{
    "Shader": {
        "info": {
            "date": "1481043098",
            "description": "Interactive seamless Poisson blending by Ruofei Du.\nDrag mouse to draw! Press 1 for imposing, press 2 for mixing gradients, press space to clear the canvas.\nChange background in Buf. A, Chnl. 2.\nRef: P. Pérez, M. Gangnet, A. Blake. Poisson Image Editing.",
            "flags": 48,
            "hasliked": 0,
            "id": "4l3Xzl",
            "likes": 18,
            "name": "Interactive Poisson Blending",
            "published": 3,
            "tags": [
                "2d",
                "interactive",
                "gradient",
                "blending",
                "poisson",
                "diffusion",
                "draw",
                "multipass",
                "mixed",
                "ruofei"
            ],
            "usePreview": 0,
            "username": "starea",
            "viewed": 5446
        },
        "renderpass": [
            {
                "code": "/** \n * Interactive Poisson Blending by Ruofei Du (DuRuofei.com)\n * Demo: https://www.shadertoy.com/view/4l3Xzl\n * Tech brief: http://blog.ruofeidu.com/interactive-poisson-blending/\n * starea @ ShaderToy,License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * https://creativecommons.org/licenses/by-nc-sa/3.0/\n * \n * Reference: \n * [1] P. Pérez, M. Gangnet, A. Blake. Poisson image editing. ACM Transactions on Graphics (SIGGRAPH'03), 22(3):313-318, 2003.\n *\n * Created 12/6/2016\n * Update 4/5/2017:\n * [1] The iteration for each pixel will automatically stop after 100 iterations of Poisson blending.\n * \n * Bugs remaining:\n * [2] Edge effect, but it's fine leaving the edge glowing\n **/\n\n// Buffer B stores the users' strokes and iteration data\n// Buffer A runs the Poisson blending algorithm\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, q);\n    fragColor.rgb *= 0.25 + 0.75 * pow( 16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.15 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/** \n * Interactive Poisson Blending by Ruofei Du (DuRuofei.com)\n * Demo: https://www.shadertoy.com/view/4l3Xzl\n * Tech brief: http://blog.ruofeidu.com/interactive-poisson-blending/\n * starea @ ShaderToy,License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * https://creativecommons.org/licenses/by-nc-sa/3.0/\n * \n * Reference: \n * [1] P. Pérez, M. Gangnet, A. Blake. Poisson image editing. ACM Transactions on Graphics (SIGGRAPH'03), 22(3):313-318, 2003.\n *\n * Created 12/6/2016\n * Update 4/5/2017:\n * [1] The iteration for each pixel will automatically stop after 100 iterations of Poisson blending.\n * \n * Bugs remaining:\n * [2] Edge effect, but it's kind'of cool right now.\n **/\n\n// the stroke and iterations mask\n// r for strokes\n// b for iterations\n#define BRUSH_SIZE 0.1\n#define INITIAL_CIRCLE_SIZE 0.4\nconst float KEY_1 = 49.5;\nconst float KEY_2 = 50.5;\nconst float KEY_SPACE = 32.5;\nconst float KEY_ALL = 256.0;\n\nbool getKeyDown(float key) {\n    return texture(iChannel1, vec2(key / KEY_ALL, 0.5)).x > 0.1;\n}\n\nbool getMouseDown() {\n    return iMouse.z > 0.0;\n}\n\nbool isInitialization() {\n\tvec2 lastResolution = texture(iChannel0, vec2(0.0) / iResolution.xy).yz; \n    return any(notEqual(lastResolution, iResolution.xy));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = 2.0 * (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tfloat mixingGradients = texture(iChannel0, vec2(1.5) / iResolution.xy).y;    \n    float frameReset = texture(iChannel0, vec2(1.5) / iResolution.xy).z;    \n    vec2 prevData = texture(iChannel0, uv).xy;\n    float mask = prevData.x;\n    float iterations = prevData.y + 0.015;\n    \n    bool resetBlending = (getKeyDown(KEY_1) && mixingGradients > 0.5) || (getKeyDown(KEY_2) && mixingGradients < 0.5); \n    \n    if (getKeyDown(KEY_1)) mixingGradients = 0.0;\n    if (getKeyDown(KEY_2)) mixingGradients = 1.0;\n\n    if (isInitialization() || getKeyDown(KEY_SPACE)) {    \n        // reset canvas\n        vec2 q = vec2(-0.7, 0.5); \n        if (distance(p, q) < INITIAL_CIRCLE_SIZE) mask = 1.0;\n        if (getKeyDown(KEY_SPACE)) mask = 0.0; \n        iterations = 0.0; \n        resetBlending = true; \n    } else \n    if (getMouseDown()) {\n        // draw on canvas\n    \tvec2 mouse = 2.0 * (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n        bool isPainted = (distance(mouse, p) < BRUSH_SIZE);\n        \n        if (isPainted) {\n            mask = 1.0; \n            iterations = 0.0; \n        };\n        frameReset = float(iFrame) - 100.0; \n    } \n    \n    if (resetBlending) iterations = 0.0; \n    \n\tif (fragCoord.x < 1.0) { \n        fragColor = vec4(mask, iResolution.xy, 1.0);  \n    } else \n    if (fragCoord.x < 2.0) { \n        if (resetBlending) frameReset = float(iFrame); \n  \t\tfragColor = vec4(mask, mixingGradients, frameReset, 1.0);  \n    } else {\n        fragColor = vec4(mask, iterations, 0.5, 1.0); \n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/** \n * Interactive Poisson Blending by Ruofei Du (DuRuofei.com)\n * Demo: https://www.shadertoy.com/view/4l3Xzl\n * Tech brief: http://blog.ruofeidu.com/interactive-poisson-blending/\n * starea @ ShaderToy,License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * https://creativecommons.org/licenses/by-nc-sa/3.0/\n * \n * Reference: \n * [1] P. Pérez, M. Gangnet, A. Blake. Poisson image editing. ACM Transactions on Graphics (SIGGRAPH'03), 22(3):313-318, 2003.\n *\n * Created 12/6/2016\n * Update 4/5/2017:\n * [1] The iteration for each pixel will automatically stop after 100 iterations of Poisson blending.\n * \n * Bugs remaining:\n * [2] Edge effect, but it's kind'of cool right now.\n **/\n\n// This is the main shader for the Poisson blending process.\n#define NUM_NEIGHBORS 4\nfloat mixingGradients; \nvec2 neighbors[NUM_NEIGHBORS];\n\n#define RES(UV) (tap(iChannel0, vec2(UV)))\n#define MASK(UV) (tap(iChannel1, vec2(UV)))\n#define BASE(UV) (tap(iChannel2, vec2(UV)))\n#define SRC(UV) (tap(iChannel3, vec2(UV)))\n#define MAX_ITERATIONS 100.0\n#define EPS 0.00001\nvec3 tap(sampler2D tex, vec2 uv) { return texture(tex, uv).rgb; }\n\nbool isInitialization() {\n    vec2 lastResolution = texture(iChannel1, vec2(0.5) / iResolution.xy).yz;   \n    return any(notEqual(lastResolution, iResolution.xy));\n}\n\nbool isMasked(vec2 uv) {\n    return texture(iChannel1, uv).x > 0.5; \n}\n\nbool isIterating(vec2 uv) {\n    return texture(iChannel1, uv).y < 1.0; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor.a = 1.0; \n    \n  \tmixingGradients = texture(iChannel1, vec2(1.5) / iResolution.xy).y;  \n  \tfloat frameReset = texture(iChannel1, vec2(1.5) / iResolution.xy).z;  \n     \n    // init: resolution does not match / current frame is black / mode changes\n    if (isInitialization() || RES(vec2(1.0)).r < EPS || float(iFrame - 2) < frameReset) {\n        fragColor.rgb = BASE(uv);\n        return; \n    }\n    \n    vec2 p = uv; \n    //if (isMasked(p) && frameReset + MAX_ITERATIONS > float(iFrame)) {\n    if (isMasked(p) && isIterating(p)) {\n        vec3 col = vec3(0.0); \n        float convergence = 0.0; \n        \n        neighbors[0] = uv + vec2(-1.0 / iChannelResolution[3].x, 0.0); \n        neighbors[1] = uv + vec2( 1.0 / iChannelResolution[3].x, 0.0); \n        neighbors[2] = uv + vec2(0.0, -1.0 / iChannelResolution[3].y); \n        neighbors[3] = uv + vec2(0.0,  1.0 / iChannelResolution[3].y);\n        \n        for (int i = 0; i < NUM_NEIGHBORS; ++i) {\n            vec2 q = neighbors[i];\n            col += isMasked(q) ? RES(q) : BASE(q);\n            vec3 srcGrad = SRC(p) - SRC(q);\n            \n            if (mixingGradients > 0.5) {\n                vec3 baseGrad = BASE(p) - BASE(q);\n                col.r += (abs(baseGrad.r) > abs(srcGrad.r)) ? baseGrad.r : srcGrad.r;\n                col.g += (abs(baseGrad.g) > abs(srcGrad.g)) ? baseGrad.g : srcGrad.g;\n                col.b += (abs(baseGrad.b) > abs(srcGrad.b)) ? baseGrad.b : srcGrad.b;\n            } else {\n                col += srcGrad;     \n            }\n        }     \n        col /= float(NUM_NEIGHBORS); \n        convergence += distance(col, RES(p)); // TODO: converge\n        fragColor.rgb = col;\n        return; \n    }\n                \n    fragColor.rgb = RES(uv); \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}