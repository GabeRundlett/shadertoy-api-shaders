{
    "Shader": {
        "info": {
            "date": "1634500563",
            "description": "Pour mes devoirs du Petit Prince dans ma classe de français. Bonjour Monsieur S! Crédit pour l'exact hexagone SDF d'IQ, et l'implémentation de OS2S par K.jpg. Je suis fier de cette shader mais il y a une bonne chance que je vais la reviser dans la future.",
            "flags": 0,
            "hasliked": 0,
            "id": "sdKXDR",
            "likes": 3,
            "name": "Ma Planete",
            "published": 3,
            "tags": [
                "raymarch",
                "planet",
                "hexagon",
                "opensimplex"
            ],
            "usePreview": 0,
            "username": "Edwy",
            "viewed": 350
        },
        "renderpass": [
            {
                "code": "mat2 getr(float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nfloat heart(vec2 p) {\n    p.x = abs(p.x);\n    p.y -= 0.35 * pow(p.x, 0.55);\n    return length(p) - 0.2;\n}\n\nfloat sdHexagon( in vec2 p, in float r ) { //IQ's 2D Hexagon SDF\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nvec3 Image(vec2 uv) {\n    vec4 starnoise = openSimplex2SDerivatives_Classical(vec3(uv.xy * 100.0, iTime / 20.0));\n\n    float s = 0.6;\n    vec2 c = vec2(0.0);\n\n    mat2 sr = getr(0.7 - iTime / 25.0);\n    mat2 pr = getr(-iTime / 5.0);\n    mat2 mr = getr(iTime / 40.0);\n\n    vec2 suv = sr * uv;\n    vec2 puv = pr * uv;\n\n    vec2 src = sr * vec2(0.5);\n\n    vec3 col = (1.0 - 0.85 * distance(src, uv)) * vec3(0.45, 0.45, 0.9);\n    col += max(1.0 - 12.0 * distance(src, uv), 0.0) * vec3(1.0, 0.6, 0.0);\n\n\n\n    vec2 rp = src;\n    for(int i = 0; i < 128; i++){\n        rp += min(sdHexagon(pr * rp, s/2.0), sdHexagon(mr * getr(1.2) * (rp - vec2(1.1, -0.25)), 0.065)) * normalize(uv - src);\n        if(min(sdHexagon(pr * rp, s/2.0), sdHexagon(mr * getr(1.2) * (rp - vec2(1.1, -0.25)), 0.065)) < 0.001 && distance(src, rp) <= distance(src, uv)){\n            col *= 0.55;\n            break;\n        }\n    }\n\n    col = max(vec3(0.0), col);\n\n    col += smoothstep(0.4, 1.0, distance(uv, src)) * vec3(1.0) * smoothstep(0.7, 1.0, starnoise[3]);\n    \n    vec4 noise = openSimplex2SDerivatives_Classical(vec3(uv.xy * 0.1, iTime / 7.5));\n    vec2 huv = getr(0.75) * (uv + vec2(1.0, -0.5)) * 2.0;\n    col += vec3(0.35, 0.0, 0.45) * (smoothstep(0.6, 1.0, distance(uv, src))) * max(0.0, step(-0.1, -heart(huv + 0.05 * normalize(noise.xy))) * sin(heart(huv + 0.05 * normalize(noise.xy)) * 6.2832 * 10.0));\n    \n    float mtime = iTime * 2.0;\n    vec4 mnoise = openSimplex2SDerivatives_Classical(vec3(uv.x * 50.0 + mtime * cos(1.2), uv.y * 50.0 + mtime * sin(1.2), 0.0));\n    vec2 muv = getr(1.2) * (uv - vec2(1.1, -0.25));\n    col += vec3(1.0, 0.8, 0.9) * min(step(0.0,  -muv.x), step(0.8, (muv.x + 0.65 - 8.0 * abs(muv.y) - mnoise[3])));\n    col += (vec3(0.0, 0.8, 0.9) - col) * min(step(0.0,  -muv.x), step(0.8, (muv.x + 0.5 - 8.0 * abs(muv.y) - mnoise[3])));\n    \n    muv = mr * muv;\n    \n    col += vec3(0.0, 0.8, 1.0) * smoothstep(0.1, 1.0, length(col)) *  step(max(abs(muv.y), dot(abs(muv), normalize(vec2(1.7321, 1.0)))), 0.08);\n    col = max(col, step(max(abs(muv.y), dot(abs(muv), normalize(vec2(1.7321, 1.0)))), 0.065));\n    \n    \n    col += vec3(0.0, 1.0, 0.0) * smoothstep(0.1, 1.0, length(col)) *  step(max(abs(puv.y), dot(abs(puv), normalize(vec2(1.7321, 1.0)))), (s + 0.007) / 2.0);\n    col *= 1.0 - step(max(abs(puv.y), dot(abs(puv), normalize(vec2(1.7321, 1.0)))), s / 2.0);\n\n    return col;\n}\n\nMAIN_FUNCTION(Image)",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const int aa = 2;\n\n#define MAIN_FUNCTION(function) \\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\\\n{\\\n    vec3 total = vec3(.0);\\\n    for(int i = 0; i <aa;i++)\\\n    for(int j = 0; j <aa;j++)\\\n    {\\\n    \tvec2 uv = ((fragCoord+vec2(float(i),float(j))/float(aa)-.5)/iResolution.xy - vec2(.5)) * 1.5;\\\n    \tuv.x *= iResolution.x/iResolution.y;\\\n        total+= function(uv);\\\n    }\\\n    total /= float(aa*aa);\\\n    fragColor = vec4(total, 1.0);\\\n}\n\n/////////////// K.jpg's Re-oriented 8-Point BCC Noise (OpenSimplex2S) ////////////////\n////////////////////// Output: vec4(dF/dx, dF/dy, dF/dz, value) //////////////////////\n\n// Borrowed from Stefan Gustavson's noise code\nvec4 permute(vec4 t) {\n    return t * (t * 34.0 + 133.0);\n}\n\n// Gradient set is a normalized expanded rhombic dodecahedron\nvec3 grad(float hash) {\n    \n    // Random vertex of a cube, +/- 1 each\n    vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0;\n    \n    // Random edge of the three edges connected to that vertex\n    // Also a cuboctahedral vertex\n    // And corresponds to the face of its dual, the rhombic dodecahedron\n    vec3 cuboct = cube;\n    cuboct[int(hash / 16.0)] = 0.0;\n    \n    // In a funky way, pick one of the four points on the rhombic face\n    float type = mod(floor(hash / 8.0), 2.0);\n    vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));\n    \n    // Expand it so that the new edges are the same length\n    // as the existing ones\n    vec3 grad = cuboct * 1.22474487139 + rhomb;\n    \n    // To make all gradients the same length, we only need to shorten the\n    // second type of vector. We also put in the whole noise scale constant.\n    // The compiler should reduce it into the existing floats. I think.\n    grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;\n    \n    return grad;\n}\n\n// BCC lattice split up into 2 cube lattices\nvec4 openSimplex2SDerivativesPart(vec3 X) {\n    vec3 b = floor(X);\n    vec4 i4 = vec4(X - b, 2.5);\n    \n    // Pick between each pair of oppposite corners in the cube.\n    vec3 v1 = b + floor(dot(i4, vec4(.25)));\n    vec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35)));\n    vec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35)));\n    vec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35)));\n    \n    // Gradient hashes for the four vertices in this half-lattice.\n    vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));\n    hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));\n    hashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0);\n    \n    // Gradient extrapolations & kernel function\n    vec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4;\n    vec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0);\n    vec4 aa = a * a; vec4 aaaa = aa * aa;\n    vec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y);\n    vec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w);\n    vec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4));\n    \n    // Derivatives of the noise\n    vec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations)\n        + mat4x3(g1, g2, g3, g4) * aaaa;\n    \n    // Return it all as a vec4\n    return vec4(derivative, dot(aaaa, extrapolations));\n}\n\n// Rotates domain, but preserve shape. Hides grid better in cardinal slices.\n// Good for texturing 3D objects with lots of flat parts along cardinal planes.\nvec4 openSimplex2SDerivatives_Classical(vec3 X) {\n    X = dot(X, vec3(2.0/3.0)) - X;\n    \n    vec4 result = openSimplex2SDerivativesPart(X) + openSimplex2SDerivativesPart(X + 144.5);\n    \n    return vec4(dot(result.xyz, vec3(2.0/3.0)) - result.xyz, result.w);\n}\n\n//////////////////////////////// End noise code ////////////////////////////////",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}