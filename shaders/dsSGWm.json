{
    "Shader": {
        "info": {
            "date": "1667676923",
            "description": "My recreation of the deleted \"Hall of Mirrors\" effect by Red Giant, one of my favourite effects. Click to drag offset position.",
            "flags": 0,
            "hasliked": 0,
            "id": "dsSGWm",
            "likes": 10,
            "name": "Hall of Mirrors",
            "published": 3,
            "tags": [
                "mirror",
                "redgiant",
                "aftereffects",
                "hallofmirrors",
                "plugin",
                "obsolete"
            ],
            "usePreview": 1,
            "username": "MysteryPancake",
            "viewed": 678
        },
        "renderpass": [
            {
                "code": "// Faithful remake of the deleted \"Hall of Mirrors\" effect by Red Giant\n// Recreated by MysteryPancake\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Number of images to display\n\tint images = 33;\n\t// Scale factor per image\n\tfloat scale = 0.9 + cos(iTime * 2.0) * 0.1;\n\t// Rotation per image in degrees\n\tfloat rotation = sin(iTime * 0.5) * 45.0;\n\t// Position offset per image in normalized coordinates (0-1)\n\tvec2 offset = iMouse.z > 0.0 ? vec2(iMouse.xy / iResolution.xy) : 0.5 + vec2(cos(iTime), sin(iTime)) * 0.5;\n\t// Composite behind or in front\n\tbool behind = false;\n\n\tfloat rad = radians(-rotation);\n\tvec2 uv = fragCoord / iResolution.xy;\n\tfragColor = vec4(0.0);\n\n\tfor (int i = 0; i < images; ++i) {\n\t\t// SCALING: Offset, apply scale, reset offset\n\t\tvec2 pos = uv - offset;\n\t\tpos /= pow(scale, float(i));\n\t\tpos += offset;\n\n\t\t// ROTATION\n\t\tfloat theta = rad * float(i);\n\t\tfloat cs = cos(theta);\n\t\tfloat sn = sin(theta);\n\t\t// Offset to center, fix aspect ratio\n\t\tpos -= vec2(0.5);\n\t\tpos *= iResolution.xy;\n\t\t// Rotate coordinate space\n\t\tpos = vec2(pos.x * cs - pos.y * sn, pos.x * sn + pos.y * cs);\n\t\t// Reset aspect ratio, reset offset\n\t\tpos /= iResolution.xy;\n\t\tpos += vec2(0.5);\n\n\t\t// Prevent out of bounds bugs, could also be done with clamp\n\t\tif (pos.x >= 0.0 && pos.x <= 1.0 && pos.y >= 0.0 && pos.y <= 1.0) {\n\t\t\tvec4 color = texture(iChannel0, pos);\n            // Alpha blending, see shadertoy.com/view/msSGDm for working example\n\t\t\tif (behind) {\n\t\t\t\tfragColor += (1.0 - fragColor.a) * color;\n\t\t\t} else {\n\t\t\t\tfragColor = color + (1.0 - color.a) * fragColor;\n\t\t\t}\n\t\t}\n\t}\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}