{
    "Shader": {
        "info": {
            "date": "1611851560",
            "description": "Really simple path tracing for this neural SDF thing",
            "flags": 32,
            "hasliked": 0,
            "id": "3lyyWc",
            "likes": 33,
            "name": "Path Traced Neural Bunny",
            "published": 3,
            "tags": [
                "pathtracing",
                "bunny"
            ],
            "usePreview": 1,
            "username": "michael0884",
            "viewed": 1068
        },
        "renderpass": [
            {
                "code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = texture(iChannel0, fragCoord/iResolution.xy); \n    fragColor = tanh(2.5*col/col.w);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MAX_STEPS 128\n#define MIN_DIST 1e-5\n#define MAX_DIST 8.0\n#define CAM_ANGLE 1e-3\n#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n\n//internal RNG state \nuvec4 s0; \n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nfloat rand()\n{\n    pcg4d(s0); return float(s0.x)/float(0xffffffffu);\n}\n\nvec2 rand2()\n{\n    pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);\n}\n\nvec4 rand4()\n{\n    pcg4d(s0); return vec4(s0)/float(0xffffffffu);\n}\n\nvec3 nrand3(float sigma, vec3 mean)\n{\n\tvec4 Z = rand4();\n    return mean + sigma * sqrt(-2.0 * log(Z.xxy)) * \n           vec3(cos(TWO_PI * Z.z),sin(TWO_PI * Z.z),cos(TWO_PI * Z.w));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat bunny(vec3 p) {\n    //sdf is undefined outside the unit sphere, uncomment to witness the abominations\n    if (length(p) > 1.) {\n        return (length(p)-0.9);\n    }\n    //neural networks can be really compact... when they want to be\n    vec4 f00=sin(p.y*vec4(-3.02,1.95,-3.42,-.60)+p.z*vec4(3.08,.85,-2.25,-.24)-p.x*vec4(-.29,1.16,-3.74,2.89)+vec4(-.71,4.50,-3.24,-3.50));\n    vec4 f01=sin(p.y*vec4(-.40,-3.61,3.23,-.14)+p.z*vec4(-.36,3.64,-3.91,2.66)-p.x*vec4(2.90,-.54,-2.75,2.71)+vec4(7.02,-5.41,-1.12,-7.41));\n    vec4 f02=sin(p.y*vec4(-1.77,-1.28,-4.29,-3.20)+p.z*vec4(-3.49,-2.81,-.64,2.79)-p.x*vec4(3.15,2.14,-3.85,1.83)+vec4(-2.07,4.49,5.33,-2.17));\n    vec4 f03=sin(p.y*vec4(-.49,.68,3.05,.42)+p.z*vec4(-2.87,.78,3.78,-3.41)-p.x*vec4(-2.65,.33,.07,-.64)+vec4(-3.24,-5.90,1.14,-4.71));\n    vec4 f10=sin(mat4(-.34,.06,-.59,-.76,.10,-.19,-.12,.44,.64,-.02,-.26,.15,-.16,.21,.91,.15)*f00+\n        mat4(.01,.54,-.77,.11,.06,-.14,.43,.51,-.18,.08,.39,.20,.33,-.49,-.10,.19)*f01+\n        mat4(.27,.22,.43,.53,.18,-.17,.23,-.64,-.14,.02,-.10,.16,-.13,-.06,-.04,-.36)*f02+\n        mat4(-.13,.29,-.29,.08,1.13,.02,-.83,.32,-.32,.04,-.31,-.16,.14,-.03,-.20,.39)*f03+\n        vec4(.73,-4.28,-1.56,-1.80))/1.0+f00;\n    vec4 f11=sin(mat4(-1.11,.55,-.12,-1.00,.16,.15,-.30,.31,-.01,.01,.31,-.42,-.29,.38,-.04,.71)*f00+\n        mat4(.96,-.02,.86,.52,-.14,.60,.44,.43,.02,-.15,-.49,-.05,-.06,-.25,-.03,-.22)*f01+\n        mat4(.52,.44,-.05,-.11,-.56,-.10,-.61,-.40,-.04,.55,.32,-.07,-.02,.28,.26,-.49)*f02+\n        mat4(.02,-.32,.06,-.17,-.59,.00,-.24,.60,-.06,.13,-.21,-.27,-.12,-.14,.58,-.55)*f03+\n        vec4(-2.24,-3.48,-.80,1.41))/1.0+f01;\n    vec4 f12=sin(mat4(.44,-.06,-.79,-.46,.05,-.60,.30,.36,.35,.12,.02,.12,.40,-.26,.63,-.21)*f00+\n        mat4(-.48,.43,-.73,-.40,.11,-.01,.71,.05,-.25,.25,-.28,-.20,.32,-.02,-.84,.16)*f01+\n        mat4(.39,-.07,.90,.36,-.38,-.27,-1.86,-.39,.48,-.20,-.05,.10,-.00,-.21,.29,.63)*f02+\n        mat4(.46,-.32,.06,.09,.72,-.47,.81,.78,.90,.02,-.21,.08,-.16,.22,.32,-.13)*f03+\n        vec4(3.38,1.20,.84,1.41))/1.0+f02;\n    vec4 f13=sin(mat4(-.41,-.24,-.71,-.25,-.24,-.75,-.09,.02,-.27,-.42,.02,.03,-.01,.51,-.12,-1.24)*f00+\n        mat4(.64,.31,-1.36,.61,-.34,.11,.14,.79,.22,-.16,-.29,-.70,.02,-.37,.49,.39)*f01+\n        mat4(.79,.47,.54,-.47,-1.13,-.35,-1.03,-.22,-.67,-.26,.10,.21,-.07,-.73,-.11,.72)*f02+\n        mat4(.43,-.23,.13,.09,1.38,-.63,1.57,-.20,.39,-.14,.42,.13,-.57,-.08,-.21,.21)*f03+\n        vec4(-.34,-3.28,.43,-.52))/1.0+f03;\n    f00=sin(mat4(-.72,.23,-.89,.52,.38,.19,-.16,-.88,.26,-.37,.09,.63,.29,-.72,.30,-.95)*f10+\n        mat4(-.22,-.51,-.42,-.73,-.32,.00,-1.03,1.17,-.20,-.03,-.13,-.16,-.41,.09,.36,-.84)*f11+\n        mat4(-.21,.01,.33,.47,.05,.20,-.44,-1.04,.13,.12,-.13,.31,.01,-.34,.41,-.34)*f12+\n        mat4(-.13,-.06,-.39,-.22,.48,.25,.24,-.97,-.34,.14,.42,-.00,-.44,.05,.09,-.95)*f13+\n        vec4(.48,.87,-.87,-2.06))/1.4+f10;\n    f01=sin(mat4(-.27,.29,-.21,.15,.34,-.23,.85,-.09,-1.15,-.24,-.05,-.25,-.12,-.73,-.17,-.37)*f10+\n        mat4(-1.11,.35,-.93,-.06,-.79,-.03,-.46,-.37,.60,-.37,-.14,.45,-.03,-.21,.02,.59)*f11+\n        mat4(-.92,-.17,-.58,-.18,.58,.60,.83,-1.04,-.80,-.16,.23,-.11,.08,.16,.76,.61)*f12+\n        mat4(.29,.45,.30,.39,-.91,.66,-.35,-.35,.21,.16,-.54,-.63,1.10,-.38,.20,.15)*f13+\n        vec4(-1.72,-.14,1.92,2.08))/1.4+f11;\n    f02=sin(mat4(1.00,.66,1.30,-.51,.88,.25,-.67,.03,-.68,-.08,-.12,-.14,.46,1.15,.38,-.10)*f10+\n        mat4(.51,-.57,.41,-.09,.68,-.50,-.04,-1.01,.20,.44,-.60,.46,-.09,-.37,-1.30,.04)*f11+\n        mat4(.14,.29,-.45,-.06,-.65,.33,-.37,-.95,.71,-.07,1.00,-.60,-1.68,-.20,-.00,-.70)*f12+\n        mat4(-.31,.69,.56,.13,.95,.36,.56,.59,-.63,.52,-.30,.17,1.23,.72,.95,.75)*f13+\n        vec4(-.90,-3.26,-.44,-3.11))/1.4+f12;\n    f03=sin(mat4(.51,-.98,-.28,.16,-.22,-.17,-1.03,.22,.70,-.15,.12,.43,.78,.67,-.85,-.25)*f10+\n        mat4(.81,.60,-.89,.61,-1.03,-.33,.60,-.11,-.06,.01,-.02,-.44,.73,.69,1.02,.62)*f11+\n        mat4(-.10,.52,.80,-.65,.40,-.75,.47,1.56,.03,.05,.08,.31,-.03,.22,-1.63,.07)*f12+\n        mat4(-.18,-.07,-1.22,.48,-.01,.56,.07,.15,.24,.25,-.09,-.54,.23,-.08,.20,.36)*f13+\n        vec4(-1.11,-4.28,1.02,-.23))/1.4+f13;\n    float o = dot(f00,vec4(.09,.12,-.07,-.03))+dot(f01,vec4(-.04,.07,-.08,.05))+\n        dot(f02,vec4(-.01,.06,-.02,.07))+dot(f03,vec4(-.05,.07,.03,.04))-0.16;\n    return o*0.85; //its a nonperfect sdf\n}\n\nvec2 opUnion(vec2 a, vec2 b)\n{\n    return (a.x < b.x)?a:b;\n}\n\nvec2 scene(vec3 p)\n{\n    vec2 plane = vec2(p.z + 0.5, 0);\n    vec2 bunnys = vec2(bunny(p), 1);\n    return opUnion(bunnys, plane);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p).x - vec3(scene(k[0]).x,scene(k[1]).x,scene(k[2]).x));\n}\n\nfloat trace(inout vec4 ro, vec3 rd)\n{\n    vec2 de = vec2(-1);\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        de = scene(ro.xyz); \n        float md = max(CAM_ANGLE*ro.w,MIN_DIST);\n        ro += vec4(rd, 1.0)*(de.x - 2.0*step(de.x, md)*md); \n        if(de.x < md) return de.y;\n        if(ro.w > MAX_DIST) return -1.0;\n    }\n    return de.y;\n}\n\nvec3 pathtrace(vec4 ro, vec3 rd)\n{\n    vec3 outcol = vec3(0.); vec3 matcol = vec3(1.);\n    for(int i = 0; i<4; i++)\n    {\n        float hit = trace(ro, rd);\n        if(hit>=0.0)\n        {\n            vec3 n = norm(ro.xyz); //geometric normal\n            vec3 s = sin(100.*erot(ro.xyz, vec3(1), 3.2)) + sin(150.*erot(ro.xyz, vec3(0,1,0.5), 1.2));\n            \n            float roughness =(rand()>0.5)?0.5:0.05;\n            if(hit == 0.0)\n            {\n                bool tile =mod(ro.x, 1.0) + mod(ro.y, 1.0) > 1.0;\n                matcol *= tile?vec3(0.780,0.678,0.678):vec3(1.000,1.000,1.000); \n            }\n            else\n            {\n                matcol *= vec3(0.804,0.914,0.996);\n            }\n            vec3 m = normalize(nrand3(roughness, n) + 0.1*hit*s); //material normal\n            rd = reflect(rd,m);\n        }\n        else\n        {\n            outcol += matcol*pow(texture(iChannel1, rd.xzy).xyz,vec3(2.0));\n            break;\n        }\n    }\n    return outcol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //RNG\n    s0 = uvec4(fragCoord, uint(iFrame), uint(fragCoord.x) + uint(fragCoord.y));\n\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    fragCoord += rand2();\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-3.,0,0);\n    \n    float yrot = 0.5 - 0.5*mouse.y;\n    float zrot = 4.0*mouse.x;\n    if (iMouse.z > 0.) {\n        fragColor *= 0.0;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    \n    init = erot(init, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    fragColor += vec4(pathtrace(vec4(init, 0.), cam), 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}