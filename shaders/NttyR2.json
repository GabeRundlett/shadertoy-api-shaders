{
    "Shader": {
        "info": {
            "date": "1660145597",
            "description": "Smoothstep your barycentric coordinates!",
            "flags": 0,
            "hasliked": 0,
            "id": "NttyR2",
            "likes": 0,
            "name": "Barycentric Smoothstep",
            "published": 3,
            "tags": [
                "barycentriccoordinatestriangle"
            ],
            "usePreview": 0,
            "username": "Bloodwyn",
            "viewed": 331
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n\n// Rotate point.\nvec2 rotate (vec2 p, float r)\n{\n    r *= PI / 180.0;\n    float x = p.x * cos(r) - p.y * sin(r);\n    float y = p.y * cos(r) + p.x * sin(r);\n    return vec2(x, y);\n}\n\n// Draw point\nbool point (vec2 a, vec2 p)\n{\n    return length(a - p) < 0.01;\n}\n\n// Draw line from a to b.\nbool line (vec2 a, vec2 b, vec2 p)\n{\n    vec2 c = b - a;\n    c = normalize(vec2(c.y, -c.x));\n    return abs(dot(c, a - p)) < 0.002;\n}\n\n// Find intersection between vectors a and b by projecting a onto b.\nvec2 projection (vec2 a, vec2 b)\n{\n    b = normalize(b);\n    return b * (b.x * a.x + b.y * a.y);\n}\n\nbool tri (vec2 a, vec2 b, vec2 c, vec2 p, out vec3 color)\n{\n    vec2 ab = b - a;\n    vec2 cb = b - c;\n    vec2 ca = a - c;\n    vec2 ac = c - a;\n    vec2 ba = a - b;\n    vec2 bc = c - b;\n    \n    // Projection of a onto c -> b\n    vec2 ai = c + projection(ca, cb);\n    \n    // Projection of test point onto ai -> a\n    vec2 pai = a + projection(p - ai, a - ai);\n    \n    float percentA = length(pai - a) / length(ai - a) * sign(dot(p - ai, a - ai));\n    \n    // Projection of b onto c -> b\n    vec2 bi = a + projection(ab, ac);\n    \n    // Projection of test point onto bi -> b\n    vec2 pbi = b + projection(p - bi, b - bi);\n    \n    float percentB = length(pbi - b) / length(bi - b) * sign(dot(p - bi, b - bi));\n    \n    // Projection of b onto c -> b\n    vec2 ci = b + projection(bc, ba);\n    \n    // Projection of test point onto ci -> c\n    vec2 pci = c + projection(p - ci, c - ci);\n    \n    float percentC = length(pci - c) / length(ci - c) * sign(dot(p - ci, c - ci));\n    \n    color = vec3(percentA, percentB, percentC);\n    \n    if (percentA > 0.0 && percentA < 1.0 && percentB > 0.0 && percentB < 1.0 && percentC > 0.0 && percentC < 1.0)\n        return true;\n    \n    return false;\n}\n\nint pascalTriangle(int a, int b) {\n    int num = 1;\n    int den = 1;\n    for (int i = 0; i < b; ++i){\n        num *= (a - i);\n        den *= (i + 1);\n     }\n    return num/den;\n}\n\nfloat gsmoothstep(float x, int N) {\n    x = clamp(x, 0., 1.);\n    float result = 0.;\n    for (int n = 0; n <= N; ++n){\n        result += float(pascalTriangle(-N - 1, n) *\n        pascalTriangle(2 * N + 1, N - n)) *\n        pow(x, float(N + n + 1));\n    }\n    return result;\n}\n\nvec3 barySmoothstep(vec3 bary, int order){\n    float sum = 0.;\n    for (int i = 0; i < 3; i++) {\n        bary[i] = gsmoothstep(bary[i], order);\n        sum += bary[i];\n    }    \n    return bary / sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ws = uv.xy * 2.0 - 1.0;\n    ws.y /= iResolution.x / iResolution.y;\n    \n    vec3 color = vec3(0.0);\n    \n    vec2 a = vec2(0.0, 0.25);\n    vec2 b = vec2(0.25, -0.25);\n    vec2 c = vec2(-0.25, -0.25);\n    \n    vec3 triUV;\n    if (tri(a, b, c, rotate(ws, iTime * 10.0), triUV))\n        color = triUV;\n    \n\tfragColor = vec4(barySmoothstep(color, int(iTime)),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}