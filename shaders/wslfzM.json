{
    "Shader": {
        "info": {
            "date": "1587948542",
            "description": "I'm Developing a Pyramid Complex",
            "flags": 8,
            "hasliked": 0,
            "id": "wslfzM",
            "likes": 21,
            "name": "I'm Developing a ...",
            "published": 3,
            "tags": [
                "fractal",
                "music",
                "pyramid"
            ],
            "usePreview": 0,
            "username": "eiffie",
            "viewed": 537
        },
        "renderpass": [
            {
                "code": "//I'm Developing a Pyramid Complex - by eiffie\nfloat nois(vec2 v){// based on 2d noise by Trisomie21\n  vec4 h=fract(sin(vec4(floor(v.x)+floor(v.y)*100.)+vec4(0.,1.,100.,101.))*100.);\n  v=smoothstep(0.,1.,fract(v));return mix(mix(h.x,h.y,v.x),mix(h.z,h.w,v.x),v.y);\n}\nfloat bxLength(vec2 p){p=abs(p);return max(p.x,p.y);}\nfloat wav(float a){return abs(fract(a)-0.5);}\nfloat brick(vec2 p){\n  p.y+=0.5;//if(mod(p.y+0.5,2.0)<1.)p.x+=1.0;//i've turned all the pyrs to 45 deg\n  return min(wav(p.x*0.45)*wav(p.y),0.07);   //so no need to offset brick pattern\n}\nvec3 mcol=vec3(0.0);float detail=0.0;\nfloat DE(vec3 p0){\n  if(detail>0.0){\n    p0.y+=0.00025*nois(p0.xz*1000.0)*detail;\n    p0.y-=abs(sin(p0.y*1000.0))*0.001*detail; \n  }\n  vec2 p=p0.xz;\n  float d=bxLength(p)-0.25+p0.y,ts=1.0,s=1.936,id=1.,sid=1.;\n  for(int i=0;i<6;i++){\n    p=(abs(vec2(p.x-p.y,p.y+p.x)*0.707)-0.6)*s;ts*=s;\n    float d2=max(((bxLength(p)-0.25)/ts+p0.y)*.5,p0.y-0.235/ts);\n    if(d2<d){sid=id;d=d2;}id=-id;\n  }\n  float y=p0.y;\n  if(detail>0.0){\n    y+=0.0025*sin(p0.x*100.0+sin(p0.z*50.0))*detail;\n    y+=0.00025*sin(y*100.0+sin(p0.x*400.0+sin(p0.z*200.0)))*detail;\n    if(sid<0.)p0.x+=p0.z;//turn axis aligned pyrs 45 deg\n    d-=brick(p0.xy*318.3)*0.005*detail;\n  }\n  mcol=vec3(0.6,(d<y?0.5:0.2),0.);\n  return min(d,y)*0.5;\n}\nvec3 sky(vec3 rd, vec3 L){//modified bananaft's & public_int_i's code\n  float d=0.4*dot(rd,L)+0.6;\n  if(rd.y<0.0)return vec3(0.28,0.17,0.07)*dot(vec3(rd.x,-rd.y,rd.z),L);\n  float y=max(0.,L.y),sun=max(1.-(1.+10.*y+rd.y)*length(rd-L),0.)\n    +.3*pow(1.-rd.y,12.)*(1.6-y);\n  return d*mix(vec3(0.3984,0.5117,0.7305),vec3(0.7031,0.4687,0.1055),sun)\n    *((.5+pow(y,.4))*(1.5-abs(L.y))+pow(sun,5.2)*y*(5.+15.0*y));\n}\nfloat rnd;\nvoid randomize(in vec2 p){rnd=fract(float(iFrame)+sin(dot(p,vec2(13.3145,117.7391)))*42317.7654321);}\n\nvec3 scene(vec3 ro, vec3 rd){\n  vec3 L=normalize(vec3(0.4,0.025,0.5));\n  vec3 bcol=sky(rd,L);\n  vec4 col=vec4(0.0);//color accumulator\n  float t=DE(ro)*rnd,d,od=1.0,px=1.0/iResolution.x;ro+=t*rd;\n  for(int i=0;i<256;i++){\n    detail=max(1.0-t*2.0,0.0);\n    d=DE(ro);\n    float soc=px*t*max(20.-750.*t,1.0);\n    if(d<soc){\n      vec3 scol=mcol;\n      float d3=DE(ro+d*16.0*L),d2=DE(ro+d*2.0*L);\n      float vis=clamp(1.0-d/od,0.0,1.0);\n      float dif=clamp(0.3*d2/d,0.0,1.0);\n      float ld=dot(rd,L);\n      float spec=ld<0.0?-ld*vis:ld*(1.0-vis);\n      float shad=clamp(0.03125*d3/d,0.0,1.0);\n      if(detail>0.0)\n        scol+=(vec3(nois(ro.xz*2500.0))+vec3(1.0,0.5,0.0)*nois((ro.zx+(mcol.g==0.5?2.0:.2)*ro.yy)*7000.0))*detail;\n      scol=(scol*dif+vec3(vis)+vec3(1.0,0.9,0.6)*spec)*shad*5.0;\n      float alpha=(1.0-col.w)*clamp(1.0-d/soc,0.0,1.0);if(alpha>0.89)alpha=1.0;\n      col+=vec4(clamp(scol,0.0,1.0),1.0)*alpha;\n      if(col.w>0.9)break;\n    }\n    t+=d;od=d;ro+=rd*d;\n    if(t>3.0)break;\n  }\n  col.rgb+=bcol*(1.0-clamp(col.w,0.0,1.0));\n  return col.rgb;\n}\nmat3 lookat(vec3 fw){vec3 up=vec3(0.0,1.0,0.0),rt=-normalize(cross(fw,up));return mat3(rt,normalize(cross(rt,fw)),fw);}\nvec3 path(float a){\n  a=mod(a,1.25);\n  vec3 v=vec3(cos(a),0.01,sin(a*1.2))*(1.3-a);\n  float d=DE(v);\n  v.y-=d*1.5;v.y+=0.01+abs(sin(a*100.0))*0.001+pow(a,10.0)*0.4;\n  return v;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n randomize(fragCoord);\n float a=iTime*0.01+sin(iTime*0.1)*0.1;\n vec3 cam = path(a);a+=3.0+sin(iTime*0.3);\n if(DE(cam)<0.0){fragColor=vec4(0.0);return;}\n vec3 fw=normalize(vec3(cos(a),cos(a*0.7)*0.025,sin(a))*1.25-cam);\n vec3 rd = lookat(fw)*normalize(vec3((iResolution.xy-2.0*fragCoord)/iResolution.y,2.0));\n fragColor = vec4(scene(cam,rd),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define bps 7.0 \nfloat rnd(float t){return fract(sin(mod(t,32.123)*32.123)*41.123);} \nvec2 nofs(float n){//the song's \"random\" ring \n  float r=0.5+0.5*rnd(floor(n));//random volume as well \n  n=mod(n,8.0); \n  if(n<1.0)n= 0.0; \n  else if(n<2.0)n= 2.0; \n  else if(n<3.0)n= 4.0; \n  else if(n<4.0)n= 5.0; \n  else if(n<5.0)n= 2.0; \n  else if(n<6.0)n= 0.0; \n  else if(n<7.0)n= -2.0; \n  else n=1.0; \n  return vec2(n,r); \n} \nfloat scale(float note){//throws out dissonant tones \n float n2=mod(note,12.); \n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//major \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//minor \n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100;//pentatonic minor \n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100.;//blues  \n //if((n2==1.)||(n2==2.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//country \n //if((n2==1.)||(n2==4.)||(n2==7.)||(n2==10.))note=-100.;//diminished whole/half \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//pentatonic major \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//harmonic minor \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//melodic minor ascending \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//whole tone \n //if((n2==2.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//diminished half/whole \n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//mixolydian   \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//dorian \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==10.))note=-100.;//lydian   \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian \n if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian Major \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//locrian \n //if((n2==2.)||(n2==4.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//lydian dominant \n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//double harmonic \n //if((n2==2.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.))note=-100.;//enigmatic \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//neapolitan  \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//neapolitan minor \n //if((n2==1.)||(n2==4.)||(n2==5.)||(n2==9.)||(n2==10.))note=-100.;//hungarian minor \n return note; \n} \n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2 \nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 12.0):0.0;} \nconst float PI=3.14159; \nfloat Cos(float a){return cos(mod(a,PI*2.));} \nfloat Sin(float a){return Cos(a+PI/2.);} \nstruct instr{float att,fo,vibe,vphas,phas,dtun;}; \nvec2 I(float n,float t,float bt,instr i){//note,time,bt 0-8,instrument \n float f=ntof(scale(n));if(f<12.)return vec2(0.0);f-=bt*i.dtun;f*=t*PI*2.; \n f=exp(-bt*i.fo)*(1.0-exp(-bt*i.att))*Sin(f+Cos(bt*i.vibe*PI/8.+i.vphas*PI/2.)*Sin(f*i.phas))*(1.0-bt*0.125); \n n+=t;return vec2(f*Sin(n),f*Cos(n)); \n} \nvec2 mainSound( in int samp,float time){//att,fo,vibe,vphs,phs,dtun\n instr epiano=instr(20.0,0.05,1.5,0.1,0.505,0.001);//silly fm synth instruments \n instr sitar=instr(100.0,0.25,4.0,0.0,0.2525,0.0025); \n instr bassdrum=instr(500.0,1.0,4.0,0.75,1.0,0.0125); \n instr stick=instr(100.0,30.0,10.5,0.0,2.3131,1000.0); \n instr pluckbass=instr(500.0,2.0,1.5,0.0,0.25,0.005); \n instr bass=instr(20.0,0.2,1.5,0.0,0.2525,0.005); \n float tim=time*bps,b0,b1,b2,t0,t1,t2; \n vec2 a=vec2(0);//accumulator \n for(float i=0.;i<8.;i+=1.){//go back 8 beats and add note tails \n   b0=floor(tim);b1=floor(tim*0.5);b2=floor(tim*0.25); \n   vec2 n2=nofs(b2*0.125)+nofs(b2*0.5)+nofs(b2);//build notes on top of notes like fbm \n   vec2 n1=n2+nofs(b1),n0=n1+nofs(b0); \n   t0=fract(tim)+i; \n   a+=I(n0.x+72.0,time,t0,sitar)*n0.y*0.25;\n   if(mod(i,3.)<1.)a+=I(n0.x+93.0,time+Sin(t0*272.0),t0,stick)*n0.y*0.3;  \n   if(mod(i,2.)<1.){//notes that play every 2 beats \n     t1=fract(tim*0.5)*2.0+i; \n     a+=I(n1.x+56.0,time,t1,epiano)*n1.y; \n     a+=I(n1.x+60.0,time,t1,epiano)*n1.y; \n     a+=I(n1.x+63.0,time,t1,pluckbass)*n1.y;\n     if(mod(i,4.)<1.){//every 4 \n       t2=fract(tim*0.25)*4.0+i;\n       \n       a+=I(n2.x+44.0,time,t2,bass)*n2.y*4.0; \n       a+=I(n2.x+24.0,time+0.008*sin(t2*15.0),t2,bassdrum)*n2.y*4.0; \n     } \n   } \n   tim-=1.;//go back in time to find old notes still decaying \n } \n return clamp(a/24.0,-1.,1.); \n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}