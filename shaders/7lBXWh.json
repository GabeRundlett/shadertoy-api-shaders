{
    "Shader": {
        "info": {
            "date": "1628099930",
            "description": "Still a work in progress.\nMy attempt at making some cool japanese torii gates.\nI wanted to improve my skills at making water and reflections.\nI need to figure out how to make the sky and lighting better. Those r still weak points for me.",
            "flags": 0,
            "hasliked": 0,
            "id": "7lBXWh",
            "likes": 8,
            "name": "Torii Gate In Water",
            "published": 3,
            "tags": [
                "water",
                "ocean",
                "japan",
                "gate",
                "tori"
            ],
            "usePreview": 0,
            "username": "intrakits",
            "viewed": 293
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 200\n#define MAX_DIST 200.\n#define SURFACE_DIST 0.01\n#define AA 1\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat voronoise( in vec2 p, float u, float v )\n{\n\tfloat k = 1.0+63.0*pow(1.0-v,6.0);\n\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n\tvec2 a = vec2(0.0,0.0);\n    for( int y=-2; y<=2; y++ )\n    for( int x=-2; x<=2; x++ )\n    {\n        vec2  g = vec2( x, y );\n\t\tvec3  o = hash3( i + g )*vec3(u,u,1.0);\n\t\tvec2  d = g - f + o.xy;\n\t\tfloat w = pow( 1.0-smoothstep(0.0,1.414,length(d)), k );\n\t\ta += vec2(o.z*w,w);\n    }\n\t\n    return a.x/a.y;\n}\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nvec2 rand2(vec2 p)\n{\n\tvec2 q = vec2(dot(p,vec2(127.1,311.7)), \n\t\tdot(p,vec2(269.5,183.3)));\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat rand(vec2 p)\n{\n\treturn fract(sin(dot(p,vec2(419.2,371.9))) * 833458.57832);\n}\n\nfloat iqnoise(in vec2 pos, float irregular, float smoothness)\n{\n\tvec2 cell = floor(pos);\n\tvec2 cellOffset = fract(pos);\n\n\tfloat sharpness = 1.0 + 63.0 * pow(1.0-smoothness, 4.0);\n\t\n\tfloat value = 0.0;\n\tfloat accum = 0.0;\n\t// Sample the surrounding cells, from -2 to +2\n\t// This is necessary for the smoothing as well as the irregular grid.\n\tfor(int x=-2; x<=2; x++ )\n\tfor(int y=-2; y<=2; y++ )\n\t{\n\t\tvec2 samplePos = vec2(float(y), float(x));\n\n  \t\t// Center of the cell is not at the center of the block for irregular noise.\n  \t\t// Note that all the coordinates are in \"block\"-space, 0 is the current block, 1 is one block further, etc\n\t\tvec2 center = rand2(cell + samplePos) * irregular;\n\t\tfloat centerDistance = length(samplePos - cellOffset + center);\n\n\t\t// High sharpness = Only extreme values = Hard borders = 64\n\t\t// Low sharpness = No extreme values = Soft borders = 1\n\t\tfloat sam = pow(1.0 - smoothstep(0.0, 1.414, centerDistance), sharpness);\n\n\t\t// A different \"color\" (shade of gray) for each cell\n\t\tfloat color = rand(cell + samplePos);\n\t\tvalue += color * sam;\n\t\taccum += sam;\n\t}\n\n\treturn value/accum;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    //line from a to b\n    vec3 ab = b-a;\n    \n    // line from p to a\n    vec3 ap = p-a;\n    \n    // as p approaches a, it will be 1\n    // as p approaches b it will b 0\n    float t = dot(ab,ap) / dot(ab,ab);\n    \n    // clamp values between 0 and 1\n    t= clamp(t,0.,1.);\n    \n    // center point of the capsule\n    // start at a (top of capsule)\n    // go towards b, t steps\n    vec3 c = a + t*ab;\n    \n    float d = length(p-c)-r;\n    \n    return d;\n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n  p = abs(p);\n  vec2 b = vec2(la,lb);\n  float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\nvec2 colMin(vec2 res, vec2 obj){\n    res.x = min(obj.x,res.x);\n    if(obj.x == res.x){\n        res.y = obj.y;\n    }\n    return res;\n}\n// https://iquilezles.org/articles/smin\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\nfloat getDisp(vec2 uv){\n\n    vec2 p = 0.5 - 0.5*sin(vec2(1.01,1.71) );\n    p = vec2(1.0, 1.0);\n\t\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\t\n\tfloat f = iqnoise(24.0*uv, p.x, p.y);\n\t\n\treturn f;\n}\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\nvec2 torii(vec3 p){\nvec2 uv = vec2(atan(p.x,p.z)/(3.14159*100.),p.y/17.);\n    float off = texture(iChannel1,uv).r*.4;\n    \n    //vec2 uv2 = vec2(atan(p.x,p.z)/(3.14159),p.y);\n    vec2 uv2 = p.xy/2.;\n    float off2 = texture(iChannel1,uv2).r*.06;\n   \n    float legHeight = 15.;\n    float legPos = 5.2;\n    float footingPos = 5.;\n    float legDist = -40.;\n    float angle = 1.5;\n    float legTaper = 1.-p.y*.04;\n    \n    vec2 leg = vec2(sdCylinder(p-vec3(-legPos,0,legDist), vec3(0,0,0), vec3(angle,legHeight,0), legTaper),2.);\n    vec2 footing = vec2(sdCylinder(p-vec3(-footingPos,0,legDist), vec3(0,0,0), vec3(0,3,0), 1.3-p.y*.05),3.);  \n    footing.x -=off2+off;\n    leg = colMin(leg, footing);\n    //leg.x-=off;\n    //leg.x-=off2;\n    vec2 res = leg;\n    \n    leg = vec2(sdCylinder(p-vec3(legPos,0,legDist), vec3(0,0,0), vec3(-angle,legHeight,0), legTaper),2.);\n    footing = vec2(sdCylinder(p-vec3(footingPos,0,legDist), vec3(0,0,0), vec3(0,3,0), 1.3-p.y*.05),3.);\n    footing.x -=off2+off;\n    leg = colMin(leg, footing);\n    //leg.x-=off;\n   // leg.x-=off2;\n    res = colMin(leg, res);\n    \n    vec2 beam = vec2(dBox(p-vec3(0,13,-40), vec3(8,.3,.1)),2.);\n    res = colMin(beam,res);\n    \n    vec2 curveBot = vec2(dBox(p-vec3(0,pow(2.,abs(p.x)*.15)+13.5,-40), vec3(8,.3,1)),2.);\n    res = colMin(curveBot,res);\n    vec2 curveTop = vec2(dBox(p-vec3(0,pow(2.,abs(p.x)*.15)+14.3,-40), vec3(9,.5,1.5)),3.);\n    curveTop.x-=off2*2.;\n    res = colMin(curveTop,res);\n    vec3 rotP = p;\n    rotP-=vec3(0,13.5,-40);\n    //rotP.xz *= Rot(iTime);\n    //rotP.xy *= Rot(iTime);\n    rotP.zy *= Rot(3.5);\n    vec2 kanban = vec2(dBox(rotP,vec3(1,2,.4)),4.);\n    res = colMin(res, kanban);\n   // sdCylinder(vec3 p, vec3 a, vec3 b, float r) \n    vec2 rope =vec2(sdCylinder(p-vec3(0,11.-sin(p.x/2.+3.1415/2.)*2.,-39.5), vec3(-4., 0,0),vec3(4., 0,0), .3) ,5.);\n    res = colMin(res, rope);\n    return res;\n}\nvec2 GetDist(vec3 p){\n    float wave = 0.0;\n\t\n    wave = noise( p.xz/5.+iTime*.6 );\n\n\twave = 0.5 + 0.5*wave;\n    \n    float wave2 = 0.0;\n\t\n    wave2 = noise( p.xz/5.-vec2(0,iTime*.5) );\n\n\twave2 = 0.5 + 0.5*wave2;\n    float off = wave+wave2;\n   // float off =sin(5.*iTime+p.x)*.1+sin(3.*iTime+p.z)*.1;\n    //off*=sin(iTime+p.x*2.);\n    //off+=sin(7.*iTime+(length(p)-.4)*7.*smoothstep(7.,1.,length(p)-.4))*.01;\n    //float off = iqnoise(p.xz/5.+iTime, .9, .9);\n    \n    vec2 po = 0.5 - 0.5*cos(vec2(2.,1.3) );\n    \n\t//if( iMouse.w>0.001 ) p = vec2(0.0,1.0) + vec2(1.0,-1.0)*iMouse.xy/iResolution.xy;\n\t\n\t//p = p*p*(3.0-2.0*p);\n\t//p = p*p*(3.0-2.0*p);\n\t//p = p*p*(3.0-2.0*p);\n\t\n\t//float off = voronoise( p.xz/10.+iTime, po.x, po.y );\n    vec3 rockP = p;\n    \n    rockP.z = mod(rockP.z, 10.0)-4.5;\n    vec3 ripPos = vec3(-4.5,0,0);\n    float rip1=sin(7.*iTime+(length(rockP-ripPos)-.4)*7.*smoothstep(4.,2.,length(rockP-ripPos)-.4))*.01;\n\n    float rip2=sin(3.*iTime+(length(rockP-ripPos)-.1)*7.*smoothstep(3.,2.,length(rockP-ripPos)-.4))*.01;\n    off+=rip1+rip2;\n    ripPos = vec3(4.5,0,0);\n    rip1=sin(7.*iTime+(length(rockP-ripPos)-.4)*7.*smoothstep(4.,2.,length(rockP-ripPos)-.4))*.01;\n\n    rip2=sin(3.*iTime+(length(rockP-ripPos)-.1)*7.*smoothstep(3.,2.,length(rockP-ripPos)-.4))*.01;\n    off+=rip1+rip2;\n    vec2 res = vec2(p.y-off,1.);\n    vec3 rotP = p;\n    \n    rotP.z = mod(rotP.z, 10.0)-44.; // 'fold space' every 2 units.\n    //rotP.xz*=Rot(6.6);\n    res = colMin(torii(rotP),res);\n    \n    //add rocks\n    rockP-=vec3(-100,0,0);\n    /*float off2 = texture(iChannel1,p.xz/40.).r*5.;\n    float off3 = texture(iChannel1,p.xz/100.).r*10.;\n    vec2 rocks = vec2(sdCylinder(rockP, vec3(0,0,0), vec3(0,1,0), 10.+mod(p.z/10.,10.)),7.);\n    rocks.x-=off2+off3;\n    res = colMin(res, rocks);\n    rockP-=vec3(-40,0,0);\n    */\n    //vec2 uv = vec2(atan(p.x,p.z)/(3.14159*3.),p.y/20.-off);\n    float off4 = texture(iChannel1,p.zy/20.).r;\n    vec2 rocks = vec2(sdCylinder(rockP, vec3(0,0,0), vec3(0,20,0), 10.+mod(p.z/10.,10.)),7.);\n    rocks.x-=off4;\n    \n    res = colMin(res, rocks);\n    //res = light;\n    return res;\n}\nvec2 RayMarch(vec3 ro, vec3 rd){\n    // distance from origin\n    vec2 dO=vec2(0.,0.);\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO.x*rd;\n        \n        // get distance to seam\n        vec2 ds = GetDist(p);\n        //move origin to new point\n        \n        /*if(ds.y==7.){\n            dO+=ds.x*.4;\n        }\n        else{\n            dO+=ds.x*.7;\n        }*/\n         dO+=ds.x*.8;\n        if(ds.x < SURFACE_DIST){\n            dO.y = ds.y;\n            break;\n        }\n        else if( dO.x > MAX_DIST){\n            dO.y= -1.;\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p).x;\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy).x,\n         GetDist(p-e.yxy).x,\n         GetDist(p-e.yyx).x);\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n    vec3 lightPos = vec3(40,100,30.-iTime);\n    \n    //lightPos.xz += vec2(sin(iTime),cos(iTime));\n    //light vector\n    vec3 l = normalize(lightPos-p);\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l).x;\n    if(d < length(lightPos-p)){\n        diff *= .1;\n    }\n    \n    return diff;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nfloat DrawSquare (vec2 uv, float width, float height, float posX, float posY, float blur){\n    float w = length((uv.x + posX));\n    float h = length(uv.y + posY);\n    float col = smoothstep(width,width-blur, w);\n    col *= smoothstep(height,height-blur, h);\n    return col;\n}\nvec3 A (vec2 uv){\n    vec3 base =vec3(1)*DrawSquare (uv-vec2(0,0), .1-uv.y*.2, .2, 0., 0., .01);\n    vec3 mask =vec3(1)*DrawSquare (uv-vec2(0,.1), .05-uv.y*.2, .07, 0., 0., .01);\n    vec3 mask2 =vec3(1)*DrawSquare (uv-vec2(0,-.1), .05-uv.y*.2, .1, 0., 0., .01);\n    return base - mask - mask2;\n}\nvec3 X (vec2 uv){\n    vec3 slashR = vec3(1)*DrawSquare (uv-vec2(uv.y*.5,0), .04, .2, 0., 0., .01);\n    vec3 slashL = vec3(1)*DrawSquare (uv-vec2(-uv.y*.5,0), .04, .2, 0., 0., .01);\n    return slashR+slashL;\n}\nvec3 coneText(vec2 uv){\n    vec3 col = A(uv-vec2(-.3,0))+X(uv-vec2(0,0));\n    return col;\n}\nvec3 rad1(vec2 uv, vec3 col){\n    vec3 a = col*DrawSquare (uv-vec2(0.), .1, .03, 0., 0., .01);\n    vec3 b = col*DrawSquare (uv-vec2(0.,pow((-uv.x-.1),1.2)-.14), .1, .03, 0., 0., .01);\n    vec3 c = col*DrawSquare (uv-vec2(0.,-.17), .03, .1, 0., 0., .01);\n    vec3 d = col*DrawSquare (uv-vec2(0.,.05), .03, .06, 0., 0., .01);\n    vec3 e = col*DrawSquare (uv-vec2(0.056,-uv.x-.04), .04, .04, 0., 0., .01);\n    a=max(a,b);\n    a=max(a,c);\n    a=max(a,d);\n    a=max(a,e);\n    return a;\n}\n\nvec3 rad2(vec2 uv, vec3 col){\n    vec3 a = col*DrawSquare (uv-vec2(0.,-.08), .03, .19, 0., 0., .01);\n    vec3 b = col*DrawSquare (uv-vec2(0.1,-.06), .03, .1, 0., 0., .01);\n    vec3 c = col*DrawSquare (uv-vec2(-0.1,-.06), .03, .1, 0., 0., .01);\n    vec3 d = col*DrawSquare (uv-vec2(0,-.05), .1, .03, 0., 0., .01);\n    vec3 e = col*DrawSquare (uv-vec2(0,+.01), .1, .03, 0., 0., .01);\n    vec3 f = col*DrawSquare (uv-vec2(0,-.11), .1, .03, 0., 0., .01);\n    \n    a=max(a,b);\n    a=max(a,c);\n    a=max(a,d);\n    a=max(a,e);\n    a=max(a,f);\n    return a;\n}\n\nvec3 rad3(vec2 uv, vec3 col){\n    vec3 a = col*DrawSquare (uv-vec2(0.,-.08), .03, .19, 0., 0., .01);\n    vec3 b = col*DrawSquare (uv-vec2(0,-.25), .12, .03, 0., 0., .01);\n    vec3 c = col*DrawSquare (uv-vec2(0,-.05), .1, .03, 0., 0., .01);\n    \n    a=max(a,b);\n    a=max(a,c);\n    return a;\n}\n\nvec3 jin(vec2 uv, vec3 col){\n    return rad1(uv,col)+rad2(uv-vec2(0.25,0.),col);\n}\n\nvec3 ja(vec2 uv,vec3 col){\n    return rad1(uv,col)+rad3(uv-vec2(0.2,0.),col);\n}\nvec3 Render (inout vec3 ro, inout vec3 rd, inout float reflVal){\n//------------------\n    vec2 d = RayMarch(ro,rd);\n// position of point\n    // start at ray origin\n    // move d units in the ray direction\n    vec3 p = ro + rd *d.x;\n //get diffuse lighting\n    float diff = GetLight(p)*2.;\n    vec3 col = vec3(0);\n    col = vec3(diff);\n    \n    vec3 n = GetNormal(p);\n    vec3 r = reflect(rd, n);\n    //vec3 refl = texture(iChannel0, r).rgb;\n    vec3 refl = vec3(r.y*2.+.5)+vec3(0,.2,r.y+.5);\n    //refl= refl*abs(n.y) + refl*abs(n.z) + refl*abs(n.x);\n    float fresnel = dot(n,-rd);\n    if(d.y == 1.){\n        col *= vec3(0,.7,1);\n        //col*=refl*.4;\n        col*=vec3(fresnel);\n        reflVal = 0.8;\n    }\n    else if(d.y==2.){\n       vec2 uv = vec2(atan(p.x,p.z)/(3.14159*100.),p.y/17.);\n       float off = texture(iChannel1,uv).r*.4;\n\n       //vec2 uv2 = vec2(atan(p.x,p.z)/(3.14159),p.y);\n       vec2 uv2 = p.xy/2.;\n       float off2 = texture(iChannel1,uv2).r*.06;\n\n       col *= vec3(1,0,0);\n       col = max(col, smoothstep(0.1,0.2,off2)*vec3(.5));\n       reflVal = 0.2;\n    }\n    else if(d.y==3.){\n        col *= vec3(0.2);\n        reflVal = 0.3;\n    }\n    else if(d.y==4.){\n      vec2 uv =p.xy;\n      col*=vec3(.3);\n      uv.y-=14.;\n      uv.x-=-.5;\n      vec3 gold = vec3(.855,.647,.125);\n      vec3 txt=(jin(uv*.3,gold)+ja((uv*.3)-vec2(0,-.4),gold));\n      col = max(txt*abs(n.y) + txt*abs(n.z) + txt*abs(n.x),col);\n      reflVal=0.3;\n    }\n    else if(d.y==5.){\n      col*=vec3(1.);\n      reflVal=0.;\n    }\n    else if(d.y==6.){\n      col*=vec3(1.,1,0);\n      col.xy*=sin(iTime*3.)*.5+.5;\n      reflVal=0.;\n    }\n    else if(d.y==7.){\n      col*=vec3(.8);\n      col = mix(col,smoothstep(4.,1.,p.y)*vec3(.5,1,0),.5);\n     // col.xy*=sin(iTime*3.)*.5+.5;\n      reflVal=0.;\n    }\n    else{\n        col=texture(iChannel0, rd).rgb;\n        col = vec3(rd.y*2.+.5)+vec3(0,.2,rd.y+.5);\n        reflVal =0.0;\n    }\n     ro = p+n*SURFACE_DIST*3.;\n     rd=r;\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n   \n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    \n    float time = iTime*.5;\n    float exp1 = cos(time);\n    float exp22 = pow(sin(time)+1.5,exp1);\n    float rot = pow(sin(time)+1.3,abs(exp22));\n    vec3 ta = vec3( 15.-rot, 15, -iTime);\n    //float rot = pow(pow(sin(iTime)+1.,abs(pow(sin(iTime)+1.,cos(iTime)))));\n    vec3 ro = ta + vec3(.3+rot,.2+(sin(iTime*.2)*.3+.3), 1);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n//    vec3 ro = vec3(0,3,-5);\n\n    \n    //ray dir\n    //controls rotation\n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 pt = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 pt = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n    vec3 rd = ca * normalize( vec3(pt,2.5) );\n    \n    \n    \n    float reflVal = 1.;\n    vec3 col = Render(ro,rd,reflVal);\n    vec3 bounce = .3*reflVal*Render(ro,rd,reflVal);\n    col += bounce;\n    /*vec3 bounce2 = reflVal*Render(ro,rd,reflVal);\n    col += bounce2;*/\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}