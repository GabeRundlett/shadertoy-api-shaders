{
    "Shader": {
        "info": {
            "date": "1556058851",
            "description": "Follow-up of Explore: https://www.shadertoy.com/view/tsSSzW\nA scene composition exercise for shadertoy with sphere-tracing.\nYou can use the mouse to explore several angles of the scene.",
            "flags": 0,
            "hasliked": 0,
            "id": "Wtl3Dn",
            "likes": 8,
            "name": "Explore 2",
            "published": 3,
            "tags": [
                "raymarch",
                "spaceship"
            ],
            "usePreview": 0,
            "username": "lsdlive",
            "viewed": 622
        },
        "renderpass": [
            {
                "code": "/*\n@lsdlive\nCC-BY-NC-SA\n\nExplore 2.\nFollow-up of Explore: https://www.shadertoy.com/view/tsSSzW\nA scene composition exercise for shadertoy with sphere-tracing.\nYou can use the mouse to explore several angles of the scene.\n\n\nGeometries are generated with sphere-tracing algorithms:\nhttp://www.michaelwalczyk.com/blog/2017/5/25/ray-marching\nhttps://iquilezles.org/articles/distfunctions\nhttp://mercury.sexy/hg_sdf/\n\n\nIridescence shading inspired by:\nhttps://twitter.com/minionsart/status/932660640178737163\nhttps://sdm.scad.edu/faculty/mkesson/vsfx419/wip/best/winter11/megan_stifter/iridescence.html\n\nSky background from xt95:\nhttps://www.shadertoy.com/view/4dXSzn\n\nMore about generation of the gradient:\nhttps://iquilezles.org/articles/palettes\n\nMore about noise:\nhttps://thebookofshaders.com/11/\n\nMore about triplanar mapping:\nhttps://catlikecoding.com/unity/tutorials/advanced-rendering/triplanar-mapping/\n\nMore about bump mapping via heighmap or texture:\nhttps://squircleart.github.io/shading/normal-map-generation.html\nhttps://www.shadertoy.com/view/4ss3W7\n\nSome notation:\np: position (usually in world space)\nn: normal\nrd: ray direction (eye or view vector)\nldir: light direction\n\n*/\n\n\n/** Parameters **/\n// put this to 1 if it's too slow\n// put this to 3 to increase quality image\n#define ANTIALIAS 1\n\n\n#define PI 3.14159\n#define TAU 6.28318\n\n#define MAT_PLANE 1\n#define MAT_ALIEN 2\n#define MAT_SHIP 3\n\n#define time iTime\n\nint id = 0; // mat id\n\nconst float dist_to = 6.; // distance from camera to the scene\n\nconst float fre_exponent = 5.;\nconst float spe_exponent = 32.;\n\nconst float iri_factor = .7;\nconst float spe_factor = .4;\nconst float dif_factor = .2;\nconst float cub_factor = .09;\nconst float fre_factor = .7;\n\nconst float bump_factor = .008;\nconst float blend_exponent = 32.;\n\n\nconst float gamma = 2.2;\n\n\n/** Libs **/\nvec3 pal(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n\treturn a + b * cos(TAU * (c * t + d));\n}\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n// Grad noise https://www.shadertoy.com/view/XdXGW8\nvec2 hash(vec2 uv) {\n\tconst vec2 k = vec2(.3183099, .3678794);\n\tuv = uv * k + k.yx;\n\treturn -1. + 2. * fract(16. * k * fract(uv.x * uv.y *(uv.x + uv.y)));\n}\n\nfloat noise2D(vec2 p) {\n\tvec2 i = floor(p);\n\tvec2 f = fract(p);\n\n\tvec2 u = f * f*(3.0 - 2.0*f);\n\n\treturn mix(mix(dot(hash(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\n\t\tdot(hash(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\n\t\tmix(dot(hash(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n\t\t\tdot(hash(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat box(vec3 p, vec3 b) {\n\tb = abs(p) - b;\n\treturn min(max(b.x, max(b.y, b.z)), 0.) + length(max(b, 0.));\n}\n\nfloat sphere(vec3 p, float d) {\n\treturn length(p) - d;\n}\n\n// LJ's short formula\nfloat octahedron(vec3 p, float d) {\n\treturn dot(p, normalize(sign(p))) - d;\n}\n\n\n// http://mercury.sexy/hg_sdf/\nfloat stmin(float a, float b, float k, float n) {\n\tfloat st = k / n;\n\tfloat u = b - k;\n\treturn min(min(a, b), .5 * (u + a + abs(mod(u - a + st, 2. * st) - st)));\n}\n\n\nfloat ship(vec3 p) {\n    p.y = abs(p.y);\n\tfloat ship = box(p, vec3(3.4 + p.y*.7, 1.3, 3.4 + p.y*.7));\n\treturn .6 * min(ship, octahedron(p, 2.));\n}\n\nfloat cruiser(vec3 p) {\n\tfloat ship = box(p, vec3(4. + p.y*.3, .8, 1. + p.y*.3));\n    p.xy -= vec2(1.5, .3);\n\treturn .6 * min(ship, octahedron(p, 1.4));\n}\n\nfloat de(vec3 p) {\n\tvec3 q = p;\n\n\n    // Main ship\n\tp += vec3(-0, -3, 40);\n\tp.z += sin(cos(time)*sin(time) + time)*25.;\n\tfloat ships = ship(p);\n\n    // Two cruisers\n    float ts = mod(time, 40.);\n    float speed = (-35.+ts)*.1;\n    \n\tp = q;\n\tp += vec3(-10, -15, 44);\n    p.xz += vec2(cos(speed), sin(speed))*15.;\n    ships = min(ships, cruiser(p));\n\n\tp = q;\n\tp += vec3(-7, -15, 53);\n    p.xz += vec2(cos(speed), sin(speed))*15.;\n    ships = min(ships, cruiser(p));\n\n    // Spheres\n\tp = q;\n\tp.xyz += vec3(cos(time*1.3)*sin(time), cos(time*1.1)-1., sin(time)*cos(time))*1.;\n\tp.xz += vec2(-5, 2.5);\n\tp.xz *= r2d(time);\n\tp.xy *= r2d(time);\n\tfloat sz = .2;\n\tfloat aliens = sphere(p, sz);\n\tp.x += 1.;\n\taliens = min(aliens, sphere(p, sz));\n\tp.z += 2.;\n\taliens = min(aliens, sphere(p, sz));\n\t\n    // Ground\n    p = q;\n\tfloat plane = p.y + 2.55 - p.x*p.x*.008 + noise2D(p.xz) * .1;\n\n\tfloat d;\n\tif (plane < aliens) {\n\t\tid = MAT_PLANE;\n\t\td = plane;\n\t}\n\telse {\n\t\tid = MAT_ALIEN;\n\t\td = aliens;\n\t}\n\n\tif (ships < d) {\n\t\tid = MAT_SHIP;\n\t\td = ships;\n\t}\n\n\treturn d;\n\n}\n\n\n// suggested from tdhooper.\n// improve compilation time & overall fps.\nconst int NORMAL_STEPS = 6;\nvec3 normal(vec3 pos) {\n\tvec3 eps = vec3(.0001, 0, 0);\n\tvec3 nor = vec3(0);\n\tfloat invert = 1.;\n\tfor (int i = 0; i < NORMAL_STEPS; i++) {\n\t\tnor += de(pos + eps * invert) * eps * invert;\n\t\teps = eps.zxy;\n\t\tinvert *= -1.;\n\t}\n\treturn normalize(nor);\n}\n\nvec3 tex2D(vec2 uv) {\n\tvec3 col = texture(iChannel1, uv).rgb;\n\treturn pow(col, vec3(gamma));\n}\n\nvec3 cubemap(vec3 rd) {\n\tvec3 col = texture(iChannel0, rd).rgb;\n\treturn pow(col, vec3(gamma));\n}\n\n\n// Tri-planar bump-mapping\n// From shane: https://www.shadertoy.com/view/MlXSWX\n// Tri-Planar blending function. Based on an old Nvidia tutorial\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(vec3 p, vec3 n) {\n\tvec3 weight = pow(abs(n), vec3(blend_exponent));\n\t//vec3 weight = max((abs(n) - .2) * 7., .001); // shane's factors\n\tweight /= (weight.x + weight.y + weight.z);\n\n\treturn\n\t\ttex2D(p.yz) * weight.x +\n\t\ttex2D(p.zx) * weight.y +\n\t\ttex2D(p.xy) * weight.z;\n}\n\n#define luma(c) (c.r * .299 + c.g * .587 + c.b * .114)\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\n// convert texture to greyscale, then compute difference to get edge\nvec3 do_bumpmap(vec3 p, vec3 n, float bumpfactor) {\n\tconst float eps = .001;\n\tfloat ref = luma(tex3D(p, n));\n\tvec3 grad = vec3(\n\t\tluma(tex3D(vec3(p.x - eps, p.y, p.z), n)) - ref,\n\t\tluma(tex3D(vec3(p.x, p.y - eps, p.z), n)) - ref,\n\t\tluma(tex3D(vec3(p.x, p.y, p.z - eps), n)) - ref) / eps;\n\n\tgrad -= n * dot(n, grad);\n\treturn normalize(n + grad * bumpfactor);\n}\n\n// iq implementation\nfloat softshadow(in vec3 ro, in vec3 rd, float mint, float k)\n{\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfloat h = 1.0;\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\th = de(ro + rd * t);\n\t\tres = min(res, k*h / t);\n\t\tt += clamp(h, .005, .1);\n\t}\n\treturn clamp(res, 0., 1.);\n}\n\n// from xt95\nvec3 sky(vec3 dir, vec2 uv) {\n\tvec3 ldir = normalize(vec3(1., .5, -1.));// not same as in shading()\n    \t\t\t\t\t\t\t\t\t\t// allow more controls\n\tfloat fact = (sin(time * .4))*20. * clamp(uv.x + .8, 0., 1.);\n\tvec3 col = mix(vec3(40. + fact, 34., 30.), vec3(18., 28., 44.), min(abs(dir.y)*2. + .5, 1.)) / 255.*.5;\n\tcol *= (1. + vec3(1., .7, .3) / sqrt(length(dir - ldir))*4.); //sun\n\treturn col;\n}\n\nvec3 shading(vec3 p, vec3 rd, vec3 n, vec2 uv) {\n\n\tvec3 ldir = normalize(vec3(1.2, 1.8, -1.));// not same as in sky() // allow more controls\n\n\tvec3 h = normalize(ldir - rd); // half vector\n\n\tint mat_id = id;// copy mat id (id is a global variable afected by various computation)\n\n\tfloat sha = softshadow(p, ldir, .05, 20.);\n\n\tvec3 skybg = sky(reflect(rd, n), uv);\n\n    if(mat_id != MAT_SHIP)\n\t\tn = do_bumpmap(p, n, bump_factor);\n\n\tfloat dotNL = max(0., dot(n, ldir));\n\tfloat dotNV = max(0., dot(n, -rd));\n\tfloat dotNH = max(0., dot(n, h));\n\n\tvec3 albedo = tex3D(p, n);\n\tvec3 cubemap = cubemap(reflect(rd, n));\n\n\tfloat fre = pow(1. - dotNV, fre_exponent);\n\tfloat spe = pow(dotNH, spe_exponent);\n\n\tvec3 col;\n\tif (mat_id == MAT_ALIEN) {\n\t\t// blue - purple\n\t\tvec3 iri = pal(dotNV ,\n\t\tvec3(.4),\n\t\tvec3(.5),\n\t\tvec3(.6),\n\t\tvec3(.9, .1, .5)\n\t\t);\n\n        // red\n\t\tvec3 iri2 = pal(dotNV,\n\t\t\tvec3(.4),\n\t\t\tvec3(.8),\n\t\t\tvec3(.5, .6, .6),\n\t\t\tvec3(.9, .1, .14)\n\t\t);\n        \n        iri = mix(iri, iri2, sin(time * .4)*.5+.5);\n\n\t\tcol = iri * iri_factor + spe * spe_factor + dotNL * dif_factor;\n\t\tcol = mix(skybg, col, dotNL*.5 + .5);\n        col += cubemap * cub_factor;\n\t}\n\t\n    if (mat_id == MAT_PLANE) {\n\t\tcol = vec3(.2, .1, .0);\n\t\tcol += albedo * .1;\n\n\n\t\tcol *= sha;\n\t}\n\t\n    if (mat_id == MAT_SHIP) {\n\t\tcol = vec3(0);\n        col += cubemap * cub_factor;\n\t}\n\n\t//col += cubemap * cub_factor;\n\n\tif (mat_id == MAT_PLANE)\n\t\tcol += fre * fre_factor;\n\n\tcol += skybg * .4;\n\n\treturn clamp(col, 0., 1.);\n}\n\nvec3 camera(vec3 ro, vec2 uv, vec3 ta) {\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 left = normalize(cross(vec3(0, 1, 0), fwd));\n\tvec3 up = normalize(cross(fwd, left));\n\treturn normalize(fwd + uv.x*left + up * uv.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\n\tvec3 ray_ori;\n\tif (iMouse.z > 0.) {\n\t\tfloat xm = (-iMouse.x*10. / iResolution.x);\n\t\tfloat ym = (-iMouse.y*10. / iResolution.x);\n\t\tray_ori = vec3(dist_to * cos(xm), cos(ym) * 5., dist_to * sin(xm));\n\t}\n\telse {\n\t\tfloat ts = 3.9;//+ sin(iTime) * .1;\n\t\tray_ori = vec3(dist_to * cos(ts * .5), 0., dist_to * sin(ts * .5));\n\t}\n\n\tvec3 tcol = vec3(0);\n\tvec3 target = vec3(0);\n\n#if ANTIALIAS > 1\n\tfor (int j = 0; j < ANTIALIAS; j++) {\n\t\tfor (int i = 0; i < ANTIALIAS; i++) {\n\t\t\tvec2 off = vec2(float(i), float(j)) / float(ANTIALIAS);\n\n\t\t\tvec2 uv = (fragCoord.xy + off) / iResolution.xy - .5;\n#else\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n#endif\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec3 ray_dir = camera(ray_ori, uv, target);\n\tvec3 pos;\n\n\tfloat tdist = 0.; // total distance from the ray origin to the point\n\tfloat tmax = 60.; // max distance\n\t\t\t\t\t  // Sphere-tracing\n\tfor (float i = 0.; i < 1.; i += .01) {// 100 iterations\n\t\tpos = ray_ori + ray_dir * tdist;\n\t\tfloat dist = de(pos); // signed distance field\n\t\tif (dist < .001 || tdist > tmax)\n\t\t\tbreak;\n\t\ttdist += dist;\n\t}\n\n\tvec3 col = vec3(0);\n\tvec3 background = sky(ray_dir, uv);\n\tif (tdist <= tmax) {\n\t\tvec3 nor = normal(pos);\n\t\tcol = shading(pos, ray_dir, nor, uv);\n\t}\n\telse {\n\t\tcol = background;\n\t}\n\n\t// fog\n\tcol = mix(col, background, 1. - exp(-.001*tdist*tdist));\n\n\ttcol += col;\n#if ANTIALIAS > 1\n\t}\n\t} // antialias\n\ttcol /= float(ANTIALIAS * ANTIALIAS);\n#endif\n\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\t// sandstorm - multiple layers of screenspace noise\n\ttcol -= texture(iChannel2, (q - vec2(iTime, .1*cos(iTime*2.)))*.1).rgb * .03;\n\ttcol -= texture(iChannel2, (q - vec2(.5, .2) + vec2(iTime*.5, .1*cos(iTime*1.)))*.1).rgb * .02;\n\ttcol -= texture(iChannel2, (q - vec2(.9, .1) - vec2(iTime*2., .1*cos(iTime*1.5)).xx)*.1).rgb * .02;\n\n\t// gamma\n\ttcol = pow(tcol, vec3(1. / gamma));\n\n\t// vignetting (from iq)\n\ttcol *= .5 + 0.5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .25);\n\n\tfragColor = vec4(tcol, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}