{
    "Shader": {
        "info": {
            "date": "1637498895",
            "description": "Trigonometric experiment (mouseable)",
            "flags": 0,
            "hasliked": 0,
            "id": "NlK3WR",
            "likes": 26,
            "name": "Robotic Head",
            "published": 3,
            "tags": [
                "mechanics",
                "trigonometry"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 320
        },
        "renderpass": [
            {
                "code": "// \"Robotic Head\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Trigonometric experiment (mouseable)\n\n/*\n  No. 12 in \"Flexible Tube\" series\n    \"Flexibility\"               (MtlyWl)\n    \"Planet Reboot\"             (wldGD8)\n    \"Decalled Floppy Tube\"      (3l3GD7)\n    \"Elevating Platter\"         (Wl33RS)\n    \"Multisegment Floppy Tube\"  (tlcGRB)\n    \"Planet Reboot 2\"           (Wtc3Rf)\n    \"Snake Worship\"             (wtyGRD)\n    \"Decalled Floppy Tube 2\"    (WsGfWd)\n    \"Floppy Column\"             (wtccR4)\n    \"Metallic Tubeworms\"        (3ltfzM)\n    \"Trapped Light\"             (flt3WB)\n    \n  But now a different (transcendental) problem must be solved: \n  compute arc angle from arc and chord lengths, rather than radius\n  from arc length and angle.\n*/\n\n#define AA  0   // optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrTorusBxDf (vec3 p, vec3 b, float ri);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrConCapsDf (vec3 p, vec2 cs, float r, float h);\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\n\nvec3 ltPos[4], ltCol[4], qHit;\nfloat tCur, dstFar;\nint idObj;\nconst int idTube = 1, idCon = 2, idBall = 3, idHead = 4, idEar = 5, idNos = 6, idCrwn = 7,\n   idTooth = 8, idEye = 9, idBas = 10, idArm = 11; \nconst float pi = 3.1415927;\n\nstruct Arc {\n  vec2 cs;\n  float chDist, chRot, ang, rad, shift;\n};\nArc arc;\n\nstruct Arm {\n  float len, sep, rot;\n};\nArm arm;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 pr, q;\n  float dMin, d, sLen, sx, a;\n  dMin = dstFar;\n  sLen = 0.25;\n  p.y -= arm.sep + 1.;\n  q = p;\n  pr = p;\n  pr.xz = Rot2D (pr.xz, arm.rot);\n  pr.y -= arm.sep;\n  q = pr;\n  q.z -= -0.5;\n  d = PrRoundBoxDf (q, vec3 (0.8, 1.2, 1.), 0.2);\n  d = SmoothMax (d, - min (PrSphDf (vec3 (abs (q.x) - 0.4, q.y - 0.4, q.z + 1.2), 0.25),\n     PrCapsDf (vec3 (q.x, q.y + 0.7, q.z + 1.2).yzx, 0.15, 0.4)), 0.02);\n  DMINQ (idHead);\n  q = pr;\n  q.z -= -0.2;\n  d = PrRoundBoxDf (q, vec3 (0., 1.3, 0.9), 0.3);\n  DMINQ (idCrwn);\n  q = pr;\n  d = PrTorusBxDf (q, vec3 (arm.len - 0.2, 0.1, 0.2), 0.1);\n  DMINQ (idCon);\n  q = pr;\n  q.x = abs (q.x);\n  q -= vec3 (0.4, 0.4, -1.65);\n  d = PrSphDf (q, 0.22);\n  DMINQ (idEye);\n  q = pr;\n  q -= vec3 (0., 0.2, -1.7);\n  d = PrConCapsDf (q.xzy, sin (0.1 * pi + vec2 (0.5 * pi, 0.)), 0.13, 0.25);\n  DMINQ (idNos);\n  q = pr;\n  q.x = abs (q.x);\n  q -= vec3 (1.1, 0.5, -0.8);\n  d = PrRoundCylDf (q.yzx, 0.3, 0.15, 0.);\n  DMINQ (idEar);\n  q = pr;\n  d = max (PrRoundBoxDf (vec3 (mod (q.x + 0.05, 0.1) - 0.05, abs (q.y + 0.7) - 0.12,\n     q.z + 1.65), vec3 (0.025, 0.04, 0.), 0.03), abs (q.x) - 0.45);\n  DMINQ (idTooth);\n  q = pr;\n  sx = sign (q.x);\n  q.x = abs (q.x) - arm.len;\n  q.xz = Rot2D (q.xz, 0.5 * (pi - arm.rot) * sx);\n  q.x += sLen * sx;\n  d = PrCylDf (q.yzx, 0.1, sLen);\n  DMINQ (idCon);\n  sx *= sign (q.x);\n  q.x = abs (q.x) - sLen;\n  if (sx > 0.) q = q.xzy;\n  d = PrSphDf (q, 0.17);\n  DMINQ (idBall);\n  q = p;\n  d = PrCylDf (q.xzy, 0.4, 0.6);\n  DMINQ (idBas);\n  q = p;\n  q.yz -= vec2 (- arm.sep - 0.2, -0.3);\n  d = PrRoundCylDf (q.xzy, 1., 0.2, 0.7);\n  DMINQ (idBas);\n  q = p;\n  q.yz -= vec2 (- arm.sep, - sLen);\n  d = PrRoundBoxDf (q, vec3 (arm.len + 0.2, 0.2, 0.), 0.2);\n  DMINQ (idArm);\n  q = p;\n  sx = sign (q.x);\n  q.x = abs (q.x);\n  q.xy -= vec2 (arm.len, - arm.sep);\n  q.xz = Rot2D (q.xz, -0.5 * (pi - arm.rot) * sx);\n  q.x -= sLen * sx;\n  d = PrCylDf (q.yzx, 0.1, sLen);\n  DMINQ (idCon);\n  sx *= sign (q.x);\n  q.x = abs (q.x) - sLen;\n  if (sx < 0.) q = q.xzy;\n  d = PrSphDf (q, 0.17);\n  DMINQ (idBall);\n  for (float k = 0.; k <= 1.; k ++) { // (constant-length flexible tubing)\n    q = p;\n    q.xz = Rot2D (q.xz, k * pi + 0.5 * arm.rot) - vec2 (arc.shift, 2. * sLen * sign (1. - 2. * k));\n    q.yz = Rot2D (q.yz, arc.chRot - (k + 0.5) * pi) + vec2 (arc.chDist, 0.);\n    a = mod ((128. / arc.ang) * atan (q.z, q.y) / (2. * pi), 1.);\n    d = max (dot (vec2 (abs (q.z), q.y), arc.cs), length (vec2 (length (q.yz) - arc.rad, q.x)) -\n       0.13 + 0.02 * smoothstep (0.15, 0.35, 0.5 - abs (0.5 - a)));\n    DMINQ (idTube);\n  }\n  return dMin;\n}\n\n#define F(x) (sin (x) / x - b)\n\nfloat SecSolve (float b)\n{  // (solve for arc angle given length and chord, |err| < 1e-4 for b < 0.95) \n  vec3 t;\n  vec2 f;\n  t.yz = vec2 (0.7, 1.2);\n  f = vec2 (F(t.y), F(t.z));\n  for (int nIt = 0; nIt < 4; nIt ++) {\n    t.x = (t.z * f.x - t.y * f.y) / (f.x - f.y);\n    t.zy = t.yx;\n    f = vec2 (F(t.x), f.x);\n  }\n  return t.x;\n}\n\nvoid ArcConf ()\n{\n  vec2 u;\n  float arcLen, arcEx, chLen, aLim;\n  aLim = 0.5 * pi;\n  arm.len = 2.;\n  arm.sep = 1.2;\n  arcEx = 1.5;\n  arcLen = arcEx * length (vec2 (arm.len * sin (0.5 * aLim), arm.sep));\n  arm.rot = aLim * (0.3 + 0.7 * Fbm1 (0.7 * tCur)) * sin (0.2 * pi * tCur);\n  u = vec2 (arm.len * sin (0.5 * arm.rot), arm.sep);\n  chLen = length (u);\n  arc.chRot = atan (u.x, u.y);\n  arc.shift = sqrt (arm.len * arm.len - u.x * u.x);\n  arc.ang = SecSolve (chLen / arcLen);\n  arc.chDist = chLen / tan (arc.ang);\n  arc.rad = sqrt (arc.chDist * arc.chDist + chLen * chLen);\n  arc.cs = sin (- arc.ang + vec2 (0.5 * pi, 0.));\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dMax)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.001 || d > dMax) break;\n  }\n  return 0.3 + 0.7 * sh;\n}\n\nvec4 ObjCol ()\n{\n  vec4 col4;\n  float s;\n  if (idObj == idTube) {\n    col4 = vec4 (0.9, 0.9, 1., 0.3);\n  } else if (idObj == idCon) {\n    col4 = vec4 (1., 0.7, 0.4, 0.3);\n  } else if (idObj == idBall) {\n    col4 = vec4 (1., 0.7, 0.4, 0.3) * (0.8 + 0.2 * smoothstep (0., 0.005,\n       abs (abs (qHit.z) - 0.05) - 0.005));\n  } else if (idObj == idHead) {\n    s = min (abs (PrRoundBox2Df (qHit.yz - vec2 (-0.7, -0.4), vec2 (0.25, 0.3), 0.1)),\n       abs (PrRoundBox2Df (qHit.yz - vec2 (0., 0.5), vec2 (0.4, 0.1), 0.07)));\n    if (qHit.y > 0.) s = min (s, abs (PrRoundBox2Df (vec2 (abs (qHit.x) - 0.55, qHit.z),\n       vec2 (0.1, 0.9), 0.07)));\n    s = min (s, (qHit.z < 0.) ? abs (PrRoundBox2Df (qHit.xy - vec2 (0., 1.),\n       vec2 (0.6, 0.1), 0.1)) : abs (PrRoundBox2Df (vec2 (abs (qHit.x), qHit.y) -\n       vec2 (0.55, 0.), vec2 (0.1, 1.1), 0.07)));\n    col4 = vec4 (0.8, 1., 0.9, 0.2) * (0.8 + 0.2 * smoothstep (0., 0.03, s));\n    if (PrRoundBoxDf (qHit, vec3 (0.8, 1.2, 1.) - 0.01, 0.2) < 0.) col4 = vec4 (0.6, 0., 0., -1.);\n  } else if (idObj == idEar) {\n    col4 = vec4 (0.5, 1., 0.8, 0.2);\n    if (qHit.x > 0.1) col4 *= 0.7 + 0.3 * smoothstep (0., 0.02, mod (16. *\n       length (qHit.yz), 1.) - 0.1);\n  } else if (idObj == idNos) {\n    col4 = vec4 (0.9, 1., 0.6, 0.2);\n    if (qHit.y < -0.3 && length (vec2 (abs (qHit.x) - 0.07, qHit.z + 0.1)) < 0.05) col4 *= 0.3;\n  } else if (idObj == idCrwn) {\n    s = 0.;\n    if (abs (qHit.z) < 0.9) s = qHit.z;\n    else if (abs (qHit.y) < 1.3) s = qHit.y;\n    col4 = vec4 (0.6, 0.6, 0.2, 0.2);\n    if (s != 0.) col4 *= 0.8 + 0.2 * smoothstep (0., 0.05, mod (8. * s, 1.) - 0.1);\n  } else if (idObj == idTooth) {\n    col4 = vec4 (1., 1., 1., 0.2);\n  } else if (idObj == idEye) {\n    col4 = vec4 (vec3 (0.3, 0.5, 1.) * (0.7 + 0.3 * Fbm1 (8. * tCur)), -1.);\n  } else if (idObj == idBas) {\n    col4 = vec4 (0.3, 0.7, 0.3, 0.2) * (0.8 + 0.2 * smoothstep (0., 0.05,\n       mod (8. * qHit.y, 1.) - 0.1));\n  } else if (idObj == idArm) {\n    col4 = vec4 (0.5, 0.9, 0.3, 0.2) * (0.8 + 0.2 * smoothstep (0., 0.03,\n       abs (PrRoundBox2Df (vec2 (abs (qHit.x), qHit.y) - vec2 (arm.len - 0.05, 0.),\n       vec2 (0.2, 0.12), 0.07))));\n  }\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, ltDir, ltAx, c;\n  float dstObj, nDotL, sh, att, ltDst;\n  ArcConf ();\n  col = vec3 (0.);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = ObjCol ();\n  } else if (rd.y < 0.) {\n    dstObj = - ro.y / rd.y;\n    ro += dstObj * rd;\n    vn = vec3 (0., 1., 0.);\n    col4 = vec4 (0.6, 0.6, 0.6, 0.1) * (1. - 0.2 * Fbm2 (4. * ro.xz));\n    col4.rgb *= 1. - 0.2 * smoothstep (0.05, 0.08,\n       length (max (abs (mod (ro.xz + 0.7, 1.4) - 0.7) - 0.6, 0.)));\n  }\n  if (dstObj < dstFar) {\n    if (col4.a >= 0.) {\n      for (int k = VAR_ZERO; k < 4; k ++) { // (see \"Controllable Hexapod 2\")\n        ltDir = ltPos[k] - ro;\n        ltDst = length (ltDir);\n        ltDir /= ltDst;\n        ltAx = normalize (ltPos[k] - vec3 (0., arm.sep + 1., 0.));\n        att = smoothstep (0., 0.02, dot (ltDir, ltAx) - 0.95);\n        sh = (dstObj < dstFar) ? ObjSShadow (ro + 0.01 * vn, ltDir, ltDst) : 1.;\n        nDotL = max (dot (vn, ltDir), 0.);\n        if (col4.a > 0.) nDotL *= nDotL * nDotL;\n        c = att * ltCol[k] * (col4.rgb * (0.15 + 0.85 * sh * nDotL) +\n           col4.a * step (0.95, sh) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.));\n        col += c * c;\n      }\n      col = sqrt (col);\n    } else col = col4.rgb * (0.2 + 0.8 * max (0., - dot (vn, rd)));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.13 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.03 * pi * tCur;\n    el += 0.1 * pi * cos (0.02 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, -0.01 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 2., -20.);\n  ro.y = max (ro.y, 0.1);\n  for (int k = VAR_ZERO; k < 4; k ++) {\n    ltPos[k] = vec3 (0., 30., 0.);\n    ltPos[k].xy = Rot2D (ltPos[k].xy, 0.25 * pi * (1. + 0.2 * sin (0.05 * pi * tCur -\n       pi * float (k) / 4.)));\n    ltPos[k].xz = Rot2D (ltPos[k].xz, 0.1 * pi * tCur + 2. * pi * float (k) / 4.);\n  }\n  ltCol[0] = vec3 (1., 0.5, 0.5);\n  ltCol[1] = ltCol[0].gbr;\n  ltCol[2] = ltCol[0].brg;\n  ltCol[3] = 0.8 * ltCol[0].rrg;\n  zmFac = 4.8;\n  dstFar = 100.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrTorusBxDf (vec3 p, vec3 b, float ri)\n{\n  return length (vec2 (length (max (abs (p.xy) - b.xy, 0.)) - b.z, p.z)) - ri;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrConCapsDf (vec3 p, vec2 cs, float r, float h)\n{\n  float d;\n  d = max (dot (vec2 (length (p.xy) - r, p.z), cs), abs (p.z) - h);\n  h /= cs.x * cs.x;\n  r /= cs.x;\n  p.z += r * cs.y;\n  return min (d, min (length (p - vec3 (0., 0., h)) - (r - h * cs.y),\n     length (p - vec3 (0., 0., - h)) - (r  + h * cs.y)));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}