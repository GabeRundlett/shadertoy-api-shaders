{
    "Shader": {
        "info": {
            "date": "1455123153",
            "description": "Get the balls into any of the 4 holes within the time limit",
            "flags": 32,
            "hasliked": 0,
            "id": "4dV3RG",
            "likes": 20,
            "name": "Trapped Balls",
            "published": 3,
            "tags": [
                "raytracing",
                "raymarching",
                "game",
                "interactive",
                "dynamics"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 1277
        },
        "renderpass": [
            {
                "code": "// \"Trapped Balls\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n\nGet the balls into any of the 4 holes within the time limit.\n\nTray angle is changed by moving the knob in the control box.\n\nUntil play starts the tray angle varies gradually by itself, and while the mouse\npointer is not in the control box it adjusts the view angle.\n\nThe game stops after 2 minutes (remaining time is shown), or when all balls have\ngone.\n\n*/\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrShCylDf (vec3 p, float rIn, float rEx, float h)\n{\n  float s;\n  s = length (p.xy);\n  return max (max (s - rEx, rIn - s), abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  p.z -= h * clamp (p.z / h, -1., 1.);\n  return length (p) - r;\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nmat3 QToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nconst int nBall = 36;\nvec3 vnBall, qHit;\nvec2 aTilt;\nfloat dstFar, hbLen;\nint idBall, idObj;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, pp;\n  float dMin, d, ww, wh;\n  dMin = dstFar;\n  ww = 0.2;\n  wh = 0.3;\n  pp = p;\n  pp.xy = Rot2D (pp.xy, - aTilt.x);\n  pp.yz = Rot2D (pp.yz, aTilt.y);\n  q = pp;  q.y -= -0.6;\n  d = PrBoxDf (q, vec3 (hbLen + 0.25, 0.1, hbLen + 0.25));\n  q = pp;  q.z = abs (abs (q.z) - hbLen);\n  d = max (d, - PrCylDf (q.xzy, 0.55, 1.));\n  q = pp;  q.x = abs (abs (q.x) - hbLen);\n  d = max (d, - PrCylDf (q.xzy, 0.55, 1.));\n  if (d < dMin) { dMin = d;  idObj = 1;  qHit = pp; }\n  pp.y -= -0.25;\n  q = pp;  q.xz = abs (q.xz) - vec2 (hbLen + 0.05, 0.5 * hbLen + 0.4);\n  d = PrBoxDf (q, vec3 (ww, wh, 0.5 * hbLen + 0.25 - 0.4));\n  q = pp;  q.xz = abs (q.xz) - vec2 (0.5 * hbLen + 0.4, hbLen + 0.05);\n  d = min (d, PrBoxDf (q, vec3 (0.5 * hbLen + 0.25 - 0.4, wh, ww)));\n  q = pp;\n  d = min (d, min (PrBoxDf (q, vec3 (2., wh, ww)),\n     PrBoxDf (q, vec3 (ww, wh, 2.))));\n  q = pp;  q.xz = abs (q.xz) - vec2 (0.5 * hbLen, hbLen - 1.);\n  d = min (d, PrBoxDf (q, vec3 (ww, wh, 1.)));\n  q = pp;  q.xz = abs (q.xz) - vec2 (hbLen - 1., 0.5 * hbLen);\n  d = min (d, PrBoxDf (q, vec3 (1., wh, ww)));\n  q = pp;  q.x = abs (q.x) - hbLen + 3.;\n  d = min (d, PrBoxDf (q, vec3 (ww, wh, 2.)));\n  q = pp;  q.x = abs (q.x) - hbLen - 1.5 * ww;  q.y -= -0.5 * wh;\n  d = min (d, PrBoxDf (q, vec3 (0.5 * ww, 0.5 * ww, 0.7)));\n  q = pp;  q.z = abs (q.z) - hbLen + 3.;\n  d = min (d, PrBoxDf (q, vec3 (2., wh, ww)));\n  if (d < dMin) { dMin = d;  idObj = 2; }\n  q = pp;  q.x = abs (q.x) - hbLen - 0.05;\n  d = PrShCylDf (q.zyx, 0.5, 0.8, ww);\n  q = pp;  q.z = abs (q.z) - hbLen - 0.05;\n  d = max (min (d, PrShCylDf (q, 0.5, 0.8, ww)), - q.y);\n  if (d < dMin) { dMin = d;  idObj = 2; }\n  pp = p;\n  pp.xy = Rot2D (pp.xy, - aTilt.x);\n  pp.y -= -0.5;\n  q = pp;  q.x = abs (q.x) - hbLen - 0.8;\n  d = PrCylDf (q.yzx, 0.5, 0.5);\n  if (d < dMin) { dMin = d;  idObj = 3; }\n  d = PrBoxDf (q, vec3 (ww, ww, hbLen + 1.));  \n  q = pp;  q.z = abs (q.z) - hbLen - 0.8;\n  d = min (d, PrBoxDf (q, vec3 (hbLen + 1., ww, ww)));  \n  if (d < dMin) { dMin = d;  idObj = 4; }\n  q = p;  q.y -= -0.5;  q.z = abs (q.z) - hbLen - 0.8;\n  d = PrCylDf (q, 0.5, 0.5);\n  if (d < dMin) { dMin = d;  idObj = 3; }\n  q = p;  q.y -= -4.6;  q.z = abs (q.z) - hbLen - 1.3;\n  d = PrCapsDf (q.xzy, 0.3, 4.);  \n  if (d < dMin) { dMin = d;  idObj = 4; }\n  q = p;  q.y -= -8.5;  \n  d = PrBoxDf (q, vec3 (1., ww, hbLen + 1.8));  \n  if (d < dMin) { dMin = d;  idObj = 5; }\n\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.0002, -0.0002, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 25; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 1., 20. * h / d));\n    d += min (0.15, 3. * h);\n    if (h < 0.001) break;\n  }\n  return 0.2 + 0.8 * sh;\n}\n\nfloat BallRay (vec3 ro, vec3 rd)\n{\n  vec3 u;\n  vec2 p;\n  float b, d, w, dMin, rad, radSq;\n  ro.xy = Rot2D (ro.xy, - aTilt.x);\n  ro.yz = Rot2D (ro.yz, aTilt.y);\n  rd.xy = Rot2D (rd.xy, - aTilt.x);\n  rd.yz = Rot2D (rd.yz, aTilt.y);\n  dMin = dstFar;\n  rad = 0.46;\n  radSq = rad * rad;\n  for (int n = 0; n < nBall; n ++) {\n    p = Loadv4 (4 + 2 * n).xy;\n    u = ro - vec3 (p.x, 0., p.y);\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + radSq;\n    if (w >= 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) {\n        dMin = d;\n        vnBall = (u + d * rd) / rad;\n        idBall = n;\n      }\n    }\n  }\n  return dMin;\n}\n\nvec3 WoodCol (vec3 p, vec3 n)\n{\n  p *= 4.;\n  float f = dot (vec3 (Fbm2 (p.yz * vec2 (1., 0.1)),\n     Fbm2 (p.xz * vec2 (1., 0.1)), Fbm2 (p.yx * vec2 (1., 0.1))), abs (n));\n  return mix (vec3 (0.8, 0.4, 0.2), vec3 (0.45, 0.25, 0.1), f);\n}\n\nfloat BallChqr (int idBall, vec3 vnBall)\n{\n  vec3 u;\n  u = QToRMat (Loadv4 (4 + 2 * idBall + 1)) * vnBall;\n  return 0.4 + 0.6 * step (0., sign (u.y) * sign (u.z) * atan (u.x, u.y));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 qtHit, objCol;\n  vec3 col, vn, rHit, ltDir1, ltDir2;\n  float dstHit, dstBall, reflCol, lcd, lcs, sh;\n  int idObjT;\n  bool doRefl;\n  dstBall = BallRay (ro, rd);\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  if (idObj < 0) dstHit = dstFar;\n  reflCol = 1.;\n  doRefl = false;\n  if (dstHit < dstBall) {\n    if (idObj == 1) {\n      if (qHit.y > -0.5 && max (abs (qHit.x), abs (qHit.z)) < hbLen - 0.1 &&\n         mod (floor (4. * qHit.x), 2.) == mod (floor (4. * qHit.z), 2.))\n         doRefl = true;\n    }\n  }\n  if (doRefl) {\n    ro += rd * dstHit;\n    vn = ObjNf (ro);\n    rd = reflect (rd, vn);\n    ro += 0.01 * rd;\n    dstBall = BallRay (ro, rd);\n    idObj = -1;\n    dstHit = ObjRay (ro, rd);\n    if (idObj < 0) dstHit = dstFar;\n    reflCol = 0.8;\n  }\n  if (min (dstBall, dstHit) < dstFar) {\n    ltDir1 = normalize (vec3 (0., 1., 0.));\n    ltDir2 = normalize (vec3 (1., 1., 1.));\n    sh = 1.;\n    if (dstHit < dstBall) {\n      ro += rd * dstHit;\n      idObjT = idObj;\n      vn = ObjNf (ro);\n      idObj = idObjT;\n      if (idObj == 1) objCol = vec4 (0.25, 0.2, 0.2, 0.1);\n      else if (idObj == 2) objCol = vec4 (0.6, 0.5, 0.1, 0.4);\n      else if (idObj == 3) objCol = vec4 (0.8, 0.8, 0., 1.);\n      else if (idObj == 4) objCol = vec4 (0.6, 0.6, 0.4, 1.);\n      else if (idObj == 5) objCol = vec4 (WoodCol (ro, vn), 0.3);\n      if (idObj > 1) sh = ObjSShadow (ro, ltDir2);\n    } else {\n      vn = vnBall;\n      objCol = vec4 (HsvToRgb (vec3 (float (idBall) / float (nBall), 0.8, 1.)) *\n         BallChqr (idBall, vn), 0.8);\n    }\n    lcd = 0.4 * max (dot (vn, ltDir1), 0.) + 0.6 * sh * max (dot (vn, ltDir2), 0.);\n    lcs = pow (max (0., dot (ltDir1, reflect (rd, vn))), 64.) +\n       sh * pow (max (0., dot (ltDir2, reflect (rd, vn))), 64.);\n    col = reflCol * objCol.rgb * (0.2 + 0.8 * lcd + objCol.a * lcs);\n  } else col = mix (vec3 (0., 0., 0.6), vec3 (0., 0.4, 0.),\n       0.1 + 0.2 * (1. - smoothstep (0.8, 0.9, abs (rd.y))) *\n       Fbm2 (16. * vec2 (2. * abs (atan (rd.z, rd.x)) / pi, rd.y)));\n  return pow (clamp (col, 0., 1.), vec3 (0.7));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, p;\n  vec3 rd, ro, col, u, vd;\n  vec2 canvas, uv, us, ut, um;\n  float tCur, az, el, zmFac, asp, f, tFrac, autoRot;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dstFar = 100.;\n  p = Loadv4 (0);\n  hbLen = p.y;\n  autoRot = p.z;\n  p = Loadv4 (1);\n  aTilt = p.xy;\n  tFrac = p.z;\n  mPtr = Loadv4 (2);\n  asp = canvas.x / canvas.y;\n  el = 0.;\n  az = 0.;\n  zmFac = 2.5;\n  um = vec2 (0.4, 0.3) * vec2 (asp, 1.);\n  if (autoRot > 0.) {\n    if (mPtr.z > 0. &&\n       max (abs (mPtr.x - um.x) * asp, abs (mPtr.y - um.y)) > 0.125) {\n      az += 6. * mPtr.x;\n      el -= 5. * mPtr.y;\n      el = clamp (el, -0.1 * pi, 0.4 * pi);\n    } else {\n      el += 0.4;\n      az -= 0.1 * tCur;\n    }\n  } else {\n    az = 0.;\n    el = 0.4 * pi;\n    zmFac = 3.;\n  }\n  ro = 30. * vec3 (cos (el) * sin (az), sin (el), cos (el) * cos (az));\n  vd = normalize (vec3 (0., -1., 0.) - ro);\n  u = - vd.y * vd;\n  f = 1. / sqrt (1. - vd.y * vd.y);\n  vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  col = ShowScene (ro, rd);\n  us = uv - 2. * um;\n  ut = abs (us) - vec2 (0.25);\n  if (max (ut.x, ut.y) < 0.) {\n    if (min (abs (ut.x), abs (ut.y)) < 0.015) col = vec3 (0., 0.7, 0.);\n    else {\n      f = length (0.5 * us - (1./5.5) * aTilt) - 0.02;\n      col = mix (mix (vec3 (1., 0.8, 0.1), vec3 (0., 0., 1.),\n         step (0.005, abs (f))), vec3 (0.1, 0.1, 0.4), step (0., f));\n    }\n  }\n  ut = uv - vec2 (-0.8, 0.8) * vec2 (asp, 1.);\n  f = length (ut) - 0.06;\n  if (f < 0.) col = mix (mix (vec3 (0., 1., 0.), vec3 (1., 0., 0.),\n     step (0.5 * (atan (- ut.x, - ut.y) / pi + 1.), tFrac)),\n     vec3 (0., 1., 0.), step (0.02, abs (f + 0.03)));\n  fragColor = vec4 (col, 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Trapped Balls\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float pi = 3.14159;\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi = float (idVar);\n  vec2 d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\nmat3 VToRMat (vec3 v, float a)\n{\n  mat3 m;\n  float c, s, a1, a2;\n  c = cos (a);  s = sin (a);\n  m[0][0] = (1. - c) * v.x * v.x + c;\n  m[1][1] = (1. - c) * v.y * v.y + c;\n  m[2][2] = (1. - c) * v.z * v.z + c;\n  a1 = (1. - c) * v.x * v.y;  a2 = - s * v.z;\n  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = (1. - c) * v.z * v.x;  a2 = - s * v.y;\n  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = (1. - c) * v.y * v.z;  a2 = - s * v.x;\n  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return m;\n}\n\nmat3 QToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQ (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQ (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nconst int nBall = 36;\nvec2 canvas, aTilt;\nfloat hbLen, tCur, autoRot;\nbool running;\n\nvec2 EvalFc (vec2 u, vec2 dr, vec2 v)\n{\n  float fOvlap, fricN, rSep;\n  fOvlap = 1000.;\n  fricN = 1.;\n  rSep = length (dr);\n  return (max (u.x, u.y) < 0.7 && rSep < 0.7) ? (fOvlap * (0.7 / rSep - 1.) -\n     fricN * (dot (v, dr) / (rSep * rSep))) * dr : vec2 (0.);\n}\n\nvoid Step (int mId, out vec4 p, out vec4 qt)\n{\n  vec2 r, rn, vn, dr, dv, f, v, u, s;\n  float fOvlap, damp, fricN, grav, rSep, vm, dt;\n  fOvlap = 1000.;\n  fricN = 2.;\n  damp = 0.05;\n  grav = 10.;\n  dt = 0.02;\n  p = Loadv4 (4 + 2 * mId);\n  r = p.xy;\n  v = p.zw;\n  qt = Loadv4 (4 + 2 * mId + 1);\n  if (r.x < 2. * hbLen) {\n    f = vec2 (0.);\n    for (int n = 0; n < nBall; n ++) {\n      p = Loadv4 (4 + 2 * n);\n      rn = p.xy;\n      vn = p.zw;\n      if (rn.x < 2. * hbLen) {\n        dr = r - rn;\n        rSep = length (dr);\n        if (n != mId && rSep < 1.) {\n          dv = v - vn;\n          f += (fOvlap * (1. / rSep - 1.) -\n             fricN * (dot (dv, dr)/ (rSep * rSep))) * dr;\n        }\n      }\n    }\n    s = r - sign (r) * vec2 (hbLen, hbLen + 0.4); \n    u = vec2 (abs (s.x), abs (s.y) - hbLen + 0.4);\n    f += EvalFc (u, vec2 (s.x, max (0., u.y) * sign (s.y)), v);\n    s = r - sign (r) * vec2 (hbLen + 0.4, hbLen); \n    u = vec2 (abs (s.x) - hbLen + 0.4, abs (s.y));\n    f += EvalFc (u, vec2 (max (0., u.x) * sign (s.x), s.y), v);\n    s = r - sign (r) * vec2 (0.5 * hbLen, hbLen - 1.); \n    u = vec2 (abs (s.x), abs (s.y) - 1.);\n    f += EvalFc (u, vec2 (s.x, max (0., u.y) * sign (s.y)), v);\n    s = r - sign (r) * vec2 (hbLen - 1., 0.5 * hbLen); \n    u = vec2 (abs (s.x) - 1., abs (s.y));\n    f += EvalFc (u, vec2 (max (0., u.x) * sign (s.x), s.y), v);\n    s = r - sign (r) * vec2 (0., hbLen - 3.); \n    u = vec2 (abs (s.x) - 2., abs (s.y));\n    f += EvalFc (u, vec2 (max (0., u.x) * sign (s.x), s.y), v);\n    s = r - sign (r) * vec2 (hbLen - 3., 0.); \n    u = vec2 (abs (s.x), abs (s.y) - 2.);\n    f += EvalFc (u, vec2 (s.x, max (0., u.y) * sign (s.y)), v);\n    u = vec2 (abs (r.x) - 2., abs (r.y));\n    f += EvalFc (u, vec2 (max (0., u.x) * sign (r.x), r.y), v);\n    u = vec2 (abs (r.x), abs (r.y) - 2.);\n    f += EvalFc (u, vec2 (r.x, max (0., u.y) * sign (r.y)), v);\n    f -= damp * v;\n    f -= grav * aTilt;\n    if (running) {\n      v += dt * f;\n      r += dt * v;\n      if (min (length (abs (r) - hbLen * vec2 (0., 1.) - 0.5),\n          length (abs (r) - hbLen * vec2 (1., 0.) - 0.5)) < 0.8) r.x = 100. * hbLen;\n      vm = length (v);\n      if (vm > 1e-6) qt = RMatToQ (QToRMat (qt) *\n         VToRMat (normalize (vec3 (v.y, 0., - v.x)), vm * dt / 0.5));\n    }\n  }\n  p = vec4 (r, v);\n}\n\nvoid Init (int mId, out vec4 p, out vec4 qt)\n{\n  vec3 e;\n  vec2 r, v;\n  float a;\n  int nbEdge;\n  nbEdge = int (sqrt (float (nBall)));\n  r.y = float (mId / nbEdge);\n  r.x = float (mId) - float (nbEdge) * r.y;\n  r = 1.2 * (r - 0.5 * float (nbEdge - 1));\n  r.x += (r.x < 0.) ? -1. : 1.;\n  r.y += (r.y < 0.) ? -1. : 1.;\n  a = 77. * mod (tCur, 1.);\n  v = normalize (vec2 (Hashff (mod (a + 0.1, 1.)) - 0.5,\n     Hashff (2. * mod (a + 0.3, 1.)) + 0.05));\n  v = vec2 (0.);\n  p = vec4 (r, v);\n  a = mod (tCur, 1.) + float (mId) / float (nBall);\n  e = normalize (vec3 (Hashff (mod (a, 1.)),\n     Hashff (mod (a + 0.2, 1.)), Hashff (mod (a + 0.4, 1.))));\n  qt = EulToQ (vec3 (atan (e.x, e.y), acos (e.z),\n     2. * pi * Hashff (mod (a + 0.6, 1.))));\n}\n\nvoid SetTilt (inout vec2 aTilt, vec4 mPtr)\n{\n  vec2 um, ud;\n  float aLim, asp;\n  aLim = 0.5;\n  if (mPtr.z > 0.) {\n    asp = canvas.x / canvas.y;\n    um = vec2 (0.4, 0.3) * vec2 (asp, 1.);\n    ud = mPtr.xy * vec2 (asp, 1.) - um;\n    if (max (abs (ud.x), abs (ud.y)) < 0.13) {\n      autoRot = 0.;\n      aTilt = 5.5 * ud;\n      aTilt = clamp (aTilt, - aLim, aLim);\n    }\n  } else aTilt = vec2 (0.);\n  if (autoRot > 0.) aTilt = aLim * vec2 (sin (0.1 * tCur), - cos (0.1 * tCur));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, stDat, p, qt;\n  float nStep, tGame, tBgn;\n  int mId, pxId, nIn;\n  bool doInit;\n  vec2 kv = floor (fragCoord);\n  pxId = int (kv.x + txRow * kv.y);\n  if (kv.x >= txRow || pxId >= 2 * nBall + 4) discard;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  if (pxId >= 4) mId = (pxId - 4) / 2;\n  else mId = -1;\n  autoRot = 1.;\n  doInit = false;\n  tGame = 120.;\n  tBgn = tCur;\n  nStep = 0.;\n  if (iFrame <= 5) {\n    hbLen = 1.1 * sqrt (float (nBall)) + 2.;\n    aTilt = vec2 (0.);\n    if (mId >= 0) doInit = true;\n  } else {\n    p = Loadv4 (0);\n    nStep = p.x;\n    hbLen = p.y;\n    autoRot = p.z;\n    p = Loadv4 (1);\n    aTilt = p.xy;\n    tBgn = p.w;\n    ++ nStep;\n    SetTilt (aTilt, mPtr);\n    running = (tCur - tBgn > 1.);\n    if (mId >= 0) Step (mId, p, qt);\n    nIn = 0;\n    for (int n = 0; n < nBall; n ++) {\n      if (Loadv4 (4 + 2 * n).x < 2. * hbLen) ++ nIn;\n    }\n    if (nIn == 0 || tCur > tBgn + tGame) doInit = true;\n  }\n  if (doInit) {\n    if (mId >= 0) Init (mId, p, qt);\n    nStep = 0.;\n    autoRot = 1.;\n    tBgn = tCur;\n  }\n  if (pxId == 0) stDat = vec4 (nStep, hbLen, autoRot, 0.);\n  else if (pxId == 1) stDat = vec4 (aTilt, (tCur - tBgn) / tGame, tBgn);\n  else if (pxId == 2) stDat = mPtr;\n  if (pxId == 4 + 2 * mId + 1) p = qt;\n  Savev4 (pxId, ((pxId >= 4) ? p : stDat), fragColor, fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}