{
    "Shader": {
        "info": {
            "date": "1703098905",
            "description": "The simplest diffuse sphere code",
            "flags": 0,
            "hasliked": 0,
            "id": "lcs3WN",
            "likes": 1,
            "name": "YT shader",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "Andreuicncuza",
            "viewed": 170
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926535\n#define NUM_OF_SPHERES 4\n\nstruct Ray {\n    vec3 o;\n    vec3 d;\n};\n\nstruct Material {\n    vec3 albedo;\n    float persistence;\n    bool diffuse;\n};\n\nstruct Sphere {\n    vec3 c;\n    float r;\n    Material mat;\n};\n\nstruct Record { \n    vec3 p;\n    float t;\n    vec3 n;\n    Material mat;\n    bool didHit;\n};\n\nvec2 randState;\n\nfloat hash( const float n ) \n{\n     return fract(sin(n)*43758.54554213);\n}\n\n\nfloat rand2D()\n{\n    randState.x = fract(sin(dot(randState.xy, vec2(12.9898, 78.233))) * 43758.5453);\n    randState.y = fract(sin(dot(randState.xy, vec2(12.9898, 78.233))) * 43758.5453);;\n    \n    return randState.x;\n}\n\n\n// random direction in unit sphere (for lambert brdf)\nvec3 random_in_unit_sphere()\n{\n    float phi = 2.0 * PI * rand2D();\n    float cosTheta = 2.0 * rand2D() - 1.0;\n    float u = rand2D();\n\n    float theta = acos(cosTheta);\n    float r = pow(u, 1.0 / 3.0);\n\n    float x = r * sin(theta) * cos(phi);\n    float y = r * sin(theta) * sin(phi);\n    float z = r * cos(theta);\n\n    return vec3(x, y, z);\n}\n\nvec3 random_in_hemisphere(vec3 normal)\n{\n    vec3 rand = random_in_unit_sphere();\n    if (dot(normal, rand) < 0.0)\n        return -rand;\n    return rand;\n}\n\n\nSphere SPHERES[] = Sphere[NUM_OF_SPHERES](\n    Sphere(\n        vec3(.05,0,-.3)*5.0,\n        1.0,\n        Material(vec3(.9,.2,.2), 0.9, false)  \n    ),\n    Sphere(\n        vec3(.0,.0,.1)*5.0,\n        0.4,\n        Material(vec3(.2,.2,.9), 0.9, false)  \n    ),\n    Sphere(\n        vec3(0,0,-.3),\n        0.5,\n        Material(vec3(0.2,0.2,.9)*5.0, 0.8, true)  \n    ),\n    Sphere(\n        vec3(0,-1.0,-.3),\n        0.2,\n        Material(vec3(0.2,0.8,.9)*5.0, 0.8, true)  \n    )\n);\n\nRecord hit(Ray r, Sphere s){\n    Record info;\n    vec3 oc = r.o - s.c;\n    float a = dot(r.d, r.d);\n    float b = dot(oc, r.d);\n    float c = dot(oc, oc) - s.r * s.r;\n\n    float disc = b*b - a * c;\n\n    if (disc > 0.0){\n        float t = (-b - sqrt(disc)) / a;\n        vec3 p = r.o + r.d * t;\n        info.didHit = true;\n        info.t = t;\n        info.n = (p - s.c) / s.r;\n        info.p = p;\n        info.mat = s.mat;\n        return info;\n    }\n\n    info.didHit = false;\n    return info;\n}\n\nRecord hit_world(Ray r){\n    Record info;\n    info.t = 99999999.0;\n\n    for (int i = 0; i < NUM_OF_SPHERES; i++){\n        Sphere s = SPHERES[i];\n        Record tempinfo = hit(r, s);\n        if (tempinfo.didHit && tempinfo.t < info.t && tempinfo.t > 0.0){\n            info = tempinfo;\n        }\n    }\n\n    return info;\n}\n\nRay calculateRay(vec3 lookTo, vec3 CameraOrigin, vec2 ScaledDown){\n    vec3 forwad = normalize(lookTo - CameraOrigin);\n    vec3 right = normalize(cross(forwad, vec3(0, 1,0)));\n    vec3 up = normalize(cross(forwad, right));\n    vec3 direction = forwad + right * ScaledDown.x + up * ScaledDown.y;\n    return Ray(CameraOrigin, direction); \n}\n\nvec3 background(Ray r){\n    return vec3(0);\n}\n\nvec3 rayColor(Ray r){\n    vec3 col = vec3(1);\n    for (int i = 0; i <= 20; i++){\n        Record info = hit_world(r);\n        if (info.didHit){\n            r.o = info.p;\n            r.d = random_in_hemisphere(info.n);\n            if (info.mat.diffuse){\n                col *= info.mat.persistence;\n            }\n            else{\n                col *= info.mat.albedo;\n                break;\n                }\n        }else{\n            col *= background(r);\n            break;\n        }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    randState = fragCoord.xy / iResolution.xy;\n    vec2 uv = randState - 0.5;\n    vec2 ScaledDown = iResolution.xy / 400.0 * uv;\n    float t = iTime;\n    t = fract(t/20.);\n    t+=0.4;\n    if (t<0.5){\n        t = 4. * t * t;\n    }else {\n        t = 1. - pow(-2.0*t + 2.,3.)/2.;\n    }\n    \n    t*= 10.;\n \n    \n    Ray r = calculateRay(\n        vec3(0,0,0),\n        vec3(sin(t), 0, cos(t)) * 2.7,\n        ScaledDown\n    );\n\n    vec3 color = rayColor(r);\n   \n    fragColor = vec4(color, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}