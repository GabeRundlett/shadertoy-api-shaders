{
    "Shader": {
        "info": {
            "date": "1514617894",
            "description": "They are running. Me too.\n*Please be careful for sound volume!*",
            "flags": 96,
            "hasliked": 0,
            "id": "MtjBRh",
            "likes": 47,
            "name": "RUN!RUN!RUN!",
            "published": 3,
            "tags": [
                "terrain",
                "animation",
                "man",
                "run"
            ],
            "usePreview": 0,
            "username": "iY0Yi",
            "viewed": 1904
        },
        "renderpass": [
            {
                "code": "//\n//\n// Commmons\n//\n//\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (sqrt(5)*0.5 + 0.5)\n#define MIN_DIST 0.001\n#define MAX_DIST 20000.0\n#define saturate(x) clamp(x, 0, 1)\nhighp float hash(highp float seed);\nvec2 hash2(float n);\nvec3 hash3(float n);\nvec4 seed = vec4(0);\nfloat rnd(inout vec4 seed);\n#define rndf rnd(seed)\n#define rndv2 vec2(rndf, rndf)\n#define rndv3 vec3(rndf, rndf, rndf)\n\n//\n//\n// \"Anti Aliasing Test\" by @VoidChicken\n// https://www.shadertoy.com/view/MsVGDK\n//\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 v = 1.0/iChannelResolution[0].xy;\n    vec4 col = texture(iChannel0, uv);\n    vec4 col2 = texture(iChannel0, uv+vec2(v.x, 0));\n    \n    col2+= texture(iChannel0, uv-vec2(v.x, 0));\n    col2+= texture(iChannel0, uv+vec2(0, v.y));\n    col2+= texture(iChannel0, uv-vec2(0, v.y));\n    \n    col2+= texture(iChannel0, uv+vec2(v.x, v.y));\n    col2+= texture(iChannel0, uv+vec2(v.x, -v.y));\n    col2+= texture(iChannel0, uv+vec2(-v.x, v.y));\n    col2+= texture(iChannel0, uv+vec2(-v.x, -v.y));\n    \n    col2/=8.0;\n    col += col2;\n    col/=2.0;\n\n    \n    //vignet\n    col.xyz *= pow(8.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y), 0.1);\n    \n    //float c = (iMouse.x/800.0)*10.0;\n    //float b = (iMouse.y/800.0)*1.0;\n    //brightness & contrast\n    col.xyz = col.xyz * 1.425;//1.8;\n\tcol.xyz = col.xyz + -0.025;//-0.0125;\n    float flicker = clamp((hash(iTime*1000.0))*1000.0, 100.0, 300.0)*0.001;\n    col.xyz *= 1.0-flicker*0.35;\n    //gamma\n    col.xyz = pow(col.xyz, vec3(0.4555));\n    \n    fragColor = col;\n}\n\nhighp float hash(highp float seed){return fract(sin(seed)*43758.5453);}vec2 hash2(float n){return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123));}\nvec3 hash3(float n){return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));}highp float rnd(inout vec4 n){const vec4 q=vec4(\n1225.0,1585.0,2457.0,2098.0);const vec4 r=vec4(1112.0,367.0,92.0,265.0);const vec4 a=vec4(3423.0,2646.0,1707.0,1999.0);const vec4 m=vec4(4194287.0,4194277.0,\n4194191.0,4194167.0);vec4 beta=floor(n/q);vec4 p=a*(n-beta*q)-beta*r;beta=(sign(-p)+vec4(1.0))*vec4(0.5)*m;n=(p+beta);return fract(dot(n/m,vec4(1.0,-1.0,1.0,\n-1.0)));}vec4 rnd4(){return vec4(rnd(seed),rnd(seed),rnd(seed),rnd(seed));}float hash(vec2 p){p=50.0*fract(p*0.3183099+vec2(0.71,0.113));return -1.0+2.0*fract(\np.x*p.y*(p.x+p.y));}float noise(in vec2 p){vec2 i=floor(p);vec2 f=fract(p);vec2 u=f*f*(3.0-2.0*f);return mix(mix(hash(i+vec2(0.0,0.0)),hash(i+vec2(1.0,0.0)),\nu.x),mix(hash(i+vec2(0.0,1.0)),hash(i+vec2(1.0,1.0)),u.x),u.y);}vec3 rotx(vec3 p,float rx){float sinx=sin(rx);float cosx=cos(rx);return mat3(1.,0.,0.,0.,cosx,\nsinx,0.,-sinx,cosx)*p;}vec3 roty(vec3 p,float ry){float sinx=sin(ry);float cosx=cos(ry);return mat3(cosx,0.,-sinx,0.,1.,0.,sinx,0.,cosx)*p;}vec3 rotz(vec3 p,\nfloat rz){float sinx=sin(rz);float cosx=cos(rz);return mat3(cosx,sinx,0.,-sinx,cosx,0.,0.,0.,1.)*p;}vec3 rot(vec3 p,vec3 r){return rotx(roty(rotz(p,r.z),r.y),\nr.x);}mat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,s,-s,c);}mat3 rot(vec3 n,float a){float s=sin(a),c=cos(a),k=1.0-c;return mat3(n.x*n.x*k+c,n.y*\nn.x*k-s*n.z,n.z*n.x*k+s*n.y,n.x*n.y*k+s*n.z,n.y*n.y*k+c,n.z*n.y*k-s*n.x,n.x*n.z*k-s*n.y,n.y*n.z*k+s*n.x,n.z*n.z*k+c);}float sgn(float x){return(x<0.0)?-1.0:1.0\n;}vec2 sgn(vec2 v){return vec2((v.x<0.0)?-1.0:1.0,(v.y<0.0)?-1.0:1.0);}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 12958,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/editionsmego/luc-ferrari-heterozygote-excerpt-regrm-017"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//\n//\n// Commmons\n//\n//\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (sqrt(5)*0.5 + 0.5)\n#define MIN_DIST 0.001\n#define MAX_DIST 20000.0\n#define saturate(x) clamp(x, 0, 1)\nfloat TIME = 0.0;\nvoid updateAnimations(float idx, float idz);\nhighp float hash(highp float seed);\nvec2 hash2(float n);\nvec3 hash3(float n);\nvec4 seed = vec4(0);\nfloat rnd(inout vec4 seed);\n#define rndf rnd(seed)\n#define rndv2 vec2(rndf, rndf)\n#define rndv3 vec3(rndf, rndf, rndf)\nfloat noise(in vec2 p);\nvec3 rotx(vec3 p, float rx);\nvec3 roty(vec3 p, float ry);\nvec3 rotz(vec3 p, float rz);\nvec3 rot(vec3 p, vec3 r);\n\n\n//\n//\n// Ray Marching\n//\n//\nfloat udBox(vec3 p, vec3 b);\nfloat sdPlane(in vec3 p);\nfloat sdSphere(in vec3 p, in float r);\nfloat sdBox(vec3 p, vec3 b);\nfloat sdCylinder(vec3 p, vec2 h);\nfloat sdCapsule(vec3 p,float r,float c);\nfloat sdEllipsoid(in vec3 p, in vec3 r);\nfloat sdConeSection(in vec3 p, in float h, in float r1, in float r2);\nfloat sdCorner (vec2 p);\n\nvec2 opSmin(vec2 a, vec2 b, float k);\nvec2 opMin(in vec2 a, in vec2 b);\n\n\n//\n//\n//  Scene\n//\n//\n#define MAT_BLACK 8.0\n#define MAT_SKIN 5.0\n#define MAT_TERRAIN 2.0\n#define MAT_BB -10.0\nfloat terrainHeight(vec2 coord)\n{\n\tfloat speed = 0.2;\n\treturn\n    noise(coord * 0.0015) * sin(TIME * speed * 0.05) * 400.0 +\n    noise(coord * 0.0005) * cos(TIME * speed * 0.005) * 400.0;\n}\nvec3 mapTerrain( in vec3 p)\n{\n\tfloat h = terrainHeight(p.xz);\n\treturn vec3(sdPlane(vec3(p.x,p.y+h,p.z)), MAT_TERRAIN, h);\n}\nvec3 calcTerrainNormal( in vec3 p)\n{\n    float eps = MIN_DIST*2.0;\n    #define f terrainHeight\n    return normalize(vec3(f(vec2(p.x-eps,p.z)) - f(vec2(p.x+eps,p.z)),\n\t\t\t\t\t2.0*eps,\n\t\t\t\t\tf(vec2(p.x,p.z-eps)) - f(vec2(p.x,p.z+eps))));\n}\nvec2 sdMan(vec3 p);\nvec2 mapMen( in vec3 p, vec2 res)\n{\n\tp.y -= 5.2;\n\tp.z -= TIME * 10.1;\n\n\tfloat margin = 80.0;\n\tvec3 c = vec3(margin, 0.0, margin);\n\tvec3 q = p + c * 0.5;\n\tfloat idx = hash(floor(q.x / c.x)) + 0.01;\n\tfloat idz = hash(floor(q.z / c.z)) + 0.01;\n\n\tq.z += sin(TIME * 0.35);\n\tq.xz = mod(q.xz, c.xz) - 0.5 * c.xz;\n\n\tq.x -= hash(idz) * c.x * 0.25;\n\tq.z -= hash(idx) * c.z * 0.25;\n\tfloat s = 5.0;\n\tfloat timeOffset = hash(idx + idz);\n\tTIME += timeOffset * s;\n\tupdateAnimations(idx, idz);\n\tres = opMin(res, sdMan(q));\n\tTIME -= timeOffset * s;\n\tupdateAnimations(idx, idz);\n\treturn res;\n}\n\nvec2 map( in vec3 p)\n{\n\tvec3 resTerrain = mapTerrain(p);\n\tvec2 res = resTerrain.xy;\n\tp.y += resTerrain.z;\n\tres = mapMen(p, res);\n    res.x+=hash(p.x+p.y+p.z*res.x)*(36.0/800.0)*0.01; //edit: added noise here.\n\treturn res;\n}\n\nvec3 calcNormal(vec3 p, float t);\nvec2 marchRay( in vec3 ro, in vec3 rd, in bool forShadow)\n{\n\tfloat t = (forShadow)?0.0:-MAX_DIST*0.05; //edit: avoid slising artefact\n\tfor (int i = 0; i < 1500; i++)\n\t{\n\t\tvec3 p = ro + t * rd;\n\t\tif (length(p) > MAX_DIST) break;\n\n\t\tvec2 res = map(p);\n\n\t\tif (res.x < MIN_DIST*10.0) return vec2(t, res.y);\n\t\tif (res.x >= MAX_DIST*0.1) break;\n\n\t\tt += res.x;\n\t}\n\treturn vec2(-1.0);\n}\n\n\n//\n//\n//  Rendering\n//\n//\nvec3 LIGHT_DIR = vec3(0);\nfloat calcShadow(vec3 p)\n{\n\tvec2 res = marchRay(p, LIGHT_DIR, true);\n\treturn (res.x < MIN_DIST*1.0) ? 1.0 : 0.0;\n}\nfloat render( in vec3 ro, in vec3 rd)\n{\n    vec2 res = marchRay(ro, rd, false);\n    if (res.y < -0.5) return 1.0;\n    \n    vec3 p = ro + res.x * rd;\n    vec3 n = calcNormal(p, res.x);\n    float mat = 1.0;\n    \n    float borderRatio = max(iResolution.x, iResolution.y)/2560.0*0.6;\n    float lineZ = abs(fract(p.z * borderRatio + 0.3 * TIME)-.5);\n    \n    float anitialiasingRatio = distance(ro,p)/(MAX_DIST*0.5); //edit: distance based antialiasing\n    float stepStart = 0.26;\n    float stepEnd = 0.1*anitialiasingRatio;\n    mat = (res.y > MAT_TERRAIN-1.0) ? (mix(0.5, 1.0, smoothstep(stepStart, stepStart+stepEnd,lineZ))):1.0;\n    mat = (res.y > MAT_SKIN-1.0) ? 1.0:mat;\n    mat = (res.y > MAT_BLACK-1.0) ? 1.0:mat;\n\n    float offsetRatio = (res.y > MAT_SKIN-1.0)?0.02:1.0; //edit: man has closer offset. terrain has more far.\n    vec3 pOffset = n * offsetRatio;\n    float shadow = calcShadow(p+pOffset);\n    float light1 = pow(clamp(dot(n+pOffset, LIGHT_DIR), 0.0, 1.0), 0.95);\n    float light2 = pow(clamp(dot(n+pOffset, -LIGHT_DIR), 0.0, 1.0), 1.5);\n    light1 = (offsetRatio!=1.0)?smoothstep(0.0,0.95, light1):smoothstep(0.0,1.95, light1);\n    \n    float shade = 0.0;\n    shade += 1.0 * (light1 *0.975+0.025);\n    shade = min(shade,shadow*0.9+0.1);\n    shade += (res.y > MAT_SKIN-1.0) ?light2*0.15:light2*0.1;\n    shade += (res.y > MAT_SKIN-1.0) ? 0.0125:0.0;\n    \n    float col = mat*shade;\n    col = mix(col, 1.0, pow(distance(ro, p) * 1.0 / MAX_DIST, 5.0));\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat col = 1.0;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0 * uv;\n\tp.x *= iResolution.x / iResolution.y;\n\n\tseed.x = hash(fragCoord.x + iTime);\n\tseed.y = hash(fragCoord.y + mod(iTime, float(iTime / 60.0)));\n\tseed.z = hash(seed.x + seed.y + iTime);\n\tseed.w = hash(dot(seed.xyz, vec3(1.0)));\n\n\tTIME = iTime * 10.0;\n\tLIGHT_DIR = normalize(vec3(-0.5, 0.5, 0.5));\n\t// camera\n\tfloat speed = 0.0028;\n\tfloat camDist = (cos(TIME * 0.005) + 1.0) * 0.5;\n\n\tvec3 eye = vec3(cos(TIME * speed) * 10000.0, 0.0, sin(TIME * speed) * 10000.0) * camDist;\n\teye.y = terrainHeight(eye.xz);\n\tvec3 n = calcTerrainNormal(eye);\n\teye = eye + n * 700.0;\n\tvec3 look = vec3(0.0, 1.0, 0.0);\n\tvec3 up = rot(vec3(0.0, 1.0, 0.0), vec3((cos(TIME * 0.002) * 0.5 + 0.5), (sin(TIME * 0.02) * 0.5 + 0.5), 0.0) * PI * 2.0);\n    \n\tvec3 w = normalize(look - eye);\n\tvec3 u = normalize(cross(w, up));\n\tvec3 v = normalize(cross(u, w));\n\n\t//a little bit adjustment...\n\tfloat ZOOM_SPEED = 1.0 / 3.0;\n\tfloat ZOOM_START = 115.0 * ZOOM_SPEED;\n\tfloat ZOOM_END = ZOOM_START * ZOOM_SPEED + PI;\n\tfloat zoom =\n\t\t(iTime * ZOOM_SPEED < ZOOM_START && iTime * ZOOM_SPEED > ZOOM_END) ?\n\t\t0.0 :\n\t\tsin(iTime * ZOOM_SPEED - ZOOM_START) * 50.0;\n\n\tvec3 rd = normalize(p.x * u + p.y * v + (100.0 + zoom) * w);\n\tcol = render(eye, rd);\n\tfragColor = vec4(vec3(col), 1.0);\n}\n\n\n//\n//\n//  Man\n//  cyclic animation is based on:\n//  \"Running man\" by @bmontell\n//\thttps://www.shadertoy.com/view/Xdy3Rd\n//\n//\nfloat TORSO_LEAN = 0.0;\nfloat TORSO_TWIST = 0.0;\nfloat TORSO_BOUNCE = 0.0;\nfloat HEAD_BOB = 0.0;\nfloat LEG_BOUNCE = 0.0;\nfloat L_LEG_SWING = 0.0;\nfloat R_LEG_SWING = 0.0;\nfloat L_KNEE_BEND = 0.0;\nfloat R_KNEE_BEND = 0.0;\nfloat L_ANKLE_BEND = 0.0;\nfloat R_ANKLE_BEND = 0.0;\nvec3 L_ARM_SWING = vec3(0.0);\nvec3 R_ARM_SWING = vec3(0.0);\nfloat L_ELBOW_BEND = 0.0;\nfloat R_ELBOW_BEND = 0.0;\nvec2 sdLeg(vec3 p, float r, vec2 h, float legSwing, float kneeBend, float ankleBend);\nvec2 sdLegs(vec3 p);\nvec2 sdArm(vec3 p, vec3 swing, float elbowBend);\nvec2 sdArms(vec3 p);\nvec2 sdHead(vec3 p);\nvec2 sdBody(inout vec3 p);\nvoid updateAnimations(float idx, float idz)\n{\n\t//idx, idz... 0.0 - 1.0\n    float as = hash(idx+idz*10.0);\n    float s = sin(as*345.0 * PI);\n    float ac = hash(idx*123.0*idz);\n\tfloat c = cos(ac*223.0 * PI);\n    float f = (idx + idz)*0.5+0.5;\n\tTORSO_LEAN = -0.2 + s * 0.25 + cos(TIME * 3.0 * idx * idz) * 0.15;\n\tTORSO_TWIST = 0.3*ac * sin(0.5 + TIME);\n\tTORSO_BOUNCE = -1.0 * clamp(sin(TIME * 2.0 + 0.4) * 1.2, -0.5, 0.9) + abs(sin(TIME + 0.4));\n\tHEAD_BOB = -0.35 * (1.0 - clamp(sin(2.0 * (TIME - 1.0)) * 1.1, -0.5, 1.0));\n\tLEG_BOUNCE = -1.0 * sin(TIME * 2.0 + 0.0) * 1.2 + abs(sin(TIME + 0.4)) * 2.0;\n\tL_LEG_SWING = (.8*ac+0.2) * sin(TIME);\n\tR_LEG_SWING = (-.8*ac-0.2) * sin(TIME);\n\tL_KNEE_BEND = -0.6*as-0.2 * (1.0 + sin(TIME + 1.7));\n\tR_KNEE_BEND = -0.6*as-0.2 * (1.0 - sin(TIME + 1.7));\n\tL_ANKLE_BEND = 0.3*as-0.2 * (1.0 + sin(TIME + 1.));\n\tR_ANKLE_BEND = 0.3*as-0.2 * (1.0 - sin(TIME + 1.));\n    #define ff(x) ((x/800.0)-0.5)*2.0\n\tL_ARM_SWING = vec3(-0.5*sin(TIME)*(as+0.5),0.5*s*0.5,-0.25*ac-0.5);//vec3(ff(iMouse.x),ff(iMouse.y),ff(iMouse.z));//vec3(-1.5 * sin(TIME) * (ac+0.4), 0.6*as+0.2, -0.5*ac+as*0.1);\n\tR_ARM_SWING = -L_ARM_SWING;//vec3(0.9 * sin(TIME), -0.1, 0.4);\n\tL_ELBOW_BEND = mix(1.0*ac+0.5, 1.0*(ac+0.5)+0.5, 1.0 - (sin(TIME + 0.3) + 0.3 * sin(2.0 * (TIME + 0.3))));\n\tR_ELBOW_BEND = mix(1.0*ac+0.5, 1.0*(ac+0.5)+0.5, 1.0 + (sin(TIME + 0.3) + 0.3 * sin(2.0 * (TIME + 0.3))));\n}\nvec2 sdLeg(vec3 p, float r, vec2 h, float legSwing, float kneeBend, float ankleBend)\n{\n\tvec3 cylOffset = vec3(0.0, h.y, 0.0);\n\tp.y -= LEG_BOUNCE;\n\tp = rotx(p - 2.0 * cylOffset, legSwing) + 2.0 * cylOffset; // Swing upper leg.\n\n\t// Knee\n\tvec2 d = vec2(sdSphere(p, r), MAT_BLACK);\n\n\t// Thigh\n\td = opSmin(d, vec2(sdEllipsoid(p - cylOffset, vec3(0.8, h.y, 0.8)), MAT_BLACK), 0.4);\n\tp = rotx(p, kneeBend); // Swing lower leg.\n\n\t// Shin\n\td = opSmin(d, vec2(sdEllipsoid(p + cylOffset - vec3(0., 0.5, 0.), vec3(0.6, h.y, 0.6)), MAT_BLACK), 0.4);\n\td = vec2(min(d.x, sdCylinder(p + cylOffset + vec3(0., 0.35, 0.), vec2(0.6, 0.7))), MAT_BLACK);\n\tvec3 ty = vec3(0.0, 2.0 * h.y, 0.0);\n\tp = rotx(p + ty, ankleBend); // Swing foot.\n\n\t// Foot\n\tvec3 tz = vec3(0.0, 0.0, -0.7);\n\td = opSmin(d, vec2(sdEllipsoid(p + tz, vec3(0.45, 0.3, 0.7)), MAT_SKIN), 0.4);\n\n\treturn d;\n}\n\nvec2 sdLegs(vec3 p)\n{\n\tvec3 BB = vec3(8.0, 7.5, 11.0);\n\tfloat bd = udBox(p - vec3(0, 0, -1.5), BB);\n\tif (bd > 0.9)\n\t{\n\t\treturn vec2(bd, MAT_BB);\n\t}\n\n\tvec2 legDimens = vec2(0.3, 1.9);\n\tvec3 legDisp = vec3(0.9, 0.0, 0.0);\n\tvec3 q = p;\n\tq.y += 1.7;\n\treturn opMin(\n\t\tsdLeg(q - legDisp, 0.1, legDimens, L_LEG_SWING, L_KNEE_BEND, L_ANKLE_BEND),\n\t\tsdLeg(q + legDisp, 0.1, legDimens, R_LEG_SWING, R_KNEE_BEND, R_ANKLE_BEND));\n}\n\nvec2 sdArm(vec3 p, vec3 swing, float elbowBend)\n{\n\tp = rot(p, swing);\n\n\t// Shoulder\n\tvec2 d = vec2(sdEllipsoid(p, vec3(0.3, 0.3, 0.4)), MAT_BLACK);\n\n\t// Upper arm\n\tvec3 upperArmDimens = vec3(0.6, 1.3, 0.6);\n\td = opSmin(d, vec2(sdEllipsoid(p + vec3(0.0, upperArmDimens.y, 0.0), upperArmDimens), MAT_BLACK), 0.4);\n\t// Rotate at elbow\n\tp.y += 2.0 * upperArmDimens.y;\n\tp = rotx(p, elbowBend);\n\n\t// Elbow\n\td = opSmin(d, vec2(sdSphere(p, 0.2), MAT_BLACK), 0.4);\n\n\t// Lower arm\n\tvec3 lowerArmDimens = vec3(0.5, 1.3, 0.5);\n\td = opSmin(d, vec2(sdEllipsoid(p + vec3(0.0, lowerArmDimens.y, 0.0), lowerArmDimens), MAT_BLACK), 0.8);\n\td = opMin(d, vec2(sdCylinder(p + vec3(0., 1.95, 0.), vec2(0.5, 0.5)), MAT_BLACK));\n\n\t// Hand\n\tp.y += 2.0 * lowerArmDimens.y;\n\td = opSmin(d, vec2(sdEllipsoid(p + vec3(0.0, 0.0, 0.0), vec3(0.25, 0.3, 0.25)), MAT_SKIN), 0.2);\n\n\treturn d;\n}\n\nvec2 sdArms(vec3 p)\n{\n\tvec3 bb = vec3(8.0, 4.0, 6.0);\n\tfloat bd = udBox(p - vec3(0, -2, 1.5), bb);\n\tif (bd > 1.0)\n\t{\n\t\treturn vec2(bd, MAT_BB);\n\t}\n\n\tvec3 armDisp = vec3(1.2, 0.0, 0.0);\n\treturn opMin(\n\t\tsdArm(p - armDisp, vec3(L_ARM_SWING), L_ELBOW_BEND),\n\t\tsdArm(p + armDisp, vec3(R_ARM_SWING), R_ELBOW_BEND));\n}\n\nvec2 sdHead(vec3 p)\n{\n\tp.y -= 2.5;\n\tp = rotx(p, HEAD_BOB);\n\tp.y -= 1.0;\n\n\tvec2 d;\n\td = vec2(sdEllipsoid(p, vec3(0.5)), MAT_SKIN);\n\treturn d;\n}\n\nvec2 sdBody(inout vec3 p)\n{\n\tp.y -= TORSO_BOUNCE + 4.9;\n\tp.z -= 0.2;\n\tp = rotx(p, TORSO_LEAN);\n\tp = roty(p, TORSO_TWIST);\n\n\tvec2 d;\n\td = vec2(sdEllipsoid(p + vec3(0.0, 0.25, 0.0), vec3(1.6, 2.6, 1.4)), MAT_BLACK);\n\td = opSmin(d, vec2(sdEllipsoid(p + vec3(0.0, 1.35, 0.0), vec3(1.6, 2.6, 1.6)), MAT_BLACK), 0.4);\n\td = opMin(d, vec2(sdConeSection(p + vec3(0., 1.65 + 1.65, 0.), 2.5, 2.0, 1.6), MAT_BLACK));\n\td = opSmin(d, vec2(sdEllipsoid(p + vec3(0.0, -0.9, 0.0), vec3(1.8, 1.6, 1.3)), MAT_BLACK), 0.4);\n\n\treturn d;\n}\n\nvec2 sdMan(vec3 p)\n{\n\tvec3 BB = vec3(14.0, 25.5, 18.0);\n\tfloat bd = udBox(p - vec3(0, 3, -1), BB);\n\tif (bd > 0.01)\n\t{\n\t\treturn vec2(bd, MAT_BB);\n\t}\n\tvec2 res = sdLegs(p);\n\tres = opSmin(res, sdBody(p), 0.85);\n\tres = opSmin(res, sdArms(p - vec3(0.0, 1.8, 0.0)), 0.9);\n\tres = opMin(res, sdHead(p));\n\treturn res;\n}\n\nhighp float hash(highp float seed){return fract(sin(seed)*43758.5453);}vec2 hash2(float n){return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123));}\nvec3 hash3(float n){return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));}highp float rnd(inout vec4 n){const vec4 q=vec4(\n1225.0,1585.0,2457.0,2098.0);const vec4 r=vec4(1112.0,367.0,92.0,265.0);const vec4 a=vec4(3423.0,2646.0,1707.0,1999.0);const vec4 m=vec4(4194287.0,4194277.0,\n4194191.0,4194167.0);vec4 beta=floor(n/q);vec4 p=a*(n-beta*q)-beta*r;beta=(sign(-p)+vec4(1.0))*vec4(0.5)*m;n=(p+beta);return fract(dot(n/m,vec4(1.0,-1.0,1.0,\n-1.0)));}vec4 rnd4(){return vec4(rnd(seed),rnd(seed),rnd(seed),rnd(seed));}float hash(vec2 p){p=50.0*fract(p*0.3183099+vec2(0.71,0.113));return -1.0+2.0*fract(\np.x*p.y*(p.x+p.y));}float noise(in vec2 p){vec2 i=floor(p);vec2 f=fract(p);vec2 u=f*f*(3.0-2.0*f);return mix(mix(hash(i+vec2(0.0,0.0)),hash(i+vec2(1.0,0.0)),\nu.x),mix(hash(i+vec2(0.0,1.0)),hash(i+vec2(1.0,1.0)),u.x),u.y);}vec3 rotx(vec3 p,float rx){float sinx=sin(rx);float cosx=cos(rx);return mat3(1.,0.,0.,0.,cosx,\nsinx,0.,-sinx,cosx)*p;}vec3 roty(vec3 p,float ry){float sinx=sin(ry);float cosx=cos(ry);return mat3(cosx,0.,-sinx,0.,1.,0.,sinx,0.,cosx)*p;}vec3 rotz(vec3 p,\nfloat rz){float sinx=sin(rz);float cosx=cos(rz);return mat3(cosx,sinx,0.,-sinx,cosx,0.,0.,0.,1.)*p;}vec3 rot(vec3 p,vec3 r){return rotx(roty(rotz(p,r.z),r.y),\nr.x);}mat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,s,-s,c);}mat3 rot(vec3 n,float a){float s=sin(a),c=cos(a),k=1.0-c;return mat3(n.x*n.x*k+c,n.y*\nn.x*k-s*n.z,n.z*n.x*k+s*n.y,n.x*n.y*k+s*n.z,n.y*n.y*k+c,n.z*n.y*k-s*n.x,n.x*n.z*k-s*n.y,n.y*n.z*k+s*n.x,n.z*n.z*k+c);}float sgn(float x){return(x<0.0)?-1.0:1.0\n;}vec2 sgn(vec2 v){return vec2((v.x<0.0)?-1.0:1.0,(v.y<0.0)?-1.0:1.0);}\nvec2 opSmin(vec2 a,vec2 b,float k){float h=clamp(0.5+0.5*(b.x-a.x)/k,0.0,1.0);return mix(b,a,h)-k*h*(1.0-h);}vec2 opMin(in vec2 a,in vec2 b){return a.x<b.x?a:b\n;}\nfloat vmax(vec2 v){return max(v.x, v.y);}float vmax(vec3 v){return max(max(v.x, v.y),v.z);}float vmax(vec4 v){return max(max(v.x,v.y),max(v.z,v.w));}float\nsdPlane(in vec3 p){return p.y;}float sdSphere(in vec3 p,in float r){return length(p)-r;}float sdCylinder(vec3 p,vec2 h){vec2 d=abs(vec2(length(p.xz),p.y))-h;\nreturn min(max(d.x,d.y),0.0)+length(max(d,0.0));}float sdEllipsoid(in vec3 p,in vec3 r){return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);}float sdConeSection(in\nvec3 p,in float h, in float r1,in float r2){float d1=-p.y-h;float q=p.y-h;float si=0.5*(r1-r2)/h;float d2=max(sqrt(dot(p.xz,p.xz)*(1.0-si*si))+q*si-r2,q);\nreturn length(max(vec2(d1,d2),0.0))+min(max(d1,d2),0.);}float udBox(vec3 p,vec3 b){return length(max(abs(p)-b*0.5,0.0));}float sdBox(vec3 p,vec3 b){vec3 d=abs\n(p)-b;return length(max(d,vec3(0)))+vmax(min(d,vec3(0)));}float sdCorner(vec2 p){return length(max(p,vec2(0)))+vmax(min(p,vec2(0)));}float sdCapsule(vec3 p,\nfloat r,float c){return mix(length(p.xz)-r,length(vec3(p.x,abs(p.y)-c,p.z))-r,step(c,abs(p.y)));}\n#define ZERO (min(iFrame, 0))\n#if 0\nvec3 calcNormal(vec3 p, float t)\n{\n\tfloat c=map(p).x;\n\tfloat e=MIN_DIST*t*2.0;\n\treturn normalize(vec3(map(p+vec3(e,0,0)).x-c,\n\t\t\t\t\t\t  map(p+vec3(0,e,0)).x-c,\n\t\t\t\t\t\t  map(p+vec3(0,0,e)).x-c));\n}\n#else\nvec3 calcNormal(vec3 pos, float t) {\n    vec3 n = vec3(0.0);\n\tfloat eps=MIN_DIST*t*0.01;\n    \n\n    // for の展開を防ぎコンパイル時間短縮 & ブラウザクラッシュ防止\n    for (int i = ZERO; i < 4; i++) {\n        vec3 e = 2.0 * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.0;\n        n += e * map(pos + eps * e).x;\n    }\n    return normalize(n);\n}\n#endif",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}