{
    "Shader": {
        "info": {
            "date": "1525302740",
            "description": "Mouse moves the camera.",
            "flags": 64,
            "hasliked": 0,
            "id": "MdtBR8",
            "likes": 4,
            "name": "Reflections of Reflections",
            "published": 3,
            "tags": [
                "raymarching",
                "reflection",
                "sdf",
                "reflections"
            ],
            "usePreview": 0,
            "username": "felipunkerito",
            "viewed": 921
        },
        "renderpass": [
            {
                "code": "#define STEPS      500\n#define FAR       50.0\n#define EPS       1e-3\n#define REFLECTIONS 10\n#define PI acos( -1.0 )\n#define TPI   PI * 2.0\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n// Uncomment for funky ass sphere\n//#define FUNKY\n// Comment for different scene\n#define SCENE\n// Comment for only XZ repetition\n#define REP\n#define WAV texture( iChannel0, vec2( 0.0, 0.45 ) ).x\n\n// Hash by Dave Hoskins\nvec3 hash(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash( float a )\n{\n\n\treturn fract( sin( a * 45932.92 ) * 234823.9 );\n\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = TPI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.0)) c = abs(c);\n\treturn c;\n}  \n\nmat2 rot( float a )\n{\n\n    return mat2( cos( a ), -sin( a ),\n                 sin( a ),  cos( a )\n                );\n\n}\n\nvec3 twiY( vec3 p, float f )\n{\n\n    vec2 mou = iMouse.xy / iResolution.xy;\n    \n    if( mou.y == 0.0 ) mou.y = 0.4;\n    \n    float a = mou.y * p.y * f;\n    \n    p.xz = cos( a ) * p.xz + sin( a ) * vec2( -p.z, p.x );\n    \n    return p;\n\n}\n\nvec3 twiX( vec3 p, float f )\n{\n\n    vec2 mou = iMouse.xy / iResolution.xy;\n    \n    if( mou.x == 0.0 ) mou.x = 0.5;\n    \n    float a = mou.x * p.x * f;\n    \n    p.yz = cos( a ) * p.yz + sin( a ) * vec2( -p.z, p.y );\n    \n    return p;\n\n}\n\nfloat sph( vec3 p ) \n{\n    \n    return length( p ) - 1.3;\n\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    \n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n\n}\n\nfloat sph( vec3 p, float r )\n{\n\n    return length( p ) - r;\n\n}\n\nfloat pla( vec3 p, float d )\n{\n\n    return p.y + d;\n\n}\n\nvec3 modd( vec3 p, float siz )\n{\n    \n    float hal = siz * 0.5;\n    \n    if( iMouse.z < 0.0 || iMouse.x == 0.0  )\n    {\n    \n        p = mod( p, siz ) - hal;\n        \n    }\n    \n    else\n    {\n    \n        p = mod( p + hal, siz ) - hal;\n    \n    }\n    \n    return p;\n\n}\n\nvec2 map( vec3 p, out vec3 id )   \n{\n\n    #ifdef SCENE\n    \n    float rO = 1.0 + 0.15 * cos( 10.0 * p.x + iTime ) * cos( 10.0 * p.y + iTime ) * cos( 10.0 * p.z + iTime );\n    \n    float tileSize = 6.5;\n    \n    if( iMouse.z < 0.0 || iMouse.x == 0.0  )\n    {\n    \n        id = vec3( int( p.x / tileSize ), int( p.y / tileSize ), int( p.z / tileSize ) );\n        \n    }\n    \n    else\n    {\n    \n        id = vec3( int( p.x / ( tileSize + tileSize * 0.5 ) ), int( p.y / ( tileSize + tileSize * 0.5 ) ), int( p.z / ( tileSize + tileSize * 0.5 ) ) );\n    \n    }\n    \n    \n    //id = vec3( int( p.x / tileSize ), int( p.y / tileSize ), int( p.z / tileSize ) );\n    \n    vec3 pO = p;\n    \n    #ifdef REP\n    \n    pO = modd( p, tileSize );\n    \n    #else\n    \n    pO.xz = mod( pO.xz, tileSize ) - tileSize * 0.5;\n    \n    #endif\n    \n    #ifdef FUNKY\n    \n    vec2 sdSph = vec2( sph( pO, rO ), 0.0 );\n    \n    #else\n    \n    vec2 sdSph = vec2( sph( pO, 1.0 + WAV + hash13( id * WAV ) ), 0.0 );\n    \n    #endif\n    \n    vec2 sdPla = vec2( pla( p, 0.9 ), 1.0 );\n    \n    if( sdSph.x < sdPla.x ) sdPla = sdSph; \n    \n    #ifdef REP\n    \n    return sdSph;\n    \n    #else\n    \n    return sdPla;\n    \n    #endif\n    \n    #else\n    \n    vec2 pla = vec2( pla( p, 2.0 ), 1.0 );\n    vec2 cubO = vec2( sdBox( p - vec3( 0.0, 0.0, -1.5 ), vec3( 3.0, 3.2, 0.2 ) ), 0.0 );\n    vec2 cubT = vec2( sdBox( p - vec3( 3.0, 0.0, 0.0 ), vec3( 0.2, 3.2, 3.2 ) ), 0.0 );\n    vec2 cubTh = vec2( sdBox( p - vec3( -3.0, 0.0, 0.0 ), vec3( 0.2, 3.2, 3.2 ) ), 0.0 );\n    p = twiX( p, 2.0 );\n    p = twiY( p, 2.0 );\n    vec2 cub = vec2( sdBox( p, vec3( 1.0 ) ), 0.0 );\n    vec2 sds = vec2( sph( p ), 0.0 );\n    vec2 fin = max( -sds, cub );\n    \n    if( pla.x < fin.x ) fin = pla;    \n    if( fin.x < cubO.x ) cubO = fin;\n\tif( cubO.x < cubT.x ) cubT = cubO;\n    if( cubT.x < cubTh.x ) cubTh = cubT;\n    \n    vec2 one =  min( cubO, fin );\n    vec2 two = min( one, cubT );\n    \n    return cubTh;\n    \n    #endif\n\n}\n\nvec3 norm( vec3 p )\n{\n\n\tvec2 e = vec2( EPS, 0.0 ); vec3 id = vec3( 0 );\n    return normalize(  vec3( map( p + e.xyy, id ).x - map( p - e.xyy, id ).x, \n                             map( p + e.yxy, id ).x - map( p - e.yxy, id ).x,\n                             map( p + e.yyx, id ).x - map( p - e.yyx, id ).x\n                            ) \n                     );\n\n}\n\nfloat ray( vec3 ro, vec3 rd, out float d )\n{\n\n    float t = 0.0; vec3 id = vec3( 0 );\n    for( int i = 0; i < STEPS; ++i )\n    {\n    \n        #ifdef SCENE\n        \n        d = 0.5 * map( ro + rd * t, id ).x;\n        \n        #else \n        \n        d = 0.5 * map( ro + rd * t, id ).x;\n        \n        #endif\n        \n        if( d < EPS || t > FAR ) break;\n        t += d;\n    \n    }\n    \n    return t;\n\n}\n\nvec3 sha( vec3 ro, vec3 rd )\n{\n      \n    float d = 0.0;\n    float t = ray( ro, rd, d );\n    vec3 p = ro + rd * t;\n    vec3 n = norm( p );\n    vec3 lig = vec3( 0 );\n    vec3 id = vec3( 0 );\n    vec2 ma = map( p, id );\n    \n    #ifdef SCENE\n    \n    if( iMouse.z > 0.0 )\n    {\n        \n        lig = normalize( vec3( 1.0, 0.8, 0.6 ) );\n    \n    }\n    \n    else\n    {\n    \n        lig = normalize( vec3( 0.0, iTime, 0.0 ) );\n        lig.zy *= rot( iTime * 0.1 );\n        lig.xz *= rot( iTime * 0.1 );\n    \n    }\n    \n    #else\n    \n    lig = normalize( vec3( 1.0, 0.8, 0.6 ) );\n    \n    #endif\n        \n    vec3 ref = reflect( rd, n );\n   \n    float dif = max( 0.0, dot( n, lig ) );\n    float amb = 0.5 + 0.5 * n.y;\n    float spe = pow( clamp( dot( lig, ref ), 0.0, 1.0 ), 32.0 );\n    float rim = pow(1.0+dot(n,rd),3.0);\n    \n    vec3 col = vec3( 0.0 );\n    \n    col += 0.5 * amb + 0.4 * dif + 1.0 * spe + 0.1 * rim;\n    \n    #ifdef SCENE\n    \n    //col += 0.5 * hash( id.x + id.y + id.z );\n    \n    float fre = texture( iChannel0, vec2( 0.0, 0.1 ) ).x * 0.05;\n    \n    col -= 0.5 * hash( id );\n    \n    #else\n    \n    if( map( p, id ).y == 0.0 ) col *= n;\n    \n    #endif    \n    \n    #ifdef REP\n    \n    #else\n    \n    if( map( p, id ).y == 1.0 ) col = vec3( 0.5 );\n    \n    #endif\n        \n    return col;\n\n}\n\nfloat rar( vec3 ro, vec3 rd, out float d )\n{\n\n    vec3 col = vec3( 0.0 ), id = vec3( 0 );\n    float t = 0.0;\n    for( int i = 0; i < 64; ++i )\n    {\n    \n    \td = 0.5 * map( ro + rd * t, id ).x;\n        if( d < EPS || t > FAR ) break;\n        t += d;\n        \n    }\n\n    return t;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n\n    vec2 mou = iMouse.xy / iResolution.xy;\n    \n    vec3 ro = vec3( 0.0 );\n    \n    vec3 rd = normalize( vec3( uv, -1.0 ) );\n        \n    #ifdef SCENE\n    \n    if( iMouse.z > 0.0 )\n    {\n        \n        ro = vec3( 0.0, 0.0, 2 );\n        ro.zy *= rot( mou.y * TPI );\n        rd.zy *= rot( mou.y * TPI );\n        ro.xz *= rot( mou.x * TPI );\n        rd.xz *= rot( mou.x * TPI );\n    \n    }\n    \n    else\n    {\n    \n        ro = vec3( 0.0, iTime, 0.0 );\n        ro.zy *= rot( iTime * 0.01 );\n        rd.zy *= rot( iTime * 0.02 );\n        ro.xz *= rot( iTime * 0.01 );\n        rd.xz *= rot( iTime * 0.05 );\n    \n    }\n    \n    #else\n    \n    ro = vec3( 0.0, 0.0, 3.4 );\n    ro.zy *= rot( mou.y * TPI );\n    rd.zy *= rot( mou.y * TPI );\n    ro.xz *= rot( mou.x * TPI );\n    rd.xz *= rot( mou.x * TPI );\n    \n    #endif\n    \n    float d = 0.0, t = ray( ro, rd, d );\n    \n    vec3 p = ro + rd * t;\n    \n    vec3 n = norm( p );\n    \n    // Time varying pixel color\n    vec3 col = d < EPS ? sha( ro, rd ) : vec3( 0.0 ); vec3 id = vec3( 0 );\n    \n    #ifdef REP\n    \n    if( map( p, id ).y == 0.0 )\n        \n    for( int i = 0; i < REFLECTIONS; ++i )\n    {\n\n        rd = normalize( reflect( rd, n ) );\n        float dO = 0.0;\n        float tO = rar( ro, rd, dO );\n        p += rd * tO;\n        ro = p + rd * tO;\n\n        if( d < EPS ) col += 0.025 * sha( ro, rd );\n        \n    }\n    \n    #else\n    \n   // ro = vec3( 0, 2, 2 );\n        \n    for( int i = 0; i < REFLECTIONS; ++i )\n    {\n\n        rd = normalize( reflect( rd, n ) );\n        float dO = 0.0;\n        float tO = rar( ro, rd, dO );\n        p += rd * tO;\n        ro = p + rd * tO;\n\n        if( d < EPS ) col += 0.025 * sha( ro, rd );\n        \n    }\n    \n    #endif\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 15791,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/engin-ee/crystal-castles-crimewave"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}