{
    "Shader": {
        "info": {
            "date": "1725156053",
            "description": "or Dancing Is Contagious.\nPut together some humanoid mechanics and music.\nThe guy on the left is relluctant at first ...",
            "flags": 8,
            "hasliked": 0,
            "id": "XflfR8",
            "likes": 9,
            "name": "Green Dancers +sound",
            "published": 3,
            "tags": [
                "mechanics",
                "music",
                "dancers"
            ],
            "usePreview": 1,
            "username": "dray",
            "viewed": 154
        },
        "renderpass": [
            {
                "code": "/*\nAfter https://www.shadertoy.com/view/XfsyWn Space Shuttle Arm, I had to try some real arms - and legs.\nI repeated music from https://www.shadertoy.com/view/X3t3Ws Formant Medley.\nIt is interesting, once you model the range and degrees of motion, even random motions appear plausible.\nOops, these guys cannot cross their arms on their chests - I don't have the optimum arm control.\n\nI struggled with the motion scripting methods and this is pretty bad:\nThis takes a long time to compile on the laptop and runs fast.\nIt compiles fast on the phone and runs slow.\nI mostly used some simple repetitions, not what I wanted.\n\nLots of room for improvements.\n\n*/\n\n#define PI (3.14159265)\n#define TAU (2.*PI)\n\n#define min3(A,B,C) min(A,min(B,C))\n\n// smooth step S curve\n//#define SS(C) ((C)*(C)*(3.-2.*(C)))\nfloat SS(float C) { return ((C)*(C)*(3.-2.*(C))); }\n\nfloat sqrN(float i,int n)\n{\n  while ( n-- > 0 ) i *= i;\n  return i;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) // https://www.shadertoy.com/view/Xds3zN from iq\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n//#define MAT3xz(ANG) mat3( cos(ANG),0,sin(ANG), 0,1,0, -sin(ANG),0,cos(ANG) )\n//#define MAT3zy(ANG) mat3( 1,0,0, 0,cos(ANG),sin(ANG), 0,-sin(ANG),cos(ANG) )\n//#define MAT3xy(ANG) mat3( cos(ANG),sin(ANG),0, -sin(ANG),cos(ANG),0, 0,0,1 )\n\nmat3 MAT3xz(float ANG) { return mat3( cos(ANG),0,sin(ANG), 0,1,0, -sin(ANG),0,cos(ANG) ); }\nmat3 MAT3zy(float ANG) { return mat3( 1,0,0, 0,cos(ANG),sin(ANG), 0,-sin(ANG),cos(ANG) ); }\nmat3 MAT3xy(float ANG) { return mat3( cos(ANG),sin(ANG),0, -sin(ANG),cos(ANG),0, 0,0,1 ); }\n\n// *********************************************************************************\n\nstruct DAN {\n    float luarm, ruarm;   // spread arms apart 0-3 radians\n    float lelbow, relbow; // bend elbows 0-3 radians\n    float lshoulder, rshoulder; // raise arms in front 0-3 radians\n    float lknee, rknee;  // bend knees 0-3 radians\n    float luleg, ruleg;  // spread legs apart 0-1.5 radians\n    float lhip, rhip;    // raise legs in front 0-3 radians\n    float spin;\n    float leanl, leanf;\n    float hop;\n};\n\n#define DANIni(D) \\\n  D.luarm=0.; D.lelbow=0.; D.ruarm=0.; D.relbow=0.; D.luleg=0.; D.lknee=0.; D.ruleg=0.; D.rknee=0.; \\\n  D.lshoulder=0.; D.rshoulder=0.; D.lhip=0.; D.rhip=0.; \\\n  D.spin=0.; D.leanl=0.; D.leanf=0.; D.hop=0.;\n\n//#define FOR(TIME) if ( tim < 0. ) return; dura = TIME; ntim = min(tim,TIME); tim -= TIME; es=ntim/dura; es=SS(es);\n//#define FOR(TIME) es=clamp(tim/(TIME),0.,1.); es=SS(es); if(tim>0.) tim -= TIME; \n//#define FOR(TIME) if (tim<0.) es=0.; else { if (tim>TIME) es=1.; else es=tim/(TIME), es=SS(es); tim -= TIME; }\n#define FOR(TIME) es = tim < 0. ? 0. : tim > (TIME) ? 1. : SS(tim/(TIME)); if ( tim > 0. ) tim -= TIME; \n//#define REPEAT(TIME,CNT) if ( tim < 0. ) return; if ( tim <= ((TIME)*(CNT)) ) tim = mod(tim,TIME); else tim -= (TIME)*(CNT);\n#define REPEAT(TIME,CNT) if ( tim > 0. ) if ( tim <= ((TIME)*(CNT)) ) tim = mod(tim,TIME); else tim -= (TIME)*(CNT);\n\n#define RAMP(S,E)   ((S)+((E)-(S))*es)\n#define SRAMP(FLD,END) (FLD=RAMP(FLD,END));\n#define MOVE(FLD,P,L,H) (FLD=tim<=0.?FLD:((.5-.5*cos(P))*((H)-(L))+(L)))\n\n#define KneeBend1(D) SRAMP(D.lhip,1.); SRAMP(D.rhip,1.); SRAMP(D.lknee,2.3); SRAMP(D.rknee,2.3);  SRAMP(D.luleg,0.); SRAMP(D.ruleg,0.);\n#define KneeBend2(D) SRAMP(D.lhip,3.); SRAMP(D.rhip,3.); SRAMP(D.lknee,3.); SRAMP(D.rknee,3.);  SRAMP(D.luleg,0.1); SRAMP(D.ruleg,0.1);\n\n#define KneeBend(D) SRAMP(D.lhip,3.); SRAMP(D.rhip,3.); SRAMP(D.lknee,3.); SRAMP(D.rknee,3.);  SRAMP(D.luleg,0.); SRAMP(D.ruleg,0.);\n#define StraightLegs(D) SRAMP(D.lhip,0.); SRAMP(D.rhip,0.); SRAMP(D.lknee,0.); SRAMP(D.rknee,0.);  SRAMP(D.luleg,0.); SRAMP(D.ruleg,0.);\n\n#define RelaxArms(D) SRAMP(D.luarm,.1); SRAMP(D.ruarm,.1);  SRAMP(D.lelbow,.6); SRAMP(D.relbow,.6); \n\n#define CrossArmsFace(D) SRAMP(D.luarm,1.); SRAMP(D.ruarm,1.);  SRAMP(D.lelbow,1.8); SRAMP(D.relbow,1.5); SRAMP(D.lshoulder,1.5); SRAMP(D.rshoulder,1.5); \n\n// Can't do it !!!!!\n#define CrossArms(D) SRAMP(D.luarm,.5);  SRAMP(D.lelbow,.5); SRAMP(D.lshoulder,.5); \\\n                     SRAMP(D.ruarm,.5);   SRAMP(D.relbow,.5); SRAMP(D.rshoulder,.5); \n\n#define HandsInFront(D) SRAMP(D.luarm,1.); SRAMP(D.ruarm,1.);  SRAMP(D.lelbow,.6); SRAMP(D.relbow,.6); SRAMP(D.lshoulder,1.5); SRAMP(D.rshoulder,1.5); \n\n#define HOP(D,V0,G,T)  STDY( D.hop, max( 0., (V0)*(T) - (G)*(T)*(T) ) )\n\n#define STDY(FLD,VAL) FLD = tim <= 0. ? FLD : (VAL);\n\n#define WildArmsA(D) \\\n    MOVE(D.lelbow,iTime*1.5,.0,2.); \\\n    MOVE(D.relbow,iTime*2.,.0,2.); \\\n    MOVE(D.lshoulder,iTime*-3.,0.,2.); \\\n    MOVE(D.rshoulder,iTime*-2.5,0.,2.);\n\n#define WildArms(D) \\\n    MOVE(D.luarm,iTime*5.,0.,3.); \\\n    MOVE(D.ruarm,iTime*4.,0.,3.); \\\n    WildArmsA(D); \n\n#define WildLLeg(D) \\\n    MOVE(D.lhip,iTime*5.,0.,1.); \\\n    MOVE(D.lknee,iTime*-7.,0.,1.); \\\n    MOVE(D.luleg,iTime*3.,0.,1.); \\\n    STDY( D.ruleg, -.075 ); \\\n    STDY( D.spin, iTime*5. );\n    \n#define WildRLeg(D) \\\n    MOVE(D.rhip,iTime*5.,0.,1.); \\\n    MOVE(D.rknee,iTime*-7.,0.,1.); \\\n    MOVE(D.ruleg,iTime*3.,0.,1.); \\\n    STDY( D.luleg, -.075 ); \\\n    STDY( D.spin, -iTime*4. );\n    \n#define StandUp(D) \\\n  SRAMP(D.luarm,0.); SRAMP(D.lelbow,0.); SRAMP(D.ruarm,0.); SRAMP(D.relbow,0.); SRAMP(D.lshoulder,0.); SRAMP(D.rshoulder,0.); \\\n  StraightLegs(D); \\\n  SRAMP(D.spin,0.); SRAMP(D.leanl,0.); SRAMP(D.leanf,0.);    \n   \n#define LeftStep(D) SRAMP(D.luleg,0.); SRAMP(D.lknee,0.); SRAMP(D.ruleg,0.); SRAMP(D.rknee,0.); SRAMP(D.lhip,0.); SRAMP(D.rhip,0.);   \n\n#define ExtendRLeg(D) SRAMP(D.rhip,1.6) SRAMP(D.rknee,0.) SRAMP(D.ruleg,.5)\n#define ExtendLLeg(D) SRAMP(D.lhip,1.9) SRAMP(D.lknee,0.) SRAMP(D.luleg,.5)\n\n#define Lotusl(D) SRAMP(D.luleg,1.4) SRAMP(D.ruleg,.4)\n\n#define Lotus(D) SRAMP(D.luleg,1.4) SRAMP(D.ruleg,1.4)\n\n// *********************************************************************************\n\nDAN Jill, Elsa, Naya;\n\nvoid animJill() {\n\n    float tim = iTime; // mod(iTime,60.);\n    float es = 1.; // smoothstep s-curve within current motion\n   \n    DANIni(Jill);\n    RelaxArms(Jill);\n    \n    FOR(4.)\n    FOR(1.)\n    es = 1.;\n    \n    HOP( Jill, 8., 20., fract(iTime) )\n    \n\n    MOVE(Jill.lelbow,iTime*1.,.0,2.);\n    MOVE(Jill.relbow,iTime*1.,.0,2.);\n    MOVE(Jill.lshoulder,iTime*-2.,0.,2.);\n    MOVE(Jill.rshoulder,iTime*-2.5,0.,2.);\n    MOVE(Jill.luarm,iTime*2.,0.,3.);\n    MOVE(Jill.ruarm,iTime*1.,0.,3.);\n    WildRLeg(Jill);\n    \n    MOVE(Jill.leanf,iTime*1.5,-.5,.5);\n    \n    FOR(2.)\n\n}\n\n///////////////////////////////////////////////////////////////\n\nvoid animElsa() {\n\n    float tim = mod(iTime,1830.);\n    float es = 1.; // smoothstep s-curve within current motion\n\n    DANIni(Elsa);\n    RelaxArms(Elsa);\n    \n    FOR(4.)\n    FOR(4.)\n    SRAMP(Elsa.spin,-1.5);\n    FOR(8.)\n    FOR(2.)\n    SRAMP(Elsa.leanf,-.3)\n    SRAMP(Elsa.rshoulder,1.)\n    SRAMP(Elsa.relbow,1.)\n    FOR(.3)\n    SRAMP(Elsa.leanf,-.2)   \n    FOR(.3)\n    SRAMP(Elsa.leanf,-.3)  \n    FOR(.3)\n    SRAMP(Elsa.leanf,-.2)   \n    FOR(.3)\n    SRAMP(Elsa.leanf,-.3)  \n    FOR(.3)\n    SRAMP(Elsa.leanf,-.2)   \n    FOR(.3)\n    SRAMP(Elsa.leanf,-.3)  \n    FOR(.3)\n    SRAMP(Elsa.leanf,-.2)   \n    FOR(2.)\n    WildArms(Elsa);\n    FOR(4.)\n    WildLLeg(Elsa);\n    //STDY( Jill.hop, sqrN(1.-tri(iTime),2)*2. );\n    FOR(10.)\n    \n}\n\n\n///////////////////////////////////////////////////////////////\n\nvoid animNaya() {\n\n\n    float tim = iTime; // mod(iTime,1118.);\n    float es = 1.; // smoothstep s-curve within current motion\n    \n\n    DANIni(Naya);\n    CrossArms(Naya);\n    KneeBend2(Naya);\n    Lotus(Naya);\n\n\n    //FOR(1.)     ExtendRLeg(Naya)\n\n    //FOR(1.)     ExtendLLeg(Naya)\n\n    FOR(1.)  \n    Lotus(Naya);\n\n    FOR(6.)\n    FOR(1.)\n    KneeBend2(Naya);\n    FOR(1.)\n    KneeBend1(Naya);\n    FOR(1.)\n    StandUp(Naya)\n\n    WildArms(Naya);\n    \n    REPEAT(7.,1000.)\n    \n\n    FOR(1.)\n    \n    //SRAMP(Naya.leanf,1.)\n    SRAMP(Naya.leanl,.2)\n\n\n    FOR(1.)\n\n    //SRAMP(Naya.leanf,0.)\n    SRAMP(Naya.leanl,0.)\n\n    FOR(1.)\n    KneeBend1(Naya);\n    \n    FOR(1.)\n    KneeBend2(Naya);\n\n    //FOR(.5)     ExtendRLeg(Naya)\n\n    //FOR(.5)     ExtendLLeg(Naya)\n\n    FOR(1.)\n    KneeBend2(Naya);\n\n    FOR(1.)\n    KneeBend1(Naya);\n\n    FOR(1.)\n    StraightLegs(Naya);\n\n    //FOR(1.)\n    //StandUp(Naya);\n    //WildArms(Naya);\n\n    //FOR(1.) \n\n    \n}\n\n// -----------------------------------------------------------------------------\n\n#define DSZ 20.\n\nfloat Dancer2(vec3 pt,DAN m) {\n    vec3 hips = vec3(0,0,0); // origin !\n    mat3 rott =  MAT3zy(m.leanf) * MAT3xz( m.spin ) * MAT3xy(m.leanl);\n    vec3 head = hips + vec3(0,.33,0)*DSZ * rott;\n    \n    vec3 shoulders = mix( hips, head, .8 );\n\n    mat3 sav = rott;\n  \n    // left arm\n    vec3 lshoulder = shoulders - vec3(.05,0,0)*DSZ * rott;\n    rott = MAT3zy( -m.lshoulder ) * MAT3xy( m.luarm ) * rott;\n    vec3 lelbow = lshoulder + vec3(0,-.14,0)*DSZ * rott;\n    rott = MAT3zy( -m.lelbow ) * rott;\n    vec3 lhand = lelbow + vec3(0,-.14,0)*DSZ * rott;\n  \n    rott = sav;\n\n    // right arm\n    vec3 rshoulder = shoulders + vec3(.05,0,0)*DSZ * rott;\n    rott = MAT3zy( -m.rshoulder ) * MAT3xy( -m.ruarm ) * rott;\n    vec3 relbow = rshoulder + vec3(0,-.14,0)*DSZ * rott;\n    rott = MAT3zy( -m.relbow ) * rott;\n    vec3 rhand = relbow + vec3(0,-.14,0)*DSZ * rott;\n\n    rott = sav;\n\n    // left leg\n    vec3 lhip = hips - vec3(.025,0,0)*DSZ * rott;\n    rott =  MAT3xy( m.luleg - m.leanl ) * MAT3zy( -m.lhip -  m.leanf ) * rott;\n    vec3 lknee = lhip + vec3(0,-.18,0)*DSZ * rott;\n    rott = MAT3zy( m.lknee ) * rott;\n    vec3 lfoot = lknee + vec3(0,-.18,0)*DSZ * rott;\n\n    rott = sav;\n\n    // right leg\n    vec3 rhip = hips + vec3(.025,0,0)*DSZ * rott;\n    rott = MAT3xy( -m.ruleg - m.leanl ) * MAT3zy( -m.rhip  - m.leanf ) * rott;\n    vec3 rknee = rhip + vec3(0,-.18,0)*DSZ * rott;\n    rott = MAT3zy( m.rknee ) * rott;\n    vec3 rfoot = rknee + vec3(0,-.18,0)*DSZ * rott;\n\n    float bottom = min3( lfoot.y, rfoot.y, hips.y-.035*DSZ/3. );\n    bottom -= m.hop;\n    \n    pt.y += bottom;\n\n\n    float dist = sdCapsule( pt, head, hips, .035*DSZ ); // body\n    float tmp;\n#define ADD(a,b,r) tmp = sdCapsule( pt, a, b, (r)*DSZ ); if ( tmp < dist ) dist = tmp;\n    ADD(lshoulder,lelbow,.02)\n    ADD(lhand,lelbow,.02)\n    ADD(rshoulder,relbow,.02)\n    ADD(rhand,relbow,.02)\n    ADD(lshoulder,rshoulder,.02)\n    ADD(lknee,lhip,.025)\n    ADD(lfoot,lknee,.025)\n    ADD(rknee,rhip,.025)\n    ADD(rfoot,rknee,.025)\n    //ADD(lhip,rhip,.02)\n\n    return dist;\n}\n\n\n// Terrain -------------------------------------\n\nfloat rndd(vec2 pt) {\n  pt += vec2(13.43544,31.2434);\n  return fract( sin(mod(pt.x*pt.y,TAU)) * 89.367456 );\n}\n\nfloat height(vec2 pt) { // 0-1\n    vec2 f = floor(pt);\n    vec2 r = fract(pt);\n    vec2 o = vec2(1,0);\n    float xf = SS(r.x);\n    return mix(\n       mix( rndd(f), rndd(f+o), xf ), // mid points of x edges\n       mix( rndd(f+o.yx), rndd(f+o.xx), xf ),\n       SS(r.y) );\n}\n\n//float water = .1;\n\nfloat height2(vec3 pt) {\n    return pt.y - height(pt.xz*.03)*10. - pt.z*.3 + 5.;\n}\n\n\nfloat texture(vec2 pt) {\n    return .5 + height(pt*50.)*.5;\n}\n\n\n// Map --------------------------------------------------------------\n\n\nvec2 Dist(vec3 pt) {\n    vec2 hit = vec2(100000,0);\n    float tmp, clr = 0.;\n#define T(SDF) if ( (tmp = SDF) < hit.x ) hit = vec2(tmp,clr); clr += 1.;\n    T( Dancer2( (pt-vec3(0,0,-3)), Jill ) )\n    T( Dancer2( (pt-vec3(-12,-.6,-3)), Elsa ) )\n    T( Dancer2( (pt-vec3(13,-.6,-3)), Naya ) )\n    T( height2(pt) )\n    return hit;\n}\n\nvec4 March(vec3 beg,vec3 dir) { // return intersection point and object of ray\n    float dist = 0.;\n    vec3 pos;\n    for ( int stps = 0; stps < 300; ++stps ) {\n        pos = beg + dir * dist;\n        vec2 obj = Dist( pos );\n        dist += obj.x;\n        if ( dist > 200. ) return vec4( pos, 91. );\n        if ( pos.z < -80. ) return vec4( pos, 91. );\n        if ( obj.x < .01 ) return vec4( pos, obj.y );\n    }\n    return vec4( pos, 90. );\n}\n\nvec3 Normal(vec3 pt) {\n    float delta = .001; // large delta gives rounded corners\n    vec3 norm = Dist(pt).x - vec3(\n        Dist(pt-vec3(delta, 0., 0.)).x, \n        Dist(pt-vec3( 0.,delta, 0.)).x, \n        Dist(pt-vec3( 0., 0.,delta)).x );\n    return normalize( norm );\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    animJill();\n    animElsa();\n    animNaya();\n    vec2 R = iResolution.xy;\n    vec2 uv = (U+U-R) / min(R.x,R.y);  // -1 ... +1\n    uv *= .25; // field of view\n    vec3 cam = vec3( 0, 10, -64.);\n    vec3 camdir = normalize( vec3( uv, 1. ) );\n\n    vec4 hit = March( cam, camdir );\n\n    vec3 Light = vec3( 20, 30, -30 );\n    vec3 dir = normalize( Light - hit.xyz );\n\n    vec4 shadow = March( hit.xyz+dir*.1, dir );\n    //vec4 shadow = vec4(.5);  // silhouette mode: from jorge2017a2\n\n    vec3 norm = Normal(hit.xyz);\n    float difu = dot( norm, dir );\n    difu = .3 + .7*difu;\n    if ( shadow.z > -10. ) difu = .2;\n    \n    #define color4(X) ( .5 + .3 * sin( vec4(0,21,23,0) + (X) ) )\n    \n    O = color4(hit.w*.4);\n    if ( hit.w == 3. ) O = mix(O,vec4(0,.3,0,1),clamp(texture(hit.xz*.1),0.,1.));\n    O *= difu;\n    //O *= difu + sqrN(difu,9);\n    \n    if ( hit.w >= 90. ) O=mix(vec4(.2,.4,.8,1.),vec4(1),sqrN(height(U*vec2(.005,2)),4));\n#ifdef SHOW_MARCHING_ISSUES\n    if ( hit.w == 90. ) O=vec4(1,0,0,1); // usually marching in parallel with a close plane\n#endif\n    O=sqrt(O);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI (3.14159265)\n#define TAU (PI*2.)\n\n#define SINC(X) (sin(X)/(X))\n\nint inoisei(int a) {\n  a = (a * 54321) ^ (a * 14873);\n  a ^= a >> 16; // graycode\n  a ^= a >> 8;\n  a ^= a >> 4;\n  a ^= a >> 2;\n  a ^= a >> 1;\n  return a & 65535;\n}  \n\nfloat noisei(int a) {\n  return float( inoisei(a) & 65535 ) / 65536. ;\n}\n\nfloat noise(float a) { return noisei(int(a*1234.)); }\n\n#define RND0(L,H,IN) (noisei(IN)*(H-L)+L)\n#define RND(L,H,IN) (noise(IN)*(H-L)+L)\n\n#define FS iSampleRate\n\nfloat tonnos(float t,float f) {\n    float a = t*f;\n    int b = int(a);\n    return mix(noisei(b),noisei(b+1),smoothstep(0.,1.,fract(a))); // crude filter\n}\n\n\n\n#define FMT(FC,VOL,Q) max( 0., VOL - max(FC/har,har/FC) * Q )\n\nfloat voice(float time,float fc,float f1,float v1,float q1,float f2,float v2,float q2/*,float f3,float v3,float q3*/) {\n  float oo = 0.;\n  int cnt = 0;\n  for ( float har = fc; har < 12e3 && cnt++ < 30; har += fc ) {\n    oo += sin(TAU*time*har) * fc/har * ( \n      FMT(f1,v1,q1)  + FMT(f2,v2,q2)  // + FMT(f2,v2,q2)\n    );\n  }\n // oo += 1.*tonnos(FS*time*PI,f1);\n  return oo;\n}\n\nfloat voiceN3(float time,float fc1,float fc2,float fc3,float f1,float v1,float q1,float f2,float v2,float q2) {\n  return voice(time,fc1,f1,v1,q1,f2,v2,q2)+voice(time,fc2,f1,v1,q1,f2,v2,q2)+voice(time,fc3,f1,v1,q1,f2,v2,q2);\n}\n\n#define OSC(L,H,F) ((sin(TAU*gtime*(F))+1.)*.5*((H)-(L))+(L))\n\n/*\n#define F_i  SF( 290., 2200. )\n#define F_I  SF( 375., 2000. )\n#define F_u  SF( 340., 1250. )\n#define F_uu SF( 400., 1100. )\n#define F_o  SF( 425., 1000. )\n#define F_ee SF( 400., 2050. )\n#define F_cc SF( 560., 560. )\n#define F_A  SF( 690., 1400. )\n#define F_a  SF( 850., 1250. )\n#define F_ae SF( 875., 1500. )\n\n#define zSF(A,B)  A, 2.,.5, B, 2., .5 \n*/\n\n\n#define TT .5\n\n#define WHEN(T,CODE) if ( time < (T) ) { CODE; time = 10000.; } time -= (T);\n\nfloat vc1(float time,float FF) {\n\n    float f1, f2, notet, tt, fc, vc;\n\n#define SF(F,A,B) \\\n    if (fc==0.) fc=F, f1=A, f2=B; \\\n    if ( time < TT ) { \\\n        notet = TT - time; \\\n        tt = min( 1., (time)*4. ); \\\n        vc = voice( notet, \\\n            F - (fc-F)*time/2. , \\\n            mix(f1,A,tt), 5., 3.5 , \\\n            mix(f2,B,tt), 4., 3. ); \\\n        time += 1000.; \\\n    } \\\n    time -= TT; \\\n    f1 = A; \\\n    f2 = B; \\\n    fc = F; \\\n\n/*\n///WHEN(.5,vc+=.2*noisei(int(time*102312.)); )\n//WHEN(.3,vc+=voice(time,FF,4000.,2.,.2,12000.,2.,.2);)\n///WHEN(.5,vc+=voice(time,FF,690.,4.,3.,2400.,3.,2.);)\nWHEN(.5,vc+=mix(.4*noisei(int(time*102312.)),voice(time,FF,690.,4.,3.,2400.,3.,2.),time/.5);)\nWHEN(.5,vc+=voice(time,FF,690.,4.,3.,1400.,4.,3.);)\nWHEN(.5,vc+=mix(.2*noisei(int(time*102312.)),voice(time,FF,425.,4.,3.,1000.,3.,2.),time/.5);)\n*/\n\nSF( FF, 375., 2000. )\nSF( FF, 850., 1250. )\nSF( FF, 340., 1250. )\nSF( FF, 290., 2200. )\nSF( FF, 400., 1100. )\nSF( FF, 875., 1500. )\nSF( FF, 425., 1000. )\nSF( FF, 400., 2050. )\nSF( FF, 560., 560. )\nSF( FF, 690., 1400. )\nSF( FF, 875., 1500. )\nSF( FF, 425., 1000. )\nSF( FF, 340., 1250. )\nSF( FF, 400., 1100. )\nSF( FF, 875., 1500. )\nSF( FF, 425., 1000. )\nSF( FF, 400., 2050. )\nSF( FF, 560., 560. )\nSF( FF, 690., 1400. )\nSF( FF, 425., 1000. )\nSF( FF, 400., 2050. )\nSF( FF, 560., 560. )\nSF( FF, 690., 1400. )\n\n    return vc;\n    \n}\n\nfloat note(float time,float rep,float phs,float att,float dur,float dec) {\n  float t=mod(time-phs-att,rep);\n  return t<att ? t/att : t<att+dur ? 1. : exp(-(t-att-dur)/dec);\n}\n\nfloat rhyt(float time,float rep,float phs,float dec) {\n  return note(time,rep,phs,.0002,.0,dec);\n}\n\nfloat pat(float time,float rep,int pbt) {\n  return float((pbt>>int(mod(time,rep*16.)/rep))&1);\n}\n\nfloat ramp(float time,float rep,float lo,float hi) {\n  return fract(time/rep)*(hi-lo)+lo;\n}\n\nfloat stair(float val,float rise) {\n  return floor(val/rise)*rise;\n}\n\n#define ROUNDTO(X,Y) (round((X)/(Y))*(Y))\n\nfloat tonrmp(float time,float f1,float t1,float f2,float t2) {\n  t1=ROUNDTO(t1,f1);\n  t2=ROUNDTO(t2,f2);\n  return time<t1 ? f1 : \n    time<t2 ? f1+(f2-f1)*(time-t1)/(t2-t1)/2. :\n      f2;\n}\n\n#define w 1.\n#define h .5\n#define q .25\n#define e .125\n#define s (e/2.)\n\n// 12-tone notes\n#define C D f f\n#define D E f f\n#define E F f\n#define F G f f\n#define G A f f\n#define A 440.\n#define B A sh sh\n\n// Just intonation pitches for C, sort of\n#define JC *8./8.\n#define JD *9./8.\n#define JE *10./8.\n#define JF *11./8.\n#define JG *12./8.\n#define JA *13./8.\n#define JBb *14./8.\n#define JB *15./8.\n\n// accidentals\n#define sh * 1.05946\n#define f * 0.9438\n\nvec2 mainSound( int samp, float time )\n{\n\n//return .2*vec2(vc1(time,220.));\n\n    float vc = 0.;\n    \n   // vc += sin(TAU*time*200.)*exp(-.5*PI*time);\n    //return vec2(vc);\n   \n    //time += 52.;\n    //time += 44.;\n#if 0\n    if ( time < 22. ) {\n    \n        int secs = int(10.*TT);\n        float xtime = float(samp%(int(iSampleRate)*secs))/iSampleRate;\n\n        //xtime *= 1. + SINC(xtime*20.)*.02; // + SINC(xtime*2.)*.3;\n        \n        /*\n        int t1 = int(time)/secs%6;\n        float[] fcs=float[](220.,330.,110.,110.,55.,55.);\n        float f1=fcs[t1];\n        //float f2=fcs[t1+1];\n        float fc=f1; // tonrmp(time,f1,float(t1)+.7,f2,float(t1+1));\n        */\n\n        vc += vc1(\n          xtime,\n          //fc\n          float[](220.,330.,110.,110.,55.,55.)[int(time)/secs%6]\n        );\n\n    }\n#endif\n /*   \n    if ( time > 18. && time < 54. )\n    {\n        float yy=0.;\n        for ( float ii = 6.; ii < 11.; ++ii ) {\n            float ttime = (time+ii/6.)*2.;\n            float ntime = fract(ttime);        \n            int ndx = int(floor(ttime));\n            yy += .3*voice( ntime,\n                time<23.?80.:20.*ii,\n                RND0(250.,1000.,ndx+2+int(ii)), 4., 3.,\n                RND0(350.,2000.,ndx+4+int(ii)), 4., 3.);\n        }\n        vc = mix(vc,yy,clamp(0.,1.,(time-18.)/4.));\n       \n    }\n */\n    float xtime = time ;//- 48.;\n    if ( xtime > 0.) {\n   // vc=0.;\n        //vc *= smoothstep( 3., 0., time-20. );\n      //  vc += tonnos(time,TAU*2000.) ; // * rhyt(time,1.,0.,.5);\n        float yy=0.;  \n        if ( xtime > 8.*1. )\n        yy += tonnos(xtime, noisei(int(xtime/e)) > .5 ? 16000. : 2000.) * rhyt(xtime,e,0.,s*.7);\n        if ( xtime > 8.*0. ) {\n        yy += .8*tonnos(xtime, noisei(1+int(xtime/h)) > .5 ? 400. : 8000.) * rhyt(xtime,q,0.,s);\n        if ( xtime > 8.*2. ) {\n        yy += tonnos(xtime, stair(ramp(xtime+2.,w*2.,20000.,120.),2000.)) * rhyt(xtime,h,0.,q);\n        yy += sin(mod(time*TAU*12000.,TAU)) * rhyt(xtime,w,q+q+q,e);\n        if ( xtime > 8.*3. ) {\n\n        \n \n        xtime=mod(xtime,1.);\n        //float[] fcs=float[](1.,2.,1./2.,3./2.,2./3.,4./5.,5./4.);\n        //xtime=xtime * (1. + SINC(time*10.)*.1);\n        float fc = 880.;\n        float fc1=fc * (1. + SINC(xtime*40.)*.03*note(time,w*4.,0.,h,q,h)); // RND0(50.,800.,int(time/4.)); // 110.;//floor(2.+6.*noisei(int(time/w)))*55.;\n        float fc2=fc * (1. + SINC(xtime*30.)*.03*note(time,w*4.,0.,w,q,h)); // RND0(50.,800.,int(time/4.)); // 110.;//floor(2.+6.*noisei(int(time/w)))*55.;\n        float fc3=fc * (1. + SINC(xtime*35.)*.03*note(time,w*4.,0.,h+q,q,h)); // RND0(50.,800.,int(time/4.)); // 110.;//floor(2.+6.*noisei(int(time/w)))*55.;\n        //yy=0.;\n        //yy += vc1( xtime, fc ) * note(time,3.*w,0.,e,e,e);\n        yy += .25*voiceN3( xtime,\n                  //fc*fcs[inoisei(int(time/4.)+1)%7],\n                  //fc*fcs[inoisei(int(time/4.)+2)%7],\n                  //fc*fcs[inoisei(int(time/4.)+3)%7],\n                  fc1, fc2*5./4., fc3*1.5,\n                  RND0(200.,1200.,int(time/4.)), //tonnos(time,1./w/8.)*1000.+250.,\n                  4., 3.,\n                  RND0(1200.,4800.,int(time/4.)), //tonnos(time+.1,1./w/8.)*3000.+350.,\n                  4., 3.)\n               * note(time,w*4.,q,q,h,q);\n               \n        } } }\n        vc = mix(vc,yy,1.);//clamp(0.,1.,(time-48.)/6.));\n    }\n    \n    return .15*vec2(vc);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}