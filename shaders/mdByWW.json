{
    "Shader": {
        "info": {
            "date": "1687704350",
            "description": "Playing with integer coordinates",
            "flags": 0,
            "hasliked": 0,
            "id": "mdByWW",
            "likes": 5,
            "name": "Discrete Land",
            "published": 3,
            "tags": [
                "math",
                "discrete",
                "maths",
                "integer",
                "integers"
            ],
            "usePreview": 0,
            "username": "beans_please",
            "viewed": 167
        },
        "renderpass": [
            {
                "code": "vec3 eval(vec2 coord)\n{\n    vec2 uv = coord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv *= iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    float scale = map_range(cos(TWO_PI * iTime * 0.05), -1.0, 1.0, 150.0, 35.0);\n    vec2 discrete = floor(uv * scale);\n    \n    int method = int(iTime / 1.2) % 5;\n    \n    bool b = false;\n    vec3 col;\n\n    switch (method) {\n    case 0:\n        b = fract(discrete.x * discrete.x / discrete.y) == 0.0;\n        col = vec3(0.01, 0.6, 0.7);\n        break;\n    case 1:\n        b = fract(sqrt(discrete.x * discrete.y)) < 0.01;\n        col = vec3(0.7, 0.55, 0.3);\n        break;\n    case 2:\n        b = fract(sqrt(abs(discrete.x * discrete.y))) > 0.95;\n        col = vec3(0.2, 0.6, 0.9);\n        break;\n    case 3:\n        b = cos(discrete.x * discrete.y / 6.0) > 0.95;\n        col = vec3(0.45, 0.6, 0.25);\n        break;\n    case 4:\n        b = fract(log(abs(discrete.x * discrete.y)) * sin(discrete.x)) < 0.05;\n        col = vec3(0.8, 0.35, 0.6);\n        break;\n    }\n    \n    return b ? col : 0.04 * pow(col, vec3(4.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Initialize PRNG\n    eprng_init(fragCoord.xy / max(iResolution.x, iResolution.y), iTime);\n\n    // Jitter sampling\n    const int numSamples = 32;\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < numSamples; i++)\n    {\n        col += eval(fragCoord + vec2(random() - 0.5, random() - 0.5));\n    }\n    col /= float(numSamples);\n    \n    // Noise\n    eprng_init((floor(fragCoord.xy / 2.0) * 2.0) / max(iResolution.x, iResolution.y), floor(iTime * 15.0) / 15.0);\n    float noiseAmount = pow(sin(PI * rgb_max(col)), 2.0);\n    noiseAmount = map_range(noiseAmount, 0.0, 1.0, 0.01, 1.0);\n    col += noiseAmount * map_range(random(), 0.0, 1.0, -0.05, 0.1);\n    \n    // Vignette\n    float dist = length((fragCoord.xy / iResolution.xy) * 2.0 - 1.0);\n    col = pow(col, vec3(map_range_clamp(dist, 0.7, 6.0, 1.0, 4.0)));\n    col *= pow(2.0, map_range_clamp(dist, 0.75, 4.0, 0.0, -5.0));\n    \n    // OETF\n    col = pow(col, vec3(1.0 / 2.2));\n    \n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265358979\n#define TWO_PI 6.28318530717959\n\nfloat map_range(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start);\n}\n\nfloat map_range_clamp(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    float t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0);\n    float v = out_start + t * (out_end - out_start);\n    return v;\n}\n\nfloat rgb_max(vec3 inp)\n{\n    return max(max(inp.x, inp.y), inp.z);\n}\n\n// ***********************************************\n// Source: https://www.shadertoy.com/view/WdSSRt\n// ***********************************************\n\n/* Usage Example:\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Initialize PRNG\n    eprng_init(fragCoord.xy / max(iResolution.x, iResolution.y), iTime);\n\n    // Using the function:\n    float a = random();\n    vec3 b = vec3(random(), random(), random());\n    \n    ...\n}\n\n*/\n\nuint eprng_state[2];\n\nuint eprng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\nfloat random()\n{\n    uint s0 = eprng_state[0];\n    uint s1 = eprng_state[1];\n    uint result = eprng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    eprng_state[0] = eprng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    eprng_state[1] = eprng_rot(s1, 13);\n    // Not sure this is actually the best way to get evenly-distributed floats -\n    // precision will be lost converting from int to float, but how much depends on the order of magnitude\n    // I could use bit magic to build the bits of a float directly, then use uintBitsToFloat,\n    // but that also loses precision - just in a different way.\n    // I guess precision loss is inevitable, since if we want floats in the range 0.0 <= r <= 1.0 then\n    // there's only so many bits to work with. It's just a matter of how they're distributed.\n    return float(result) / float(0xffffffffu);\n}\n\nvoid eprng_init(vec2 uv, float iTime)\n{\n    uv *= (iTime + 10.258);\n\n    eprng_state[0] = floatBitsToUint(uv.x);\n    eprng_state[1] = floatBitsToUint(uv.y);\n\n    random();\n}\n\n// ***********************************************\n// End\n// ***********************************************\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}