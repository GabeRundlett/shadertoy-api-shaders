{
    "Shader": {
        "info": {
            "date": "1685841370",
            "description": "raytracing fragment shader with blinn-phong shading + specular, shadow probing, and mirror reflections",
            "flags": 0,
            "hasliked": 0,
            "id": "DlcXWl",
            "likes": 2,
            "name": "raytracing shader",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "tjgalcik",
            "viewed": 427
        },
        "renderpass": [
            {
                "code": "const float INFINITY = 9999.99;\nconst vec3 BACKGROUND = vec3(0.5, 0.8, 1);\nconst int NUM_LIGHTS = 3;\nconst int NUM_SPHERES = 10;\nconst int MAX_BOUNCE = 20;\n\nstruct Ray{\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Material{\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float specPow;\n    float reflect;\n};\n\nstruct Light{\n    float intensity;\n    vec3 pos;\n    vec3 color;\n};\n\nstruct Sphere{\n    vec3 pos;\n    float radius;\n    Material mat;\n};\n\nstruct Scene{\n    Light lights[NUM_LIGHTS];\n    Sphere spheres[NUM_SPHERES];\n};\n\nfloat intersectSphere(Ray ray, Sphere sphere){\n    float a = dot(ray.dir, ray.dir);\n    vec3 g = ray.origin - sphere.pos;\n    float b = dot(ray.dir, g);\n    float c = dot(g,g) - (sphere.radius * sphere.radius);\n    \n    float discriminant = b*b - a*c;\n    if (discriminant < 0.0) return INFINITY;\n    \n    float dsq = sqrt(discriminant);\n    float t = (-b - dsq) / a;    // first intersection test\n    if (t > 0.001) return t;\n    \n    t = (-b + dsq) / a;\n    if (t > 0.001) return t;\n    \n    return INFINITY;\n}\n\nbool probe(vec3 e, vec3 d, float dist, Scene scene){\n    \n    // For each sphere\n    for (int i = 0; i < NUM_SPHERES; i++) {\n        Ray ray;\n        ray.origin = e;\n        ray.dir = d;\n        Sphere sphere = scene.spheres[i];\n        float intersection = intersectSphere(ray, sphere);\n        if (0.001 < intersection && intersection < dist) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nvec3 trace(Ray ray, Scene scene){\n    vec3 color = vec3(0,0,0);    // starting color\n    int bounces = 0;\n    for (int depth = 0; depth < MAX_BOUNCE; depth++){\n        bounces++;\n        if (depth == MAX_BOUNCE) {\n            return vec3(0);\n        }\n\n        // find index of closest sphere\n        float t_star = INFINITY;\n        int nearestSphere = -1;\n        for (int i = 0; i < NUM_SPHERES; i++) {\n            float t = intersectSphere(ray, scene.spheres[i]);\n\n            if (t < t_star) {\n                t_star = t;\n                nearestSphere = i;\n            }\n        }\n\n        if (nearestSphere == -1 && depth == 0){\n            return BACKGROUND;\n        }\n        else if (nearestSphere == -1){\n            return (BACKGROUND * color);\n        }\n        \n        vec3 P;\n        vec3 N;\n        Sphere sphere;\n        // for O in objects:\n        for (int k = 0; k < NUM_SPHERES; k++){\n            if (k == nearestSphere){\n                sphere = scene.spheres[k];    \n                float t = intersectSphere(ray,sphere);\n                P = ray.origin + (ray.dir * t);\n                N = normalize(P - sphere.pos);\n\n                // check for intersection\n                if (t != INFINITY){\n                    // for L in lights:\n                    for (int i = 0; i < NUM_LIGHTS; i++){\n                        color += sphere.mat.ambient * scene.lights[i].color;    // ambient\n\n                        vec3 L = normalize(scene.lights[i].pos - P);\n                        float N_dot_L = dot(N,L);\n\n                        if(N_dot_L >= 0.0 && probe(P, L, length(P - L), scene)){\n                            // phong shading\n                            float I_l = scene.lights[i].intensity;\n                            float lamb_ref = max(0.0, N_dot_L);\n                            color += sphere.mat.diffuse * I_l * lamb_ref;\n\n                            // specular highlights\n                            vec3 H = normalize(L - ray.dir);\n                            float N_dot_H = dot(N, H);\n                            if (N_dot_H > 0.0) {\n                                vec3 spec = sphere.mat.specular * I_l * pow(N_dot_H, sphere.mat.specPow) * N_dot_H;\n                                color += spec;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (sphere.mat.reflect == 0.0){\n            break;\n        }\n        ray.origin = P;\n        ray.dir = ray.dir + 2.0*(dot(N, -ray.dir)*N) * sphere.mat.reflect;\n    }\n    return color/vec3(bounces);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // uv coords\n    vec2 tc = gl_FragCoord.xy/iResolution.xy;\n    \n    // scene setup\n    Scene scene;\n    scene.lights[0] = Light(1.0, vec3(-10, 10, -20), vec3(1,1,1));\n    scene.lights[1] = Light(0.5, vec3(20, -30, 40), vec3(1,1,1));\n    scene.spheres[0] = Sphere(vec3(sin(iTime) * 3.0 + 4.0,sin(iTime + 0.5) + 2.5, -5.0), 2.0, Material(vec3(0.25, 0, 0), vec3(1, 0, 0), vec3(0.5, 0.5, 0.5), 40.0, 0.0));\n    scene.spheres[1] = Sphere(vec3(sin(iTime + 0.5) * 3.0 + 5.5,sin(iTime + 0.25) + 3.5, -3.0), 2.0, Material(vec3(0.25, 0.125, 0), vec3(1, 0.5, 0), vec3(0.5, 0.5, 0.5), 40.0, 0.0));\n    scene.spheres[2] = Sphere(vec3(sin(iTime + 1.0) * 3.0 + 6.75,sin(iTime + 0.0) + 4.75, 0.0), 2.0, Material(vec3(0.25, 0.25, 0), vec3(1, 1, 0), vec3(0.5, 0.5, 0.5), 40.0, 0.0));\n    scene.spheres[3] = Sphere(vec3(sin(iTime + 1.5) * 3.0 + 8.0,sin(iTime - 0.25) + 6.0, 3.0), 2.0, Material(vec3(0.0, 0.25, 0), vec3(0, 1, 0), vec3(0.5, 0.5, 0.5), 40.0, 0.0));\n    scene.spheres[4] = Sphere(vec3(sin(iTime + 2.0) * 3.0 + 9.0,sin(iTime + -0.5) + 7.0, 5.0), 2.0, Material(vec3(0.0, 0.0, 0.25), vec3(0, 0, 1), vec3(0.5, 0.5, 0.5), 40.0, 0.0));\n    scene.spheres[5] = Sphere(vec3(sin(iTime + 2.5) * 3.0 + 10.0,sin(iTime + -0.75) + 8.0, 7.5), 2.0, Material(vec3(0.125, 0.0, 0.25), vec3(0.5, 0, 1), vec3(0.5, 0.5, 0.5), 40.0, 0.0));\n    scene.spheres[6] = Sphere(vec3(8.5, 0, 20), 10.0, Material(vec3(0.125 * sin(iTime), -0.125 *sin(iTime), 0.125 *cos(iTime)), vec3(1.0 * sin(iTime), -1.0 *sin(iTime), 1.0 *cos(iTime)), vec3(0.8, 0.8, 0.8), 40.0, 0.0));\n    scene.spheres[7] = Sphere(vec3(8.5, 20, 20), 10.0, Material(vec3(0.125, 0.125, 0.125), vec3(1, 1, 1), vec3(0.5, 0.5, 0.5), 40.0, 1.0));\n    scene.spheres[8] = Sphere(vec3(0, sin(iTime)*4.0 + 6.0, 10), 2.0, Material(vec3(0.125, 0.125, 0.125), vec3(1, 1, 1), vec3(0.8, 0.8, 0.8), 40.0, 0.7));\n    scene.spheres[9] = Sphere(vec3(13.5, -sin(iTime)*4.0 + 6.0, 10), 2.0, Material(vec3(0.125, 0.125, 0.125), vec3(1, 1, 1), vec3(0.8, 0.8, 0.8), 40.0, 0.7));\n    \n    // camera vars\n    vec3 eyep = vec3(-sin(iTime) * 15.0, 0, -20);\n    vec3 lookp = vec3(scene.spheres[4].pos.x, 10, 20);\n    float aspectRatio = iResolution.x / iResolution.y; // aspect ratio calculation\n    vec3 cameraDir = normalize(lookp - eyep);\n\n    // ray starts at eye pos and goes through current uv coord\n    Ray ray;\n    ray.origin = eyep;\n    vec3 rayDir = normalize(cameraDir);  // initial ray direction is the camera's forward direction\n    vec3 right = normalize(cross(vec3(0, 1, 0), rayDir));  // calculate the camera's right direction\n    vec3 up = normalize(cross(rayDir, right));  // calculate the camera's up direction\n\n    // adjust right direction based on aspect ratio\n    right *= aspectRatio;\n\n    // calculate the position on the image plane based on texture coordinates (tc)\n    vec3 distanceToImagePlane = vec3(3);\n    vec3 imagePlanePos = eyep + rayDir * distanceToImagePlane;\n    vec3 offset = (2.0 * tc.x - 1.0) * right + (2.0 * tc.y - 1.0) * up;\n\n    ray.dir = normalize(imagePlanePos + offset - eyep);\n\n    // cast the ray (one ray per pixel for now)\n    vec3 color = trace(ray, scene);\n\n    // final color\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}