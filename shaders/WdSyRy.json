{
    "Shader": {
        "info": {
            "date": "1586809077",
            "description": "first submission to shadertoy, very much still learning. definitely credits to flopine and evvvvil for their seminar on shader coding. TY ^^b.",
            "flags": 0,
            "hasliked": 0,
            "id": "WdSyRy",
            "likes": 1,
            "name": "glitched marching",
            "published": 3,
            "tags": [
                "glitch"
            ],
            "usePreview": 0,
            "username": "jemappelle",
            "viewed": 227
        },
        "renderpass": [
            {
                "code": "float opSubtract(float o0, float o1){return max(-o0,o1);}\n\nfloat opIntersection(float o0, float o1){return max(o0,o1);}\n\nfloat diffuse_directional(vec3 n, vec3 l){\n  \treturn dot(n, normalize(l))*.5 + .5;\n}\n\nfloat sphere(vec3 d, float r){\n  \t//d = mod(d, 2.)-2*0.5;  \n  \treturn length(d)-r;\n}\n\nfloat sdRoundedX(in vec2 d, in float w, in float r ){\n   \td = abs(d);\n   \treturn length(d-min(d.x+d.y,w)*0.5) - r;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h ){\n  \tconst vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  \tp = abs(p);\n  \tp.xy -= 2.0*min(dot(k.xy, p.xy), .0)*k.xy;\n  \tvec2 d = vec2(\n   \tlength(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),p.z-h.y );\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat hexMap(vec3 d){\n    d = mod(d, 2.)-2.*0.5;  \n  \treturn opIntersection(-sdHexPrism(d, vec2(0.6, 1.0)), sdHexPrism(d, vec2(0.61, 1.)));\n}\n\nfloat map(vec3 d){\n  \td = mod(d, 2.)-2.*0.5;  \n  \treturn mix(sdRoundedX(d.xy, 0.3, 0.12), (sphere(d, 0.4)), cos(iTime*0.8*0.8));\n}\n\nvec3 get_normal(vec3 p){\n  \tvec2 eps = vec2(0.01,0.);\n  \treturn normalize(vec3(map(p+eps.xyy) - map(p-eps.xyy),\n    map(p+eps.yxy) - map(p-eps.yxy),  \n    map(p+eps.yyx) - map(p-eps.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=0.5;\n    uv/=vec2(iResolution.y/iResolution.x, 1);\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*sin(iTime+uv.xyx+vec3(0,2,4));\n \tfloat circle = smoothstep(0.05*uv.y, 0.5,length(uv.x));\n  \n  \tvec3 ro = vec3(0.+cos(iTime)/2.,0.,-8.+(iTime*4.)); \n  \tvec3 p = ro;\n  \tvec3 rd = normalize(vec3(uv,1.));\n  \n  \tbool hit = false;\n  \tbool hit2 = false;\n  \tfloat shading = 0.;\n  \n   \tfor(float i = 0.; i < 35.; i++){\n    \tfloat env = map(p);\n    \tfloat hex = hexMap(p);\n    \tfloat sp = sphere(p, 0.4);\n    \tif(hex<0.01){\n      \t\thit2 = true;\n      \t\tshading = i/50.;\n      \t\tbreak;\n    \t}\n    \t//p -= hex * rd;\n    \t//p += (env - (sin(-hex*iTime))) * rd;\n  \t}\n  \n  \tfor(float i = 0.; i < 35.; i++){\n    \tfloat env = map(p);\n    \tfloat hex = hexMap(p);\n    \tif(env<0.01){\n      \t\thit = true;\n      \t\tshading = i/100.;\n      \t\tbreak;\n    \t}\n    \tp += env * rd;\n    \t//p += (env * sin(-hex*time)) * rd;\n  \t}\n \n  \n  \t//Waving screen\n  \tuv.x += sin(uv.y*8.5)*0.5;\n  \tuv.y += sin(uv.x*8.5+iTime)*0.5;\n  \t//Screen split\n  \tuv.x = mod(uv.x, 0.2)-0.2*0.5;\n  \n  \t//Shape\n  \tfloat verLine = smoothstep(0.05, 0.2,length(uv.y+circle));\n  \n  \t//Color define\n  \tvec3 color = vec3(0.);\n  \n  \n  \t//Color from raymarch\n  \tif(hit){\n    \tvec3 n = get_normal(p);\n    \tvec3 l = vec3(0.5,2.,-2.);\n    \tcolor = get_normal(p) + vec3(shading);\n    \tcolor = mix(vec3(0.8,0.05,0.2), vec3(0.1,0.0,0.0), vec3(diffuse_directional(n,l)));\n    \thit = false;\n  \t}else if(hit2){\n    \tvec3 n = get_normal(p);\n    \tvec3 l = vec3(0.5,2.,-4.);\n    \tcolor = get_normal(p) + vec3(shading);\n    \tcolor = mix(vec3(0.65,0.65,0.7), vec3(0.1,0.0,0.0), mix(vec3(0.65,0.45,0.7), vec3(circle-verLine),\n    \tvec3(diffuse_directional(n,l))));\n    \thit2 = false;\n  \t}else{\n    \t//color = vec3(circle - verLine/shading);\n    \tcolor = vec3(circle -= atan(verLine)*iTime);\n  \t}\n  \tfloat t = length(ro*p);\n  \t//is final output for now\n  \tvec3 fog = mix(color, vec3(0.1,0.1,0.2), 1.*exp(-0.01*t*t));\n    \n  \tfragColor = vec4(fog, 1.) + vec4((color + circle / 1.5), 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}