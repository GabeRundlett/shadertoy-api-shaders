{
    "Shader": {
        "info": {
            "date": "1582394193",
            "description": "Recursive KIFS with glow",
            "flags": 0,
            "hasliked": 0,
            "id": "wtGSRm",
            "likes": 6,
            "name": "Vegan honey",
            "published": 3,
            "tags": [
                "kifs",
                "recursion"
            ],
            "usePreview": 0,
            "username": "rodgzilla",
            "viewed": 391
        },
        "renderpass": [
            {
                "code": "#define time iTime\n#define ZPOS -130.\n\nfloat PI = acos(-1.);\n\nmat2 rot2d(float a) {\n  float c = cos(a), s = sin(a);\n  \n  return mat2(c, s, -s, c);\n}\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat wave(float t, float a) {\n    return a * (.5 * sin(time) + .5);\n}\n\nvec3 kifs(vec3 p, float r, float s, float tf, float it) {\n    float t = tf * time;\n    for (float i = 0.; i < it; i++) {\n        p.xy *= rot2d(t * .6);\n        p.yz *= rot2d(t * .7 - i);\n        p = abs(p);\n        p -= s;\n        s *= r;\n    }\n    \n    return p;\n}\n\nfloat tube(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 ab = b - a;\n  vec3 ap = p - a;\n  float t = dot(ab, ap) / dot(ab, ab);\n  t = clamp(t, 0., 1.);\n  vec3 c = a + ab * t;\n  \n  return length(p - c) - r;\n}\n\nvec3 rep(vec3 p, vec3 r) {\n  vec3 q = mod(p, r) - .5 * r;\n  \n  return q;\n}\n\nfloat at = 0.;\nfloat map(vec3 p) {\n    p = kifs(p, .8, 3., .5, 2.);\n    p = kifs(p, .5, 2. + length(p) * .3, .5, 4.);\n    float d = 5000.;\n    \n    float obj = tube(p, vec3(-2, 0, 0), vec3(2, 0, 0), 1.);\n\tobj = min(obj, tube(p, vec3(0, -2, 0), vec3(0, 2, 0), 1.));\n\tobj = min(obj, tube(p, vec3(0, 0, -2), vec3(0, 0, 2), 1.));\n    obj = max(obj, sph(p, 2.));\n    obj = mix(obj, sph(p, 1.), wave(1., 1.));\n    d = min(d, obj);\n    \n    at += .05 / (.2 + d);\n    \n    return d;\n}\n\nvec3 glow = vec3(0, 0, 0);\nfloat rm(vec3 ro, vec3 rd) {\n  float d = 0.;\n  \n  for (int i = 0; i < 100; i++) {\n    vec3 p = ro + d * rd;\n    float ds = map(p);\n    \n    if (ds < 0.01 || ds > 100.) {\n      break;\n    }\n    \n    d += ds * .8;\n    glow += .002 * at * vec3(.5, .3 + wave(.5, .4), 0.);\n  }\n  \n  return d;\n}\n\nvec3 normal(vec3 p) {\n  vec2 e = vec2(0.01, 0);\n  \n  vec3 n = map(p) - vec3(\n    map(p - e.xyy),\n    map(p - e.yxy),\n    map(p - e.yyx)\n  );\n  \n  return normalize(n);\n}\n\nfloat light(vec3 p) {\n  vec3 lp = vec3(2, 5, ZPOS);\n//  lp.xz *= rot2d(time);\n  vec3 tl = lp - p;\n  vec3 tln = normalize(tl);\n  vec3 n = normal(p);\n  float dif = dot(n, tln);\n  float d = rm(p + .01 * n, tln);\n  \n  if (d < length(tl)) {\n    dif *= .1;\n  }\n  \n  return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    uv *= .5 + wave(1., .5);\n//    uv *= sin(time);\n//    uv *= rot2d(sin(time) * PI);\n\n\tvec3 ro = vec3(0, 0, ZPOS);\n  \tvec3 rd = normalize(vec3(uv, 1.));\n    \n  \tfloat d = rm(ro, rd);\n  \tvec3 p = ro + d * rd;\n  \tfloat dif = light(p);\n  \t\n//    vec3 col = .2 * dif * glow;\n  \tvec3 col = glow;\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}