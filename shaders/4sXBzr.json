{
    "Shader": {
        "info": {
            "date": "1494538180",
            "description": "set time=0 and go full screen!\n\nBy chance or by moire, your pattern recognition will make yo see \"ghost glyphs\" in this texture of far zooming out hashed  tiled high contrast glyphs.\nYou could set the hash function to return any string for a linear input.",
            "flags": 0,
            "hasliked": 0,
            "id": "4sXBzr",
            "likes": 9,
            "name": "this \"noise\" is hashed glyphs",
            "published": 3,
            "tags": [
                "2d",
                "grid",
                "text",
                "hue",
                "tiling",
                "matrix",
                "tile",
                "hash",
                "babel",
                "glyh",
                "libraryofbabel",
                "complementary",
                "dwarffortress"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1119
        },
        "renderpass": [
            {
                "code": "\n/*\nBy chance or by moire, your pattern recognition will make yo see \"ghost glyphs\"\nin this texture of far zooming out hashed  tiled high contrast glyphs.\n\nThis could be cute within fbm\n\nYou could set the hash function to return any string for a linear input.\n*/\n\n//self  = https://www.shadertoy.com/view/4sXBzr\n//parent= https://www.shadertoy.com/view/MdjcDd (uses triangle grid)\n\n/*\nAn attempt at making text rendering FASTER \n...by putting it on a tiled grid, \nso that every fragment only checks for one glyph within the same tile.\n\nthen ANY AMOUNT of (kinda repeating/hashed) text\n... at any zoom level gives the same performance.\n\n\nThis enables you to give your hashed noise some \"meaning\"\n\nif ([backContrast] is set to a value far away from 0.5){\n By chance or by moire, your pattern recognition \n ...can make you see \"ghost glyphs\" in this texture \n ...of far zooming out hashed glyphs on a tiled grid.\n}\n\nThis could be cute within fractal brownian motion noise.\n\nYou could set the hash function to return any string \n..for a linear input of a [hash function with \"string exceptions\"]\n\n\non rendering text FASTER \n\n[slow text]:\nevery fragment sums up the brightness of EVERY glyph and has to \n...check each glyph, even if it is easily nowhere near the fragment.\n\n[fast text]:\nexists on rectangular tiling.\nevery tile has exactly 1 glyph in it\nevery fragment sums up the brightness of only one glyph.\n\n[slow text] has the advantage of allowing overlapping glyphs.\nFor [fast text] to have overlapping glyphs, \n[fast text] just needs multiple iterations with offsets.\nBut htis is usually not necessary at all,\nunless you want to use this for fbm()\n\n[fast text] does not combine well \n...with the mipmap texture filter for the glyph texture.\n... because it causes visibletile borders.\n... For shame, because mipmap imovices the average of far zoomed out cases.\n...and it needs \"repeat\" Wrap.\n*/\n\n//control flow of time\n#define time iTime-acos(-1.)-.2\n//use below for \"zoomed in\"\n//#define time .1+acos(-1.)\n//use below for \"zoomed out\"\n//#define time .1\n\n//oscillating over time range [0..1], different wavelengths.\n#define time1 (cos(time   )*.5+.5)\n#define time2 (cos(time*9.)*.5+.5)\n\n//zoom factor\n//values >99999 have rounding errors mess up all the things\n#define ViewZoom (time1*9999.)\n\n//size of tile\n#define TileSize (vec2(2,3)*.4)\n\n//set brightness of glyph backgound to glyph ratio, range [0..1]\n//ideally iis set to .5 as average.\n#define backContrast time2\n\nfloat hash31(vec3 p){return fract(cos(dot(p, vec3(157, 113, 7)))*45758.5453); }\n\n//glyph texture addresses:\n#define FONT_SPACE 0.5\nconst vec2 vFontSize  = vec2(8.0, 15.0);  // multiples of 4x5 work best\n#define SPACE tp.x-=FONT_SPACE;\n#define S(a) c+=char(a);   tp.x-=FONT_SPACE;\n#define _sub   S(45);   // -\n#define _add   S(43);   // + \n/*\n#define _note  S(10);   //\n#define _star  S(28);   // *\n#define _smily S(29);           \n#define _ tp.x-=FONT_SPACE;\n#define _exc   S(33);   // !\n#define _comma S(44);   // ,\n#define _dot   S(46);   // .\n#define _slash S(47);   // /\n#define _0 S(48);\n#define _1 S(49);\n#define _2 S(50);\n#define _3 S(51);\n#define _4 S(52);\n#define _5 S(53);\n#define _6 S(54);\n#define _7 S(55);\n#define _8 S(56);\n#define _9 S(57);\n#define _ddot S(58);   // :\n#define _sc   S(59);   // ;\n#define _less S(60);   // <\n#define _eq   S(61);   // =\n#define _gr   S(62);   // >\n#define _qm   S(63);   // ?\n#define _at   S(64);   // at sign \n#define _A S(65);\n#define _B S(66);\n#define _C S(67);\n#define _D S(68);\n#define _E S(69);\n#define _F S(70);\n#define _G S(71);\n#define _H S(72);\n#define _I S(73);\n#define _J S(74);\n#define _K S(75);\n#define _L S(76);\n#define _M S(77);\n#define _N S(78);\n#define _O S(79);\n#define _P S(80);\n#define _Q S(81);\n#define _R S(82);\n#define _S S(83);\n#define _T S(84);\n#define _U S(85);\n#define _V S(86);\n#define _W S(87);\n#define _X S(88);\n#define _Y S(89);\n#define _Z S(90);\n#define _a S(97);\n#define _b S(98);\n#define _c S(99);\n#define _d S(100);\n#define _e S(101);\n#define _f S(102);\n#define _g S(103);\n#define _h S(104);\n#define _i S(105);\n#define _j S(106);\n#define _k S(107);\n#define _l S(108);\n#define _m S(109);\n#define _n S(110);\n#define _o S(111);\n#define _p S(112);\n#define _q S(113);\n#define _r S(114);\n#define _s S(115);\n#define _t S(116);\n#define _u S(117);\n#define _v S(118);\n#define _w S(119);\n#define _x S(120);\n#define _y S(121);\n#define _z S(122);\n/**/\n\n#define tpp tp.x+=FONT_SPACE\n#define tpm tp.x-=FONT_SPACE\nvec2 tp=vec2(0);//text position\nvoid SetTextPosition(vec2 p,float x,float y){//x=line, y=column\n tp=10.0*p;tp.x=tp.x+17.-x;tp.y=tp.y-9.4+y;}\n//return number of decimal digits of [f], with [d]leading zeroes.\nint getNumberOfDigits(in int f,in int d){\n for(int n=0;n<10;n++){f/=10;if(f==0)break;d++;}return d;}\nfloat char(int c){vec4 f=any(lessThan(vec4(tp,1,1),vec4(0,0,tp))) \n ?vec4(0):texture(iChannel0,.0625*(tp+vec2(c-c/16*16,15-c/16)));  \n return f.x;}\n/*\n//display [f]fraction with [d]leadingZeros \nfloat drawFract(int d,float f){float c=0.;f=fract(f)*10.; \n for(int i=1;i<60;i++){c+=char(48+int(f));tpm; \n  d--;f=fract(f)*10.;if(d<=0||f==0.) break;\n }tpp*float(d);return c;}\n*/\n//draw [v]int with a minimum # of [m]glyphs\nfloat drawInt(int v,int m){float c=0.;\n if(v<0){v=-v;_sub//if(m<1){m=1;}else m--;\n  }else{_add//if(v<0){v=-v;if(m<1){m=1;}else m--;\n }//sign handling\n int f=v,d=1;d=getNumberOfDigits(f,d);//for(int n=0;n<10;n++){f/=10;if(f==0)break;d++;} \n //d=max(m,d);\n tpm*float(d);\n for(int n=1;n<11;n++){tpp;c+=char(48+(v-((v/=10)*10)));if(n>=d)break;} \n tpm*float(d);return c;}//https://www.shadertoy.com/view/ldByDw\n/*\n//display [v]float with [p]decimalPrecision and [m]maxDigits\nfloat drawFloat(float v,int p,int m){float c=0.,tpx=tp.x-FONT_SPACE*float(m);\n if (v<0.){c=char(45);v=-v;}tp.x-=FONT_SPACE; //write \"-\"\n c+=drawInt(int(v),1);c+=char(46);SPACE;//write floor()+\".\"+fract()    \n c+=drawFract(p,fract(v));tp.x=min(tp.x,tpx);return c;}\n//shorter defaults\nfloat drawFloat(float v)      {return drawFloat(v,2,5);} \nfloat drawFloat(float v,int p){return drawFloat(v,p,2);} \nfloat drawInt(int v)          {return drawInt(v,1);}\nvec3 drawColor=vec3(1.);\nvoid SetGlyphColor(float r,float g,float b){drawColor=vec3(b,g,b);}\n*/\n\n\n\n//number of unique glyph addresses\n#define addresses 256.\n\n//return color of glyphs for [p], glyph-numerals set by [i]\nvec3 glyphs(vec2 p,float glyph){\n p*=.08;//optional, making glyphs as large as possible\n p.x*=1.2;\n float x=16.5,y=9.9;//offsets\n SetTextPosition(p,x,y);vec3 c;\n S(65+int(glyph*addresses));\n //S(65+int((a.x+a.y)*addresses));\n //_B//alternatively only draw \"B\" or an integer\n //c+=drawInt(1,0);//this function may add a leading \"+\" sign\n return c;}\n\n\n//float pmod (float p,float s){float h=s*.5;return mod(p+h,s)-h;}\n//float pmodM(float p,float s){float h=s*.5;return floor((p+h)/s);}\nvec2 pmod (vec2 p,vec2 s){vec2 h=s*.5;return mod(p+h,s)-h;}\nvec2 pmodM(vec2 p,vec2 s){vec2 h=s*.5;return floor((p+h)/s);}\n\nvec2 frame(vec2 u){u/=iResolution.xy;u-=.5;\n u.x*=iResolution.x/iResolution.y;u*=ViewZoom;return u;}\n\n//return fully saturated hue.rgb of [h]; 0=1=red, 1/3=green, 2/3=blue \nvec3 hue(float h){return clamp(abs(mod(h*6.+vec3(0,4,2),6.)-3.)-1.,0.,1.);}\n\n\n//assume [y] to be greyscale and x to be (almost) fully saturated.\n//if(x=0.5) [a] stays the same.\n//return [x] for y=0.; return  complementary color of [x] for y=1., \nvec3 cmplementBy(vec3 x, vec3 y){\n    y-=backContrast;//y-=.5;\n    x-=.5;return x*y*4.;}\n//cmplementBy() gives great contrast and nice smooth grey outlines.\n//is a lazy way to control the \"average\" of this noise.\n\nvoid mainImage(out vec4 O,vec2 U){\n vec2 u=frame(U),m=frame(iMouse.xy);u-=m; \n vec2 h=pmodM(u,TileSize);\n h=fract(h/addresses);\n u=pmod(u,TileSize);\n //float c=smoothstep(.01,.0,length(u)-.01)*.5;//circle at mouse position\n vec2 a=u;a=pmodM(a,TileSize);\n a=floor(a*4.);//a shhows coords within a tile, soewhat\n    \n  float glyph=hash31(vec3(h,9));\n //[glyph] sets what should be displayed in a tile\n //[glyph] is range [0..1] (being hashed and freeding a hue() function)\n //[glyph] gets scaled to range [0..255] to address 255 characters.\n \n vec3 col=cmplementBy(hue(glyph),glyphs(u,glyph));//+c;\n O=vec4(col,1);}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}