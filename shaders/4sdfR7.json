{
    "Shader": {
        "info": {
            "date": "1524541206",
            "description": "Taking a stab at actually implementing path tracing. Messing around with a sample scene from my old graphics project. You can move around with the mouse, but you have to reset the shader each time. 'i' key to reset the shader.",
            "flags": 48,
            "hasliked": 0,
            "id": "4sdfR7",
            "likes": 0,
            "name": "Path Tracing Adventures",
            "published": 3,
            "tags": [
                "3d",
                "pathtracing",
                "tracing",
                "path"
            ],
            "usePreview": 0,
            "username": "twitchingace",
            "viewed": 579
        },
        "renderpass": [
            {
                "code": "#define keyTex iChannel3\n#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    \n    if( iFrame>0 )\n    {\n        col = texture( iChannel0, uv ).xyz;\n        col /= float(iFrame) - texture( iChannel0, uv ).w;\n        col = pow( col, vec3(0.4545) );\n    }\n    \n    \n    // color grading and vignetting\n    col = pow( col, vec3(0.8) ); col *= 1.6; col -= vec3(0.03,0.02,0.0);\n    \n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n    \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159\n#define keyTex iChannel3\n#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\nconst float focalLength = 800.0;\nconst float discR = 20.0;\nvec3 eye = vec3(0.0, 0.0, 800.);\nconst float amb = 0.1;\n\nconst int numL = 6;\nconst int numSpheres = 10;\n\nstruct Light{\n    vec3 pos;\n    vec3 col;\n};\nLight l[numL];\n    \nstruct Material{\n\tvec3 kd;\n    vec3 ks;\n    float reflectance;\n    float transparency;\n    float indR;\n    float phongN;\n    \n};\n   \nstruct Sphere{\n\tvec3 pos;\n    Material mat;\n    float radius;\n};\nSphere spheres[numSpheres];\n    \nstruct Ray{\n\tvec3 ro;\n    vec3 rd;\n    float indR;\n};\n    \nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat intersectSphere(Ray ray, Sphere s){\n    vec3 d = ray.ro - s.pos;\n    float A = dot(ray.rd, ray.rd);\n    float B = 2. * dot(ray.rd, d);\n    float C = dot(d, d) - s.radius * s.radius;\n        \n    float D = B*B - 4.*A*C;\n    if (D < 0.0) return -1.0;\n    \n    float t = -B - sqrt(D);\n\tif (t / (2.0 * A) < 0.) { // Closest intersection behind the ray\n  \t\tt += 2.*sqrt(D); // t = -B + sqrt(D)\n\t}\n\tif (t / (2.0 * A) < 0.) {\n  \t\treturn -1.0;\n\t}\n \treturn t / (2.0 * A);   \n}\n\n// Returns true if there's an object that intersects with the ray. Used for shadowing.\nbool castShadow(Ray ray){\n    for (int i = 0; i  < numSpheres; i++){\n    \tfloat t = intersectSphere(ray, spheres[i]);\n\t    if (t >= 0.1){\n    \t\treturn true;\n    \t}\n    }\n    return false;\n}\n\n// Ray that hits the surface, how far along it does, the surface normal, and the hit material\nvec3 phongLight(Ray ray, vec3 sP, vec3 norm, Material mat){\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < numL; i++){\n        vec3 col2 = vec3(0.0);\n            vec3 lpos = l[i].pos;\n        \t// Do soft shadows by faking our point lights as 50x50x50 area lights\n        \tlpos += vec3(rand(vec2(3.4, sin(iTime * 7.2 + 4.3)) - 0.5) * 50.0,\n                         rand(vec2(cos(iTime * -0.4), sin(iTime * 5. + 0.3)) - 0.5) * 50.0,\n                         rand(vec2(5.4, sin(iTime * 2.2 + .04)) - 0.5) * 50.0);\n            \n            vec3 sDir = lpos - sP;\n            sDir /= length(sDir);\n            Ray sRay;\n            sRay.rd = sDir;\n            sRay.ro = sP;\n\n            if (castShadow(sRay)){\n                continue;   \n            }\n\n            // Add in diffuse bit\n            float diffCoeff = max(0.0, dot(norm, sDir));\n            col2.x += mat.kd.x * l[i].col.x * diffCoeff;\n            col2.y += mat.kd.y * l[i].col.y * diffCoeff;\n            col2.z += mat.kd.z * l[i].col.z * diffCoeff;\n\n            // Add in specular bit\n            vec3 refDir = reflect(sDir, norm);\n            float specDot = max(0.0, dot(ray.rd, refDir));\n            float specCoeff = pow(specDot, mat.phongN);\n\n            col2.x += mat.ks.x * l[0].col.x * specCoeff;\n            col2.y += mat.ks.y * l[0].col.y * specCoeff;\n            col2.z += mat.ks.z * l[0].col.z * specCoeff;\n        \n        col += col2;\n    }\n    col /= float(numL);\n    \n    return col + amb * mat.kd;\n}\n\nvec3 castRay(Ray ray, int levels){\n    vec3 tcol = vec3(0.0);\n    vec3 fcol = vec3(1.0);\n    vec3 dcol = vec3(0.0);\n    for (int j = 0; j < levels; j++){\n        Material hitM = Material(vec3(0.0), vec3(0.0), 0.0, 0.0, 0.0, 0.0);\n        vec3 hitNorm = vec3(0.0);\n        float tMin = 999999.0;\n\n        // Let's go through each object in the scene, check which is the closest\n        for (int i = 0; i  < numSpheres; i++){\n            float t = intersectSphere(ray, spheres[i]);\n            if (t >= 0.1 && t <= tMin){\n                hitM = spheres[i].mat;\n                hitNorm = ray.ro + t * ray.rd - spheres[i].pos;\n                hitNorm /= length(hitNorm);\n                tMin = t;\n            }\n        }\n\n        // Do Phong reflection model\n        if (tMin < 9999.0){\n            dcol = phongLight (ray, ray.ro + tMin *ray.rd, hitNorm, hitM);  \n            ray.ro = ray.ro + tMin *ray.rd;\n            float odds = rand(vec2(cos(iTime * 1.4) * 5.4, 1.3));\n            if (odds < hitM.ks.x){ // if we decide to do spec reflection\n                vec3 refDir = reflect(ray.rd, hitNorm);                \n                ray.rd = refDir;\n            }else{ // if we decide to do diffuse\n\t\t\t\tfloat r1 = rand(vec2(0.2 + sin(iTime * 4.2 + 0.2), -1.3));\n                float r2 = rand(vec2(1.2, 4.3));\n                \n                ray.rd = vec3(cos(2. * PI * r1) * sqrt(1. - (r2 * r2)),\n                              sin(2. * PI * r1) * sqrt(1. - (r2 * r2)),\n                              r2);\n            }\n        }else{\n            if ( j == 0 ){ fcol = vec3(0.0);}\n            else { break;}\n        }\n        \n        fcol *= hitM.kd;\n        tcol += fcol * dcol;\n    }\n    return tcol;\n}\n\nvoid initScene(){\n    // Define lights\n    l[0] = Light(vec3(-600.0, 200., 00.0), vec3(0.9));\n    l[1] = Light(vec3(0.0, 400., 400.0), vec3(0.9));\n    l[2] = Light(vec3(600.0, 200., 00.0), vec3(0.9));\n    \n    l[3] = Light(vec3(-600.0, 200., 00.0), vec3(0.3, 0.0, 0.7));\n    l[4] = Light(vec3(0.0, 0., 0.0), vec3(0.6, 0.7, 0.2));\n    l[5] = Light(vec3(320.0, 400., 500.0), vec3(1.0, 0.0, 0.0));\n    \n    // Define materials\n    Material m1 = Material(vec3(0.6, 0.6, 0.6), vec3(1.), 0.5, 0.0, 1.0, 14.);\n    Material m2 = Material(vec3(0.3, 0.6, 0.4), vec3(0.2), 0.0, 0.5, 1.52, 14.);\n    Material m3 = Material(vec3(0.2, 0.2, 0.8), vec3(0.3), 0.5, 0.0, 1.0, 14.);\n    Material m4 = Material(vec3(0.4, 0.2, 0.4), vec3(0.8), 0.0, 0.5, 1.52, 14.);\n    Material m5 = Material(vec3(0.4, 0.7, 0.8), vec3(0.6), 0.5, 0.0, 1.0, 14.);\n    Material m6 = Material(vec3(0.3, 0.6, 0.4), vec3(0.55), 0.0, 0.5, 1.52, 10.);\n    \n    //Define shapes\n    spheres[0] = Sphere(vec3(-200.0, 100.0, -100.0), m1, 150.);\n    spheres[1] = Sphere(vec3(000.0, 0.0, -300.0), m2, 150.);\n    spheres[2] = Sphere(vec3(0.0, -750.0, 00.0), m2, 600.);\n    spheres[3] = Sphere(vec3(00.0, 0.0, -2500.0), m1, 1500.);    \n    spheres[4] = Sphere(vec3(200.0, 100.0, 100.0), m3, 150.);\n    spheres[5] = Sphere(vec3(000.0, -50.0, -300.0), m4, 150.);\n    spheres[6] = Sphere(vec3(230.0, -250.0, -100.0), m4, 100.);\n    spheres[7] = Sphere(vec3(-500.0, 0.0, -1400.0), m3, 600.);\n    spheres[8] = Sphere(vec3(00.0, 300.0, 200.0), m5, 150.);\n    spheres[9] = Sphere(vec3(300.0, -200.0, -600.0), m6, 150.);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    initScene();\n    \n    eye.xy += (iMouse.xy - 0.5 * iResolution.xy);\n\tvec2 uv = fragCoord.xy / iResolution.xy - vec2(0.5);\n    vec2 size = iResolution.xy;\n    \n    vec4 col = texture( iChannel0, fragCoord/iResolution.xy ).xyzw;\n    \n    // We want to store the last frame we refreshed the image, so it doesn't fade\n    // as we do it. We use the last channel of the texture for that.\n    if( iFrame==0 || KEY_I > 0.5) col = vec4(0.0, 0.0, 0.0, float(iFrame));\n    \n    uv += vec2((0.5 / iResolution.x) * (0.5 - rand(vec2(1.02 + uv.x + 2.3 * cos(iTime * 0.1),\n                                     0.52 + uv.y))),\n               (0.5 / iResolution.y) * (0.5 - rand(vec2(1.02 + uv.x + 2.3 * cos(iTime * 0.1),\n                                     0.52 + uv.y))));\n    Ray ray = Ray(vec3(0.0), vec3(0.0), 1.0);\n    ray.ro = eye;\n    ray.rd = vec3(uv, -1.0);\n    ray.rd /= length(ray.rd);   \n    \n    vec3 focalPoint = ray.ro + focalLength * ray.rd;\n    ray.ro = eye;\n    ray.ro += vec3(discR * (0.5 - rand(vec2(1.02 + uv.x + 2.3 * cos(iTime * 0.1),\n                                     0.52 + uv.y))),\n                   discR * (0.5 - rand(vec2(2.4 + uv.x,\n                                     1.3 + uv.y + 503. * cos(iTime * 0.4 + 1.0)))), 0.);\n    ray.rd = focalPoint - ray.ro;\n    ray.rd /= length(ray.rd);\n    col.xyz += castRay(ray, 10);\n \n    fragColor = vec4( col );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}