{
    "Shader": {
        "info": {
            "date": "1592403857",
            "description": "Great lecture on Newton's method - https://www.youtube.com/watch?v=j6ikEASjbWE\n",
            "flags": 0,
            "hasliked": 0,
            "id": "wtsyRS",
            "likes": 9,
            "name": "Newton's method [Day 180]",
            "published": 3,
            "tags": [
                "tutorial",
                "newton",
                "maths",
                "root",
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 376
        },
        "renderpass": [
            {
                "code": "// Also check out Bisection method demonstration - https://www.shadertoy.com/view/3tsyzj\n\n// Newton's root finding method\n// Great video on the subject - https://www.youtube.com/watch?v=j6ikEASjbWE\n\n// function smoothing thanks to iq and mla\n\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n#define rot(j) mat2(cos(j), sin(j), -sin(j), cos(j))\n        \n#define feps 0.0001\n\n#define offs \t\t(iTime/1.5)\n\n#define fn(j) \t\t(cos(j+offs)+sin( (j+offs)*2. ))\n#define deriv(j) \t(fn(j+feps)-fn(j))/feps\n\n\n// Plotting width\nconst float W = 0.025;\n\n\nconst float eps = 0.01;\nvec3 graph(float y, float fn0, float fn1, vec3 col, float width){\n  return smoothstep(W*width*1.,W*width*0.5, \n                    abs(fn0-y)/length(vec2((fn1-fn0)/eps,1.)))*col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y*5.;\n\n    vec3 col = vec3(0);\n    \n    // function\n\tcol += graph( uv.y, fn(uv.x),\t  fn(uv.x+eps),     vec3(0.8,.75,0.8), 1. );\n    \n    \n    // plotlines\n    \n    col += graph(abs(uv.y),0.,dFdx(uv.x),vec3(1,1,1),0.5);\n    \n    \n    float off = 0.;\n    \n    float iters = 4.;\n    for(float i = 0.; i <= iters; i++){\n        float f = fn(0. - off);\n    \tfloat dfdx = deriv(0. - off);\n    \t\n        vec2 fnuv = uv - vec2(-off,f);\n        \n        \n        vec3 c1 = pal(0.5,0.5,vec3(0.9,0.1,0.1),1.,i*1. + 1.);\n        \n        // slope\n        float theta = atan(dfdx);\n        \n        col = mix(col, c1,smoothstep(W*1., W*0.5, abs( ( fnuv*rot(theta)).y))) ;\n        \n        // column\n        col = mix(col,c1,smoothstep(W*1.,W*0.5, max(abs(fnuv.x), abs(fnuv.y +f/2. ) -abs(f/2.))) );\n        \n        float hypotenuse = f/sin(theta); // cos(theta) = adj / hypotenuse\n        float lowerleg = sqrt(hypotenuse*hypotenuse - f*f); \n        \n        // not my proudest line of code lol\n        lowerleg = lowerleg*(-1. + float(dfdx <0.)*2. - float(f <0. && dfdx < 0.)*2. + float(f <0. && dfdx > 0. )*2. );\n        \n        // lower leg of triangle\n        col = mix(col,c1,smoothstep(W*1.,W*0.5,length(fnuv - vec2( lowerleg,-f))));\n        \n        off -= lowerleg;\n        \n        // function value\n        col = mix(col,c1,smoothstep(W*3.,W*2.,length(fnuv)));\n        \n        \n    }\n    \n    \n    \n    col = smoothstep(0.,1.,col);\n    \n    // gamma correction\n    \n    col = pow(col,vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}