{
    "Shader": {
        "info": {
            "date": "1583882374",
            "description": "need optimization and coloring",
            "flags": 0,
            "hasliked": 0,
            "id": "3lVSDd",
            "likes": 7,
            "name": "caterpillar sort of thing",
            "published": 3,
            "tags": [
                "raymarch",
                "caterpillar"
            ],
            "usePreview": 0,
            "username": "libensvivit",
            "viewed": 337
        },
        "renderpass": [
            {
                "code": "float Sphere(vec3 p, float radius) {\n\treturn length(p)-radius;\n}\n\n// Blending function\nfloat smin( float a, float b, float k ){\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\n// Get the distance to the plane and sphere\nfloat GetDist(vec3 p) {\n    float d = p.y;\n    float t = iTime;\n    \n    for(float i = 5.; i >= 1.; i-=1.) {\n        float size = .9 + i *.15 + 0.1*sin(iTime);\n        float spiral = 9.; \t\t\t\t\t\t\t// eight figure size\n        float ds = size*2.5; \t\t\t\t\t\t// distance between spheres\n        \n        float x = spiral*cos(t+ds);\n        float y = .3+1.5*size*sin(3.*t+i);\n        float z = spiral*cos(t+ds)*sin(t+ds);\n        \n    \td = smin(Sphere(p-vec3(x, y, z), size), d, .4);\n    }\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat d = 0.;\n    for(int i = 0; i < 80; i++) {\n    \tfloat step = GetDist(ro + rd*d);\n        d += step*.5;\n        if(abs(d) < 0.0001 || d > 30.) break;\n    }\n    return d;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0.);\n    vec3 normal = d - vec3(GetDist(p-e.xyy),\n                           GetDist(p-e.yxy),\n                           GetDist(p-e.yyx)); //differentiation\n    normal = normalize(normal);\n    return normal;\n}\n\nfloat GetLight(vec3 p){\n\tvec3 light = vec3(3., 10., 7.);\n    vec3 normal = GetNormal(p);\n    \n    vec3 lightVec = normalize(light-p);\n    float dif = max(0., dot(normal, lightVec));\n    float shadow = RayMarch(p+normal*.002, lightVec);\n    \n    if(shadow < length(light-p)){\n        dif *= clamp(shadow*.2, 0.,1.);\n    }\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n    vec3 col = vec3(0.);\n   \n    // any ideas about mouse rotation?\n    vec3 ro = vec3(8., 10., 13.);\n    vec3 lookAt = vec3(0.);\n    float zoom = 1.;\n    \n    // front, right and up vectors (3d camera model)\n    vec3 f = normalize(lookAt - ro);\n    vec3 r = normalize(cross(f, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(r,f));\n    vec3 c = ro + f * zoom; \t\t\t// center\n    vec3 i = c + r*uv.x + u*uv.y; \t\t// point on the rotated uv screen\n    vec3 rd = i - ro;\n    \n    float d = RayMarch(ro, rd);\n    float dif = GetLight(ro + rd *d);\n    col = vec3(dif);\n    \n    fragColor = vec4(col,1.0);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}