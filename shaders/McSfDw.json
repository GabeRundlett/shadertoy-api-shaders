{
    "Shader": {
        "info": {
            "date": "1725008183",
            "description": "originals from glslsandbox;",
            "flags": 0,
            "hasliked": 0,
            "id": "McSfDw",
            "likes": 0,
            "name": "borean tundra space",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 67
        },
        "renderpass": [
            {
                "code": "\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n#define  time iTime\n#define  resolution iResolution.xy\n\n\n// Emulate a black texture\n#define texture(s, uv) vec4(0.0)\n\n// --------[ Original ShaderToy begins here ]---------- //\n/**\n    Fractal Remix | Box Fractal\n\torignal @gaz https://twigl.app/?ch=-MFu0X8wYxqxuhK4Cgd9&dm=graphics \n \tI translated you're comments...\n\n\ttime based animation changes\n\trotating though x/z vectors\n\n\thelp/motion\n\tthebookofshaders.com/examples/\n\n*/\n// not tied to uniform names\n#define R           iResolution\n#define M           iMouse\n#define T           iTime\n#define S           smoothstep\n#define PI          3.1415926\n#define PI2         6.2831853\n#define d5          .5773\n#define MINDIST     .0001\n#define MAXDIST     100.\n\n#define r2(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n//thebookofshaders timing functions\nfloat easeInOutExpo(float t) {\n    if (t == 0.0 || t == 1.0) return t;\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * pow(2.0, 10.0 * (t - 1.0));\n    } else {\n        return 0.5 * (-pow(2.0, -10.0 * (t - 1.0)) + 2.0);\n    }\n}\n\nfloat linearstep(float begin, float end, float t) {\n    return clamp((t - begin) / (end - begin), 0.0, 1.0);\n}\n\nfloat circle(vec2 pt, vec2 center, float r, float lw) {\n  float len = length(pt - center),\n        hlw = lw / 2.,\n        edge = .11;\n  return smoothstep(r-hlw-edge,r-hlw, len)-smoothstep(r+hlw,r+hlw+edge, len);\n}\n\nvec3 getMouse(vec3 p) {\n\t\n    float x = M.xy == vec2(0) ? -.6 : -(M.y/R.y * 1. - .5) * PI;\n    float y = M.xy == vec2(0) ? -1. :  (M.x/R.x * 1. - .5) * PI;\n    \n \n    return p;\n}\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\t\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.)-.05;\n}\nfloat orbit = .01,\n      txx   = .01025,\n      txa   = .005,\n      glw   = .0;\nfloat zoom = 1.5; \nmat2 rotA = mat2(0.), rotB = mat2(0.), spin = mat2(0.);\n\nfloat Scale;\nvec3 map(vec3 p,float mgl){\n  \t\n   \n    vec3 res = vec3(100.,-1.,0.);\n\n    float b = sdBox(p,vec3(3.5));\n    if(b<res.x) res=vec3(b,2.,orbit);\n   \n    p=abs(p)-3.5;\n\n    if(p.x<p.z)p.xz=p.zx;\n    if(p.y<p.z)p.yz=p.zy;\n    if(p.x>p.y)p.xy=p.yx;\n\n  \n\tfloat rate=+15.5;\n\t\n\t// This number has good sensitivity, so I think it is fine.\n\tfloat mr2=0.105;\n\t// I think the standard here is about 0.3 to 1.8.\n\tfloat off=0.37;\t// This number is the initial magnification. \n    \tfloat s=.35;\n    // Fractal folding is IFS of magnification. After changing the scale, move to make changes.\n    // The initial coordinates are used for the movement amount. By the way, \n    //the variable of off is used to adjust the degree of this movement amount.\n    vec3  p0 = p;\n\n    // You can play around with the number of iterations.\n    for (float i=0.; i<10.; i++){\n\n    // Please do not tamper with this function.\n    p=5.5-abs(p-1.);\n\n    // You can play around with all the constants here.\n    float g=clamp(mr2*max(1.25/dot(p,p),.8),0.,1.);\n\n    // Please do not tamper with these two lines.\n    p=p*rate*g+p0*off;\n    s=s*abs(rate)*g+off;\n        \n    // Rotate the coordinates a little. It's a bit peaky, so try it little by little.\n    // You can do various things without rotating it forcibly. I think it's better to use it with an accentã€‚\n    \n\t  p.xy*=r2(iTime*0.11);\n    p.yz*=r2(iTime*0.11);\n    }\n\n    // This number is log2() the final scale factor. It is a parameter for coloring.\n    // There is no problem with log() separately. I'm using it with a glue like log2() because it will be multiplied like twice.\n    Scale = log2(s);\n\torbit=log2(s*.0091553);\n    // Three final output distance functions are prepared. Please use it by replacing it.\n    // The last 0.03 is the thickness of the line, so you can change it\n    //return length(p.xy)/s-.003;\n    \n    float d= length(p.xz)/s-.025;\n    d= max(sdBox(p,vec3(5.))/s-.01,-d);\n    if(d<res.x) res=vec3(d,1.,orbit);\n    //glw += .00025/(.025+d*d);//@evvvil \n    glw += .15/(.3+b*b);//@evvvil\n    return res;\n    //return length(cross(p,normalize(vec3(1))))/s-.003;\n}\n\n// distance estimator\nvec3 marcher(vec3 ro, vec3 rd, int maxsteps) {\n    float d = 0.,\n          m = -1.,\n          o = 0.;\n    int i = 0;\n\t\n    for(int ii = 0; ii<256; ii++) {\n        vec3 p = ro + rd * d;\n        \t\n        vec3 t = map(p,1.);\n        if(t.x<MINDIST||d>MAXDIST) break;\n        d += t.x*.5;\n        m  = t.y;\n        o  = t.z;\n        ++i;\n    }\n    float de = float(i)/float(maxsteps);\n    return vec3(d,m,o);\n}\n\n// Tetrahedron technique @iq\n// https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 getNormal(vec3 p, float t){\n\n    float e = (MINDIST + .0001) *t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ,0.).x + \n                      h.yyx*map( p + h.yyx*e ,0.).x + \n                      h.yxy*map( p + h.yxy*e ,0.).x + \n                      h.xxx*map( p + h.xxx*e ,0.).x );\n}\n\n//camera setup\nvec3 camera(vec3 lp, vec3 ro, vec2 uv) {\n    vec3 f=normalize(lp-ro),//camera forward\n         r=normalize(cross(vec3(0,1,0),f)),//camera right\n         u=normalize(cross(f,r)),//camera up\n         c=ro+f*.95,//zoom\n         i=c+uv.x*r+uv.y*u,//screen coords\n        rd=i-ro;//ray direction\n    return rd;\n}\n//vec3(.45,1.5,1.25)?\nvec3 gethue(float a){return  .5 + .45*cos((4.5*a) - vec3(.25,1.5,2.15));}\n\nvec3 getColor(float m, float o){\n    vec3 h = gethue(o*.25);\n    // use orbit number to band coloring\n    if(o>4.     && o<5.1)   h=vec3(1.);\n    if(o>6.     && o<6.1)   h=vec3(1.);\n    if(o>7.15   && o<7.65)  h=vec3(1.);\n    if(o>8.     && o<8.6)   h=vec3(1.);\n    if(o>.0     && o<.5)    h=vec3(1.);\n    if(o>-.1    && o<-.05)  h=vec3(1.);\n    if(o>-2.2   && o<-1.75) h=vec3(1.);\n    if(o>-3.8   && o<-2.75) h=vec3(1.);\n    if(o>-6.    && o<-5.75) h=vec3(1.);\n    if(o>-9.    && o<-8.75) h=vec3(1.);\n    if(o>-8.5   && o<-7.75) h=vec3(1.);\n    return h;\n}\n\nfloat ao(float j, vec3 p, vec3 n) {\n    return clamp(map(p + n*j,0.).x/j, 0.,1.);   \n}\n\nvoid mainImage( out vec4 O, in vec2 F ){\n    // Precalculations to speed map and my\n    // timing functions - this is new so be\n    // kind. using Book of shader examples.\n    // \n    float tm = mod(T*2.5, 32.);\n    // move x steps in rotation\n    float v1 = linearstep(0.0, 1.0, tm);\n    float a1 = linearstep(2.0, 3.0, tm);\n    \n\tfloat v2 = linearstep(4.0, 5.0, tm);\n    float a2 = linearstep(6.0, 7.0, tm);\n    \n    float v3 = linearstep(8.0, 9.0, tm);\n    float a3 = linearstep(10.0, 11.0, tm);\n    \n    float v4 = linearstep(12.0, 13.0, tm);\n    float a4 = linearstep(14.0, 15.0, tm);\n    \n    float v5 = linearstep(16.0, 17.0, tm);\n    float a5 = linearstep(18.0, 19.0, tm);\n    \n\tfloat v6 = linearstep(20.0, 21.0, tm);\n    float a6 = linearstep(22.0, 23.0, tm);\n    \n    float v7 = linearstep(24.0, 25.0, tm);\n    float a7 = linearstep(26.0, 27.0, tm);\n    \n    float v8 = linearstep(28.0, 29.0, tm);\n    float a8 = linearstep(30.0, 31.0, tm);\n    \n    float degs = mix(0., 360./8.,v1+v2+v3+v4+v5+v6+v7+v8);\n    float degx = mix(0., 360./8.,a1+a2+a3+a4+a5+a6+a7+a8);\n    \n    // mix downs\n    txa = degs;\n    txx = degx;\n    \n    rotB = r2(degs*PI/180.);\n    rotA = r2(degx*PI/180.);\n    \n    spin = r2(-T*.06);\n\n   \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 C = vec3(0.);\n\tvec3 FC = gethue(13.3);\n    vec3 lp = vec3(0.,0.,0.),\n         ro = vec3(0.,0.,-55.);\n         ro = getMouse(ro);\n\n    vec3 rd = camera(lp, ro, uv);\n    vec3 t = marcher(ro,rd, 256);\n    \n    float m = t.y;\n    float o = t.z;\n    \n    if(t.x<MAXDIST) {\n        vec3 p = ro + rd * t.x,\n        \n             n = getNormal(p, t.x);\n        vec3 light1 = vec3(0,25.,-50.0),\n             light2 = vec3(0,25.,30.0);\n        float dif  = clamp(dot(n,normalize(light1-p)),0. , 1.);\n              dif += clamp(dot(n,normalize(light2-p)),0. , 1.);\n        vec3 h = (m==1.) ? getColor(m,o) : FC;      \n        C += dif* (ao (0.5,p,n) + ao(.05,p,n))*h*vec3(2.);\n    } else {\n        C += FC;\n    }\n    \n    vec2 dv = uv+vec2(T*.041,-T*.023);\n    float cir = circle(fract(dv*12.),vec2(0.5),.34,.03);\n    cir += circle(fract(dv*12.),vec2(0.5),.45,.06);\n    vec3 cirx = mix(FC,gethue(14.3),cir);\n    float dt = smoothstep(.2,.65,distance(uv,vec2(0.))*.75);\n    cirx = mix(FC,cirx,dt*.25);\n   \n    C = mix( C, cirx, 1.-exp(-.000125*t.x*t.x*t.x));\n\n  \n    C += vec3(glw*1.25)*vec3(5.,5.2,5.);\n    O = vec4(pow(C, vec3(5.4545)),1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}