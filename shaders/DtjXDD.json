{
    "Shader": {
        "info": {
            "date": "1676101636",
            "description": "Just trying to understand noise and I wondered what it would look like to try to build a noise function on top of a truchet pattern. I came across this lacy pattern and I thought it was interesting enough to share.",
            "flags": 0,
            "hasliked": 0,
            "id": "DtjXDD",
            "likes": 15,
            "name": "Truchet FBM Lace",
            "published": 3,
            "tags": [
                "fbm",
                "truchet"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 277
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//    Just trying to understand noise and I wondered what it would look like to try to\n//    build a noise function on top of a truchet pattern. I came across this lacy pattern\n//    and I thought it was interesting enough to share.\n//\n// ---------------------------------------------------------------------------------------\n\n// From iq's Noise - gradient - 2D https://www.shadertoy.com/view/XdXGW8\nvec2 grad( ivec2 z )  // replace this anything that returns a random vector\n{\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n    // simple random vectors\n    return vec2(cos(float(n)),sin(float(n)));                       \n}\n\nmat2 rotate(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, -sc.x, sc.x, sc.y);\n}\n\nconst float PI = 3.141592653589793;\n\nfloat truchet(vec2 p, float t)\n{\n    float a = trunc(grad(ivec2(p)).x * 4.) * PI * .5;\n    vec2 uv = (fract(p) - .5) * rotate(a) + .5;\n    return smoothstep(t, 0., abs(length(uv) - .5)) + smoothstep(t, 0., abs(length(uv - 1.) - .5));\n}\n\nvec3 truchetFbm(vec2 p)\n{\n    vec3 c = vec3(0);\n    float t = .0005;\n    for (float i = 0.; i < 50.; ++i)\n    {\n        p += i*vec2(0.01 * iTime + .3, 0.) * rotate(i * 4.);\n        c = max(c, truchet(p, t));\n        const float R = 1.1;\n        p = p * rotate(1.9) * R;\n        t *= R;\n    }\n    return c;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    u = (u - .5*iResolution.xy) / iResolution.y;\n    \n    vec3 bg = normalize(sin(iTime + u.x + u.y + vec3(0, 1, 3)) * .5 + .5) * .5;\n    O.rgb = truchetFbm(u*.25) + bg;\n    O.a = 1.;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}