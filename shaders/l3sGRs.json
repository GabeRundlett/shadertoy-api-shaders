{
    "Shader": {
        "info": {
            "date": "1707849346",
            "description": "Set up some color grading, and a fade-to-black on the edges.  Looks decent.",
            "flags": 0,
            "hasliked": 0,
            "id": "l3sGRs",
            "likes": 13,
            "name": "Penrose Pinwheel, Fancy Edition",
            "published": 3,
            "tags": [
                "practice",
                "penrose"
            ],
            "usePreview": 0,
            "username": "thedarkbunny",
            "viewed": 222
        },
        "renderpass": [
            {
                "code": "//Notional coordinates for large Robinson triangle\n#define KA vec2( 0.0,        1.53884177)\n#define KB vec2(-0.5,        0.0       )\n#define KC vec2( 0.5,        0.0       )\n//which splits at these points...\n#define KD vec2(-0.19098301, 0.95105652)\n#define KE vec2( 0.30901699, 0.58778525)\n//Notional coordinates for small Robinson triangle\n#define DA vec2(-0.80901699, 0.0       )\n#define DB vec2( 0.80901699, 0.0       )\n#define DC vec2( 0.0,        0.58778525)\n//which splits at this points...\n#define DD vec2( 0.19098301, 0.0       )\n//and a couple of constants for flavor\n#define PHI 1.618034\n#define TAU 6.2831853\n\n\n//returns twice the area of the triangle ABC\nfloat signedArea(in vec2 a, in vec2 b, in vec2 c){\n\treturn ((a.x - c.x)*(b.y - c.y) - (b.x - c.x)*(a.y - c.y));\n}\n\n//converts D into barycentric coordinates relative to triangle ABC\nvec3 bary(in vec2 a, in vec2 b, in vec2 c, in vec2 d){\n    float aa = signedArea(b,c,d);\n    float bb = signedArea(c,a,d);\n    float cc = signedArea(a,b,d);\n    float ss = aa+bb+cc;\n    if (ss == 0.){\n\t\treturn vec3(0.,0.,0.);\n\t}\n    return vec3(aa/ss,bb/ss,cc/ss);\n}\n\n//converts D into cartesian coordinates relative to triangle ABC\nvec2 unBary(in vec2 a, in vec2 b, in vec2 c, in vec3 d){\n\treturn vec2(a.x*d.x+b.x*d.y+c.x*d.z,a.y*d.x+b.y*d.y+c.y*d.z);\n}\n\n// given barycentric coordinates relative to a Robinson triangle,\n// as a vec4 of x,y,z,[0.0 for small triangle or 1.0 for large one]\n// returns a vec4 with that point's position in the next inflation\nvec4 nextLayer(in vec4 bc){\n\tvec3 res;\n\tvec2 cz;\n    // it just runs through the possible sub-triangles the point could be in,\n    // and returns the one that matches.\n    if (bc.w > 0.5){\n        cz = unBary(KA,KB,KC,bc.xyz);\n        // kite -> kite 1\n        res = bary(KB,KD,KE,cz);\n\t\tif (min(res.x,min(res.y,res.z)) >= 0.){\n\t\t\treturn vec4(res,1.0);\n\t\t}\n        // kite -> kite 2\n        res = bary(KB,KC,KE,cz);\n        if (min(res.x,min(res.y,res.z)) >= 0.){\n\t\t\treturn vec4(res,1.0);\n\t\t}\n        // kite -> dart\n        res = bary(KA,KE,KD,cz);\n        if (min(res.x,min(res.y,res.z)) >= 0.){\n\t\t\treturn vec4(res,0.0);\n\t\t}\n    }else{\n        cz = unBary(DA,DB,DC,bc.xyz);\n        // dart -> kite\n        res = bary(DA,DD,DC,cz);\n        if (min(res.x,min(res.y,res.z)) >= 0.){\n\t\t\treturn vec4(res,1.0);\n\t\t}\n        // dart -> dart\n        res = bary(DB,DC,DD,cz);\n        if (min(res.x,min(res.y,res.z)) >= 0.){\n\t\t\treturn vec4(res,0.0);\n\t\t}\n\t}\n\treturn vec4(0.0);\n}\n\nfloat runLayers(in vec2 cc, in float runs){\n    vec4 bc = vec4(bary(KA,KB,KC,cc),1.0);\n    float res = 0.5;\n    while(runs > 0.0){\n        bc = nextLayer(bc);\n        float tr = min(1.,runs);\n        float loMul = 1. - bc.x*bc.z*4.;\n        // Complex math done in advance.\n        // Short version:\n        // blend from one depth to another based on tr\n        // blend centers and edges based on loMul\n        // darts get darker, kites get lighter\n        // dark/light balance should average out to 0.5\n        res += res*loMul*tr*( + bc.w*0.23606798 - 0.61803399 ) + bc.w*loMul*tr*0.38196601;\n        runs -= 1.0;\n    \n    }\n    return res;\n}\n\nvoid mainImage0( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Translated so that the origin is in the center,\n    // and scaled so that the corners of the frame are 1.0 units from origin.\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/length(iResolution.xy*0.5);\n    vec2 edge = fragCoord/iResolution.xy;\n    edge *= vec2(1.) - edge;\n    float ev = edge.x*edge.y*16.;\n    // only need this for the ripple-update effect later\n    float luv = length(uv);\n    // variable for timing...\n    float cz = fract(iTime/10.);\n    // ...and its corresponding scaling\n    float currZoom = pow(PHI-1.,cz*4.);\n    // now that we have the scale, scale the vector\n    uv *= currZoom;\n    // ...and take its length again, because we'll need it.\n    float lzuv = length(uv);\n    //\n    float a = fract(atan(uv.x,-uv.y)/TAU*5.+cz);\n    a = min(a,1.0-a)*2.0 - 0.5;\n    uv = KA - vec2(sin(a*0.62831853),cos(a*0.62831853))*lzuv*0.95105652;\n    //get barycentric coords, run the Penrose inflation on it, much rejoicing, etc.\n    vec4 bc = vec4(bary(KA,KB,KC,uv),1.0);\n    float cm = runLayers(uv, 8.+cz*4.-luv);\n    //Gradient-mapped, yey.\n    float c_base = cm*cm;\n    float c_range = cm - c_base;\n    float c_ang = (cz*2.+0.5-luv)*TAU;\n    vec4 col = vec4(vec3(0.,(cos(c_ang)+1.)*0.5*c_range,(-cos(c_ang)+1.)*0.5*c_range)+c_base,cm);\n    \n    col = mix(col*1.2,vec4(0.),1. - sqrt(ev));\n    \n    //vec3 col = vec3(cm);\n    fragColor = col;\n}\n\n\n// This bit is just to prevent jagged edges.\n// === easy adaptive sampling. === https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n//                           more: https://www.shadertoy.com/results?query=easy+adaptive+sampling\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n    }\n}\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}