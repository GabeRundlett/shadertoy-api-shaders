{
    "Shader": {
        "info": {
            "date": "1577269165",
            "description": "A gnarly apollian tree\nBased upon: https://www.shadertoy.com/view/4ds3zn",
            "flags": 0,
            "hasliked": 0,
            "id": "3ttGRs",
            "likes": 87,
            "name": "Gnarly Apollian Tree",
            "published": 3,
            "tags": [
                "raymarcher"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 1623
        },
        "renderpass": [
            {
                "code": "// A gnarly apollian tree\n// Based upon: https://www.shadertoy.com/view/4ds3zn\n#define PI  3.141592654\n\nconst int   max_iter      = 130;\nconst vec3  bone          = vec3(0.89, 0.855, 0.788);\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat mod1(inout float p, float size) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n\nvec2 modMirror2(inout vec2 p, vec2 size) {\n    vec2 halfsize = size*0.5;\n    vec2 c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    p *= mod(c,vec2(2))*2.0 - vec2(1.0);\n    return c;\n}\n\nfloat apollian(vec3 p) {\n  vec3 op = p;\n  float s = 1.3 + smoothstep(0.15, 1.5, p.y)*0.95;\n//  float s = 1.3 + min(pow(max(p.y - 0.25, 0.0), 1.0)*0.75, 1.5);\n  float scale = 1.0;\n\n  float r = 0.2;\n  vec3 o = vec3(0.22, 0.0, 0.0);\n\n  float d = 10000.0;\n    \n  const int rep = 7;\n\n  for( int i=0; i<rep ;i++ ) {\n    mod1(p.y, 2.0);\n    modMirror2(p.xz, vec2(2.0));\n    rot(p.xz, PI/5.5);\n\n    float r2 = dot(p,p) + 0.0;\n    float k = s/r2;\n    float r = 0.5;\n    p *= k;\n    scale *= k;\n  }\n  \n  d = box(p - 0.1, 1.0*vec3(1.0, 2.0, 1.0)) - 0.5;\n  d = abs(d) - 0.01;\n  return 0.25*d/scale;\n}\n\nfloat df(vec3 p) { \n  float d1 = apollian(p);\n  float db = box(p - vec3(0.0, 0.5, 0.0), vec3(0.75,1.0, 0.75)) - 0.5;\n  float dp = p.y;\n  return min(dp, max(d1, db)); \n} \n\n\nfloat intersect(vec3 ro, vec3 rd, out int iter) {\n  float res;\n  float t = 0.2;\n  iter = max_iter;\n    \n  for(int i = 0; i < max_iter; ++i) {\n    vec3 p = ro + rd * t;\n    res = df(p);\n    if(res < 0.0003 * t || res > 20.) {\n      iter = i;\n      break;\n    }\n    t += res;\n  }\n    \n  if(res > 20.) t = -1.;\n  return t;\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n) {\n  float stepSize = 0.012;\n  float t = stepSize;\n\n  float oc = 0.0;\n\n  for(int i = 0; i < 12; i++) {\n    float d = df(p + n * t);\n    oc += t - d;\n    t += stepSize;\n  }\n\n  return clamp(oc, 0.0, 1.0);\n}\n\nvec3 normal(in vec3 pos) {\n  vec3  eps = vec3(.001,0.0,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nvec3 lighting(vec3 p, vec3 rd, int iter) {\n  vec3 n = normal(p);\n  float fake = float(iter)/float(max_iter);\n  float fakeAmb = exp(-fake*fake*9.0);\n  float amb = ambientOcclusion(p, n);\n\n  vec3 col = vec3(mix(1.0, 0.125, pow(amb, 3.0)))*vec3(fakeAmb)*bone;\n  return col;\n}\n\nvec3 post(vec3 col, vec2 q) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.65)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )  { \n  vec2 q=fragCoord.xy/iResolution.xy;\n  vec2 uv = -1.0 + 2.0*q; \n  uv.y += 0.225;\n  uv.x*=iResolution.x/iResolution.y; \n    \n  vec3 la = vec3(0.0, 0.5, 0.0); \n  vec3 ro = vec3(-4.0, 1., -0.0);\n  rot(ro.xz, 2.0*PI*iTime/120.0);\n  vec3 cf = normalize(la-ro); \n  vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n  vec3 cu = normalize(cross(cs,cf)); \n  vec3 rd = normalize(uv.x*cs + uv.y*cu + 3.0*cf);  // transform from view to world\n\n  vec3 bg = mix(bone*0.5, bone, smoothstep(-1.0, 1.0, uv.y));\n  vec3 col = bg;\n\n  vec3 p=ro; \n\n  int iter = 0;\n  \n  float t = intersect(ro, rd, iter);\n    \n  if(t > -0.5) {\n    p = ro + t * rd;\n    col = lighting(p, rd, iter); \n    col = mix(col, bg, 1.0-exp(-0.001*t*t)); \n  } \n    \n\n  col=post(col, q);\n  fragColor=vec4(col.x,col.y,col.z,1.0); \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}