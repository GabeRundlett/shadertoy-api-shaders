{
    "Shader": {
        "info": {
            "date": "1631655604",
            "description": "CG course sdf practice",
            "flags": 0,
            "hasliked": 0,
            "id": "fdKGDw",
            "likes": 1,
            "name": "Fork дед инсайд oneWisdom 723",
            "published": 3,
            "tags": [
                "sdf",
                "trip"
            ],
            "usePreview": 0,
            "username": "oneWisdom",
            "viewed": 199
        },
        "renderpass": [
            {
                "code": "const float PI = 3.14;\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\nfloat sphere(vec3 pos, vec3 spherePos, float sphereRadius) {\n    return length(pos - spherePos) - sphereRadius;\n}\n\nfloat prism(vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.7+p.y*0.3,-p.y)-h.x*0.5);\n}\n\n\nfloat smin ( float a, float b, float k )\n{\n\tfloat res = exp ( -k*a ) + exp ( -k*b );\n\treturn -log ( res ) / k;\n}\n\n\nfloat smax ( float a, float b, float k )\n{\n\tfloat res = exp ( k*a ) + exp ( k*b );\n\treturn log ( res ) / k;\n}\n\n\nfloat scene_eyes(vec3 pos, mat3 m) {\n    vec3 q = m * pos;\n    float k = min(\n        sphere(q, vec3(0.45, -0.7, 0.2), 0.3),\n        sphere(q, vec3(-0.45, -0.7, 0.2), 0.3)\n    );\n    return k;\n}\n\n\nfloat scene_head(vec3 pos, mat3 m) {\n    vec3 q = m * pos;\n    \n    // prism transform\n    vec3 q2 = q + vec3(0., 1.6, 1.);\n    mat3 m2 = rotateY(PI / 2.) * rotateZ(PI / 180. * 30.);\n    q2 *= m2;\n    \n    float k = max(\n        -prism(q2, vec2(1., 1.5)),\n        sphere(q, vec3(0., 0., 0.), 1.)\n    );\n    \n    // ear radius\n    float a = 2.;\n    // ear thickness\n    float d = 0.2;\n    \n    vec3 ear_position1 = vec3(-1.1, 0, 1.0);\n    vec3 ear_position2 = vec3(1.1, 0, 1.0);\n        \n    float s1 =  smax(\n        -sphere(q,ear_position1 +  vec3(0., -a, 0.), a),\n        sphere(q, ear_position1, 1.), 10.0\n    );\n        \n    float s2 = smax(\n        sphere(q, ear_position1 + vec3(0., -a + d, 0.), a),\n        s1, 10.0\n    );\n    \n    float s3 =  smax(\n        -sphere(q,ear_position2 +  vec3(0., -a, 0.), a),\n        sphere(q, ear_position2, 1.), 10.0\n    );\n        \n    float s4 = smax(\n        sphere(q, ear_position2 + vec3(0., -a + d, 0.), a),\n        s3, 10.0\n    );\n    \n    \n    return min(s4, min(s2, k));\n}\n\n\nfloat scene(vec3 pos, mat3 m, int n) {\n    float dist;\n    if (n == 0) {\n\n        dist = scene_head ( pos, m );\n    }\n    else {\n        dist = scene_eyes ( pos, m );\n    } \n    return dist;\n}\n\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, mat3 m, int n)\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n    int stepNum = 70;\n\tfor ( int steps = 0; steps < stepNum; steps++ )\n\t{\n        float dist = scene(p, m, n);\n\n        p += dist * dir;\n        \n\t\tif ( dist < 0.01 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 10.0 )\n\t\t\tbreak;\t\n\t}\n\t\n\treturn p;\n}\n\nvec3 generateNormal ( vec3 z, float d, mat3 m, int n)\n{\n    float eps = 0.01;\n    float e   = max (d * 0.5, eps );\n    float dx1 = scene(z + vec3(e, 0, 0), m, n);\n    float dx2 = scene(z - vec3(e, 0, 0), m, n);\n    float dy1 = scene(z + vec3(0, e, 0), m, n);\n    float dy2 = scene(z - vec3(0, e, 0), m, n);\n    float dz1 = scene(z + vec3(0, 0, e), m, n);\n    float dz2 = scene(z - vec3(0, 0, e), m, n);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\n\n\nmat2 rotate(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n\n    return mat2(c, -s, s, c);\n}\n\n\nvec4 background(vec2 uv) {\n    //source: https://www.shadertoy.com/view/Xt2BDG\n    \n    vec4 result = vec4(0,0,0,1);\n\n    float t = 1.;\n    float offset = -5. * iTime;\n    float base = 100. * length(uv);\n\n    float d = sin(-iTime + 15. * length(uv));\n    d *= d * d;\n\n    mat2 rot = rotate(5. * length(uv));\n    uv += .5;\n    \n    uv = abs(rot * uv);\n    \n    for (int p = 0; p < 3; p++)\n    {\n        result[p] = sin(offset + t * base) - cos(20. * uv.x) - cos(20. * uv.y);\n        t += 0.05;\n    }\n\n    result.xyz *= result.xyz;\n    result.xyz = 1. - result.xyz;\n    \n    return result * d;\n}\n\nvec3 lightPos = vec3(0, -6., 0.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    mat3 m;\n    \n    vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    if ( iMouse.z > 0.) {\n        m     = rotateX ( 6.0*mouse.y ) * rotateY ( 6.0*mouse.x );\n    }\n    else {\n        m = mat3(\n            vec3(1, 0, 0),\n            vec3(0, 1, 0),\n            vec3(0, 0, 1)\n        );\n    }\n    \n    vec3 cameraPos = vec3(0.,-5.-sin(iTime)*4., 0.);\n    vec3 cameraForward = vec3(0., 1, 0.);\n    vec3 cameraUp = vec3 (0., 0., 1.);\n    float cameraFocus = 5.;\n    \n    vec2 scale = 9. * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\n    \n    vec3 from = vec3(uv.x, (cameraPos + cameraForward * cameraFocus).z, uv.y);\n    vec3 dir = normalize(from - cameraPos);\n    \n    bool hit;\n    vec3 p1 = trace(cameraPos, dir, hit, m, 0);\n    float d1 = length(cameraPos - p1);\n     float c1 = length(p1);\n    \n    vec3 backgroundColor = vec3(0., 0., 0.);\n    vec3 surfaceColor = vec3(1., 1., 1.);\n    \n    vec4 col;\n    \n    if (hit) {\n\n       vec3 l = normalize(lightPos - p1);\n       vec3 n = generateNormal(p1, 0.001, m, 0);\n       vec3 v = normalize(cameraPos - p1);\n       float diffuse = max(0., dot(n, l));\n\n       vec3  h  = normalize ( l + v );\n       float hn = max ( 0.0, dot ( h, n ) );\n       float specular = pow ( hn, 150.0 );\n\n       col = 0.5*vec4 ( diffuse ) * vec4(1.0, 0.1, 0.4, 1) + 0.5 * specular * vec4 ( 1, 1, 1, 1 );\n    }\n    else {\n       col = background(uv / 2.);\n    }\n   \n    vec3 p2 = trace(cameraPos, dir, hit, m, 1);\n    float d2 = length(cameraPos - p2);\n    float c2 = length(p2);\n\n    if (hit && (d2 < d1)) {\n\n       vec3 l = normalize(lightPos - p2);\n       vec3 n = generateNormal(p2, 0.001, m, 1);\n       vec3 v = normalize(cameraPos - p2);\n       float diffuse = max(0., dot(n, l));\n\n       vec3  h  = normalize ( l + v );\n       float hn = max ( 0.0, dot ( h, n ) );\n       float specular = pow ( hn, 150.0 );\n       \n       float t = abs(sin(70. * c2 + 20. * iTime) - 0.9);\n\n       col = 0.5 * vec4 ( diffuse ) * vec4(t, abs(t - 0.9), abs(t - 0.3), 1) + 0.5 * specular * vec4 ( 1, 1, 1, 1 );\n    }\n\n    \n    // Output to screen\n    fragColor = col;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}