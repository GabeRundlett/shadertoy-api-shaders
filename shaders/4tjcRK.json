{
    "Shader": {
        "info": {
            "date": "1509827376",
            "description": "camera for rotation in 4d, blurs 50 samples.\nq,w,e,r,a,s,d,f to move\nt,y,u,i,o,p,g,h,j,k,l,Ã¸ to look around\nmay not work with all keyboards\n",
            "flags": 48,
            "hasliked": 0,
            "id": "4tjcRK",
            "likes": 3,
            "name": "rotations 4d",
            "published": 3,
            "tags": [
                "camera",
                "rotation"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 606
        },
        "renderpass": [
            {
                "code": "#define blendbackground\n#define supersampling 90.0\n#define samplesize 0.3\n#define hypercubescene\n\n//by iq https://www.shadertoy.com/view/XljGDy\nvec2 sphIntersect(in vec3 rd, in vec4 sph )\n{\n\tvec3 oc =  sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0  || dot(sph.xyz,sph.xyz) > sph.w*sph.w) return vec2(-1.0);\n    h = sqrt( h );\n\treturn -b + vec2(-h,h);\n}\n\n//by iq https://www.shadertoy.com/view/XljGDy\nfloat sphDensity( vec4  ro, vec4  rd,   // ray origin, ray direction\n                  vec4  sc, float sr,   // sphere center, sphere radius\n                  float dbuffer )       // depth buffer\n{\n    // normalize the problem to the canonical sphere\n    float ndbuffer = dbuffer / sr;\n    vec4  rc = (ro - sc)/sr;\n\t\n    // find intersection with sphere\n    float b = dot(rd,rc);\n    float c = dot(rc,rc) - 1.0;\n    float h = b*b - c;\n\n    // not intersecting\n    if( h<0.0 ) return 0.0;\n\t\n    h = sqrt( h );\n    \n    //return h*h*h;\n\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    // not visible (behind camera or behind ndbuffer)\n    if( t2<0.0 || t1>ndbuffer ) return 0.0;\n\n    // clip integration segment from camera to ndbuffer\n    t1 = max( t1, 0.0 );\n    t2 = min( t2, ndbuffer );\n\n    // analytical integration of an inverse squared density\n    float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n    float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n    return (i2-i1)*(3.0/4.0);\n}\n\n/*vec2 circle(in vec2 rd, in vec3 sph )\n{\n    vec2 oc = sph.xy;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.z*sph.z;\n    float h = b*b - c;\n    if( h<0.0 || dot(sph.xy,sph.xy) > sph.z*sph.z) return vec2(0.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}*/\n\n\n\nfloat cylinder(vec4 ray, vec4 pos, float size,\n        float lenrayyzw,\n        float lenrayzwx,\n        float lenraywxy,\n        float lenrayxyz) {\n    return max(max(max(\n        sphIntersect(ray.yzw*lenrayyzw,vec4(pos.yzw,size)).y*lenrayyzw,\n        sphIntersect(ray.zwx*lenrayzwx,vec4(pos.zwx,size)).y*lenrayzwx),\n        sphIntersect(ray.wxy*lenraywxy,vec4(pos.wxy,size)).y*lenraywxy),\n        sphIntersect(ray.xyz*lenrayxyz,vec4(pos.xyz,size)).y*lenrayxyz);\n    \n}\nvec4 cylindernormal(vec4 ray, vec4 pos, float size,\n        float lenrayyzw,\n        float lenrayzwx,\n        float lenraywxy,\n        float lenrayxyz) {\n    vec4 lens = vec4(\n        sphIntersect(ray.yzw*lenrayyzw,vec4(pos.yzw,size)).y*lenrayyzw,\n        sphIntersect(ray.zwx*lenrayzwx,vec4(pos.zwx,size)).y*lenrayzwx,\n        sphIntersect(ray.wxy*lenraywxy,vec4(pos.wxy,size)).y*lenraywxy,\n        sphIntersect(ray.xyz*lenrayxyz,vec4(pos.xyz,size)).y*lenrayxyz);\n    float len = max(max(max(lens.x,lens.y),lens.z),lens.w);\n    vec4 mask = step(len,lens);\n    pos += ray*len;\n    return -pos/size*(1.0-mask);\n}\n\nvec4 hypercylinder(vec4 ro, vec4 rd) {\n    vec4 ray = rd;\n    float lenrayyzw = 1.0/length(ray.yzw);\n    float lenrayzwx = 1.0/length(ray.zwx);\n    float lenraywxy = 1.0/length(ray.wxy);\n    float lenrayxyz = 1.0/length(ray.xyz);\n    float time = iTime*0.1;\n    vec4 cam = ro;\n    \n\n    vec4 pos = cam;\n    vec4 lightpos = ro+vec4(0,0,0.2,0);\n\n\n    //vec4 pos = vec4(0.0,0.0,0.0,iTime);\n    float dist = 0.0;\n    vec4 normal;\n    int i;\n    for (i = 0; i < 20; i++) {\n        float len = 0.0;\n        for (float j = 1.0/6.0; j > 0.001; j /= 3.0) {\n            vec4 p = mod(pos+3.0*j,6.0*j)-3.0*j;\n            float len2 = cylinder(ray, p, j,\n                                  lenrayyzw,\n                                  lenrayzwx,\n                                  lenraywxy,\n                                  lenrayxyz);\n\n            if (len2 > len) {\n                normal = cylindernormal(ray, p, j,\n                                        lenrayyzw,\n                                        lenrayzwx,\n                                        lenraywxy,\n                                        lenrayxyz);\n                len = len2;\n            }\n        }\n\n        if (len < 0.001) {\n            break;\n        }\n        dist += len;\n        pos += ray*len;\n    }\n\n    vec4 lightdir = normalize(lightpos-pos);\n\n    vec4 fragColor = vec4(0.5*normal+0.5);\n    fragColor *= vec4(max(dot(lightdir,normal),0.2));\n    fragColor += max(sphDensity(cam,ray,lightpos,0.01,dist),0.0);\n    return fragColor;\n        //fragColor *= vec4(-dot(cos(pos*5.0),vec4(1.0/3.0))*0.5+0.5);\n}\n\nfloat map(vec4 p) {\n    vec4 p2 = mod(p,3.0)-1.5;\n    \n    return length(p2)-1.0;\n}\n\nvec4 hypercubes(vec4 ro, vec4 rd)\n{\n    vec4 fragColor = vec4(0.0);\n    \n    \n    vec4 pos = ro;\n    vec4 dir = rd;\n    float dist = 0.0;\n    \n    for (int i = 0; i < 8; i++) {\n        vec4 pos2 = mod(pos+1.0,2.0)-1.0;\n        \n        vec4 planes  = 0.8-pos2*sign(dir);\n        planes *= step(abs(pos2),vec4(0.8));\n        planes /= dir*sign(dir);\n        //float len  = max(max(max(planes.x,planes.y),planes.z),planes.w);\n        \n        \n        planes = max(planes,planes.yzwx);\n        \n        float len  = min(min(min(planes.x,planes.y),planes.z),planes.w);\n        \n        /*pos2 = mod(pos,2.0)-1.0;\n        planes = 0.79-pos2*sign(dir);\n        planes *= step(abs(pos2),vec4(0.79));\n        planes /= dir*sign(dir);*/\n        \n        pos += dir*len;\n        dist += len;\n        \n        if (len < 0.001||dist > 10.0) {\n            break;\n        }\n    }\n    if (dist < 10.0) {\n        vec4 pos2 = mod(pos,2.0)-1.0;\n        \n        vec4 normal = vec4(greaterThan(abs(pos2),max(max(abs(pos2.yzwx),abs(pos2.zwxy)),abs(pos2.wxyz))))*sign(pos2);\n        //fragColor = (sin(pos*3.0+dist)*0.5+0.5)/(dist+1.0)*2.0+(normal*0.25+0.25);\n\n        fragColor = normal*0.5+0.5;\n        fragColor *= 2./(2. + dist*dist*.1);\n        fragColor.w = 1.0;\n    }\n    return fragColor;\n}\n\nvec4 memory(int i) {\n    return texelFetch(iChannel0,ivec2(i,0),0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec4 cam = memory(4);\n    \n    mat4 rotation = mat4(\n        memory(0),\n        memory(1),\n        memory(2),\n        memory(3));\n    \n    for (float i = 0.0; i < supersampling; i++) {\n        vec4 ro = cam;\n        vec4 rd = vec4(uv,i/supersampling*(samplesize*2.0)-samplesize,1);\n        \n        //vec4 ro = cam+vec4(0,0,i/supersampling*(samplesize*2.0)-samplesize,0);\n        //vec4 rd = vec4(uv,0,1);\n        \n        if (supersampling == 1.0) {\n        \tro.z = cam.z;\n        \trd.z = 0.0;\n        }\n        \n        rd = normalize(rd);\n        \n        rd *= transpose(rotation);\n        \n        #ifdef hypercubescene\n        fragColor += hypercubes(ro,rd);\n        #else\n        fragColor += hypercylinder(ro,rd);\n        #endif\n\t}\n    if (fragColor.w > 0.0) {\n        #ifdef blendbackground\n    \tfragColor /= supersampling;\n        #else\n    \tfragColor /= fragColor.w;\n        #endif\n    } else {\n        fragColor = vec4(0.0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MOVE_SPEED 1.0\n#define ROT_SPEED 1.0\n\n#define KEY_Q 81\n#define KEY_W 87\n#define KEY_E 69\n#define KEY_R 82\n#define KEY_T 84\n#define KEY_Y 89\n#define KEY_U 85\n#define KEY_I 73\n#define KEY_O 79\n#define KEY_P 80\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n#define KEY_F 70\n#define KEY_G 71\n#define KEY_H 72\n#define KEY_J 74\n#define KEY_K 75\n#define KEY_L 76\n#define KEY_OO 192\n\n#define PLUS_X keys(KEY_Q)\n#define PLUS_Y keys(KEY_W)\n#define PLUS_Z keys(KEY_R)\n#define PLUS_W keys(KEY_E)\n\n#define MINUS_X keys(KEY_A)\n#define MINUS_Y keys(KEY_S)\n#define MINUS_Z keys(KEY_F)\n#define MINUS_W keys(KEY_D)\n\n#define ROT_PLUS_0 keys(KEY_U)\n#define ROT_PLUS_1 keys(KEY_O)\n#define ROT_PLUS_2 keys(KEY_Y)\n#define ROT_PLUS_3 keys(KEY_I)\n#define ROT_PLUS_4 keys(KEY_T)\n#define ROT_PLUS_5 keys(KEY_P)\n\n#define ROT_MINUS_0 keys(KEY_J)\n#define ROT_MINUS_1 keys(KEY_L)\n#define ROT_MINUS_2 keys(KEY_H)\n#define ROT_MINUS_3 keys(KEY_K)\n#define ROT_MINUS_4 keys(KEY_G)\n#define ROT_MINUS_5 keys(KEY_OO)\n\nfloat keys(int i) {\n    return texelFetch(iChannel1,ivec2(i,0),0).x;\n}\n\nvec4 memory(int i) {\n    return texelFetch(iChannel0,ivec2(i,0),0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n    if (int(fragCoord.y) == 0) {\n        int index = int(fragCoord.x);\n        if (index < 4) {\n            if (iFrame == 0) {\n                fragColor = vec4(index==0,index==1,index==2,index==3);\n                return;\n            }\n            \n            float[6] rot;\n            rot[0] = (ROT_PLUS_0-ROT_MINUS_0)*iTimeDelta*ROT_SPEED;\n            rot[1] = (ROT_PLUS_1-ROT_MINUS_1)*iTimeDelta*ROT_SPEED;\n            rot[2] = (ROT_PLUS_2-ROT_MINUS_2)*iTimeDelta*ROT_SPEED;\n            rot[3] = (ROT_PLUS_3-ROT_MINUS_3)*iTimeDelta*ROT_SPEED;\n            rot[4] = (ROT_PLUS_4-ROT_MINUS_4)*iTimeDelta*ROT_SPEED;\n            rot[5] = (ROT_PLUS_5-ROT_MINUS_5)*iTimeDelta*ROT_SPEED;\n            \n            mat4 rotation = mat4(\n                memory(0),\n                memory(1),\n                memory(2),\n                memory(3));\n            \n            mat4 newrotation = rotation;\n            \n            newrotation[0] = (rotation[0]*cos(rot[0])+rotation[1]*sin(rot[0]));\n            newrotation[1] = (rotation[1]*cos(rot[0])-rotation[0]*sin(rot[0]));\n            \n            rotation = newrotation;\n            \n            newrotation[0] = (rotation[0]*cos(rot[1])+rotation[2]*sin(rot[1]));\n            newrotation[2] = (rotation[2]*cos(rot[1])-rotation[0]*sin(rot[1]));\n            \n            rotation = newrotation;\n            \n            newrotation[0] = (rotation[0]*cos(rot[2])+rotation[3]*sin(rot[2]));\n            newrotation[3] = (rotation[3]*cos(rot[2])-rotation[0]*sin(rot[2]));\n            \n            rotation = newrotation;\n            \n            newrotation[1] = (rotation[1]*cos(rot[3])+rotation[2]*sin(rot[3]));\n            newrotation[2] = (rotation[2]*cos(rot[3])-rotation[1]*sin(rot[3]));\n            \n            rotation = newrotation;\n            \n            newrotation[1] = (rotation[1]*cos(rot[4])+rotation[3]*sin(rot[4]));\n            newrotation[3] = (rotation[3]*cos(rot[4])-rotation[1]*sin(rot[4]));\n            \n            rotation = newrotation;\n            \n            newrotation[2] = (rotation[2]*cos(rot[5])+rotation[3]*sin(rot[5]));\n            newrotation[3] = (rotation[3]*cos(rot[5])-rotation[2]*sin(rot[5]));\n            \n            rotation = newrotation;\n            \n            fragColor = rotation[index];\n            \n            return;\n        }\n        if (index == 4) {\n            if (iFrame == 0) {\n                fragColor = vec4(0,0,0,1);\n            }\n            \n            mat4 rotation = mat4(\n                memory(0),\n                memory(1),\n                memory(2),\n                memory(3));\n            \n            vec4 move = vec4(\n                PLUS_X-MINUS_X,\n                PLUS_Y-MINUS_Y,\n                PLUS_Z-MINUS_Z,\n                PLUS_W-MINUS_W)*iTimeDelta*MOVE_SPEED;\n            \n            fragColor += rotation*move;\n            \n            return;\n        }\n        if (iFrame == 0) {\n            fragColor = vec4(0,1,0,1);\n            return;\n        }\n    }\n    if (iFrame == 0) {\n        fragColor = vec4(1,0,0,1);\n        return;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}