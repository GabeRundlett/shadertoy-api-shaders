{
    "Shader": {
        "info": {
            "date": "1466265657",
            "description": "This is an update to Musk's and Icecool's Lens Flare shader. This new one allows for easier customization, with brightness and size control.\n\nUpdate: Barrel distortion for flares",
            "flags": 0,
            "hasliked": 0,
            "id": "MdGSWy",
            "likes": 46,
            "name": "Musk's Lens Flare v2.",
            "published": 3,
            "tags": [
                "2d",
                "lens",
                "flare",
                "flare2d"
            ],
            "usePreview": 1,
            "username": "SolarLiner",
            "viewed": 6215
        },
        "renderpass": [
            {
                "code": "// musk's lense flare, modified by icecool.\n// \"Modularized\" by SolarLiner, with improvements\n// See the original at: https://www.shadertoy.com/view/4sX3Rs \n\n#define ORB_FLARE_COUNT\t6\n#define DISTORTION_BARREL\t\t1.0\n\nvec2 GetDistOffset(vec2 uv, vec2 pxoffset)\n{\n    vec2 tocenter = uv.xy;\n    vec3 prep = normalize(vec3(tocenter.y, -tocenter.x, 0.0));\n    \n    float angle = length(tocenter.xy)*2.221*DISTORTION_BARREL;\n    vec3 oldoffset = vec3(pxoffset,0.0);\n    \n    vec3 rotated = oldoffset * cos(angle) + cross(prep, oldoffset) * sin(angle) + prep * dot(prep, oldoffset) * (1.0-cos(angle));\n    \n    return rotated.xy;\n}\n\nfloat noise(float t)\n{\n\treturn texture(iChannel0,vec2(t, 0.0) / iChannelResolution[0].xy).x;\n}\nfloat noise(vec2 t)\n{\n\treturn texture(iChannel0,(t + vec2(iTime)) / iChannelResolution[0].xy).x;\n}\n\nfloat glare(vec2 uv, vec2 pos, float size)\n{\n    vec2 main = uv-pos;\n\t\n\tfloat ang = atan(main.y, main.x);\n\tfloat dist=length(main); dist = pow(dist,.1);\n\t\n\tfloat f0 = 1.0/(length(uv-pos)*(1.0/size*16.0)+1.0);\n    \n    return f0+f0*(sin((ang)*8.0)*.2+dist*.1+.9);\n}\n\nvec3 flare(vec2 uv, vec2 pos, float dist, float size)\n{\n    pos = GetDistOffset(uv, pos);\n    \n    float r = max(0.01-pow(length(uv+(dist-.05)*pos),2.4)*(1./(size*2.)),.0)*6.0;\n\tfloat g = max(0.01-pow(length(uv+ dist     *pos),2.4)*(1./(size*2.)),.0)*6.0;\n\tfloat b = max(0.01-pow(length(uv+(dist+.05)*pos),2.4)*(1./(size*2.)),.0)*6.0;\n    \n    return vec3(r,g,b);\n}\nvec3 flare(vec2 uv, vec2 pos, float dist, float size, vec3 color)\n{\n    return flare(uv, pos, dist, size)*color;\n}\n\nvec3 orb(vec2 uv, vec2 pos, float dist, float size)\n{\n    vec3 c = vec3(0.0);\n    /*c += flare(uv,pos,dist      ,3.0*size,vec3(1.0,0.8,0.5));\n    c += flare(uv,pos,dist+.1   ,2.0*size,vec3(1.0,0.9,0.8));\n    c += flare(uv,pos,dist+.15  ,1.5*size);\n    c += flare(uv,pos,dist+.155 ,1.25*size,vec3(0.8,0.9,1.0));\n    c += flare(uv,pos,dist+.1555,1.125*size,vec3(0.5,0.8,1.0));*/\n    \n    for(int i=0; i<ORB_FLARE_COUNT; i++)\n    {\n        float j = float(i+1);\n        float offset = j/(j+1.);\n        float colOffset = j/float(ORB_FLARE_COUNT*2);\n        \n        c += flare(uv,pos,dist+offset, size/(j+.1), vec3(1.0-colOffset, 1.0, 0.5+colOffset));\n    }\n    \n    c += flare(uv,pos,dist+.5, 4.0*size, vec3(1.0))*4.0;\n    \n    return c/4.0;\n}\nvec3 orb(vec2 uv, vec2 pos, float dist, float size, vec3 color)\n{\n    return orb(uv,pos,dist,size)*color;\n}\n\nvec3 ring(vec2 uv, vec2 pos, float dist)\n{\n    vec2 uvd = uv*(length(uv));\n    \n    float r = max(1.0/(1.0+32.0*pow(length(uvd+(dist-.05)*pos),2.0)),.0)*00.25;\n\tfloat g = max(1.0/(1.0+32.0*pow(length(uvd+ dist     *pos),2.0)),.0)*00.23;\n\tfloat b = max(1.0/(1.0+32.0*pow(length(uvd+(dist+.05)*pos),2.0)),.0)*00.21;\n    \n    return vec3(r,g,b);\n}\n\nvec3 lensflare(vec2 uv,vec2 pos, float brightness, float size)\n{\n\t/*vec2 main = uv-pos;\n\tvec2 uvd = uv*(length(uv));\n\t\n\tfloat ang = atan(main.y, main.x);\n\tfloat dist=length(main); dist = pow(dist,.1);\n\tfloat n = noise(vec2((ang-iTime/9.0)*16.0,dist*32.0));\n\t\n\tfloat f0 = 1.0/(length(uv-pos)*16.0+1.0);\n\t\n\tf0 = f0+f0*(sin((ang+iTime/18.0 + noise(abs(ang)+n/2.0)*2.0)*12.0)*.1+dist*.1+.8);\n\n\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\n\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\n\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\n\t\n\tvec2 uvx = mix(uv,uvd,-0.5);\n\t\n\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\n\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\n\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\n\t\n\tuvx = mix(uv,uvd,-.4);\n\t\n\tfloat f5 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\n\tfloat f52 = max(0.01-pow(length(uvx+0.4*pos),5.5),.0)*2.0;\n\tfloat f53 = max(0.01-pow(length(uvx+0.6*pos),5.5),.0)*2.0;\n\t\n\tuvx = mix(uv,uvd,-0.5);\n\t\n\tfloat f6 = max(0.01-pow(length(uvx-0.3*pos),1.6),.0)*6.0;\n\tfloat f62 = max(0.01-pow(length(uvx-0.325*pos),1.6),.0)*3.0;\n\tfloat f63 = max(0.01-pow(length(uvx-0.35*pos),1.6),.0)*5.0;\n\t\n\tvec3 c = vec3(.0);\n\t\n\tc.r+=f2+f4+f5+f6; c.g+=f22+f42+f52+f62; c.b+=f23+f43+f53+f63;\n\tc+=vec3(f0);\n    c.r=f2;c.g=f22;c.b=f23;\n\t\n\treturn c;*/\n    \n    vec3 c = vec3(glare(uv,pos,size));\n    c += flare(uv,pos,-3.,3.*size);\n    c += flare(uv,pos, -1.,size)*3.;\n    c += flare(uv,pos, .5,.8*size);\n    c += flare(uv,pos,-.4,.8*size);\n    \n    c += orb(uv,pos, 0., .5*size);\n    \n    c += ring(uv,pos,-1.)*.5*size;\n    c += ring(uv,pos, 1.)*.5*size;\n    \n    return c*brightness;\n}\n\nvec3 cc(vec3 color, float factor,float factor2) // color modifier\n{\n\tfloat w = color.x+color.y+color.z;\n\treturn mix(color,vec3(w)*factor,w*factor2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n\tmouse.x *= iResolution.x/iResolution.y; //fix aspect ratio\n\t/*if (iMouse.z<.5)\n\t{\n\t\tmouse.x=sin(iTime)*.6;\n\t\tmouse.y=cos(iTime*.913)*.6;\n\t}*/\n\t\n\tvec3 color = /*vec3(1.4,1.2,1.0)*/lensflare(uv,mouse.xy,1.,1.+sin(iTime*.6)*.5);\n\t//color = cc(color,.5,.1);\n\tfragColor = vec4(pow(color, vec3(1.5)),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}