{
    "Shader": {
        "info": {
            "date": "1649696216",
            "description": "Could better, could be worse :) ",
            "flags": 0,
            "hasliked": 0,
            "id": "fl2yWW",
            "likes": 14,
            "name": "Color aberrated stars.",
            "published": 3,
            "tags": [
                "aberration",
                "hue",
                "starfield",
                "aberrated"
            ],
            "usePreview": 0,
            "username": "fyisic123",
            "viewed": 635
        },
        "renderpass": [
            {
                "code": "\n#define hue(v) ( .6 + .6 * cos( 2.*PI*(v) + vec3(0,-2.*PI/3.,2.*PI/3.) ) )\n#define PI 3.14159265359\n\n\n// Settings\n#define LAYER_COUNT 5.\n#define ABERRATION 0.25\n#define ABERRATION_SIZE 0.3\n#define DOT_SIZE 0.05\nfloat hash12(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 dotLayer(vec2 uv, vec2 uvNorm, float uvLength, float fade, float layerID)\n{\n    vec2 gv = fract(uv) -.5;\n    vec2 ID = floor(uv);\n    vec3 col = vec3(0);\n    for (int x = -1; x <= 1; x++)\n        for (int y = -1; y <= 1; y++)        \n        {\n            vec2 offs = vec2(x,y);            \n            float rnID = hash12(ID + offs + layerID);\n            float variantID = 123.123 * rnID ;            \n            vec2 rndOffs = vec2(sin(variantID), cos(variantID)) ;\n            vec2 pos = gv - offs + rndOffs;\n            \n            float starScale = 0.5 + (0.5 * rnID);\n            float dotScale = DOT_SIZE * starScale * fade;\n            float abbrsize = 0.01 + (ABERRATION_SIZE * uvLength) * fade * starScale;\n            float p =smoothstep(dotScale,dotScale*.5   ,length(pos));\n            col += p;\n            \n            float aberr = ABERRATION * starScale * fade;\n            float fC = 0.;\n            for(int i = 0; i < 3; i++)\n            {                  \n                fC += 0.33333;\n                float cDist =   (fC * uvLength * aberr);\n                \n                col[i] += pow(smoothstep(abbrsize   , 0., length(pos + (uvNorm * cDist))), 2.);\n                \n                \n            }\n            \n        }\n        return col * fade;\n}\n\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord.xy -.5 * iResolution.xy) / iResolution.y;\n    float uvLength = length(uv);\n    uv *= Rot(iTime*0.1);\n    vec2 uvNorm = normalize(uv);\n    \n    \n    \n        \n    vec3 col = vec3(0);            \n    \n    float speed = iTime * 0.2;\n    for(float i=0.; i < 1.; i+=1./LAYER_COUNT)\n    {\n        float depth = fract(speed+i) ;\n        col += dotLayer(uv * (20. - (19. * depth)) , uvNorm, uvLength , smoothstep(1.,0.8, depth), i)  * depth;\n    }\n                                \n    vec3 bgCol = abs(dot(uvNorm.x * uvLength, uvNorm.y))* (hue(uvLength + (iTime* 0.2)) * 0.1); \n    col += bgCol;\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}