{
    "Shader": {
        "info": {
            "date": "1543749640",
            "description": "the walls glow without the lights on.",
            "flags": 0,
            "hasliked": 0,
            "id": "XlyBDG",
            "likes": 5,
            "name": "glow in the dark pathtracing",
            "published": 3,
            "tags": [
                "realtimepathtracing"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 589
        },
        "renderpass": [
            {
                "code": "#define samples (10+min(iFrame,0))\n#define bounces 4\n\n#define rots mat3(\t\\\n    -1, 0, 1,\t\t\\\n     1,-1, 0,\t\t\\\n     0, 1,-1)\n\nfloat time = 0.0;\n\n//random function by romasm\n//https://www.shadertoy.com/view/4scfz4\nfloat seed = 0.0;\nvec2 fragUV = vec2(0.0);\nfloat rand() \n{\n\tfloat r = fract(sin(dot(fragUV, vec2(12.9898, 78.233)) + seed) * 43758.5453);\n\tseed++;\n    return r;    \n}\n\nfloat mid(vec3 p) {\n    p = min(p,p.yzx);\n    return max(max(p.x,p.y),p.z);\n}\n\nvec4 intersect(vec3 ro2, vec3 rd) {\n    //float sphere = sphIntersect(ro.xy-light.xy,normalize(rd.xy))/length(rd.xy);\n    \n    float size = 0.6666;\n    vec3 ro = ro2;\n    vec3 invrd = 1.0/abs(rd+0.000001);\n    float dist = 0.0;\n    vec3 normal;\n    float j2;\n    for (int i = 0; i < 8; i++) {\n        vec3 pos2;\n        float j;\n            \n        for (j = 1.0; j < 90.0; j *= 3.0) {\n            pos2 = mod(ro*j,3.0*size)-1.5*size;\n            if (mid(abs(pos2)) < 0.4999*size)\n                break;\n        }\n        \n        vec3 num = (0.5*size-pos2*sign(rd))\n            \t   *step(abs(pos2),vec3(0.5*size))\n                   *invrd/j;\n        \n        float len = mid(num);\n        \n        if (len < 0.001) {\n            break;\n        }\n        j2 = j;\n        normal = vec3(equal(vec3(len),num));\n        \n        ro += rd*len;\n        dist += len;\n    }\n    \n    \n    \n    bool light = j2 > 80.0 && fract(time*0.2) > 0.5;\n    return vec4(dist,-dot(normal,vec3(1,2,3))*sign(dot(normal,rd)),light,0);\n}\n\nvec3 surfacecolor(vec3 pos, vec3 nor) {\n    return mix(texture(iChannel0, pos).xyz,nor*0.5+0.5,0.4);\n}\n\nvec3 getcolor(vec3 pos, vec3 dir, vec3 nor)\n{\n    vec3 dcol = surfacecolor(pos,nor);\n    return dcol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragUV = fragCoord / iResolution.xy;\n    seed = iTime;\n    \n    fragColor = vec4(0);\n    \n    for (int i = 0; i < samples; i++) {\n        vec3 col = vec3(1);\n        \n        vec2 uv = ((fragCoord+vec2(rand(),rand()))*2.0-iResolution.xy)/iResolution.y;\n        \n        #ifdef static\n        time = 0.0;//+0.02*hash13(vec3(i+float(iFrame)*0.864,fragCoord));\n        vec3 ro = vec3(1.22,0.55,0.6)+8.0;\n        #else\n        time = iTime*0.4;\n        vec3 ro = vec3(1.22,.75,time)+2.0;\n        #endif\n        \n        vec3 rd = normalize(vec3(uv,1.0));\n        bool hitlight = false;\n        for (int j = 0; j < bounces; j++) {\n            vec4 hit = intersect(ro,rd);\n            \n            ro += rd*(hit.x-0.001);\n            \n            if (hit.z == 1.0) {\n                hitlight = true;\n                break;\n            } else {\n                vec3 normal = vec3(equal(vec3(abs(hit.y)),vec3(1,2,3)))*sign(hit.y);\n                vec3 rd2;\n                float spread;\n                mat3 mat;\n                \n                rd2 = normal;\n                spread = 0.98;\n\n                mat = mat3(rd2,\n                           rd2.yzx,\n                           rd2.zxy);\n                \n                col *= getcolor(ro, rd,normal);\n                col /= hit.x*hit.x+1.0;\n                vec2 rando = vec2(rand(),rand())\n                    *vec2(1,spread);\n                \n                vec2 direction = vec2(sin(rando.x*6.28),cos(rando.x*6.28))*rando.y;\n                rd = mat[0]*sqrt(1.0-rando.y*rando.y)+mat[1]*direction.x+mat[2]*direction.y;\n                \n                //because rand() is between 0 and 1 log(rand()) will always be below 0,\n                //so time goes backwards for the glow in the dark effect\n                time += log2(rand())*0.2;\n            }\n        }\n        if (hitlight)\n        fragColor.xyz += clamp(col,0.0,1.0);//getcolor(ro, rd,normal);\n    }\n    fragColor /= float(samples);\n    \n    fragColor = sqrt(fragColor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}