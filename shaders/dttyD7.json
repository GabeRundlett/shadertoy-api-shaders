{
    "Shader": {
        "info": {
            "date": "1699312792",
            "description": "buggy mandelbulb",
            "flags": 0,
            "hasliked": 0,
            "id": "dttyD7",
            "likes": 0,
            "name": "buggy mandelbulb",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "ninofiliu",
            "viewed": 148
        },
        "renderpass": [
            {
                "code": "// lygia\n\nvec2 cart2polar(in vec2 st) {\n    return vec2(atan(st.y, st.x), length(st));\n}\n\nvec3 cart2polar( in vec3 st ) {\n    float r = length(st);\n    float theta = acos(st.z/r);\n    float phi = atan(st.y, st.x);\n    return vec3(r, theta, phi);\n}\n\nvec2 mandelbulbSDF( in vec3 st ) {\n   vec3 zeta = st;\n   float m = dot(st,st);\n   float dz = 1.;\n   float n = mod(iTime, 10.);\n   const int maxiterations = 20;\n   float iterations = 0.0;\n   float r = 0.0; \n   float dr = 1.0;\n   for (int i = 0; i < maxiterations; i+=1) {\n       dz = n*pow(m, 3.5)*dz + 1.0;\n       vec3 sphericalZ = cart2polar( zeta ); \n       float newx = pow(sphericalZ.x, n) * sin(sphericalZ.y*n) * cos(sphericalZ.z*n);\n       float newy = pow(sphericalZ.x, n) * sin(sphericalZ.y*n) * sin(sphericalZ.z*n);\n       float newz = pow(sphericalZ.x, n) * cos(sphericalZ.y*n);\n       zeta.x = newx + st.x;\n       zeta.y = newy + st.y;\n       zeta.z = newz + st.z;\n\n       m = dot(zeta, zeta);\n       if ( m > 2.0 )\n         break;\n   }\n \n   // distance estimation through the Hubbard-Douady potential from Inigo Quilez\n   return vec2(0.25*log(m) * sqrt(m) / dz, iterations);\n}\n\n// mine\n\nfloat sdf(vec3 p) {\n    return mandelbulbSDF(p).x;\n}\n\nconst float rot_speed = 0.1;\nconst float surface = 0.001;\nconst int max_steps = 100;\nconst float zoom = 1.5;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 cam_pos = 1.*vec3(2.*cos(rot_speed*iTime), 2.*sin(rot_speed*iTime), 1.);\n    vec3 cam_dir = normalize(-cam_pos); // looks at center\n    vec3 cam_x = vec3(cam_dir.y, -cam_dir.x, 0);\n    vec3 cam_y = cross(cam_x, cam_dir);\n    \n    vec2 uv = -1. + 2. * fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/max(iResolution.x, iResolution.y);\n    uv.y *= iResolution.y/max(iResolution.x, iResolution.y);\n    vec3 ray_dir = normalize(cam_dir + uv.x * cam_x / zoom + uv.y * cam_y / zoom);\n    \n    vec3 p = cam_pos;\n    int i = 0;\n    while(i < max_steps) {\n        float d = sdf(p);\n        if (d < surface) { break; }\n        p += ray_dir * 0.99*d;\n        i++;\n    }\n    vec3 normal = normalize(sdf(p) - vec3(\n        sdf(p+5.*surface*vec3(1.,0.,0.)),\n        sdf(p+5.*surface*vec3(0.,1.,0.)),\n        sdf(p+5.*surface*vec3(0.,0.,1.))\n    ));\n    \n    // half lambert with hemisphere light\n    float l = 0.5+0.5*dot(normal, normalize(vec3(0.5,0.,-1.)));\n    fragColor = vec4(vec3(l),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}