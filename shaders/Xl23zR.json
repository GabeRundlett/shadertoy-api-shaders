{
    "Shader": {
        "info": {
            "date": "1426863086",
            "description": "Who are these mysterious invaders? What do they want?",
            "flags": 2,
            "hasliked": 0,
            "id": "Xl23zR",
            "likes": 0,
            "name": "[NV15] UFBs",
            "published": 3,
            "tags": [
                "space",
                "nv15",
                "unidentified"
            ],
            "usePreview": 0,
            "username": "andr00",
            "viewed": 1204
        },
        "renderpass": [
            {
                "code": "vec2 hash2( vec2 p ) {\n\treturn texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n}\n\nvoid rY(inout vec3 p, float a) {\n\tfloat c,s;vec3 q=p;\n\tc = cos(a); s = sin(a);\n\tp.x = c * q.x + s * q.z;\n\tp.z = -s * q.x + c * q.z;\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat box(vec3 p, vec3 s) {\n    return length(max(abs(p) - s, 0.0));\n}\n\nfloat mod1(inout float x, float m) {\n\tfloat r = floor(x/m);\n\tx = mod(x,m) - 0.5 * m;\n\treturn r;\n}\n\nfloat aUfb(vec3 pos) {\n    return \n\t\tmax(\n        min(\n        sphere(pos - vec3(-1.0,0.0,0.0), 2.0)\n        ,sphere(pos - vec3(1.0,0.0,0.0), 2.0)\n\t\t),\n       box(pos - vec3(0.0, 1.9,1.0), vec3(3.0,1.0,3.0))\n        )\n        ;\t\n\n}\n\nfloat regularUfbs(vec3 pos) {\n\tpos.x -= iTime * 5.0;\n\tpos.y += 7.1;\n\tmod1(pos.x, 12.0);\n\tmod1(pos.z, 12.0);\n\trY(pos, iTime * 0.5);\n    return aUfb(pos);\n}\n\nvoid wavey( inout vec3 p )\n{\n\tp.y += (sin(length(p-vec3(100.0,0.0,-100.0)) - iTime * 5.0) * 0.1)\n\t\t+ sin(length(p-vec3(-100.0,0.0,-100.0)) - iTime * 5.0) * 0.1\n;\n}\n\nfloat xzplane(vec3 pos,float y) {\n\treturn abs(pos.y - y);\n}\n\nfloat waterplane(vec3 pos) {\n\twavey(pos);\n\treturn xzplane(pos,12.0);\n}\n\nfloat distFunc(vec3 pos) {\n    return min(regularUfbs(pos),waterplane(pos));\n}\n\nvec3 distNorm(vec3 pos) {\n    const vec2 eps = vec2(0.0, 0.1);\n    return normalize(vec3(\n\t\t\t distFunc(pos + eps.yxx) - distFunc(pos - eps.yxx),\n\t\t\t distFunc(pos + eps.xyx) - distFunc(pos - eps.xyx),\n\t\t\t distFunc(pos + eps.xxy) - distFunc(pos - eps.xxy)));\n}\n\nvec4 lightUfb(vec3 pos, vec3 lig, vec3 rayDir) {\n\tvec3 normal = distNorm(pos);\n\n\tfloat ndl = clamp( dot(normal, lig), 0.0, 1.0 );\n\tfloat diffuse = max(0.0, dot(-rayDir, normal));\n//\tvec3 bcolor = vec3(1.0); // NASA\n  vec3 bcolor = vec3(0.92, 0.82, 0.63); // strangely peachy\n//\tvec3 bcolor = vec3(0.92, 0.82, 0.01); // maybe these are minions\n\n    vec3 color = bcolor * 0.1 + bcolor * ndl + ndl * 0.05 * pow(clamp(dot(normalize(-rayDir+lig),normal),0.0,1.0),1.0);\n\n\treturn vec4(color, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = fragCoord.xy / iResolution.xx;    \n    float t = iTime;\n\n\tvec3 cameraOrigin = vec3(2.0, 4.0, 2.0);\n\n    // You probably want to zero this out if you're viewing this in VR\n    vec2 cameraNoise = hash2(vec2(iTime * 0.0001, iTime));\n\n    vec3 cameraTarget = vec3(cameraNoise.xy * pow(sin(iTime),2.0) + vec2(0.0,3.0), 0.0);\n       \n    vec3 upDirection = normalize(vec3(0.1 - cameraNoise.x * 0.3, 1.0, 0.0));\n\n\tvec3 cameraDir = normalize(cameraTarget - cameraOrigin);    \n    \n\tvec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n\tvec3 cameraUp = cross(cameraDir, cameraRight);\n\tvec2 screenPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy; \n\tscreenPos.x *= iResolution.x / iResolution.y;\n\n\tvec3 rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n\n\n\tconst int MAX_ITER = 100; // 30 = eerie\n\tconst float MAX_DIST = 800.0; \n\tconst float EPSILON = 0.001;\n\n\tfloat totalDist = 0.0;\n\tvec3 pos = cameraOrigin;\n\tfloat dist = EPSILON;\n\n    vec2 cCoord = vec2(0.5,0.5);\n    \n    float d2 = pow(length(p-cCoord),2.0);\n\n    float moreShade = clamp(0.5 - abs(0.3 - d2),0.0,1.0);\n    vec4 halo = vec4(moreShade * 0.2);\n\n\n\tfloat reflectcount = 0.0;    \n\tfloat ix = 0.0;\n\tconst float iterStep = 1.0 / float(MAX_ITER);\n\n\tfor (float ix = 0.0; ix <= 1.0; ix += iterStep) {\n\n\t    if ((dist < EPSILON) || (totalDist > MAX_DIST))\n     \t   break;\n\n        dist = distFunc(pos);\n        totalDist += dist;\n        pos += dist * rayDir; \n\n        vec3 lig = normalize( vec3(5.0, -1.4, 2.0) );\n\t\t\n        if (dist < EPSILON) {\n            if(waterplane(pos) < EPSILON && (reflectcount < 1.0)) {\n\t\t\treflectcount += 1.0;\n\n\t\t\tpos.y -= 0.04; // corny\n\t\t\trayDir = reflect(rayDir, distNorm(pos));\n\t\t\tdist = distFunc(pos);\n            } else {\n                // it's a ufb              \n\t            fragColor = lightUfb(pos, lig, rayDir);            \n\t\t\t   fragColor += vec4(ix);\n\t\t  }\n\n        } else {\n\t\t\tfragColor = vec4(ix,ix,ix*0.8 + 0.2,1.0);\n\t\t}\n\t}\n\tfragColor += halo;\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "webcam",
                        "id": 31,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/webcam.png"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}