{
    "Shader": {
        "info": {
            "date": "1611927719",
            "description": "Directed by Darya Kolesnikova https://youtube.com/channel/UC-92Wm8nea2J6hX5jN166Eg\nMade with code by Ivan Dianov https://twitter.com/i_dianov\nMusic by Leonid Zazulin https://soundcloud.com/skillpnk",
            "flags": 64,
            "hasliked": 0,
            "id": "WlycWt",
            "likes": 2,
            "name": "Abyss!",
            "published": 3,
            "tags": [
                "video"
            ],
            "usePreview": 1,
            "username": "illus0r",
            "viewed": 268
        },
        "renderpass": [
            {
                "code": "// PLEASE, FabriceNeyret2, DO NOT READ THIS\n\n#define MAX_STEPS 70\n#define MAX_DIST 90.\n#define EPSILON .01\n#define PI 3.14159265\n\n#define EMPTY 0.\n#define MIRROR 1.\n#define BLUE 2.\n#define BLACK 3.\n#define RED 4.\n#define WHITE_MIRROR 5.\n#define PUREWHITE 6.\n#define FUNNEL 7.\n#define GLOW 8.\n#define ROCKET 9.\n#define METHEORS 10.\n#define LIGHTNING 11.\n#define TUNNEL 12.\n#define BUGNETWORK 13.\n#define FUNNEL_BUGNETWORK 14.\n\n#define BEAT0 texture(iChannel0, vec2(0.25, 0.25) ).x\n#define BEAT1 texture(iChannel0, vec2(0.5, 0.25) ).x\n#define BEAT2 texture(iChannel0, vec2(0.75, 0.25) ).x\n\n#define FUNNELROT p.xy+=vec2(sin(p.z),cos(p.z))*.4*smoothstep(7.8, 8.2, T)*sin(T*3.1415);p.x-=2.0*sin(T*5.);p.xy*=rot(sin(T*4.*PI)*.05)\n#define CHUNK  4.28125\n#define ROCKET_LIGHTNINGS_SWING p.y+=(2.*noise(vec2(iTime+1.))-1.)*2.;p.x += (2.*noise(vec2(iTime+5.))-1.)*2.;\n\n\n#define tBeam vec2(.2,.5)\n\n#define PHI (sqrt(5.)*0.5 + 0.5)\n// Total time (1. = 1 beat)\n#define T ((iTime-.36) / 4.28125)+0.\n// Number of current beat\n#define Ti floor(T)\n// Number of current subbeat (0…3)\n#define ti floor(t*4.)\n\nfloat rnd(float x) {return 2.*fract(54321.987139 * sin(987.123452331 * x))-1.;}\n#define strLen 32.\n\nfloat text(vec2 uv, float t)\n{\n    float o=0.;\n    vec2 FC = uv*iResolution.xy;\n    int str[int(strLen)];\n    float id = floor(uv.x*strLen);\n    float thresh = .49;\n    uv.x-=id/strLen;\n    uv.x*=strLen;\n    float names[3];\n    for(int n=0; n<3; n++){\n        if(n==0)\n            if(uv.y>.5)str = int[](48,48,48,48,84,121,130,117,115,132,117,116,48,114,137,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48);\n            else {str = int[](48,48,48,48,84,113,130,137,113,48,91,127,124,117,131,126,121,123,127,134,113,48,48,48,48,48,48,48,48,48,48,48);thresh+=.01+.1*pow(rnd(iTime+length(FC)),16.);}\n        if(n==1)\n            if(uv.y>.5)str = int[](48,48,48,48,93,113,116,117,48,135,121,132,120,48,115,127,116,117,48,114,137,48,48,48,48,48,48,48,48,48,48,48);\n            else str = int[](48,48,48,48,89,134,113,126,48,84,121,113,126,127,134,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48);\n        if(n==2)\n            if(uv.y>.5)str = int[](48,48,48,48,93,133,131,121,115,48,114,137,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48);\n            else str = int[](48,48,48,48,92,117,127,126,121,116,48,106,113,138,133,124,121,126,48,48,48,48,48,48,48,48,48,48,48,48,48,48);\n        int i=int(float(str[int(id)])+32.*0.)%256;\n        ivec2 xy=ivec2(i%16,16-i/16);\n        vec2 uv_ = uv;\n        uv_.y=clamp(uv_.y*16.-7.-(uv_.y>.5?1.:0.),0.,1.);\n        names[n] = texture(iChannel1,vec2(xy)/16.+uv_/16.).a;\n    }\n\n    float name = mix(1.,names[0],smoothstep(.0,1.5,t-0.));\n    name = mix(name,names[1],smoothstep(.0,1.5,t-3.));\n    name = mix(name,names[2],smoothstep(.0,1.5,t-6.));\n    o += step(-thresh,-name);\n    o = min(o,1.-smoothstep(.6,.8,t-9.));\n    return o;\n}\n\nfloat g_glow;\n\nmat2 rot(float a) { float s = sin(a), c = cos(a); return mat2(c, -s, s, c); }\nfloat sdBox( vec3 p, vec3 b ) { vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0); }\nfloat sdOctahedron( vec3 p, float s) { p = abs(p); float m = p.x+p.y+p.z-s; vec3 q; if( 3.0*p.x < m ) q = p.xyz; else if( 3.0*p.y < m ) q = p.yzx; else if( 3.0*p.z < m ) q = p.zxy; else return m*0.57735027; float k = clamp(0.5*(q.z-q.y+s),0.0,s); return length(vec3(q.x,q.y-s+k,q.z-k)); }\nfloat opSmoothUnion( float d1, float d2, float k ) { float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 ); return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat opSmoothSubtraction( float d1, float d2, float k ){float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );return mix( d2, -d1, h ) + k*h*(1.0-h); }\n//float sdTorus(vec3 p, vec2 t){ vec2 q = vec2(length(p.xz)-t.x,p.y); return length(q)-t.y;}\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n// Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nfloat snoise(vec2 v) {\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        0.366025403784439,\n                        -0.577350269189626,\n                        0.024390243902439);\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n        permute( i.y + vec3(0.0, i1.y, 1.0))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n        dot(x0,x0),\n        dot(x1,x1),\n        dot(x2,x2)\n    ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\nfloat rand(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noise(vec2 n) {\n    //https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\nvec2 p2d(vec2 polar) {\n    float alpha = polar.x;\n    float R = polar.y;\n    float x = sin(alpha) * R;\n    float y = cos(alpha) * R;\n    return vec2(x, y);\n}\nvec2 d2p(vec2 decart) {\n    float alpha = atan(decart.x, decart.y);\n    float R = length(decart);\n    return vec2(alpha, R);\n}\nvec2 snowflakeSymmetry(vec2 p, float rays){\n    vec2 ar = d2p(p);\n    float astep = 2. * 3.1415 / rays;\n    float a = ar.x, r = ar.y;\n    a = mod(a, astep);\n    a -= astep / 2.;\n    a = abs(a);\n    p = p2d(vec2(a, r));\n    return p;\n}\nfloat sdWater(vec3 p) {\n    float tt = iTime * 10.1;\n    p.y += .001*sin(p.z*17.+tt);\n    p.y += .001*sin(p.z*13.+tt);\n    p.y += .001*sin(p.x*11.+tt*.5);\n    return p.y;\n}\nfloat bullets (vec3 p){\n    float dist = length(p);\n    p.z+=iTime*1.;\n    p.xy*=rot(p.z+p.z*BEAT0*.001);\n    p.xy*=(1.+2.1*BEAT0);\n    p = mod(p,1.)-.5;\n\treturn (length(p)*(1.-.01*BEAT1)-.02)*.7*(1.+8.*smoothstep(10., 10.1, dist));\n}\nfloat rocket (vec3 p){\n    //if(T>4. && T<4.25){\n    \t//p.z += 4.;\n    \t//p.z += fract(T*40.)*.1;\n    \tp.z -= 10.-10.*pow(smoothstep(4., 4.25, T),1.);\n        //pow(1.-mod(T*4.,1.),.8)\n    //}\n    //if(T>4.25){\n    \tp/=1.+(BEAT2)*1.;\n    //\tp.y/=((BEAT2))*4.;\n    //\tp.z-=((BEAT2))*8.;\n    //\tp.xz*=((BEAT2))*3.;\n    //\tp.xy *= rot(PI/4.);\n    //}\n    float sph=length(p)-1.3-5.*smoothstep(8.,8.5,T); \n        //-0.*pow(sin((T-.25)*PI*8.)*.5+.5,16.) // time beat\n        //-0.*pow(BEAT2,1.5)*4.-.2; // sound beat\n    //for(float i=2.;i<3.;i+=0.5){\n    //    // float shift = 4.*sin(iTime*i);\n    //    // float shift = 20.*(fract(.1*iTime*(1.2+.4*Rnd(i))+Rnd(i))*2.-1.)*i;\n    //    float shift = tan(iTime*(1.2+.4*rnd(i))+rnd(i));\n    //    float spread = 4.;\n    //    sph=opSmoothUnion(sph, (length(p*i+vec3(spread*rnd(i),shift,spread*rnd(i+1.))) - 1.)/i, .4);\n    //}\n    return sph;\n}\nfloat bugNetwork(vec3 p) {\n    float plane = -p.z+70.-20.*smoothstep(9.5,10.,T+.1*rnd(p.x+p.y));\n    p.z+=iTime;\n    p.x += .5*sin(p.z+T*4.);\n    p.z = fract(p.z+.5);\n    p.xy = abs(p.xy);\n    p.xy-=1.;\n    p.xy*=rot(PI/4.+p.z);\n    return min(plane, length(p.yz)+.1);\n}\nfloat lightning(vec3 p, vec2 amp){\n    float id = floor(p.x);\n    \n    //p.xy += 10.*smoothstep(40., 50., -p.x)*rnd(iTime+p.x+p.y+1.);\n    //p.xy += 10.*smoothstep(3.5, 4.5, T)*rnd(iTime+p.x+p.y+1.);\n    \n    vec2 shift=      vec2(rnd(id+   iTime*.0),\n                          rnd(id+   iTime*.0+10.));\n    vec2 shiftNext = vec2(rnd(id+1.+iTime*.0),\n                          rnd(id+1.+iTime*.0+10.));\n    // vec2 shift_ = shift, shiftNext_ = shiftNext;\n    shift=shift*.5; shiftNext=shiftNext*.5;\n    // shift=pow(shift,vec2(4.)); shiftNext=pow(shiftNext,vec2(4.));\n    // shift*=shift/abs(shift); shiftNext*=shiftNext/abs(shiftNext);\n    // shift=shift*2.-1.; shiftNext=shiftNext*2.-1.;\n    shift*=amp; shiftNext*=amp;\n    // shift.y=shiftNext.y=0.;\n    // shift.x=shiftNext.x=0.;\n    p.x -= id;\n    p.yz += shift;\n    // p.zx *= rot(iTime);\n    float dx = 1.,\n        dy = shiftNext.x-shift.x,\n        dz = shiftNext.y-shift.y;\n    p.xy *= rot(atan(dy, dx));\n    p.zx *= rot(-atan(dz, length(vec2(dx, dy))));\n    return (length(p.yz)-0.01*BEAT2);\n}\nfloat metheors(vec3 p){\n    // p-=.05*(rnd(floor(p.z*50.)/50.)-.5)*2.;\n    p-=.005*length(p)*(rnd(p.z)-.5)*2.;\n    p.z+=4.;\n    float tt = iTime*4.;//4.*sin(iTime*5.);\n    float scale = 1.;\n    p=normalize(p)/length(p);\n    for(int j=0;j<3;j++){\n        p.xz*=rot((tt / 3.91));\n        p.xy*=rot((tt / 2.91));\n        // if(rnd(p.y)<.001)break;\n        p=abs(p)-(j<2?0.1:.4);\n        p*=2.1;\n        scale*=2.1;\n    }\n    // p.xz*=rot(t);\n    return 10.*sdBox(p, vec3(.1))/scale;\n}\nfloat funnel(vec3 p){\n    //p.xy\n\t//    p.z += sin(iTime*10.)*10.;\n\t//    //if (T<4.){\n\t        FUNNELROT;\n    //if(p.z > 100.) return -1.;\n\t//    //}\n\t//    //p.z-=1.5;\n\t//    p/=4.;\n\t//\n\t//    //if (T<4.){\n\t//\t    p.y*=3.;\n\t//    //}\n\t//    //else {\n\t//    //\tp.y*=9.;\n\t//    //}\n\t//    vec2 q = vec2(length(p.xz)-16.1,p.y);\n\t//    return -(length(q)-16.)*1.8;\n\t//    // return length(p)-.1;\n    return -(length(p.xy)-4.)*(1.+8.*pow(smoothstep(7.,9.,T-sin(d2p(p.xy).x*4.)*.5+.5),1.));\n}\nfloat tunnel(vec3 p) {\n    p.z += iTime * 1.1;\n    float w = p.z * 1.5;\n    p.x += .4*cos(w);\n    p.y += .4*sin(w);\n    p.xy*=rot(p.z * 2.9 + iTime);\n    // p.x += 1.4;\n    return -(length(p.xy) - 1.);\n}\n\n// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\nvec2 getDist(vec3 p) {\n    vec2 obj = vec2(9999.);\n\n    // // float metheors = metheors(p);\n    \n\tfloat bn = bugNetwork(p);\n    float funnel = funnel(p);\n    //obj = obj.x < bn ? obj : vec2(funnel,BUGNETWORK);\n    float funnel_bg_mix = mix(funnel, bn, smoothstep(7.5,8.5,T));\n    obj = obj.x < funnel_bg_mix ? obj : vec2(funnel_bg_mix,FUNNEL_BUGNETWORK);\n\n    \n    if(T>11.5){\n    }\n    \n    //float tunnel = tunnel(p);\n    //obj = obj.x < tunnel ? obj : vec2(tunnel, TUNNEL);\n\n    if(T>8.){\n        vec3 p_ = p;\n        ROCKET_LIGHTNINGS_SWING\n        float rocket = rocket(p);\n        p=p_;\n        rocket=opSmoothSubtraction(-rocket,-funnel,1.5);\n    \tfloat metheors = metheors(p);\n        float r_m_mix = mix(rocket, metheors, smoothstep(8.,11.,T));\n        float bullets = bullets(p);// / smoothstep(11.5,12.5,T);\n        float r_m_b_mix = mix(r_m_mix, bullets, smoothstep(11.,12.,T));\n    \tobj = obj.x < r_m_b_mix ? obj : vec2(r_m_b_mix, ROCKET);\n    }\n\n    if (T>4. && T<8.){\n        ROCKET_LIGHTNINGS_SWING\n        float rocket = rocket(p);\n        rocket=opSmoothSubtraction(-rocket,-funnel,1.5);\n        obj = obj.x < rocket ? obj : vec2(rocket, ROCKET);\n\n        p.z/=3.;\n        p.xz*=rot(PI/2.+BEAT1-0.5);\n        p.x-=BEAT1*100.;\n        //p.zy *= rot(0.5);\n        p.zy *= rot(iTime+BEAT1-0.5);\n        vec2 amp=vec2(2.);\n        float lightnings = lightning(p, amp)*1.4 * (1.+2.*smoothstep(7.5,8.,T));\n        // // p.zy *= rot(-1.6*iTime);\n        // // p.x *=-1.;\n        // // lightnings = min(lightnings, lightning(p, amp)*1. );\n        obj = obj.x < lightnings ? obj : vec2(lightnings, LIGHTNING);\n    }\n\n    return obj;\n    // return vec2(length(p)-1., WHITE_MIRROR);\n}\n// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n\n\n\n\n\n\n\n\n\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n    float d = 0.;\n    float info = EMPTY;\n    float minAngleToObstacle = 1e10;\n    float glow = 0.;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec2 distToClosest = getDist(ro + rd * d);\n        info = distToClosest.y;\n        // minAngleToObstacle = min(minAngleToObstacle, atan(distToClosest.x, d));\n        if(info == BUGNETWORK)\n            glow += 0.00001/pow(distToClosest.x,10.);\n        d += abs(distToClosest.x);\n        if(abs(distToClosest.x) < EPSILON || d > MAX_DIST) {\n            break;\n        }\n    }\n    return vec3(d, info, glow);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n    vec3 n_ = getDist(p).x - vec3(getDist(p - e.xyy).x,\n                                  getDist(p - e.yxy).x,\n                                  getDist(p - e.yyx).x);\n    return normalize(n_);\n}\n\nvec3 getRayDirection (vec3 ro, vec2 uv, vec3 lookAt) {\n    vec3 rd;\n    rd = normalize(vec3(uv - vec2(0, 0.), 1.));\n    vec3 lookTo = lookAt - ro;\n    float horizAngle = acos(dot(lookTo.xz, rd.xz) / length(lookTo.xz) * length(rd.xz));\n    rd.xz *= rot(horizAngle);\n    return rd;\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n// used recursively for reflections\n// vec3 getColor(vec3 ro, vec3 rd, vec3 color, int depth) {\n// }\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    float d, info, dtotal=0., glow, marches, lightSpots=0.;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ro, rd, color=vec3(0), p, rm, n;\n\n    // пумы\n    if (T > 0. && T < 5. || T > 16.) {\n        vec2 uvLs = uv;\n        uvLs.x += sin(uvLs.y+T+BEAT2)*cos(uvLs.y) + T;\n        uvLs.y+=T;\n        lightSpots = (sin(uvLs.x*5.)+sin(uvLs.y*5.))*.5;\n        lightSpots = clamp(0.,1.,lightSpots);\n        uvLs = uv;\n        uvLs.x *= .6;\n        uvLs.y *= .7;\n        lightSpots *= 1.-length(uvLs*2.);\n\n    }\n    if (Ti == 3. || Ti == 4.) {\n        vec2 uvKl = uv;\n        float katarsisLight = 3.*pow(smoothstep(3.3, 4., T),10.)-length(uvKl);\n        katarsisLight = clamp(katarsisLight, 0., 1.);\n        katarsisLight -= smoothstep(4., 4.1, T);\n        lightSpots += katarsisLight;\n    }\n\n    if (T<4.){\n\t\tuv.y *= pow(2.,1.+10.*smoothstep(4.0, .0, T));\n    }    \n    if (T>15.){\n\t\tuv.y *= pow(2.,10.*smoothstep(15., 17., T));\n    }\n\n    float camDist = -10.;\n    ro = vec3(0,0,camDist);\n    rd = getRayDir(uv, ro, vec3(0), 1.);\n\n    // making several marches outside and inside\n    // the surface along the ray\n    for (int i = 0; i < 1; i++) {\n        rm = rayMarch(ro, rd);\n        dtotal += d = rm[0];\n        p = ro + rd * d;\n        info = rm[1];\n        glow = rm[2];\n\n\n\n        if (dtotal > MAX_DIST) break;\n\n        if(info==LIGHTNING) {\n            // color += 100./glow;\n            color = vec3(1.);\n        }\n        \n        if(info==BUGNETWORK) {\n            color = vec3(1.);\n            //color += glow;\n        }\n\n        if(info==FUNNEL_BUGNETWORK) {\n            FUNNELROT;\n            vec3 pf = p;\n            //if (T<4.){\n            //}   \n            // находим цвет\n            //n = getNormal(p);\n            // color+= n*.5+.5;\n            //vec2 po = d2p(p.xz*rot(PI));\n            //po.x += .1;\n            //po.x+=po.y*(p.y/abs(p.y))*.4;\n            //po.y/=16.;\n            //po.y-=iTime/16.;\n            //color = (vec3(snoise(po*19.))+1.);\n            pf.z+=iTime*10.;\n            pf.xy*=rot(pf.z/10.);\n            color+=sin(pf.x*32.)+sin(pf.y*32.)\n                +sin(pf.z+pf.y);\n            color+=sin(pf.x*19.)+sin(pf.y*21.)\n                +sin(pf.z+pf.y);\n            color/=6.;\n            color+=.5;\n            color = clamp(color, 0., 1.);\n            color = pow(color, vec3(1.2));\n            //color = smoothstep(1., 1.9, color); // noise threshold\n            //color *= smoothstep(16., 0., length(p.xz));\n            if (T<4.){\n               color *= 1.-smoothstep(.0, 8., dtotal);\n            }\n            else {\n               color *= smoothstep(-20.0, 10., -dtotal);\n               color+= (sin(T*4.)*.5+.5)*smoothstep(10.0, 21., dtotal);\n            }\n            \n            //// color *= 1.-smoothstep(-.7, 3.5, dot(rd,n));\n            //// color *= 1.-smoothstep(-.7, 3.5, dot(rd,n));\n            color = clamp(color, 0., 1.);\n            //color *= fract(iTime/2.);\n            marches+=.2;\n        }\n        if (info == TUNNEL) {\n            n = getNormal(p);\n            vec2 pol = d2p(p.xy);\n            p.z +=  iTime * 1.1;\n            float pz = p.z * 50.;\n            float px = pol.x * 50.;\n            float idx = floor(px/PI);\n            float idz = floor(pz/PI - .5);\n            // pol.x += Rnd(idx + floor(iTime * 4.));\n            color = vec3(sin(px) + cos(pz));\n            color = pow(color, vec3(10.));\n            color /= 500. * d;\n            color *= rnd(idx + 10. * idz + floor(iTime*.00005+p.z))<0. ? 0. : 1.;\n            marches+=1.;\n            // color.r += Rnd(idx + 10. * idz + floor(iTime+p.z))<0. ? 0. : 1.;\n            // color = nn*.5+.5;\n        }  if(info==METHEORS) {\n            // находим цвет\n            n = getNormal(p);\n            // color+= n*.5+.5;\n            color+= 2.*dot(n,vec3(0,1,0))+1.;\n            color*=smoothstep(5.,3.,d);\n            marches+=1.;\n        }\n        if(info==ROCKET) {\n            // находим цвет\n            n = getNormal(p);\n            // color = n*.5+.5;\n            color = vec3(1.) * dot(n*.5+.5,vec3(0.,1.,0.));\n            marches+=.5;\n        }\n        // marches+=1.;\n        // мы нактнулись.\n        // n = getNormal(p);\n        // // находим отражение\n        // float refK = 7.;\n        // ref = reflect(rd, n);\n        // color+=refK*textureCubeZ(bg, ref).xyz;\n        // marches+=refK;\n        // находим блеск\n        // color+=2.*smoothstep(-.5,1.,dot(ref, rd));\n        // color+=2.*smoothstep(.6,1.,dot(ref, rd));\n\n\n        ro = p + rd * 0.05;\n    }\n    //color/=marches;\n    color += vec3(glow);\n    color = clamp(color, 0., 1.);\n\n    color *= smoothstep(0., 1., T);;\n    color *= smoothstep(17., 15., T);\n    color += lightSpots*smoothstep(2., 2.1, T);\n    \n    if(T>16.&&T<25.){\n        color+=text(fragCoord/iResolution.xy,(T-16.5)*CHUNK);\n    }\n\n    fragColor = vec4(color, 1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 25344,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/ivan-zorin/skillpunk-abyss"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}