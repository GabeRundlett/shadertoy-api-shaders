{
    "Shader": {
        "info": {
            "date": "1695045905",
            "description": "i just added visualizing XY.x as color\nfrom forked:\noriginal shader was forked from FabriceNeyret2.\nI forked it trying to make yhis 3d. Its not easy...\n",
            "flags": 0,
            "hasliked": 0,
            "id": "cd3yWN",
            "likes": 3,
            "name": "Colorized Fake Sphere 3d",
            "published": 3,
            "tags": [
                "3d",
                "distortions",
                "dots",
                "short",
                "golf",
                "loopless"
            ],
            "usePreview": 0,
            "username": "timmaffett",
            "viewed": 204
        },
        "renderpass": [
            {
                "code": "// Fork of \"Fake Sphere 3d\" by davidmachadosf. https://shadertoy.com/view/md3cDH\n// 2023-09-18 14:01:29\n\n// loopless + golfing 533 \"Sphere fake 3d\" by SnackEater. https://shadertoy.com/view/dljfWW\n// 272 without Jacobians -  288 with approx J  - 308 with exact J\n\n#define VISUALIZE_XY_Y_ALSO   0\n\nvec4 hsb2rgb( in vec4 c )\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return vec4(c.z * mix( vec3(1.0), rgb, c.y), 1.);\n}\n\n\n#define ROT mat2(cos( iTime +vec4(.5,33,11,0.)))\n\nvoid mainImage( out vec4 COR, vec2 XY ) {\n\n    bool esq = int(XY.y)%2==0;\n    //if (!esq) {\n    //     XY.y = XY.y-1.;\n    //    return;\n   // }\n    \n\n    vec3  R = iResolution, P;\n    XY = ( 2.*XY - R.xy );\n    XY /= R.y;\n    \n    \n    float S = (1.+sin(iTime/1000.))*.05,\n          Z = 1. - dot(XY,XY);\n    \n    //COR = vec4(esq?1.:0., esq?0.:1., 0., 1.);\n    COR *= 0.;\n    Z > 0.                                                         // if on sphere\n      ? \n        P = vec3( XY, pow(Z,.5) ),                                    // 3D point on front half-sphere\n        P.yz *= ROT,\n        P.xz *= ROT,                                                 // rotate on sphere\n        XY =  vec2( atan(length(P.xy),P.z), atan(P.x,P.y) ),        // get parameterization\n        COR.g= 1. - length( ( mod( XY + S , 2.*S ) -S )               // draw blob at grid centers\n                          // / fwidth(XY) ) * 140./R.y                // compensate distorsion with Jacobian (approx)\n                          * inverse(transpose(mat2(dFdx(XY),dFdy(XY)))) )  * 1e2/R.y  // ( precise )\n      : S\n      ;\n      \n#if VISUALIZE_XY_Y_ALSO\n  COR = COR.g * hsb2rgb( vec4( (XY.x/5.+XY.y/10.0)*iTime/10.0, 0.9, 0.9, 1.0));\n#else\n  // XY.x only\n  COR = COR.g * hsb2rgb( vec4( (XY.x/5.)*iTime/10.0, 0.9, 0.9, 1.0));\n#endif\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}