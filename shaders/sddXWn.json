{
    "Shader": {
        "info": {
            "date": "1632967861",
            "description": "Analyzing sRGB blue in the ZCAM (default) and Oklab (mouse down) color spaces.\n\nThis shader has many other features that can be enabled by uncommenting the respective sections in mainImage. See https://github.com/kdrag0n/glcolortest for more info.",
            "flags": 0,
            "hasliked": 0,
            "id": "sddXWn",
            "likes": 2,
            "name": "sRGB blue analysis in ZCAM",
            "published": 3,
            "tags": [
                "color",
                "blue",
                "cam",
                "srgb",
                "colorscience",
                "oklab",
                "zcam"
            ],
            "usePreview": 0,
            "username": "kdrag0n",
            "viewed": 315
        },
        "renderpass": [
            {
                "code": "precision highp float;\n\n/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2021 Danny Lin <danny@kdrag0n.dev>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n/*\n * Config\n */\n\nconst float HUE_RATE = 20.0;\n\nconst float SRGB_WHITE_LUMINANCE = 203.0; // cd/m^2\nconst float SRGB_WHITE_LUMINANCE_DYN_MAX = 10000.0; // cd/m^2\n\n\n/*\n * Helpers\n */\n\nconst float PI = 3.141592653589793;\nconst float FLT_MAX = 3.402823466e+38;\n\nfloat degreesToRadians(float x) {\n    return x * PI / 180.0;\n}\n\nfloat radiansToDegrees(float x) {\n    return x * 180.0 / PI;\n}\n\nfloat atan2(float y, float x) {\n    bool s = (abs(x) > abs(y));\n    return mix(PI/2.0 - atan(x,y), atan(y,x), s);\n}\n\nfloat cbrt(float x) {\n    return sign(x) * pow(abs(x), 1.0 / 3.0);\n}\n\nfloat square(float x) {\n    return x * x;\n}\n\nfloat cube(float x) {\n    return x * x * x;\n}\n\nfloat sqrtStd(float x) {\n    if (x < 0.0) {\n        return 0.0 / 0.0;\n    } else {\n        return sqrt(x);\n    }\n}\n\n\n/*\n * Number rendering\n */\n\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0)\n// https://www.shadertoy.com/view/4sBSWW\n\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{\n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n\n    bool bNeg = ( fValue < 0.0 );\n    fValue = abs(fValue);\n\n    float fLog10Value = log2(abs(fValue)) / log2(10.0);\n    float fBiggestIndex = max(floor(fLog10Value), 0.0);\n    float fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n    float fCharBin = 0.0;\n    if(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n        if(fDigitIndex > fBiggestIndex) {\n            if((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n        } else {\n            if(fDigitIndex == -1.0) {\n                if(fDecimalPlaces > 0.0) fCharBin = 2.0;\n            } else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n                float fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n            }\n        }\n    }\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n// ---- 8< -------- 8< -------- 8< -------- 8< ----\n\n\n/*\n * LCh\n */\n\nvec3 labToLch(vec3 c) {\n    float L = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float hDeg = radiansToDegrees(atan2(b, a));\n    return vec3(\n        L,\n        sqrt(a*a + b*b),\n        (hDeg < 0.0) ? hDeg + 360.0 : hDeg\n    );\n}\n\nvec3 lchToLab(vec3 c) {\n    float L = c.x;\n    float C = c.y;\n    float h = c.z;\n\n    float hRad = degreesToRadians(h);\n    return vec3(\n        L,\n        C * cos(hRad),\n        C * sin(hRad)\n    );\n}\n\n\n/*\n * sRGB\n */\n\nvec3 srgbTransfer(vec3 c) {\n    vec3 gamma = 1.055 * pow(c, vec3(1.0/2.4)) - 0.055;\n    vec3 linear = 12.92 * c;\n    bvec3 selectParts = lessThan(c, vec3(0.0031308));\n    return mix(gamma, linear, selectParts);\n}\n\nvec3 srgbTransferInv(vec3 c) {\n    vec3 gamma = pow((c + 0.055)/1.055, vec3(2.4));\n    vec3 linear = c / 12.92;\n    bvec3 selectParts = lessThan(c, vec3(0.04045));\n    return mix(gamma, linear, selectParts);\n}\n\nbool linearSrgbInGamut(vec3 c) {\n    vec3 clamped = clamp(c, 0.0, 1.0);\n    return c == clamped;\n}\n\nfloat _int8ToFloat(int x) {\n    return float(x) / 255.0;\n}\n\nvec3 rgb8ToFloat(int c) {\n    return vec3(\n        _int8ToFloat((c >> 16) & 0xff),\n        _int8ToFloat((c >> 8) & 0xff),\n        _int8ToFloat(c & 0xff)\n    );\n}\n\n\n/*\n * XYZ\n */\n\nconst vec3 D65 = vec3(0.95047, 1.0, 1.08883);\nconst vec3 DCI_P3 = vec3(0.89458689, 1.0, 0.95441595);\n\nconst mat3 M_SRGB_TO_XYZ = mat3(\n    0.4123908 , 0.21263901, 0.01933082,\n    0.35758434, 0.71516868, 0.11919478,\n    0.18048079, 0.07219232, 0.95053215\n);\nconst mat3 M_XYZ_TO_SRGB = mat3(\n     3.24096994, -0.96924364,  0.05563008,\n    -1.53738318,  1.8759675 , -0.20397696,\n    -0.49861076,  0.04155506,  1.05697151\n);\n\nconst mat3 M_DISPLAY_P3_TO_XYZ = mat3(\n     0.48657095,  0.22897456, -0.        ,\n     0.26566769,  0.69173852,  0.04511338,\n     0.19821729,  0.07928691,  1.04394437\n);\nconst mat3 M_XYZ_TO_DISPLAY_P3 = mat3(\n     2.49349691, -0.82948897,  0.03584583,\n    -0.93138362,  1.76266406, -0.07617239,\n    -0.40271078,  0.02362469,  0.95688452\n);\n\nconst mat3 M_BT2020_TO_XYZ = mat3(\n    0.63695805, 0.26270021, 0.        ,\n    0.1446169 , 0.67799807, 0.02807269,\n    0.16888098, 0.05930172, 1.06098506\n);\nconst mat3 M_XYZ_TO_BT2020 = mat3(\n     1.71665119, -0.66668435,  0.01763986,\n    -0.35567078,  1.61648124, -0.04277061,\n    -0.25336628,  0.01576855,  0.94210312\n);\n\nconst mat3 M_DCI_P3_TO_XYZ = mat3(\n     0.44516982,  0.20949168, -0.        ,\n     0.27713441,  0.72159525,  0.04706056,\n     0.17228267,  0.06891307,  0.90735539\n);\nconst mat3 M_XYZ_TO_DCI_P3 = mat3(\n     2.72539403, -0.79516803,  0.04124189,\n    -1.01800301,  1.68973205, -0.08763902,\n    -0.4401632 ,  0.02264719,  1.10092938\n);\n\nvec3 linearSrgbToXyz(vec3 c) {\n    return M_SRGB_TO_XYZ * c;\n}\n\nvec3 xyzToLinearSrgb(vec3 c) {\n    return M_XYZ_TO_SRGB * c;\n}\n\n\n/*\n * CIELAB\n */\n\n\nfloat cielabF(float x) {\n    if (x > 216.0/24389.0) {\n        return cbrt(x);\n    } else {\n        return x / (108.0/841.0) + 4.0/29.0;\n    }\n}\n\nfloat cielabFInv(float x) {\n    if (x > 6.0/29.0) {\n        return cube(x);\n    } else {\n        return (108.0/841.0) * (x - 4.0/29.0);\n    }\n}\n\nvec3 xyzToCielab(vec3 c) {\n    float L = 116.0 * cielabF(c.y / D65.y) - 16.0;\n    float a = 500.0 * (cielabF(c.x / D65.x) - cielabF(c.y / D65.y));\n    float b = 200.0 * (cielabF(c.y / D65.y) - cielabF(c.z / D65.z));\n    return vec3(L, a, b);\n}\n\nvec3 cielabToXyz(vec3 c) {\n    float L = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float lp = (L + 16.0) / 116.0;\n    float x = D65.x * cielabFInv(lp + (a / 500.0));\n    float y = D65.y * cielabFInv(lp);\n    float z = D65.z * cielabFInv(lp - (b / 200.0));\n    return vec3(x, y, z);\n}\n\n\n/*\n * Oklab\n */\n\nconst float LR_K1 = 0.206;\nconst float LR_K2 = 0.03;\nconst float LR_K3 = (1.0 + LR_K1) / (1.0 + LR_K2);\n\nvec3 xyzToOklab(vec3 c) {\n    float l = 0.8189330101 * c.x + 0.3618667424 * c.y - 0.1288597137 * c.z;\n    float m = 0.0329845436 * c.x + 0.9293118715 * c.y + 0.0361456387 * c.z;\n    float s = 0.0482003018 * c.x + 0.2643662691 * c.y + 0.6338517070 * c.z;\n\n    float l_ = cbrt(l);\n    float m_ = cbrt(m);\n    float s_ = cbrt(s);\n\n    float L = 0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_;\n    float a = 1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_;\n    float b = 0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_;\n\n    return vec3(L, a, b);\n}\n\nvec3 oklabToXyz(vec3 c) {\n    float L = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float l_ = L + 0.3963377774f * a + 0.2158037573f * b;\n    float m_ = L - 0.1055613458f * a - 0.0638541728f * b;\n    float s_ = L - 0.0894841775f * a - 1.2914855480f * b;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    return vec3(\n        +1.2270138511 * l - 0.5577999807 * m + 0.2812561490 * s,\n        -0.0405801784 * l + 1.1122568696 * m - 0.0716766787 * s,\n        -0.0763812845 * l - 0.4214819784 * m + 1.5861632204 * s\n    );\n}\n\nvec3 linearSrgbToOklab(vec3 c) {\n    return xyzToOklab(linearSrgbToXyz(c));\n}\n\nvec3 oklabToLinearSrgb(vec3 c) {\n    return xyzToLinearSrgb(oklabToXyz(c));\n}\n\n\n/*\n * OkLrab\n */\n\nvec3 xyzToOklrab(vec3 c) {\n    float l = 0.8189330101 * c.x + 0.3618667424 * c.y - 0.1288597137 * c.z;\n    float m = 0.0329845436 * c.x + 0.9293118715 * c.y + 0.0361456387 * c.z;\n    float s = 0.0482003018 * c.x + 0.2643662691 * c.y + 0.6338517070 * c.z;\n\n    float l_ = cbrt(l);\n    float m_ = cbrt(m);\n    float s_ = cbrt(s);\n\n    float L = 0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_;\n    float a = 1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_;\n    float b = 0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_;\n\n    float Lr = (LR_K3*L - LR_K1 + sqrt(square(LR_K3*L - LR_K1) + 4.0*LR_K2*LR_K3*L)) / 2.0;\n\n    return vec3(Lr, a, b);\n}\n\nvec3 oklrabToXyz(vec3 c) {\n    float Lr = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float L = (Lr * (Lr + LR_K1)) / (LR_K3 * (Lr + LR_K2));\n\n    float l_ = L + 0.3963377774f * a + 0.2158037573f * b;\n    float m_ = L - 0.1055613458f * a - 0.0638541728f * b;\n    float s_ = L - 0.0894841775f * a - 1.2914855480f * b;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    return vec3(\n        +1.2270138511 * l - 0.5577999807 * m + 0.2812561490 * s,\n        -0.0405801784 * l + 1.1122568696 * m - 0.0716766787 * s,\n        -0.0763812845 * l - 0.4214819784 * m + 1.5861632204 * s\n    );\n}\n\nvec3 linearSrgbToOklrab(vec3 c) {\n    return xyzToOklrab(linearSrgbToXyz(c));\n}\n\nvec3 oklrabToLinearSrgb(vec3 c) {\n    return xyzToLinearSrgb(oklrabToXyz(c));\n}\n\n\n/*\n * Oklab gamut clipping\n */\n\n/*\n * Ported from the original C/C++ implementation:\n *\n * Copyright (c) 2021 Björn Ottosson\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do\n * so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n// Finds the maximum saturation possible for a given hue that fits in sRGB\n// Saturation here is defined as S = C/L\n// a and b must be normalized so a^2 + b^2 == 1\nfloat compute_max_saturation(float a, float b)\n{\n    // Max saturation will be when one of r, g or b goes below zero.\n\n    // Select different coefficients depending on which component goes below zero first\n    float k0, k1, k2, k3, k4, wl, wm, ws;\n\n    if (-1.88170328f * a - 0.80936493f * b > 1.0)\n    {\n        // Red component\n        k0 = +1.19086277f; k1 = +1.76576728f; k2 = +0.59662641f; k3 = +0.75515197f; k4 = +0.56771245f;\n        wl = +4.0767416621f; wm = -3.3077115913f; ws = +0.2309699292f;\n    }\n    else if (1.81444104f * a - 1.19445276f * b > 1.0)\n    {\n        // Green component\n        k0 = +0.73956515f; k1 = -0.45954404f; k2 = +0.08285427f; k3 = +0.12541070f; k4 = +0.14503204f;\n        wl = -1.2681437731f; wm = +2.6097574011f; ws = -0.3413193965f;\n    }\n    else\n    {\n        // Blue component\n        k0 = +1.35733652f; k1 = -0.00915799f; k2 = -1.15130210f; k3 = -0.50559606f; k4 = +0.00692167f;\n        wl = -0.0041960863f; wm = -0.7034186147f; ws = +1.7076147010f;\n    }\n\n    // Approximate max saturation using a polynomial:\n    float S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;\n\n    // Do one step Halley's method to get closer\n    // this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite\n    // this should be sufficient for most applications, otherwise do two/three steps\n\n    float k_l = +0.3963377774f * a + 0.2158037573f * b;\n    float k_m = -0.1055613458f * a - 0.0638541728f * b;\n    float k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n    {\n        float l_ = 1.f + S * k_l;\n        float m_ = 1.f + S * k_m;\n        float s_ = 1.f + S * k_s;\n\n        float l = l_ * l_ * l_;\n        float m = m_ * m_ * m_;\n        float s = s_ * s_ * s_;\n\n        float l_dS = 3.f * k_l * l_ * l_;\n        float m_dS = 3.f * k_m * m_ * m_;\n        float s_dS = 3.f * k_s * s_ * s_;\n\n        float l_dS2 = 6.f * k_l * k_l * l_;\n        float m_dS2 = 6.f * k_m * k_m * m_;\n        float s_dS2 = 6.f * k_s * k_s * s_;\n\n        float f  = wl * l     + wm * m     + ws * s;\n        float f1 = wl * l_dS  + wm * m_dS  + ws * s_dS;\n        float f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;\n\n        S = S - f * f1 / (f1*f1 - 0.5f * f * f2);\n    }\n\n    return S;\n}\n\n// finds L_cusp and C_cusp for a given hue\n// a and b must be normalized so a^2 + b^2 == 1\nvec2 find_cusp(float a, float b)\n{\n    // First, find the maximum saturation (saturation S = C/L)\n    float S_cusp = compute_max_saturation(a, b);\n\n    // Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:\n    vec3 rgb_at_max = oklabToLinearSrgb(vec3( 1.0, S_cusp * a, S_cusp * b ));\n    float L_cusp = cbrt(1.f / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));\n    float C_cusp = L_cusp * S_cusp;\n\n    return vec2( L_cusp , C_cusp );\n}\n\n// Finds intersection of the line defined by\n// L = L0 * (1 - t) + t * L1;\n// C = t * C1;\n// a and b must be normalized so a^2 + b^2 == 1\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0)\n{\n    // Find the cusp of the gamut triangle\n    vec2 cusp = find_cusp(a, b);\n    float cuspL = cusp.x;\n    float cuspC = cusp.y;\n\n    // Find the intersection for upper and lower half seprately\n    float t;\n    if (((L1 - L0) * cuspC - (cuspL - L0) * C1) <= 0.f)\n    {\n        // Lower half\n\n        t = cuspC * L0 / (C1 * cuspL + cuspC * (L0 - L1));\n    }\n    else\n    {\n        // Upper half\n\n        // First intersect with triangle\n        t = cuspC * (L0 - 1.f) / (C1 * (cuspL - 1.f) + cuspC * (L0 - L1));\n\n        // Then one step Halley's method\n        {\n            float dL = L1 - L0;\n            float dC = C1;\n\n            float k_l = +0.3963377774f * a + 0.2158037573f * b;\n            float k_m = -0.1055613458f * a - 0.0638541728f * b;\n            float k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n            float l_dt = dL + dC * k_l;\n            float m_dt = dL + dC * k_m;\n            float s_dt = dL + dC * k_s;\n\n            // If higher accuracy is required, 2 or 3 iterations of the following block can be used:\n            {\n                float L = L0 * (1.f - t) + t * L1;\n                float C = t * C1;\n\n                float l_ = L + C * k_l;\n                float m_ = L + C * k_m;\n                float s_ = L + C * k_s;\n\n                float l = l_ * l_ * l_;\n                float m = m_ * m_ * m_;\n                float s = s_ * s_ * s_;\n\n                float ldt = 3.0 * l_dt * l_ * l_;\n                float mdt = 3.0 * m_dt * m_ * m_;\n                float sdt = 3.0 * s_dt * s_ * s_;\n\n                float ldt2 = 6.0 * l_dt * l_dt * l_;\n                float mdt2 = 6.0 * m_dt * m_dt * m_;\n                float sdt2 = 6.0 * s_dt * s_dt * s_;\n\n                float r = 4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s - 1.0;\n                float r1 = 4.0767416621f * ldt - 3.3077115913f * mdt + 0.2309699292f * sdt;\n                float r2 = 4.0767416621f * ldt2 - 3.3077115913f * mdt2 + 0.2309699292f * sdt2;\n\n                float u_r = r1 / (r1 * r1 - 0.5f * r * r2);\n                float t_r = -r * u_r;\n\n                float g = -1.2681437731f * l + 2.6097574011f * m - 0.3413193965f * s - 1.0;\n                float g1 = -1.2681437731f * ldt + 2.6097574011f * mdt - 0.3413193965f * sdt;\n                float g2 = -1.2681437731f * ldt2 + 2.6097574011f * mdt2 - 0.3413193965f * sdt2;\n\n                float u_g = g1 / (g1 * g1 - 0.5f * g * g2);\n                float t_g = -g * u_g;\n\n                float b = -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s - 1.0;\n                float b1 = -0.0041960863f * ldt - 0.7034186147f * mdt + 1.7076147010f * sdt;\n                float b2 = -0.0041960863f * ldt2 - 0.7034186147f * mdt2 + 1.7076147010f * sdt2;\n\n                float u_b = b1 / (b1 * b1 - 0.5f * b * b2);\n                float t_b = -b * u_b;\n\n                t_r = u_r >= 0.f ? t_r : FLT_MAX;\n                t_g = u_g >= 0.f ? t_g : FLT_MAX;\n                t_b = u_b >= 0.f ? t_b : FLT_MAX;\n\n                t += min(t_r, min(t_g, t_b));\n            }\n        }\n    }\n\n    return t;\n}\n\nvec3 gamut_clip_preserve_lightness(vec3 rgb)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float L0 = clamp(L, 0.0, 1.0);\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_0_5(vec3 rgb)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float L0 = 0.5;\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_L_cusp(vec3 rgb)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    // The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n    vec2 cusp = find_cusp(a_, b_);\n    float cuspL = cusp.x;\n    float cuspC = cusp.y;\n\n    float L0 = cuspL;\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_0_5(vec3 rgb, float alpha)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float Ld = L - 0.5f;\n    float e1 = 0.5f + abs(Ld) + alpha * C;\n    float L0 = 0.5f*(1.f + sign(Ld)*(e1 - sqrt(e1*e1 - 2.f *abs(Ld))));\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.f - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_L_cusp(vec3 rgb, float alpha)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    // The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n    vec2 cusp = find_cusp(a_, b_);\n    float cuspL = cusp.x;\n    float cuspC = cusp.y;\n\n    float Ld = L - cuspL;\n    float k = 2.f * (Ld > 0.0 ? 1.f - cuspL : cuspL);\n\n    float e1 = 0.5f*k + abs(Ld) + alpha * C/k;\n    float L0 = cuspL + 0.5f * (sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * k * abs(Ld))));\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.f - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\n\n/*\n * ZCAM (JCh values)\n */\n\nconst float B = 1.15;\nconst float G = 0.66;\nconst float C1 = 3424.0 / 4096.0;\nconst float C2 = 2413.0 / 128.0;\nconst float C3 = 2392.0 / 128.0;\nconst float ETA = 2610.0 / 16384.0;\nconst float RHO = 1.7 * 2523.0 / 32.0;\nconst float EPSILON = 3.7035226210190005e-11;\n\nconst float SURROUND_DARK = 0.525;\nconst float SURROUND_DIM = 0.59;\nconst float SURROUND_AVERAGE = 0.69;\n\nstruct ZcamViewingConditions {\n    // Given\n    float F_s;\n    float L_a;\n    float Y_b;\n    vec3 refWhite;\n    float whiteLuminance;\n\n    // Calculated\n    float F_b;\n    float F_l;\n    float refWhiteIz;\n};\n\nfloat pq(float x) {\n    float num = C1 + C2 * pow(x / 10000.0, ETA);\n    float denom = 1.0 + C3 * pow(x / 10000.0, ETA);\n\n    return pow(num / denom, RHO);\n}\n\nfloat pqInv(float x) {\n    float num = C1 - pow(x, 1.0/RHO);\n    float denom = C3*pow(x, 1.0/RHO) - C2;\n\n    return 10000.0 * pow(num / denom, 1.0/ETA);\n}\n\nvec3 xyzToIzazbz(vec3 c) {\n    float xp = B*c.x - (B-1.0)*c.z;\n    float yp = G*c.y - (G-1.0)*c.x;\n\n    float rp = pq( 0.41478972*xp + 0.579999*yp + 0.0146480*c.z);\n    float gp = pq(-0.20151000*xp + 1.120649*yp + 0.0531008*c.z);\n    float bp = pq(-0.01660080*xp + 0.264800*yp + 0.6684799*c.z);\n\n    float az = 3.524000*rp + -4.066708*gp +  0.542708*bp;\n    float bz = 0.199076*rp +  1.096799*gp + -1.295875*bp;\n    float Iz = gp - EPSILON;\n\n    return vec3(Iz, az, bz);\n}\n\nfloat hpToEz(float hp) {\n    return 1.015 + cos(degreesToRadians(89.038 + hp));\n}\n\nfloat izToQz(float Iz, ZcamViewingConditions cond) {\n    return 2700.0 * pow(Iz, (1.6 * cond.F_s) / pow(cond.F_b, 0.12)) *\n            (pow(cond.F_s, 2.2) * pow(cond.F_b, 0.5) * pow(cond.F_l, 0.2));\n}\n\nZcamViewingConditions createZcamViewingConditions(float F_s, float L_a, float Y_b, vec3 refWhite, float whiteLuminance) {\n    float F_b = sqrt(Y_b / refWhite.y);\n    float F_l = 0.171 * cbrt(L_a) * (1.0 - exp(-48.0/9.0 * L_a));\n    float refWhiteIz = xyzToIzazbz(refWhite).x;\n\n    return ZcamViewingConditions(\n        F_s, L_a, Y_b, refWhite, whiteLuminance,\n        F_b, F_l, refWhiteIz\n    );\n}\n\nstruct Zcam {\n    float brightness;\n    float lightness;\n    float colorfulness;\n    float chroma;\n    float hueAngle;\n    /* hue composition is not implemented */\n\n    float saturation;\n    float vividness;\n    float blackness;\n    float whiteness;\n\n    ZcamViewingConditions cond;\n};\n\nZcam xyzToZcam(vec3 c, ZcamViewingConditions cond) {\n    /* Step 2 */\n    // Achromatic response\n    vec3 izazbz = xyzToIzazbz(c);\n    float Iz = izazbz.x;\n    float az = izazbz.y;\n    float bz = izazbz.z;\n    float Iz_w = cond.refWhiteIz;\n\n    /* Step 3 */\n    // Hue angle\n    float hz = radiansToDegrees(atan2(bz, az));\n    float hp = (hz < 0.0) ? hz + 360.0 : hz;\n\n    /* Step 4 */\n    // Eccentricity factor\n    float ez = hpToEz(hp);\n\n    /* Step 5 */\n    // Brightness\n    float Qz = izToQz(Iz, cond);\n    float Qz_w = izToQz(cond.refWhiteIz, cond);\n\n    // Lightness\n    float Jz = 100.0 * (Qz / Qz_w);\n\n    // Colorfulness\n    float Mz = 100.0 * pow(square(az) + square(bz), 0.37) *\n            ((pow(ez, 0.068) * pow(cond.F_l, 0.2)) /\n                    (pow(cond.F_b, 0.1) * pow(Iz_w, 0.78)));\n    \n    // Chroma\n    float Cz = 100.0 * (Mz / Qz_w);\n\n    /* Step 6 */\n    // Saturation\n    float Sz = 100.0 * pow(cond.F_l, 0.6) * sqrt(Mz / Qz);\n\n    // Vividness, blackness, whiteness\n    float Vz = sqrt(square(Jz - 58.0) + 3.4 * square(Cz));\n    float Kz = 100.0 - 0.8 * sqrt(square(Jz) + 8.0 * square(Cz));\n    float Wz = 100.0 - sqrt(square(100.0 - Jz) + square(Cz));\n\n    return Zcam(\n        Qz,\n        Jz,\n        Mz,\n        Cz,\n        hp,\n\n        Sz,\n        Vz,\n        Kz,\n        Wz,\n\n        cond\n    );\n}\n\nvec3 zcamToXyz(vec3 c, ZcamViewingConditions cond) {\n    float Jz = c.x;\n    float Cz = c.y;\n    //float Sz = c.y;\n    float hz = c.z;\n\n    float Iz_w = cond.refWhiteIz;\n    float Qz_w = izToQz(Iz_w, cond);\n\n    /* Step 1 */\n    // Achromatic response\n    float Iz_denom = 2700.0 * pow(cond.F_s, 2.2) * pow(cond.F_b, 0.5) * pow(cond.F_l, 0.2);\n    float Iz_src = (Jz * Qz_w) / (Iz_denom * 100.0);\n    float Iz = pow(Iz_src, pow(cond.F_b, 0.12) / (1.6 * cond.F_s));\n\n    /* Step 2 */\n    // Chroma\n    /* skipped because we take Cz as input */\n    //float Qz = (Jz / 100.0) * Qz_w;\n    //float Cz = (Qz * square(Sz)) / (100.0 * Qz_w * pow(cond.F_l, 1.2));\n\n    /* Step 3 is missing because hue composition is not supported */\n\n    /* Step 4 */\n    // ... and back to colorfulness\n    float Mz = (Cz * Qz_w) / 100.0;\n    float ez = hpToEz(hz);\n    float Cz_p = pow((Mz * pow(Iz_w, 0.78) * pow(cond.F_b, 0.1)) /\n            // Paper specifies pow(1.3514) but this extra precision is necessary for more accurate inversion\n            (100.0 * pow(ez, 0.068) * pow(cond.F_l, 0.2)), 1.0 / 0.37 / 2.0);\n    float az = Cz_p * cos(degreesToRadians(hz));\n    float bz = Cz_p * sin(degreesToRadians(hz));\n\n    /* Step 5 */\n    float I = Iz + EPSILON;\n\n    float r = pqInv(I + 0.2772100865*az +  0.1160946323*bz);\n    float g = pqInv(I);\n    float b = pqInv(I + 0.0425858012*az + -0.7538445799*bz);\n\n    float xp =  1.9242264358*r + -1.0047923126*g +  0.0376514040*b;\n    float yp =  0.3503167621*r +  0.7264811939*g + -0.0653844229*b;\n    float z  = -0.0909828110*r + -0.3127282905*g +  1.5227665613*b;\n\n    float x = (xp + (B - 1.0)*z) / B;\n    float y = (yp + (G - 1.0)*x) / G;\n\n    return vec3(x, y, z);\n}\n\nvec3 zcamJchToLinearSrgb(vec3 jch, ZcamViewingConditions cond) {\n    vec3 xyzAbs = zcamToXyz(jch, cond);\n    vec3 xyzRel = xyzAbs / cond.whiteLuminance;\n    return xyzToLinearSrgb(xyzRel);\n}\n\nconst float ZCAM_CHROMA_EPSILON = 0.0001;\nconst bool CLIP_ZCAM = false;\nvec3 clipZcamJchToLinearSrgb(vec3 jch, ZcamViewingConditions cond) {\n    vec3 initialResult = zcamJchToLinearSrgb(jch, cond);\n    if (linearSrgbInGamut(initialResult)) {\n        return initialResult;\n    }\n\n    float lightness = jch.r;\n    float chroma = jch.g;\n    float hue = jch.b;\n    if (lightness <= ZCAM_CHROMA_EPSILON) {\n        return vec3(0.0);\n    } else if (lightness >= 100.0 - ZCAM_CHROMA_EPSILON) {\n        return vec3(1.0);\n    }\n\n    float lo = 0.0;\n    float hi = chroma;\n\n    vec3 newLinearSrgb = initialResult;\n    while (abs(hi - lo) > ZCAM_CHROMA_EPSILON) {\n        float mid = (lo + hi) / 2.0;\n\n        newLinearSrgb = zcamJchToLinearSrgb(vec3(lightness, mid, hue), cond);\n        if (!linearSrgbInGamut(newLinearSrgb)) {\n            hi = mid;\n        } else {\n            float mid2 = mid + ZCAM_CHROMA_EPSILON;\n\n            vec3 newLinearSrgb2 = zcamJchToLinearSrgb(vec3(lightness, mid2, hue), cond);\n            if (linearSrgbInGamut(newLinearSrgb2)) {\n                lo = mid;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return newLinearSrgb;\n}\nvec3 clipCielchToLinearSrgb(vec3 lch) {\n    vec3 initialResult = xyzToLinearSrgb(cielabToXyz(lchToLab(lch)));\n    if (linearSrgbInGamut(initialResult)) {\n        return initialResult;\n    }\n\n    float lightness = lch.r;\n    float chroma = lch.g;\n    float hue = lch.b;\n    if (lightness <= ZCAM_CHROMA_EPSILON) {\n        return vec3(0.0);\n    } else if (lightness >= 100.0 - ZCAM_CHROMA_EPSILON) {\n        return vec3(1.0);\n    }\n\n    float lo = 0.0;\n    float hi = chroma;\n\n    vec3 newLinearSrgb = initialResult;\n    while (abs(hi - lo) > ZCAM_CHROMA_EPSILON) {\n        float mid = (lo + hi) / 2.0;\n\n        newLinearSrgb = xyzToLinearSrgb(cielabToXyz(lchToLab(vec3(lightness, mid, hue))));\n        if (!linearSrgbInGamut(newLinearSrgb)) {\n            hi = mid;\n        } else {\n            float mid2 = mid + ZCAM_CHROMA_EPSILON;\n\n            vec3 newLinearSrgb2 = xyzToLinearSrgb(cielabToXyz(lchToLab(vec3(lightness, mid2, hue))));\n            if (linearSrgbInGamut(newLinearSrgb2)) {\n                lo = mid;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return newLinearSrgb;\n}\nvec3 clipOklchToLinearSrgb(vec3 lch) {\n    vec3 initialResult = oklabToLinearSrgb(lchToLab(lch));\n    if (linearSrgbInGamut(initialResult)) {\n        return initialResult;\n    }\n\n    float lightness = lch.r;\n    float chroma = lch.g;\n    float hue = lch.b;\n    if (lightness <= ZCAM_CHROMA_EPSILON) {\n        return vec3(0.0);\n    } else if (lightness >= 100.0 - ZCAM_CHROMA_EPSILON) {\n        return vec3(1.0);\n    }\n\n    float lo = 0.0;\n    float hi = chroma;\n\n    vec3 newLinearSrgb = initialResult;\n    while (abs(hi - lo) > ZCAM_CHROMA_EPSILON) {\n        float mid = (lo + hi) / 2.0;\n\n        newLinearSrgb = oklabToLinearSrgb(lchToLab(vec3(lightness, mid, hue)));\n        if (!linearSrgbInGamut(newLinearSrgb)) {\n            hi = mid;\n        } else {\n            float mid2 = mid + ZCAM_CHROMA_EPSILON;\n\n            vec3 newLinearSrgb2 = oklabToLinearSrgb(lchToLab(vec3(lightness, mid2, hue)));\n            if (linearSrgbInGamut(newLinearSrgb2)) {\n                lo = mid;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return newLinearSrgb;\n}\n\n\n/*\n * Theme generation\n */\n\nconst float OKLAB_ACCENT1_CHROMA = 0.1328123146401862;\nconst float OKLAB_LIGHTNESS_MAP[13] = float[](\n    1.0,\n    0.9880873963836093,\n    0.9551400440214246,\n    0.9127904082618294,\n    0.8265622041716898,\n    0.7412252673769428,\n    0.653350946076347,\n    0.5624050605208273,\n    0.48193149058901036,\n    0.39417829080418526,\n    0.3091856317280812,\n    0.22212874192541768,\n    0.0\n);\n\nconst float ZCAM_ACCENT1_CHROMA = 20.54486422; // careful!\nconst float ZCAM_ACCENT1_COLORFULNESS = 36.47983487;\nconst float ZCAM_LIGHTNESS_MAP[13] = float[](\n    100.00000296754273,\n    98.60403974009428,\n    94.72386350388908,\n    89.69628870011267,\n    79.3326296037671,\n    68.938947819272,\n    58.15091644790415,\n    46.991689840263206,\n    37.24709908558773,\n    26.96785892507836,\n    17.67571012446932,\n    9.36696155986009,\n    0.0\n);\n\nconst float CIELAB_LIGHTNESS_MAP[13] = float[](\n    100.0,\n    99.0,\n    95.0,\n    90.0,\n    80.0,\n    70.0,\n    60.0,\n    49.6,\n    40.0,\n    30.0,\n    20.0,\n    10.0,\n    0.0\n);\n\nconst float ZCAM_LINEAR_LIGHTNESS_MAP[13] = float[](\n    100.0,\n    99.0,\n    95.0,\n    90.0,\n    80.0,\n    70.0,\n    60.0,\n    50.0,\n    40.0,\n    30.0,\n    20.0,\n    10.0,\n    0.0\n);\n\nconst int REF_ACCENT1_COLOR_COUNT = 9;\nconst int REF_ACCENT1_COLORS[9] = int[](\n    0xd3e3fd,\n    0xa8c7fa,\n    0x7cacf8,\n    0x4c8df6,\n    0x1b6ef3,\n    0x0b57d0,\n    0x0842a0,\n    0x062e6f,\n    0x041e49\n);\n\nconst float SWATCH_CHROMA_SCALES[5] = float[](\n    1.0, // accent1\n    1.0 / 3.0, // accent2\n    (1.0 / 3.0) * 2.0, // accent3\n    1.0 / 8.0, // neutral1\n    1.0 / 5.0 // neutral2\n);\n\nvec3 calcShadeParams(int swatch, float lightness, float seedChroma, float seedHue, float chromaFactor, float accent1Chroma) {\n    float refChroma = accent1Chroma * SWATCH_CHROMA_SCALES[0];\n    float targetChroma = accent1Chroma * SWATCH_CHROMA_SCALES[swatch];\n    float scaleC = (refChroma == 0.0) ? 0.0 : (clamp(seedChroma, 0.0, refChroma) / refChroma);\n    float chroma = targetChroma * scaleC * chromaFactor;\n    float hue = (swatch == 2) ? seedHue + 60.0 : seedHue;\n\n    return vec3(lightness, chroma, hue);\n}\n\nvec3 generateShadeOklab(int swatch, int shade, float seedChroma, float seedHue, float chromaFactor) {\n    float cielabL = CIELAB_LIGHTNESS_MAP[shade];\n    vec3 cielabXyz = cielabToXyz(vec3(cielabL, 0.0, 0.0));\n    float lightness = xyzToOklab(cielabXyz).x;\n\n    vec3 lch = calcShadeParams(swatch, lightness, seedChroma, seedHue, chromaFactor, OKLAB_ACCENT1_CHROMA);\n    vec3 oklab = lchToLab(lch);\n    return oklabToLinearSrgb(oklab);\n}\n\nZcamViewingConditions getZcamCond() {\n    float whiteLuminance = SRGB_WHITE_LUMINANCE;\n\n    // Dynamic luminance for testing\n    //whiteLuminance = pow(10.0, (iMouse.x / iResolution.x) * (log(SRGB_WHITE_LUMINANCE_DYN_MAX) / log(10.0)));\n\n    float dynVal1 = (iMouse.x / iResolution.x) * whiteLuminance;\n    float dynVal2 = (iMouse.y / iResolution.y) * whiteLuminance;\n\n    ZcamViewingConditions cond = createZcamViewingConditions(\n        /* surround */ SURROUND_AVERAGE,\n        /* L_a */ 0.4 * whiteLuminance,\n        /* Y_b */ cielabToXyz(vec3(50.0, 0.0, 0.0)).y * whiteLuminance,\n        /* ref white */ D65 * whiteLuminance,\n        /* white luminance */ whiteLuminance\n    );\n\n    return cond;\n}\n\nvec3 generateShadeZcam(int swatch, int shade, float seedChroma, float seedHue, float chromaFactor) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    float cielabL = CIELAB_LIGHTNESS_MAP[shade];\n    vec3 cielabXyz = cielabToXyz(vec3(cielabL, 0.0, 0.0)) * cond.whiteLuminance;\n    float lightness = xyzToZcam(cielabXyz, cond).lightness;\n\n    // Calculate accent1 chroma given the viewing conditions\n    float chromaAcc = 0.0;\n    for (int i = 0; i < REF_ACCENT1_COLOR_COUNT; i++) {\n        vec3 srgb = rgb8ToFloat(REF_ACCENT1_COLORS[i]);\n        vec3 xyzAbs = linearSrgbToXyz(srgbTransferInv(srgb)) * cond.whiteLuminance;\n        Zcam zcam = xyzToZcam(xyzAbs, cond);\n        chromaAcc += zcam.chroma;\n    }\n    float avgChroma = 1.2 * chromaAcc / float(REF_ACCENT1_COLOR_COUNT);\n\n    // For constant values\n    //lightness = ZCAM_LIGHTNESS_MAP[shade];\n    //avgChroma = ZCAM_ACCENT1_CHROMA;\n    // For linear shade lightness in ZCAM\n    //lightness = ZCAM_LINEAR_LIGHTNESS_MAP[shade];\n\n    vec3 jch = calcShadeParams(swatch, lightness, seedChroma, seedHue, chromaFactor, avgChroma);\n\n    if (CLIP_ZCAM) {\n        return clipZcamJchToLinearSrgb(jch, cond);\n    } else {\n        return zcamJchToLinearSrgb(jch, cond);\n    }\n}\n\nvec3 getThemeColor(vec2 uv, float hue) {\n    int shadeIdx = int(uv.x * 13.0);\n    int swatchIdx = int((1.0 - uv.y) * 5.0);\n    float seedChroma = 1000000.0;\n\n    if (shadeIdx == 0) {\n        return vec3(1.0);\n    } else if (shadeIdx == 12) {\n        return vec3(0.0);\n    }\n\n    if (iMouse.z > 0.0) {\n        return gamut_clip_preserve_lightness(generateShadeOklab(swatchIdx, shadeIdx, seedChroma, hue, 1.0));\n    } else {\n        return generateShadeZcam(swatchIdx, shadeIdx, seedChroma, hue, 1.0);\n    }\n}\n\n\n/*\n * Color space interfaces\n */\n\nvec3 getColorOklab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawLightness, rawChroma, hue);\n    vec3 oklab = lchToLab(lch);\n    return oklabToLinearSrgb(oklab);\n}\n\nvec3 getColorCielab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawLightness * 100.0, rawChroma * 170.0, hue);\n    vec3 cielab = lchToLab(lch);\n    return xyzToLinearSrgb(cielabToXyz(cielab));\n}\n\nvec3 getColorZcam(float rawLightness, float rawChroma, float hue) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    vec3 jch = vec3(rawLightness * 100.0, rawChroma * 170.0, hue);\n\n    if (CLIP_ZCAM) {\n        return clipZcamJchToLinearSrgb(jch, cond);\n    } else {\n        return zcamJchToLinearSrgb(jch, cond);\n    }\n}\n\n\nvec3 getLightnessOklab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawChroma, 0.0, hue);\n    vec3 oklab = lchToLab(lch);\n    return oklabToLinearSrgb(oklab);\n}\n\nvec3 getLightnessOklrab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawChroma, 0.0, hue);\n    vec3 oklrab = lchToLab(lch);\n    return oklrabToLinearSrgb(oklrab);\n}\n\nvec3 getLightnessCielab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawChroma * 100.0, 0.0, hue);\n    vec3 cielab = lchToLab(lch);\n    return xyzToLinearSrgb(cielabToXyz(cielab));\n}\n\nvec3 getLightnessZcam(float rawLightness, float rawChroma, float hue) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    vec3 zcam = vec3(rawChroma * 100.0, 0.0, hue);\n\n    vec3 xyzAbs = zcamToXyz(zcam, cond);\n    vec3 xyzRel = xyzAbs / cond.whiteLuminance;\n    return xyzToLinearSrgb(xyzRel);\n}\n\n\n/*\n * Blending\n */\n\nvec3 blendZcam(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    Zcam lhs = xyzToZcam(linearSrgbToXyz(srgbTransferInv(lhsRgb)) * cond.whiteLuminance, cond);\n    Zcam rhs = xyzToZcam(linearSrgbToXyz(srgbTransferInv(rhsRgb)) * cond.whiteLuminance, cond);\n\n    vec3 lhsJch = vec3(lhs.lightness, lhs.chroma, lhs.hueAngle);\n    vec3 rhsJch = vec3(rhs.lightness, rhs.chroma, lhs.hueAngle);\n    return clipZcamJchToLinearSrgb(mix(lhsJch, rhsJch, uv.x), cond);\n}\n\nvec3 blendOklch(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    vec3 lhs = labToLch(linearSrgbToOklab(srgbTransferInv(lhsRgb)));\n    vec3 rhs = labToLch(linearSrgbToOklab(srgbTransferInv(rhsRgb)));\n    rhs.z = lhs.z;\n    return clipOklchToLinearSrgb(mix(lhs, rhs, uv.x));\n}\n\nvec3 blendOklab(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    vec3 lhs = linearSrgbToOklab(srgbTransferInv(lhsRgb));\n    vec3 rhs = linearSrgbToOklab(srgbTransferInv(rhsRgb));\n    return oklabToLinearSrgb(mix(lhs, rhs, uv.x));\n}\n\nvec3 blendOklrab(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    vec3 lhs = linearSrgbToOklrab(srgbTransferInv(lhsRgb));\n    vec3 rhs = linearSrgbToOklrab(srgbTransferInv(rhsRgb));\n    return oklrabToLinearSrgb(mix(lhs, rhs, uv.x));\n}\n\nvec3 blendLinearSrgb(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    vec3 lhs = srgbTransferInv(lhsRgb);\n    vec3 rhs = srgbTransferInv(rhsRgb);\n\n    return srgbTransfer(mix(lhs, rhs, uv.x));\n}\n\nvec3 blendSrgb(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    return mix(lhsRgb, rhsRgb, uv.x);\n}\n\n\n/*\n * Chroma/hue sweep\n */\n\nvec3 chromaHueSweepZcam(vec2 uv) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    float lightness = uv.y * 100.0;\n    float chroma = 1000.0;\n    float hue = uv.x * 360.0;\n\n    return clipZcamJchToLinearSrgb(vec3(lightness, chroma, hue), cond);\n}\n\nvec3 chromaHueSweepOklab(vec2 uv) {\n    float lightness = uv.y;\n    float chroma = 1000.0;\n    float hue = uv.x * 360.0;\n\n    return clipOklchToLinearSrgb(vec3(lightness, chroma, hue));\n}\n\nvec3 chromaHueSweepCielab(vec2 uv) {\n    float lightness = uv.y * 100.0;\n    float chroma = 1000.0;\n    float hue = uv.x * 360.0;\n\n    return clipCielchToLinearSrgb(vec3(lightness, chroma, hue));\n}\n\n\n\n/*\n * Main\n */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy; // NDC (0-1)\n\n    float rawLightness = uv.y;\n    float rawChroma = uv.x;\n    float hue = mod(iTime * HUE_RATE, 360.0); // degrees\n    //hue = 286.66117416556847;\n    vec3 camOut;\n\n    // Rainbow\n    //rawLightness = 0.7502;\n    //rawChroma = 0.138;\n    //hue = uv.x * 360.0;\n\n    // Gamut/cusp animation\n    /*if (iMouse.z > 0.0) {\n        camOut = getColorOklab(rawLightness, rawChroma, hue);\n        //camOut = gamut_clip_preserve_lightness(camOut);\n    } else {\n        camOut = getColorZcam(rawLightness, rawChroma, hue);\n    }*/\n\n    // Lightness ramp\n    /*if (iMouse.z > 0.0) {\n        camOut = getLightnessOklab(rawLightness, rawChroma, hue);\n    } else {\n        camOut = getLightnessZcam(rawLightness, rawChroma, hue);\n    }*/\n\n    // Theme generation\n    //camOut = getThemeColor(uv, hue);\n\n    // Chroma contrast\n    /*int testSwatch = 3; // neutral1\n    int testShade = 11; // 900\n    testShade = 4; // 200\n    testSwatch = 0; // accent1\n    if (uv.x > 0.5) {\n        ZcamViewingConditions cond = getZcamCond();\n        vec3 xyzAbs = linearSrgbToXyz(srgbTransferInv(rgb8ToFloat(0x533b79))) * cond.whiteLuminance;\n        Zcam seed = xyzToZcam(xyzAbs, cond);\n        camOut = generateShadeZcam(testSwatch, testShade, seed.chroma, seed.hueAngle, 1.0);\n    } else {\n        testSwatch = 3;\n        testShade = 11;\n        camOut = generateShadeZcam(testSwatch, testShade, 0.0, 0.0, 1.0);\n    }*/\n\n    // Blending\n    /*if (uv.y >= 0.5) {\n        camOut = blendZcam(uv, vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    } else {\n        camOut = blendSrgb(uv, vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    }*/\n\n    // Blue demo - ZCAM\n    ZcamViewingConditions cond = getZcamCond();\n    vec3 xyzAbs = linearSrgbToXyz(vec3(0.0, 0.0, 1.0)) * cond.whiteLuminance;\n    Zcam blue = xyzToZcam(xyzAbs, cond);\n    //blue.hueAngle = hue;\n    //blue.hueAngle = 33.44; // red\n    //blue.hueAngle = 89.29; // yellow\n    //blue.hueAngle = 146.30; // green\n    //blue.hueAngle = 238.36; // blue\n    if (uv.y >= 0.0) {\n        camOut = clipZcamJchToLinearSrgb(vec3(uv.x * 100.0, blue.chroma, blue.hueAngle), cond);\n    }\n    if (uv.y >= 1.0/3.0) {\n        camOut = clipZcamJchToLinearSrgb(vec3(blue.lightness, uv.x * blue.chroma, blue.hueAngle), cond);\n    }\n    if (uv.y >= 2.0/3.0) {\n        float hue = uv.x * 360.0;\n        float chroma = (abs(hue - blue.hueAngle) < 0.5) ? blue.chroma : 10.0;\n        camOut = clipZcamJchToLinearSrgb(vec3(blue.lightness, chroma, hue), cond);\n    }\n    if (uv.y >= 4.0/6.0 && uv.y <= 5.0/6.0) {\n        float hue = uv.x * 360.0;\n        camOut = clipZcamJchToLinearSrgb(vec3(blue.lightness, 500.0, hue), cond);\n    }\n\n    // Blue demo - CIELAB\n    /*vec3 blue = labToLch(xyzToCielab(linearSrgbToXyz(vec3(0.0, 0.0, 1.0))));\n    if (uv.y >= 0.0) {\n        camOut = clipCielchToLinearSrgb(vec3(uv.x * 100.0, blue.y, blue.z));\n    }\n    if (uv.y >= 1.0/3.0) {\n        camOut = clipCielchToLinearSrgb(vec3(blue.x, uv.x * blue.y, blue.z));\n    }\n    if (uv.y >= 2.0/3.0) {\n        float hue = uv.x * 360.0;\n        float chroma = (abs(hue - blue.z) < 0.5) ? blue.y : 21.0;\n        camOut = clipCielchToLinearSrgb(vec3(blue.x, chroma, hue));\n    }\n    if (uv.y >= 4.0/6.0 && uv.y <= 5.0/6.0) {\n        float hue = uv.x * 360.0;\n        camOut = clipCielchToLinearSrgb(vec3(blue.x, 500.0, hue));\n    }*/\n\n    // Blue demo - Oklab\n    if (iMouse.z > 0.0) {\n        vec3 blue = labToLch(linearSrgbToOklab(vec3(0.0, 0.0, 1.0)));\n        //blue.z = hue;\n        if (uv.y >= 0.0) {\n            camOut = clipOklchToLinearSrgb(vec3(uv.x, blue.y, blue.z));\n        }\n        if (uv.y >= 1.0/3.0) {\n            camOut = clipOklchToLinearSrgb(vec3(blue.x, uv.x * blue.y, blue.z));\n        }\n        if (uv.y >= 2.0/3.0) {\n            float hue = uv.x * 360.0;\n            float chroma = (abs(hue - blue.z) < 0.5) ? blue.y : 0.07;\n            camOut = clipOklchToLinearSrgb(vec3(blue.x, chroma, hue));\n            //camOut = oklabToLinearSrgb(lchToLab(vec3(blue.x, chroma, hue)));\n        }\n        if (uv.y >= 4.0/6.0 && uv.y <= 5.0/6.0) {\n            float hue = uv.x * 360.0;\n            camOut = clipOklchToLinearSrgb(vec3(blue.x, 500.0, hue));\n        }\n    }\n\n    // Hue ring - ZCAM\n    /*vec2 center = 0.5 * iResolution.xy;\n    vec2 cDistance = fragCoord - center;\n    hue = radiansToDegrees(atan2(cDistance.y, cDistance.x));\n    ZcamViewingConditions cond = getZcamCond();\n    vec3 xyzAbs = linearSrgbToXyz(vec3(0.0, 0.0, 1.0)) * cond.whiteLuminance;\n    Zcam blue = xyzToZcam(xyzAbs, cond);\n    blue.hueAngle = hue;\n    blue.lightness = 73.0;\n    //blue.lightness = (cos(iTime / 2.0) + 1.0) * 50.0;\n    float chroma = 12.0;\n    float rDistance = distance(center, fragCoord);\n    if (rDistance <= 400.0 && rDistance >= 250.0) {\n        camOut = clipZcamJchToLinearSrgb(vec3(blue.lightness, chroma, hue), cond);\n        //camOut = zcamJchToLinearSrgb(vec3(blue.lightness, chroma, hue), cond);\n    } else {\n        camOut = vec3(1.0);\n        //camOut = zcamJchToLinearSrgb(vec3(blue.lightness, 0.0, 0.0), cond);\n    }*/\n\n    // Chroma/hue sweep\n    /*if (iMouse.z > 0.0) {\n        camOut = chromaHueSweepOklab(uv);\n    } else {\n        camOut = chromaHueSweepZcam(uv);\n    }*/\n\n    // Blending red with blue\n    /*if (uv.y >= 0.5) {\n        camOut = blendOklab(uv, vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n    } else {\n        camOut = blendOklrab(uv, vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n    }*/\n\n    // Oklab gamut clipping\n    //camOut = gamut_clip_preserve_lightness(camOut);\n    //camOut = gamut_clip_project_to_0_5(camOut);\n    //camOut = gamut_clip_project_to_L_cusp(camOut);\n    //camOut = gamut_clip_adaptive_L0_0_5(camOut, 0.05);\n    //camOut = gamut_clip_adaptive_L0_L_cusp(camOut, 0.05);\n\n    // Simple RGB clipping (also necessary after gamut clipping)\n    camOut = clamp(camOut, 0.0, 1.0);\n\n    if (linearSrgbInGamut(camOut)) {\n        vec3 dither = texture(iChannel0, uv * (iResolution.xy / 64.0)).rgb * 2.0 - 1.0;\n        dither = sign(dither) * (1.0 - sqrt(1.0 - abs(dither))) / 64.0;\n        fragColor = vec4(srgbTransfer(camOut) + dither, 1.0);\n    } else {\n\t    vec2 fontSize = vec2(16.0, 30.0);\n        float digit = PrintValue((fragCoord - vec2(iResolution.x - 80.0, 10.0)) / fontSize, hue, 3.0, 0.0);\n        fragColor = vec4(vec3(0.5) + digit, 1.0);\n    }\n\n    // Print dynamic sRGB white luminance\n    /*\n    float whiteL = pow(10.0, (iMouse.x / iResolution.x) * (log(SRGB_WHITE_LUMINANCE_DYN_MAX) / log(10.0)));\n    vec2 fontSize = vec2(16.0, 30.0);\n    float digit2 = PrintValue((fragCoord - vec2(iResolution.x - 80.0, 10.0)) / fontSize, whiteL, 3.0, 0.0);\n    if (digit2 > 0.001) {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n    */\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}