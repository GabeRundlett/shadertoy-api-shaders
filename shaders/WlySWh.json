{
    "Shader": {
        "info": {
            "date": "1582579991",
            "description": "Simple volume scattering, originally just a test but I decided to animate it.",
            "flags": 32,
            "hasliked": 0,
            "id": "WlySWh",
            "likes": 87,
            "name": "ghost fractal",
            "published": 3,
            "tags": [
                "fractal",
                "volume",
                "cloud",
                "volumetric",
                "fog",
                "scattering",
                "atmosphere",
                "atmospheric"
            ],
            "usePreview": 1,
            "username": "loicvdb",
            "viewed": 2532
        },
        "renderpass": [
            {
                "code": "#define Log2BlurRadius 1.5\n#define NoiseStrength .4\n\nvec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    fragColor = texture(iChannel0, fragCoord/iResolution.xy, Log2BlurRadius);\n    \n    // yes the noise is added afterwards\n    float random = texture(iChannel1, (fragCoord+vec2(iFrame*50))/iChannelResolution[1].xy).x;\n    float noise = exp((random*.5-.5)*NoiseStrength);\n    fragColor = vec4(ACESFilm(fragColor.rgb*noise), 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define Pi 3.14159265359\n\n//set to 1 for a higher quality version\n#define HD 0\n\n#if HD\n    #define FogSteps 128\n    #define ShadowSteps 8\n#else\n    #define FogSteps 64\n    #define ShadowSteps 4\n#endif\n\n#define FogRange 5.\n#define ShadowRange 2.\n\n#define ShadowSampleBias 2.\n#define FogSampleBias 2.\n\n#define MaxIterations 50\n\n#define Anisotropy .4\n\nvec3 VolumeColor;\nvec3 CamPos = vec3(0., 0., -2.2);\nvec3 CamRot = vec3(-.2, 0., 0.);\nfloat CamFocalLength = .7;\nvec3 LightRot = vec3(1., 0., 0.);\nvec3 LightCol = vec3(5.);\n\nmat3 rotationMatrix(vec3 rotEuler){\n    float c = cos(rotEuler.x), s = sin(rotEuler.x);\n    mat3 rx = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    c = cos(rotEuler.y), s = sin(rotEuler.y);\n    mat3 ry = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    c = cos(rotEuler.z), s = sin(rotEuler.z);\n    mat3 rz = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    return rz * rx * ry;\n}\n\nfloat henyeyGreenstein(vec3 dirI, vec3 dirO){\n \treturn Pi/4.*(1.-Anisotropy*Anisotropy) / pow(1.+Anisotropy*(Anisotropy-2.*dot(dirI, dirO)), 1.5);\n}\n\nint julia(vec2 z, vec2 c){\n    for(int i = 0; i < 12; i++){\n        z = vec2(z.x*z.x - z.y*z.y, 2.*z.x*z.y) + c;\n        if(z.x*z.x+z.y*z.y > 4.) return i;\n    }\n    return MaxIterations;\n}\n\nfloat density(vec3 pos){\n    float angle = iTime*.3;\n    vec2 c = vec2(pos.x*cos(angle)+pos.y*sin(angle),\n             \t  pos.y*cos(angle)-pos.x*sin(angle));\n    return float(julia(pos.xz, c))*.2+.1;\n}\n\nvec3 directLight(vec3 pos, vec3 dir, float headStart){\n    vec3 lightDir = vec3(0., 0., 1.) * rotationMatrix(LightRot);\n    vec3 pos0 = pos, oldPos, volAbs = vec3(1.);\n    float stepDist;\n    for(int i = 0; i < ShadowSteps; i++){\n        oldPos = pos;\n        pos = pos0 - lightDir * pow((float(i)+headStart) / float(ShadowSteps), ShadowSampleBias) * ShadowRange;\n        volAbs *= vec3(exp(-density(pos)*length(pos-oldPos)*VolumeColor));\n    }\n    return LightCol * volAbs * henyeyGreenstein(-lightDir, dir);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    vec2 uv = (fragCoord-iResolution.xy/2.0) / iResolution.y;\n    \n    VolumeColor = vec3(cos(iTime*.5), sin(iTime*.4), sin(iTime*.3))*.35+.5;\n    CamRot.y += iTime*.3;\n    LightRot.y -= iTime*.25;\n    \n    CamPos *= rotationMatrix(CamRot);\n    vec3 dir = normalize(vec3(uv, CamFocalLength)) * rotationMatrix(CamRot);\n    \n    float headStartCam = texture(iChannel0, (fragCoord+vec2(iFrame*50))/iChannelResolution[0].xy).a;\n    float headStartShadow = texture(iChannel0, (fragCoord+vec2(5+iFrame*50))/iChannelResolution[0].xy).a;\n    \n    vec3 volCol = vec3(0.), volAbs = vec3(1.), pos = CamPos, oldPos, stepAbs, stepCol;\n    for(int i = 0; i < FogSteps; i++){\n        oldPos = pos;\n        pos = CamPos + dir * pow((float(i)+headStartCam) / float(FogSteps), FogSampleBias) * FogRange;\n        stepAbs = exp(-density(pos)*length(pos-oldPos)*VolumeColor);\n        stepCol = vec3(1.)-stepAbs;\n        volCol += stepCol*volAbs*directLight(pos, dir, headStartShadow);\n        volAbs *= stepAbs;\n    }\n    fragColor = vec4(volCol, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}