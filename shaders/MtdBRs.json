{
    "Shader": {
        "info": {
            "date": "1540754154",
            "description": "fork of \nhttps://www.shadertoy.com/view/llj3Wy\nless globals\nless repetition\nuses value noise, not noise texture\ntinted in silly colors",
            "flags": 0,
            "hasliked": 0,
            "id": "MtdBRs",
            "likes": 8,
            "name": " Nitrostasis b",
            "published": 3,
            "tags": [
                "volume",
                "clouds"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1046
        },
        "renderpass": [
            {
                "code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^This means do anything you want with this code. Because we are programmers, not lawyers.\n-Otavio Good\n/**/\n\n//i like how hacky this is, the gradient is distorted, the root solving of it is coarse\n//that gets hidden in noisy camera screenspace-jitter\n//distance for is a fade to bright blue, estimating atmosheric scattering.\n\n//float localTime = 0.0;\n\n#define pi acos(-1.)\n#define sat(a) clamp(a,0.,1.)\n\nconst vec2 zeroOne = vec2(0,1);\n\nfloat smin(float a, float b, float k// polynomial smooth min (k = 0.1);\n){float h=sat( 0.5+0.5*(b-a)/k)\n ;return mix(b,a,h)-k*h*(1.-h);}\nfloat smax(float a, float b, float k){return -smin(-a,-b,k);}\n\nvec3 RotateX(vec3 v, float a\n){float c = cos(a),s=sin(a)\n ;return vec3(v.x, c * v.y + s * v.z, -s * v.y + c * v.z);}\n\n\n// noise functions\nfloat hash1(vec2 u){return fract(sin(u.x + u.y * 37.0)*104003.9);}\nfloat hash1(vec3 u){return fract(sin(u.x + u.y * 37.0 + u.z * 521.0)*110003.9);}\nfloat hash1(vec4 u){return fract(sin(u.x + u.y * 37.0 + u.z * 521.0-u.w)*110003.9);}\n//this hash3 is very lazy/inefficient\nvec3 hash3(vec2 u){return vec3(hash1(u)*.91, hash1(u+37.), hash1(u+47.))*.01;}\n\n//written this way to transform into a define, but not now.\n//want ot use the same define to multitap for a ValueNoise than for a gradient surface normal \n//almost (same function), differs in interpolant-scaling\n\nvoid diff2(vec2 u,vec2 e,inout vec4 a\n){a=vec4(hash1(u+e.xx),hash1(u+e.yx),hash1(u+e.xy),hash1(u+e.yy));}\n//diff3 can not include diff2 and diff2 can not include diff3, because their hash1() functions are VERY different folds\nvoid diff3(vec3 u,vec2 e,inout vec4 a,inout vec4 b\n){a=vec4(hash1(u+e.xxx),hash1(u+e.yxx),hash1(u+e.xyx),hash1(u+e.yyx))\n ;b=vec4(hash1(u+e.xxy),hash1(u+e.yxy),hash1(u+e.xyy),hash1(u+e.yyy));}\n//but maybe hilbert-space gam simplify all this\nvoid diff4(vec4 u,vec2 e,inout vec4 a,inout vec4 b,inout vec4 c,inout vec4 d){\n ;a=vec4(hash1(u+e.xxxx),hash1(u+e.yxxx),hash1(u+e.xyxx),hash1(u+e.yyxx))\n ;b=vec4(hash1(u+e.xxyx),hash1(u+e.yxyx),hash1(u+e.xyyx),hash1(u+e.yyyx)) \n ;c=vec4(hash1(u+e.xxxy),hash1(u+e.yxxy),hash1(u+e.xyxy),hash1(u+e.yyxy))\n ;d=vec4(hash1(u+e.xxyy),hash1(u+e.yxyy),hash1(u+e.xyyy),hash1(u+e.yyyy));}\n\n\nfloat mx(float a        ,vec2 b                     ){return mix(b.x,b.y,a)                              ;}//1linear interpolate\nfloat mx2(vec2 u        ,vec4 a                     ){return mix(mx(u.x,a.xy      ),mx(u.x,a.zw      ),u.y);}//2linear interpolate\nfloat mx3(vec3 u        ,vec4 a,vec4 b              ){return mix(mx2(u.xy ,a      ),mx2(u.xy ,b      ),u.z);}//3linear interpolate\nfloat mx4(vec4 u        ,vec4 a,vec4 b,vec4 c       ){return mix(mx3(u.xyz,a,b    ),mx3(u.xyz,a,b    ),u.w);}//4Linear interpolate\nfloat mx5(vec4 u,float v,vec4 a,vec4 b,vec4 c,vec4 d){return mix(mx4(u    ,a,b,c  ),mx4(u    ,a,b,c  ),v  );}//5Linear interpolate\nfloat mx6(vec4 u,vec2  v,vec4 a,vec4 b,vec4 c,vec4 d){return mix(mx5(u,v.x,a,b,c,d),mx5(u,v.x,a,b,c,d),v.y);}//5Linear interpolate\n//a value noise in 4d needs mx6(), due to the permutations of diff4()\n//using mx5() or mx4() instead of mx6() will neglect the permutations of [d]\n\n#define h3core(u) (u)*(u)*(3.-2.*(u))\n\nfloat noise1v(vec2 u//value noise\n){vec4 a=vec4(0)\n ;diff2(floor(u),vec2(0,1),a)\n ;return mx2(h3core(fract(u)),a);}\n\nfloat noise1v(vec3 u\n){vec4 a=vec4(0),b=vec4(0)\n ;diff3(floor(u),vec2(0,1),a,b)\n ;return mx3(h3core(fract(u)),a,b);}\n\nfloat noise1v(vec4 u//this is a bitweird, a 4d valuenoise has 4x4 permutations in diff4()\n              //and to linearily interpolate over these, you need 6, and not 4 sliders, where fract(u) only provides 4.\n){vec4 a=vec4(0),b=vec4(0),c=vec4(0),d=vec4(0)\n ;diff4(floor(u),vec2(0,1),a,b,c,d)\n ;return mx5(h3core(fract(u)),1.,a,b,c,d);}\n\n/*\n//IQ's style of fast texture LUT noise\nfloat noise1t(vec3 u\n){vec3 fl=floor(u)\n ;u=fract(u)\n ;u=u*u*(3.-2.*u)\n ;vec2 v=(fl.xy + vec2(37.0, 17.0) * fl.z) + u.xy+.5\n ;v=textureLod(iChannel0,v*.00390625,.0).xy\n ;return mix(v.y, v.x,u.z)\n ;}\n*/\n\nvec2 minx(vec2 a,vec2 b){return mix(b,a,step(a.x,b.x));}\n\n#define usedNoise1 noise1v\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(in vec3 p,vec3 camLookat\n){// first distort the y with some noise so it doesn't look repetitive.\n ;//p.xyz = RotateY(p, length(p.xz) + iTime)\n ;//p.y += 0.1\n ;//p.xyz = RotateZ(p, length(p.z) + iTime*.2)\n ;p.y += usedNoise1(p*0.5)*0.5\n ;// multiple frequencies of noise, with time added for animation\n ;float n=0.\n +usedNoise1(p*  2.+iTime*0.6)\n +usedNoise1(p*  4.+iTime*0.7)*0.5\n +usedNoise1(p*  8.)*0.25\n +usedNoise1(p* 16.)*0.125\n +usedNoise1(p* 32.)*0.0625\n +usedNoise1(p* 64.)*0.0625*0.5\n +usedNoise1(p*128.)*0.0625*0.25\n ;// subtract off distance for cloud thickness\n ;float dist = n*0.25 - (0.275)// - abs(p.y*0.02)/* - iTime*0.01*/)\n ;//dist = smax(dist, -(length(p-camPos) - 0.3), 0.1);\t// nice near fade\n ;// smooth blend subtract repeated layers\n ;dist = smax(dist, -(abs(fract(p.y*4.0)-0.5) - 0.15), 0.4)\n ;vec2 distMat = vec2(dist,0)\n ;// sun in the distance\n ;distMat = minx(distMat, vec2(length(p-camLookat - vec3(0.0, 0.5, -1.0)) - 0.6, 6.0))\n ;return distMat;}\n\n//these parameters can be soiimpler, i just made it one big void function\nvoid march(inout vec3 pos,inout vec3 camPos,inout vec3 camLookat,inout vec3 rayVec,inout float t,float maxDepth,inout vec2 distAndMat,inout float marchCount\n){for (int i = 0; i < 150; i++\n ){pos = camPos + rayVec * t\n  ;distAndMat = DistanceToObject(pos,camLookat)\n  ;if ((t > maxDepth) || (abs(distAndMat.x) < 0.0025)) break\n  ;t += distAndMat.x * 0.7\n  ;//marchCount+= (10.0-distAndMat.x)*(10.0-distAndMat.x)*1.2;//distance(lastPos, pos)\n  ;marchCount+= 1.0/distAndMat.x\n ;}}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord\n){\n ;float localTime=iTime\n ;vec2 u=fragCoord.xy/iResolution.xy*2.-1.\n ;float zoom = 1.7\n ;u/= zoom\n ;vec3 camUp=vec3(0,1,0)\n ;vec3 camLookat=vec3(0)\n ;float mx=(iMouse.x/iResolution.x+0.375)*pi*2.0-0.7 + localTime*3.1415 * 0.0625*0.666*0.0\n ;float my=-iMouse.y*0.0/iResolution.y*10.0 - sin(localTime * 0.31)*0.5*0.0;//*PI/2.01\n ;vec3 camPos = vec3(0.0), camFacing\n ;camPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(3.2)\n ;camPos.z -= iTime * 0.5\n ;camLookat.z -= iTime * 0.5\n ;camPos += hash3(u)//optionally jitter camPos, to hide coarse rootSolving in noise\n ;vec3 camVec=normalize(camLookat - camPos)\n ;vec3 sideNorm=normalize(cross(camUp, camVec))\n ;vec3 upNorm=cross(camVec, sideNorm)\n ;vec3 worldFacing=(camPos + camVec)\n ;vec3 worldPix = worldFacing + u.x * sideNorm * (iResolution.x/iResolution.y) + u.y * upNorm\n ;vec3 rayVec = normalize(worldPix - camPos)\n ;//animate\n ;vec2 distAndMat=vec2(.5,0)\n ;const float nearClip =.02\n ;float t=nearClip\n ;float maxDepth = 10.\n ;vec3 pos = vec3(0)\n ;float marchCount = 0.0;\n ;march(pos,camPos,camLookat,rayVec,t,maxDepth,distAndMat, marchCount)\n ;//texturing:\n ;vec3 c=vec3(0)\n ;if(abs(distAndMat.x) < 0.0025\n ){vec3 e=vec3(0)\n  ;//e=vec3(.2, .26,.21)*.75 //optional minimulm tone (silly white ballance?)\n  ;if (distAndMat.y == 6.0) e = vec3(.5,.2,.1)*10. // sun material\n  ;c=e\n  ;// visualize length of gradient of distance field to check distance field correctness\n  ;//c = vec3(0.5) * (length(normalU) / smallVec.x)\n  ;//c = normal * 0.5 + 0.5\n ;}\n ;c+=marchCount*(1.5-vec3(4.2,1.,.41))*.0001//base red tint (semi direct light)\n ;c = mix(1.5-(vec3(.91,.81, 0.99))*1.75, c, exp(-t*0.15))  // fog fade to bright blue\n ;if(t<=nearClip) c=(1.5-vec3(1.9,1.1,.9))*.25//*usedNoise1(vec3(iTime*8.0))//optional near plane is nicer than blackness\n ;c*=pow(sat(1.-length(u/2.5)), 2.)//gamma\n ;c*=1.2\n ;c*=0.85\n ;c=sat(c)\n ;c=sqrt(c)//sqrt after sat (order matters)\n ;fragColor = vec4(c,1)\n ;}\n\n\n/*\nvec3 RotateY(vec3 v, float rad){\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);}\nvec3 RotateZ(vec3 v, float rad){\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}*/\n\n/*\nvec2 noise2t(in vec3 x\n){vec3 fl = floor(x)\n ;vec3 fr = fract(x)\n ;fr = fr * fr * (3.0 - 2.0 * fr)\n ;vec2 uv = (fl.xy + vec2(37.0, 17.0) * fl.z) + fr.xy\n ;vec4 rgba = textureLod(iChannel0, (uv + 0.5) * 0.00390625, 0.0 ).xyzw\n ;return mix(rgba.yw, rgba.xz, fr.z);}\n*/\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}