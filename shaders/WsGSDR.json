{
    "Shader": {
        "info": {
            "date": "1573997555",
            "description": "Using one of the cube map faces to store 2D information and create a Turing texture.",
            "flags": 0,
            "hasliked": 0,
            "id": "WsGSDR",
            "likes": 29,
            "name": "Turing Texture",
            "published": 3,
            "tags": [
                "blur",
                "filter",
                "cubemap",
                "diffusion",
                "pattern",
                "reaction",
                "turing"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1281
        },
        "renderpass": [
            {
                "code": "/*\n\n\n\tTuring Texture\n\t--------------\n\t\n\tThis is just a simple example demonstrating writing 2D UV coordinates to one \n\tof the faces of the cube map, and reading them back. The reason you'd want to \n\tdo this is the ability to gain access to six constant-sized 1024 by 1024 pixel\n    buffers -- Although, to keep things simple, I'm only using one here. There are\n\talso the benefits regarding screen size changes -- If you switch to fullscreen,\n\tyou don't need to recalculate. To me, that's worth the effort alone. :)\n\n    If you'd simply like to know how to read from a particular cubemap face, see the \n    \"tx\" function and comments in the \"Common\" tab. There's a \"SCHEME\" define there\n\ttoo, which allows you to see the plain monochrome or color channeled pattern.\n\n\tI wasn't initially sure how to go about reading and writing to a cubemap face\n\tuntil TDHooper put up his awesome \"Copper / Flesh\" example -- The link's below, \n\tfor anyone interested. I skimmed through the relevant code, but decided to take \n\tmy own route. However, it was very helpful just knowing that it could be done. :)\n\n\tAs mentioned, this is just a simple 2D example, but packing in and reading 3D \n\tcoordinates is a relatively simple extension of the process. As such, I have a \n    few examples along those lines coming up, including a 3D Turing shader.\n\n    Anyway, I've used a Turing pattern as the demonstration mechanism, because it \n\tfollows the process of initialization and data manipulation in the \"Cube A\" tab, \n\tthen presentation of data in the image tab.\n\n\tI like Turing patterns because they're visually interesting and can form quickly. \n\tHowever, a lot of the information out there is pretty obscure. Like everyone on \n\there, I can suck it up and do the so-called hard stuff, but I never understand \n\twhy people make it harder than it has to be. \n\n    For all intents and purposes, Turing patterns -- or things that look pretty \n\tclose to the real thing -- are just a pattern (random, or otherwise) with a \n\tblurry edge filter applied. This is achieved by combining the initial value \n\twith a blurred value, and an even more blurred value -- See the \"Cube A\" tab for \n\tthe actual formula, which is a combination of a lot of reading and a lot of \n    experimentation. Anyway, if you can apply a filter, you should have it covered.\n\n\tBy the way, I can thank Flexi and Cornusammonis's expertise in the area of \n    diffusion-reaction related phenomena for settting me off on the right path. I \n    don't know who initially decided to create patterns via filtering mechanisms \n\tonly, but Jonathan McCabe's name seems to come up a lot, so feel free to look\n\this work up.\n\n\n    \n    Other examples:\n\n\t// The world's smallest, and lowest quality, Turing texture code. :)\n\tTwo Tweet Turing Texture - Shane\n    https://www.shadertoy.com/view/4ldcWS\n\n    // Really nice example, and the thing that motivated me to get in amongst it\n\t// and finally learn to read and write from the cube map. I have a few 3D packing \n    // examples coming up, which use more simplistic formulas, but I couldn't tell \n    // you whether that translates to extra speed or not. Probably not. :)\n    Copper / Flesh - tdhooper\n    https://www.shadertoy.com/view/WljSWz\n\n*/\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n \n    \n    // Capping the screen resolution.\n    float iRes = min(iResolution.y, 750.);\n    \n    // Centered aspect-correct screen coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iRes;\n    \n    // Scale, depending on scheme. See the \"Common\" tab.\n    #if SCHEME>0\n    float sc = 4.;\n    #else\n    float sc = 6.;\n    #endif\n    \n    #ifdef SMALL_BLUR\n    // Increase the scale a bit, if using smaller blurring kernels.\n    sc += 1.;\n    #endif\n    \n    // Smoothing factor, based on scale. This time, the resolution of the cube face\n    // texture being accessed is constant, so we no longer have to factor that in\n    // during screen resolution changes.\n    float sf = .1/sc;\n    \n    // Scaling and translation.\n    vec2 p = uv/sc + iTime/16./sc;\n    \n    // Turing texture sample.\n    vec4 tur = tx(iChannel0, p)*.5 + .5;\n    \n    // Second sample at a nearby point in a particular direction.\n    \n    vec2 e = vec2(-2, -2.5)/iChannelResolution[0].xy;\n    #ifdef SMALL_BLUR\n    e *= .74; // Smaller shadow range with the tighter pattern.\n    #endif\n    vec4 tur2 = tx(iChannel0, (p - e))*.5 + .5;\n    \n   \n    // Distance fields for the two samples.\n    float d = (tur.x - .725)/sc;\n    float d2 = (tur2.x - .725)/sc;\n    \n    // Turing pattern overlays.\n    float sc2 = 6.;\n    vec4 turPat = tx(iChannel0, p*sc2)*.5 + .5;\n    float dPat = (turPat.x - .5)/sc/sc2;\n    \n   \n    // Distance field-based shading.   \n    float sh = clamp(-(d + .1/sc)/(.5/sc), 0., 1.);\n    \n    // Initializing the scene to a brownish color.\n    vec3 col = vec3(.83, .7, .6);\n    // Blend the higher frequency Turing pattern onto the background.\n    col = mix(col, vec3(0),  (1. - smoothstep(0., sf/sc2, dPat))*.6);\n \n    \n    // The Turing layer color. Just a bit of orange with some\n    // high resolution Turing pattern overlays.\n    vec3 oCol = vec3(1, .05, 0);\n    oCol = mix(oCol, oCol*2.,  (1. - smoothstep(0., sf/sc2, dPat - .2/sc2)));\n    oCol = mix(oCol, vec3(0),  (1. - smoothstep(0., sf/sc2, dPat))*.7);\n    \n    // Rendering the Turing layers -- If you need to see what any of them\n    // are for, just comment it out.\n    //\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*3.5, d2))*.8); // Drop shadow.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., d))*.7); // Fake AO;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, d)); // Edge, or stroke.\n    \n    // The main shaded layer.\n    col = mix(col, oCol*(sh + .25), (1. - smoothstep(0., sf, d + .3/sc))); \n    \n    \n    // Extra, subtle white highlights... I'm making this up as a go along. :)\n    col = mix(col, mix(col*1.5, vec3(1), .35), \n             (1. - smoothstep(0., sf*1.5, abs(d + .35/sc) - .03/sc))*.08);\n    \n    \n    // Object shadow -- Didn't really need it.   \n    //col = mix(col, vec3(0), (1. - smoothstep(0., sf, max(-(d2 - .2), (d))))*.5);\n    \n    // The main object highlight.\n    col = mix(col, col*(sh + vec3(6, 9, 12)), (1. - smoothstep(0., sf*3., max(-(d2 - .1/sc), (d + .2/sc))))*.8);\n    \n    // Extra shiny middle strip.\n    vec3 hl = vec3(.5, .7, 1)*(smoothstep(0., sf/sc2*2., dPat - .03/sc2) + .1);\n    col = mix(col, col*1.25 + hl, (1. - smoothstep(0., sf, d + .73/sc))*.65);\n   \n    \n    // Adding a bit of noise.\n    gSc = sc*24./2.;\n    vec2 q = p*sc*24.;\n    float ns = n2D(q)*.57 +  n2D(q*3.)*.28 +  n2D(q*9.)*.15;\n    col *= ns*.75 + .5;\n    \n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    float vig = pow(16.*(1. - uv.x)*(1. - uv.y)*uv.x*uv.y, 1./6.);\n    col = mix(col*1.1, col.zyx, max(.5 - vig*.7, 0.))*vig;\n    \n    \n    #if SCHEME == 1\n    // The monochrome distance field. Fancy layering is great, but sometimes, you\n    // just want the plain monochrome pattern.\n    col = mix(vec3(1), vec3(0), (1. - smoothstep(0., sf*2., d + .2/sc)));\n    #elif SCHEME == 2\n    // Three individual colored patterns.\n    col = mix(vec3(1), vec3(0), (1. - smoothstep(0., sf*2., (tur.xyz - .7)/sc + .2/sc)));\n    #endif\n    \n    \n    // Rough gamma correction, and we're done.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n// Just a custom blur filter. This one's triangle based, but it can be Gaussian, boxey, etc.\nvec4 BlurTri(samplerCube ctx, vec2 p, int dim){\n    \n    // Initiate the color.\n    vec4 col = vec4(0);\n    \n    int hDim = dim/2; // Half dimension.\n    \n    float tot = 0.;\n    // There's a million boring ways to apply a kernal matrix to a pixel, and this \n    // is one of them. :)\n    for (int j=0; j<dim; j++){\n        for (int i=0; i<dim; i++){ \n            \n            // Alternative distance-based blur. Gaussians are possible too, but\n            // I found the simpler formulas better suited to these examples.\n            //float ij = length(vec2(hDim - i, hDim - j));\n            //ij = max(length(vec2((hDim + 1)*(hDim + 1)))*.75 - ij*ij, 0.);\n\n            // Smoothed triangle blur, of sorts.\n            float ij = float(hDim - abs(hDim - i) + 1)*float(hDim - abs(hDim - j) + 1);\n            float mDim = float((hDim + 1)*(hDim + 1));\n            ij = smoothstep(0., 1., ij/mDim)*mDim;\n            \n            // Adding the weighted value.\n            col += ij*tx(ctx, (p + vec2(i - hDim, j - hDim)/iRes0));\n            tot += ij;\n        }\n    }   \n    \n    return col/tot;\n}\n\n\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir){\n    \n    \n    // UV coordinates.\n    //\n    // For whatever reason (which I'd love expained), the Y coordinates flip each\n    // frame if I don't negate the coordinates here -- I'm assuming this is internal, \n    // a VFlip thing, or there's something I'm missing. If there are experts out there, \n    // any feedback would be welcome. :)\n    vec2 uv = fract(fragCoord/iResolution.y*vec2(1, -1));\n \n    // Pixel storage.\n    vec3 col;\n   \n    // Initial conditions -- Performed upon initiation.\n    if(abs(tx(iChannel0, uv).w - iResolution.y)>.001){\n        \n        // INITIAL CONDITIONS.\n       \n        // Sprinkle some hash noise into the RGB channels on the canvas. \n        // Set the wrapping values.\n        \n        gSc = 512.;\n        col = vec3(hash21(uv), hash21(uv + 7.), hash21(uv + 9.));\n        \n        #if SCHEME == 0\n        // Smooth value noise overlay to achieve that pattern within\n        // a pattern look.\n        gSc = 24.;\n        col *= smoothstep(0., .01, n2D(uv*gSc) - .5)*4. + 1.;\n        #endif\n        \n        // Another square combination.\n        //gSc = 512.;\n        //col = vec3(1)*hash21(floor(uv*64.)/32.);\n        //col = max(col, hash21(uv));\n        \n        /*\n        // Just to show that it works with anything, add the \"London\" texture to \n        // \"iChannel1\" and uncomment this block... For better resolution, you\n        // might also wish to switch to the SMALL_BLUR option in the \"Common\" tab, \n        // and take out the scrolling in the \"Image\" tab.\n        vec3 tx = texture(iChannel1, fract(uv*2. + .5)).xyz; tx *= tx; // Rough SRGB to linear.\n        #if SCHEME == 1\n        tx = vec3(1)*dot(tx, vec3(.299, .587, .114))\n        #endif\n        col = tx;\n        */\n        \n    }\n    else {\n            \n       \t// Formula: Initial value, minus the larger filter differences,\n        // plus the smaller filter difference.\n \n        vec3 val = tx(iChannel0, uv).xyz;\n        \n        // Larger kernel sizes give more controlls blurs, and generally thicker patterns,\n        // which I like, but they tend to be slightly slower and more costly. Having said \n        // that, the larger blurs require a total of 74 (49 + 25) texel reads, which the \n        // average GPU can do with ease. The smaller blur dimensions require just 34 \n        // (25 + 9) reads.\n        \n        // Inside a raymarching loop, it'd be just the one read. Plus, you could \n        // stop the blurring process entirely, once you're satisfied with the pattern.\n        \n        // Only odd sizes differing by two will work.\n        #ifdef SMALL_BLUR\n        const int blurDimL = 5; // Large filter dimension.\n        const int blurDimS = 3; // Small filter dimension.\n        #else \n        const int blurDimL = 7; // Large filter dimension.\n        const int blurDimS = 5; // Small filter dimension.\n        #endif\n        \n        // You could stop filtering at this point. For raymarched patterns, it'd be \n        // worth saving every cycle you can. I think there's a discard option as well.\n        //if(iTime<15.){        \n            vec3 val3 = BlurTri(iChannel0, uv, blurDimL).xyz;    \n            vec3 val2 = BlurTri(iChannel0, uv, blurDimS).xyz; \n        \n            // These figures require a bit of coaxing, but they're not too hard\n            // to tweak. With small kernel sizes, the larger blurring speed needs\n            // to slow down. Once you get them right, they'll work with virtually\n            // any normal range pattern.\n            #ifdef SMALL_BLUR\n            col = val + (val2 - val3) + (val2 - val);\n            #else\n            col = val + (val2 - val3)*1.6 + (val2 - val);\n            #endif\n        //}\n        //else col = val;\n        \n       \n          \n    }\n    \n    fragColor = vec4(clamp(col, -1., 1.), iResolution.y);\n    \n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            },
            {
                "code": "// The cubemap texture resultion.\n#define iRes0 vec2(1024)\n\n// Pattern scheme:\n// 0 - Default pattern and shading.\n// 1 - Monochrome.\n// 2 - Color (Better with a reset).\n#define SCHEME 0\n\n// Uses smaller blurring kernel sizes\n//#define SMALL_BLUR\n\n\n\n\n// Believe it or not, the simple one-line function below took me ages to figure out. The \n// only refrences to it seem to be from some Microsoft documentation somewhere, because it's \n// all written in some obscure way that involves the term, \"fract(p)*2. - 1.,\" etc.\n//\n// Anyway, the following should have been obvious to me, but it wasn't: A unit cube centered \n// on a grid has six faces with a center at vec3(0), and 8 vertices at coordinates, \n// vec3(-.5, -.5, -.5), vec3(-.5, -.5, .5), etc. Therefore, using very basic UV mapping logic, \n// the faces will be the following:\n//\n// Left face: \n// // Wrapping and centering coordinates on the YZ plain: \n// p.yz = fract(p.yz) - .5;\n// // The X coordinate is at \"-.5\".\n// p.x = -.5;\n// // Texture coordinate. \n// vec4 tx = texture(texChannel, vec3(-.5, fract(p.yz) - .5));\n//\n// All faces follow the same logic, with a bit of UV flipping to get things facing the right \n// way, etc. Using uv = fract(uv) - .5:\n//\n// The four cube sides - Left, back, right, front.\n// NEGATIVE_X, POSITIVE_Z, POSITIVE_X, NEGATIVE_Z\n// vec3(-.5, uv.yx), vec3(uv, .5), vec3(.5, uv.y, -uv.x), vec3(-uv.x, uv.y, -.5).\n//\n// Bottom and top.\n// NEGATIVE_Y, POSITIVE_Y\n// vec3(uv.x, -.5, uv.y), vec3(uv.x, .5, -uv.y).\n//\n//\n// From what I've noticed, the size of the cube you use doesn't seem to matter -- I'm \n// assuming this is due to an internal normalization process. Therefore, to save extra \n// calculations (which matter when doing 3D stuff), you may as well use the unit cube \n// figures above -- instead of vec3(fract(p)*2. - 1., 1), vec3(fract(p) - .5)*n, n), etc.\n \n\n// Reading in the texture from the right face of the cube: I chose this because it \n// writes more easily, but you can read from any, or as many, faces you'd like. I'm\n// assuming that all sides index in memory at the same rate, otherwise you'd have to\n// take that into consideration when favoring one side or the other.\n//\n// By the way, \"p\" is simply your \"uv\" coordinates, which are usually: \n// uv = fragCoord/iResolution.y, but could represent cube sides, like p.xz, etc.\nvec4 tx(samplerCube tx, vec2 p){    \n\n    return texture(tx, vec3(fract(p) - .5, .5));\n}\n\n\n// If you want things to wrap, you need a wrapping scale. It's not so important\n// here, because we're performing a wrapped blur. Wrapping is not much different\n// to regular mapping. You just need to put \"p = mod(p, gSc)\" in the hash function\n// for anything that's procedurally generated with random numbers. If you're using\n// a repeat texture, then that'll have to wrap too.\nfloat gSc = 1.;\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){\n    p = mod(p, gSc);\n    return fract(sin(dot(p, vec2(27.609, 157.583)))*43758.5453); \n}\n\n// IQ's vec4 to vec4 hash.\nvec4 hash44(vec4 p){\n    p = mod(p, gSc);\n    return fract(sin(p)*43758.5453); \n}\n\n\n// Cheap and nasty 2D smooth noise function -- based on IQ's original. Very \n// trimmed down. In fact, I probably went a little overboard. I think it might \n// also degrade with large time values.\nfloat n2D(vec2 p){\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(hash44(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113))))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}