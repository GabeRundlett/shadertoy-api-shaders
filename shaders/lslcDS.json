{
    "Shader": {
        "info": {
            "date": "1489750088",
            "description": "Raytracing experiment",
            "flags": 0,
            "hasliked": 0,
            "id": "lslcDS",
            "likes": 0,
            "name": "Sepia hyper-jump",
            "published": 3,
            "tags": [
                "raytracing",
                "randomresult"
            ],
            "usePreview": 0,
            "username": "login22876534184820",
            "viewed": 396
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 32\n#define EPSILON .001\n#define BALL_CENTER_X_COORD 0.\n#define BALL_CENTER_Y_COORD 0.\n#define BALL_CENTER_Z_COORD 3.\n#define BALL_RADIUS 1.4\n#define MAGIC_NUM .95\n\nfloat world(vec3 a) {\n\treturn length(a) - BALL_RADIUS;\n}\n\n\nfloat trace(vec3 O, vec3 D) {\n\tfloat L = 0.; \n\tfor (int i = 0; i < MAX_STEPS; ++i) { \n\t\tfloat d = world(O + D*L);\n\t\tL += d; \n\t\tif (d < EPSILON*L) break; \n\t}\n\treturn L; \n}\n\n/// Координаты in относительно центра окружности\nvec3 convertCoordToPolar(vec3 coordsInDekart, float r)\n{\n    vec3 outCoords = vec3(r, atan(sqrt(coordsInDekart.x*coordsInDekart.x+coordsInDekart.y*coordsInDekart.y), coordsInDekart.z), atan(coordsInDekart.y, coordsInDekart.x));\n    return outCoords;\n}\n\n/// Координаты out относительно центра окружнсти\nvec3 convertCoordToDecart(vec3 coordsInPolar)\n{\n    float xCoord = coordsInPolar.x*sin(coordsInPolar.y)*cos(coordsInPolar.z);\n    float yCoord = coordsInPolar.x*sin(coordsInPolar.y)*sin(coordsInPolar.z);\n    float zCoord = coordsInPolar.x*cos(coordsInPolar.y);\n    return vec3(xCoord, yCoord, zCoord);\n}\n\n/// На вход координаты относительно центра \nvec4 getColorPoint(float distancePoint, vec3 coord, float r)\n{\n    vec3 polarCoord = convertCoordToPolar(coord, r);\n    polarCoord.z += cos(iTime) * 180.;\n    vec3 newCoord = convertCoordToDecart(polarCoord);\n    vec4 color  = texture(iChannel0, newCoord.xy-vec2(newCoord.z*MAGIC_NUM));\n    color.xyz += vec3(1.5);\n    color.xyz -= vec3(distancePoint);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    \n\n\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 O = vec3(BALL_CENTER_X_COORD, BALL_CENTER_Y_COORD, BALL_CENTER_Z_COORD);\n\n\tvec3 D = normalize(vec3(uv, -2.));\n\t\n\tfloat path = trace(O, D);\n\t\n\tfragColor = getColorPoint(path, vec3(uv.x, uv.y, BALL_CENTER_Z_COORD-(uv.x*uv.y)*MAGIC_NUM)-O, BALL_RADIUS);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}