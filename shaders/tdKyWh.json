{
    "Shader": {
        "info": {
            "date": "1602772332",
            "description": "Producing packed extruded asymmetric rounded hexagons in realtime, with the help of some texture precalculation. Rendered in an austere pencil ink style.",
            "flags": 0,
            "hasliked": 0,
            "id": "tdKyWh",
            "likes": 28,
            "name": "Extruded Asymmetric Hexagons",
            "published": 3,
            "tags": [
                "voronoi",
                "cartoon",
                "hexagon",
                "sketch",
                "pencil",
                "cross",
                "hatch",
                "extrude",
                "asymmetric"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 999
        },
        "renderpass": [
            {
                "code": "/*\n\n    Extruded Asymmetric Hexagons\n    ----------------------------\n\n\tHere's a trimmed down version of my \"Asymmetric Hexagon Landscape\"\n    example. Aesthetically speaking, I've kept it pretty basic. Without the \n    extra detail, it should definitely run faster. However, how well it runs \n    is still dependent upon how well your machine can deal with textures, and  \n    other things.\n\n\tMy laptop can run this in the 800 by 450 window form in its sleep, and \n    can almost run it in fullscreen (1920 by 1080), but experiences slight \n    stutter. Having said that, I think running any detailed pixel shader in\n\tfullscreen mode is a bit of a stretch for the GPU.\n\n    Texture storage can be annoying to code, and a lot of systems still don't\n\tlike the idea of putting them in memory and reading from them in realtime. \n    However, the alternative is to calculate really expensive distance \n    functions on the fly, which would be near impossible on present systems.\n    This particular field comprises of packed pixel-perfect rounded asymmetric \n    extruded hexagons. As an aside, I've already tried to produce the same \n    using nonstorage methods and it practically grinds my machine to a halt. \n\n    Either way, this is a pretty simple field in the general scheme of things, \n    so if you wanted to raymarch something more elaborate, then some kind of \n    texture precalculation will be mandatory. With this particular method, I\n\tcould turn it into a jigsaw, and the performance would remain relatively \n    unaffected.\n\n    By the way, for anyone interested, the cheap 3D cross hatching-based \n    pencil ink post processing routine was written off the top of my head in \n    under ten minutes. It's substandard for sure, but effective (See the\n\tDRAW_STYLE directive below). I've been meaning to add one for a while, \n    since I haven't seen many written on Shadertoy. All routines like this \n    are just an extension of tri-planar texturing and greyscale pixel \n    thresholds, and are not very difficult to implement. Anyway, the code is\n\tat the bottom of the page.\n\n\n \n\tOther examples:\n\n\t// Dr2's latest, which takes a Voronoi approach. The Voronoi aesthetic is \n    // similar, and arguably, superior, which makes it the algorithm of choice \n    // in many situations. However, it involves more taps, plus gaining access \n    // to vertex information is definitely not as straight forward, which \n    // means there are times when an offset hexagon vertices approach would\n    // be preferred.\n    //\n    Gliders Over Voropolis - Dr2\n    https://www.shadertoy.com/view/WdKcz1\n    \n    // A more involved example.\n    //\n\tAsymmetric Hexagon Landscape - Shane\n \thttps://www.shadertoy.com/view/tdtyDs\n\n    // Flockaroo's less hacky sketch shader: This is a planar algorithm, \n    // and is great with static scenery and some moving scenery. For general \n    // moving scenery, it'd need to be converted to a tri-planar version.\n    when voxels wed pixels - Flockaroo\n    https://www.shadertoy.com/view/MsKfRw\n\n\n*/\n\n// The drawing style -- Choose greyscale pencil (2) to see the typical \n// cross hatching representation on its own.\n//\n// 0: No postprocessing, 1: Heavy greyscale pencil, 2: Greyscale pencil, \n// 3: Colored pencil.\n#define DRAW_STYLE 2\n\n// The pencil algorithm looks more authentic with this turned off -- I\n// think it has something to do with our eyes not accepting pronounced\n// lighting changes with animated sketches. However, I'd like the user \n// to see it with it turned on. Anyway, the ability to turn it off is \n// a compromise.\n#define ENVIRONMENT_LIGHTING \n\n// Turning the metallic texturing on and off.\n#define TEXTURED\n\n// Colored blinking pylons.\n#define BLINK \n\n\n\n// Max ray distance.\n#define FAR 20.\n\n// Pylong height scale. Between zero and one works, but larger numbers\n// introduce more artifacts.\n#define HS .6  \n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// The path is a 2D sinusoid that varies over time, which depends upon the frequencies and amplitudes.\nvec2 path(in float z){ \n    \n    //return vec2(0);\n    return vec2(3.*sin(z*.1) + .5*cos(z*.4), .25*(sin(z*.875)*.5 + .5));\n}\n\n\n// Getting the video texture. I've deliberately stretched it out to fit across the screen,\n// which means messing with the natural aspect ratio.\n//\n// By the way, it'd be nice to have a couple of naturally wider ratio videos to choose from. :)\n//\nvec3 getTex(sampler2D tex, in vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    //p = p/2. + .5;\n    //p = (floor(p*1024.) + .5)/1024.;\n    vec3 tx = texture(tex, p).xyz;\n    //vec3 tx = textureLod(iChannel0, p, 0.).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Tri-Planar blending function: Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n// Height map value, which is just the pixel's greyscale value.\nfloat hmB(in vec2 p){ \n     \n    return dot(getTex(iChannel1, p), vec3(.299, .587, .114)); \n}\n\n// The height map. It was orginally supposed to be a fast texture call, but then\n// I was insistent on creating a valley that followed the camera path, which would\n// be pretty difficult to encode into a repeat texture... Anyway, it's slower now,\n// but within acceptable ranges.\nfloat hmBlock(in vec2 p){ \n    \n    \n    // Wrapping things around the camera path.\n    vec2 pth = path(p.y);\n    p -= pth; // Y is the Z coordinate here.\n    \n    float d = abs((p.x + .5) - .5)*2.;\n    \n    // Scaling by 1/16 and snapping to repeat texture pixels. Alternatively, you \n    // can change the cube map filter to \"nearest\" and save a calculation, which\n    // is what I've done.\n    p /= 24.;\n    // p = (floor(p*1024./16.) + .5)/1024.;  \n    \n    // Retrieving the height value from the precalculated wrapped texture map.\n    float h = tx5(iChannel0, p).x; \n                    \n    // Carving out a path.\n    h = mix(h + pth.y,  h/1.5 + pth.y/2., 1. - smoothstep(0., .75, d - .25));\n    \n    #ifdef QUANTIZE_HEIGHT\n    // Quantizing the height levels. More expensive, but it looks a little neater.\n    h = floor(h*23.999)/23.;\n    #endif\n    \n    return h;\n    \n    \n}\n\n\n\n\n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed square pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n \n\n\nvec4 blocks(vec3 q){\n    \n    \n    // Pulling in the 4 precalculated offset values from their respective\n    // cube map faces.\n    //\n    // By the way, calculating the minimum 2D face distance, then using it to\n    // render the extruded block doesn't work... It'd be nice, but you have to\n    // compare all 4 extruded blocks... It's obvious, yet if I haven't done this\n    // for a while, it's the first thing I try. :D\n    vec2 uv = (floor(q.xy*1024.) + .5)/1024.;\n    vec4 p40 = tx0(iChannel0, uv);  // The 2D distance fields.  \n    // Precalculated heights. These would have tripled the speed, but\n    // unforturnately weren't practic\n\n\n    // Block dimension: Length to height ratio with additional scaling. By the way,\n    // I'm being sneaky here and not applying the vec2(.8660254, 1) stretch scaling\n    // that gives you proper scaled hexagons. One reason is that they're mutated by\n    // the offset vertices anyway, and the main one is that it makes wrapping more\n    // difficult. Not impossible, but more complicated.\n\tconst vec2 dim = GSCALE;\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = dim*2.; \n \n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0);\n    vec2 cntr = vec2(0);\n\n    // Four block corner postions.\n    const vec2 ll = vec2(.5);\n    //vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll, -ll, vec2(ll.x, -ll.y));\n    // Pointed top.\n    #ifdef FLAT_TOP\n    // Flat top.\n    vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll + vec2(0., ll.y), -ll, vec2(ll.x, -ll.y) + vec2(0., ll.y));\n    #else\n    // Pointed top.\n    vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll, -ll + vec2(ll.x, 0), vec2(ll.x, -ll.y) + vec2(ll.x, 0));\n    #endif  \n    \n\n    // Initializing the extruded face distance for the hexagon cell.\n    float d2D = 1e5;\n    \n    for(int i = 0; i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2.; \n        \n        p = q.xy; // Local coordinates.\n        ip = floor(p/s - cntr) + .5; // Local tile ID.\n        p -= (ip + cntr)*s; // New local position.\n        \n        // Correct positional individual tile ID.\n        vec2 idi = ip + cntr;\n \n        // Hexagon vertices. \n        vec4[3] vert = vID; \n        \n        \n        #ifdef OFFSET_VERTICES\n        // Offsetting the vertices. Note that accuracy is important here. I had a bug for\n        // a while because I was premultiplying by \"s,\" to save some calculations, which meant\n        // points were not quite meeting at the joins... I won't bore you with the rest,\n        // except to say that it's necessary to keep these numbers simple.\n        const float vo = .15;\n        vec4 vrt0 = idi.xyxy + vert[0]/2.;\n        vec4 vrt1 = idi.xyxy + vert[1]/2.;\n        vec4 vrt2 = idi.xyxy + vert[2]/2.;\n        vrt0 = hash42B(vrt0);\n        vrt1 = hash42B(vrt1);\n        vrt2 = hash42B(vrt2);\n        vert[0] += vrt0*vo;\n   \t\tvert[1] += vrt1*vo;\n        vert[2] += vrt2*vo;\n        #endif \n        \n        // Scaling to enable rendering back in normal space.\n        vert[0] *= dim.xyxy;\n        vert[1] *= dim.xyxy;\n        vert[2] *= dim.xyxy; \n        \n          \n        // Hexagon vertices.\n        vec2[6] v1 = vec2[6](vert[0].xy, vert[0].zw, vert[1].xy, vert[1].zw, vert[2].xy, vert[2].zw); \n        \n        \n        // Scaling the ID.\n\t    idi *= s;\n         \n        \n        // Offset hexagon center.\n        //vec2 inC = vec2(0);\n        // Preferred, but not necessary and it's a huge bottleneck, which surprises me.\n        //vec2 inC = (vert[0].xy + vert[0].zw + vert[1].xy + vert[1].zw + vert[2].xy + vert[2].zw)/6.;\n        //vec2 idi1 = idi + inC;\n        \n        // Stored 2D rounded offset hexagon face distance information. Without this, \n        // the example would fry your GPU.\n        float face1 = p40[i];\n        //float face1 = sdPoly(p, vert); \n        \n        float h1 = hmBlock(idi); //p42[i] For future stored heights.\n        h1 *= HS; // Height scaling.\n        \n        float face1Ext = opExtrusion(face1, (q.z - h1), h1); \n        \n        /*\n        // Lego style.\n        float top = length(p) - .2*scale.x + .065*scale.x;\n        float cyl1 = opExtrusion(abs(top) - .035*scale.x, q.z - (h1 + .01), h1 + .01);\n        face1Ext = min(face1Ext, cyl1);\n        */\n        \n        face1Ext += max(face1, -.015)*.5;\n        face1Ext += face1*.05;\n        \n        \n        // If applicable, update the overall minimum distance value,\n        // ID, and pylon face distance. \n        if(face1Ext<d){\n            d = face1Ext;\n            id = idi;\n            d2D = face1; // Recording the face distance.\n\n        }\n        \n    }\n    \n    // Return the distance, position-based ID and triangle ID.\n    return vec4(d, id, d2D);\n}\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec4 gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor.\n    //float fl = p.y;\n\n    // The extruded blocks.\n    vec4 d4 = blocks(p.xzy);\n    gID = d4; // Individual block ID.\n \n    // Overall object ID.\n    objID = p.y<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded image\n    return min(p.y, d4.x);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = 0; i<96; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001*(1. + t*.125) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        t += i<40? d*.5 : d*.75; \n        //t += d*.8; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\tconst vec2 e = vec2(.001, 0);\n    \n    \n    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    //map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n    \n    float sgn = 1.;\n    vec3 n = vec3(0);\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        if(sca>1e5) break; // Compiler related.\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 4.;\n    p.y += iTime;\n    \n    float n3D2 = n3D(p*2.);\n   \n    // A bit of fBm.\n    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;\n    c = smoothstep(.45, 1., c); // Putting in some dark space.\n    \n    p = vec3(c, c*c, c*c*c); // Redish tinge.\n    \n    return mix(p, p.xzy, n3D2*.4); // Mixing in a bit of purple.\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n \t\n\t// Camera Setup.\n\n\tvec3 ro = vec3(0, 1.15, iTime*.75); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, -.2, .25); // \"Look At\" position.\n    \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n    \n    #if DRAW_STYLE == 0\n    // With no pencil post processing, the light looks a little nicer here.\n    const float lightZ = 4.5;\n    #else\n    // When using a pencil overlay, reposition the light to hit the surface more directly.\n    const float lightZ = -.5;\n    #endif\n \tvec3 lp = ro + vec3(1.25, 1.5, lightZ);// Put it a bit in front of the camera.\n    \n    // Moving the camera and light along the path.\n\tro.xy += path(ro.z); \n    lk.xy += path(lk.z); \n    lp.xy += path(lp.z); \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera about the XY-plane.\n\t//rd.xy *= rot2( sin(iTime/8. - cos(iTime/12.))/2. );\n\n    // Setting the global time variable so that the \"Common\" tab can recognize time.\n    setTime(iTime);\n\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block ID and object ID.\n    vec4 svGID = gID;\n    \n    float svObjID = objID;\n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n    \n    // Surface position and surface normal. We're setting them\n    // up here, due to some postprocess that require them...\n    // See below.\n\tvec3 sp = ro + rd*t;\n    vec3 sn = rd; // Surface normal for the sky dome.\n    float gRnd = 0.; // Random number to move the hatching around.\n    float gRndB = 0.; // Random number to move the hatching around.\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n  \t\n    \t// Normal overide for cases where we've hit\n        // the surface. In this example, we don't see the \n        // horizon, so it would be always, but we still\n        // need to do things correctly. :)\n\t    //sn = getNormal(sp, edge, crv, ef, t);\n        sn = getNormal(sp, t);\n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol;   \n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n            // Texturing.\n            //\n            #ifdef TEXTURED\n            // Coloring the individual blocks with the saved ID.\n            vec3 tx = getTex(iChannel1, svGID.yz/2.);\n            //tx = smoothstep(.05, .5, tx);\n            // Continuous tri-planar texturing.\n            vec3 tx2 = tex3D(iChannel1, sp*1., sn);\n            tx2 = smoothstep(.0, .5, tx2);\n            #else\n            vec3 tx = vec3(.35);\n            vec3 tx2 = vec3(.35);\n            #endif\n            \n\t\t\tfloat rnd = hash21(svGID.yz); \n            gRnd = rnd;\n            #ifdef BLINK\n            // Blinking: Couldn't make it look right, but I'll look at it later.\n            //rnd = rnd<.125? 1. : 0.;\n            rnd = smoothstep(.9, .95, sin(6.2831*rnd + iTime)*.5 + .5);\n            gRndB = rnd;\n            vec3 bCol = vec3(1, .2, .05);\n            bCol = mix(bCol, bCol.xzy, hash21(svGID.yz + .09)*.6);\n            tx2 *= mix(vec3(1), bCol*5., rnd);\n            #endif\n            \n            texCol = mix(tx, tx2, .5); // Blend.\n            //texCol = vec3(.34);\n            //float rnd = hash21(svGID.yz);\n            //vec3 rndC = .5 + .45*cos(6.2831*(rnd)/4. + vec3(0, 1, 2) + 0.);\n            //texCol = mix(texCol, rndC, .15);\n            \n\n\n            vec2 svP = sp.xz - svGID.yz;\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., .005, length(svP) - .04*GSCALE.x));\n             \n            // Hexagonal face value.\n            float ht = hmBlock(svGID.yz)*HS;\n            float hex = svGID.w;\n   \n            float hex2 = hex;\n            hex = max(abs(hex), abs(sp.y - ht*2.)) - .001; // Face border.\n            //hex = min(hex, abs(hex2 + .01) - .00125); // Extra border.\n            \n            // Coloring the sides of the columns. I wasn't feeling it. :)\n            //vec3 rndC = .5 + .45*cos(6.2831*(ht)*4. + vec3(2, 1, 0) + 2.);\n            //texCol = mix(texCol, texCol*rndC, (1. - smoothstep(0., .002, -(hex2)))*.9);\n            \n            // Applying the face border.\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., .002, hex)));\n            \n            \n            // Failed attempts at decoration. I opted for \"less is more\" in the end. :)\n            /*\n            float rnd = hash21(svGID.yz);\n            vec2 puv = rot2(ht*6.2831)*svP;\n            float pat = abs(fract(puv.x*48.) - .5)*2. - .125;\n            pat = smoothstep(0., .003*48.*(1. + t*t), pat);\n            texCol = mix(texCol, texCol*pat, 1. - smoothstep(0., .003, -(sp.y - ht*2.)));\n            */\n            \n            /*\n            float ang = atan(svP.y, svP.x)/6.2831;\n            float pat = abs(fract(ang*24.) - .5)*2. - .25;\n            pat = smoothstep(0., .003*24.*(1. + t*t), pat);\n            texCol = mix(texCol, texCol*vec3(2, 1, .5)*pat, 1. - smoothstep(0., .003, sp.y - ht));\n            */\n     \n \n        }\n        else {\n            \n            // The dark floor in the background. Hiddent behind the pylons, but\n            // you still need it.\n            texCol = vec3(0);\n        }\n       \n    \t\n    \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        //sh = min(sh + ao*.25, 1.);\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1.25/(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        diff = pow(diff, 2.)*1.35; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 2.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\t//float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\t//float freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + ao*.25 + vec3(.25, .5, 1)*fre*sh + vec3(1, .5, .3)*spec*4.);\n\n        #ifdef ENVIRONMENT_LIGHTING\n        // Fake environment mapping.\n        vec3 cTex = envMap(reflect(rd, sn));\n        #if DRAW_STYLE==0\n        col += col*cTex*5.;\n        #elif DRAW_STYLE==1\n        col += col*cTex*.5;\n        #else  \n        col += col*cTex*2.;\n        #endif\n        #endif\n        \n        // Shading.\n        col *= ao*atten;\n        \n\t\n\t}\n    \n    // Applying fog.\n    vec3 fog = vec3(0);//mix(vec3(.25, .5, 1), vec3(1, .8, .6), rd.y*.5 + .5)*2.;\n    col = mix(col, fog, smoothstep(0., .99, t/FAR));\n    \n    \n    // Here's a quick hacky 3D cross hatching routine that I made up on the spot. \n    // You could do better, but this works surprisingly well for the amount of \n    // effort involved. Normally, there's an element of frequency grading involved,\n    // but aside from that, all 3D hatching would be based on similar principles.\n    //\n    // Texure samples. One for each plane.\n    mat2 m2 = rot2(3.14159/12.); // Rotation.\n    sp += gRnd; // Constant translation from object to object.\n    sp *= 3.; // Scaling.\n    #if DRAW_STYLE==1\n    sp *= 1.5; // Finer grain pencil for the heavy pencil.\n    #endif\n    sp += n3D(sp*12.)*.02; // Perturbation, since pencil lines aren't perfect.\n    // Use the hatch texture, for obvious reasons. At some stage, I'll code\n    // up one that's more specific to this purpose.\n\tvec3 tx = getTex(iChannel2, m2*sp.yz); \n    vec3 ty = getTex(iChannel2, m2*sp.xz);\n    vec3 tz = getTex(iChannel2, m2*sp.xy);\n    // Second level of cross hatching.\n    sp *= 1.5; m2 *= rot2(3.14159/4.);\n    vec3 tx2 = getTex(iChannel2, m2*sp.yz); \n    vec3 ty2 = getTex(iChannel2, m2*sp.xz); \n    vec3 tz2 = getTex(iChannel2, m2*sp.xy); \n    // Normal manipulation.\n    sn = max(sn*sn - .2, .001); // max(abs(n), 0.001), etc.\n    sn /= dot(sn, vec3(1)); \n    //sn /= length(sn); \n    // Multiply each texture plane by its normal dominance factor.\n    tx = mat3(tx, ty, tz)*sn;\n    tx = vec3(1)*dot(tx, vec3(.299, .587, .114));\n    tx2 = mat3(tx2, ty2, tz2)*sn;\n    tx2 = vec3(1)*dot(tx2, vec3(.299, .587, .114));\n    tx = max(tx, tx2);\n    // Compare the texture to the scene's color value.\n    \n    #if DRAW_STYLE==1\n    // Straight cross hatching.\n    // The \"-.25\" and \".6\" terms control light and darkness. This little tidbit is\n    // based on some of Flockaroos logic from his sketch shader, here:\n    //\n    // when voxels wed pixels - flockaroo\n    // https://www.shadertoy.com/view/MsKfRw\n    tx = vec3(1)*smoothstep(0., .45, dot((min(col, 1.) - tx), vec3(.299, .587, .114)));\n    #ifdef BLINK\n    col = mix(tx, col*tx*1.35, gRndB);\n    #else\n    col = tx;\n    #endif\n    #elif DRAW_STYLE==2\n    // Straight cross hatching.\n    // The \"-.25\" and \".6\" terms control light and darkness.\n    tx = vec3(1)*smoothstep(-.25, .6, dot((min(col, 1.) - tx), vec3(.299, .587, .114)));\n    //tx = vec3(1)*clamp(dot((min(col, 1.) - tx), vec3(.299, .587, .114))/.6 + .25, 0., 1.);\n    #ifdef BLINK\n    col = mix(tx, col*tx*1.35, gRndB);\n    #else\n    col = tx;\n    #endif\n    #elif DRAW_STYLE==3\n    // Colorize. \n    // The \"-.25\" and \".5\" terms control light and darkness.\n    tx = vec3(1)*smoothstep(-.2, .5, dot((min(col, 1.) - tx), vec3(.299, .587, .114)));\n    // I was in a hurry here. It'd be better to perfrom some kind of nice\n    // Photoshop style overlay.\n    col *= tx*1.35;\n    //col *= mix(vec3(1), tx*1.25, .85);\n    //col = 1. - exp(-col*1.2); \n    //col = mix(col, max(col, tx), .25);\n    #endif\n    \n    // Color to greyscale edge fade.\n    //col = mix(col, tx, dot(uv, uv));\n   \n    // Debug: Just the height map.\n    //uv = fragCoord/iResolution.y;\n    //vec3 tx = tx5(iChannel0, uv/1.).xyz;\n    //col = tx;\n         \n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// Producing hexagons with offset vertices can be a little painful, but it's \n// doable. Regular hexagon grids are almost trivial, but don't really suit this\n// example. Either way, comment this out to see.\n#define OFFSET_VERTICES\n\n\n// Quantizing the height levels. More expensive, if not precalated, but it looks \n// a little neater -- Windows line up with the terraced levels, etc.\n#define QUANTIZE_HEIGHT\n\n\n// Grid pattern repeat scale. Baking wrapped distance fields into textures can be \n// a little fiddly... and at times, can be downright annoying. The distance fields\n// involve offsets, and all have to work in unison. Powers of two work, but for \n// some reason that mystifies me, (1024./36.) will work with GSCALE = vec2(1./6.).\n// Anyway, I'll revisit this at some stage.\nfloat repSc = 1024./32.;\n\n// This sets the scale of the extruded shapes. Because of the way I've calculated\n// things, the scale needs to be even divisors and each term needs to be equal --\n// I use it in other applications where I can use two different numbers though. \n// As above, if you choose this option, a reset will be necessary. Ie. Hit the \n// back button.\n//\n// I like a scale of \"1./4.\" too, but I opted for more detail for this example.\n#define GSCALE vec2(1./4.)  //*vec2(1./.8660254, 1)\n \n// Flat top hexagon.\n#define FLAT_TOP\n#ifdef FLAT_TOP\n// Vertices and mid edge points: Clockwise from the left.\nvec4[3] vID = vec4[3](vec4(-2./3., 0, -2./6., .5), vec4(2./6., .5, 2./3., 0), vec4(2./6., -.5, -2./6., -.5)); \nvec4[3] eID = vec4[3](vec4(-.5, .25, 0, .5), vec4(.5, .25, .5, -.25), vec4(0, -.5, -.5, -.25));\n#else\n// Vertices and mid edge points: Clockwise from the bottom left. -- Basically, the ones \n// above rotated anticlockwise. :)\nvec4[3] vID = vec4[3](vec4(-.5, -2./6., -.5, 2./6.), vec4(0, 2./3.,.5, 2./6.), vec4(.5, -2./6., 0, -2./3.));\nvec4[3] eID = vec4[3](vec4(-.5, 0, -.25, .5), vec4(.25, .5, .5, 0), vec4(.25, -.5, -.25, -.5));\n#endif\n\n////////\n\n// Work around for the time variable.\nfloat gTime = 0.;\nvoid setTime(float tm){ gTime = tm; }\n\n\n// Reading from various cube map faces.\nvec4 tx0(samplerCube tx, vec2 p){    \n\n    return textureLod(tx, vec3(-.5, fract(p.yx) - .5), 0.);\n    //return texture(tx, vec3(-.5, fract(p.yx) - .5));\n}\n\nvec4 tx1(samplerCube tx, vec2 p){    \n\n    p = fract(p) - .5;\n    return textureLod(tx,  vec3(.5, p.y, -p.x), 0.);\n    //return texture(tx, vec3(.5, p.y, -p.x));\n}\nvec4 tx5(samplerCube tx, vec2 p){ \n   \n    return textureLod(tx, vec3(fract(p) - .5, .5), 0.);\n    //return texture(tx, vec3(fract(p) - .5, .5));\n}\n/*\nvec4 tx1B(samplerCube tx, vec2 p){    \n\n    p = (floor(p*1024.) + .5)/1024.;\n    p = fract(p) - .5;\n    \n    return textureLod(tx, vec3(.5, p.y, -p.x), 0.);\n    //return texture(tx, vec3(.5, p.y, -p.x));\n}\n\nvec4 tx2B(samplerCube tx, vec2 p){    \n\n    p = (floor(p*1024.) + .5)/1024.;\n    p = fract(p) - .5;\n    \n    return textureLod(tx, vec3(p.x, -.5, p.y), 0.);\n    //return texture(tx, vec3(.5, p.y, -p.x));\n}\n*/\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n\n// Based on IQ's hash formula.\nvec4 hash42B(vec4 p){ \n\n    p = (floor(p*1024.) + .5)/1024.;\n  \n    p = mod(p*repSc*GSCALE.x*2., repSc);\n   \n    p = vec4(dot(p.xy, vec2(27.619, 113.583)), dot(p.xy, vec2(57.527, 85.491)),\n             dot(p.zw, vec2(27.619, 113.583)), dot(p.zw, vec2(57.527, 85.491)));\n                                                  \n    p = fract(sin(p)*43758.5453)*2. - 1.; \n    return p;\n    \n    \n    //return sin(p*6.2831853 + gTime);//mix(p, sin(p*6.2831853 + iTime), .35);\n    \n}\n\n\n// vec2 to vec2 hash.\nvec2 hash22C(vec2 p) { \n\n    p = mod(p, repSc);\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    vec2 n = sin(vec2(dot(p, vec2(27.29, 57.81)), dot(p, vec2(7.14, 113.43))));\n    return fract(vec2(262144.1397, 32768.8793)*n)*2. - 1.; \n    \n    // Animated.\n    //p = fract(vec2(262144, 32768)*n);\n    //return sin(p*6.2831853 + gTime); \n    \n}\n\n// Based on IQ's gradient noise formula.\nfloat n2D3G( in vec2 p ){\n   \n    vec2 i = floor(p); p -= i;\n    \n    vec4 v;\n    v.x = dot(hash22C(i), p);\n    v.y = dot(hash22C(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22C(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22C(i + 1.), p - 1.);\n\n#if 1\n    // Quintic interpolation.\n    p = p*p*p*(p*(p*6. - 15.) + 10.);\n#else\n    // Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n#endif\n\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n    \n}\n\n\n// Height map. Just some gradient noise. \n// By the way, because this is precalculated, you could\n// make this as extravagent as you wished.\nfloat hm(in vec2 p){ \n   \n\n    p *= repSc;\n    return n2D3G(p)*.5 + .5;\n \n    //return (n2D3G(p)*.66 + n2D3G(p*2.)*.34)*.5 + .5;\n/*    \n    // We're going for simplicity, so just a couple of\n    // noise layers. The bottom layer is hollowd out a\n    // bit to give a basin like feel.\n    float h = smoothstep(.08, 1., n2D3G(p)*.5 + .5);\n    h = mix(h, n2D3G(p*2.)*.5 + .5, .33);\n    #ifdef QUANTIZE_HEIGHT\n    h = floor(h*31.999)/31.; // Discreet heights.\n    #endif\n   \n    return h;\n*/    \n}\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2(sdf, abs(pz) - h);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .002;\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n    */\n}\n\n// IQ's distance to a regular pentagon, without trigonometric functions. \n// Other distances here:\n// https://iquilezles.org/articles/distfunctions2d\n//\n#define NV 6\n//\nfloat sdPoly(in vec2 p, in vec2[NV] v){\n\n    const int num = v.length();\n    float d = dot(p - v[0],p - v[0]);\n    float s = 1.0;\n    for( int i = 0, j = num - 1; i < num; j = i, i++){\n    \n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e, e), 0., 1. );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\n\n/*\n// IQ's unsigned box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n\n// IQ's standard box function.\nfloat sBox(in vec2 p, in vec2 b){\n   \n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// This will draw a box (no caps) of width \"ew\" from point \"a \"to \"b\". I hacked\n// it together pretty quickly. It seems to work, but I'm pretty sure it could be\n// improved on. In fact, if anyone would like to do that, I'd be grateful. :)\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew){\n    \n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n   \n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n*/\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n\n\n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed objects.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n\n// For a 2D extruded block tiling four objects are needed. For the Cairo tiling,\n// each block needs to be subdivided into two seperate pentagonal pieces, so \n// that's eight pentagon distances all up. Since there are no vec8 containers in \n// WebGL, we need to make one. By the way, for regular 2D Cairo tiles, you only \n// need four or even two, depending what you're trying to do.\n//\nstruct vect8{ vec4 distA; vec4 distB; vec4 distC; };\n\n\nvect8 df(vec2 q){\n    \n    \n    // Block dimension: Length to height ratio with additional scaling. By the way,\n    // I'm being sneaky here and not applying the vec2(.8660254, 1) stretch scaling\n    // that gives you proper scaled hexagons. One reason is that they're mutated by\n    // the offset vertices anyway, and the main one is that it makes wrapping more\n    // difficult. Not impossible, but more complicated.\n\tconst vec2 dim = GSCALE;\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = dim*2.; \n   \n\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual block ID.\n    vec2 cntr = vec2(0);\n\n    \n    // Four block corner postions.\n    const vec2 ll = vec2(.5);\n    //vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll, -ll, vec2(ll.x, -ll.y));\n    #ifdef FLAT_TOP\n    // Flat top.\n    vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll + vec2(0., ll.y), -ll, vec2(ll.x, -ll.y) + vec2(0., ll.y));\n    #else\n    // Pointed top.\n    vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll, -ll + vec2(ll.x, 0), vec2(ll.x, -ll.y) + vec2(ll.x, 0));\n    #endif\n    \n    // The tile struct.\n    vect8 tile;\n    \n   \n    for(int i = 0; i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2.; \n        \n        p = q.xy; // Local coordinates.\n        ip = floor(p/s - cntr) + .5; // Local tile ID.\n        p -= (ip + cntr)*s; // New local position.\n        \n        // Correct positional individual tile ID.\n        vec2 idi = ip + cntr;\n \n        // Hexagon vertices. \n        vec4[3] vert = vID; \n        \n        #ifdef OFFSET_VERTICES\n        // Offsetting the vertices. Note that accuracy is important here. I had a bug for\n        // a while because I was premultiplying by \"s,\" to save some calculations, which meant\n        // points were not quite meeting at the joins... I won't bore you with the rest,\n        // except to say that it's necessary to keep these numbers simple.\n        const float vo = .15;\n        vec4 vrt0 = idi.xyxy + vert[0]/2.;\n        vec4 vrt1 = idi.xyxy + vert[1]/2.;\n        vec4 vrt2 = idi.xyxy + vert[2]/2.;\n        vrt0 = hash42B(vrt0);\n        vrt1 = hash42B(vrt1);\n        vrt2 = hash42B(vrt2);\n        vert[0] += vrt0*vo;\n   \t\tvert[1] += vrt1*vo;\n        vert[2] += vrt2*vo;\n        #endif \n        \n        // Scaling to enable rendering back in normal space.\n        vert[0] *= dim.xyxy;\n        vert[1] *= dim.xyxy;\n        vert[2] *= dim.xyxy; \n        \n        // Scaling the ID.\n\t    idi *= s;\n \n  \n          \n        // Hexagon vertices.\n        vec2[6] v1 = vec2[6](vert[0].xy, vert[0].zw, vert[1].xy, vert[1].zw, vert[2].xy, vert[2].zw);\n        \n\n        // Moving the vertices in to help create rounded hexagons. Rounded offset hexgons can\n        // be created by simply adding a factor to the distance field. Unfortunately, in a \n        // packed grid, that would create overlap, so it's necessary to move the points in\n        // first, then add the amount. This is less trivial, as you can see, but is just a\n        // bit of trigonometry. The following is robust, but was something I came up with on\n        // the spot, so if anyone knows of a more elegant way, feel free to let me know.\n        // Remember that this is just a one-off precalculation, so speed isn't a factor.\n        const float ndg = .0175*8.*GSCALE.x;\n        vec2[6] tmpV;\n        \n        for(int j = 0; j<6; j++){\n            \n            // Vertices and flanking neighbors.\n            vec2 g = v1[j];\n            vec2 g1 = v1[(j + 1)%6];\n            vec2 g2 = v1[(j + 5)%6];\n            vec2 nj = normalize(g1 - g); // Tangent vector.\n         \n            // Move the vertices in the direction of the tangent vector\n            // by the nudge factor.\n            vec2 v1 = g - g1;\n            vec2 v2 = g - g2;\n            // Angle between vectors.\n            float ang = acos(dot(v1, v2)/length(v1)/length(v2));\n            float sl = ndg/tan(ang/2.);\n            tmpV[j] = g + sl*nj + ndg*nj.yx*vec2(1, -1);\n        }\n                               \n        v1 = tmpV;                 \n\n        float face1 = sdPoly(p, v1);\n        // float face1 =  sHexS(p, scale/2.);\n        face1 -= ndg*.9;\n        tile.distA[i] = face1;\n        \n        // No precalculated heights for this example, since we'll be reading\n        // from a precalculated texture in the \"Image\" tab.\n        /*\n        // Using the original outer vertices for the offset factor.\n        vec2 inC = vec2(0);//(vert[0].xy + vert[0].zw + vert[1].xy + vert[1].zw + vert[2].xy + vert[2].zw)/6.;\n        vec2 idi1 = idi + inC.xy;\n        float h = hm(idi1);\n        tile.distB[i] = h;\n        */\n        \n        \n    }\n    \n    // Return the tile struct.\n    return tile;\n\n}\n\n\n\n// Cube mapping for face identification - Adapted from one of Fizzer's routines. \nint CubeFaceCoords(vec3 p){\n\n    // Elegant cubic space stepping trick, as seen in many voxel related examples.\n    vec3 f = abs(p); f = step(f.zxy, f)*step(f.yzx, f); \n    \n    ivec3 idF = ivec3(p.x<.0? 0 : 1, p.y<.0? 2 : 3, p.z<0.? 4 : 5);\n    \n    return f.x>.5? idF.x : f.y>.5? idF.y : idF.z; \n}\n\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir){\n    \n    \n    // UV coordinates.\n    //\n    // For whatever reason (which I'd love expained), the Y coordinates flip each\n    // frame if I don't negate the coordinates here -- I'm assuming this is internal, \n    // a VFlip thing, or there's something I'm missing. If there are experts out there, \n    // any feedback would be welcome. :)\n    vec2 uv = fract(fragCoord/iResolution.y*vec2(1, -1));\n    \n    // Adapting one of Fizzer's old cube mapping routines to obtain the cube face ID \n    // from the ray direction vector.\n    int faceID = CubeFaceCoords(rayDir);\n    \n    \n    // Setting the global time variable so that the \"Common\" tab can recognize time.\n    setTime(iTime);\n  \n    // Pixel storage.\n    vec4 col;\n   \n    // Initial conditions -- Performed just the once upon initialization.\n    //if(abs(tx(iChannel0, uv).w - iResolution.y)>.001){\n    //\n    // IQ gave me the following tip, which saved me a heap of trouble and an extra channel. \n    // I'm not sure how he figured this out, but he pretty much knows everything. :D\n    //\n    // If the texture hasn't loaded, or if we're on the first frame, initialize whatever \n    // you wish to initialize. In this case, I'm precalculating an expensive distance\n    // field and storing it in some of the cube map faces.\n    if(textureSize(iChannel0, 0).x<2 || iFrame<1){\n        \n        // INITIALIZING.\n        \n        // Construct a distance field, then store it.\n    \tvect8 d = df(uv);\n        \n        if(faceID == 0) col = d.distA; // Distance fields.\n    \n        if(faceID == 5) col = vec4(1)*hm(uv);//d.distB; // Pylon heights.\n    \n        \n        //repSc = 1024.;\n        //if(faceID == 1) {\n            //col = vec4(1)*hm(uv*repSc);//hm(iChannel1, uv*repSc)\n        //}\n     \n    }\n    else {\n        if(faceID == 0) col = tx0(iChannel0, uv);\n        if(faceID == 5) col = tx5(iChannel0, uv);//vec4(1)*hm(uv);//\n        //if(faceID == 1) col = tx1(iChannel0, uv);\n    }\n\n\n    // Store in the cube map.\n    fragColor = col;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            }
        ],
        "ver": "0.1"
    }
}