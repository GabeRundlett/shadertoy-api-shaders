{
    "Shader": {
        "info": {
            "date": "1475777009",
            "description": "Part 06: Loops and arrays\nIntro to democoding using ShaderToy\nBy cxw/Incline - Demosplash 2016\n\nYes, this code is clunky!  I wrote it for explanation rather than for speed.",
            "flags": 0,
            "hasliked": 0,
            "id": "MlVGRK",
            "likes": 1,
            "name": "demosplash2016-cxw-06",
            "published": 3,
            "tags": [
                "tutorial",
                "demoparty"
            ],
            "usePreview": 0,
            "username": "cxw",
            "viewed": 524
        },
        "renderpass": [
            {
                "code": "precision highp int;precision highp float;\n\n// Parameters for your demo\n\n// blinds\n#define BLIND_CYCLE_TIME (3.0)\n    // Over this time (sec), the blinds will open and then close\n#define BLIND_RAMP_TIME (1.0)\n    // How long they take to open or close.  Keep it < BLIND_CYCLE_TIME/2.0\n#define NBLINDS (7)\n    // An integer!!!!!1!!\n#define BLIND_EDGE_STEP (0.14285714285714285714285714285714)\n    // 1/NBLINDS, precomputed to avoid division\n\n// moire\n#define THICKNESS (0.85)\n    // larger means narrower\n#define SPACING (200.0)\n    //ditto\n#define SPEED (0.6)\n    // Higher is faster\n\n// Computed parameters //////////////////////////////////////////////////\n#define BLIND_HALFCYCLE_TIME (BLIND_CYCLE_TIME*0.5)\n#define BLIND_END_RAMPDOWN_TIME (BLIND_HALFCYCLE_TIME + BLIND_RAMP_TIME)\n    // blinds begin closing halfway through the cycle, and are fully closed\n    // at BLIND_END_RAMPDOWN_TIME.\n#define BLIND_RAMP_RATE (1.0/BLIND_RAMP_TIME)\n    // Laziness!  For the release, precompute this since the shader\n    // may have lower precision than your calculator.\n\n// Transition: Vertical blinds //////////////////////////////////////////\n// Evenly-spaced vertical blinds can be done with mod().  Unevenly, though...\n\nfloat get_blind_mask(in float percent, in float x_01)\n{ // x_01 is X coord, 0..1 (not pixel).\n  // percent is how open the blinds are.  ** No time in this function! **\n  // return value is 0.0 for a pixel that is covered, and 1.0 for a pixel\n  // that is not covered.\n\n    float edges[NBLINDS+1];   // Array.  Can also be outside any function.\n        // Blind x goes from edges[x] to edges[x+1].\n        // edges[0]=0.0; edges[NBLINDS+1]=1.0.\n\n    // Init (each frame!).  Note: \"for\" loops are very fixed-form.\n    // Also note that \"break\" and \"continue\" work in loops.\n\n    for(int edge_idx = 0; edge_idx < NBLINDS+1; ++edge_idx) {\n        float edge_idx_f = float(edge_idx);   //explicit typecast\n        edges[edge_idx] = smoothstep(0.0, 1.0, edge_idx_f * BLIND_EDGE_STEP);\n    } //for each edge\n\n    // See if we are in a blind\n    for(int blind_idx = 0; blind_idx < NBLINDS; ++blind_idx) {\n        float left_edge = edges[blind_idx];\n        float right_edge = edges[blind_idx+1];\n        float center = mix(left_edge, right_edge, 0.5);\n        float open_left = mix(center, left_edge, percent);\n        float open_right = mix(center, right_edge, percent);\n        if( (x_01 >= open_left) && (x_01 <= open_right) ) {\n            return 1.0;     // This pixel is visible!\n        }\n    } //for each blind\n\n    return 0.0;     // If we get here, the pixel is hidden by the blinds.\n\n} //get_blind_mask\n\n// Effect: moire ////////////////////////////////////////////////////////\n\nfloat get_sine_01( in float time, in vec2 coords, in vec2 center, in float radius, in float speed) { float whereami = radius*distance(center,coords) - speed*time; return 0.5+0.5*sin(whereami); }\nfloat squish(in float f) { return (f+1.0)*0.5; }\nvec2 lisa(in float time, in float a, in float b, in float delta) { return vec2(squish(sin(a*time+delta)), squish (sin(b*time))); }\n\nvec4 moire(in float time, in vec2 pixel_coord_01 )\n{ //used to be mainImage() - now it's moire() and has a \"time\" parameter.\n    vec2 ca = lisa(time*0.5*SPEED,        5.0,4.0,0.0); vec2 cb = lisa(time*0.835744*SPEED,   3.0,2.0,1.8); cb = mix(ca, cb, 0.6); float sa = get_sine_01(time, pixel_coord_01, ca, SPACING, 10.0); float sb = get_sine_01(time, pixel_coord_01, cb, SPACING, 10.0); sa=step(THICKNESS,sa); sb=step(THICKNESS,sb); return vec4(max(sa,sb),0.0,0.0,1.0);\n} //moire\n\n// mainImage() //////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 pixel_coord_01 = fragCoord.xy / iResolution.xy;\n    fragColor = moire(t, pixel_coord_01);       // The effect\n\n    // Apply the mask\n\n    // Make a clipped, repeating triangular profile\n    float blind_time = mod(t, BLIND_CYCLE_TIME);        //the repeat\n    float blind_rise = blind_time * BLIND_RAMP_RATE;    //ramp up\n    float blind_fall = (BLIND_END_RAMPDOWN_TIME - blind_time) * BLIND_RAMP_RATE;\n                                                        //ramp down\n    float blind_percent = clamp(min(blind_rise, blind_fall), 0.0, 1.0);\n                                                        //clip\n    // Is this pixel visible through the blinds?\n    float blind_mask = get_blind_mask(blind_percent, pixel_coord_01.x);\n\n    //Black out masked pixels\n    fragColor = mix(vec4(0.0), fragColor, blind_mask);\n        // use fragColor = vec4(vec3(blind_percent),1.0); to see just one value\n} //mainImage\n\n// vi: set ts=4 sts=4 sw=4 et ai: //\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}