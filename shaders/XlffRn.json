{
    "Shader": {
        "info": {
            "date": "1510782086",
            "description": "spAGHeTiCOoODE",
            "flags": 0,
            "hasliked": 0,
            "id": "XlffRn",
            "likes": 9,
            "name": "Future Floppy",
            "published": 3,
            "tags": [
                "grid",
                "neon",
                "floppy",
                "discette"
            ],
            "usePreview": 1,
            "username": "DrLuke",
            "viewed": 771
        },
        "renderpass": [
            {
                "code": "// This work is licensed under a Creative Commons Attribution 4.0 International License.\n// https://creativecommons.org/licenses/by/4.0/\n\n// Inspiration: http://kingsanda.tumblr.com/image/163796736752\n\n#define PI 3.14159\n#define PI2 (2.*PI)\n\nmat2 rot2(float angle)\n{\n    return mat2( cos( angle ), -sin( angle ), sin( angle ),  cos( angle ));\n}\n\n\n#define box1(uv) step(-1., uv.x) * step(-1., -uv.x) * step(-1., uv.y) * step(-1., -uv.y)\nfloat gridRoom(vec2 uv)\n{\t\n    #define FACES 4.\n    #define ANIMPANGLE (iTime*0.)\n    #define PANGLE (round(FACES*(atan(uv.y, -uv.x) - PI2*0.25 + ANIMPANGLE)/PI2)/FACES*PI2 - ANIMPANGLE)\n    #define PLANEPOS vec3(rot2(PANGLE)*vec2(0,-1),0)\n    #define PLANENOR vec3(rot2(PANGLE)*vec2(0,1),0)\n   \n    vec3 dir = vec3(uv.x, uv.y, 1.);\n    vec3 p0 = vec3(0);\n    \n    float d = dot((PLANEPOS - p0), PLANENOR) / dot(dir, PLANENOR);\t// Calculate multiples of dir to intersection with plane\n    vec3 p = p0 + dir*d;\t// Point of line-plane intersection\n    \n    float v = smoothstep(0.98, 0.99, abs(uv.x)) + smoothstep(0.98, 0.99, abs(uv.y));\n    \n    #define LINEC 4.\n    #define URX ((rot2(-PANGLE)*p.xy).x)\n    #define W 0.95\n    #define F 0.03\n    v += smoothstep(W-F, W+F, abs(fract(URX*LINEC)-0.5)*2.);\n    v += smoothstep(W-F, W+F, abs(fract(p.z*LINEC)-0.5)*2.);\n\n    #define ZCUTOFF 3.0\n    if(p.z < -ZCUTOFF)\n    {\n        v = smoothstep(W-F, W+F, abs(fract(uv.x*LINEC*ZCUTOFF)-0.5)*2.);\n        v += smoothstep(W-F, W+F, abs(fract(uv.y*LINEC*ZCUTOFF)-0.5)*2.);\n    }\n    \n    return min(1., v * box1(uv));\n}\n\nfloat gridRoomAA(vec2 uv)\n{\n    #define Xsamps 1\n    #define Ysamps 1\n    #define Xoff (1./float(2*Xsamps + 1)*float(i))\n    #define Yoff (1./float(2*Ysamps + 1)*float(j))\n    #define PXSIZE ( (vec2(1) / iResolution.xy) * (iResolution.x/iResolution.y) )\n    \n    float v = 0.0;\n    for(int i=-Xsamps; i <= Xsamps; i++)\n    for(int j=-Ysamps; j <= Ysamps; j++)\n    {\n        v += gridRoom(uv + vec2(Xoff, Yoff) * PXSIZE);\n    }\n    \n    return v / float((2*Xsamps + 1) * (2*Ysamps + 1));\n}\n\n// Distance functions from: https://www.shadertoy.com/view/4dfXDn\nfloat sdBox(vec2 p, vec2 size, float radius)\n{\n\tsize -= vec2(radius);\n\tvec2 d = abs(p) - size;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\nfloat sdLine(vec2 p, vec2 start, vec2 end, float width)\n{\n\tvec2 dir = start - end;\n\tfloat lngth = length(dir);\n\tdir /= lngth;\n\tvec2 proj = max(0.0, min(lngth, dot((start - p), dir))) * dir;\n\treturn length( (start - p) - proj ) - (width / 2.0);\n}\n\nfloat sdCircle(vec2 p, float radius)\n{\n\treturn length(p) - radius;\n}\n\nvec4 futureFloppy(vec2 uv, vec2 fragCoord)\n{\n    if(abs(uv.x) > 1.) return vec4(0);\t// Out of bounds\n    \n    #define FLOPPYTIME\tfract(iTime*0.05)\n    #define ENDY -0.\n    #define ZDEPTH ZCUTOFF\n    #define STARTY -0.6 + smoothstep(0., 1., FLOPPYTIME*1.5)*0.6\n    \n    #define FPLANEPOS vec3(0, STARTY,0)\n    #define FPLANENOR vec3(0.,ZDEPTH,STARTY-ENDY)\n    \n    vec3 dir = vec3(uv.x, uv.y, 1.5);\n    vec3 p0 = vec3(0);\n    \n    float d = dot((FPLANEPOS - p0), FPLANENOR) / dot(dir, FPLANENOR);\t// Calculate multiples of dir to intersection with plane\n    vec3 p = p0 + dir*d;\t// Point of line-plane intersection\n    \n\n    #define OFFSET mod(vec2(0, 6.*FLOPPYTIME), 6.)\n    #define SCALE 0.4\n    float bDist = sdBox(p.xz - OFFSET, vec2(0.5)*SCALE, 0.02*SCALE);\n    float mainBody = 1.-smoothstep(-0.001, 0.001, bDist);\n    vec3 mainBodyC = vec3(0.09) + texture(iChannel0, (p.xz - OFFSET)*4.).r *\n         vec3(.1,0,0)* (1.-dot(normalize(dir), normalize(-FPLANENOR) ));\n    mainBodyC *= vec3(1.-length(p.xz - OFFSET)*2.);\n    vec3 outCol = mainBodyC;\n    \n    float lineThingy = 1.-smoothstep(-0.002, 0.002, sdLine(p.xz - OFFSET, vec2(0, -0.25)*SCALE, vec2(0, -0.44)*SCALE, 0.07*SCALE));\n    vec3 lineThingyC = vec3(0.85, 0.8, 0.8) * (1.-dot(normalize(dir), normalize(-FPLANENOR) ));\n    outCol = mix(outCol, lineThingyC, lineThingy);\n    \n    float holeRim = 1.-smoothstep(-0.002, 0.002, sdCircle(p.xz - OFFSET, 0.14*SCALE));\n    vec3 holeRimC = vec3(0.54, 0.6, 0.5)*0.6;\n    outCol = mix(outCol, holeRimC, holeRim);\n    \n    float hole = 1.-smoothstep(-0.002, 0.002, sdCircle(p.xz - OFFSET, 0.1*SCALE));\n    \n    // Trail\n    #define TRAILLEN 1.2\n    #define NOISE (texture(iChannel0, (p.xz - OFFSET)/vec2(4., 16.) + vec2(0, p.z*0.1)).r-0.5)\n    float tDist = sdBox(p.xz - OFFSET + vec2(0, 0.5 + TRAILLEN)*SCALE, vec2(0.5, TRAILLEN)*SCALE, 0.02*SCALE);\n    float falloff = (p.z - OFFSET.y + 0.5*SCALE + TRAILLEN*SCALE)/(TRAILLEN*SCALE) *step(0., -uv.y);//* (cos(p.x*PI2)*0.5+0.5);\n    float trail = (1.-smoothstep(-0.001, 0.001, tDist)) * falloff;\n    vec3 trailC = mix(vec3(0.1,0.2,1)*0.7, lineThingyC*1.4, smoothstep(0.007, 0.002, abs(p.x)*SCALE + 0.001 - falloff*0.002)) + (NOISE*smoothstep(0.5, 1., (1.-trail)) );\n    outCol = mix(outCol, trailC, trail);\n    \n    float diskmask = (mainBody-hole+trail) * (1.-step(3., p.z));\n    \n    // Insertion glow\n    float insertdist = sdBox(uv, vec2(0.12, 0.0), 0.01);\n    float insertmask = 0.;\n    if(OFFSET.y > 2.5 && OFFSET.y < 3.5)\n    {\n        #define IRAMP 0.1\n        float intensity = smoothstep(2.5, 2.5+IRAMP, OFFSET.y);\n        intensity -= smoothstep(3.5-IRAMP, 3.5, OFFSET.y);\n        insertmask = (1.-smoothstep(0.0, 0.007, insertdist))*intensity;\n        #define INSERTCOL vec3(1., 1., 1.5)\n        outCol = mix(clamp(INSERTCOL*intensity,0.,1.), outCol, diskmask);\n    }\n\n    \n    #define DITH ((texture(iChannel0, fragCoord/iChannelResolution[0].xy).rgb-0.5)/255.)\n    return vec4(outCol + DITH, clamp(diskmask+insertmask, 0., 1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy*2. / iResolution.xy) - vec2(1);\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 1.1;\n    \n    #define GRIDCOL vec3(0.6,0,0)\n    \n\tfragColor = vec4(gridRoomAA(uv)*GRIDCOL, 1.);\n    vec4 fl = futureFloppy(uv, fragCoord);\n    fragColor.rgb = mix(fragColor.rgb, fl.rgb, clamp(fl.a,0.,1.));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}