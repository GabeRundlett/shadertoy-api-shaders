{
    "Shader": {
        "info": {
            "date": "1466849689",
            "description": "Here goes 6 months worth of lunch time programming !\nSort of procedural animation and a healthy dose of @SebHillaire volumetric light integration.",
            "flags": 0,
            "hasliked": 0,
            "id": "lsVXRh",
            "likes": 211,
            "name": "Lightsaber Duel",
            "published": 3,
            "tags": [
                "animation",
                "starwars",
                "lightsaber",
                "tux"
            ],
            "usePreview": 1,
            "username": "Maurogik",
            "viewed": 21640
        },
        "renderpass": [
            {
                "code": "\n#define FOCAL_LENGTH 1.2\n#define MOVE_SPEED 20.0\n#define MAX_STEPS 256\n#define MIN_DIST 0.01\n#define MAX_DIST 75.0\n#define AMBIANT_LIGHT 0.01\n#define DAY_LENGTH 15.0 \n\n#define PI 3.14159265359\n\n//comment this out if your GPU can't handle the shader,\n//you'll only get ont character, but it should run much faster\n#define TWO_EGGS\n\n//quality settings, uncomment higher quality for better results\n//or comment out higher quality for better performances\n\n//#define QUALITY_HIGH\n#define QUALITY_MEDIUM \n//#define QUALITY_LOW \n//#define QUALITY_OFF\n\n#if defined(QUALITY_HIGH)\n\n\t#define VOL_SHADOW_STEPS 5.0\n\t#define MIN_STEP_BIAS 0.3\n\t#define VOL_FOG 1\n\t#define VOL_SHADOW 1\n\t#define LIGHT_QUALITY 1\n\n#elif defined(QUALITY_MEDIUM)\n\n\t#define VOL_SHADOW_STEPS 2.0\n\t#define MIN_STEP_BIAS 0.6\n\t#define VOL_FOG 1\n\t#define VOL_SHADOW 1\n\t#define LIGHT_QUALITY 1\n\n#elif defined(QUALITY_LOW)\n\n\t#define VOL_SHADOW_STEPS 1.0\n\t#define MIN_STEP_BIAS 0.9\n\t#define VOL_FOG 1\n\t#define VOL_SHADOW 0\n\t#define LIGHT_QUALITY 0\n\n#elif defined(QUALITY_OFF)\n\n\t#define VOL_SHADOW_STEPS 1.0\n\t#define MIN_STEP_BIAS 1.0\n\t#define VOL_FOG 0\n\t#define VOL_SHADOW 0\n\t#define LIGHT_QUALITY 0\n\n#endif\n\n//saber colors\n#define LASER_STR 1.5\n#define LASER_CORE vec3(0.5)\n#define LASER_LIGHT_STR 1.5\n#define PURPLE vec3(0.5, 0.0, 1.5)\n#define GREEN vec3(0.0, 1.0, 0.0)\n#define BLUE vec3(0., 0., 1.0)*2.\n#define RED vec3(1.0, 0.0, 0.0)*1.5\n#define YELLOW vec3(0.6, 0.6, 0.0)\n\n//paste in one of the colors from above\n#define JEDI GREEN\n#define SITH RED\n\n#define JEDI_SABER_NOISE 2.\n#define SITH_SABER_NOISE 5.\n\n//helpers\nvec3 zero = vec3(0.0);\n\n//scene data\nvec3 projectionUp;\nvec3 projectionRight;\nvec3 projectionForward;\nvec3 projectionCenter;\nvec3 cameraOffset;\nfloat dayProgress;\nfloat minSurfaceDist;\n\n//positions\nvec4  plane         = vec4(vec3(0.0, 1.0, 0.0), 1.0);\nvec3  sunLightPos;\n\n//colors\nvec4 groundColor    = vec4(vec3(0.08), 0.7);\nvec4 handleColor    = vec4(vec3(0.1), 0.3);\nvec3 sunLightColor;\nvec3 skyColor;\nvec3 fogColor;\n\nfloat s_pixelRand = 0.0;\nfloat s_time = 0.0;\n\nfloat mapToRange(float fromMin, float fromMax, float toMin, float toMax, float val)\n{\n    val = max(fromMin, (min(fromMax, val)));//clamp in range if outside\n    float fromSize = fromMax - fromMin;\n    val = (val - fromMin) / fromSize;\n    return mix(toMin, toMax, val);\n}\n\n//fast noise\nvec3 noise3( in vec3 x )\n{\n    return textureLod(iChannel0, x.xy/x.z, 0.0).xyz;   \n}\n\n//////////////////////////////\n\n#if VOL_FOG\n\nfloat layeredNoise( vec3 p )\n{\n    float f;\n    f  = 0.5000* textureLod( iChannel1, p, 0.0 ).x; p = p*2.0;\n    f += 0.2500* textureLod( iChannel1, p, 0.0 ).x; p = p*2.0;\n    f += 0.1250* textureLod( iChannel1, p, 0.0 ).x; p = p*2.0;\n    f += 0.0800* textureLod( iChannel1, p, 0.0 ).x; p = p*2.0;\n    f += 0.0625* textureLod( iChannel1, p, 0.0 ).x; p = p*2.0;\n    \n    return f;\n}\n\n#define CONSTANT_FOG 0.03\n// To simplify: wavelength independent scattering and extinction\nfloat atmThickness(in vec3 pos)\n{\n    float disp1 = 0.5;\n    float disp2 = 0.5;\n    \n    //disp1 = mapToRange(0.5, 1.0, 0.1, 1.0, layeredNoise(pos.xz*0.015 + s_time*0.008));\n    disp1 = mapToRange(0.3, 1.0, 0.1, 1.0, layeredNoise(pos*0.02 - vec3(0.0, 1.0, 0.0)*s_time*0.01));\n    //float noise = clamp(mapToRange(0.4, 0.8, 0.0, 1.0, disp2),0.0,1.0);\n    float fogMax  = -1. - smoothstep(8.0, -3.0, length(pos.xz));\n   \tfloat fogMin = fogMax + disp1*3.0;    \n    float heightFog = smoothstep(fogMin, fogMax, pos.y);\n\n    heightFog = min(1.0, heightFog * 3.0);\n    \n    return CONSTANT_FOG + heightFog * 2.0;  \n}\n\nfloat phaseFunctionVal = 1.0/(4.0*PI);\n#define PHASE_FUNC phaseFunctionVal\n\nfloat volumetricShadow(in vec3 from, in vec3 dir)\n{\n    float shadow = 1.0;\n    float cloud = 0.0;\n    float dd = 1.0 / VOL_SHADOW_STEPS;    \n    vec3 pos;\n    for(float s=0.5; s < VOL_SHADOW_STEPS - 0.1; s+=1.0)// start at 0.5 to sample at center of integral part\n    {\n        pos = from + dir*(s/VOL_SHADOW_STEPS);\n        cloud = atmThickness(pos);\n        shadow *= exp(-cloud * dd);\n    }\n    return shadow;\n}\n\n#endif \n\n////////////////////////////////\n\nvec2 pixelToNormalizedspace(vec2 pixel)\n{\n    vec2 res;\n    res.x = pixel.x * 2.0 / iResolution.x - 1.0;\n    res.y = pixel.y * 2.0 / iResolution.y - 1.0;\n    res.y *= iResolution.y / iResolution.x;//correct aspect ratio\n    return res;\n}\n\nfloat fCapsule(vec3 p, float r, float c) {\n    return mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\nfloat fSphere(vec3 d, float r)\n{\n    return length(d) - r;\n}\n\nfloat fPlane(vec4 plane, vec3 point)\n{    \n    return abs(dot(plane, vec4(point, 1.0)));\n}\n\n// Hexagonal prism, circumcircle variant\nfloat fHexagonCircumcircle(vec3 p, vec2 h) {\n\tvec3 q = abs(p);\n\t//return max(q.y - h.y, max(q.x*sqrt(3)*0.5 + q.z*0.5, q.z) - h.x);\n\t//this is mathematically equivalent to this line, but less efficient:\n\treturn max(q.y - h.y, max(dot(vec2(cos(PI/3.0), sin(PI/3.0)), q.zx), q.z) - h.x);\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n//////////////////////////////\n\nfloat linearstep(float e1, float e2, float v)\n{\n \tv = clamp(v, e1, e2);\n    return (v - e1)/(e2 - e1);\n}\n\nfloat fEgg(vec3 d, float r, vec3 deform)\n{\n    return length(d/deform) - r;\n}\n\n#define IMAT3 mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0))\n\nfloat maxDist = 100.0;\n\n//constants\nfloat   handRSize = 0.15;\nfloat   handLSize = 0.15;\nfloat   footRSize = 0.22;\nfloat   footLSize = 0.22;\nvec3    eyeRPos = vec3(0.2, 0.2, 0.0);\nvec3    eyeLPos = vec3(-0.2, 0.2, 0.0);\nfloat   eyeRSize = 0.105;\nfloat   eyeLSize = 0.105;\nvec3    mouthPos = vec3(0.0, 0.0, -0.03);\nfloat   mouthSize = 0.1;\nfloat   mouthXRot = PI*0.325;\nfloat   handleRadius = 0.1;\nfloat   handleLen = 0.35;   \nvec4 \tbodyColor = vec4(vec3(0.1), 0.8);\nvec4    eyeColor = vec4(vec3(0.9), 0.1);\nvec4    eyeInsideColor = vec4(vec3(0.1), 0.1);\nvec4\tmouthColor = vec4(1.0, 1.0, 0.0, 0.1);\n\nstruct StickmanData\n{\n    vec3 stickmanPos;\n    //relative to stickManPos\n    vec3 bodyPos;\n    vec3 bodyDeform;\n    vec3 headPos;\n    vec3 handRPos;\n    vec3 handLPos;\n    vec3 handRDeform;\n    vec3 handLDeform;\n    mat3 handRRot;\n    mat3 handLRot;\n\n    vec3 footRPos;\n    vec3 footLPos;\n    mat3 footRRot;\n    mat3 footLRot;\n    vec3 footRDeform;\n    vec3 footLDeform;\n\n    mat3 invBodyRot;\n    mat3 invStickmanRot;\n    mat3 invMouthRot;\n\n    //relative to headPos\n\n    vec3 eyeRDeform;\n    vec3 eyeLDeform;\n    \n    vec3 mouthDeform;    \n\n    vec3 saberTarget;\n    vec3 saberPos;\n    float saberRadius;\n    float saberLen;\n    float saberNoise;\n    mat3 invSaberRot;\n    \n    vec3 laserColor;\n    vec3 laserLight;\n};\n\nStickmanData jediData;\nStickmanData sithData;\n\nstruct FieldData\n{\n    vec3 saberDiff;\n    vec3 saberOffset;\n    vec3 handleOffset;\n    float fSaber;\n};\n    \nFieldData jediFieldData;\nFieldData sithFieldData;\n    \nvoid rotationZ(float r, out mat3 mat)\n{\n    mat[0].x = cos(r);  mat[0].y = sin(r);  mat[0].z = 0.;\n    mat[1].x = -sin(r); mat[1].y = cos(r);  mat[1].z = 0.;\n    mat[2].x = 0.;      mat[2].y = 0.;      mat[2].z = 1.;\n}\n\nvoid rotationY(float r, out mat3 mat)\n{\n    mat[0].x = cos(r);  mat[0].y = 0.;      mat[0].z = -sin(r);\n    mat[1].x = 0.;      mat[1].y = 1.;      mat[1].z = 0.;\n    mat[2].x = sin(r);  mat[2].y = 0.;      mat[2].z = cos(r);\n}\n\nvoid rotationX(float r, out mat3 mat)\n{\n    mat[0].x = 1.;      mat[0].y = 0.;      mat[0].z = 0.;\n    mat[1].x = 0.;      mat[1].y = cos(r);  mat[1].z = sin(r);\n    mat[2].x = 0.;      mat[2].y = -sin(r); mat[2].z = cos(r);\n}\n\n//wonderfull function from iq's article \n//https://iquilezles.org/articles/noacos\nvoid rotationAlign( vec3 d, vec3 z, out mat3 mat )\n{\n    vec3  v = cross( z, d );\n    float c = dot( z, d );\n    float k = 1./(1. + c);\n\n    mat = mat3(    v.x*v.x*k + c,     v.y*v.x*k - v.z,    v.z*v.x*k + v.y,\n                   v.x*v.y*k + v.z,   v.y*v.y*k + c,      v.z*v.y*k - v.x,\n                   v.x*v.z*k - v.y,   v.y*v.z*k + v.x,    v.z*v.z*k + c    );\n}\n\n//ugly hack to get partial look at rotation, works well enough\nvoid rotationAlign( vec3 targ, vec3 dir, float i, out mat3 mat )\n{\n    vec3 diff = targ - dir;\n    if(dot(diff, diff) > 0.1)\n    {\n \t\tvec3 mixed = normalize(mix(targ, dir, 1.0 - i));\n    \trotationAlign(mixed, dir, mat);\n    }\n    else\n    {\n        mat = IMAT3;\n    }\n}\n\n//pre-computes field data that doesn't change during the raymarching\nvoid computeFieldData(in StickmanData data, out FieldData fieldData)\n{\n    fieldData.saberDiff = data.bodyPos + data.saberPos*data.bodyDeform;\n    fieldData.saberOffset = vec3(0.0, -data.saberLen - handleLen, 0.0);\n    fieldData.handleOffset = vec3(0.0, handleLen*0.5, 0.0);\n    fieldData.fSaber = MAX_DIST;\n}\n\nfloat fSaber(vec3 d, in StickmanData data, in FieldData fieldData)\n{\n    vec3 saberDiff = d - fieldData.saberDiff;\n    saberDiff = data.invSaberRot*saberDiff;\n    float saber = fCapsule(saberDiff + fieldData.saberOffset,\n                           data.saberRadius\n                           *(pow(mapToRange(data.saberLen*1.95, data.saberLen*2.+handleLen, 1.0, 0.01, saberDiff.y), 0.35)) \n                           *mapToRange(0.0, 1.0, 0.85, 1., sin(s_time*30.-saberDiff.y*data.saberNoise)),\n                           data.saberLen);\n    \n    return saber;\n}\n\nfloat fHandle(vec3 d, in StickmanData data, in FieldData fieldData)\n{\n    vec3 saberDiff = d - fieldData.saberDiff;\n    saberDiff = data.invSaberRot*saberDiff;\n    float handle = fCapsule(saberDiff + fieldData.handleOffset,\n                           handleRadius, \n                           handleLen);\n    return handle;\n}\n\nvec4 fStickman(vec3 d, in StickmanData data, in FieldData fieldData, inout float minDist)\n{\n    float r = s_time * 3.14 * 0.5;        \n    \n    vec3 bodyD = data.invBodyRot*(d - data.bodyPos);\n    vec3 fixedBodyD = d - data.bodyPos;\n    //main body\n    float body = fEgg(bodyD, 1.0, data.bodyDeform); \n    float subBody = fEgg(bodyD + vec3(0.0, 0.6, 0.5), 1.0, data.bodyDeform*vec3(0.8, 0.8, 0.8));\n    //eyes\n    float eye = fEgg(bodyD - (data.headPos + eyeLPos)*data.bodyDeform, eyeLSize, data.eyeLDeform);   \n    eye = min(eye, fEgg(bodyD - (data.headPos + eyeRPos)*data.bodyDeform, eyeRSize, data.eyeRDeform));\n    \n    float subEye = fEgg(bodyD - (data.headPos + eyeLPos + vec3(0.07, -0.03 , -0.1))*data.bodyDeform, \n                        eyeLSize, data.eyeLDeform*vec3(0.3, 0.4, 0.3));    \n    subEye = min(subEye, fEgg(bodyD - (data.headPos + eyeRPos + vec3(-0.07, -0.03 , -0.1))*data.bodyDeform, \n                        eyeLSize, data.eyeLDeform*vec3(0.3, 0.4, 0.3)));    \n    eye = min(eye, subEye);\n    \n    //mouth\n    float mouth = fEgg(\n        data.invMouthRot*(bodyD - (data.headPos + mouthPos)*data.bodyDeform),\n        mouthSize, data.mouthDeform);\n    \n    //hands\n    float hands;\n    hands = fEgg(data.handRRot*(fixedBodyD - data.handRPos*data.bodyDeform), \n                          handRSize, data.handRDeform);\n    hands = min(hands, fEgg(data.handLRot*(fixedBodyD - data.handLPos*data.bodyDeform),  \n                          handLSize, data.handLDeform));\n    //feet  \n    float feet;\n    feet = fEgg(data.footRRot*(d - (data.footRPos)),\n                          footRSize, data.footRDeform);\n    feet = min(feet, fEgg(data.footLRot*(d - (data.footLPos)),\n                          footLSize, data.footLDeform));\n    //saber\n    float saber = fieldData.fSaber;//fSaber(d, data, fieldData);\n    float handle = fHandle(d, data, fieldData);\n    \n    minDist = min(minDist, body);\n    minDist = min(minDist, eye);\n    minDist = min(minDist, mouth);\n    minDist = min(minDist, hands);\n    minDist = min(minDist, feet);\n    minDist = min(minDist, saber);\n    minDist = min(minDist, handle);\n    \n    vec4 color = vec4(0.0);//egg bolor\n    color += mix(bodyColor, vec4(vec3(0.9), 0.8), step(subBody, body))*step(body, minDist);\n    color += mix(eyeColor, bodyColor, step(subEye, eye))*step(eye, minDist);\n    color += bodyColor*step(hands, minDist);\n    color += bodyColor*step(feet, minDist);\n    color += mouthColor*step(mouth, minDist);\n    color += vec4(data.laserColor, 0.0)*step(saber, minDist);\n    color += handleColor*step(handle, minDist);\n    \n    return color;\n}\n\n//transition functions\nfloat pingPong(float p)\n{\n    return 1.0-abs(p*2.0 - 1.0);   \n}  \n\nfloat minHandDist = 1.2;\nfloat maxHandDist = 1.7;\n\nvoid invKinOneHand(float i, mat3 alignRot, inout StickmanData data)\n{\n    data.handLPos = data.handLPos*alignRot;\n}\n\nvoid invKinTwoHand(float i, mat3 alignRot, inout StickmanData data)\n{\n    vec3 f = vec3(0.0, 0.0, 1.0);\n    vec3 dir = normalize(mix(f, data.invSaberRot*f, i));\n    \n    mat3 rot;\n    rotationAlign(f, dir, rot);        \n    data.handLRot = data.handLRot*rot;\n    \n    vec3 target = data.handRPos + vec3(0.0, -0.3, 0.)*data.invSaberRot;\n    float l = mix(length(data.handLPos), max(length(target), minHandDist), i);\n    data.handLPos = normalize(mix(data.handLPos, target, pow(i, 0.5)))*l;\n}\n\nvec3 neutralTarget = vec3(0.0, 0.0, -1.0);\nfloat ll = 1.0;//leg length ratio\n\nvoid invKinematics(float twoHanded, float hit, inout StickmanData data)\n{    \n    data.saberTarget = normalize(data.saberTarget);\n    mat3 alignRot;\n    \n    //rotate saber\n    rotationAlign(data.saberTarget, vec3(0.0, 1.0, 0.0)*data.invSaberRot, hit, alignRot);\n    data.invSaberRot = data.invSaberRot*alignRot; \n    \n    //move hand/handle\n    data.saberPos = mix(data.saberPos, maxHandDist*normalize(data.saberPos), hit);\n    rotationAlign(data.saberTarget, neutralTarget, .8, alignRot);\n    vec3 armTarget = neutralTarget * alignRot;\n    rotationAlign(armTarget, normalize(data.saberPos), hit, alignRot);\n    data.saberPos *= alignRot;\n    \n    data.saberPos = max(length(data.saberPos), minHandDist) * normalize(data.saberPos);\n    data.handRPos = data.saberPos;\n    data.handRRot = data.invSaberRot;\n    //move body stance\n    data.bodyPos = mix(data.footRPos, data.footLPos, 0.5) + vec3(0.0, data.bodyPos.y, 0.1);\n    //turn body\n    vec3 bodyRestDir = normalize(vec3(1.0, -0.5, -.5));\n    vec3 saberDir = normalize(mix(bodyRestDir, data.saberPos, 0.3));    \n    rotationAlign(saberDir, bodyRestDir, alignRot);\n    data.invBodyRot *= alignRot;\n    //back hand rot\n    saberDir = normalize(mix(bodyRestDir, data.saberPos, 1.0 - twoHanded));    \n    rotationAlign(saberDir, bodyRestDir, alignRot);\n    \n    //squint eyes while you hit, just because ....\n    data.eyeLDeform.y *= 1.0 - hit*0.4;\n    data.eyeRDeform.y *= 1.0 - hit*0.5;\n    \n    invKinOneHand(1.0 - twoHanded, alignRot, data);\n    invKinTwoHand(twoHanded, alignRot, data);\n}\n\nfloat frontLoop(float i, float t, inout StickmanData data)\n{\n    float dur = 1.0;\n    float r = mod(t, dur)/dur;\n    float p = pingPong(r)*i;\n    \n    mat3 rotY;\n    rotationY(PI*i*-0.15, rotY);\n    \n    mat3 rotX;\n    rotationX(PI*2.0*r*i, rotX);\n    \n    data.invSaberRot = rotX*data.invSaberRot*rotY;\n    \n    vec3 offset = vec3(0., .7, .7)*.4*data.invSaberRot;\n    data.saberPos.x += 0.7*i;\n    data.saberPos.y += 0.6*i;\n    data.saberPos.z += 0.3*i;\n    data.saberPos -= offset;\n            \n    return 0.0;\n}\n\nfloat backLoop(float i, float t, inout StickmanData data)\n{\n    float dur = 1.0;\n    float r = mod(t, dur)/dur;\n    float p = pingPong(r)*i;\n    \n    mat3 rotY;\n    rotationY(PI*i*-0.1, rotY);\n    \n    mat3 rotX;\n    rotationX(PI*2.*r*i, rotX);\n    \n    data.invSaberRot = rotX*data.invSaberRot*rotY;\n    \n    vec3 offset = vec3(0., .65, .7)*.3*data.invSaberRot;\n        \n    data.saberPos.y += 0.55*i;\n    data.saberPos -= offset;\n            \n    return 0.0;    \n}\n\nfloat nullMove(float i, float m, inout StickmanData data)\n{ \n    return 0.0;\n}\n\nfloat nullPose(float i, inout StickmanData data)\n{ \n    return 0.0;\n}\n\nfloat whirlingHit(float i, float m, inout StickmanData data)\n{    \n    float p1d = 0.3;\n    float p2d = 0.4;\n    float p3d = 0.3;\n    \n    float t = i;\n    //arming part\n    float p1 = smoothstep(0.0, p1d, t);    \n    //hitting part\n    float p2 = linearstep(p1d, p1d + p2d, t);\n    p2 = min(m, p2);\n    //back to rest part\n    float p3 = linearstep(p1d + p2d, p1d + p2d + p3d, t);\n    \n    //move the target on trajectory\n    vec3 start = vec3(0.8, -0.3, 0.3);\n    vec3 end = vec3(-0.5, -.1, -0.45);\n    vec3 target = mix(start, end, p2);\n    target.y += 0.3*pingPong(p2);\n    //target = mix(target, neutralTarget, pow(p3, 0.4));\n    data.saberTarget = mix(data.saberTarget, target, p1);\n\n    //stance\n    data.footRPos = mix(data.footRPos, ll*vec3(0.4, 0.1, data.footLPos.z + 1.2), (p1 - p3));\n    data.footRPos = mix(data.footRPos, ll*vec3(0.4, 0.1, data.footLPos.z - 1.2), pow(p2 - p3, 2.0));\n    data.footRPos.y += pingPong(p1 - p3)*ll*0.1;\n    //footRPos.y += pingPong(p2 - p3)*ll*0.1;\n    \n    float landing = pingPong(linearstep(p1d + p2d*.7, p1d + p2d + p3d*.5, t));\n    float takeoff = 1.0 - pow(1.0 - (smoothstep(0., p1d*0.6, t) - smoothstep(p1d*0.6, p1d + p2d*0.1, t)), 2.0);    \n    float jump = 1.0 - pow(1.0 - (smoothstep(p1d, p1d + p2d*0.5, t) - smoothstep(p1d + p2d*0.5, p1d + p2d, t)), 3.0);\n    \n    data.bodyPos.y += -takeoff*.3 + jump*.4 - landing*.2;\n    data.bodyDeform.y += -takeoff*.1 + jump*.05- landing*.1;\n    data.stickmanPos.y += jump*1.;\n    //footRPos.y -= jump*0.4;\n    data.footLPos.y -= jump*0.4;\n    \n    float r = smoothstep(p1d, p1d + p2d, t);\n    mat3 rotY;\n    rotationY(PI*-2.*r, rotY);\n    \n    mat3 rotX;\n    rotationX(PI*.1*pow((p1 + jump)*.5, 2.0), rotX);\n    \n    data.invStickmanRot = rotY*rotX*data.invStickmanRot;\n    \n    return p1 - p3;\n}\n\nfloat forwardHit(float i, float m, inout StickmanData data)\n{   \n    float p = step(i, 0.5)*pow(i*2.0, 2.0) + step(0.5, i)*smoothstep(1.0, 0.5, i);//pingPong(i);\n    data.saberTarget = step(i, 0.001)*data.saberTarget + step(0.001, i)*vec3(0.3, 0., -2.0);\n    \n    float mp = min(m, p);\n    //stance\n    data.footRPos = mix(data.footRPos, ll*vec3(0.4, 0.1, data.footLPos.z - 1.5), mp);\n    data.footRPos.y += pingPong(p)*ll*0.1;\n    return mp;\n}\n\nfloat upDownHit(float i, float m, inout StickmanData data)\n{\n    float p1d = 0.2;\n    float p2d = 0.6;\n    float p3d = 0.2;\n    \n    float t = i;\n    //arming part\n    float p1 = smoothstep(0.0, p1d, t);\n    float p2 = 1.0 - pow(1.0 - linearstep(p1d, p1d + p2d, t), 1.0);\n    p2 = min(m, p2);\n    float p3 = linearstep(p2d, p1d + p2d + p3d, t);\n    \n    //move the target on trajectory\n    vec3 start = vec3(0.8, .35, 0.3);\n    vec3 end = vec3(-1., -0.45, -0.45);\n    vec3 target = mix(start, end, p2);//mix(mix(start, end, p2), neutralTarget, pow(p3, 0.4));\n    data.saberTarget = mix(data.saberTarget, target, p1);\n    \n    //stance\n    data.footRPos = mix(data.footRPos, ll*vec3(0.4, 0.1, data.footLPos.z - 1.2), (p1 - p3));\n    data.footRPos.y += pingPong(p1 - p3)*ll*0.1;\n    return p1 - p3;\n}\n\nfloat parryUpRight(float i, float m, inout StickmanData data)\n{   \n    float p = 1.0 - pow(1.0 - pingPong(i), 4.0);\n\n    mat3 alignRot;\n    vec3 restTarget = vec3(0.0, 1.0, 0.0)*data.invSaberRot;    \n    vec3 armTarget = vec3(-1.0, 0.15, -0.1);\n    rotationAlign(armTarget, restTarget, p, alignRot);\n    data.invSaberRot = data.invSaberRot*alignRot;\n        \n    data.saberPos = mix(data.saberPos, vec3(0.6, 0.42, -1.7), p);\n                \n    //squint eyes while you parry, just because ....\n    data.eyeLDeform.y *= 1.0 - p*0.4;\n    data.eyeRDeform.y *= 1.0 - p*0.6;\n    \n    //stance\n    data.footRPos = mix(data.footRPos, ll*vec3(0.8, 0.1, data.footRPos.z + 0.5), p);\n    data.footRPos.y += pingPong(p)*ll*0.1;\n    return 0.0;\n}\n\nfloat parryDownLeft(float i, float m, inout StickmanData data)\n{   \n    float p = 1.0 - pow(1.0 - pingPong(i), 4.0);\n    \n    mat3 alignRot;\n    vec3 restTarget = vec3(0.0, 1.0, 0.0)*data.invSaberRot;    \n    vec3 saberTarget = vec3(-0.2, 1.0, -0.5);\n    rotationAlign(saberTarget, restTarget, p, alignRot);\n    data.invSaberRot = data.invSaberRot*alignRot;\n\n    data.saberPos = mix(data.saberPos, vec3(-0.9, -0.5, -1.4), p);\n                \n\t//squint eyes while you parry, just because ....\n    data.eyeLDeform.y *= 1.0 - p*0.4;\n    data.eyeRDeform.y *= 1.0 - p*0.6;\n    \n    //stance\n    data.footRPos = mix(data.footRPos, ll*vec3(0.7, 0.1, data.footRPos.z + 0.5), p);\n    data.footRPos.y += pingPong(p)*ll*0.1;\n    return 0.0;\n}\n\nvoid iddle(float t, float i, inout StickmanData data)\n{\n    //mouth\n    float dur = 3.0;\n    float p;\n    //p = pingPong(mod(t, dur)/dur)*i;\n    //mouthDeform *= 0.9 + 0.2*p;\n    //body\n    p = pingPong(mod(t - 0.1, dur)/dur)*i;\n    data.bodyDeform *= 0.975 + 0.025*p;\n    //hands\n    float r = p*PI*-0.07;\n    data.handRRot = data.handRRot*mat3(vec3(cos(r), sin(r), 0.0),\n                    vec3(-sin(r), cos(r), 0.0),\n                    vec3(0.0, 0.0, 1.0));\n    r = -r;\n    data.handLRot = data.handLRot*mat3(vec3(cos(r), sin(r), 0.0),\n                    vec3(-sin(r), cos(r), 0.0),\n                    vec3(0.0, 0.0, 1.0));        \n    //eyes\n    dur = 5.0;\n    p = pingPong(smoothstep(dur - 0.3, dur, mod(t, dur)))*i;\n    data.eyeRDeform.y *= 1.0 - p;\n    data.eyeLDeform.y *= 1.0 - p;    \n}\n\nfloat poseSaberSide(float i, inout StickmanData data)\n{   \n    data.saberPos = mix(data.saberPos, vec3(1.0, -0.2, -0.8), i);\n    mat3 xRot;\n    rotationX(PI*0.07*i, xRot);\n    data.invSaberRot = data.invSaberRot*xRot;\n    \n    //foot placement\n    data.footLPos = mix(data.footLPos, vec3(-0.8, 0.1, -.6*ll), i);\n    data.footLPos.y += ll*0.1*pingPong(i);\n    \n    return 1.0;\n}\n\nfloat poseSaberFront(float i, inout StickmanData data)\n{   \n    data.saberPos = mix(data.saberPos, vec3(0.2, -0.4, -1.4), i);\n    mat3 xRot;\n    rotationX(PI*0.25*i, xRot);\n    data.invSaberRot = data.invSaberRot*xRot;\n    \n    //foot placement\n    data.footRPos = mix(data.footRPos, vec3(0.6, 0.1, -0.8*ll), i);\n    data.footRPos.y += ll*0.1*pingPong(i);\n    return 0.0;\n}\n\nfloat poseSaberBack(float i, inout StickmanData data)\n{    \n    mat3 xRot;\n    rotationX(0.55*PI*i, xRot);\n    mat3 yRot;\n    rotationY(-0.07*PI*i, yRot);\n    \n    data.invSaberRot = data.invSaberRot*xRot*yRot;\n   \n    mat3 zRot;\n    rotationZ(PI*0.4*i, zRot);\n    data.handLRot = data.handLRot*zRot;\n    data.handLPos = mix(data.handLPos, vec3(-1.3, 0.3, -0.9), i);\n    data.saberPos = mix(data.saberPos, vec3(1.3, 0.2, 0.5), i);\n    \n    //foot placement\n    data.footLPos = mix(data.footLPos, vec3(-0.6, 0.1, -1.*ll), i);\n    data.footLPos.y += ll*0.1*pingPong(i);\n    return 0.0;\n}\n\nfloat poseSaberBackDown(float i, inout StickmanData data)\n{    \n    mat3 xRot;\n    rotationX(0.65*PI*i, xRot);\n    mat3 yRot;\n    rotationY(0.3*PI*i, yRot);\n    \n    data.invSaberRot = data.invSaberRot*xRot*yRot;\n    \n    mat3 zRot;\n    rotationZ(PI*0.4*i, zRot);\n    data.handLRot = data.handLRot*zRot;\n    data.handLPos = mix(data.handLPos, vec3(-1.2, -0.3, -0.8), i);\n    \n    data.saberPos = mix(data.saberPos, vec3(1.3, -0.3, 0.5), i);\n    \n    //foot placement\n    data.footLPos = mix(data.footLPos, vec3(-0.7, 0.1, -0.7*ll), i);\n    data.footLPos.y += ll*0.1*pingPong(i);\n    return 0.0;\n}\n\nfloat animateEntranceJedi(float p, inout StickmanData data)\n{        \n    data.saberLen *= smoothstep(0.05, 0.3, p);\n    float pose1 = 1.0 - smoothstep(.52, .7, p);\n    poseSaberFront(pose1, data);\n    \n    frontLoop(smoothstep(.3, .4, p) - smoothstep(0.65, 0.7, p), linearstep(.3, .65, p)*2., data);\n    \n    float pose2 = smoothstep(.5, .7, p);\n    poseSaberSide(pose2, data);\n    \n    return pose2;\n}\n\nfloat animateEntranceSith(float p, inout StickmanData data)\n{    \n    data.saberLen *= smoothstep(0.05, 0.15, p);\n    float pose1 = 1.0 - smoothstep(.52, .6, p);\n    poseSaberBackDown(pose1, data);\n    \n    backLoop(max(smoothstep(.2, .25, p) - smoothstep(0.55, 0.6, p), 0.00001), linearstep(.2, .55, p)*3., data);\n    \n    float pose2 = smoothstep(.5, .6, p);\n    poseSaberBack(pose2, data); \n    return 0.0;\n}\n\n#define ANIMATE 1\n\n//assumes t is time\n//i is a float \n//data is the stickman\n//hit receives the hit progress\n//twoHanded receives the two hand amount\n#define HIT_SEQ(s, e, m, hitAnim) if(t > s && t <= e) {i = (t-s)/(e-s); hit = hitAnim(i, m, data);}\n#define HOLD_POSE(s, e, poseAnim) if(t > s && t <= e) {twoHanded = poseAnim(1.0, data);}\n#define TRANS_POSE(s, e, prevPoseAnim, poseAnim) if(t > s && t <= e) {i = (t-s)/(e-s); prevTwoHanded = prevPoseAnim(1.0-i, data); twoHanded = poseAnim(i, data); twoHanded = mix(prevTwoHanded, twoHanded, i);}\n\nfloat loopTime = 9.5;\n\nvoid animateJedi(float t, inout StickmanData data)\n{    \n    float entranceDur = 4.5;\n    float prevTwoHanded = 0.0;\n    float twoHanded = 0.0;\n    float i = 0.0;\n    float hit = 0.0;\n    float s, e;\n    \n#if ANIMATE    \n    s = -entranceDur;\n    e = 0.0;\n    TRANS_POSE(s, e, nullPose, animateEntranceJedi)\n    \n    t = mod(t, loopTime) * step(0.0, t);\n    \n\ts = e;\n    e = s + 0.5;    \n    HOLD_POSE(s, e, poseSaberSide)\n        \n    s = e;\n    e = s + 0.7;    \n    HOLD_POSE(s, e, poseSaberSide)\n    HIT_SEQ(s, e, 1.0, parryDownLeft) \n        \n    s = e;\n    e = s + 0.2;    \n    HOLD_POSE(s, e, poseSaberSide)\n        \n    s = e;\n    e = s + 1.65;    \n    HOLD_POSE(s, e, poseSaberSide)\n    HIT_SEQ(s, e, 0.60, whirlingHit)  \n        \n    s = e;\n    e = s + 1.0;    \n    HOLD_POSE(s, e, poseSaberSide)\n                \n    s = e;\n    e = s + 0.9;    \n    HOLD_POSE(s, e, poseSaberSide)\n    HIT_SEQ(s, e, 1.0, parryDownLeft)  \n\n    s = e;\n    e = s + 0.45;    \n    TRANS_POSE(s, e, poseSaberSide, poseSaberFront) \n        \n    s = e;\n    e = s + 0.9;    \n    HOLD_POSE(s, e, poseSaberFront)\n    HIT_SEQ(s, e, 1.0, parryDownLeft)                  \n        \n    s = e;\n    e = s + 2.0;    \n    HOLD_POSE(s, e, poseSaberFront)\n    HIT_SEQ(s, e, 0.4375, upDownHit)   \n        \n\ts = e;\n    e = s + 0.4;    \n    HOLD_POSE(s, e, poseSaberFront)\n        \n    s = e;\n    e = s + 0.6;    \n    TRANS_POSE(s, e, poseSaberFront, poseSaberSide) \n    \n    s = e;\n    e = loopTime;    \n    HOLD_POSE(s, e, poseSaberSide)\n#endif        \n            \n    invKinematics(twoHanded, hit, data);\n}\n\nvoid animateSith(float t, inout StickmanData data)\n{        \n    float entranceDur = 4.5;\n    float twoHanded = 0.0;\n    float i = 0.0;\n    float hit = 0.0;\n    float prevTwoHanded = 0.0;\n    \n    float s, e;\n#if ANIMATE\n    //do pose    \n    s = -entranceDur;\n    e = 0.0;\n    TRANS_POSE(s, e, nullPose, animateEntranceSith)\n    \n    t = mod(t, loopTime) * step(0.0, t);\n    \n    s = e;\n    e = s + 1.7;    \n    HOLD_POSE(s, e, poseSaberBack)\n    HIT_SEQ(s, e, 0.434, upDownHit)\n       \n    s = e;\n    e = s + 0.6;    \n    HOLD_POSE(s, e, poseSaberBack)\n        \n    s = e;\n    e = s + 0.6;    \n    HOLD_POSE(s, e, poseSaberBack)\n    HIT_SEQ(s, e, 1.0, parryUpRight)\n        \n    s = e;\n    e = s + 0.5;    \n    TRANS_POSE(s, e, poseSaberBack, poseSaberBackDown)\n        \n    s = e;\n    e = s + 1.5;    \n    HOLD_POSE(s, e, poseSaberBackDown)\n    HIT_SEQ(s, e, 0.558, whirlingHit)\n        \n    s = e;\n    e = s + 0.4;    \n    TRANS_POSE(s, e, poseSaberBackDown, poseSaberBack)\n        \n    s = e;\n    e = s + 1.0;    \n    HOLD_POSE(s, e, poseSaberBack)            \n    HIT_SEQ(s, e, 0.6, forwardHit)\n    \n    s = e;\n    e = s + 0.1;    \n    HOLD_POSE(s, e, poseSaberBack)  \n        \n    s = e;\n    e = s + 0.42;    \n    TRANS_POSE(s, e, poseSaberBack, poseSaberBackDown)\n        \n    s = e;\n    e = s + 1.2;    \n    HOLD_POSE(s, e, poseSaberBackDown)\n    HIT_SEQ(s, e, 1.0, parryDownLeft)   \n        \n\ts = e;\n    e = s + 0.8;    \n    HOLD_POSE(s, e, poseSaberBackDown)\n        \n    s = e;\n    e = s + 0.5;    \n    TRANS_POSE(s, e, poseSaberBackDown, poseSaberBack)\n    \n    s = e;\n    e = loopTime;    \n    HOLD_POSE(s, e, poseSaberBack)\n#endif        \n    \n    invKinematics(twoHanded, hit, data);\n}\n\nvoid initStickman(inout StickmanData data, bool isJedi)\n{\n    data.stickmanPos = vec3(0.0, -1.0, 0.0);\n    //relative to stickManPos\n    data.bodyPos = vec3(0.0, 1.5, 0.0);\n    data.bodyDeform = vec3(1.0, 1.15, 1.0);\n    data.headPos = vec3(0.0, .05, -0.92);\n    data.handRPos = vec3(1.1, -0.45, -0.5);\n    data.handLPos = vec3(-1.1, -0.45, -0.5);\n    data.handRDeform = vec3(1.2, 1.5, 1.6);\n    data.handLDeform = vec3(1.2, 1.5, 1.6);\n    data.handRRot = IMAT3;\n    data.handLRot = IMAT3;\n    data.footRPos = vec3(0.6, 0.1, -0.1);\n    data.footLPos = vec3(-0.6, 0.1, -0.1);\n    data.footRRot = IMAT3;\n    data.footLRot = IMAT3;\n    data.footRDeform = vec3(1.5, 0.9, 1.8);\n    data.footLDeform = vec3(1.5, 0.9, 1.8);\n\n\n    data.invBodyRot = IMAT3;\n    data.invStickmanRot = IMAT3;\n    data.invMouthRot = IMAT3;\n\n    //relative to headPos\n    data.eyeRDeform = vec3(2.0, 1.8, 1.0);\n    data.eyeLDeform = vec3(2.0, 2.5, 1.0);\n\n    data.mouthDeform = vec3(2., 1.0, 3.5); \n\n    data.saberPos = vec3(1.1, -0.45, -0.5);\n    data.saberRadius = 0.06;\n    data.saberLen = 0.85;\n    data.saberNoise = isJedi ? JEDI_SABER_NOISE : SITH_SABER_NOISE;\n    data.invSaberRot = IMAT3;\n    \n    data.laserColor = LASER_CORE + (isJedi ? JEDI : SITH);\n    data.laserLight = (data.laserColor - LASER_CORE)*LASER_LIGHT_STR;\n    \n    rotationX(mouthXRot, data.invMouthRot);\n}\n\nvec4 characterField(vec3 p, inout float minDist )\n{\n\tvec4 jediField = vec4(maxDist);\n    vec4 sithField = vec4(maxDist);\n    float jediMinDist = MAX_DIST;\n    float sithMinDist = MAX_DIST;\n    jediField = fStickman(jediData.invStickmanRot*(p - jediData.stickmanPos), jediData, jediFieldData, jediMinDist);\n#ifdef TWO_EGGS    \n    sithField = fStickman(sithData.invStickmanRot*(p - sithData.stickmanPos), sithData, sithFieldData, sithMinDist);\n#endif    \n    minDist = min(jediMinDist, sithMinDist);\n    return jediField*step(jediMinDist, minDist) + sithField*step(sithMinDist, minDist);\n}\n\n////////////////////////////////\n\n//get distance to nearest surface and atmosphere/surface color\nvec4 colorDistanceField(vec3 point, inout float minDist)\n{       \n    float charDist \t\t= MAX_DIST;\n    vec4 charfield\t\t= characterField(point, charDist);\n       \n    vec3 mPoint = point - vec3(7.5, 0.0, 2.0);\n    pMod2(mPoint.xz, vec2(15.0, 15.0));\n\n    float hexaHeight \t= 3.0;\n    float hexaDist\t\t= fHexagonCircumcircle(mPoint, vec2(1.5, hexaHeight));\n    float distPlane     = fPlane(plane, point);\n    minDist             = min(minDist, distPlane);\n    minDist\t\t\t\t= min(minDist, charDist);\n    minDist\t\t\t\t= min(minDist, hexaDist);\n        \n    //blend colors\n    vec4 color = vec4(0.0);\n    color += groundColor * step(distPlane, minDist);\n    color += groundColor * step(hexaDist, minDist);\n    color += charfield * step(charDist, minDist);\n\n    return color;\n}\n\n//get distance and color to nearest surface\nfloat distanceField(vec3 point)\n{\n    float minDist = MAX_DIST;\n    colorDistanceField(point, minDist);\n    return minDist;\n}\n\nvec3 computeNormal(vec3 p, float roughness, out float ao)\n{    \n    vec3 normalWS = vec3(0.0);\n    for(int i = min(0, iFrame); i < 4; i++)\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        uint unusedMatId;\n        normalWS += e*distanceField(p + e * 0.001);\n    }\n    normalWS = normalize(normalWS);    \n    vec3 deform = noise3(p*0.0002);\n    \n    ao = length(deform);\n    deform = deform*2.0 - vec3(1.0);\n    return normalize(normalWS + deform * roughness*0.0001);\n}\n\nvec3 computeSaberLightDir(vec3 point, StickmanData data, FieldData fieldData)\n{\n#if LIGHT_QUALITY\n    float grad = 0.75;\n    \n    vec3 normalWS = vec3(0.0);\n    for(int i = min(0, iFrame); i < 4; i++)\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        uint unusedMatId;\n        vec3 p = point + e * grad;\n        normalWS += e*fSaber(data.invStickmanRot*(p - data.stickmanPos), data, fieldData);\n    }\n    normalWS = -normalize(normalWS); \n    return normalWS;\n#else\n    vec3 s = (vec3(0., data.saberLen*2.0, 0.)*data.invSaberRot);\n    vec3 a = data.stickmanPos + (data.bodyPos + data.saberPos*data.bodyDeform)*data.invStickmanRot;\n    vec3 c = data.stickmanPos + (data.bodyPos + (s + data.saberPos)*data.bodyDeform)*data.invStickmanRot;\n    return normalize(mix(a, c, 0.5) - point);\n#endif\n}\n\nfloat distBetweenSabers(StickmanData first, StickmanData secnd, FieldData secndField)\n{\n    vec3 s = (vec3(0., first.saberLen*2.0, 0.)*first.invSaberRot);\n    vec3 a = first.stickmanPos + (first.bodyPos + first.saberPos*first.bodyDeform)*first.invStickmanRot;\n    vec3 c = first.stickmanPos + (first.bodyPos + (s + first.saberPos)*first.bodyDeform)*first.invStickmanRot;\n        \n    float sithDistLaser = 1000.0;\n    for(float i = 0.; i <= 1.0; i += 1.0/32.0)\n    {\n        vec3 b = mix(a, c, i);\n        vec3 stickmanDiff = secnd.invStickmanRot*(b - secnd.stickmanPos);        \n    \tsithDistLaser = min(sithDistLaser, fSaber(stickmanDiff, secnd, secndField)); \n    }\n    \n    return sithDistLaser;\n}\n\nvec3 doLighting(vec3 surfColor, vec3 surfPoint, vec3 surfNormal, vec3 lightColor, vec3 lightDir, float roughness)\n{\n    if(dot(surfColor, surfColor) <= 2.5)\n    {             \n        float lightingWrap = 0.5;\n        float diff \t\t= dot(surfNormal, lightDir);\n        diff\t\t\t= clamp((diff + lightingWrap)/((1.0 + lightingWrap)*(1.0 + lightingWrap)), 0.0, 1.0);\n        vec3 eyeDir \t= normalize(projectionCenter - surfPoint);\n        vec3 halfVec \t= normalize(eyeDir + lightDir);\n        float spec \t\t= clamp(dot(halfVec, surfNormal), 0.0, 1.0);\n        spec \t\t\t= pow(spec, mix(128.0, 8.0, pow(roughness, 0.5))) * pow(diff, 1.0);\n        surfColor \t\t= surfColor * diff * lightColor + lightColor * spec;\n    }    \n    return surfColor;\n}\n\n//raymarch and sample atmosphere color along the ray\nvec4 rmAtmosphere(vec3 rayStart, vec3 rayDir, float minDist)\n{\n    float cloud = 0.0;\n\tfloat transmittance = 1.0;\n    vec3 scatteredLight = vec3(0.0, 0.0, 0.0);\n    \n    float totalDist = minDist;\n    float dist = 0.0;\n    float dStep = 0.0;\n    vec3 color = zero;\n    float stepBias, jediDistLaser, sithDistLaser, strLaser;\n    vec3 atmColor, surfColor, litColor;\n    vec3 endPoint, sithStickmanDiff, jediStickmanDiff, normal;\n    vec3 jediSaberLightDir, sithSaberLightDir;\n    vec4 dfRes;   \n    float roughness = .0;\n    vec3 S, Sint;\n    float saberOverlap;\n    \n    float distSab = distBetweenSabers(jediData, sithData, sithFieldData);\n    //distSab = min(distSab, distBetweenSabers(sithData, jediData, jediFieldData));\n    float contactLightPower = 1.0 + smoothstep(0.3, 0.15, distSab)*3.0;\n        \n    vec4 rmRes;\n    \n    for(int i = 0; i < MAX_STEPS; ++i)\n    {   \n        stepBias = max(MIN_STEP_BIAS, totalDist*2.0/MAX_DIST);//to avoid artefacts\n                      \n        endPoint = rayStart + rayDir * totalDist; \n        jediStickmanDiff = jediData.invStickmanRot*(endPoint - jediData.stickmanPos);\n        jediFieldData.fSaber = fSaber(jediStickmanDiff, jediData, jediFieldData);\n        strLaser = 1.0 + smoothstep(jediData.saberLen*2., 0.0, fHandle(jediStickmanDiff, jediData, jediFieldData))*2.;\n        jediDistLaser = (LASER_STR + strLaser)/pow(jediFieldData.fSaber, 2.0);  \n        \n#ifdef TWO_EGGS\n        sithStickmanDiff = sithData.invStickmanRot*(endPoint - sithData.stickmanPos);\n        sithFieldData.fSaber = fSaber(sithStickmanDiff, sithData, sithFieldData);\n        strLaser = 1.0 + smoothstep(sithData.saberLen*2., 0.0, fHandle(sithStickmanDiff, sithData, sithFieldData))*2.;\n        sithDistLaser = (LASER_STR + strLaser)/pow(sithFieldData.fSaber, 2.0);         \n        \n        saberOverlap = 1.0/pow(jediFieldData.fSaber*sithFieldData.fSaber, 1.5);\n        jediDistLaser += saberOverlap;\n        sithDistLaser += saberOverlap;\n#endif\n        \n        jediSaberLightDir = computeSaberLightDir(endPoint, jediData, jediFieldData);\n        sithSaberLightDir = computeSaberLightDir(endPoint, sithData, sithFieldData);\n\n#if VOL_FOG\n        vec3 atmSamplePos = endPoint + rayDir*dist*(s_pixelRand-0.5);\n        cloud = atmThickness(atmSamplePos);\n        \n        S = jediDistLaser*jediData.laserLight*contactLightPower*\n#if VOL_SHADOW            \n            volumetricShadow(atmSamplePos, jediSaberLightDir)*\n#endif            \n            cloud * PHASE_FUNC; // incoming light\n#ifdef TWO_EGGS\n        S += sithDistLaser*sithData.laserLight*contactLightPower*\n#if VOL_SHADOW            \n            volumetricShadow(atmSamplePos, sithSaberLightDir)*\n#endif            \n            cloud * PHASE_FUNC; // incoming light        \n#endif        \n        \n        Sint = (S - S * exp(-cloud * dStep)) / cloud; // integrate along the current step segment\n        scatteredLight += transmittance * Sint; // accumulate and also take into account the transmittance from previous steps\n\t\t// Evaluate transmittance to view independentely\n        transmittance *= exp(-cloud * dStep); \n        if(transmittance < 0.005) \n        {\n            break;\n        }\n#endif              \n        dist = MAX_DIST;\n        dfRes = colorDistanceField(endPoint, dist);        \n        dStep = dist * stepBias;        \n        totalDist += dStep;  \n        \n        if(dist <= MIN_DIST)\n        {                  \n            float ao = 1.0;\n            normal = computeNormal(endPoint, roughness, ao);\n            //store final hit color\n            surfColor = dfRes.xyz;\n            roughness = dfRes.w;\n\t\t\t\n            //do lighting            \n            litColor = AMBIANT_LIGHT * surfColor;            \n            //Don't do sunlight, night time looks better\n            //litColor += doLighting(surfColor, endPoint, normal, sunLightColor, normalize(sunLightPos - endPoint), roughness);                                  \n            \n            litColor += doLighting(surfColor, endPoint, normal, \n                                   (jediData.laserLight*contactLightPower)*jediDistLaser*0.5,\n                                   jediSaberLightDir, roughness);                        \n#ifdef TWO_EGGS\n      \t\t\n            litColor += doLighting(surfColor, endPoint, normal, \n                                   (sithData.laserLight*contactLightPower)*sithDistLaser*0.5, \n                                   sithSaberLightDir, roughness);                        \n#endif                                                \n            \n            color = surfColor*ao*0.01 + litColor;\n\n            rmRes = vec4(color, totalDist);   \n            break;\n        }                \n\n        //no surface hit, return sky + atmColor\n        if(totalDist >= MAX_DIST || i >= MAX_STEPS - 1)\n        {\n            rmRes = vec4(color + skyColor, MAX_DIST + 0.01);\n            break;\n        }\n    }    \n    \n    rmRes.xyz = mix(fogColor*0.8, rmRes.xyz, transmittance) + scatteredLight;\n    return rmRes;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{      \n    s_pixelRand = textureLod(iChannel0, fragCoord/vec2(1024.0), 0.0).r;\n    s_pixelRand = fract(s_pixelRand + float(iFrame % 256)*1.618);\n    s_time = iTime;// - iTimeDelta * s_pixelRand;\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy * 2.0 - vec2(1.0);\n    float day = 0.0;\n    day = sign(day) * pow(abs(day), 2.0);\n    dayProgress = abs(day);\n\n    float sunsetFromNight = smoothstep(0.4, 0.5, dayProgress);\n    float sunsetToDay = smoothstep(0.8, 0.5, dayProgress);\n    vec3 sunsetColor = mix(mix(vec3(0.5, 0.0 ,0.0), vec3(1.0, 0.8, 0.3), sunsetFromNight),\n                           mix(vec3(0.2, 0.2, 1.0), vec3(1.0, 0.8, 0.3), sunsetToDay), (sunsetFromNight + sunsetToDay)/2.0);\n    float sunsetStr = sunsetFromNight*sunsetToDay;    \n    \n    sunLightPos = vec3(0.0, -1000.0, 0.0);\n    mat3 sRotZ;\n    rotationZ(day*PI, sRotZ);\n    sunLightPos = sRotZ*sunLightPos;\n    \n    sunLightColor = mix(vec3(0.004, 0.004, 0.0065), vec3(0.8, 0.8, 0.7), dayProgress);    \n    sunLightColor = mix(sunLightColor, sunsetColor, sunsetStr);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;    \n    vec3 ro = vec3(0.0);\n    \n    float t = s_time * 1.1; \n    t += (cos(t*0.5))*0.2;\n    \n    float camT = t*0.5;\n    float camRotY = (mousePos.x + camT*0.1)*PI*-2.0;\n    float camY = (1.0 - cos(camT*0.5))*0.3;\n    float camDist = 12.0 - sin(camT*0.5)*4.0;\n    \n    //animate before marching\n    initStickman(jediData, true);\n#ifdef TWO_EGGS    \n    jediData.stickmanPos.x += 2.7;\n    mat3 yRot;\n    rotationY(-0.5*PI, yRot);    \n    jediData.invStickmanRot = yRot*jediData.invStickmanRot;\n    \n    initStickman(sithData, false);    \n    sithData.stickmanPos.x -= 2.7;\n    rotationY(0.5*PI, yRot);\n    sithData.invStickmanRot = yRot*sithData.invStickmanRot;\n    animateSith(t, sithData);      \n    computeFieldData(sithData, sithFieldData);\n#endif    \n    animateJedi(t, jediData);\n    computeFieldData(jediData, jediFieldData);\n    \n    \n    //////////////////\n    \n    //Do camera setup from mouse coord\n    vec3 pCenter        = vec3(0.0, 0.2, 0.0);\n    vec3 pOffset\t\t= vec3(0.0, 0.0, 1.0);\n    \n    mat3 pRotY;\n    rotationY(camRotY, pRotY);\n    pOffset.y = camY;\n    pOffset = pRotY*pOffset;    \n    projectionCenter    = pCenter + pOffset*camDist;\n    \n    vec3 tmpCenter      = (projectionCenter + vec3(0.0, 0.0, .50));\n\n    projectionCenter    = (projectionCenter);\n    \n    projectionForward   = normalize(-pOffset);\n    projectionUp \t\t= vec3(0.0, 1.0, 0.0);\n    projectionRight \t= cross(projectionUp, projectionForward);\n    projectionUp \t\t= cross(projectionForward, projectionRight);      \n    mousePos       = pixelToNormalizedspace(iMouse.xy);\n           \n    \n    cameraOffset        = -projectionForward * FOCAL_LENGTH;\n    \n    vec2 rd = uv*2.0 - vec2(1.0);\n    rd.y /= iResolution.x/iResolution.y;\n    //setup ray\n    vec3 rayPos                 = projectionCenter + cameraOffset;\n    vec3 pointOnProjectionPlane = projectionCenter + projectionRight * rd.x + projectionUp * rd.y;\n    vec3 rayDirection           = normalize(pointOnProjectionPlane - rayPos);\n    \n    float sun = pow(max(0.0, dot(rayDirection, normalize(sunLightPos))), 2.0);\n    \n    //sky and stars\n    vec2 xzDir \t\t= normalize(rayDirection.xz);\n    vec2 starsUv \t= vec2(atan(xzDir.x, xzDir.y), rayDirection.y);\n    vec3 stars      = textureLod(iChannel0, starsUv * 0.1, 0.).xyz;\n    stars           *= pow(dot(stars, stars)*0.5, 16.0) * 0.3;// smoothstep(2.1, 2.5, dot(stars, stars));\n    stars = smoothstep(vec3(0.0), vec3(1.0), stars);\n    float skyHeight = pow(max(0.0, rayDirection.y) * 2.0, 0.75);\n    float starVis   = skyHeight * pow(1.0 - dayProgress, 2.0);\n    stars = mix(zero, stars, pow(starVis, 6.0));\n       \n    vec3 lowColor = mix(vec3(0.01, 0.01, 0.05), vec3(0.85, 0.85, 1.0), dayProgress);\n    lowColor = mix(lowColor, sunsetColor, sunsetStr + pow(sun, 5.0)*sunsetStr*2.0);\n    vec3 upColor = mix(vec3(0.0005, 0.0005, 0.001), vec3(0.15, 0.15, 1.0), dayProgress);\n    upColor = mix(upColor, sunsetColor, sunsetStr*0.5 + pow(sun, 5.0)*sunsetStr*2.0);\n    \n    skyColor = mix(lowColor, upColor, skyHeight);    \n    \n    float fogBlur = 0.5;\n    fogColor = mix(mix(lowColor, upColor, max(0.0, skyHeight - fogBlur)),\n                   mix(lowColor, upColor, min(1.0, skyHeight + fogBlur)),\n                   0.5);\n    \n    //march ray\n    vec4 rayMarchResult     = rmAtmosphere(rayPos, rayDirection, 0.0);    \n    float dist              = rayMarchResult.w;\n    vec4 surfaceColor       = vec4(rayMarchResult.xyz , 1.0);\n    \n    if(dist >= MAX_DIST)\n    {\n        surfaceColor.xyz += stars;\n        surfaceColor.xyz = surfaceColor.xyz + sunLightColor*pow(sun, 80.0)*10.0;\n    }    \n    \n    //convert to gamma space\n    surfaceColor = pow( surfaceColor, vec4(1.0/2.2));\n    fragColor = surfaceColor;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}