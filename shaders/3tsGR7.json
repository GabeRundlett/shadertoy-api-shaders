{
    "Shader": {
        "info": {
            "date": "1590232806",
            "description": "Prototype for a 16-segment digital clock. Newer version here: https://www.shadertoy.com/view/tlX3DB",
            "flags": 0,
            "hasliked": 0,
            "id": "3tsGR7",
            "likes": 5,
            "name": "Old proto 16-seg digital clock",
            "published": 3,
            "tags": [
                "clock",
                "display",
                "digital",
                "segment",
                "prototype",
                "visual",
                "16",
                "seg",
                "sixteen"
            ],
            "usePreview": 0,
            "username": "Yambam",
            "viewed": 419
        },
        "renderpass": [
            {
                "code": "const float TAU = 6.28318530718;\n\n//const int[] _S = int[] (      H+4,    H+5,\n//                            D+0,        D+2,\n//                          V+1,    V+3,    V+5,\n//                                                   \n//                              H+2,    H+3,\n//                                                   \n//                          V+0,    V+2,    V+4,\n//                            D+3,        D+1,\n//                              H+0,    H+1      );\n\nvec2 distIgSegmentIt( vec2 xy, float size, vec2 dimensions )\n{\n    \n//. Ambifix is a \"notation\" I (@Yambam) invented, my goal is to make learning and making use of maths more intuitive.\n//: Comments like this these are statements in a hypothetical shader language based on ambifix, with the values omitted.\n    \n    //if (xy.x<0.-1.) return vec2(1000.,-1.);\n    xy.x = clamp(xy.x,-1.,2.); //clamp((xy.x/size+1.)/(1./size+1.),0.,1.);\n    xy.y = clamp(xy.y,0.,1.); //clamp(xy.y,-size,1.+size);\n    \n    float s = dimensions.y*round(xy.x*dimensions.x)+floor(xy.y*dimensions.y);\n    //float s = round(xy.x*dimensions.x)+(dimensions.x+1.)*floor(xy.y*dimensions.y);\n    float px = round(xy.x*dimensions.x)/dimensions.x;\n    float py = floor(xy.y*dimensions.y)/dimensions.y;\n    //4.00*clamp(-.2+1.4*iMouse.x/iResolution.x,0.,1.)\n    vec2 offset =   vec2(xy.x,           xy.y-py)\n                  - vec2(clamp(px,0.,1.),clamp(xy.y-py,0.+size,1./dimensions.y-size));\n    float d = 2.*abs(offset.x)+1.*abs(offset.y);\n    //float d = 2.*length(offset);\n    \n    //Old code:\n    //float d =  4.00*(abs(xy.x   -clamp(px,0.,1.))\n    //          +1.00* abs(xy.y-py-clamp(xy.y-py,0.+size,1./dimensions.y-size)));\n//. //float d =           (-        (clamp  ) -) (abs)\n//: //          (+ (-  -) (- (-  -) (clamp  ) -) (abs) +)\n    \n    //aligned for comparison of GLSL ES infix code versus (hypothetical) ambifix code\n    //\n   ///                   xy.x                   px                   0.,1.\n   ///                   xy.y    py             xy.y    py           0.,.5-size\n   //a  float d =   (abs(               - clamp(            ,                   )        )\n   //a             + abs(      -        - clamp(      -     ,                   )        ));\n//.//a  float d =                      (-                     (clamp            ) -) (abs)\n//://a            (+          (-    -) (-            (-    -) (clamp            ) -) (abs) +)\n   ///                   xy.x                   px                   0.,1.\n   ///                   xy.y    py             xy.y    py           0.,.5-size\n    //\n\t//\n    \n    return vec2(d,s);\n}\n\nfloat colorRefreshRateArtifact( vec2 uv )\n{\n    return clamp(.8+.2*(.5+.5*sin(TAU*(5./2.*iTime+uv.y+1./16.*uv.x))*sin(TAU*(7./2.*iTime+uv.y+1./16.*uv.x))),0.,1.);\n}\n\nvec2 digIt( vec2 xy, int state, vec2 margin, float size, vec2 dimensions )\n{\n    vec2 segmented = vec2(size,-1.);\n    vec2 segmentedBest = segmented;\n    vec2 space = -margin;\n    vec2 xyf = space +(vec2(1,1)-2.*space)*xy;\n    vec2 xyfR = vec2(xyf.y,xyf.x);\n    float diag = sqrt(.5); //1.; //\n    float sFactor = (dimensions.x+1.)*dimensions.y;\n    \n    if (xyf.x<0.-.5*size\n    ||  xyf.y<0.-.5*size\n    ||  xyf.x>1.+.5*size\n    ||  xyf.y>1.+.5*size) return segmentedBest;\n    \n    \n    /*xysym = vec2(abs(xy.y-.5)+abs(xy.x-.5),abs(abs(xy.y-.5)-abs(xy.x-.5)));\n\t//xysym = vec2((xysym.x-xysym.y)/4.+.5,(xysym.x+xysym.y)/4.+.5);\n    segmented = distIgSegmentIt(vec2(xysym.x,xysym.y),size,dimensions);\n    if (segmented.x<=segmentedBest.x)\n        segmentedBest = segmented+float(abs(xyf.x)>abs(xyf.y));*/\n    \n    segmented = distIgSegmentIt(xyf,size,dimensions);\n    if (segmented.x<=segmentedBest.x)\n        segmentedBest = segmented;\n    segmented = distIgSegmentIt(xyfR,size,dimensions);\n    if (segmented.x<=segmentedBest.x)\n        segmentedBest = segmented+sFactor*vec2(0.,1.);\n    \n    vec2 xyrot = xy;\n    xyrot -= vec2(.5,.5);\n    xyrot *= vec2(sign(xy.x-.5)*sign(xy.y-.5),1.);\n    xyrot = .5*(vec2( xyrot.x,-xyrot.y)\n               +vec2(-xyrot.y,-xyrot.x));\n\txyrot += vec2(.5,.5);\n    \n    segmented = distIgSegmentIt(space+(vec2(1,1)-2.*space)*vec2(xyrot.x,xyrot.y),size,dimensions);\n    segmented = vec2(segmented.x/diag,segmented.y-(sFactor-dimensions.y)/2.);\n    if (segmented.y>=0.\n    &&  segmented.y<dimensions.y\n    &&  segmented.x<=segmentedBest.x)\n        segmentedBest = vec2(segmented.x,sFactor*2.+segmented.y+(sFactor-2.*dimensions.x)*max(0.,sign(xy.x-.5)*sign(xy.y-.5)));\n    \n    return segmentedBest; // /vec2(1.,4.*sFactor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    /*\n     * Display customization\n     */\n    \n    vec2 margin = vec2(.15,.15);\n    float size = .15;\n    float digitCount = 3.;\n    float skew = .1; //.1*sin(TAU/6.*iTime);\n    vec2 dimensions = vec2(2.,2.);\n    \n    //// A variety of display colors you can choose from\n    \n    vec3 colTheme = vec3(1.,.15,0.); //<-- Red\n    //vec3 colTheme = vec3(0.,1.,0.);  //<-- Green\n    //vec3 colTheme = vec3(1.,.8,0.);  //<-- Yellow\n    //vec3 colTheme = vec3(.8,1.,0.);  //<-- Neon yellowish green\n    //vec3 colTheme = vec3(1.,.6,0.);  //<-- Orange\n    vec3 colBg = vec3(0,0,0);\n    \n    float a = -atan(skew); //asin(skew);\n    mat2 m = mat2(cos(a),-sin(a),\n                  sin(a), cos(a));\n    float skewNew = cos(a)-sin(a);\n    \n    vec2 ch = fragCoord/iResolution.x;\n    //vec2 ch = (fragCoord+vec2(0.,iResolution.y/2.))/iResolution.x;\n    ch *= (digitCount-1.+skewNew); //digitCount; //\n    ch = m * ch;\n    \n    ch *= distance(vec2(0.,0.),vec2(1.,skew));\n    vec3 col;\n    ch.y -= skew*ch.x;\n    \n    /* \n     * Color gradient\n     */\n    //vec3 colTheme = (1.-ch.y)*vec3(1,.4,.4)+ch.y*vec3(.4,.4,1);\n    //vec3 colBg = vec3(1,1,1);\n    \n    float aa = iResolution.x/200.; //30.*iMouse.x/iResolution.x;\n    int i = int(floor(ch.x));\n    float crra = colorRefreshRateArtifact(uv);\n    float t;\n    \n    if (ch.x<0.\n    ||  ch.x>digitCount) col = colBg;\n    else\n    {\n        ch.x -= floor(ch.x);\n        vec2 doughdge = digIt(ch,0,margin,size,dimensions);\n        if (doughdge.y>=0.)\n        {\n            //if (((digits[0])&(1<<int(doughdge.y)))>0) //0-65536\n            //if (((1<<int(16./iResolution.x*iMouse.x))&(1<<int(doughdge.y)))>0) //0-65536\n            if ((int(iDate.w)&(1<<int(doughdge.y)))>0) //0-65536\n            //if ((int(iDate.w)&(1<<int(doughdge.y)))>0) //0-65536\n            //if (((int(iDate.w)>>(16*i))&(1<<int(doughdge.y)))>0) //0-65536\n        \t\tt = (.5+.5/15.*doughdge.y)*crra;\n            else\n        \t\tt = .15*crra;\n            t *= smoothstep(0.,1.,clamp(1.-10.*doughdge.x,0.,1./aa)*aa);\n            //t *= smoothstep(0.,1.,1.-8.*doughdge.x);\n            //t *= (1.-pow(2.,-2.+30.*doughdge.x));\n            t = clamp(t,0.,1.);\n        }\n        else\n            t = 0.;\n\n        col = (1.-t)*colBg+t*colTheme;\n    }\n    \n    fragColor = vec4(col,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}