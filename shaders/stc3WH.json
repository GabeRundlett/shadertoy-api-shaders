{
    "Shader": {
        "info": {
            "date": "1636067999",
            "description": "....",
            "flags": 0,
            "hasliked": 0,
            "id": "stc3WH",
            "likes": 5,
            "name": "heart.....",
            "published": 3,
            "tags": [],
            "usePreview": 0,
            "username": "lllcz",
            "viewed": 193
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926\n#define PI_HALF (.5*PI)\n#define PIx2 (2.*PI)\n \n// 2D rotation matrix\nmat2 rotmat(float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n \n/// @brief 返回带有抗锯齿的 2D 圆的距离场\n/// @param uv 纹理坐标\n/// @param origin 圆心坐标\n/// @param radius 圆的半径\n/// @param alias 抗锯齿的区间\nfloat smooth_circle(in vec2 uv, in vec2 origin, float radius, float alias)\n{\n    return /*1.0 - */smoothstep(radius - alias, radius + alias,\n                                length(uv - origin));\n}\n \n/// @brief 返回默认带抗锯齿的 2D 圆的距离场\n/// @param uv 纹理坐标\n/// @param origin 圆心坐标\n/// @param radius 圆的半径\nfloat circle(in vec2 uv, in vec2 origin, float radius)\n{\n    return smooth_circle(uv, origin, radius, 0.005);\n}\n \n/// 可以分别控制四个角的大小 [z, x\n///                         w, y]\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x > 0.0) ? r.xy : r.zw;\n    r.x  = (p.y > 0.0) ? r.x  : r.y;\n \n    vec2 q = abs(p) - b + r.x;\n    float d = max(q.x, q.y);\n    return min(d, 0.0) + length(max(q, 0.0)) - r.x;\n}\n \n/// @brief 绘制心形\nfloat inHeart (vec2 p, vec2 center)\n{\n    //移动中心\n    p = p - center;\n    //旋转\n    vec2 q = rotmat(45. / 180.*PI) * p;\n    \n    float ret = sdRoundBox(q, vec2(.15), vec4(0.03));\n \n    ret = smoothstep(0.01, .012, ret);\n    ret = min(ret, circle(p, vec2(.1, .1), .161));\n    ret = min(ret, circle(p, vec2(-.1, .1), .161));\n \n    return ret;\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n \n     //先绘制心形\n    float dist = inHeart(uv, vec2(.5));\n \n     //再填充波浪\n    float color[2];\n    for (int i = 0; i < 2; i++)\n    {\n  \n        /// @note 正弦波形\n        float p = (5.*uv.x + float(i)  +  1.*iTime);\n        float offset =  .025 * sin(p) + .62;\n \n        float eps = 1e-3;\n        float color_0 = step(uv.y, offset);\n        color[i] = color_0 * step(dist, .1);\n    }\n \n    vec3 temp = mix(vec3(57., 56., 78.) / 255., vec3(245., 245., 245.) / 255., dist);\n    temp = mix(temp, vec3(233., 51., 74.)/255., color[0]);\n    \n    fragColor = vec4(mix(temp,  vec3(.4, 0., 0.),clamp(color[0] - color[1], 0., 1.)), 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}