{
    "Shader": {
        "info": {
            "date": "1477259210",
            "description": "BLUE=obstacles/hills, RED=food, CENTER=nest\nLMB=show scent marks, new trails, paint food (repl.obstacles)\nRestart shader for new environment. \n2 seconds to go fullscreen!\nInitially you might have to restart the shader after all textures are loaded.",
            "flags": 32,
            "hasliked": 0,
            "id": "MtKGD3",
            "likes": 17,
            "name": "Ant Trail Simulation",
            "published": 3,
            "tags": [
                "ants",
                "multiagentsystem"
            ],
            "usePreview": 0,
            "username": "movAX13h",
            "viewed": 1508
        },
        "renderpass": [
            {
                "code": "/*\n\tDISPLAY AGENTS AND SHOW SCENT & OBSTACLE MAP\n\tPart of \"Multi Agent System\", ant trail simulation\n    https://en.wikipedia.org/wiki/Multi-agent_system\n\tShadertoy by movAX13h, october 2016\n*/\n\nfloat rand(float n) { return fract(sin(n)*43758.5453); }\nfloat rand(vec2 co) { return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5357); }\n\nconst float PI2 = 6.283185307;\nconst int NUMRT=14;\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pix = floor(fragCoord);\n    vec2 nestPos = floor(0.5*iResolution.xy);\n    \n    vec3 col = vec3(0.0);\n    \n    // show food, scent and obstacle map\n    vec4 env = texture(iChannel1, uv);\n    col = env.rgb;\n    \n    if (iMouse.z < 0.5) col.g = 0.0;\n\n    \n    col.g = max(env.a, col.g * smoothstep(1.0, 0.0, col.r));\n    \n    // find closest agent\n    vec4 agent = vec4(0.0);\n\tfloat minD = 1e6;\n    float d;\n    int id = 0;\n    \n    for(int j=0; j<NUMRT; j++)\n    for(int i=0; i<NUMRT; i++)\n    {\n        vec2 sPos = vec2(float(i), float(j));\n        \n        vec4 a = texture(iChannel0,sPos/iResolution.xy);\n        d = length(fragCoord - a.xy);\n        \n        if (d < 12.0 && d < minD) // agent is in range\n        {\n            minD = d;\n            agent = a; // position, rotation, mode\n            id = i + j*NUMRT;\n        }\n        \n    }    \n\n    if (agent.a > 0.5) // valid agent\n    {\n        vec2 forward = vec2(cos(agent.z), sin(agent.z));\n        float dForward = length(fragCoord - agent.xy - 4.0*forward);\n\n        float s = step(abs(float(id)-2.0), 0.1);\n        float agentSize = 3.0 + s * 2.0;\n        vec3 agentColor = mix(vec3(0.8, 0.8, 1.0), vec3(1.0, 1.0, 0.0), s);\n\n        // agent\n        col = mix(agentColor, col, smoothstep(0.0, agentSize, minD));\n        \n        // attachments depending on mode\n        if (agent.a < 1.5) // just running around\n        {\n            // forward marker\n            col = mix(vec3(0.4, 0.4, 0.5), col, smoothstep(0.0, 2.0, dForward));\n        }\n        else if (agent.a < 2.5) // picking up food\n        {\n            if (mod(iTime, 0.4) > 0.2) col = mix(vec3(1.0, 0.0, 0.0), col, smoothstep(2.0, 5.0, minD));\n        }\n        else if (agent.a < 3.5) // carrying foot to nest\n        {\n            // food\n            col = mix(vec3(1.0, 0.0, 0.0), col, smoothstep(0.0, 2.0, dForward));\n        }\n        \n        //if (id == 10) col = mix(vec3(1.0, 1.0, 0.0), col, smoothstep(0.0, 1.5, abs(minD-10.0)));\n        \n    }\n  \n    // nest\n    col = mix(col, vec3(1.0), smoothstep(60.0, 0.0, length(pix-nestPos)));\n    \n\tfragColor = vec4(clamp(col, vec3(0.0), vec3(1.0)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\tAGENT CONTROLLER\n\tPart of \"Multi Agent System\", ant trail simulation\n\tShadertoy by movAX13h, october 2016\n*/\n\n//float rand(float n) { return fract(sin(n)*43758.5453); }\n//float rand(vec2 co) { return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5357); }\n\nfloat rand(vec2 n) { return texture(iChannel3, n*0.73175).r; }\nfloat rand(float n) { return rand(vec2(fract(n))); }\n\n\nconst float PI =  3.141592653;\nconst float PI2 = 6.283185307;\nconst int NUMRT=14;\n\nvoid rotate(inout float r, in vec2 dir, in float limit)\n{\n\tfloat ta = atan(dir.y,dir.x);\n    float d = mod(ta - r, PI2);\n    d -= step(0.0, d - PI) * PI2; // shorter angle\n    r += clamp(d, -limit, limit);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pix = floor(fragCoord);\n    vec2 nestPos = floor(0.5*iResolution.xy);\n    \n    if (iFrame < 120) // spawn agents at nest\n    {\n        vec4 value = vec4(0.0);\n        \n        for(int j=0; j<NUMRT; j++)\n        for(int i=0; i<NUMRT; i++)\n        {\n            vec2 aPos = vec2(float(i), float(j));\n        \tif (length(pix - aPos) < 0.1) value = vec4(nestPos, PI2*rand(aPos+vec2(1.3725, 7.2142)), 1.0); // position, rotation, mode\n        }\n        \n    \tfragColor = value;\n        return;\n    }\n       \n    // update agent\n    vec4 agent = texture(iChannel0, uv);\n    \n    if (agent.a < 0.5) // not a agent data slot?\n    {\n        fragColor = agent;\n     \treturn;   \n    }\n    \n    \n    float r = rand(pix+vec2(5.3131, 1.7325));\n\n    // sample of food & scene map\n    vec4 env = texture(iChannel1, agent.xy/iResolution.xy);\n\n    // pick samples around agent and find min/max values & directions\n    vec2 scentDir = vec2(0.0);\n    vec2 sd; // sample direction\n    float bestScent = 0.0;\n    vec4 envSample;\n\n    float lowGround = 1e8;\n    vec2 lowGroundDir = vec2(0.0);\n\n    float highGround = 0.0;\n    vec2 highGroundDir = vec2(0.0);\n\n    //TODO: detect same values (or avoid same values in scent map)\n    const float sda = 3.0;\n\n    #define ENVPICK(sdx,sdy) sd = vec2(sdx,sdy);\\\n    \tenvSample = texture(iChannel1, (agent.xy+sd)/iResolution.xy);\\\n        if (envSample.g > bestScent) {\\\n            bestScent = envSample.g;\\\n            scentDir = sd;\\\n        }\\\n    \tif (envSample.b < lowGround) {\\\n            lowGround = envSample.b;\\\n            lowGroundDir = sd;\\\n        }\\\n    \tif (envSample.b > highGround) {\\\n            highGround = envSample.b;\\\n            highGroundDir = sd;\\\n        }\n\n    ENVPICK(-sda,-sda);\n    ENVPICK( sda,-sda);\n    ENVPICK(-sda, sda);\n    ENVPICK( sda, sda);\n\n    ENVPICK( 0.0,-sda);\n    ENVPICK( 0.0, sda);\n    ENVPICK(-sda, 0.0);\n    ENVPICK( sda, 0.0);\n\n    \n    // SEARCHING FOR FOOD\n    if (agent.a < 1.5)\n    {\n        float agentSpeed = 0.4 + 0.4 * r;\n        bool scentDone = false;\n        \n        // ant leaves the canvas -> revert direction\n        if (agent.x > iResolution.x || agent.x < 0.0 || agent.y > iResolution.y || agent.y < 0.0) \n        {\n            agent.z += PI;\n        }\n\n        // sometimes do ...\n        if (rand(r*agent.x+0.13757*iTime) < 0.25)\n        {\n            // rotate towards scent\n            if (bestScent > 0.01) \n            {\n                rotate(agent.z, scentDir, 0.3);\n                scentDone = true;\n            }\n        }\n\n        // avoid obstacles\n        if (highGround > 0.05 && bestScent < highGround)\n        {\n            #if 1\n            // rotate towards lowest point\n            rotate(agent.z, lowGroundDir, 0.2*lowGround);\n            #else\n            // rotate away from highest point\n            rotate(agent.z, highGroundDir, 0.2*highGround);\n            #endif\n\n        }\n        else if (!scentDone)\n            agent.z += 0.4*rand(agent.x + agent.y + iTime) - 0.2; // no scent and no hill detected -> free passage\n\n        // hit food!!!\n        if (env.r > 0.2) agent.a = 2.0;\n\n        agent.x += agentSpeed*cos(agent.z);\n        agent.y += agentSpeed*sin(agent.z);\n    }\n    \n    // PICKING UP FOOD\n    else if (agent.a < 2.5)\n    {\n        agent.a += iTimeDelta*0.3;\n\n        vec2 d = nestPos - agent.xy;\n        agent.z = atan(d.y, d.x);\n    }        \n    \n    // CARRYING FOOD TO NEST\n    else if (agent.a < 3.5)\n    {\n        float agentSpeed = 0.4 + 0.1 * r;\n        \n        //  walk back avoiding obstacles\n\t\tvec2 d = nestPos - agent.xy;\n        float toNest = 0.2;\n        \n        // avoid obstacles\n        if (highGround > 0.01)\n        {\n            #if 1\n            // rotate towards lowest point\n            rotate(agent.z, lowGroundDir, 0.4*lowGround);\n            #else\n            // rotate away from highest point\n            rotate(agent.z, highGroundDir, 0.4*highGround);\n            #endif\n            toNest = 0.1;\n        }\n        \n      \t// rotate towards nest\n       \trotate(agent.z, d, toNest);\n\n        if (length(d) < 4.0) // drop food at nest\n        {\n            agent.a = 1.0;\n            #if 0\n            // reverse direction\n            agent.z += PI; \n            #else\n            // randomize direction\n            agent.z = PI2 * rand(agent.z + iTime);\n            #endif\n        }\n        else\n        {\n            // hit the wall, revert direction\n            if (agent.x > iResolution.x || agent.x < 0.0 || agent.y > iResolution.y || agent.y < 0.0) \n            {\n                agent.z += PI;\n            }\n        }\n\n        agent.x += agentSpeed*cos(agent.z);\n        agent.y += agentSpeed*sin(agent.z);\n    }\n    \n    fragColor = agent;    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n\tFOOD, SCENT MARK & OBSTACLE CONTROLLER\n\tPart of \"Multi Agent System\", ant trail simulation\n\tShadertoy by movAX13h, october 2016\n*/\n\nfloat rand(vec2 n) { return texture(iChannel3, n*0.73175).r; }\nfloat rand(float n) { return rand(vec2(n)); }\n\nconst int NUMRT=14;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = uv;\n    st.x *= iResolution.x / iResolution.y;\n        \n    vec2 nestPos = floor(0.5*iResolution.xy);\n    \n    // spawn food all around nest\n    if (iFrame < 120) \n    {\n        float d = length(nestPos - fragCoord);\n        \n        float envValue = texture(iChannel2, 0.2*st+0.1*vec2(floor(iDate.w),fract(iDate.w))).r;\n        \n        // food\n        float food = smoothstep(0.2, 0.19, envValue) * smoothstep(170.0, 180.0, d);\n        \n        // obstacles\n        float obstacle = smoothstep(0.7, 1.0,  envValue * 2.0) * smoothstep(150.0, 170.0, d);\n        \n        // frame obstacle\n        obstacle += smoothstep(0.5, 0.6, length(uv-0.5));\n        \n        // store environment data\n    \tfragColor = vec4(food, 0.0, max(0.0, clamp(obstacle-food, 0.0, 1.0) - 0.06*rand(st)), 0.0);\n        return;\n    }    \n    \n    \n    vec4 smpl = texture(iChannel1, uv);\n\n    if (iMouse.z > 0.5) \n    {\n        float mDist = length(fragCoord - iMouse.xy);\n        smpl.r += 0.1*smoothstep(20.0, 0.0, mDist);\n        smpl.b = max(0.0, smpl.b - 0.1*smoothstep(20.0, 0.0, mDist));\n    }\n\n    \n    // scent fade\n    smpl.g = max(0.0, smpl.g - 0.04 * iTimeDelta);\n    \n    // check agents\n    for(int j=0; j<NUMRT; j++)\n    for(int i=0; i<NUMRT; i++)\n    {\n        vec2 sPos = vec2(float(i), float(j));\n        vec4 agent = texture(iChannel0,sPos/iResolution.xy);\n        \n\t\tfloat d = length(fragCoord - agent.xy);\n\t\tfloat dFwd = length(fragCoord - agent.xy + 6.0*vec2(cos(agent.z), sin(agent.z)));\n        float nestFactor = 2.0 * length(nestPos - agent.xy) / iResolution.x + 0.1;\n        \n        // just running around\n        if (agent.a < 1.5) \n        {\n            //sample.b += smoothstep(4.0, 0.0, d) * iTimeDelta * 0.2;\n            smpl.g = max(0.0, smpl.g - smoothstep(5.0, 0.0, d) * iTimeDelta * 0.08); // remove some scent\n            if (iMouse.z > 0.5) smpl.a += iTimeDelta * smoothstep(3.0, 0.0, d);\n            else smpl.a = 0.0;\n        }\n        \n        // picking up food\n        else if (agent.a < 2.5) \n        {\n            smpl.r *= smoothstep(0.0, 4.0, d); // remove food\n            smpl.g += smoothstep(30.0, 0.0, dFwd) * iTimeDelta * 0.1; // spray scent\n        }\n        \n        // carrying food to nest\n        else if (agent.a < 3.5) \n        {\n            float scent = smoothstep(10.0 * (nestFactor + 1.0), 0.0, d) * iTimeDelta * nestFactor;\n            //scent *= min(1.0, 0.4 + smoothstep(0.7, 0.0, sample.b));\n            if (smpl.g > 1.0) scent *= 0.4;\n            smpl.g += scent;\n        }        \n        \n    }      \n    \n    \n    fragColor = smpl;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}