{
    "Shader": {
        "info": {
            "date": "1576952190",
            "description": "An attempt at making the original sphereflake implementation. Use the mouse to rotate around the sphere.\nhttps://erich.realtimerendering.com/rtrt/index.html\n\nYou may need to disable ANGLE if the code does not compile for you.",
            "flags": 0,
            "hasliked": 0,
            "id": "3dGXDt",
            "likes": 0,
            "name": "Sphereflake",
            "published": 3,
            "tags": [
                "fractal",
                "sphere",
                "sphereflake"
            ],
            "usePreview": 0,
            "username": "moon4u",
            "viewed": 542
        },
        "renderpass": [
            {
                "code": "\n#define\tHASH_CONST\tvec3( 3.5453123, 4.1459123, 1.3490423 )\nvec3\thash3( float n )\n{\n\treturn\tfract( sin( vec3( n, n + 1.0, n + 2.0 ) ) * HASH_CONST );\n}\n\nstruct\tSphereFlakeElement\n{\n    vec3\tcenter;\n    vec3\tdirection;\n    int\t\tsphereIndex;\n    float\tradius;\n} g_stack[ STACK_MAX_SIZE + 1 ];\nfloat\tSphereFlakeShadowStack( in vec3 ro, in vec3 rd )\n{\n    float\tresult\t= 1.0;\n\n    int\tidx\t= 1;\n// Get current element on the stack.\n#define\tSFEL g_stack[ idx ] \n// Get parent element on the stack\n#define\tSFPEL g_stack[ idx - 1 ]\n// Get parent's parent element on the stack\n#define\tSFPPEL g_stack[ idx - 2 ]\n// Do sphere intersect call on the current element on the stack.\n#define SFShadow sphSoftShadow( ro, rd, SFEL.center, SFEL.radius, result )\n// Do sphere intersect test call on the current element on the stack.\n#define SFIntersectTest sphIntersectTest( ro, rd, SFEL.center, SFEL.radius )\n// Check if current element on the stack has a small radius.\n#define SFIsRadTooSmall isRadTooSmall( ro, SFEL.center, SFEL.radius )\n\n    if( ! SFIntersectTest )\n        return\tresult;\n\n    SFShadow;\n\n    idx = 2;\n    while( idx > 1 )\n    {\n        if( SFEL.sphereIndex == TOTAL_SPHERES_COUNT )\n        {\n            SFEL.sphereIndex\t= 0;\n            idx--;\n            continue;\n        }\n\n        vec3\tperp1\t= normalize( cross( SFPEL.direction, SFPPEL.direction ) );\n        vec3\tperp2\t= normalize( cross( SFPEL.direction, perp1 ) );\n\n        vec3\trot\t\t= perp1 * PERP1MOD( SFEL.sphereIndex ) \n            \t\t\t+ perp2 * PERP2MOD( SFEL.sphereIndex );\n\n        vec3\tdirNN\t= SFPEL.direction * YAXIS_COS( SFEL.sphereIndex )\n            \t\t\t+ rot;\n        \n        SFEL.direction\t= normalize( dirNN );\n        SFEL.center\t\t= SFEL.direction * ( SFEL.radius + SFPEL.radius ) \n            \t\t\t+ SFPEL.center;\n\n        SFEL.sphereIndex++;\n        \n        if( SFIsRadTooSmall || ! SFIntersectTest )\n            continue;\n\n        SFShadow;\n\n        if( idx == STACK_MAX_SIZE )\n            continue;\n\n\t\tidx++;\n    }\n    \n    return\tresult;\n}\n\nSFHit\tSphereFlakeIntersectStack( in vec3 ro, in vec3 rd )\n{\n    SFHit\thit;\n    hit.dist\t= -1.0;\n    hit.resMin\t= -1.0;\n    hit.resMax\t= 1000.0;\n\n    int\tidx\t= 1;\n// Get current element on the stack.\n#define\tSFEL g_stack[ idx ] \n// Get parent element on the stack\n#define\tSFPEL g_stack[ idx - 1 ]\n// Get parent's parent element on the stack\n#define\tSFPPEL g_stack[ idx - 2 ]\n// Do sphere intersect call on the current element on the stack.\n#define SFIntersect sphIntersect( ro, rd, SFEL.center, SFEL.radius, hit )\n// Do sphere intersect test call on the current element on the stack.\n#define SFIntersectTest sphIntersectTest( ro, rd, SFEL.center, SFEL.radius )\n// Check if current element on the stack has a small radius.\n#define SFIsRadTooSmall isRadTooSmall( ro, SFEL.center, SFEL.radius )\n\n    if( ! SFIntersectTest )\n        return\thit;\n\n    SFIntersect;\n\n    idx = 2;\n    while( idx > 1 )\n    {\n        if( SFEL.sphereIndex == TOTAL_SPHERES_COUNT )\n        {\n            SFEL.sphereIndex\t= 0;\n            idx--;\n            continue;\n        }\n\n        int\t\tsphIdx\t= SFEL.sphereIndex;\n        vec3\tparDir\t= SFPEL.direction;\n        \n        vec3\tperp1\t= normalize( cross( parDir, SFPPEL.direction ) );\n        vec3\tperp2\t= normalize( cross( parDir, perp1 ) );\n\n        vec3\trot\t\t= perp1 * PERP1MOD( sphIdx ) \n            \t\t\t+ perp2 * PERP2MOD( sphIdx );\n\n        vec3\tdirNN\t= parDir * YAXIS_COS( sphIdx ) + rot;\n        \n        SFEL.direction\t= normalize( dirNN );\n        SFEL.center\t\t= SFEL.direction * ( SFEL.radius + SFPEL.radius ) \n            \t\t\t+ SFPEL.center;\n\n        SFEL.sphereIndex++;\n        \n        if( SFIsRadTooSmall || ! SFIntersectTest )\n            continue;\n\n        SFIntersect;\n\n        if( idx == STACK_MAX_SIZE )\n            continue;\n\n\t\tidx++;\n    }\n    \n    return\thit;\n}\n\nvec3\tlight\t= vec3( 10.0, 10.0, 10.0 );\nvec4\ttrace( vec3 ro, vec3 rd )\n{\n    // Setup stack at start, so we don't calculate it every time.\n    float\tcRad\t= STARTING_RADIUS;\n    for( int i = 1; i < STACK_MAX_SIZE; ++i )\n    {\n        g_stack[ i ].sphereIndex\t= 0;\n        g_stack[ i ].radius\t\t= cRad;\n        cRad\t\t\t\t\t\t*= RADIUS_RATIO;\n    }\n    g_stack[ 0 ].sphereIndex\t= 0;\n    g_stack[ 0 ].radius\t\t= STARTING_RADIUS;\n    g_stack[ 0 ].center\t\t= vec3( 0.0, 0.0, 0.0 );\n    g_stack[ 0 ].direction\t= vec3( 0.0, 0.0, 1.0 );\n    g_stack[ 1 ].center\t\t= vec3( 0.0, 0.0, 0.0 );\n    g_stack[ 1 ].direction\t= vec3( 0.0, 1.0, 0.0 );\n    \n\tvec3\tc\t= vec3( 0.0 );\n\n\tfor( int j = 0; j < AA; ++j )\n\tfor( int i = 0; i < AA; ++i )\n\t{\n\t\tvec3\tnRo\t= ro;\n\t\tnRo.x += float( i ) / iResolution.x;\n\t\tnRo.y += float( j ) / iResolution.y;\n\n\t\tSFHit\tflakeHit;\n        flakeHit\t= SphereFlakeIntersectStack( nRo, rd );\n\n\t\tif( flakeHit.dist == -1.0 )\n\t\t\treturn\ttexture( iChannel0, rd );\n\n\t\tvec3\thit\t= ( nRo + rd * flakeHit.dist );\n\t\tvec3\tdir\t= light - hit;\n\t\tfloat\tlen\t= length( dir );\n        \n        float\tshadow;\n        shadow\t= SphereFlakeShadowStack( hit, normalize( dir ) );\n\n\t\tvec3\tpo\t= hit - flakeHit.hitPoint;\n        po /= flakeHit.radius;\n\t\tvec3\th\t= hash3( flakeHit.radius );\n\t\th\t+=  po.y * 0.5;\n        h\t*= normalize( shadow );\n\n\t\tc\t+= h;\n\t}\n\n\treturn\tvec4( c / float( AA * AA ), 1.0 );\n}\n\n\nmat3\tlookat( vec3 eye, vec3 at, vec3 up )\n{\n\tvec3\tf\t= normalize( at - eye );\n\tvec3\ts\t= normalize( cross( f, up ) );\n\tvec3\tu\t= normalize( cross( s, f ) );\n\n\treturn\tmat3( s, u, -f );\n}\n\nvec3\tsphere2xyz( float yaw, float pitch )\n{\n\treturn\tvec3( sin( pitch ) * cos( yaw ),\n\t\t\t\t  cos( pitch ),\n\t\t\t\t  sin( pitch ) * sin( yaw ) );\n}\nfloat\tlinscale( float x, float x1, float x2, float y1, float y2 )\n{\n\treturn\t( y2 - y1 ) / ( x2 - x1 ) * ( x - x1 ) + y1;\n}\n\nvec2\tscreen_space( vec2 pixel, vec2 dim )\n{\n\treturn\t( pixel - 0.5 * dim ) / min( dim.x, dim.y );\n}\n\n#define PI 3.14159\nvoid\tmainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tInitializeConsts();\n\n#ifdef ROTATE_LIGHT\n\tvec3\tdirr\t= vec3( 1.0, 0.0, 0.0 );\n    vec3\tdirf\t= vec3( 0.0, 0.0, 1.0 );\n    \n    float\tllen\t= length( light );\n    light\t\t\t= dirr * sin( iTime ) + dirf * cos( iTime );\n    light\t\t\t*= llen;\n#endif\n    \n    vec2\tp\t\t= screen_space( fragCoord.xy, iResolution.xy );\n    float\tmx\t\t= 0.5;\n    float\tmy\t\t= 0.5;\n    if( iMouse.x != 0.0 )\n        mx\t\t= iMouse.x / iResolution.x;\n    if( iMouse.y != 0.0 )\n        my\t\t= iMouse.y / iResolution.y;\n\tfloat\tyaw\t\t= linscale( mx, 0.0, 1.0, -PI, PI );\n\tfloat\tpitch\t= linscale( my, 0.0, 1.0, 0.0, PI );\n\n\tfloat\tdist\t= 4.0 - sin( iTime * 0.3 ) * 2.5;\n\n\tvec3\tro \t\t= dist * sphere2xyz( yaw, pitch );\n\tvec3\tat\t\t= vec3( 0, 0, 0 );\n\tvec3\tup\t\t= vec3( 0, 1, 0 );\n\tvec3\trd\t\t= lookat( ro, at, up ) * normalize( vec3( p, -1.0 ) );\n\n\tfragColor\t\t= trace( ro, rd );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// Antialiasing.\n#define AA 1\n\n// Each stack adds another level of spheres\n#define\tSTACK_MAX_SIZE\t\t\t32\n\n// Number of type1 and type2 spheres.\n#define\tTYPE1_SPHERES_COUNT\t\t6\n#define\tTYPE2_SPHERES_COUNT\t\t3\n\n// Sphere Y axis position. Only between 0 and 90 degrees.\n#define\tTYPE1_SPHERES_DEGREE\t90.0\n#define\tTYPE2_SPHERES_DEGREE\t30.0\n\n// Rotation on the surface of the sphere\n#define\tTYPE1_SPHERES_ROTATION\t0.0\n#define TYPE2_SPHERES_ROTATION\t60.0\n\n#define\tRADIUS_RATIO\t\t\t( 1.0 / 3.0 )\n\n#define\tSTARTING_RADIUS\t\t\t1.\n\n// Total number of spheres.\n#define TOTAL_SPHERES_COUNT\tTYPE1_SPHERES_COUNT + TYPE2_SPHERES_COUNT\n\n// Macros used for conviniense to access the stack (and consts).\n\n// Get cos of the angle of rotation on the y axis.\n#define YAXIS_COS( x ) g_consts.yAxisRotCosines[ x ]\n\n#define\tPERP1MOD( x ) g_consts.perp1Mod[ x ]\n#define\tPERP2MOD( x ) g_consts.perp2Mod[ x ]\n\nstruct\tSphereConsts\n{\n\n\tfloat\tyAxisRotCosines[ TOTAL_SPHERES_COUNT ];\n    \n    float\tperp1Mod[ TOTAL_SPHERES_COUNT ];\n    float\tperp2Mod[ TOTAL_SPHERES_COUNT ];\n} g_consts;\n\nvoid\tInitializeConsts()\n{\n\tfloat\trotateSines[ TOTAL_SPHERES_COUNT ];\n\tfloat\trotateCosines[ TOTAL_SPHERES_COUNT ];\n\tfloat\tyAxisRotSines[ TOTAL_SPHERES_COUNT ];\n    \n\tfloat\tangle1\t= radians( 360.0 / float( TYPE1_SPHERES_COUNT ) );\n\tfloat\tangle2\t= radians( 360.0 / float( TYPE2_SPHERES_COUNT ) );\n\n\tfloat\tt1Rads\t= radians( TYPE1_SPHERES_ROTATION );\n\tfloat\tt2Rads\t= radians( TYPE2_SPHERES_ROTATION );\n\tfor( int k = 0; k < TYPE1_SPHERES_COUNT; ++k )\n\t{\n\t\trotateSines[ k ]\t= sin( t1Rads + angle1 * float( k ) );\n\t\trotateCosines[ k ]\t= cos( t1Rads + angle1 * float( k ) );\n\t}\n\n\tfor( int k = TYPE1_SPHERES_COUNT; k < TOTAL_SPHERES_COUNT; ++k )\n\t{\n\t\trotateSines[ k ]\t= sin( t2Rads + angle2 * float( k ) );\n\t\trotateCosines[  k ]\t= cos( t2Rads + angle2 * float( k ) );\n\t}\n\n\tfloat\tt1sin\t= sin( radians( TYPE1_SPHERES_DEGREE ) );\n\tfloat\tt1cos\t= cos( radians( TYPE1_SPHERES_DEGREE ) );\n\tfloat\tt2sin\t= sin( radians( TYPE2_SPHERES_DEGREE ) );\n\tfloat\tt2cos\t= cos( radians( TYPE2_SPHERES_DEGREE ) );\n\tfor( int k = 0; k < TYPE1_SPHERES_COUNT; ++k )\n\t{\n\t\tyAxisRotSines[ k ]\t= t1sin;\n\t\tYAXIS_COS( k )\t\t= t1cos;\n\t}\n\n\tfor( int k = TYPE1_SPHERES_COUNT; k < TOTAL_SPHERES_COUNT; ++k )\n\t{\n\t\tyAxisRotSines[ k ]\t= t2sin;\n\t\tYAXIS_COS( k )\t\t= t2cos;\n\t}\n    \n    for( int k = 0; k < TOTAL_SPHERES_COUNT; ++k )\n    {\n        PERP1MOD( k )\t= yAxisRotSines[ k ] * rotateCosines[ k ];\n        PERP2MOD( k )\t= yAxisRotSines[ k ] * rotateSines[ k ];\n    }\n}\n\n\n// This function is supposed to discard spheres that are\n// smaller than a pixel (or two).\n// (Not sure on it's correctness, tho)\nconst float\tPIXEL_AT_DISTANCE\t= 2.0 * sin( 1.0 / 2.0 );\nbool\tisRadTooSmall( in vec3 ro, in vec3 curCntr, float curRad )\n{\n\tfloat\tdist\t= abs( length( ro - curCntr ) );\n\tfloat\tresult\t= PIXEL_AT_DISTANCE * 1024.0 * curRad / dist;\n\tif( result < 2.0 )\n\t\treturn\ttrue;\n\n\treturn\tfalse;\n}\n\n\nstruct\tSFHit\n{\n\tvec3\thitPoint;\n\tfloat\tdist;\n\tfloat\tresMax;\n\tfloat\tresMin;\n\tfloat\tradius;\n};\n\n// Checks intersection and returns the distance.\nfloat\tsphIntersect( in vec3 ro, in vec3 rd, in vec3 ca, in float ra, inout SFHit result )\n{\n\tvec3\toc\t= ro - ca;\n\tfloat\tb\t= dot( oc, rd );\n\tfloat\tc\t= dot( oc, oc ) - ra * ra;\n\tfloat\th\t= b * b - c;\n\n\tif( h < 0.0 ) // no intersection\n\t\treturn\t-1.0;\n\n\th\t= sqrt( h );\n\n\tfloat\tres\t= max( 0.0, min( - b - h, - b + h ) );\n\tif( res > result.resMin && res < result.resMax )\n\t{\n\t\tresult.radius\t= ra;\n\t\tresult.hitPoint\t= ca;\n\t\tresult.dist\t\t= res;\n\t\tresult.resMax\t= res;\n\t}\n}\n\n// This simply checks if a sphere is intersected, does not compute distance.\nbool\tsphIntersectTest( in vec3 ro, in vec3 rd, in vec3 ca, in float ra )\n{\n\tvec3\toc\t= ro - ca;\n\tfloat\tb\t= dot( oc, rd );\n\tfloat\tc\t= dot( oc, oc ) - 4.0 * ra * ra;\n\tfloat\th\t= b * b - c;\n\n\treturn\th >= 0.0;\n}\n\n#define k 0.5\n\nvoid sphSoftShadow( in vec3 ro, in vec3 rd, in vec3 sph, in float ra, inout float result )\n{\n    vec3\toc\t= ro - sph;\n    float\tb\t= dot( oc, rd );\n    float\tc\t= dot( oc, oc ) - ra * ra;\n    float\th\t= b*b - c;\n\n    float\tres\t= (b>0.0) ? step(-0.0001,c) : smoothstep( 0.0, 1.0, h*k/b );\n\n    result\t= min( result, res );\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}