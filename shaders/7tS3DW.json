{
    "Shader": {
        "info": {
            "date": "1624168616",
            "description": "This would not have been possible without epic michael0884's help! DaniilMaks, a user on the SpaceEngine Discord gave invaluable color management help.",
            "flags": 32,
            "hasliked": 0,
            "id": "7tS3DW",
            "likes": 44,
            "name": "Path-Traced Black Hole",
            "published": 3,
            "tags": [
                "pathtrace",
                "pathtracing",
                "pathtracer",
                "blackhole",
                "tracing",
                "traced",
                "tracer",
                "optics",
                "trace",
                "path",
                "hole",
                "optic",
                "black",
                "bh",
                "pathtraced"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 1768
        },
        "renderpass": [
            {
                "code": "// ####### Path-Traced Black Hole #######\n// Made by Jacob Bingham (Zi7ar21) on June 19th, 2021\n// Happy Juneteenth :)\n\n// Last Updated on September 11th, 2021 at 20:30 Mountain Standard Time\n// (I realized I made a mistake and was using density instead of absorbance when determining if a ray should bounce, oops! Fixed.)\n\n// If you found this anywhere except Shadertoy, you can find the original and possibly updated version at:\n// https://www.shadertoy.com/view/7tS3DW\n\n/* I wanted to know how to Ray-March a black hole, I initially used Newtonian gravity (1/r^2) as the force acting on the ray,\nbut michael0884 showed me that there is a better way of doing it and so I ~~stole~~ borrowed that. He sent a link to a cool\narticle which I think he used. Check it out at: https://rantonels.github.io/starless/. This Shader features:\n- Parameters (on Shadertoy, go to Common)\n- Ray-Marched Black Hole Simulation\n- Volumetric Accretion Disk (the stuff orbiting the Black Hole)\n- HDR and Tonemapped Image Preview\n- Monte-Carlo Bloom\n- XYZ Color Management Stuff\n- OpenEXR Export (on Shadertoy, go to Buffer B)\n- Some fixes and visual improvements from michael0884\n- idk what else to advertize, I really like how this turned out\n*/\n\n/*\nTodo:\n- Redshift/Blueshift (eh there isn't really a way to do this accurately without going to spectral rendering)\n- Kerr metric Stuff (lmao funny joke, if I can't add Redshift/Blueshift then there is no chance of this being added)\n- idk tell me what I should do\n*/\n\n// \"License\":\n// You are free to use this code, even commercially, as long as you keep comments in the source with credits to snippets that aren't mine.\n// e.g. PCG Random: https://www.pcg-random.org/\n// Of course, you must also still respect whatever licenses they use. We are programmers, not lawyers! :)\n\n// Check out my friends!\n// michael0884\n// https://www.shadertoy.com/user/michael0884\n// loicvdb\n// https://www.shadertoy.com/user/loicvdb\n// Dumb_Pyscho\n// https://www.shadertoy.com/user/Dumb_Psycho\n\n// Render Preview\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get the Image Export Buffer\n    vec3 color = texel0.rgb;\n\n    // HDR Tonemapping\n    color = tonemap(color);\n\n    // Output the Image Preview\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ##### Preprocessor #####\n\n/*\n//\n#if __VERSION__ < 300\n#error This shader requires GLSL 300 ES to run!\n#endif\n*/\n\n// Build Flags\n//#pragma optimize(on)\n//#pragma debug(off)\n\n// ##### Parameters #####\n\n// Exposure\n#define exposure 1.0\n\n// Image Gamma\n// unused by the default tonemap, uncomment one of the other one to use this\n//#define gamma 2.2\n\n// Camera Field of View\n#define camfov 1.0\n\n#define dt 0.05\n#define blackholeRadius 0.5\n#define maxSteps 65536U\n#define maxDist 4.0\n#define maxBounces 8U\n\n// Camera Sensor Size (for DoF, unused by default, uncomment it in Buffer A)\n//#define sensorSize 0.035\n\n// ##### Constants #####\n\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\n#define pi 3.1415926535897932384626433832795028841971693993751058209749445923078164\n#define twopi pi*2.0\n\n// ##### Shortcuts #####\n\n// Traditional Input Names (Shadertoy Only)\n#define resolution iResolution\n#define frame iFrame\n\n// Sample Buffer\n#define texel0 texelFetch(iChannel0, ivec2(gl_FragCoord.xy), 0)\n#define texel1 texelFetch(iChannel1, ivec2(gl_FragCoord.xy), 0)\n#define texel2 texelFetch(iChannel2, ivec2(gl_FragCoord.xy), 0)\n#define texel3 texelFetch(iChannel3, ivec2(gl_FragCoord.xy), 0)\n\n// ##### Additional Maths #####\n\n// Rotate a 2-Component Vector\nvec2 rotate2(vec2 vec, float rot)\n{\n    float s = sin(rot), c = cos(rot);\n    return vec2(vec.x*c-vec.y*s, vec.x*s+vec.y*c);\n}\n\n// Dot Product\n// For optimizations involving comparing length, for example:\n// min(length(vector0), length(vector1))\n// This can be simplified and save 1 sqrt computation by changing it to:\n// sqrt(min(dotp(vector0), dotp(vector1)))\n\nfloat dotp(vec2 vec)\n{\n    return dot(vec, vec);\n}\n\nfloat dotp(vec3 vec)\n{\n    return dot(vec, vec);\n}\n\nfloat dotp(vec4 vec)\n{\n    return dot(vec, vec);\n}\n\n// ##### Color Management #####\n\n/*\n// https://www.color.org/chardata/rgb/sRGB.pdf\nconst mat3 XYZ2sRGB = mat3(\n 3.2406255, -1.5372080, -0.4986286,\n-0.9689307,  1.8757561,  0.0415175,\n 0.0557101, -0.2040211,  1.0569959);\n*/\n/*\n// https://www.shadertoy.com/view/4s3cRr\nconst mat3 XYZ2sRGB = mat3(\n 3.2404542, -1.5371385, -0.4985314,\n-0.9692660,  1.8760108,  0.0415560,\n 0.0556434, -0.2040259,  1.0572252);\n*/\n/*\n// https://www.shadertoy.com/view/tsKczy\nconst mat3 XYZ2sRGB = mat3(\n 3.2409699419, -1.5373831776, -0.4986107603,\n-0.9692436363,  1.8759675015,  0.0415550574,\n 0.0556300797, -0.2039769589,  1.0569715142);\n*/\n\n// Every XYZ to sRGB matrix I find is slightly different, so here is a rounded off one:\nconst mat3 XYZ2sRGB = mat3(\n 3.240, -1.537, -0.499,\n-0.969,  1.876,  0.042,\n 0.056, -0.204,  1.057);\n\n// Convert XYZ to sRGB\nvec3 XYZtoRGB(vec3 XYZ)\n{\n    return XYZ*XYZ2sRGB;\n}\n\n// idk what to cite, here are some shaders that all use this:\n// https://www.shadertoy.com/view/tsKczy\n// https://www.shadertoy.com/view/MslSDl\n// https://www.shadertoy.com/view/MttyzB\nvec3 blackbodyXYZ(float t)\n{\n    // https://en.wikipedia.org/wiki/Planckian_locus\n    float u = (0.860117757+1.54118254E-4*t+1.28641212E-7*t*t)/(1.0+8.42420235E-4*t+7.08145163E-7*t*t);\n    float v = (0.317398726+4.22806245E-5*t+4.20481691E-8*t*t)/(1.0-2.89741816E-5*t+1.61456053E-7*t*t);\n\n    // https://en.wikipedia.org/wiki/CIE_1960_color_space\n    // https://en.wikipedia.org/wiki/XYZ_color_space\n\n    // Hippitty Hoppity through magic convert the planckian locus to some weird Color space linked to XYZ\n    vec2 xyy = vec2(3.0*u, 2.0*v)/(2.0*u-8.0*v+4.0);\n\n    // And then convert from the shart color space to XYZ and fart it out\n    return vec3(xyy.x/xyy.y, 1.0, (1.0-xyy.x-xyy.y)/xyy.y);\n}\n\n// Sh*tty HDR Tonemap(tm)\nvec3 tonemap(vec3 color)\n{\n    // Tonemap (fits colors to 0.0-1.0)\n    color = 1.0-exp(-color*exposure);\n\n    // sRGB Color Component Transfer: https://www.color.org/chardata/rgb/sRGB.pdf\n    color  = vec3(\n    color.r > 0.0031308 ? (pow(color.r, 1.0/2.4)*1.055)-0.055 : color.r*12.92,\n    color.g > 0.0031308 ? (pow(color.g, 1.0/2.4)*1.055)-0.055 : color.g*12.92,\n    color.b > 0.0031308 ? (pow(color.b, 1.0/2.4)*1.055)-0.055 : color.b*12.92);\n\n    return clamp(color, 0.0, 1.0);\n}\n\n/*\n// HDR Tonemapping Function (Basically Reinhard with Gamma-Correction)\nvec3 tonemap(vec3 color)\n{\n    // Clamp Values Less Than 0.0\n    color = max(color, 0.0);\n\n    // Image Gamma\n    const vec3 imageGamma = vec3(1.0/gamma);\n\n    // Reinhard and Gamma-Correction\n    color = pow(color/(color+1.0), imageGamma);\n    //color = pow(tanh(color), imageGamma);\n\n    // Return Tone-Mapped Color\n    return clamp(color, 0.0, 1.0);\n}\n*/\n\n// ##### Random Number Generation #####\n\n// Hash44 Hash without Sine: https://www.shadertoy.com/view/4djSRW\nvec4 hash44(vec3 pos, float t)\n{\n    vec4 p4 = vec4(pos, t);\n    p4  = fract(p4*vec4(0.1031, 0.1030, 0.0973, 0.1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n// PCG Random: https://www.pcg-random.org/\nuint hash(uint x)\n{\n    uint state = x*0x2C9277B5U+0xAC564B05U;\n    uint word  = ((state >> ((state >> 28U) + 4U)) ^ state) * 0x108EF2D9U;\n    return (word >> 22U) ^ word;\n}\n\n//\nuint ns;\n#define initializeRNG ns = uint(frame)*uint(resolution.x*resolution.y)+uint(gl_FragCoord.x+gl_FragCoord.y*resolution.x)\n\n//\nfloat rand()\n{\n    ns = hash(ns);\n    return float(ns)/float(0xFFFFFFFFU);\n}\n\n// Random Vectors\nvec2 rand2(){return vec2(rand (), rand());}\nvec3 rand3(){return vec3(rand2(), rand());}\nvec4 rand4(){return vec4(rand3(), rand());}\n//vec5 rand5(){return vec5(rand4(), rand());} // GLSL Sus Imposter Confirmed!? The truth is out there...\n\n// See michael0884's usage of PCG Random\n// https://www.shadertoy.com/view/wltcRS\n// https://www.shadertoy.com/view/WttyWX\n\n// Normalized Random Vectors\n// A point is equally probable to land at every point inside the volume of a sphere at the mean with a radius of sigma\nvec2 nrand2(float sigma, vec2 mean)\n{\n    vec2 z = rand2();\n    return mean+sigma*sqrt(-2.0*log(z.x   ))*vec2(cos(2.0*pi*z.y), sin(2.0*pi*z.y));\n}\n\nvec3 nrand3(float sigma, vec3 mean)\n{\n    vec4 z = rand4();\n    return mean+sigma*sqrt(-2.0*log(z.xxy ))*vec3(cos(2.0*pi*z.z), sin(2.0*pi*z.z), cos(2.0*pi*z.w));\n}\n\nvec4 nrand4(float sigma, vec4 mean)\n{\n    vec4 z = rand4();\n    return mean+sigma*sqrt(-2.0*log(z.xxyy))*vec4(cos(2.0*pi*z.z), sin(2.0*pi*z.z), cos(2.0*pi*z.w), sin(2.0*pi*z.w));\n}\n\n// Uniform Random Vectors\n// A point is equally probable to land at every point on the surface of a sphere with a radius of 1.0\nvec3 urand3()\n{\n    vec2 z = rand2();\n    vec2 r = vec2(2.0*pi*z.x, acos(2.0*z.y-1.0));\n    vec2 s = sin(r), c = cos(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ##### Rendering #####\n\n// Noise (from Hash)\nfloat noise(vec3 pos, uint octave)\n{\n    // Octave\n    float t = float(octave);\n\n    // Store the Fractional Part of the Coordinate, for Interpolation later\n    vec3 f = fract(pos);\n\n    // Floor-ify the Position (so the hash gets nice whole numbers)\n    pos = floor(pos);\n\n    // Sample\n    float t0 = hash44(vec3(0.0, 0.0, 0.0)+pos, t).x;\n    float t1 = hash44(vec3(1.0, 0.0, 0.0)+pos, t).x;\n    float t2 = hash44(vec3(0.0, 1.0, 0.0)+pos, t).x;\n    float t3 = hash44(vec3(1.0, 1.0, 0.0)+pos, t).x;\n    float t4 = hash44(vec3(0.0, 0.0, 1.0)+pos, t).x;\n    float t5 = hash44(vec3(1.0, 0.0, 1.0)+pos, t).x;\n    float t6 = hash44(vec3(0.0, 1.0, 1.0)+pos, t).x;\n    float t7 = hash44(vec3(1.0, 1.0, 1.0)+pos, t).x;\n\n    // Return Interpolated Value\n    return mix(mix(mix(t0, t1, f.x), mix(t2, t3, f.x), f.y), mix(mix(t4, t5, f.x), mix(t6, t7, f.x), f.y), f.z);\n}\n\n// Fractal Brownian Motion (FBM) Noise\nfloat fbm(vec3 pos)\n{\n    // Set-Up Variables\n    float value = 0.0;\n    float scale = 1.0;\n    float atten = 0.5;\n\n    for(uint i = 0U; i < 8U; i++)\n    {\n        value += noise(pos*scale, 10U*i)*atten;\n        //value += (length(function(pos*scale*2.0))*0.3)*atten;\n        scale *= 2.2;\n        atten *= 0.5;\n    }\n\n    return value;\n}\n\n// Basically copied and pasted from michael0884\n// https://rantonels.github.io/starless/\nvec3 gravitationalForce(vec3 pos)\n{\n    vec3 r = pos/blackholeRadius;\n    float R = length(r);\n    return -4.0*1.5*r/pow(R, 5.0);\n}\n\n// Color Shift Function Reference from SE Ship Engine Shader\n/*\n*/\n\n/*\n// Approximation of Redshift/Blueshift\nvec3 shiftColor(vec3 color, float t)\n{\n    color = t > 0.0 ?\n    vec3(\n    mix(color.r, 0.0    , clamp(t, 0.0, 1.0)),\n    mix(color.g, color.r, clamp(t, 0.0, 1.0)),\n    mix(color.b, color.g, clamp(t, 0.0, 1.0))) :\n    vec3(\n    mix(color.r, color.g, clamp(-t, 0.0, 1.0)),\n    mix(color.g, color.b, clamp(-t, 0.0, 1.0)),\n    mix(color.b, 0.0    , clamp(-t, 0.0, 1.0)));\n\n    return color;\n}\n*/\n\n//\nfloat getDensity(in vec3 pos, out vec3 volumeColor, out vec3 emission)\n{\n    // Set-Up Variables\n    volumeColor = vec3(0.20, 0.15, 0.10);\n    emission = vec3(0.0);\n\n    // Bounds (increases performance by skipping sampling noise where it isn't needed)\n    if(dotp(pos.xz) > 8.0 || abs(pos.y) > 0.3)\n    {\n        return 0.0;\n    }\n\n    // Accretion Disk \n    vec3 gasColor = blackbodyXYZ(2300.0);\n    gasColor = XYZtoRGB(gasColor);\n    gasColor = clamp(gasColor/max(max(gasColor.x, gasColor.y), gasColor.z), 0.0, 1.0);\n\n    // Noise\n    float volumeNoise = fbm(vec3(rotate2(pos.xz, pos.y+length(pos.xz)*2.0), pos.y).xzy*20.0);\n\n    // Emission\n    emission = gasColor*128.0*max(volumeNoise-length(vec3(0.2, 8.0, 0.2)*pos), 0.0)/((dotp(pos*0.5)*dotp(pos*0.5))+0.05);\n\n    // Return Density\n    return max(volumeNoise-length(vec3(0.12, 7.5, 0.12)*pos), 0.0)*128.0;\n}\n\n// Color of the Sky\nvec3 skyColor(vec3 dir)\n{\n    // Pure Black Void\n    return vec3(0.0);\n}\n\n// Path-Tracing\nvec3 radiance(vec3 ro, vec3 rd)\n{\n    // Set-Up Variables\n    vec3 raypos = ro+(rand()*rd*dt);\n    vec3 velocity = rd;\n    vec3 attenuation = vec3(1.0);\n    vec3 radiance = vec3(0.0);\n    vec3 volumeColor = vec3(1.0);\n    vec3 volumeEmission = vec3(0.0);\n    uint bounces = 0U;\n\n    // Ray-Marching\n    for(uint i = 0U; i < maxSteps; i++)\n    {\n        // Check if we reached the bounce limit\n        if(bounces > maxBounces)\n        {\n            break;\n        }\n\n        //if(length(raypos) > maxDist)\n        if(dotp(raypos) > maxDist*maxDist)\n        {\n            radiance += attenuation*skyColor(normalize(velocity));\n            return radiance;\n        }\n\n        // Get the Volume at the Ray Position\n        float density = getDensity(raypos, volumeColor, volumeEmission);\n\n        // Compute the Absorbance of the Volume\n        float absorbance = exp(-1.0*density*dt);\n\n        // Emission\n        radiance += attenuation*volumeEmission*dt;\n\n        // Determine if the Ray will Bounce\n        if(absorbance < rand())\n        {\n            // Compute the Direction of the Ray\n            velocity = reflect(velocity, urand3());\n            //velocity = reflect(normalize(velocity), urand3())*length(velocity);\n\n            // Absorbed Light\n            attenuation = clamp(attenuation*volumeColor, 0.0, 1.0);\n\n            // Increment the Bounces Counter\n            bounces++;\n        }\n\n        // Compute the Gravitational Force Acting on the Ray\n        vec3 g = gravitationalForce(raypos);\n\n        // Apply the Gravitational Force\n        velocity += g*dt;\n\n        // Redshift/Blueshift?\n        //radiance = shiftColor(radiance, raypos);\n\n        // March the Ray Forward\n        raypos += velocity*dt;\n\n        //if(length(raypos) < blackholeRadius)\n        if(dotp(raypos) < blackholeRadius*blackholeRadius)\n        {\n            return radiance;\n        }\n    }\n\n    // Return Expired Sample\n    return vec3(-1.0);\n}\n\n// Monte-Carlo Dithering/Anti-Aliasing\nvec2 dither(vec2 pos)\n{\n    return nrand2(0.5, pos);\n}\n\n// Render and Output the Frame\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Progressive Rendering\n    fragColor = frame != 0 ? texel0 : vec4(0.0);\n\n    // Initialize the Random Number Generator\n    initializeRNG;\n\n    // Bloom\n    float t = rand();\n    if(t < 0.25)\n    {\n        // Large Bloom\n        float r2 = rand();\n        fragCoord += nrand2(32.0*r2*r2*r2, vec2(0.0));\n    }\n    else if(t < 0.5)\n    {\n        // Microbloom\n        fragCoord += nrand2(4.0, vec2(0.0));\n    }\n\n    // Screen UV Coordinates\n    vec2 uv = 2.0*(dither(fragCoord.xy)-0.5*resolution.xy)/max(resolution.x, resolution.y);\n\n    // Position of the Camera\n    vec3 cameraPosition = vec3(0.0, 0.2, -3.5);\n    //vec3 cameraPosition = vec3(0.0, 0.4, -3.0);\n\n    // No DoF\n    vec3 ro = cameraPosition;\n    // Crappy Depth of Field (more infinitely far objects in focus)\n    //vec3 ro = cameraPosition+vec3(rand2()*sensorSize, 0.0);\n\n    // Standard Rotation Matrix\n    //mat3 rotmat = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n\n    // Slight Angle\n    mat3 rotmat = mat3(\n    1.0,-0.2, 0.0,\n    0.2, 1.0, 0.1,\n    0.0,-0.1, 1.0);\n\n    // Normalize the Rotation Matrix\n    rotmat[0] = normalize(rotmat[0]);\n    rotmat[1] = normalize(rotmat[1]);\n    rotmat[2] = normalize(rotmat[2]);\n\n    // Compute the Ray Direction\n    vec3 rd = normalize(camfov*(uv.x*rotmat[0]+uv.y*rotmat[1])+rotmat[2]);\n\n    // Render the Sample\n    vec3 color = radiance(ro, rd);\n\n    // Output the Rendered Sample\n    fragColor += !any(lessThan(color, vec3(0.0))) && !any(isinf(color)) && !any(isnan(color)) ? vec4(color, 1.0) : vec4(0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ##### Image Export #####\n// On Shadertoy you can export an OpenEXR image, just press the image-icon button on the bottom right of the editor.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get the Progressive Rendering Buffer\n    vec4 texel = texel0;\n\n    // Compute and Output the Final Color\n    fragColor = vec4(texel.a != 0.0 ? texel.rgb/texel.a : texel.rgb, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}