{
    "Shader": {
        "info": {
            "date": "1463506103",
            "description": "Requiem for a CPC / Haujobb and Alcatraz\nhttps://www.youtube.com/watch?v=GIFrs7dqv1E",
            "flags": 64,
            "hasliked": 0,
            "id": "4sKXRw",
            "likes": 26,
            "name": "Requiem for a CPC",
            "published": 3,
            "tags": [
                "raymarching",
                "tunnel",
                "postprocessing",
                "sdf",
                "refraction",
                "demoscene",
                "particles",
                "ice"
            ],
            "usePreview": 1,
            "username": "Virgill",
            "viewed": 1970
        },
        "renderpass": [
            {
                "code": "//***************************************************************************************************\n//\n// Requiem for a CPC  /  Haujobb and Alcatraz\n// Jochen \"Virgill\" Feldkoetter\n//\n// 4k Intro for Nordlicht demoparty 2016      Shadertoy version\n//\n//***************************************************************************************************\n\n\n//const int efx_ = 3;\nint efx_=0;\nvec2 ku=vec2(0);\n\n\n//***************************************************************************************************\n// domain repetition and rotation functions\n//***************************************************************************************************\n\nvec2 pMod(inout vec2 p,vec2 size) \n{\n    vec2 hz=size/2.;\n\tvec2 c=floor((p+hz)/size);\n\tp=mod(p+hz,size)-hz;\n\tp*=mod(c,vec2(2))*2.-vec2(1);\n    if (efx_!=0)\n    {\n\t\tp-=hz;\n\t\tif (p.x>p.y) p.xy=p.yx;\n    }\n\treturn floor(c/2.);\n}\n\nvoid pR(inout vec2 p,float a) \n{\n\tp=cos(a)*p+sin(a)*vec2(p.y,-p.x);\n}\n\n//***************************************************************************************************\n// sdf box\n//***************************************************************************************************\n\nfloat fBox(vec3 p, vec3 b) \n{\n\tvec3 d=abs(p)-b;\n    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\n//***************************************************************************************************\n// noise functions\n//***************************************************************************************************\n\nfloat snoise(vec3 p){\n    \n    const vec3 s=vec3(7,157,113);\t\n    vec3 ip=floor(p);    \n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);    \n    p-=ip;\n    p=p*p*(3.-2.*p);\n    h=mix(fract(sin(h)*43758.5453),fract(sin(h+s.x)*43758.5453),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z);\t\n}\n\nfloat noise(vec3 n)\n{\n \treturn snoise(n)*.6+snoise(n*2.)*.4;\n}\n\n//***************************************************************************************************\n// particle function\n//***************************************************************************************************\n\nfloat particles(vec3 direction)\n{\n\tfloat accumulate=0.;\n    const mat3 p=mat3(13.3,23.5,21.7,21.1,28.7,11.9,21.8,14.7,61.3);\n\tvec2 uvx=vec2(direction.x,direction.z)+vec2(1.,iResolution.y/iResolution.x)*gl_FragCoord.xy/iResolution.xy;\n\tfloat DEPTH = direction.y*direction.y-.3;\n\tfor (float fi=0.;fi<10.;fi++) \n\t{\n\t\tvec2 q=uvx*(1.+fi*DEPTH)+vec2(DEPTH,0.2*iTime/(1.+fi*DEPTH*.03));\n\t\tvec3 n=vec3(floor(q),31.1+fi);\n\t\tvec3 m=floor(n)*.0001 + fract(n);\n\t\tvec3 r=fract((31415.+m)/fract(p*m));\n\t\tvec2 s=abs(mod(q,1.)-.5+.9*r.xy-.45);\n\t\tfloat d=s.x+s.y+0.7*max(s.y,s.x)-.01;\n\t\tfloat edge=.06;\n\t\taccumulate+=smoothstep(edge,-edge,d)*r.x;\n\t}\n\treturn accumulate;\n\t}\n\n//***************************************************************************************************\n// signed distance functions\n//***************************************************************************************************\n\n// \tsuper waves\nfloat fField0(vec3 p)\n{\n    float fbm_=noise(p*7.);\n\tpMod(p.xz,vec2(1.8-0.4*fbm_));\n\tpR(p.xz,iTime*0.2+0.2*fbm_);\n\tpR(p.xy,iTime*0.4+0.2*fbm_);\n\treturn fBox(p-vec3(0.0),vec3(1.1))-0.15-0.05*fbm_;\n}\n\n// \tpyramid carpet & tunnel effects\nfloat fField1(vec3 p) \n{\n\tku = pMod(p.xz,vec2(.8));\n\tpR(p.xz,iTime*.16);\n\tpMod(p.xz,vec2(.7));\n\tif (efx_!=3) pR(p.xy,iTime*.334);\n\tfloat box=fBox(p-vec3(0),vec3(.6));\n    if (efx_==2) box=.05-box;\n    if (efx_==1) box-=.02*noise(vec3(0.,0.,p.z)*8.0);\n    return box;\n}\n\n//***************************************************************************************************\n// map\n//***************************************************************************************************\n\nfloat map(vec3 p)\n{\n//\tsuper waves\n    if (efx_==0) return fField0(p);\n//\tpyramid carpet\n    if (efx_==1) return fField1(p);\t\n//\twormhole tunnel  \n    if (efx_==2) p=p.xzy;  \n//  fancy tunnel\n    if (efx_==3) {p=p.xzy;p.z-=iTime; p+=(sin(p*1.9+iTime)+sin(p.yzx+iTime*2.2))*.11;}\n\n    p.xy = vec2( (atan(p.x,p.y)+1.5*sin(0.9*sqrt(dot(p.xy,p.xy))-0.5*iTime))*1.0187,1.-length(p.xy));\n\treturn fField1(p);\n    \n}\n\n\n//***************************************************************************************************\n// softshadow\n//***************************************************************************************************\n\nfloat shadowsoft( vec3 ro, vec3 rd, float k )\n{\n\tfloat t=.1;\n\tfloat res=1.;\n    for (int i=0;i<25;++i)\n    {\n        float h=map(ro+rd*t);\n        if (h<0.001) return 0.;\n\t\tres=min(res,k*h/t);\n        t+=h;\n\t\tif (t>0.23) break;\n    }\n    return res;\n}\n\n//***************************************************************************************************\n// normal calculation\n//***************************************************************************************************\n\nvec3 calcNormal(vec3 pos)\n{\n    float eps=0.04; pos-=0.01;\n\tfloat d=map(pos);\n\treturn normalize(vec3(map(pos+vec3(eps,0,0))-d,map(pos+vec3(0,eps,0))-d,map(pos+vec3(0,0,eps))-d));\n}\n\n//***************************************************************************************************\n// marching outside sdf\n//***************************************************************************************************\n\nfloat castRay(vec3 ro,vec3 rd) \n{\n    float precis=.0001;\n    float h=precis*2.;\n    float t=0.;\n\tfor(int i=0;i<100;i++) //*************************************\n\t{\n        if(abs(h)<precis||t>12.) break;\n\t\th=map(ro+rd*t);\n        t+=h;\n\t}\n    return t;\n}\n\n//***************************************************************************************************\n// marching inside sdf\n//***************************************************************************************************\n\nfloat castRay2(vec3 ro,vec3 rd) \n{\n//\ttunnel effects\n    float precis=.01;\n//\tsuper waves\n    if (efx_==0) precis=.3;\n//\tmirror carpet\n    if (efx_==1) precis=.8;\n    float h=0.;\n    float t=.1;\n    for(int i=0;i<40;i++) \n\t{\n\t\tif(abs(h)>precis) break;\n\t\th=map(ro+rd*t);\n\t\tt-=h;\n\t}\n\treturn t;\n}\n\n\n//***************************************************************************************************\n// main\n//***************************************************************************************************\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) \n{\n\n// time control (only in shadertoy)\n\n    if (iTime<136.) efx_=2;\n    if (iTime<102.) efx_=0;\n    if (iTime<68. ) efx_=1;\n    if (iTime<34. ) efx_=3;\n    \n    \n    vec2 uv,p;\n\tuv=gl_FragCoord.xy/iResolution.xy; \n    p=uv*2.-1.;\n   \tp.x*=iResolution.x/iResolution.y;\n\t\n//  camera\n    float theta=sin(iTime*.1)*6.28;\n    float x=3.*cos(theta); \n    float z=3.*sin(theta);\n\tvec3 ro=vec3(x*2.2,5.+2.*sin((iTime+37.)*.15), z*1.4);\t\t\n\tif (efx_==2||efx_==3) ro=vec3(0.,8.,.01);\n    if (efx_==0) ro.y+=1.6; //*******************************************\n\tvec3 cw=normalize(vec3(0.,.25,0.)-ro);\n    vec3 cu=normalize(cross(cw,vec3(0.,1.,0.)));\n\tvec3 rd=normalize(p.x*cu+ p.y*(cross(cu,cw))+7.5*cw);\n\n// \trender:\n\tfloat t=castRay(ro,rd);\n\tvec3 pos=ro+rd*t;\n\tvec3 nor=calcNormal(pos);\n\n// \tlightning:\n\tvec3 ligvec=vec3(-.5,.2,.5);\n\tif (efx_==2) ligvec=vec3(-.3*cos(iTime),-.2,.5*sin(iTime*1.9)+.2);\n    \n\tvec3 lig=normalize(ligvec);\t\n    float dif=max(dot(lig,nor),0.);\n    float spec=pow(max(dot(reflect(rd,nor),lig),0.),32.);\n\tvec3 col=vec3(.1*dif+1.*spec);\n    if (efx_==1) col+=.5*ku.x;\n    \n//\tnew shadow\n\tfloat sh=shadowsoft(pos,lig,1.2); \n    col*=clamp(sh,.4,1.);\n\n    \n//\trefraction 1st pass\n\tvec3 te,dif2,rd2,pos2,nor2,ro3,rd3,pos3,nor3;\n\trd2=refract(rd,nor,.78);  \n    te.x=castRay2(pos,rd2);\n\tpos2=pos+rd2*te.x;\n    nor2=calcNormal(pos2);\n\tdif2.x=clamp(dot(lig,nor2),0.,1.);\n    \n\trd2=refract(rd,nor,.82);\n    te.z=castRay2(pos,rd2);\n\tpos2=pos+rd2*te.z;\n    nor2=calcNormal(pos2);\n\tdif2.z=clamp(dot(lig,nor2),0.,1.);\n    \n\trd2=refract(rd,nor,.8);\n    te.y=castRay2(pos,rd2);\n\tpos2=pos+rd2*te.y;\n    nor2=calcNormal(pos2);\n\tdif2.y=clamp(dot(lig,nor2),0.,1.);\n    \n    float spec2=pow(clamp(dot(reflect(rd2,nor2),lig),0.,1.),32.);\n    col+=.3*spec2;\n    \n    te=clamp(te,0.,1.);\n    col+=(1.-te*.25)+(1.-t*.15)*dif2;\n    \n//\tdouble shadow on tunnel effects\n    if (efx_==2||efx_==3) col*=clamp(sh,.4,1.);    \n    \n// \trefraction 2nd pass\n\tro3=pos2+rd; \n\trd3=rd2+0.05;\n    float t3=castRay(ro3,rd3);\n\tpos3=ro3+rd3*t3;\n    nor3=calcNormal(pos3);\n\tfloat dif3=clamp(dot(lig,-nor3),0.,1.);\n    col-=.2*(1.-dif3);\n\n//  add more color depth\n\tcol=mix(col,vec3(.5,.4,.4),ku.y*.2*te.z);\n\n//\ttunnel depth and particles    \n    float particlevar=.35*(particles(cw)-particles(vec3(cw.x,cw.y,cw.z+rd.z)));\n    vec3 deep=vec3(1.);\n    if (efx_==2||efx_==3) \n    {\n        deep=clamp(1.-vec3(t*t)*.007,0.,1.);\n    \tparticlevar=0.;\n    }\n\n//  fade in and out   \n\tfloat blend=min(2.*abs(sin((.1*iTime)*3.1415/3.4)),1.); \n    if (noise((gl_FragCoord.xyz)*.02)>blend) col-=(1.-blend);\n    if(iTime>136.0)blend=0.;\n    \n// \tpostprocessing\n\tcol-=.3*noise(.4*rd3*iTime);\t\t\t\t\t\t\t\t\t\n\tcol*=.9+.1*sin(uv.y*800.);\t\n    col-=1.-dot(uv,1.-uv)*2.5;\n    fragColor=vec4((deep*col+particlevar)*blend,0.);\n}\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 3864,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/virgill/requiem-for-a-cpc"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}