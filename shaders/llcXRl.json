{
    "Shader": {
        "info": {
            "date": "1481091481",
            "description": "This is a demo of how to use the new font texture. See the source code for details.",
            "flags": 0,
            "hasliked": 0,
            "id": "llcXRl",
            "likes": 99,
            "name": "SDF Texture Font",
            "published": 3,
            "tags": [
                "font",
                "texfont",
                "fontpage"
            ],
            "usePreview": 0,
            "username": "otaviogood",
            "viewed": 6054
        },
        "renderpass": [
            {
                "code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n/*\nThis is a demo of the new font texture. It has a distance field and gradients in the texture.\nRed channel:   Antialiased font if you just want something simple and easy to use.\nGreen channel: x gradient of distance field.\nBlue channel:  y gradient of distance field.\nAlpha channel: distance field.\n\nThe characters that are encoded are the characters from the first 8 bits of unicode (aka Latin-1 codepage).\nThat includes ASCII. In the blanks, there are symbols that seemed useful for shadertoy. Math symbols,\ngreek letters, play/pause controls, arrows, musical notes, and some others.\n\nThe distance field lets you use the font for ray marching. Since the texture didn't have enough precision\nfor a clean distance field, nice smooth gradients have been put in the green/blue channels to get smooth edges.\n\nSometimes you might see some artifacts in the font edges when you look from an angle. To fix those,\nthe ray marching would have to pause at the boundary between each letter since the distance field is\nnot continuous between letters. That would complicate this code a bit, so it was left out.\n*/\n\n// ---------------- Config ----------------\n//#define MANUAL_CAMERA\n\nconst float PI=3.14159265;\n#define saturate(a) clamp(a, 0.0, 1.0)\n\nvec3 GetReflection(vec3 rayDir)\n{\n\tvec3 tex = texture(iChannel1, -rayDir).xyz;\n\treturn(tex*tex);\n}\n\n// min and max function that supports materials in the y component\nvec2 matmin(vec2 a, vec2 b)\n{\n    if (a.x < b.x) return a;\n    else return b;\n}\nvec2 matmax(vec2 a, vec2 b)\n{\n    if (a.x > b.x) return a;\n    else return b;\n}\n\n// ---- shapes defined by distance fields ----\n// See this site for a reference to more distance functions...\n// https://iquilezles.org/articles/distfunctions\n\n// signed box distance field\nfloat sdBox(vec3 p, vec3 radius)\n{\n  vec3 dist = abs(p) - radius;\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\n}\n// -------------------------------------------\n\nvec4 SampleFontTex(vec2 uv)\n{\n    // Do some tricks with the UVs to spell out \"TexFont\" in the middle.\n    vec2 fl = floor(uv + 0.5);\n    if (fl.y == 0.0) {\n        if (fl.x == -3.0) fl = vec2(4.0, 10.0);\n    \telse if (fl.x == -2.0) fl = vec2(5.0, 9.0);\n    \telse if (fl.x == -1.0) fl = vec2(8.0, 8.0);\n    \telse if (fl.x == 0.0) fl = vec2(6.0, 11.0);\n    \telse if (fl.x == 1.0) fl = vec2(15.0, 9.0);\n    \telse if (fl.x == 2.0) fl = vec2(14.0, 9.0);\n    \telse if (fl.x == 3.0) fl = vec2(4.0, 8.0);\n    }\n    uv = fl + fract(uv+0.5)-0.5;\n\n    // Sample the font texture. Make sure to not use mipmaps.\n    // Add a small amount to the distance field to prevent a strange bug on some gpus. Slightly mysterious. :(\n    return texture(iChannel0, (uv+0.5)*(1.0/16.0), -100.0) + vec4(0.0, 0.0, 0.0, 0.000000001);\n}\n\n// This is the distance function that defines all the scene's geometry.\n// The input is a position in space.\n// The output is the distance to the nearest surface and a material index.\nvec2 DistanceToObject(vec3 p)\n{\n\t// Load the font texture's distance field.\n    float letterDistField = (SampleFontTex(p.xy).w - 0.5+1.0/256.0);\n    // intersect it with a box.\n    float cropBox = sdBox(p, vec3(0.5 + 5.0, 3.5, 0.25));\n    vec2 letters = matmax(vec2(letterDistField, 0.0), vec2(cropBox, 1.0));\n    return letters;\n}\n\n// Input is UV coordinate of pixel to render.\n// Output is RGB color.\nvec3 RayTrace(in vec2 fragCoord )\n{\n\tvec3 camPos, camUp, camLookat;\n\t// ------------------- Set up the camera rays for ray marching --------------------\n    // Map uv to [-1.0..1.0]\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n    uv /= 2.0;  // zoom in\n\n#ifdef MANUAL_CAMERA\n    // Camera up vector.\n\tcamUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\n\n    // debugging camera\n    float mx=-iMouse.x/iResolution.x*PI*2.0;\n\tfloat my=iMouse.y/iResolution.y*3.14*0.95 + PI/2.0;\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*7.0;\n#else\n    // Camera up vector.\n\tcamUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0,0);\n\n    float camSpeed = 0.5;\n\tfloat camRad = 6.25;\n    float camAngle = sin(iTime*camSpeed)*0.5;\n\tcamPos = vec3(sin(camAngle)*camRad, 0.0, -cos(camAngle)*camRad);\n#endif\n\n\t// Camera setup for ray tracing / marching\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\t// ----------------------------- Ray march the scene ------------------------------\n\tvec2 distAndMat;  // Distance and material\n\tfloat t = 0.05;\n\tconst float maxDepth = 16.0; // farthest distance rays will travel\n\tvec3 pos = camPos;\n    const float smallVal = 1.0 / 16384.0;\n    // ray marching time\n    for (int i = 0; i <160; i++)\t// This is the count of the max times the ray actually marches.\n    {\n        // Step along the ray.\n        pos = (camPos + rayVec * t);\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry. The idea is that the\n        // distance field returns the distance to the closest object, and then\n        // we know we are safe to \"march\" along the ray by that much distance\n        // without hitting anything. We repeat this until we get really close\n        // and then break because we have effectively hit the object.\n        distAndMat = DistanceToObject(pos);\n\n        // move along the ray a safe amount\n        t += distAndMat.x;\n        // If we are very close to the object, let's call it a hit and exit this loop.\n        if ((t > maxDepth) || (abs(distAndMat.x) < smallVal)) break;\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n    if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal. This is called a gradient.\n        vec3 smallVec = vec3(1.0/4096.0, 0, 0);\n        vec3 normalU = vec3(DistanceToObject(pos + smallVec.xyy).x - DistanceToObject(pos - smallVec.xyy).x,\n                           DistanceToObject(pos + smallVec.yxy).x - DistanceToObject(pos - smallVec.yxy).x,\n                           DistanceToObject(pos + smallVec.yyx).x - DistanceToObject(pos - smallVec.yyx).x)*0.5;\n        // If the material says we are on the edge of the font, override the normal with the\n        // font texture's gradient. This will give us smoother surfaces on the sides of the font's letters.\n        if (distAndMat.y == 0.0) {\n\t\t    vec4 tx = SampleFontTex(pos.xy) - 0.5;\n            // Put a small number in Z so it can't go to zero.\n            normalU = -vec3(-tx.g, tx.b, 0.0001)*2.0*smallVec.x;\n        }\n        // It looks like ??texture filtering?? can sometimes take the normal to zero length.\n        // Compensate so we don't divide by zero in the normalize function.\n        normalU = normalU+0.000000001;\n        vec3 normal = normalize(normalU);\n\n        // ------ Calculate texture color  ------\n        vec3 texColor = vec3(0.3,0.325,0.6)*0.5;\n        if (distAndMat.y == 1.0) {\n            // Make the \"TexFont\" word yellow\n            if ((floor(pos.y+0.5) == 0.0) && (abs(floor(pos.x+0.5)) <= 3.5)) texColor = vec3(1.0,0.9,0.1);\n        }\n\n        // ------ Calculate lighting color ------\n        // Sky color\n        vec3 lightColor = (saturate(normal.y * 0.5 + 0.5)) * vec3(2.5);\n\n        // Apply the light to the texture.\n        finalColor = texColor * lightColor;\n\n        // calculate the reflection vector for highlights\n        vec3 ref = reflect(rayVec, normal);\n        vec3 refColor = GetReflection(ref);\n        refColor *= vec3(1.0, 0.5, 0.2)*2.5*dot(normal, -rayVec);\n        finalColor += refColor;\n\n        // debug visualize length of gradient of distance field to check distance field correctness\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\n        //finalColor = normal * 0.5 + 0.5;\n\t}\n    else\n    {\n        // Our ray trace hit nothing, so draw background.\n        finalColor = GetReflection(rayVec);\n    }\n\n\t// output the final color without gamma correction - will do gamma later.\n\treturn vec3(clamp(finalColor, 0.0, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 finalColor = RayTrace(fragCoord);\n\n    // Render 2d text.\n    vec2 uv = fragCoord/iResolution.xy;\n    // Render entire font texture for the first few seconds.\n    float letters = texture(iChannel0, uv, -1.0).x;\n    finalColor = mix(finalColor, vec3(1.0, 1.0, 1.0)*letters, saturate(0.9-iTime*0.3));\n\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}