{
    "Shader": {
        "info": {
            "date": "1612937639",
            "description": "panini/pannini projection: http://tksharpless.net/vedutismo/Pannini/panini.pdf\ncamera controls via mouse + shift key\n\ntop knob - fov\nbot knob - d (for d=0 projection becomes rectilinear/vanilla perspective)",
            "flags": 48,
            "hasliked": 0,
            "id": "Wt3fzB",
            "likes": 54,
            "name": "Panini Projection",
            "published": 3,
            "tags": [
                "projection",
                "pannini",
                "panini"
            ],
            "usePreview": 1,
            "username": "TinyTexel",
            "viewed": 2861
        },
        "renderpass": [
            {
                "code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\npanini/pannini projection: http://tksharpless.net/vedutismo/Pannini/panini.pdf\ncamera controls via mouse + shift key\n\ntop knob - fov\nbot knob - d (for d=0 projection becomes rectilinear/vanilla perspective)\n\nRelated:\n    https://www.shadertoy.com/view/tt3BRS - \"Panini Projection Visualization\" (simple visualization of the projection)\n*/\n    \n#define VarTex iChannel0\n#define OutCol col\n#define OutChannel w\n\n#define WriteVar(v, cx, cy) {if(uv.x == float(cx) && uv.y == float(cy)) OutCol.OutChannel = v;}\n#define WriteVar4(v, cx, cy) {WriteVar(v.x, cx, cy) WriteVar(v.y, cx, cy + 1) WriteVar(v.z, cx, cy + 2) WriteVar(v.w, cx, cy + 3)}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec2 ReadVar2(int cx, int cy) {return vec2(ReadVar(cx, cy), ReadVar(cx, cy + 1));}\nvec3 ReadVar3(int cx, int cy) {return vec3(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2));}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\nfloat ReadVar(inout int x) { return ReadVar(x++, 0); }\nvec2 ReadVar2(inout int x) { return ReadVar2(x++, 0); }\nvec3 ReadVar3(inout int x) { return ReadVar3(x++, 0); }\nvec4 ReadVar4(inout int x) { return ReadVar4(x++, 0); }\n\nvec4 A, B, C, D;\n\n\nbool map0(vec3 p)\n{\n    p += 0.5;\n    vec3 b = abs(p);\n    \n    bool r;\n    \n    r =      b.x < 4.0;\n    r = r && b.y < 4.0;\n    r = r && b.z < 4.0;\n    \n    r = r && (b.x > 2.0 || b.y > 2.0);\n    r = r && (b.z > 2.0 || b.y > 2.0);\n    r = r && (b.x > 2.0 || b.z > 2.0);    \n    \n    return r;\n}\n\nbool map(vec3 p)\n{\n    float o = 2.0; \n    \n    return map0(p + vec3( -o, 0.0, 0.0)) != \n           map0(p + vec3(  o, 0.0, 0.0)) != \n           map0(p + vec3(0.0,  -o, 0.0)) != \n           map0(p + vec3(0.0,   o, 0.0)) != \n           map0(p + vec3(0.0, 0.0,  -o)) != \n           map0(p + vec3(0.0, 0.0,   o));\n}\n\nvec3 minmask(vec3 v)\n{\n    return vec3(v.x <= v.y && v.x <= v.z,\n                v.y <  v.z && v.y <  v.x,\n                v.z <  v.x && v.z <= v.y);\n}\n\n// https://www.shadertoy.com/view/3s23Ww\nbool VoxelRaycast(vec3 ro, vec3 rd, out vec3 vp, out vec3 N, out float t)\n{\n\tvp = floor(ro);\n\t\n    vec3 ri = 1.0/rd;\n    \n\tvec3 rs = vec3(rd.x < 0.0 ? -1.0 : 1.0,\n                   rd.y < 0.0 ? -1.0 : 1.0,\n                   rd.z < 0.0 ? -1.0 : 1.0);\n                     \n\tvec3 off = vec3(rd.x < 0.0 ? 0.0 : ri.x,\n                    rd.y < 0.0 ? 0.0 : ri.y,\n                    rd.z < 0.0 ? 0.0 : ri.z) - ro * ri;\n\n\tvec3 mm = vec3(0.0);\n    vec3 t3 = vec3(0.0);\n    \n\tbool hit = false;\n\tfor(int i = 0; i < 24; i++) \n\t{\n\t\tif(map(vp)) { hit = true; break; }\n        \n        t3 = vp * ri + off;\n\t\t\n        mm = minmask(t3);\n        \n        vp += mm * rs;\n\t}\n\t\n\tN = -rs * mm;\n    t = dot(t3, mm);\n\n\treturn hit;\n}\n\nbool SceneRayCast(vec3 rp, vec3 rd, out vec3 c, out vec3 n, out vec3 p)\n{\n    vec3 vp; float t;\n\tbool hit = VoxelRaycast(rp, rd, /*out:*/ vp, n, t);\n    \n    if(hit)\n    {\n        p = rp + rd * t;\n        \n        vec3 fm = abs(n);\n        \n        p = mix(p, round(p), equal(fm, vec3(1.0))) + (n * 1e-5);\n\n        bvec3 b = greaterThan(abs(fract(p) - 0.5), vec3(0.45));\n        float wf = ((b.z && (b.x || b.y)) || (b.x && (b.y || b.z)) ? 0.0 : 1.0);\n\n        c = (fm + fm.yzx*0.125) * wf;\n    }\n\n   #if 0\n    vec2 tt;\n    if(Intersect_Ray_Sphere(rp, rd, vec3(0.0), 0.5, tt) > 0.0 && (tt.x < t || !hit))\n    {\n        hit = true;\n        t = tt.x;\n        \n        p = rp + rd * t;\n        \n        n = normalize(p);\n        \n        p += n * 1.0/512.0;\n        \n        c = vec3(1.0, 0.5, 0.0);\n    }\n   #endif\n    \n    return hit;\n}\n\n\n// tc ∈ [-1,1]² | fov ∈ [0, π) | d ∈ [0,1]\nvec3 PaniniProjection(vec2 tc, float fov, float d)\n{\n    float d2 = d*d;\n\n    {\n        float fo = Pi05 - fov * 0.5;\n\n        float f = cos(fo)/sin(fo) * 2.0;\n        float f2 = f*f;\n\n        float b = (sqrt(max(0.0, Pow2(d+d2)*(f2+f2*f2))) - (d*f+f)) / (d2+d2*f2-1.0);\n\n        tc *= b;\n    }\n    \n    /* http://tksharpless.net/vedutismo/Pannini/panini.pdf */\n    float h = tc.x;\n    float v = tc.y;\n    \n    float h2 = h*h;\n    \n    float k = h2/Pow2(d+1.0);\n    float k2 = k*k;\n    \n    float discr = max(0.0, k2*d2 - (k+1.0)*(k*d2-1.0));\n    \n    float cosPhi = (-k*d+sqrt(discr))/(k+1.0);\n    float S = (d+1.0)/(d+cosPhi);\n    float tanTheta = v/S;\n    \n    float sinPhi = sqrt(max(0.0, 1.0-Pow2(cosPhi)));\n    if(tc.x < 0.0) sinPhi *= -1.0;\n    \n    float s = inversesqrt(1.0+Pow2(tanTheta));\n    \n    return vec3(sinPhi, tanTheta, cosPhi) * s;\n}\n\n\nvec3 EvalSceneCol(vec3 rp, mat3 cmat, vec2 uv)\n{    \n    vec3 col = vec3(0.8);  \n    \n    vec2 tc = uv * (1.0 / (iResolution.xx*0.5)) - vec2(1.0, iResolution.y/iResolution.x);\n    \n\n    vec3 rd;\n    {\n        float fov = min(A.x, 0.999999) * Pi;\n        float d = B.x;\n\n        rd = cmat * PaniniProjection(tc, fov, d);\n        //rd = normalize(cmat * vec3(tc, 0.5 * tan(Pi05 - fov * 0.5))); \n    }\n    \n    \n#if 1\n    vec2 tt; \n    float res = Intersect_Ray_Cube(rp, rd, vec3(6.0 + 1e-5), /*out:*/ tt);\n    \n    if(res == -1.0) { return col; }\n    \n    if(res == 1.0)\n    {\n    \trp += rd * tt.x;\n    }\n#endif\n    \n\tvec3 c, n, p;\n    if(SceneRayCast(rp, rd, /*out:*/ c, n, p))\n    {\n        vec3 r = n * (2.0 * dot(n, -rd)) + rd;\n        \n        col = c;\n        \n        vec3 n0;\n        if(!SceneRayCast(p, r, /*out:*/ c, n0, p)) {c = vec3(0.8);}\n        \n        col = mix(col, c, mix(0.05, 1.0, Pow5(1.0 - dot(-rd, n))));\n    }\n\n    return col;\n}\n\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    Resolution = iResolution;\n    \n    vec3 col = vec3(0.0);\n    vec2 uv = uv0.xy - 0.5;\n    \n    int I = 0;\n    vec4 iMouse     = ReadVar4(I);\n    vec4 mouseAccu  = ReadVar4(I);\n    vec4 wasdAccu   = ReadVar4(I);\n    float frameAccu = ReadVar (I);\n    float knobVal   = ReadVar (I);\n\n    A.x = texelFetch(iChannel0, ivec2(0, 4), 0).w;\n    //A.y = texelFetch(iChannel0, ivec2(1, 4), 0).w;\n    //A.z = texelFetch(iChannel0, ivec2(2, 4), 0).w;\n    //A.w = texelFetch(iChannel0, ivec2(3, 4), 0).w;\n\n    B.x = texelFetch(iChannel0, ivec2(4, 4), 0).w;\n    //B.y = texelFetch(iChannel0, ivec2(5, 4), 0).w;\n    //B.z = texelFetch(iChannel0, ivec2(6, 4), 0).w;\n    //B.w = texelFetch(iChannel0, ivec2(7, 4), 0).w;\n\n    //C.x = texelFetch(iChannel0, ivec2( 8, 4), 0).w;\n    //C.y = texelFetch(iChannel0, ivec2( 9, 4), 0).w;\n    //C.z = texelFetch(iChannel0, ivec2(10, 4), 0).w;\n    //C.w = texelFetch(iChannel0, ivec2(11, 4), 0).w;\n\n    //D.x = texelFetch(iChannel0, ivec2(12, 4), 0).w;\n    //D.y = texelFetch(iChannel0, ivec2(13, 4), 0).w;\n    //D.z = texelFetch(iChannel0, ivec2(14, 4), 0).w;\n    //D.w = texelFetch(iChannel0, ivec2(15, 4), 0).w;\n        \n    vec2 ang = vec2(-0.1 * Pi, -Pi * 0.1);\n    ang += mouseAccu.xy * 0.008;\n\n    mat3 cmat;\n    {\n        float sinPhi   = sin(ang.x);\n        float cosPhi   = cos(ang.x);\n        float sinTheta = sin(ang.y);\n        float cosTheta = cos(ang.y);    \n\n        vec3 front = vec3(cosPhi * cosTheta, \n                                   sinTheta, \n                          sinPhi * cosTheta);\n\n        vec3 right = vec3(-sinPhi, 0.0, cosPhi);\n        \n        vec3 up    = vec3(-cosPhi * sinTheta,\n                                    cosTheta,\n                          -sinPhi * sinTheta);\n        \n        cmat = mat3(right, up, front);\n    }\n    \n    vec3 cpos = -cmat[2] * exp2(1.5 + mouseAccu.w * 0.02);\n    \n\n#if 0\n    // 1 sample\n    col = vec3(EvalSceneCol(cpos, cmat, uv0));\n#elif 1\n    // 3 samples ( https://www.shadertoy.com/view/3tdBWM )\n    uvec2 uvi = uvec2(uv);\n    if(((uvi.x ^ uvi.y) & 4u) == 0u) uvi   = uvi.yx;\n\tif(((uvi.x        ) & 4u) == 0u) uvi.x =-uvi.x;\n\n    // constants of the 2d Roberts sequence\n    const uint r0 = 3242174893u;\n    const uint r1 = 2447445397u;\n\n    float u = float((uvi.x * r0) + (uvi.y * r1)) * (1.0 / 4294967296.0);\n\n    if((uint(iFrame) & 1u) != 0u) u += 0.5;\n\n    for(float i = 0.0; i < 3.0; ++i) \n    {\n        float ang = (Pi*0.666667) * (i+u);\n        \n        vec2 off = vec2(cos(ang), sin(ang))*0.333333;\n\n        col += vec3(EvalSceneCol(cpos, cmat, uv0 + off));\n    }\n    col *= 0.333333; \n#endif\n\n#if 1\nif(uv.x < 48.0*1.0 && abs(uv.y - iResolution.y*0.5) < 48.0 ||\n   uv.x < 64.0 && uv.y < 16.0)\n{    \n    // knobs\n    vec2 ui = texelFetch(iChannel0, ivec2(uv), 0).xy;\n    \n    col *= 1.0-ui.y;\n    col = mix(col, vec3(0.03), ui.x);\n}\n#endif\n\n#if 1\n{\n    // vignetting\n    vec2 s = abs(uv0/iResolution.xy*2.0-1.0);\n    s.x = 1.0-Pow3(s.x);    s.y = 1.0-Pow3(s.y);\n    col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n}\n#endif\n    \n\toutCol = vec4(GammaEncode(clamp01(col)), 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec3 Resolution;\n\n#define Frame float(iFrame)\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\n\nconst float Pi = 3.14159265359;\nconst float Pi2 = Pi * 2.0;\nconst float Pi05 = Pi * 0.5;\n\nconst float RcpPi  = 1.0 / (1.0 * Pi);\nconst float RcpPi2 = 1.0 / (2.0 * Pi);\nconst float RcpPi4 = 1.0 / (4.0 * Pi);\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\nfloat Pow5(float x) {return Pow4(x)*x;}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}   \n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\nfloat Intersect_Ray_Cube(vec3 rp, vec3 rd, vec3 cth, out vec2 t)\n{\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\tbool inside = t.x < 0.0 && t.y > 0.0;\n    \n\tif(inside) {return 0.0;}\n\t\n\treturn t.y < t.x ? -1.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\n// ============================================================================================================================= //\nstruct KnobState\n{\n    vec2 p;\n    vec2 r;\n    bool signed;\n    \n    float n;\n};\n\nKnobState CreateKnobState(vec2 p, vec2 r, bool signed, float n)\n{\n    KnobState state;\n    state.p = p;\n    state.r = r;\n    state.signed = signed;\n    state.n = n;\n\n    return state;\n}\n    \nKnobState GetKnobOfMat(int i, bool signed, float n)\n{\n    float x = float(uint(i) & 3u);\n    float y = float(uint(i) >> 2u);\n    \n    float s = 32.0 + 8.0;\n    \n    KnobState knob;\n    knob.p.x = s * 0.5 + x * s;\n    knob.p.y = s * 0.5 + y * s;\n    \n    knob.p.y = Resolution.y*0.5 + (s*1.0) - knob.p.y;\n\n    knob.r = vec2(16.0, 4.0);\n    knob.signed = signed;\n\tknob.n = n;\n    \n    return knob;\n}\n\nconst int KnobCount = 16;\nbool GetKnob(int i, out KnobState knob)\n{\n    switch(i)\n    {\n        case  0: knob = GetKnobOfMat(i, false, 0.6667);  return true;// A.x\n        //case  1: knob = GetKnobOfMat(i, false, 0.44); return true;// A.y\n      //case  2: knob = GetKnobOfMat(i, false, 0.0); return true;// A.z\n      //case  3: knob = GetKnobOfMat(i, false, 0.0); return true;// A.w\n      \n        case  4: knob = GetKnobOfMat(i, false, 0.75); return true;// B.x\n      //  case  5: knob = GetKnobOfMat(i, false, 0.4); return true;// B.y\n      //case  6: knob = GetKnobOfMat(i, false, 0.0); return true;// B.z\n      //case  7: knob = GetKnobOfMat(i, false, 0.0); return true;// B.w\n      \n      //case  8: knob = GetKnobOfMat(i, false, 0.0); return true;// C.x\n      //case  9: knob = GetKnobOfMat(i, false, 0.0); return true;// C.y\n      //case 10: knob = GetKnobOfMat(i, false, 0.0); return true;// C.z\n      //case 11: knob = GetKnobOfMat(i, false, 0.0); return true;// C.w\n      \n      //case 12: knob = GetKnobOfMat(i, false, 0.0); return true;// D.x\n      //case 13: knob = GetKnobOfMat(i, false, 0.0); return true;// D.y\n      //case 14: knob = GetKnobOfMat(i, false, 0.0); return true;// D.z\n      //case 15: knob = GetKnobOfMat(i, false, 0.0); return true;// D.w\n    }\n    \n    KnobState knob0;\n    knob0.n = 1.25;\n    knob = knob0;\n    \n    return false;\n}\n\nbool GetKnob(int i, sampler2D stateBuffer, bool doInit, out KnobState knob)\n{\n\tif(!GetKnob(i, /*out*/ knob)) return false;\n\n    if(!doInit)\n    knob.n = texelFetch(stateBuffer, ivec2(i, 4), 0).w;\n    \n    return i < KnobCount;\n}\n\nbool GetKnob(int i, sampler2D stateBuffer, out KnobState knob)\n{\n    return GetKnob(i, stateBuffer, false, knob);\n}\n\nint GetKnob(vec2 uv, sampler2D stateBuffer, bool doInit, out KnobState knob)\n{\n    for(int i = 0; i < KnobCount; ++i)//TODO optimize loop away for knob array\n    {\n    \tif(!GetKnob(i, /*out*/ knob)) continue;\n        \n        if(SqrLen(uv - knob.p) < Pow2(knob.r.x + 4.0))\n        {\n\t        if(!doInit)\n            knob.n = texelFetch(stateBuffer, ivec2(i, 4), 0).w;\n\n            return i;\n        }\n    }\n    \n    return -1;\n}\n\nint GetKnob(vec2 uv, sampler2D stateBuffer, out KnobState knob)\n{\n    return GetKnob(uv, stateBuffer, false, /*out*/ knob);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/* persistent state stuff and knobs */\n\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_SHIFT 0x10\n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define KeyBoard iChannel1\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\n\n\n#define VarTex iChannel0\n#define OutCol col\n#define OutChannel w\n\n#define WRITEVAR(v, cx, cy) {if(uv.x == float(cx) && uv.y == float(cy)) OutCol.OutChannel = v;}\n#define WRITEVAR2(v, cx, cy) {WRITEVAR(v.x, cx, cy) WRITEVAR(v.y, cx, cy + 1)}\n#define WRITEVAR3(v, cx, cy) {WRITEVAR(v.x, cx, cy) WRITEVAR(v.y, cx, cy + 1) WRITEVAR(v.z, cx, cy + 2)}\n#define WRITEVAR4(v, cx, cy) {WRITEVAR(v.x, cx, cy) WRITEVAR(v.y, cx, cy + 1) WRITEVAR(v.z, cx, cy + 2) WRITEVAR(v.w, cx, cy + 3)}\n\n#define WriteVar(v, x) {WRITEVAR(v, x, 0) ++x;}\n#define WriteVar2(v, x) {WRITEVAR2(v, x, 0) ++x;}\n#define WriteVar3(v, x) {WRITEVAR3(v, x, 0) ++x;}\n#define WriteVar4(v, x) {WRITEVAR4(v, x, 0) ++x;}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec2 ReadVar2(int cx, int cy) {return vec2(ReadVar(cx, cy), ReadVar(cx, cy + 1));}\nvec3 ReadVar3(int cx, int cy) {return vec3(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2));}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\nfloat ReadVar(inout int x) { return ReadVar(x++, 0); }\nvec2 ReadVar2(inout int x) { return ReadVar2(x++, 0); }\nvec3 ReadVar3(inout int x) { return ReadVar3(x++, 0); }\nvec4 ReadVar4(inout int x) { return ReadVar4(x++, 0); }\n\nvec2 Knob(vec2 uv, KnobState state)\n{\n    uv -= state.p;\n    \n    float v = 0.0;\n    \n    float l = length(uv);\n    \n    v = abs(l - (state.r.x - state.r.y)) - state.r.y;\n    \n    float sh = 1.0;\n    sh = clamp01(v * 0.15);\n    sh = 1.0-(1.0-sh)*(1.0-sh);\n    sh = mix(0.85, 1.0, sh);\n    v = clamp01(v);\n    \n    v = 1.0 - v;\n    float o;\n    {\n        float a = state.n;\n\n        bool tc = state.signed;\n        if(tc) a = a * 0.5 + 0.5;\n        a *= 2.0;\n        bool ac = a > 1.0;\n        float m = clamp01((ac ? uv.x : -uv.x)+0.5);\n        if(ac) a = a - 1.0;\n\n        m = min(m, clamp01((tc ? 1.0 : -1.0) * dot(AngToVec((1.0-a)*Pi), uv)+0.5));\n        if(!tc && ac) m = 1.0-m;\n       \n        o = m;\n    }\n    \n    float r = v;\n    r = v * mix(0.15, 0.95, o);\n\n    if(state.signed && uv.x < 0.0) { r = v * mix(0.06, 0.6, o);}\n    return vec2(r, sh);\n}\n\n// https://www.shadertoy.com/view/4tfBzn\nfloat TextSDF(vec2 p, float glyph)\n{\n    p = abs(p.x - .5) > .5 || abs(p.y - .5) > .5 ? vec2(0.) : p;\n    return 2. * (texture(iChannel3, p / 16. + fract(vec2(glyph, 15. - floor(glyph / 16.)) / 16.)).w - 127. / 255.);\n}\n\nvoid ValueText(inout vec4 col, vec2 uv0, float n)\n{\n    vec2 p = uv0 * 0.5;\n    \n    vec2 scale = vec2(4., 8.);\n    vec2 t = floor(p / scale);   \n\n    if(t.x < 0.0 || t.x > 5.0 || t.y != 0.0) return;\n    if((n == 0.0 || abs(n) == 1.0) && t.x > 1.0) return;\n    if(t.x == 0.0 && n >= 0.0) return;\n    \n\n    float c = 0.0;\n    \n    if(t.x == 0.0) c = 45.0;\n    else if(t.x == 1.0) c = n == 0.0 ? 48.0 : (abs(n) == 1.0 ? 49.0 : 46.0);\n    else\n    c = abs(n) == 1.0 ? 48.0 : 48.0 + mod(floor(abs(n)*1000.0 * exp2((4.0-t.x) * -(log2(10.0)/log2(2.0)))), 10.0);\n\n    p = (p - t * scale) / scale;\n    p.x = (p.x - 0.5) * 0.5 + 0.5;\n\n    if (c == 0.) return;\n    \n    float sdf = TextSDF(p, c);\n    \n    sdf = smoothstep(-0.05, 0.05, sdf);\n\n    col.r = (1.0 - sdf) * 0.75;\n}\n\n\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{  \n    Resolution = iResolution;\n    \n    col = vec4(0.0);\n    vec2 uv = uv0 - 0.5;\n   \n    \n    //if(uv.y > 5.0) return;\n    \n    int I = 0;\n    vec4 iMouseLast     = ReadVar4(I);\n    vec4 iMouseAccuLast = ReadVar4(I);\n    vec4 wasdAccuLast   = ReadVar4(I);\n    float frameAccuLast = ReadVar (I);\n    float knobVal       = ReadVar (I);\n    //KnobState stateLast = ReadKnobState(I);\n    \n    vec2 iMouseClick    = ReadVar2(I);\n    \n    \n    bool isClick = iMouseLast.z < 0.0 && iMouse.z >= 0.0;\n    \n    if(isClick) iMouseClick = iMouse.xy;\n    \n    bool shift = ReadKey(KEY_SHIFT) != 0.0;\n    \n    float kW = ReadKey(KEY_W);\n    float kA = ReadKey(KEY_A);\n    float kS = ReadKey(KEY_S);\n    float kD = ReadKey(KEY_D);\n    \n    float left  = ReadKey(KEY_LEFT);\n    float right = ReadKey(KEY_RIGHT);\n    float up    = ReadKey(KEY_UP);\n    float down  = ReadKey(KEY_DOWN);\n    \n    vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n    \n    bool didInteractUI = false;\n    \n    float knopMouseDelta = mouseDelta.y * (1.0 / 96.0 * (shift ? 0.125 : 1.0));\n     \n    if(uv.y == 4.0)\n    {\n        KnobState knob;\n    \tif(GetKnob(int(uv.x), iChannel0, frameAccuLast == 0.0, /*out*/ knob))\n        {\n            if(!isClick)\n            if(SqrLen(iMouseClick.xy - knob.p) < Pow2(knob.r.x))\n            {\n                knobVal = knob.n = clamp(knob.n + knopMouseDelta * (knob.signed ? 2.0 : 1.0), knob.signed ? -1.0 : 0.0, 1.0);\n                didInteractUI = true;\n            }\n\n            col.w = knob.n;\n        }\n    }\n    \n    float knobVal0 = 0.0;\n    {\n        KnobState knob; int i;\n        if((i = GetKnob(iMouseClick.xy, iChannel0, /*out*/ knob)) >= 0)\n        {\n            knobVal0 = knob.n;\n            didInteractUI = true;\n        }\n        \n        //if(uv.y != 4.0) knobVal0 = knobVal;\n    }\n    \n    {\n        KnobState state;\n        bool isKnob = GetKnob(uv0, iChannel0, frameAccuLast == 0.0, /*out*/ state) >= 0;\n\n        if(isKnob)\n        {\n            vec2 k = Knob(uv0, state);\n            col.xy = vec2(k.x, 1.0 - k.y);\n        }\n        \n    \tValueText(col, uv0, knobVal0);\n    }\n    \n    bool anyK = false;\n    \n    anyK = anyK || iMouse.z > 0.0;\n    anyK = anyK || shift;\n    anyK = anyK || kW != 0.0;\n    anyK = anyK || kA != 0.0;\n    anyK = anyK || kS != 0.0;\n    anyK = anyK || kD != 0.0;\n    anyK = anyK || left  != 0.0;\n    anyK = anyK || right != 0.0;\n    anyK = anyK || up    != 0.0;\n    anyK = anyK || down  != 0.0;\n    \n    \n    float frameAccu = frameAccuLast + 1.0;\n    //if(anyK) frameAccu = 0.0;\n    \n    \n    vec4 wasdAccu = wasdAccuLast;\n    wasdAccu += vec4(kW, kA, kS, kD);\n    wasdAccu += vec4(up, left, down, right);        \n    \n        \n    bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n    cond0 = cond0 && !didInteractUI;\n    \n    vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n    vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n    \n    vec4 iMouseAccu = iMouseAccuLast + vec4(mouseDelta2, mouseDelta3);\n    \n\n    \n    int J = 0;\n    WriteVar4(iMouse,       J);\n    WriteVar4(iMouseAccu,   J);\n    WriteVar4(wasdAccu,     J);\n    WriteVar(frameAccu,     J);\n    WriteVar(knobVal,       J);\n\t//WriteKnobState(state, uv, col, J);\n\n    WriteVar2(iMouseClick,  J);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}