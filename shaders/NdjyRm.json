{
    "Shader": {
        "info": {
            "date": "1643286499",
            "description": "Looking through glass with the Mandelbrot set imprinted. Mouse to rotate the cubemap. See comments to speed up.",
            "flags": 32,
            "hasliked": 0,
            "id": "NdjyRm",
            "likes": 38,
            "name": "Glass Mandelbrot",
            "published": 3,
            "tags": [
                "mouse",
                "mandelbrot",
                "triangle",
                "glass",
                "heightmap",
                "orbit",
                "trap",
                "refract"
            ],
            "usePreview": 0,
            "username": "amhall",
            "viewed": 854
        },
        "renderpass": [
            {
                "code": "// Looking through glass with the Mandelbrot set imprinted. There's a few\n// approximations/corners cut to simplify things but it still looks good.\n\n// Performance boosters in order of importance: enable CIRCLEORBIT in buffer A,\n// reduce maxIters in buffer A, disable DISPERSE, disable FRESNEL.\n\n// Buffer A renders the heightmap, which is used here to calculate the surface normal\n// and have a field day from there.\n\n// Created by Anthony Hall\n\n\n// Refracts an individual beam for each color channel\n#define DISPERSE\n\n// Introduces some reflection according to (slightly modified) Fresnel equation\n#define FRESNEL\n\n// Index must be at least 1.0 as the shader is not designed to handle total internal\n// reflection. 1.52 is the refractive index of glass, disperse intensity is arbitrary\n// because the dispersion is not exactly physically modeled\nconst float refractiveIndex = 1.52;\nconst float disperseIntensity = 0.02;\n\n// This is inversely proportional to the max height of the heightmap, i.e. raising this\n// will treat the map as flatter\nconst float normalZScale = 5.0;\n\nconst float fov = radians(70.0);\n\nfloat convertHeight(vec2 rawHeight)\n{\n    return rawHeight.x + rawHeight.y / 1024.0;\n}\n\nvec3 getNormal(vec2 fragCoord, float height)\n{\n    float xSign = 2.0 * float(fragCoord.x < iResolution.x - 1.0) - 1.0;\n    float ySign = 2.0 * float(fragCoord.y < iResolution.y - 1.0) - 1.0;\n    float heightX = convertHeight(texelFetch(iChannel0, ivec2(fragCoord + vec2(xSign, 0)), 0).xy);\n    float heightY = convertHeight(texelFetch(iChannel0, ivec2(fragCoord + vec2(0, ySign)), 0).xy);\n    \n    float dx = xSign * (heightX - height);\n    float dy = ySign * (heightY - height);\n    return normalize(vec3(-dx, -dy, normalZScale / min(iResolution.x, iResolution.y))); // Correct against resolution\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // The ray intersection is treated as if the glass is flat because doing\n    // otherwise is more expensive than it's worth\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    float height = convertHeight(texelFetch(iChannel0, ivec2(fragCoord), 0).xy);\n    vec3 normal = getNormal(fragCoord, height);\n    \n    float effectMix = smoothstep(0.0, 3.0, iTime); // Strength of refraction/dispersion\n    float index = 1.0 + (refractiveIndex - 1.0) * effectMix;\n    \n    vec3 rayDir = normalize(vec3(uv * tan(fov / 2.0), -1.0));\n    vec3 refracted = refract(rayDir, normal, 1.0 / index);\n    \n    // Rotation/mouse input\n    float xyTheta;\n    float yzTheta;\n    float xzTheta;\n    if (iMouse.z > 0.0)\n    {\n        xyTheta = 0.0;\n        yzTheta = (iMouse.y / iResolution.y - 0.5) * pi;\n        xzTheta = (2.0 * iMouse.x / iResolution.x - 1.0) * pi;\n    }\n    else\n    {\n        xyTheta = -0.031 * iTime;\n        yzTheta = 0.45 - 0.05 * cos(0.11 * iTime);\n        xzTheta = -0.04 * iTime;\n    }\n    mat3 rayMat = xyRotate(xyTheta);\n    rayMat = yzRotate(yzTheta) * rayMat;\n    rayMat = xzRotate(xzTheta) * rayMat;\n    \n#ifdef DISPERSE\n    vec3 refractedG = refract(rayDir, normal,\n        1.0 / (index + effectMix * disperseIntensity));\n    vec3 refractedB = refract(rayDir, normal,\n        1.0 / (index + 2.0 * effectMix * disperseIntensity));\n#endif\n    \n#ifdef FRESNEL\n    // Fresnel for S polarization - It's already subtle, so it's hardly noticeable at\n    // all with any amount of P polarization reflectance factored in. Since it's subtle\n    // I also change the exponent to bring up the low values a bit\n    float cosIncident = abs(dot(rayDir, normal));\n    float cosRefracted = abs(dot(refracted, normal));\n    float reflectance = (cosIncident / index - cosRefracted)\n        / (cosIncident / index + cosRefracted);\n    reflectance = pow(abs(reflectance), 1.7); // 2.0 for scientific accuracy\n#endif\n    \n    refracted = rayMat * refracted;\n    \n#ifdef DISPERSE\n    refractedG = rayMat * refractedG;\n    refractedB = rayMat * refractedB;\n#endif\n    \n#ifdef FRESNEL\n\n#ifdef DISPERSE\n    vec3 transmitColor = vec3(\n        texture(iChannel1, refracted).r,\n        texture(iChannel1, refractedG).g,\n        texture(iChannel1, refractedB).b);\n#else\n    vec3 transmitColor = texture(iChannel1, refracted).rgb;\n#endif\n\n    vec3 reflected = rayMat * reflect(rayDir, normal);\n    vec3 reflectColor = texture(iChannel1, reflected).rgb;\n    vec3 color = mix(transmitColor, reflectColor, reflectance);\n    \n#else\n\n#ifdef DISPERSE\n    vec3 color = vec3(\n        texture(iChannel1, refracted).r,\n        texture(iChannel1, refractedG).g,\n        texture(iChannel1, refractedB).b);\n#else\n    vec3 color = texture(iChannel1, refracted).rgb;\n#endif\n\n#endif\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// The buffer generates the heightmap of the Mandelbrot set by using smooth iteration\n// count with a little bit of orbit trapping to spice things up. Unfortunately I got\n// greedy with this whole shader and supersampling is too expensive.\n\n// Circular orbit trap is cheaper than triangular\n//#define CIRCLEORBIT\n\nconst float maxIters = 400.0;\n\n// This tool is always useful for finding interesting regions (with coordinates)\n// within double precision limits\n// https://sciencedemos.org.uk/mandelbrot.php\nconst vec2 zoomCenter = 0.5 * vec2(\n    -0.111792418416\t- 0.105212213568,\n    -0.902231313283 - 0.899972653438);\n\nvec2 cSquare(vec2 c)\n{\n    return vec2(c.x*c.x - c.y*c.y, 2.0*c.x*c.y);\n}\n\n// \"Triangular\" distance from origin (or circle with CIRCLEORBIT)\nfloat orbit(vec2 point)\n{\n#ifdef CIRCLEORBIT\n    return dot(point, point);\n#endif\n    point.y = abs(point.y);\n    return max(point.x, dot(point, vec2(-0.5, 0.5 * sqrt(3.0))));\n}\n\n// Returns iteration count and triangle orbit distance\nvec2 mandelbrot(vec2 C)\n{\n    vec2 z = C;\n    float zz; // z . z\n    float orbitDist = 100.0;\n    float iters;\n    const float bound = 32.0;\n    \n    // This optimizes the smooth iteration formula and brings it into the format I want\n    const float smoothIterOffset = -log2(log2(bound)) - 2.0;\n    \n    for (iters = 0.0; iters < maxIters; iters++)\n    {\n        z = cSquare(z) + C;\n        zz = dot(z, z);\n        if (zz >= bound * bound)\n            break;\n        orbitDist = min(orbitDist, orbit(z));\n    }\n    // See Inigo Quilez's article on smooth iteration count\n    // https://iquilezles.org/articles/msetsmooth\n    if (iters != maxIters)\n        iters -= (log2(log2(zz)) + smoothIterOffset);\n        \n    return vec2(iters, orbitDist);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    float smoothTime; // Time that smoothly transitions from 0 to normal speed\n    if (iTime < 2.0)\n        smoothTime = 0.25 * iTime * iTime;\n    else\n        smoothTime = iTime - 1.0;\n    float rotTime = 0.11 * smoothTime;\n    float zoom = exp2(-10.0 * (0.5 - 0.5 * cos(0.16 * iTime)));\n    \n    vec2 center = mix(zoomCenter, vec2(-0.6, 0.0), pow(zoom, 1.3));\n    vec2 point = center + 1.35 * rotate(rotTime) * uv * zoom;\n    vec2 result = mandelbrot(point);\n    \n#ifdef CIRCLEORBIT\n    float height = log2(result.x) / log2(maxIters)\n        + 0.05 * cos(2.0 * log2(result.y));\n#else\n    float height = log2(result.x) / log2(maxIters)\n        + 0.05 * cos(3.0 * log2(result.y));\n#endif\n    \n    // Half float smallest interval is 1/1024 when the value is between 1 and 2\n    // (max height is a little over 1)\n    // To get better resolution, the first channel is a quantized height value\n    // and the second channel is the fractional component between the steps\n    float h1 = floor(height * 1024.0) / 1024.0;\n    float h2 = fract(height * 1024.0);\n    fragColor = vec4(h1, h2, 1, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float pi = radians(180.0);\nconst float twoPi = radians(360.0);\n\nmat2 rotate(float theta)\n{\n    vec2 cs = vec2(cos(theta), sin(theta));\n    return mat2(cs.x, cs.y, -cs.y, cs.x);\n}\n\nmat3 xyRotate(float theta)\n{\n    vec2 cs = vec2(cos(theta), sin(theta));\n    return mat3(\n        cs.x, cs.y, 0,\n        -cs.y, cs.x, 0,\n        0, 0, 1);\n}\n\nmat3 yzRotate(float theta)\n{\n    vec2 cs = vec2(cos(theta), sin(theta));\n    return mat3(\n        1, 0, 0,\n        0, cs.x, cs.y,\n        0, -cs.y, cs.x);\n}\n\nmat3 xzRotate(float theta)\n{\n    vec2 cs = vec2(cos(theta), sin(theta));\n    return mat3(\n        cs.x, 0, cs.y,\n        0, 1, 0,\n        -cs.y, 0, cs.x);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}