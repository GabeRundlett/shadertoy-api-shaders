{
    "Shader": {
        "info": {
            "date": "1556847466",
            "description": "Infinite pulsating sponge. WASD + mouse to fly around. Controls taken from https://www.shadertoy.com/view/Mtc3WX (modified with fractal-aware speed). Now with collisions!",
            "flags": 48,
            "hasliked": 0,
            "id": "3tfGzj",
            "likes": 10,
            "name": "Spongiform universe",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "sponge",
                "movement",
                "wasd"
            ],
            "usePreview": 1,
            "username": "ShnitzelKiller",
            "viewed": 714
        },
        "renderpass": [
            {
                "code": "\n\nvec4 chan3(float x){return texture(iChannel3,vec2(x,.5)/iResolution.xy,-100.);}\n\n\nfloat lattice(vec3 pos) {\n    pos = mod(pos+0.5, 1.0)-0.5;\n    float radius = baseradius + amplitude * sin(iTime/retardation);\n    return min(length(pos.xy)-radius, min(length(pos.yz)-radius, length(pos.zx)-radius));\n}\n\nfloat map(vec3 pos) {    \n    int i;\n    float scale = 0.333333;\n    float d1 = -9999.9;\n    for (i=0; i<6; i++) {\n    \td1 = max(d1, -lattice(pos*scale)/scale);\n        scale = scale * 3.0;\n    }\n    return d1;\n}\n\nvec4 normal(vec3 pos) {\n    vec3 offsets = vec3(0.0005, -0.0005, 0.0);\n    float mxp = map(pos+offsets.xzz);\n    float mxn = map(pos+offsets.yzz);\n    float myp = map(pos+offsets.zxz);\n    float myn = map(pos+offsets.zyz);\n    float mzp = map(pos+offsets.zzx);\n    float mzn = map(pos+offsets.zzy);\n    return vec4(normalize(vec3(mxp-mxn,myp-myn,mzp-mzn)), mxp+mxn+myp+myn+mzp+mzn-6.0*map(pos));\n}\n\nfloat shadowtrace(vec3 ro, vec3 rd) {\n    int i;\n    float t = shadoweps;\n    float dist = map(ro+t*rd);\n    float fac = 1.0;\n    float currstep = shadowstep;\n    for (i=0; i<shadowiters; i++) {\n        t += currstep;\n        dist = map(ro + t*rd);\n        fac = min(fac, dist * sharpness / t);\n        currstep += stepstep;\n    }\n    return fac > 0. ? mix(0.5, 1., fac) : mix(0.5, 0., -fac);\n}\n\nvec2 raytrace(vec3 eye, vec3 dir) {\n    float t = 0.0;\n    float m = map(eye);\n    int i;\n    for (i=0;i<iters && m >= 0.;i++) {\n        t += m;\n        m = map(eye+t*dir);\n        if (abs(m) < tol) {\n            break;\n        } else if (m > maxdist) {\n            return vec2(t, 0.0);\n        }\n    }\n    return vec2(t, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //float h = iMouse.y < 1. ? 0.2 : (iMouse.y/iResolution.y - 0.5) * PI;\n    //float ww = (iMouse.x < 1. ? 0. : (iMouse.x/iResolution.x - 0.5) * PI) + iTime/20.;\n    //vec3 ro = 2.*vec3(sin(ww)*cos(h), sin(h), cos(ww)*cos(h));\n    //vec3 w = -normalize(ro);\n    //vec3 u = normalize(cross(w, vec3(0., 1.0, 0.)));\n    //vec3 v = cross(u, w);\n    //vec3 rd = normalize(w*fdist+(fragCoord.x/iResolution.x-0.5)*u+(fragCoord.y-iResolution.y/2.0)/iResolution.x*v);\n    vec3 ro=chan3(.5).xyz;\n    vec3 ta=chan3(1.5).xyz*6.28318530718;\n    vec3 ray=normalize(vec3((fragCoord.xy-iResolution.xy*.5)/iResolution.x,fdist));\n \tray.zy=ray.zy*cos(ta.x)+sin(ta.x)*vec2(1,-1)*ray.yz;\n \tray.xz=ray.xz*cos(ta.y)+sin(ta.y)*vec2(1,-1)*ray.zx;\n    vec2 d = raytrace(ro, ray);\n    vec3 col;\n    vec3 ambient = mix(vec3(0.0, 0.0, 0.1), vec3(0.0, 0.5, 1.0), pow(1.0-abs(ray.y), 7.0));\n    if (d.y > 0.5) {\n        vec3 pos = ro+ray*d.x;\n        vec4 n = normal(pos);\n        float fac = dot(n.xyz, lightdir);\n        fac = min(fac, shadowtrace(pos, lightdir));\n        fac = max(fac, 0.0);\n        fac += max(dot(n.xyz, -lightdir), 0.0)*0.2;\n        vec3 poscale = pos * 100.;\n        vec3 texz = texture(iChannel0, poscale.xy).xyz;\n        vec3 texx = texture(iChannel0, poscale.yz).xyz;\n        vec3 texy = texture(iChannel0, poscale.zx).xyz;\n        vec3 col0 = vec3(0.8, 1., 0.6)-texy*n.y*n.y+texz*n.z*n.z+texx*n.x*n.x;\n\n        //vec3 col0 = vec3(0.8, 1., 0.6);\n        col = col0*fac;\n        col += n.w*700. * vec3(1.0, 0.3, 0.2);\n        col *= min(1.0, 2./(d.x*d.x));\n        col += ambient * d.x/10.;\n        \n    } else {\n        col = ambient;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 2,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//WASD-Movement\n//Ben Quantock 2016\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//shortened&modified by ollj \n#define fl float\n#define ff const fl\n#define collisiondist 0.001\nff minY=0.;//minimum height.\nff yMul=-1.;//negate to invert y-axis in controls\nff acc =.001;//acceleration \nff fri =.95;//friction\n\n//if both are disabled, it uses both (zq=wa)+sd+f+space\n//#define wasd\n//#define zqsd\n\n#define cf 256.;\n#define cfc cf ff\nff Key_left=37.5/cfc Key_up=38.5/cfc Key_right=39.5/cfc Key_down=40.5/cfc Key_Space=32.5/cfc \nKey_0=48.5/cfc Key_1=49.5/cfc Key_2=50.5/cfc Key_3=51.5/cfc Key_4=52.5/cfc Key_5=53.5/cfc Key_6=54.5/cfc Key_7=55.5/cfc Key_8=56.5/cfc Key_9=57.5/cfc \nKey_A=65.5/cfc Key_B=66.5/cfc Key_C=67.5/cfc Key_D=68.5/cfc Key_E=69.5/cfc Key_F=70.5/cfc Key_G=71.5/cfc Key_H=72.5/cfc Key_I=73.5/cfc Key_J=74.5/cfc Key_K=75.5/cfc Key_L=76.5/cfc Key_M=77.5/cfc Key_N=78.5/cfc Key_O=79.5/cfc Key_P=80.5/cfc Key_Q=81.5/cfc Key_R=82.5/cfc Key_S=83.5/cfc Key_T=84.5/cfc Key_U=85.5/cfc Key_V=86.5/cfc Key_W=87.5/cfc Key_X=88.5/cfc Key_Y=89.5/cfc Key_Z=90.5/cf\nfl rkInternal(fl k,fl t){return texture(iChannel3,vec2(k,t)).x;}\nfl rk      (fl k){return rkInternal(k,.25);}\nfl rkToggle(fl k){return rkInternal(k,.75);}\nvec4 chan0(fl x){return texture(iChannel0,vec2(x,.5)/iResolution.xy,-100.);}\n\nfloat lattice(vec3 pos) {\n    pos = mod(pos+0.5, 1.0)-0.5;\n    float radius = baseradius + amplitude * sin(iTime/retardation);\n    return min(length(pos.xy)-radius, min(length(pos.yz)-radius, length(pos.zx)-radius));\n}\n\nfloat map(vec3 pos) {    \n    int i;\n    float scale = 0.333333;\n    float d1 = -9999.9;\n    for (i=0; i<6; i++) {\n    \td1 = max(d1, -lattice(pos*scale)/scale);\n        scale = scale * 3.0;\n    }\n    return d1;\n}\n\nvec3 normal(vec3 pos) {\n    vec3 offsets = vec3(0.0005, -0.0005, 0.0);\n    float mxp = map(pos+offsets.xzz);\n    float mxn = map(pos+offsets.yzz);\n    float myp = map(pos+offsets.zxz);\n    float myn = map(pos+offsets.zyz);\n    float mzp = map(pos+offsets.zzx);\n    float mzn = map(pos+offsets.zzy);\n    return normalize(vec3(mxp-mxn,myp-myn,mzp-mzn));\n}\n\nvoid mainImage(out vec4 r, in vec2 i){r=vec4(0.,0.,0.,1.);if(int(i.y)==0){\n if(int(i.x)==0){//x=0 stores CameraPosition.xyz; .w stores if the camera is flying: if(camPos.w>.0) is flying, no gravity|jumping\n  vec4 camPos=chan0(.5);\n  vec4 camVel=chan0(3.5);\n  float dist = map(camPos.xyz);\n     if (dist < collisiondist) {\n         camPos.xyz -= normal(camPos.xyz) * (dist-collisiondist);\n     }\n     if (iMouse.x < 1. && iMouse.y < 1.) {\n         camPos.z += 0.015;\n     }\n  r=camPos+camVel*max(dist*2., 0.01);\n  //if(camPos.y<.0)r.y=minY;//no flying below .y<minY\n  r.w=rkToggle(Key_F);\n }else if(int(i.x)<2){//x=1. stores [cameraRot=0] in radians; .w stores iMouse.z, if mouse was held down at the last frame.\n  vec4 b=chan0(2.5);vec4 o=chan0(1.5);\n  vec2 m=(iMouse.yx/iResolution.yx-.5)*vec2(.5*yMul,1.);\n  o.w=iMouse.z;bool p=o.w>.0;\n  if(p&&!(b.w >.0))b.xy-=m;if(p)o.xy=b.xy+m;else b=o;b.w=o.w;\n  r=(int(i.x)==1)?o:b;\n  //x=2. stores [BASE-cameraRot=b] in radians; the last [camRot=o] were the mouse was being held down.\n }else if(int(i.x)==3){//x=3. stores [cameraVel=v] for acceleration and friction.\n  vec4 p=chan0(.5);vec4 v=chan0(3.5);vec4 o=chan0(1.5)*6.28318530718;\n  bool fly=p.w>.0;\n  vec3 f=acc*vec3(0,0,1);vec3 l=f.zxx;\n  if(!fly){fl s=sin(o.x);fl c=cos(o.x);\n   f.zy=f.zy*c+s*vec2(1,-1)*f.yz;\n   l.zy=l.zy*c+s*vec2(1,-1)*l.yz;}\n  fl s=sin(o.y);fl c=cos(o.y);\n  f.xz=f.xz*c+s*vec2(1,-1)*f.zx;\n  l.xz=l.xz*c+s*vec2(1,-1)*l.zx;\n#ifdef wasd\n v.xyz+=(rk(Key_W)-rk(Key_S))*f;\n v.xyz+=(rk(Key_D)-rk(Key_A))*l;\n#elseif zqsd\n v.xyz+=(rk(Key_Z)-rk(Key_S))*f;\n v.xyz+=(rk(Key_D)-rk(Key_Q))*l;  \n#else \n v.xyz+=(max(rk(Key_W),rk(Key_Z))-rk(Key_S))*f;\n v.xyz+=(rk(Key_D)-max(rk(Key_A),rk(Key_Q)))*l; \n#endif\n v.xyz+=(rk(Key_up)-rk(Key_down))*f;\n v.xyz+=(rk(Key_right)-rk(Key_left))*l;\n v*=fri;\n  if(fly){v.y-=.01;\n   if(p.y<=.0)v.y=(rk(Key_Space)!=.0)?.3:minY;\n  }r=v;}} else discard;}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define iters 100\n#define tol 0.00001\n#define maxdist 8.0\n#define PI 3.141593\n#define fdist 0.3\n#define radius2 1.0\n#define lightdir normalize(vec3(1,3,2))\n#define shadoweps 0.05\n#define shadowiters 30\n#define shadowstep 0.05\n#define stepstep 0.009\n#define sharpness 400.\n#define amplitude 0.08\n#define baseradius 0.28\n#define retardation 2.0",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}