{
    "Shader": {
        "info": {
            "date": "1610126944",
            "description": "just following video Tutorial: Advanced anime water splash FX in blender [url]https://youtu.be/zZsfr5f273c[/url]\n\ncontrol - [b]Mouse left click[/b] to rotate camera, [b]Keyboard arrows[/b] to move camera",
            "flags": 48,
            "hasliked": 0,
            "id": "wldcW2",
            "likes": 96,
            "name": "anime water splash FX",
            "published": 3,
            "tags": [
                "water",
                "anime",
                "splash"
            ],
            "usePreview": 0,
            "username": "morimea",
            "viewed": 2918
        },
        "renderpass": [
            {
                "code": "\n// Created by Danil (2021+) https://github.com/danilw\n\n// just following youtube video tutroial\n// original video https://youtu.be/zZsfr5f273c\n\n// (in this shader just setting voronoi parameters to make it look like on\n// video)\n\n// License Mit license\n\n// helper-functions for noise in Common\n\n// using https://www.shadertoy.com/view/ldB3zc\n// using https://www.shadertoy.com/view/XdXGW8\n// using https://www.shadertoy.com/view/4sfGzS\n\n// using iq's intersectors:\n// https://iquilezles.org/articles/intersectors\n\n#define AA 2\n\n#define cloud_steps 16\n\nconst vec3 bgcol = vec3(0x06, 0xb6, 0xf3) / float(0xff);\nconst vec3 white = vec3(0xd1, 0xee, 0xf5) / float(0xff);\nconst vec3 blue = vec3(0x01, 0x8e, 0xc6) / float(0xff);\n\n// mix two voronoi layers and ring\nfloat get_voronoi_texture(vec2 p, float fade, float time) {\n  vec2 op = p;\n\n  // two voronoi\n  p = ToPolar(p) * 01.175;\n  p.y += -time * 0.51;\n  p.x = abs(p.x) * 4.;\n  vec2 td = voronoi(p * vec2(2.5, 1.185), 0.51, time * .1);\n  vec2 td2 = voronoi(p * vec2(1.5, 1.185), 0.51, time * .05);\n  td *= td2;\n\n  // rings\n  // adding rings to voronoi\n  time += -0.35;\n  p = op;\n  p *= 0.05;\n  float d = noise2(p * 4. + time * 0.51 * 0.05 * 8.);\n  d = (fade * 0.235 +\n       abs(mod(length(p) + 0.07 * d - time * 0.51 * 0.05 * 2., 0.15) - 0.075));\n  float a = 1. - smoothstep(0.4485, 0.4485 + 0.005, td.y * .855 + d);\n\n  td.y = min(td.y + fade * 15., 1.);\n  float b = 1. - smoothstep(0.4785, 0.4785 + 0.005, td.y);\n\n  return max(a, b);\n}\n\n// rings\n// mix voronoy noise and rings\nfloat get_rings(vec2 p, float val, float time, float fade) {\n  vec2 op = p;\n\n  // one leayer of voronoi\n  p = ToPolar(p) * 01.5;\n  p.y += -time * 0.51;\n  p.x = abs(p.x) * .125;\n  vec2 td = voronoi(p * vec2(2.5, 1.185), 0.51, time * .1);\n  td.x = 1. - smoothstep(val, val + 0.005, td.x + fade);\n\n  // rings\n  p = op;\n  p *= 0.05;\n  float d = noise2(p * 4. + time * 0.51 * 0.05 * 8.);\n  d = (1. - smoothstep(0.01, 0.015,\n                       fade * 0.5 + abs(mod(length(p) + 0.07 * d -\n                                                time * 0.51 * 0.05 * 2.,\n                                            0.15) -\n                                        0.075)));\n  return td.x * d;\n}\n\n// floor texture\nvec4 get_color_floor(vec2 p, vec3 sunDir, vec3 nor) {\n  float d = 0.;\n  float time = iTime * 2.5;\n  float fade = smoothstep(0.3, .845, length(p * 0.05));\n  fade = max(fade, 1. - (smoothstep(-0.075, 0.15, length(p * 0.05))));\n\n  d = get_voronoi_texture(p, fade, time);\n  d = min(d + get_rings(p, 0.73, time, fade) +\n              get_rings(p, 0.3, time * 0.75, fade),\n          1.);\n\n  return vec4(mix(blue * (max(dot(nor, sunDir), 0.0) + 0.05), white, d), 1.);\n}\n\n// cylinder on middle\nvec4 get_colorCylinder(vec2 p) {\n  float d = 0.;\n  float time = iTime;\n  p.y += time * 0.51;\n  p.x = abs(p.x);\n  p *= 5.;\n  vec2 td = voronoi(p * vec2(2.5, 1.185), 0.51, time * .1);\n  p.y += time * 0.51;\n  vec2 td2 = voronoi(p * vec2(2.5, 1.185), 0.51, (time)*.1);\n  td *= td2;\n  d = max((1. - smoothstep(0.476, 0.476 + 0.005, td.y)),\n          (1. - smoothstep(0.685, 0.685 + 0.005, td2.y)));\n\n  return vec4(mix(blue, white, d), 1.);\n}\n\n// cloud SDF\n// this made only for this shader, do not use it in real time, it slow\n\nvec2 sdf(vec3 p) {\n  vec3 p2 = p + vec3(0., 1.8, 0.) * iTime;\n  \n  float plane = dot(p + vec3(0, -0.34, 0), vec3(0., 1., 0.));\n  float sphere = length(p * vec3(1., 1.25, 1.) + vec3(0.)) - 1.949;\n  float sphere2 = length(p * vec3(1., 2.75, 1.) + vec3(0.)) - 2.1949;\n  sphere = min(sphere, sphere2);\n  float sphere3 = length(p + vec3(0., -1.5, 0.0)) - 1.219;\n  float d =\n      max(max(sphere, -sphere3), -plane);\n\n  float f = fbm(p2) - 0.8;\n  float td = mix(d, f, .372);\n  if (td < sphere3)\n    return vec2(td, 1);\n  else\n    return vec2(td, 2);\n}\n\nvec3 materialCloud(float d) {\n\n  float result = 1.;\n  float depth = 0.21;\n  float minlight = 0.31;\n  result = min(result, (d * 2.6 / depth) + minlight);\n  if (d < 0.00001) {\n    result = minlight;\n  }\n  return clamp(mix(blue * 0.465, (white)*3.515, result * (result + result)), 0.,\n               1.);\n}\n\n// ignore AA in sdf\n#if AA > 1\nbool once = false;\nvec4 col_once = vec4(0.);\n#endif\n\nvec4 get_colorSphere(vec3 ro, vec3 rd, vec3 bg) {\n#if AA > 1\n  if (once)\n    return col_once;\n#endif\n  float ratio = 1.0;\n  vec3 cloud = bg;\n\n  float depth = 0.;\n  for (int I = 0; I < cloud_steps; ++I) {\n\n    vec3 p = ro + rd * depth;\n    if (depth > 100.) {\n      break;\n    }\n    vec2 ss = sdf(p);\n\n    if (ss.x < 0.015) {\n      if (int(ss.y) == 1) {\n        ratio = min(ratio, 0.9);\n        vec3 l = materialCloud(ss.x);\n        cloud = mix(cloud, l, ratio);\n        ratio *= .7;\n        if (ratio < 0.0001) {\n          break;\n        }\n        depth += ss.x;\n      }\n    } else {\n      depth += max(ss.x, 0.01);\n    }\n  }\n\n#if AA > 1\n  col_once = vec4(cloud, 1.);\n  once = true;\n#endif\n\n  return vec4(cloud, 1.);\n}\n\n\n\n// other code is intersection scene\n\nvec3 l1Pos = vec3(0.0, 5.0, 0.0);\n\n#define MAX_DIST 1000.\n#define MIN_DIST 0.\n\n#define OBJ_NONE 0\n#define OBJ_SPH 1\n#define OBJ_FLOOR 2\n#define OBJ_CYL 3\n\n#define load(P) texelFetch(iChannel0, ivec2(P), 0)\n\nconst ivec2 RES_LAST = ivec2(0, 0);\nconst ivec2 INIT = ivec2(0, 1);\nconst ivec2 TARGET = ivec2(0, 2);\n\nconst ivec2 POSITION = ivec2(1, 0);\nconst ivec2 POSITION_last = ivec2(1, 1);\n\nconst ivec2 VMOUSE = ivec2(2, 0);\nconst ivec2 VMOUSE_last = ivec2(2, 1);\n\nconst ivec2 INPUT = ivec2(3, 0);\nconst ivec2 PMOUSE = ivec2(3, 1);\n\nstruct Ray {\n  vec3 pos;\n  vec3 dir;\n};\n\nvoid SetCamera(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    ro = load(POSITION).xyz;\n    vec2 m = load(VMOUSE).xy;\n    m.y = -m.y;\n    float fov=70.;\n    float aspect = iResolution.x / iResolution.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    rd = vec3(uv*screenSize, 1./aspect);\n    \n    rd = normalize(rd);\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n\n    rd = (rotY * rotX) * rd;\n}\n\nbool PlaneIntersect(vec4 Plane, vec3 ro, vec3 rd, out float t, out vec3 norm) {\n  norm = vec3(0., 1., 0.);\n  t = -1.;\n  float dd = dot(rd, Plane.xyz);\n  if (dd == 0.0)\n    return false;\n  float t1 = -(dot(ro, Plane.xyz) + Plane.w) / dd;\n  if (t1 < 0.0)\n    return false;\n  norm = normalize(Plane.xyz);\n  t = t1;\n  return true;\n}\n\nbool SphereIntersect(vec3 SpPos, float SpRad, vec3 ro, vec3 rd, out float t,\n                     out vec3 norm) {\n  ro -= SpPos;\n\n  float A = dot(rd, rd);\n  float B = 2.0 * dot(ro, rd);\n  float C = dot(ro, ro) - SpRad * SpRad;\n  float D = B * B - 4.0 * A * C;\n  t = -1.;\n  norm = vec3(0., 1., 0.);\n  if (D < 0.0)\n    return false;\n\n  D = sqrt(D);\n  A *= 2.0;\n  float t1 = (-B + D) / A;\n  float t2 = (-B - D) / A;\n  if (t1 < 0.0)\n    t1 = t2;\n  if (t2 < 0.0)\n    t2 = t1;\n  t1 = min(t1, t2);\n  if (t1 < 0.0)\n    return false;\n  norm = ro + t1 * rd;\n  t = t1;\n  norm = normalize(norm);\n  return true;\n}\n\nbool CylinderIntersect(in vec3 ro, in vec3 rd, in float ra, in float heigh,\n                       out float tN, out vec3 norm) {\n  vec3 pa = vec3(0., heigh, 0.);\n  vec3 pb = vec3(0., -heigh, 0.);\n  vec3 ba = pb - pa;\n\n  norm = vec3(0., 1., 0.);\n  tN = -1.;\n\n  vec3 oc = ro - pa;\n\n  float baba = dot(ba, ba);\n  float bard = dot(ba, rd);\n  float baoc = dot(ba, oc);\n\n  float k2 = baba - bard * bard;\n  float k1 = baba * dot(oc, rd) - baoc * bard;\n  float k0 = baba * dot(oc, oc) - baoc * baoc - ra * ra * baba;\n\n  float h = k1 * k1 - k2 * k0;\n  if (h < 0.0)\n    return false;\n  h = sqrt(h);\n  float t = (-k1 - h) / k2;\n  if (t < 0.0)\n    return false;\n\n  float y = baoc + t * bard;\n  if (y > 0.0 && y < baba) {\n    tN = t;\n    norm = (oc + t * rd - ba * y / baba) / ra;\n    return true;\n  }\n\n  t = (((y < 0.0) ? 0.0 : baba) - baoc) / bard;\n  if (abs(k1 + k2 * t) < h) {\n    tN = t;\n    norm = ba * sign(y) / baba;\n    return true;\n  }\n\n  return false;\n}\n\nstruct HitInfo {\n  float t;\n  vec3 norm;\n  vec4 color;\n  int obj_type;\n};\n\nvoid GroundIntersectMin(vec3 ro, vec3 rd, inout bool result,\n                        inout HitInfo hit) {\n  float tnew = -1.;\n  vec3 normnew = vec3(0., 1., 0.);\n  vec4 pp = vec4(0., 1., 0., 0.);\n  if (PlaneIntersect(pp, ro, rd, tnew, normnew)) {\n    if (tnew < hit.t) {\n      hit.t = tnew;\n      hit.norm = normnew;\n      hit.obj_type = OBJ_FLOOR;\n      vec3 p = (ro + rd * tnew);\n      if (any(greaterThan(abs(p.xz * 0.05), vec2(.65)))) {\n\n      } else {\n        hit.color = get_color_floor(p.xz, normalize(l1Pos - p), hit.norm);\n        result = true;\n      }\n    }\n  }\n}\n\nvoid SphereIntersectMin(vec3 SpPos, float SpRad, vec3 ro, vec3 rd,\n                        inout bool result, inout HitInfo hit) {\n  float tnew;\n  vec3 normnew;\n  if (SphereIntersect(SpPos, SpRad, ro, rd, tnew, normnew)) {\n    if (tnew < hit.t) {\n      vec3 p = (ro + rd * tnew);\n      hit.color = get_colorSphere(ro, rd, hit.color.rgb);\n      hit.obj_type = OBJ_SPH;\n      hit.t = tnew;\n      hit.norm = normnew;\n      result = true;\n    }\n  }\n}\n\nvoid CylinderIntersectMin(vec3 ro, vec3 rd, float rad, float heigh, vec3 pos,\n                          inout bool result, inout HitInfo hit) {\n  float tnew;\n  vec3 normnew;\n  ro -= pos;\n  if (CylinderIntersect(ro, rd, rad, heigh, tnew, normnew)) {\n    if (tnew < hit.t) {\n      hit.t = tnew;\n      hit.norm = normnew;\n      vec3 pos = (ro + rd * hit.t);\n      vec2 tuv =\n          0.5 + vec2(atan(pos.z, pos.x) / (3.1415926 * 2.), pos.y * .5 / heigh);\n      hit.color = get_colorCylinder(tuv);\n      hit.obj_type = OBJ_CYL;\n      result = true;\n    }\n  }\n}\n\nbool minDist(vec3 ro, vec3 rd, out HitInfo hit) {\n  hit.t = MAX_DIST;\n  hit.color = vec4(bgcol.rgb, 1.);\n  bool result = false;\n\n  GroundIntersectMin(ro, rd, result, hit);\n  CylinderIntersectMin(ro, rd, 1.2, 5., vec3(0., 4.99, 0.), result, hit);\n  SphereIntersectMin(vec3(0.), 2.5, ro, rd, result, hit);\n\n  return result;\n}\n\nconst float eps = 1e-3;\n\nvec3 render(Ray r) {\n  vec3 col = vec3(0.0);\n  vec3 objectcolor = vec3(1.0);\n  vec3 mask = vec3(1.0);\n  HitInfo hit;\n  {\n    if (minDist(r.pos, r.dir, hit)) {\n      objectcolor = hit.color.rgb;\n      vec3 p = r.pos + r.dir * hit.t + hit.norm * eps;\n      // vec3 sunDir = normalize(l1Pos-p);\n      col = objectcolor;\n      // col = objectcolor * (vec3(max(dot(hit.norm,sunDir),0.0)) + 0.05);\n    } else\n      col = bgcol;\n  }\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec3 ret_col = vec3(0.0);\n#if AA > 1\n  for (int mx = 0; mx < AA; mx++)\n    for (int nx = 0; nx < AA; nx++) {\n      vec2 o = vec2(float(mx), float(nx)) / float(AA) - 0.5;\n      vec2 uv = (fragCoord + o) / iResolution.xy * 2.0 - 1.0;\n#else\n  vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n#endif\n      uv.y *= iResolution.y / iResolution.x;\n      vec3 ro; vec3 rd;\n      SetCamera(uv, ro, rd);\n      vec3 col = render(Ray(ro, rd));\n      ret_col += col;\n#if AA > 1\n    }\n  ret_col /= float(AA * AA);\n#endif\n  ret_col = pow(ret_col, vec3(0.85));\n  fragColor = vec4(ret_col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nvec2 ToPolar(vec2 v)\n{\n    return vec2(atan(v.y, v.x), length(v));\n}\n\n\n// using https://www.shadertoy.com/view/ldB3zc\n\n// The MIT License\n// Copyright © 2014 Inigo Quilez\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec2 voronoi( in vec2 x, float w , float time)\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec2 m = vec2(8.0, 0.0);\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n        vec2 o = hash22( n + g );\n        o = 0.5 + 0.5*sin( time + 6.2831*o );\n\t\tfloat d = length(g - f + o);\t\n\t\tfloat h = smoothstep( 0.0, 1.0, 0.5 + 0.5*(m.x-d)/w );\n\t    m.x = mix( m.x,     d, h ) - h*(1.0-h)*w/(1.0+3.0*w); // distance\n        m.y = mix( m.y, 0.75, h ) - h*(1.0-h)*w/(1.0+3.0*w);\n    }\n\t\n\treturn m;\n}\n\n\n// using https://www.shadertoy.com/view/XdXGW8\n\n// The MIT License\n// Copyright © 2013 Inigo Quilez\n\nfloat noise2( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n// using https://www.shadertoy.com/view/4sfGzS\n\n// The MIT License\n// Copyright © 2013 Inigo Quilez\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise3( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash13(i+vec3(0,0,0)), \n                        hash13(i+vec3(1,0,0)),f.x),\n                   mix( hash13(i+vec3(0,1,0)), \n                        hash13(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash13(i+vec3(0,0,1)), \n                        hash13(i+vec3(1,0,1)),f.x),\n                   mix( hash13(i+vec3(0,1,1)), \n                        hash13(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat fbm( vec3 p)    // in [0,1]\n{\n    p*=0.35;\n    vec3 q = 8.0*p;\n    float f=0.;\n    f  = 0.5000*noise3( q ); q = m*q*2.01;\n    f += 0.2500*noise3( q ); q = m*q*2.02;\n    f += 0.1250*noise3( q ); q = m*q*2.03;\n    f += 0.0625*noise3( q ); q = m*q*2.01;\n    return f;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// only camera control\n// License - CC0 or use as you wish\n\n#define keyboard_texture iChannel3\n#define self_texture iChannel0\n\nconst vec3 start_pos = vec3(6.0, 7.0, -10.0);\nconst vec2 start_mouse = vec2(-0.4,-0.65); \n\n\nconst float speed = 3.75;\n\n\nvoid store(ivec2 P, ivec2 ipx, vec4 V, inout vec4 fc){ if(ipx==P) fc = V;}\n\nvec4 load(ivec2 P, sampler2D self){return texelFetch(self, ivec2(P), 0);}\nfloat key(int K, sampler2D kb){return step(0.5, texelFetch(kb, ivec2(K, 0), 0).x);}\n\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\n\nconst ivec2 RES_LAST = ivec2(0, 0);\nconst ivec2 INIT = ivec2(0, 1);\nconst ivec2 TARGET = ivec2(0, 2);\n\nconst ivec2 POSITION = ivec2(1, 0);\nconst ivec2 POSITION_last = ivec2(1, 1);\n\nconst ivec2 VMOUSE = ivec2(2, 0);\nconst ivec2 VMOUSE_last = ivec2(2, 1);\n\nconst ivec2 INPUT = ivec2(3, 0);\nconst ivec2 PMOUSE = ivec2(3, 1);\n\n\nconst int Key_Backspace = 8, Key_Tab = 9, Key_Enter = 13, Key_Shift = 16, Key_Ctrl = 17, \nKey_Alt = 18, Key_Pause = 19, Key_Caps = 20, Key_Escape = 27, Key_Space = 32, \nKey_PageUp = 33, Key_PageDown = 34, Key_End = 35,Key_Home = 36, Key_LeftArrow = 37, \nKey_UpArrow = 38, Key_RightArrow = 39, Key_DownArrow = 40, Key_Insert = 45, \nKey_Delete = 46, Key_0 = 48, Key_1 = 49, Key_2 = 50, Key_3 = 51, Key_4 = 52,\nKey_5 = 53, Key_6 = 54, Key_7 = 55, Key_8 = 56, Key_9 = 57, Key_A = 65, Key_B = 66, \nKey_C = 67, Key_D = 68, Key_E = 69, Key_F = 70, Key_G = 71, Key_H = 72,Key_I = 73, \nKey_J = 74, Key_K = 75, Key_L = 76, Key_M = 77, Key_N = 78, Key_O = 79, Key_P = 80,\nKey_Q = 81, Key_R = 82, Key_S = 83, Key_T = 84, Key_U = 85,Key_V = 86, Key_W = 87, \nKey_X = 88, Key_Y = 89, Key_Z = 90, Key_LeftWindow = 91, Key_RightWindows = 92, \nKey_Select = 93, Key_Numpad0 = 96, Key_Numpad1 = 97, Key_Numpad2 = 98, Key_Numpad3 = 99,\nKey_Numpad4 = 100, Key_Numpad5 = 101, Key_Numpad6 = 102, Key_Numpad7 = 103, \nKey_Numpad8 = 104, Key_Numpad9 = 105, Key_NumpadMultiply = 106, Key_NumpadAdd = 107,\nKey_NumpadSubtract = 109, Key_NumpadPeriod = 110, Key_NumpadDivide = 111, Key_F1 = 112,\nKey_F2 = 113, Key_F3 = 114, Key_F4 = 115, Key_F5 = 116, Key_F6 = 117, Key_F7 = 118,\nKey_F8 = 119, Key_F9 = 120, Key_F10 = 121, Key_F11 = 122, Key_F12 = 123, \nKey_NumLock = 144, Key_ScrollLock = 145,Key_SemiColon = 186, Key_Equal = 187, \nKey_Comma = 188, Key_Dash = 189, Key_Period = 190, Key_ForwardSlash = 191, \nKey_GraveAccent = 192, Key_OpenBracket = 219, Key_BackSlash = 220, \nKey_CloseBraket = 221, Key_SingleQuote = 222;\n\n\n\nvec2 KeyboardInput(sampler2D kb) {\n    ivec4 inputs1 = ivec4(Key_UpArrow, Key_DownArrow, Key_RightArrow, Key_LeftArrow); //ARROWS\n    ivec4 inputs2 = ivec4(Key_W, Key_S, Key_D, Key_A);//WASD\n    //ivec4 inputs2 = ivec4(Key_E, Key_D, Key_F, Key_S);//ESDF\n    \n\tvec2 i = vec2(max(key(inputs1.z,kb),key(inputs2.z,kb))   - max(key(inputs1.w,kb),key(inputs2.w,kb)), \n                  max(key(inputs1.x,kb),key(inputs2.x,kb)) - max(key(inputs1.y,kb),key(inputs2.y,kb)));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*0.707106);\n}\n\nvec3 CameraDirInput(vec2 vm, sampler2D kb) {\n    vec2 m = vm;\n    m.y = -m.y;\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    return (rotY * rotX) * vec3(KeyboardInput(kb), 0.0).xzy;\n}\n\n\nvoid Collision_floor(vec3 prev, inout vec3 p) {\n    if (p.y < 1.0) p = vec3(prev.xz, max(1.0, prev.y)).xzy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    ivec2 ipx = ivec2(fragCoord);\n    fragColor=vec4(0.);\n    if (any(greaterThan(ipx, MEMORY_BOUNDARY))) return;\n    \n    fragColor = load(ipx, self_texture);\n    \n    vec3 position_l = load(POSITION, self_texture).xyz;\n    vec2 vm_l = load(VMOUSE, self_texture).xy;\n    bool is_init = load(INIT, self_texture).x>1.;\n    \n    if (iFrame == 0 || !is_init) {\n        vm_l=start_mouse;\n        position_l=start_pos;\n        store(POSITION, ipx, vec4(start_pos, 0.), fragColor);\n        store(POSITION_last, ipx, vec4(position_l, 0.), fragColor);\n        store(TARGET, ipx, vec4(start_pos, 0.), fragColor);\n        store(VMOUSE, ipx, vec4(start_mouse,0.,0.), fragColor);\n        store(VMOUSE_last, ipx, vec4(vm_l,0.,0.), fragColor);\n        store(PMOUSE, ipx, vec4(start_mouse,0.,0.), fragColor);\n        store(INIT, ipx, vec4(2.,0.,0.,0.), fragColor);\n        store(INPUT, ipx, vec4(2.,0.,0.,0.), fragColor);\n        store(RES_LAST, ipx, vec4(iResolution.xy,0.,0.), fragColor);\n        return;\n    }\n\n    vec3 target      = load(TARGET, self_texture).xyz;   \n    vec3 position    = load(POSITION, self_texture).xyz;\n    vec2 pm          = load(PMOUSE, self_texture).xy;\n    vec3 vm          = load(VMOUSE, self_texture).xyz;\n    vec2 res_l       = load(RES_LAST, self_texture).xy;\n    \n    vec3 ptarget = target;\n    target += CameraDirInput(vm.xy, keyboard_texture) * iTimeDelta * speed;\n    \n    //Collision_floor(ptarget, target);\n    \n    vec3 lp = position;\n    position += (target - position) * iTimeDelta * 5.0;\n    \n    bool input_registered = false;\n    input_registered = ivec2(res_l)!=ivec2(iResolution.xy);\n    if(length(abs(position)-abs(lp))>0.0001)input_registered=true;\n    \n    store(TARGET, ipx, vec4(target, 0.0), fragColor);\n    store(POSITION, ipx, vec4(position, 0.0), fragColor);\n    \n    if (iMouse.z>0.0) {\n        input_registered=true;\n    \tstore(VMOUSE, ipx, vec4(pm + (abs(iMouse.zw) - iMouse.xy)/iResolution.y, 1.0, 0.0), fragColor);\n    }\n    else if (vm.z != 0.0) {\n    \tstore(PMOUSE, ipx, vec4(vm.xy, 0.0, 0.0), fragColor);\n    }\n    store(POSITION_last, ipx, vec4(position_l, 0.), fragColor);\n    store(VMOUSE_last, ipx, vec4(vm_l,0.,0.), fragColor);\n    \n    store(INPUT, ipx, vec4(input_registered?2.:0.,0.,0.,0.), fragColor);\n    \n    store(RES_LAST, ipx, vec4(iResolution.xy,0.,0.), fragColor);\n    \n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}