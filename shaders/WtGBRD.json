{
    "Shader": {
        "info": {
            "date": "1614007665",
            "description": "https://twitter.com/EncharmDre\n\nhttps://t.me/creative_coder\n\nInspired by https://twitter.com/muratpak",
            "flags": 0,
            "hasliked": 0,
            "id": "WtGBRD",
            "likes": 18,
            "name": "MÃ¶bius torus ",
            "published": 3,
            "tags": [
                "raymarching",
                "iridescent"
            ],
            "usePreview": 0,
            "username": "Encharm",
            "viewed": 692
        },
        "renderpass": [
            {
                "code": "#define AA 4\n#define drawEdge .875\n#define torus .9\n#define tri .3\n#define corner .02\n#define pi 3.141592653589793\n#define sqrt3 1.7320508075688772\n#define time iTime\n\nfloat random(vec2 v2) {\n    return fract(sin(dot(v2, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 opRevolution(in vec3 p, float w) {\n    return vec2(length(p.xy) - w, p.z);\n}\n\nmat2 rot(float a) {\n  float s = sin(a),\n        c = cos(a);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdEquilateralTriangle(in vec2 p, in float r ) {\n    p.x = abs(p.x) - r;\n    p.y = p.y + r / sqrt3;\n    if (p.x + sqrt3 * p.y > 0.)\n        p = vec2(p.x - sqrt3 * p.y, -sqrt3 * p.x - p.y) * .5;\n    p.x -= clamp(p.x, -2. * r, 0.);\n    return -length(p) * sign(p.y);\n}\n\nfloat map(in vec3 pos) {\n    pos.xz *= rot(time * .5);\n    vec2 revolution = opRevolution(pos, torus);\n    vec2 rotated = revolution * rot(pi * .5 - atan(pos.y, pos.x) * .33333333 + time);\n    \n    float d = sdEquilateralTriangle(rotated, tri) - corner;\n    \n    return d;\n}\n\nvec3 calcNormal(in vec3 pos) {\n    const float ep = .01;\n    vec2 e = vec2(1., -1.) * .5773;\n    return normalize(e.xyy * map(pos + e.xyy * ep) + \n\t\t\t\t\t e.yyx * map(pos + e.yyx * ep) + \n\t\t\t\t\t e.yxy * map(pos + e.yxy * ep) + \n\t\t\t\t\t e.xxx * map(pos + e.xxx * ep));\n}\n\nvec3 draw(vec2 st) {\n    vec3 color = vec3(0.);\n    vec3 normal = vec3(0.);\n    float needAA = 0.;\n    vec2 p = st / iResolution.y;\n\n    vec3 ro = vec3(0., 0., -8.);\n    vec3 rd = normalize(vec3(p, 5.));\n\n    float t = 5.0;\n    for (int i = 0; i < 30; i++) {\n        vec3 p = ro + t * rd;\n        float mapped = map(p);\n        if (abs(mapped) < 0.001 || t > 20.) break;\n        t += .9 * mapped;\n    }\n    \n    if (t < 10.) {\n        vec3 pos = ro + t * rd;\n        normal = calcNormal(pos);\n        normal.xy += random(pos.xy) * .05 - .025;\n        normal = normalize(normal);\n        float height = atan(normal.y, normal.x);\n        color = cos((height + vec3(0., .33, .67) * pi) * 2.) * .5 + .5;\n        color *= smoothstep(.95, .25, abs(normal.z));\n    }\n    \n    return color; \n}\nvec4 aaTrace(vec2 st) {\n    vec3 tot = vec3(0.);\n    for (int m = 0; m < AA; m++)\n    for (int n = 0; n < AA; n++) {\n        vec2 o = vec2(float(m), float(n)) / float(AA) - .5;\n        tot += draw(st + o * 2.);\n    }\n    tot /= float(AA * AA);\n    \n    tot = pow(tot, vec3(.45)) * 1.25;\n    tot = pow(tot, vec3(1.25));\n    \t\n    return vec4(tot, 1.);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0., 0., 0., 1.);\n    vec2 st = (-iResolution.xy + 2.0 * fragCoord);\n    float dc = length(st / iResolution.y);\n    if (dc < drawEdge) {\n        fragColor = aaTrace(st);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}