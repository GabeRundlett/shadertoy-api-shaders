{
    "Shader": {
        "info": {
            "date": "1622555605",
            "description": "Use mouse for custom rays.\nVisits cells in a rectangular grid that touch a ray:\n  - Interleaved: Sort cells by first intersection with ray\n  - Sequential: One run per dimension\n",
            "flags": 0,
            "hasliked": 0,
            "id": "7tl3RX",
            "likes": 5,
            "name": "2D Rectangular Grid Traversal",
            "published": 3,
            "tags": [
                "visualization",
                "voxel",
                "rectangle"
            ],
            "usePreview": 0,
            "username": "pyBlob",
            "viewed": 306
        },
        "renderpass": [
            {
                "code": "struct Line\n{\n    vec2 position;\n    vec2 tangent;\n    float a, b;\n};\n\nLine line(vec2 p1, vec2 p2);\nvec2 normal(vec2 tangent);\nvec2 normal(Line);\nfloat map(vec2 x, Line);\nvec4 blend(vec4 C, vec4 c, float f);\n\nvoid mainImage(out vec4 C, in vec2 O)\n{\n    O = (O - iResolution.xy / 2.);\n    C = vec4(0);\n\n    vec2 c1 = vec2(-100., -50.); // lower left corner\n    vec2 c2 = vec2(100., 50.); // upper right corner\n    ivec2 n = ivec2(9, 9); // cells per dimension\n    vec2 grid = vec2(n) / (c2 - c1); // world-position to cell-id\n\n    {\n        vec2 f = vec2(10.);\n\n        Line ray = line(\n            mix(\n                vec2(-250., -100.),\n                vec2(250., -100.),\n                .5+.5*cos(iTime*.1)),\n            vec2(50., 55.));\n        if (iMouse.z > 0.)\n            ray = line(iMouse.xy - iResolution.xy / 2., abs(iMouse.zw) - iResolution.xy / 2.);\n        // special cases\n        //ray = line(vec2(0, -100), vec2(0, 100)); // up\n        //ray = line(vec2(0, 100), vec2(0, -100)); // down\n        //ray = line(vec2(-150, 0), vec2(150, 0)); // right\n        //ray = line(vec2(150, 0), vec2(-150, 0)); // left\n        \n        vec2 i = min(\n            sign(ray.tangent) * (c1 - ray.position) * grid,\n            sign(ray.tangent) * (c2 - ray.position) * grid\n        );\n        vec2 len = 1. / abs(ray.tangent) / grid;\n        vec2 vx = ray.tangent * len.x;\n        vec2 vy = ray.tangent * len.y;\n\n        if (true)\n        {\n            // interleave x-hits and y-hits\n            for (ivec2 j=ivec2(0,0) ; any(lessThan(j, n)) ; )\n            {\n                vec2 t = (i + vec2(j)) * len;\n                int k;\n                if (j.y == n.y || j.x < n.x && t.x < t.y)\n                    k = 0;\n                else\n                    k = 1;\n                vec2 x = ray.position + t[k] * ray.tangent;\n                j[k] += 1;\n                vec2 offset = vec2(0);\n                offset[k] = .5 * sign(ray.tangent)[k];\n                vec2 cell = floor((x - c1) * grid + offset);\n                vec2 center = c1 + (cell + .5) / grid;\n                vec2 connect = center;\n                connect[k] = x[k];\n                vec2 bar = vec2(.5) / grid;\n                bar[k] = 0.;\n                f[k] = min(f[k], length(O - center) - float(k + 1));\n                f[k] = min(f[k], map(O, line(connect, center)));\n                f[k] = min(f[k], map(O, line(x - bar, x + bar)));\n            }\n        } else {\n            // find x-hits, then y-hits\n            for (int j=0 ; j<n.x ; ++j)\n            {\n                vec2 x = ray.position + i.x * vx;\n                i.x += 1.;\n                vec2 cell = floor((x - c1) * grid + vec2(.5 * sign(ray.tangent).x, 0));\n                vec2 center = c1 + (cell + .5) / grid;\n                f.x = min(f.x, length(O - center) - 1.);\n                f.x = min(f.x, map(O, line(vec2(x.x, center.y), center)));\n                f.x = min(f.x, map(O, line(x - vec2(0,.5) / grid, x + vec2(0,.5) / grid)));\n            }\n\n            for (int j=0 ; j<n.y ; ++j)\n            {\n                vec2 x = ray.position + i.y * vy;\n                i.y += 1.;\n                vec2 cell = floor((x - c1) * grid + vec2(0, .5 * sign(ray.tangent).y));\n                vec2 center = c1 + (cell + .5) / grid;\n                f.y = min(f.y, length(O - center) - 2.);\n                f.y = min(f.y, map(O, line(vec2(center.x, x.y), center)));\n                f.y = min(f.y, map(O, line(x - vec2(.5,0) / grid, x + vec2(.5,0) / grid)));\n            }\n        }\n\n        C = blend(C, vec4(1.,.2,0,1), f.x);\n        C = blend(C, vec4(0,.2,1,1), f.y);\n        C = blend(C, vec4(0,.5,0,1), map(O, ray));\n    }\n    \n    // grid\n    {\n        float f = 10.;\n        for (int i=0 ; i<n.x+1 ; ++i)\n        {\n            float a = float(i) / float(n.x);\n            f = min(f, map(O, line(\n                vec2(mix(c1, c2, a).x, c1.y),\n                vec2(mix(c1, c2, a).x, c2.y) )));\n        }\n        for (int i=0 ; i<n.y+1 ; ++i)\n        {\n            float a = float(i) / float(n.y);\n            f = min(f, map(O, line(\n                vec2(c1.x, mix(c1, c2, a).y),\n                vec2(c2.x, mix(c1, c2, a).y) )));\n        }\n        C = blend(C, vec4(vec3(0),1), f);\n    }\n\n    C = blend(C, vec4(1), 0.);\n    C.xyz = pow(C.xyz, vec3(1./2.2));\n}\n\nLine line(vec2 p1, vec2 p2)\n{\n    return Line(p1, normalize(p2 - p1), 0., length(p2 - p1));\n}\n\nvec2 normal(vec2 tangent)\n{\n    return vec2(-tangent.y, tangent.x);\n}\n\nvec2 normal(Line l)\n{\n    return normal(l.tangent);\n}\n\nfloat map(vec2 x, Line l)\n{\n    x -= l.position + l.tangent * (l.a + l.b) / 2.;\n    float u = dot(x, l.tangent);\n    float v = dot(x, normal(l));\n    return length(vec2(max(0., abs(u) - (l.b - l.a) / 2.), v));\n}\n\nvec4 blend(vec4 C, vec4 c, float f)\n{\n    return C + c * smoothstep(1.5, 0., f) * (1. - C.w);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}