{
    "Shader": {
        "info": {
            "date": "1572341123",
            "description": "An idea I had in mind for a long time :)",
            "flags": 0,
            "hasliked": 0,
            "id": "wdcXRj",
            "likes": 12,
            "name": "DVD screensaver",
            "published": 3,
            "tags": [
                "2d",
                "retro",
                "sdf"
            ],
            "usePreview": 0,
            "username": "z0rg",
            "viewed": 1775
        },
        "renderpass": [
            {
                "code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec2 rot2D(vec2 v, float a)\n{\n  float cosa=cos(a);float sina=sin(a);\n  mat2 rot = mat2(cosa,-sina,sina,cosa);\n  return v*rot;\n}\n\nfloat sat(float a)\n{\n  return clamp(a,0.0,1.0);\n}\nfloat lenny(vec2 v)\n{\n  return abs(v.x)+abs(v.y);\n}\nint imod(int a, int b)\n{\n  int res = a/b;\n  return a-(res*b);\n}\n\n// SDF operations\nfloat _union(float a, float b)\n{\n  return min(a, b);\n}\nfloat _sub(float a, float b)\n{\n  return max(-a,b);\n}\n\n// SDF functions\nfloat sdf_rect(vec2 uv, vec2 sz)\n{\n  vec2 r = abs(uv)-sz;\n  return max(r.x,r.y);\n}\n\nfloat sdf_cir(vec2 uv, float r, float thick)\n{\n  float li = length(uv)-r;\n  float lo = li-thick;\n  return _sub(li,lo);\n}\n\nfloat sdf_plaind(vec2 uv)\n{\n  float left = uv.x;\n  return _sub(left, sdf_cir(uv*vec2(.6,1.), -1.,1.075));\n}\n\nfloat sdf_v(vec2 uv)\n{\n  float res;\n  float widthUp = 0.085;\n  float pxu = 0.15;\n  res = sdf_rect(uv-vec2(-pxu,0.089), vec2(widthUp,0.018));\n  res = _union(res, sdf_rect(uv-vec2(pxu-0.02,0.089), vec2(widthUp-0.02,0.018)));\n  res = _union(res, sdf_rect(rot2D(uv-vec2(-0.04,0.0005),1.1), vec2(0.1,0.025)));\n  res = _union(res, sdf_rect(rot2D(uv-vec2(0.04,0.0005),-1.1), vec2(0.1,0.025)));\n  return res;\n}\n\nfloat sdf_d(vec2 uv)\n{\n  float res = _sub(sdf_plaind(vec2(0.9,1.)*uv+vec2(0.05,0.)),sdf_plaind(uv*vec2(0.9,0.7)));\n\n  res = _union(res, sdf_rect(uv-vec2(-0.015,0.089), vec2(0.03,0.018)));\n  res = _union(res, sdf_rect(uv-vec2(-0.015,-0.089), vec2(0.03,0.018)));\n  res = _union(res, sdf_rect(uv-vec2(-0.025,-0.02), vec2(0.02,0.07)));\n  return res;\n}\n\nvec2 myPixel(vec2 uv, vec2 sz)\n{\n  vec2 tmp = uv / sz;\n\n  uv.x = float(int(tmp.x));\n  uv.y = float(int(tmp.y));\n  return uv*sz;\n}\n\nfloat rdrDVDtxt(vec2 uv)\n{\n  float blurMax = 200.;\n  float blur = 0.02;\n  float realBlur = mix(blurMax,0.,blur);\n\n  float res=sdf_v(uv);\n  res = _union(sdf_d(uv-vec2(-0.25,0.)),sdf_v(uv));\n  res = _union(res, sdf_d(uv-vec2(0.17,0.)));\n\n  if (res<0.)\n    return 0.;\n  return sat(1.-(res/blur));\n}\n\n\nvec3 rdrDvd(vec2 uv)\n{\n  float inC = float(length(uv*vec2(1.,1.5))<0.2);\n  float lVid = length(uv*vec2(.9,4.5)*2.+vec2(0.,0.49));\n  float cVid = (1.-sat((lVid-0.2)*5.));\n  float DVDtxt = rdrDVDtxt(uv*2.-vec2(0.,0.02));\n  return (vec3(1.)*inC-cVid*.5)-vec3(DVDtxt);\n}\nconst float PI = 3.141592653927;\nvec3 rdr(vec2 uv)\n{\n  vec2 pos;\n  vec3 col[4];\n\n  col[0] = vec3(0.897,0.31,0.21);\n  col[1] = vec3(0.897,0.31,0.21).xzy;\n  col[2] = vec3(0.897,0.31,0.21).yzx;\n  col[3] = vec3(0.1,0.897,0.21);\n\n  pos.x = asin(sin(iTime))*0.5;\n  bool isUpX = pos.x > asin(sin(iTime+0.01))*0.5;\n  pos.y = asin(sin(2.*iTime+PI))*0.25;\n  bool isUpY = pos.y < asin(sin(2.*iTime+PI+0.01))*0.25;\n  int colIdx = int(isUpX)+(isUpY ? 1 : 2);\n  return rdrDvd(uv-pos)*col[imod(colIdx,4)];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xx;\n  vec2 center = vec2(0.5)*iResolution.xy/iResolution.xx;\n  uv = uv - center;\n  uv = uv *2.;\n  vec3 col;\n  uv = myPixel(uv-vec2(2.), vec2(0.01))+vec2(2.); // minus then plus offset to avoid mod fail around 0\n  col = rdr(uv);\n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}