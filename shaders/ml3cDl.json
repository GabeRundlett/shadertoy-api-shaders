{
    "Shader": {
        "info": {
            "date": "1700696008",
            "description": "A frozen sparkly miniature landscape with soft shadows and a tilt-shift lens effect.\n\n*mouse controls camera*",
            "flags": 32,
            "hasliked": 0,
            "id": "ml3cDl",
            "likes": 29,
            "name": "Sparkly Winter Wonderland",
            "published": 3,
            "tags": [
                "dof",
                "trees",
                "tiltshift",
                "glints",
                "winter",
                "sparkle",
                "glitter"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 390
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  A frozen sparkly miniature landscape with soft shadows and a tilt-shift lens effect.\n//\n//  I've always been fascinated with glittery effects, and I've borrowed glitter code\n//  for previous shaders from wnu's:\n//\n//    sparkle commented               https://www.shadertoy.com/view/Ndlczs\n//\n//  I tried to use it again here, but I didn't get the results I wanted so I decided to\n//  write a glitter function myself.  A design goal was for the glints to be able to span\n//  multiple pixels, to combat aliasing.  The way it works, the world is divided into an\n//  XZ grid. Within each grid cell, N points are selected randomly within the cell by XZ,\n//  and then their Y position is determined by the ground height. These points are rendered\n//  in screen space with randomized normals.\n//\n//  I've used the tilt-shift lens effect before in other shaders like\n//\n//    Dynamic Editable Terrain        https://www.shadertoy.com/view/NlyBWm\n//\n//  I was hoping the sparkles would look even better with some blur on top, and I was\n//  happy with the result.\n//\n//  Otherwise this is a straightforward application of typical SDF rendering with marched\n//  soft shadows.  The trees use a bounding sphere approximation in the SDF until you get\n//  close, to avoid the more costly tree SDF until necessary. This does complicate the\n//  soft shadows, since they can \"see\" this bounding sphere if everything isn't tuned\n//  correctly, but I think I've got it dialed in without very many artifacts.\n//\n//  The trees are randomized using the same basic idea as the sparkles, but there is only\n//  one tree per sector. It's necessary to check multiple sectors when marching, and I\n//  use that trick where I search in the marching direction to reduce the cost.\n//\n//  Buffer A: Main render\n//  Image: Tilt-shift lens blur\n// ---------------------------------------------------------------------------------------\n\n\n// based on gaussian blur from FabriceNeyret2's smart gaussian blur: https://www.shadertoy.com/view/WtKfD3\n\nint           N =  11;                              // target sampling rate\nfloat         w,                                   // filter width\n              z;                                        // LOD MIPmap level to use for integration \n#define init  z = ceil(max(0.,log2(w*R.y/float(N))));   // N/w = res/2^z\n#define R     iResolution.xy\n\nvec4 convol2D(vec2 U) {                                                     \n    vec4  O = vec4(0.0);  \n    float r = float(N-1)/2., g, t=0.;                                       \n    for( int k=0; k<N*N; k++ ) {                                            \n        vec2 P = vec2(k%N,k/N) / r - 1.;                                    \n        t += g = exp(-2.*dot(P,P) );                                        \n        O += g * textureLod(iChannel0, (U+w*P) *R.y/R, z );  \n    }                                                                       \n    return O/t;                                                             \n}      \n\n// From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float centerDepth = textureLod(iChannel0, vec2(.5, .6), 4.).w; // mip sample here softens focal length changes\n    float depth = textureLod(iChannel0, u / R.xy, 4.).w; // mip sample here protects against \"halos\" where different depths meet\n    \n    // Blur based on depth, the farther from the depth of the center pixel, the more blur,\n    // to create a tilt-shift lens effect.\n    w = abs(depth-centerDepth) * .0005;\n    \n    if (w > 0.001)\n    {\n        init\n\n        O = convol2D(u / R.y);\n    }\n    else\n    {\n        O = texture(iChannel0, u/R.xy);\n    }\n    \n    // Simple vignette effect by Ippokratis\n    // https://www.shadertoy.com/view/lsKSWR\n\tvec2 uv = u / R;\n    uv *=  1. - uv.yx;   //vec2(1.0)- uv.yx; -> 1.-u.yx; Thanks FabriceNeyret \n    float vig = uv.x*uv.y * 15.; // multiply with sth for intensity\n    vig = pow(vig, .25); // change pow for modifying the extend of the  vignette\n    O *= vig;\n    \n    O.rgb = pow(ACESFilm(O.rgb), vec3(1./2.2));\n    O.a = 1.;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n//  Main render (outputs RGB, t)\n// ---------------------------------------------------------------------------------------\n\nmat2 rot2(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }\n\nvoid getCamera(out vec3 ro, out vec3 cd)\n{\n    float t = iTime;\n    ro = vec3(0, 1, 1) * 40.;\n    vec2 m = (iMouse.z > 0.) ? 3.*(iMouse.xy - .5 * iResolution.xy) / iResolution.y : vec2(0);\n    ro.xz *= rot2(-m.x);\n    ro.xz *= rot2(t * .15);\n    cd = normalize(-ro);\n    ro.y += sin(t * .2) * 10. - 5. - 10. * m.y;\n    ro.x += sin(t * .05) * 100.;\n    ro.z += cos(t * .05) * 100.;\n}\n\nvec3 getRay(vec3 cd, vec2 u, inout vec3 lf, inout vec3 up)\n{\n    lf = normalize(cross(cd, vec3(0, 1, 0)));\n    up = normalize(cross(lf, cd));\n    return normalize(cd + u.x * lf + u.y * up);\n}\n\nmat4 cameraMat(vec3 lf, vec3 up, vec3 cd, vec3 ro)\n{\n    return mat4(vec4(lf, 0),\n                vec4(up, 0),\n                vec4(cd, 0),\n                vec4(ro, 1));\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( vec3 z )\n{\n    uvec3 x = uvec3(ivec3(z));\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n// simple 3 layer sine field for terrain\nfloat snowHeight(vec2 p)\n{\n    p *= .08;\n    float h = sin(p.x) * sin(p.y) * .4;\n    p *= 1.6;\n    p += 1.;\n    p *= rot2(.5);\n    h += sin(p.x) * sin(p.y) * .3;\n    p *= 1.6;\n    p += 1.;\n    p *= rot2(.5);\n    h += sin(p.x) * sin(p.y) * .2;\n    return h * 15.;\n}\n\n// (approximate) SDF of terrain\nfloat mapSnow(vec3 p) { return p.y - snowHeight(p.xz); }\n\n// calculate terrain normal\nvec3 normSnow(vec3 p)\n{\n    vec2 e = vec2(.01, 0);\n    return normalize(vec3(mapSnow(p + e.xyy) - mapSnow(p - e.xyy),\n                          mapSnow(p + e.yxy) - mapSnow(p - e.yxy),\n                          mapSnow(p + e.yyx) - mapSnow(p - e.yyx)));\n}\n\n// Tree modelled via my Polygon SDF Modelling Tool\n// https://www.shadertoy.com/view/dtBSDw\nconst vec2 VERTS[] = vec2[](vec2(.0, 3.2),\n                            vec2(0, 0),\n                            vec2(2, 0),\n                            vec2(1.16, .84),\n                            vec2(1.44, .84),\n                            vec2(.76, 1.72),\n                            vec2(1.12, 1.72),\n                            vec2(.48, 2.52),\n                            vec2(.76, 2.52));\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdPolygon(int num, vec2 p)\n{\n    p.x = abs(p.x);\n    float d = dot(p-VERTS[0],p-VERTS[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = VERTS[j] - VERTS[i];\n        vec2 w = p - VERTS[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=VERTS[i].y, \n                            p.y <VERTS[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat opRevolution(vec3 p)\n{\n    vec2 q = vec2(length(p.xz), p.y);\n    return sdPolygon(9, q);\n}\n\n// SDF for a single tree, whose sector center is in ct\nfloat sdTree(vec3 p, vec2 ct)\n{\n    // compute tree position within this sector\n    vec3 h = hash3(ct.xyy) - .5;\n    vec2 off = h.xy * 14.;\n    vec3 tp;\n    tp.xz = ct + off;\n    tp.y = snowHeight(tp.xz);\n    float s = (h.z + 1.); // size;\n    \n    p -= tp;\n    p *= s;\n\n    // compute center of bounding sphere\n    vec3 c = p;\n    c.y -= 1.;\n    \n    float d2 = dot(c, c);\n    float RADIUS = 5.; // treat as sphere beyond this radius (optimization)\n    //return (sqrt(d2) - RADIUS) / s; // render as spheres to check bounding sphere size/position\n    float d = (d2 > RADIUS * RADIUS) ? sqrt(d2) - RADIUS * .5 : opRevolution(p);\n    return d / s;\n}\n\nconst float TREE_REPEAT = 20.;\n\n// get the center of the current tree sector\nvec2 treeSectorCenter(vec3 p)\n{\n    return p.xz - mod(p.xz, TREE_REPEAT) + TREE_REPEAT * .5;\n}\n\n// SDF of the entire forest\nfloat mapTrees(vec3 p, vec3 rd)\n{\n    vec2 ct = treeSectorCenter(p);\n    vec2 s = sign(rd.xz); // search extra cells in the direction we're marching\n    \n    float d = 1e6;\n    for(int x = 0; x <= 1; ++x)\n    for(int y = 0; y <= 1; ++y)\n    {\n        float td = sdTree(p, ct + vec2(x, y) * s * TREE_REPEAT);\n        d = min(d, td);\n    }\n    \n    return d;\n}\n\n// material types\nconst float SNOW = 0.;\nconst float TREE = 1.;\nconst float SKY = 2.;\n\n// combined SDF of snow and trees, returning d, material\nvec2 scene(vec3 p, vec3 rd)\n{\n    float d1 = mapSnow(p);\n    float d2 = mapTrees(p, rd);\n    if (d1 < d2)\n        return vec2(d1, SNOW);\n    else\n        return vec2(d2, TREE);\n}\n\n// ray march against entire scene, returning t, material\nvec2 marchScene(inout vec3 p, vec3 rd)\n{\n    float t = 0.;\n    float m = 0.;\n    for (int i = 0; i < 48; ++i)\n    {\n        vec2 d = scene(p, rd);\n        m = d.y;\n        \n        if (abs(d.x) < .01) break;\n        \n        p += d.x * rd;\n        t += d.x;\n    }\n    \n    return vec2(t, m);\n}\n\n// compute normal for trees\nvec3 normTrees(vec3 p)\n{\n    const vec2 e = vec2(.01, 0);\n    vec2 ct = treeSectorCenter(p);\n    \n    return normalize(vec3(sdTree(p + e.xyy, ct) - sdTree(p - e.xyy, ct),\n                          sdTree(p + e.yxy, ct) - sdTree(p - e.yxy, ct),\n                          sdTree(p + e.yyx, ct) - sdTree(p - e.yyx, ct)));\n}\n\n// From iq's Soft Shadow Variation\n// https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<48; i++ )\n    {\n\t\tfloat h = scene(ro + rd*t, rd).x;\n\n        res = min( res, 10.*h/t );\n        t += h;\n        \n        if( res<.0001 || t>tmax ) break;\n    }\n    \n    res = clamp( res, 0., 1. );\n    return res*res*(3.-2.*res);\n}\n\nconst vec3 LDIR = normalize(vec3(-.5, .5, 1));\n\nfloat renderGlint(vec2 id, int i, mat4 m, vec2 u, vec3 n, vec3 rd, float sh)\n{\n    // compute glint position\n    vec2 off = hash3(vec3(id.xy, i)).xy;\n    vec3 sp;\n    sp.xz = id + off;\n    sp.y = snowHeight(sp.xz);\n\n    // glint position in screen space\n    vec3 sc = (m * vec4(sp, 1)).xyz;\n    sc.xy = sc.xy / sc.z;\n    float d = distance(sc.xy, u);\n    float c = smoothstep(3./iResolution.y, 0., d); // glint shape\n\n    vec3 gn = normalize(hash3(vec3(i, id.yx)) - .5 + 1.1 * n); // glint normal\n    vec3 re = reflect(LDIR, gn); // reflected\n    float spec = pow(max(0., dot(rd, re)), 200.); // specular\n    return spec * c * sh * iResolution.y / 10. / sc.z; // dim at lower resolutions to keep similar brightness\n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2 R = iResolution.xy;\n    u = (u - .5 * R) / R.y;\n    \n    vec3 ro, cd, lft, up;\n    getCamera(ro, cd);\n    \n    vec3 rd = getRay(cd, u, lft, up);\n    vec3 p = ro;\n\n    vec2 r = marchScene(p, rd);  \n    O.a = r.x; // t\n    float m = r.y; // material\n\n    vec3 n = m == SNOW ? normSnow(p) : normTrees(p);\n    vec3 c = m == SNOW ? vec3(.5) : vec3(.1, .2, .01);\n    \n    vec3 df = max(0., dot(n, LDIR)) * c;\n    \n    float sh = calcSoftshadow(p + n * .1, LDIR, .5, 35.);\n    O.rgb = df * sh * .95 + vec3(0, 0, .05);\n    \n    if (m == SNOW && sh > 0.)\n    {\n        vec2 id = floor(p.xz);\n        mat4 m = inverse(cameraMat(lft, up, cd, ro));\n\n        const int NUM_GLINTS = 20;\n        for (int i = 0; i < NUM_GLINTS; ++i)\n            O.rgb += renderGlint(id, i, m, u, n, rd, sh);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}