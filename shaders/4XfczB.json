{
    "Shader": {
        "info": {
            "date": "1726304033",
            "description": "CC0: Hextiling tinkering\n  Saw some sweet shaders by shadertoy's byt3m3chanic\n  Tinkered a little bit inspired by it. Thought I should clean up before publishing \n  but bored myself doing so just published in the current state.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "4XfczB",
            "likes": 45,
            "name": "Hextiling tinkering",
            "published": 3,
            "tags": [
                "hextile"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 269
        },
        "renderpass": [
            {
                "code": "// CC0: Hextiling tinkering\n//  Saw some sweet shaders by shadertoy's byt3m3chanic\n//  Tinkered a little bit inspired by it. Thought I should clean up before publishing \n//  but bored myself doing so just published in the current state.\n\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst vec3 lightDir0    = normalize(vec3(1.,1.,-3.));\nconst vec3 lightCol0    = HSV2RGB(vec3(0.58, 0.5, 3E-3))*1.;\nconst vec3 lightDir1    = normalize(vec3(-0.5,1.,-3.));\nconst vec3 lightCol1    = HSV2RGB(vec3(0.58, 0.5, 3E-3))*1.;\nconst vec3 bottomBoxCol = HSV2RGB(vec3(0.55, 0.7, .125))*1.;\nconst vec3 topBoxCol    = HSV2RGB(vec3(0.58, 0.9, 1.));\n\n\nfloat ndot(vec2 a, vec2 b) { return a.x*b.x - a.y*b.y; }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat rhombus(vec2 p, vec2 b)  {\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon(vec2 p, float r) {\n  p = p.yx;\n  const vec3 k = 0.5*vec3(-sqrt(3.0), 1.0, sqrt(4.0/3.0));\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n\nvec4 sphereNormal(vec2 p, float r) {\n  float z2 = (r*r-dot(p, p));\n  float d = length(p)-r;\n  if (z2 > 0.0) {\n    float z = sqrt(z2);\n    vec3 cp = vec3(p, z);\n    vec3 cn = normalize(cp);\n    return vec4(d, cn);\n  }\n  return vec4(d,0.,0.,1.);\n}\n\nfloat ref(inout vec2 p, vec2 r) {\n  float d = dot(p, r);\n  p -= r*min(0.0, d)*2.0;\n  return d < 0.0 ? 0.0 : 1.0;\n}\n\n\nfloat modr3(inout vec2 p) {\n  const vec2 r = normalize(vec2(sqrt(3.), -1.));\n\n  vec2 op = p;\n  float n0 = p.y > 0. ? 1. : 0.;  \n  p.y = abs(p.y);\n  float n1 = ref(p, r);\n\n  if (n1 > 0.) {\n    p = op;\n    return 2.;\n  } else {\n    return n0;\n  }\n\n}\n\nvec3 render0(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n  rd.yz *= ROT(0.3);\n  rd.xz *= ROT(0.0);\n  float srd  = sign(rd.y);\n  float tp   = -(ro.y-6.)/abs(rd.y);\n\n  if (srd < 0.) {\n    col += bottomBoxCol*exp(-0.25*(length((ro + tp*rd).xz)));\n  }\n\n  if (srd > 0.0) {\n    vec3 pos  = ro + tp*rd;\n    vec2 pp = pos.xz;\n    float db = length(pp)-9.;\n    \n    col += topBoxCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += 0.2*topBoxCol*exp(-0.5*max(db, 0.0));\n    col += 0.05*sqrt(topBoxCol)*max(-db, 0.0);\n  }\n\n\n  col += lightCol0/(1.001-dot(lightDir0, rd));\n  col += lightCol1/(1.001-dot(lightDir1, rd));\n  return col; \n}\n\nfloat grid(vec2 p, float f, float mf) {\n  const float steps = 4.0;\n  vec2 gz = vec2(PI/(steps*mf), PI/steps);\n  vec2  n = mod2(p, gz);\n  p.y     *= f;\n  float d = min(abs(p.x), abs(p.y))-0.00125;\n  return d;\n}\n\n\nvec3 toSpherical(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z/r);\n  float ph  = atan(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/noacos/\nmat3 rot(vec3 d, vec3 z) {\n  vec3  v = cross( z, d );\n  float c = dot( z, d );\n  float k = 1.0/(1.0+c);\n\n  return mat3( v.x*v.x*k + c,     v.y*v.x*k - v.z,    v.z*v.x*k + v.y,\n               v.x*v.y*k + v.z,   v.y*v.y*k + c,      v.z*v.y*k - v.x,\n               v.x*v.z*k - v.y,   v.y*v.z*k + v.x,    v.z*v.z*k + c    );\n}\n\n\nvec3 effect(vec2 p, vec2 pp, float aa) {\n  vec2 op = p;\n  vec3 ro = vec3(0., -1, 10.);\n  vec3 p3 = vec3(0.,0., 0.);\n  vec3 rd = normalize(p3-ro);\n  \n  const float arad = 4.;\n  p += arad*sin(vec2(sqrt(0.5),1.)*(TIME+1E3)/arad/8.);\n  \n  vec2 cp0 = p;\n  vec2 hp0 = hextile(cp0);\n  vec2 cp1 = -cp0.yx;\n  float hp1 = modr3(cp1);\n  vec2 cp4 = cp0.yx;\n  float hp4 = modr3(cp4);\n\n  float h0 = hash(hp0+12.3);\n\n  float gsz = 0.1;;\n\n  vec2 cp2 = cp1;\n  cp2 *= ROT(PI/3.);\n  float hp2 = mod1(cp2.y, gsz);\n  vec2 cp3 = cp1;\n  cp3 *= ROT(PI/6.);\n  float hp3 = mod1(cp3.x, gsz);\n  \n\n  float d0 = hexagon(cp0, 0.5-aa*2.);\n  float d1 = abs(cp2.y)-aa;\n  float d2 = abs(cp3.x)-aa;\n  float d3 = abs(cp4.y);\n  float d4 = min(min(d1, d2), -d0);\n  vec2 cp6 = cp1-vec2(0.5/sqrt(3.), 0.0);\n  float d5 = rhombus(cp6, vec2(1./sqrt(3.),1.)*gsz);\n  float d6 = length(cp6*vec2(1.,1./sqrt(3.)));\n  \n  float btime = mix(0.8, 1., h0)*TIME+h0;\n  float bntime = floor(btime);\n  float bftime = fract(btime);\n  float bounce = bftime-0.5;\n  bounce *= bounce;\n\n  float h1 = hash(hp1+12.+h0);\n  float h2 = fract(8667.*h0);\n  float h3 = hash(vec2(hp2, hp3)+h0);\n\n  const vec3 lightDir = normalize(vec3(1.,1.2,1.5)); \n  vec2 cp5 = cp0;  \n  cp5.y -= -0.11-bounce+0.25;\n  vec4 sn_ = sphereNormal(cp5, 0.2);\n  float sd = sn_.x;\n  vec3 wnor = vec3(0.,1.,0.);\n  if (hp1 == 0.0) {\n    wnor = normalize(vec3(-1.,0.,1.));\n  } else if (hp1 == 1.0) {\n    wnor = normalize(vec3(1.,0.,1.));\n  }\n\n  float a = fract(3667.0*h0)*1E2+bntime+sqrt(bftime);\n  vec3 r0 = vec3(1.0, sin(vec2(sqrt(0.5), 1.0)*a));\n  vec3 r1 = vec3(cos(vec2(sqrt(0.5), 1.0)*0.913*a), 1.0);\n  mat3 rot = rot(normalize(r0), normalize(r1));\n\n  vec3 snor = sn_.yzw;\n  vec3 ssp = toSpherical((snor*rot).zxy);\n  float f  = sin(ssp.y); \n  float lf2 = -ceil(log(f)/log(2.0));\n  float mf = pow(2.0, lf2);\n\n  vec3 sref = reflect(rd, snor);\n\n  float sfre = 1.+dot(rd, snor);  \n  sfre *= sfre;\n  vec3 scol = vec3(0.);\n  float sdif= max(dot(lightDir, snor), 0.0);\n  float gd = grid(ssp.yz, f, mf);\n  \n  vec3 ccol = hsv2rgb(vec3(h2, 0.95, 0.25));\n  scol += sdif*sdif*ccol;\n  scol += render0(p3+vec3(0.0,0.0,10.), sref)*sfre;\n  scol += (1E-5*(1.-sfre))*sqrt(ccol)/max(gd*gd, 1E-5);\n  vec3 col = vec3(0.0);\n  vec3 bcol1 = vec3(0.8*h3);\n  col = bcol1*max(dot(wnor, lightDir), 0.);\n  \n  col = mix(col, vec3(0.4), smoothstep(aa, -aa, d4));\n  col = mix(col, vec3(0.7), smoothstep(aa, -aa, -d0));\n\n  col *= mix(1., 0.25, exp(-10.*d3));\n  if (hp1 != 2.) {\n    col += exp(-100.*max(d5, 0.));\n  }\n  col -= 0.033*(length(pp)+0.25);\n  if (h2 > 0.5 ){\n    if (hp1 == 2.) {\n        // As suggested by IQ\n        col *= 1.0 - bounce*4.0/(1.0+d6*d6*100.0);\n        // This hack was a bit too intense.\n        // col *= mix(1., 1.0-bounce*4., smoothstep(bounce, 0., d6));      \n    }\n    col = mix(col, scol, smoothstep(aa, -aa, sd+aa));\n  }\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = sqrt(2.)/RESOLUTION.y;\n\n  const float iz = 2./3.;\n  vec3 col = vec3(0.);\n  col = effect(p*iz, pp, aa*iz);\n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}