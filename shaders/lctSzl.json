{
    "Shader": {
        "info": {
            "date": "1714332115",
            "description": "Light illuminating glass, evokes an ethereal glow and individual luminosity within each block.\nFeel free to move the blocks with the mouse and modify the #defined lines (in Common) to your liking!\nMade w/ ChatGPT + manual additional tweaking by Adri.",
            "flags": 0,
            "hasliked": 0,
            "id": "lctSzl",
            "likes": 7,
            "name": "Glassscape",
            "published": 3,
            "tags": [
                "postprocessing",
                "distort",
                "glass",
                "frosted",
                "chatgpt"
            ],
            "usePreview": 0,
            "username": "adrilyphia",
            "viewed": 280
        },
        "renderpass": [
            {
                "code": "float min1to1(float value) {\n    return value * 2.0 - 1.0;\n}\n\nfloat rnoise(vec2 uv) {\n    float sum = 0.0;\n    vec2 delta = 1.0 / iResolution.xy;\n\n    int numSamples = 5;\n    float blurRadius = 1.0;\n\n    for (int i = -numSamples; i <= numSamples; i++) {\n        for (int j = -numSamples; j <= numSamples; j++) {\n            vec2 offset = vec2(i, j) * delta * blurRadius;\n            sum += fract(sin(dot(uv + offset, vec2(12.9898, 78.233))) * 43758.5453);\n        }\n    }\n\n    return sum / float((2 * numSamples + 1) * (2 * numSamples + 1));\n}\n\nfloat valueNoise(vec2 uv, float posx, float posy) {\n    uv += vec2(-posx, -posy);\n    vec2 integralUV = floor(uv);\n    vec2 fractionalUV = fract(uv);\n\n    float v1 = rnoise(integralUV);\n    float v2 = rnoise(integralUV + vec2(1.0, 0.0));\n    float v3 = rnoise(integralUV + vec2(0.0, 1.0));\n    float v4 = rnoise(integralUV + vec2(1.0, 1.0));\n\n    vec2 smoothFractionalUV = fractionalUV * fractionalUV * (3.0 - 2.0 * fractionalUV);\n\n    float i1 = mix(v1, v2, smoothFractionalUV.x);\n    float i2 = mix(v3, v4, smoothFractionalUV.x);\n\n    return min1to1(mix(i1, i2, smoothFractionalUV.y));\n}\n\nvec3 normalMap(vec3 normal, vec2 uv) {\n    float strength = 1.;\n    float h = strength * valueNoise(uv, 0.0, 0.0);\n    vec3 tangentNormal = normalize(normal + vec3(h, 0.0, 0.0));\n    vec3 binormal = normalize(cross(normal, vec3(0.0, 0.0, 1.0)));\n    vec3 bitangentNormal = cross(tangentNormal, binormal);\n    mat3 TBN = mat3(tangentNormal, bitangentNormal, normal);\n    return normalize(TBN * normal);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float posx = mposx * distance;\n    float posy = mposy * distance;\n    \n    float distortionX = tan(uv.x * -distance + posx) * -roundness\n    + (frost * min1to1((rnoise((uv - frost) * distance\n    + vec2(-posx, -posy * aspect))))\n    + namp * valueNoise((uv * nscale) * distance,\n    posx* nparallax * nscale, posy* nparallax * nscale));\n    \n    float distortionY = tan(uv.y * -distance * aspect + (posy * aspect)) * -roundness\n    + frost * min1to1((rnoise((uv) * distance + vec2(-posx, -posy * aspect))) - roundness\n    + namp * valueNoise((uv * nscale) * distance, posx * nscale, posy * nscale));\n    uv.x += distortionX;\n    uv.y += distortionY;\n    \n    vec3 normal = normalize(vec3(distortionX, distortionY, 1.0));\n    vec3 newNormal = normalMap(normal, uv);\n\n    vec2 uvR = uv + vec2(distortionX * aberration, distortionY * aberration);\n    vec2 uvG = uv;\n    vec2 uvB = uv + vec2(-distortionX * aberration, -distortionY * aberration);\n    vec4 colR = texture(iChannel0, uvR);\n    vec4 colG = texture(iChannel0, uvG);\n    vec4 colB = texture(iChannel0, uvB);\n    vec3 ca = vec3(colR.r, colG.g, colB.b);\n\n    vec2 refractUV = uv;\n    refractUV.xy += namp * valueNoise((uv * nscale) * distance, posx * nscale, posy * nscale);\n    vec4 refractionColor = vec4(ca, refractUV);\n    \n    vec3 lightDir = normalize(vec3(specularx, speculary, specularz));\n    float specularIntensity = specamt;\n    float specularPower = specpower;\n    float specular = pow(max(dot(newNormal, lightDir), 0.0), specularPower);\n    vec3 finalColor = refractionColor.rgb * (1.0 + specularIntensity * specular);\n\n    fragColor = vec4(finalColor, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define roundness 0.05\n#define distance 30.0\n#define frost 0.25\n#define aspect 0.6\n#define namp 0.5\n#define nscale 2.0\n#define nparallax 1.05\n#define aberration 0.125\n\n#define mposx (iMouse.x / iResolution.x)\n#define mposy (iMouse.y / iResolution.y)\n\n#define specularx 0.\n#define speculary .25\n#define specularz 1.\n#define specamt 1.\n#define specpower 72.\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}