{
    "Shader": {
        "info": {
            "date": "1719867097",
            "description": "sources https://www.shadertoy.com/view/DlycWR",
            "flags": 0,
            "hasliked": 0,
            "id": "MXGSRh",
            "likes": 1,
            "name": "fractal #0107",
            "published": 3,
            "tags": [
                "light",
                "color",
                "neon",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 235
        },
        "renderpass": [
            {
                "code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(22,23,51))*.5+.5)\n#define time (iTime/60.0)*140.0\n#define mod01 floor(mod(time * 0.0, 16.0))\n#define mod02 floor(mod(time * 0.0, 8.0))\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n \nfloat gg = 0.0;\n\nmat2 rot(float a)\n{\n    float ca = cos(a);\n    float sa = sin(a);\n    return mat2(ca, sa, -sa, ca);\n}\n\nstruct matter\n{\n  float m;\n    int type;\n    bool reflected;\n};\n   \nfloat box(vec3 p, vec3 s)\n{\np = abs(p) - s;\n    return max(p.x, max(p.y, p.z));\n}\n\nfloat sphere(vec3 p, float s)\n{\n\n    return length(p) - s;\n}\n\nvec3 kifs(vec3 p)\n{\n    float t1 = 0.5 + (time * 0.1 * 0.25);\n    float s = 2.0;\n   \n    for(int i = 0; i < 4; ++i)\n    {\n      p.yz *= rot(t1 + float(i) * 0.1);\n        p.yz = abs(p.xz);\n        p.yz -= s;\n    }\n   \n   \n   \n    return p;\n}\n\nvoid map(inout matter mat, vec3 p)\n{\nfloat mat01, mat02, mat03;\n   \n   \n   \n   \n   \n    vec3 p01 = p, p02 = p, p03 = p, p04 = kifs(p);\n   \n    mat02 = box(p, vec3(0.55 + 0.45 * abs(sin(time * 0.25))));\n    //mat02 = min(mat02, -box(p, vec3(3.5)));\n   \n   \n   \n    if(mod(mod02, 4.0) <= 1.0)\n    mat01 = box(p, vec3(1.05 + 0.10 * mod02));\n\n   \n    float rep01 = 0.45;\n   \n   \n   \n \n   \n   \n   \n    gg += 0.15/(0.11+abs(mat01));\n   \n    mat.m = min(mat01, mat02);\n}\n\nvec3 normals(vec3 p)\n{\n  vec2 uv = vec2(0.01, 0.0);\n   \n    matter m01,m02,m03,m04;\n   \n    map(m01, p);\n    map(m02, p - uv.xyy);\n    map(m03, p - uv.yxy);\n    map(m04, p - uv.yyx);\n   \n    return normalize(m01.m - vec3(m02.m, m03.m,m04.m));\n}\nvoid mainImage(out vec4 O, vec2 C)\n{\n\nvec2 uv = C/iResolution.xy-0.5;\n  \n    uv /= vec2(iResolution.y/iResolution.x, 1.0);\n   \n    vec3 o = vec3(0.0, 0.0, 4.0), t= vec3(0.0);\n    vec3 fr = normalize(t-o);\n    vec3 ri = normalize(cross(vec3(0.0, 1.0, 0.0), fr));\n    vec3 up = normalize(cross(fr, ri));\n    vec3 dir = normalize(fr + uv.x * ri + uv.y * up);\n    vec3 p2 = o + dir * 0.5;\n    \n       \n    matter mat;\n    vec3 col = vec3(0.0);\n    for(int i = 0; i < 150; ++i)\n    {\n        //p.xy *= rot(0.001);\n       \n      map(mat, p2);\n       \n        if(mat.m < 0.01)\n        {\n            if(mat.type == 1)\n            {\n                vec3 n = normals(p2);\n                dir = reflect(dir, -n);\n               \n                mat.m = 0.15;\n                mat.type = 0;\n                mat.reflected = true;\n            }\n          mat.m = 0.1;\n        }\n       \n        if(mod(mod02, 4.0) <= 1.0)\n        col += gg * 0.00030 * vec3(0.0, 0.5, 1.0);\n        if(mod(mod02, 4.0) > 1.0)\n        col += gg * 0.00030 * vec3(1.0, 0.5, 0.0);\n       \n        p2 += dir * mat.m * 0.5;\n    }\n    O=vec4(0);\n    \n    vec4 p;\n    vec3 q,r=iResolution,\n    \n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    \n    for(float i=0.,a,s,e,g=0.;\n        ++i<110.;\n        O.xyz+=mix(vec3(1),H(g*.1),sin(.8))*1./e/8e3\n    )\n    {\n     \n        p.xwz=g*d;\n  \n           p.z+=5.*cos(iTime*1.); \n            p.w+=5.*sin(iTime*1.); \n        a=30.;\n        p=mod(p-a,a*2.)-a;\n        s=2.;\n        for(int i=0;i++<8;){\n        \n            p=.3-abs(p);\n              p.xw*=rot(iTime);\n            p.x>p.w?p=p.zyxw:p;\n            p.z<p.y?p=p.xzyw:p;\n             p.x<p.y?p=p.xwzy:p;\n            s*=e=1.4+sin(iTime*.234)*.1;\n            p.xyz=abs(p.xyz)*e-\n                vec3(\n                    5.+sin(iTime*.3+.5*sin(iTime*.3))*3.,\n                    120,\n                    8.+cos(iTime*.2)*5.\n                 )+col;\n         }\n      \n          g+=e=length(p.yw)/s;\n    }\n     uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    O+= vec4(happy_star(uv, anim) * vec3(0.35,0.2,0.75)*.2, 1.0);\n \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}