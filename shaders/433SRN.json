{
    "Shader": {
        "info": {
            "date": "1724467546",
            "description": "multivariate polynomial varieties",
            "flags": 0,
            "hasliked": 0,
            "id": "433SRN",
            "likes": 1,
            "name": "garden varieties",
            "published": 3,
            "tags": [
                "math"
            ],
            "usePreview": 0,
            "username": "willwombell",
            "viewed": 72
        },
        "renderpass": [
            {
                "code": "\nfloat gaussian(vec2 uv, vec2 ms, float s, float a) {\n    return a*exp(-pow(length(uv - ms), 2.)/(2.*s*s))/sqrt(s);\n}\n\nfloat pnorm(vec3 v, float p) {\n    return pow((pow(v.x, p) + pow(v.y, p) + pow(v.z, p)), 1./p);\n}\n\nfloat pexec(vec3 v, float p) {\n    return pow((pow(v.x, p) * pow(v.y, p) * pow(v.z, p)), 1./p);\n}\n\nfloat brightness(vec3 col) {\n    vec3 cnorm = col - 0.5;\n    return pnorm(cnorm, 1.)/3.;\n}\n\nfloat[136] pwalk(float t, float seed) {\n    float vals[136];\n    float pprod;\n    for (int i=0; i<21; i++) {\n        pprod = float(primes[randint(1./float(i), 136.)] *\n                      primes[randint(float(i), 136.)] *\n                      primes[randint(float(i*i), 136.)] * \n                      primes[randint(float(i*i*i), 136.)]);\n        pprod /= pow(121.,5.);\n        vals[i] = 5.*tan(2.*PI*rand(1.) + t * pprod);\n    }\n    return vals;\n} \n\nfloat mpoly(vec2 xy, float[136] p) {\n    float sum = 0.0;\n    int index = 0;\n    for (int i = 0; i <= 15; i++) {\n        for (int j = 0; j <= 14; j++) {\n            if (i + j <= 5) {\n                sum += safePow(xy.x, float(i)) * safePow(xy.y, float(j)) * p[index++];\n            }\n        }\n    }\n    return sum;\n}\n\n// Fisher-Yates Shuffle Algorithm\nvoid shuffle_primes(inout int arr[136], float seed) {\n    for (int i=0; i < 136; i++) {\n        int j = int(floor(rand(seed + float(i)) * float(i + 1)));\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float scale = 8.;\n    vec2 uv = scale*(fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 ms = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    \n    shuffle_primes(primes, 1.);\n    \n    vec3 freqs = vec3(1., 1.1, 1.11);\n    // Function value\n    \n    float T = iTime + 390.;\n    float p[136] = pwalk(T, 1.);\n    \n    float z = mpoly(uv, p);\n    // Include mouse control\n    float z_ctrl = scaler(ms.y) + scaler(ms.x) * z;\n    \n    if (ORD) {z_ctrl = magval(z_ctrl);}\n    if (INV) {z_ctrl = 1.0 / z_ctrl;}\n    \n    vec3 inv_freq_z = sin(powers(z_ctrl)*freqs);\n    \n    // More sophisticated color mapping\n    vec3 col = vec3(\n        cos(PI * inv_freq_z.x),\n        sinh(PI * inv_freq_z.y),\n        tanh(PI * inv_freq_z.z)\n    );\n    \n    float maussian = gaussian(uv/scale, ms, .005, 10.);\n    col = ushift(col.yzx);\n    \n    col += brightness(col+.3) * sin(vec3(maussian)*vec3(2., 3., 5.));\n    //col *= brightness(col+.3) * cos(vec3(maussian)*vec3(2., 3., 5.));\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PHI 1.618033988\n#define PI 3.141592\n\n#define ushift(x) (0.5 + (0.5 * x))\n#define dshift(x) ((2.0 * x) - 2.0)\n\n#define scaler(x) (exp(5.0 * x))\n#define magval(x) (log(1.+abs(x)))\n\n\n#define POWS5(z) float[5](z, z*z, z*z*z, z*z*z*z, z*z*z*z)\n#define powersplus(x) (vec3(x, x*x, x*x*x))\n#define powers(x) (pow(vec3(x), vec3(1., 1.1, 0.9)+0.1))\n\n#define ORD false\n#define INV true\n\n//int primes[36] = int[36](2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151);\nint primes[136] = int[136](\n        2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, \n        101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, \n        197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, \n        311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, \n        431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, \n        557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, \n        661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769\n    );\n\n\n// Random Float Generator\nfloat rand(float seed) {\n    return fract(sin(seed) * 43758.5453123);\n}\n\nint randint(float seed, float max) {\n    return int(floor(rand(seed) * max));\n}\n\n// Random Vector Generators\nvec2 randVec2(float seed) {\n    return vec2(rand(seed), rand(seed + 1.0));\n}\n\nvec3 randVec3(float seed) {\n    return vec3(rand(seed), rand(seed + 1.0), rand(seed + 2.0));\n}\n\nvec4 randVec4(float seed) {\n    return vec4(rand(seed), rand(seed + 1.0), rand(seed + 2.0), rand(seed + 3.0));\n}\n\n// Random Matrix Generators\nmat2 randMat2(float seed) {\n    return mat2(randVec2(seed), randVec2(seed + 2.0));\n}\n\nmat3 randMat3(float seed) {\n    return mat3(randVec3(seed), randVec3(seed + 3.0), randVec3(seed + 6.0));\n}\n\nmat4 randMat4(float seed) {\n    return mat4(randVec4(seed), randVec4(seed + 4.0), randVec4(seed + 8.0), randVec4(seed + 12.0));\n}\n\nfloat safePow(float base, float exp) {\n    if (base < 0.0) {\n        if (mod(exp, 2.0) == 1.0) {\n            return -pow(-base, exp); // Negative base with odd exponent results in negative\n        } else if (mod(exp, 2.0) == 0.0) {\n            return pow(-base, exp); // Negative base with even exponent results in positive\n        } else {\n            return 0.0; // Non-integer exponent for negative base, result undefined\n        }\n    } else {\n        return pow(base, exp);\n    }\n}\n\nfloat f9(vec2 uv, vec2 ms, float t) {\n    mat3 proj0 = mat3(vec3(-0.9499784895546661, 0.20645608931221683, 0.6142565465487604), vec3(-0.9499784895546661, -0.8693883262941615, -0.3269107404317511), vec3(0.9470988594994225, -0.0833820394550312, -0.8259848705233505));\n    mat3 proj1 = mat3(vec3(0.9380333877603132, 0.4561970999559593, -0.12545435719621062), vec3(0.05904762621234115, -0.6731950124811022, -0.5831928336685313), vec3(-0.1298199086329703, -0.3673589175483792, -0.9093369612830438));\n    proj0 = randMat3(t);\n    proj1 = randMat3(PHI*t);\n    vec3 p0 = proj0 * vec3(uv, 1.0);\n    vec3 p1 = proj1 * vec3(ms, 1.0);\n    \n    vec2 result1 = sin(cos(p0.xy/p0.z)) * cos(sinh(p1.xy/p1.z));\n    vec2 result2 = tan(sin(p1.xy/p1.z)) + sinh(cos(p0.xy/p0.z));\n    \n    return result1.x + result1.y - result2.x + result2.y;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}