{
    "Shader": {
        "info": {
            "date": "1566274677",
            "description": "Combination of two great shaders and a bit of Cthulhu.",
            "flags": 32,
            "hasliked": 0,
            "id": "WtjXzG",
            "likes": 13,
            "name": "Ancient is awoken",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "noise",
                "sdf",
                "volumetric",
                "bumpmapping",
                "city",
                "storm",
                "dust"
            ],
            "usePreview": 0,
            "username": "TimoKinnunen",
            "viewed": 640
        },
        "renderpass": [
            {
                "code": "///////////////////////////////////////////////////////////////////////////\n//\n// Ancient is awoken\n// by Timo Kinnunen 2019\n//\n// Based on TomCity @ https://www.shadertoy.com/view/wt2SDW by tmulgrew\n// Based on Xyptonjtroz @ https://www.shadertoy.com/view/4ts3z2 by nimitz\n//\n///////////////////////////////////////////////////////////////////////////\n\n//#define DEBUG\n\n#define FAR 30.\n\n#define TMIN 0.1\n#define TMAX 170.0\n#define LIMIT 0.0005\n#define STEPS 100\n#define SHADOWSTEPS 30\n#define SCREENDIST 0.5\n\n#define BLOCK\t8.0\n#define HALF\t(BLOCK*0.5)\n\n// Materials\n#define M_GROUND \t1.0\n#define M_BLD \t\t2.0\n#define M_ROAD\t\t3.0\n#define M_PAVEMENT\t4.0\n#define M_DEBUG \t100.0\n#define M_DEBUG2\t101.0\n#define M_DEBUG3\t102.0\n#define M_DEBUG4\t103.0\n\n#ifdef DEBUG\nfloat printNum2(vec2 uv, float value) {\n#define ints int[]\n#define int1 int\n#define float1 float\n\tvec2 origin = vec2(0);\n\tint width = 0;\n\tint digits = 0;\n\tfloat sY = 1.0f;\n\tfloat sX = 1.0f;\n\tif(uv.y < origin.y || uv.y >= 5.0f * sY + origin.y) return 0.0f;\n\tfloat px = (uv.x - origin.x) / (4.0f * sX);\n\tfloat py = (uv.y - origin.y) / (5.0f * sY);\n\tint index = int1(floor(px)) + width - digits;\n\tint ch;\n\tint bits;\n\tif(index < 0) {\n\t\tch = -1;\n\t} else if((bits = floatBitsToInt(value)) < 0 && index == 0) {\n\t\tch = 0x2D;\n\t} else if(index == 0) {\n\t\tch = 0x20;\n\t} else if(bits << 1 == 0) {\n\t\tch = index > 3 ? -1 : ints(bits < 0 ? 0x2D : 0x20, 0x30, 0x2E, 0x30)[index];// [ -]0\\.0\n\t} else if((bits & 0x7FFFFFFF) - 0x7F800000 == 0) {\n\t\tch = index > 8 ? -1 : ints(bits < 0 ? 0x2D : 0x2B, 0x49, 0x6E, 0x66, 0x69, 0x6E, 0x69, 0x74, 0x79)[index];// [+-]Infinity\n\t} else if((bits & 0x7F800000) - 0x7F800000 == 0) {\n\t\tch = index > 2 ? -1 : ints(0x4E, 0x61, 0x4E)[index];// NaN\n\t} else {\n\t\t// Subnormal numbers; exponent is effectively one higher,\n\t\t// but there's no extra normalization bit in the mantissa.\n\t\t// Normal numbers; leave exponent as it is,\n\t\t// but add extra bit to the front of the mantissa.\n\t\t// Bias the exponent. It's actually biased by 127,\n\t\t// but we're treating the mantissa as m.0 rather than 0.m,\n\t\t// so we need to subtract another 23 from it.\n\t\t// Normalize even mantissa to odd.\n\t\tint last1 = (bits | 0xFF800000) & -(bits | 0xFF800000);\n\t\tint numTrail0s =\n\t\t((-(last1 & 0x55555555) >> 31) + 1)\n\t\t| ((-(last1 & 0x33333333) >> 31) + 1) << 1\n\t\t| ((-(last1 & 0x0F0F0F0F) >> 31) + 1) << 2\n\t\t| ((-(last1 & 0x00FF00FF) >> 31) + 1) << 3\n\t\t| ((-(last1 & 0x0000FFFF) >> 31) + 1) << 4;\n\t\tint m = (bits & 0x7FFFFF | (-(bits >> 23 & 0xFF) >> 8 & 0x800000)) >> numTrail0s;\n\t\tint e = (bits >> 23 & 0xFF) - 149 + (-(bits >> 23 & 0xFF) >> 31) + numTrail0s;\n\t\tint[] to10 = ints(1, 10, 100, 1000, 10000, 100000, 1000000, 10000000);\n\t\tint len;\n\t\tfor(len = 1; len < 8; len++) {\n\t\t\tif(m < to10[len]) break;\n\t\t}\n\t\tint align = (5 * (max(0, e) + len)) % 6;\n\t\tint at21 = len > 6 ? m % to10[len - 6] * to10[12 - len] : 0;\n\t\tint at01 = len > 6 ? m / to10[len - 6] : m * to10[6 - len];\n\t\t/* Fill digits array */\n\t\tint[] digits01 =\n\t\tints(\n\t\t\tat01 / to10[align],\n\t\t\tat01 % to10[align] * to10[6 - align] + at21 / to10[align],\n\t\t\tat21 % to10[align] * to10[6 - align],\n\t\t\t/*Q*/0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0/*E*/);\n\t\tint mulBy = e < 0 ? 5 : 2;\n\t\tint divBy = e < 0 ? 2 : 5;\n\t\tint first = align;\n\t\tfor(int i = 0; i < abs(e); i++) {\n\t\t\tint indexN = first / 6;\n\t\t\tif(digits01[indexN] < divBy * to10[5 - first % 6]) {\n\t\t\t\tfirst++;\n\t\t\t}\n\t\t\tfor(int index0 = (len + align + i - 1) / 6; index0 >= indexN; index0--) {\n\t\t\t\tint value0 = digits01[index0];\n\t\t\t\tdigits01[index0 + 1] += (value0 * mulBy) % 10 * 100000;\n\t\t\t\tdigits01[index0] = value0 / divBy;\n\t\t\t}\n\t\t}\n\t\tint mid = max(0, e) + len + align;\n\t\tint beg = index + min(first, mid - 1) - 1;\n\t\tint sep = mid - beg;\n\t\tif(sep < min(-1, e)) {\n\t\t\tch = -1;\n\t\t} else if(sep == 0) {\n\t\t\tch = 0x2E;\n\t\t} else {\n\t\t\tint digitIndex = beg + (sep >> 31);\n\t\t\tch = 0x30 + digits01[digitIndex / 6] / to10[5 - (digitIndex % 6)] % 10;\n\t\t}\n\t}\n\t\n\tint bit = ch < 0 || ch > 127 ? 0 : ints(\n\t\t0x00000, 0x33202, 0x55000, 0x57575, 0x36736, 0x41241, 0x25357, 0x22000, 0x12221, 0x42224, 0x05250, 0x02720, 0x00024, 0x00700, 0x00066, 0x11244,\n\t\t0x75557, 0x26227, 0x61247, 0x61316, 0x13571, 0x74616, 0x34757, 0x71244, 0x75757, 0x75716, 0x02020, 0x02024, 0x12421, 0x07070, 0x42124, 0x61202,\n\t\t0x35543, 0x65755, 0x65656, 0x34443, 0x65556, 0x34643, 0x34644, 0x34553, 0x55755, 0x72227, 0x31153, 0x55655, 0x44447, 0x57755, 0x65555, 0x25552,\n\t\t0x65644, 0x25563, 0x65655, 0x34216, 0x72222, 0x55557, 0x55552, 0x55775, 0x55255, 0x55722, 0x71247, 0x32223, 0x44211, 0x62226, 0x25000, 0x00007,\n\t\t0x21000, 0x02575, 0x04656, 0x00343, 0x01353, 0x03563, 0x12722, 0x03517, 0x04655, 0x20622, 0x20224, 0x04565, 0x06221, 0x00775, 0x00655, 0x00252,\n\t\t0x06564, 0x03531, 0x00344, 0x03636, 0x02723, 0x00553, 0x00552, 0x00577, 0x00525, 0x00524, 0x06246, 0x32423, 0x22222, 0x62126, 0x03600, 0x00000)\n\t\t[ch-0x20] >> (4 * int1(floor(5.0 * py)) + int1(floor(4.0 * fract(-px)))) & 1;\n\treturn float1(bit);\n#undef ints\n#undef int1\n#undef float1\n}\nvec4 boxCount;\n#endif\n// Environment\nconst vec3 light \t= normalize(vec3(0.3, -1., 0.7));\nconst vec3 fog \t\t= vec3(0.9,0.925,1.0);\n\n// Misc\nint frame;\nfloat time;\nfloat prog;\n\nvec2 minDist(vec2 d1, vec2 d2) {\n \treturn d1.x < d2.x ? d1 : d2;   \n}\n\nvec2 carveDist(vec2 d, float c) {\n    return vec2(max(d.x, -c), d.y);\n}\n\nvec2 carveDist(vec2 d1, vec2 d2) {\n \treturn d1.x > -d2.x ? d1 : vec2(-d2.x, d2.y);   \n}\n   \nvec2 pModPolar90(vec2 p) {\n    p = -p.x > p.y ? vec2(-p.x, -p.y) : p;\n    p = abs(p.x) > p.y ? vec2(-p.y, p.x) : p;\n    return p;\n}\nfloat sModPolar90(vec2 p) {\n    return 2.* float(-p.x > p.y) + float(abs(p.x) > abs(p.y));\n}\n\n// Trig\nvec3 rotatex(in vec3 p, float a) {\n\treturn vec3(p.x,\n                cos(a) * p.y - sin(a) * p.z,\n                cos(a) * p.z + sin(a) * p.y);\n}\n\nvec3 rotatey(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.z,\n                p.y,\n                cos(a) * p.z - sin(a) * p.x);\n}\n\n// Shapes\nfloat sphere(in vec3 p, float r) {\n    return length(p) - r;\n}\nfloat box(in vec3 p, in vec3 s) {\n#ifdef DEBUG\n    boxCount.x++;\n#endif\n    vec3 d = abs(p) - s; \n    return max(d.x, max(d.y, d.z));\n}\nfloat box(in vec3 p, in vec3 c1, in vec3 c2) {\n \tvec3 center = (c1+c2)*0.5;\n    vec3 s = (c2-c1)*0.5;\n    return box(p - center, s);\n}\n\n// Grid access\nGridCell read(int x, int y, int z) {return read(iChannel0,x,y,z);}\n\n// Scene\n#define WALL (HALF-0.1)\nconst vec3 wallC1 = vec3(-HALF,-HALF,HALF-0.7);\nconst vec3 wallC2 = vec3( HALF, HALF,HALF-0.2);\n\nvec2 mainWallDist(vec3 p) {\n\treturn vec2(box(p, wallC1, wallC2), M_BLD);\n}\nvec2 wallDist(in vec3 p) {\n    \n    // Main wall\n\tvec2 d = mainWallDist(p);\n    \n    // Window hole\n    d = carveDist(d, box(p, vec3(1.5, 1.5, HALF)));\n    \n    // Sill\n    d = minDist(d, vec2(box(p, vec3(-1.6, -1.7, HALF-0.4), vec3(1.6, -1.5, HALF)), M_BLD));\n    \n    return d;\n}\n\nvec2 buildingDist(in vec3 p, int subType, int y) {\n    // Ceiling/roof\n \tvec2 d = vec2(box(p, vec3(-HALF,HALF-0.5,-HALF), vec3(HALF,HALF,HALF)), M_BLD);  \n    \n    // Floor if at ground level\n    if (y == 0)\n        d.x = min(d.x, box(p, vec3(-HALF,-HALF,-HALF), vec3(HALF,-HALF + 0.3,HALF)));\n    \n    // Walls\n    int cid = int(sModPolar90(p.xz));\n    p.xz = pModPolar90(p.xz);\n    bvec3 cids = bvec3((ivec3(subType)>>((ivec3(3,0,1)+cid)%4))&1);\n    if(cids.x) d = minDist(d, mainWallDist(vec3(p.z,p.y,-p.x)));\n    if(cids.y) d = minDist(d, wallDist(p));\n    if(cids.z) d = minDist(d, mainWallDist(vec3(-p.z,p.y,p.x)));\n\n    return d;\n}\n\n#define ROAD (HALF*0.6)\n#define HALFP (HALF+0.1)\n\nconst vec3 roadC1 = vec3(-ROAD,-HALFP,-HALFP);\nconst vec3 roadC2 = vec3(ROAD,HALFP,HALFP);\n\nvec2 roadDist(in vec3 p, int subType, in vec3 worldp) {\n    \n    // Road, extruded to block height, so we can carve it from the pavement\n\n    // Regularize towards north\n    int cid = int(sModPolar90(p.xz));\n    p.xz = pModPolar90(p.xz);\n    bvec3 cids = bvec3((ivec3(subType)>>((ivec3(3,0,1)+cid)%4))&1);\n    float d0 = box(p,                   roadC1, roadC2); // road and we go north...\n    float d3 = box(vec3( p.z,p.y,-p.x), roadC1, roadC2); // ... or we go east\n    float d1 = box(vec3(-p.z,p.y, p.x), roadC1, roadC2); // ... or west\n    \n    float rd = cids.y ? d0 : d3; // check north\n    rd = min(rd, cids.x ? d3 : d1); // west\n    rd = min(rd, cids.z ? d1 : d3); // east\n\n    // Pavement\n    float pd = box(p, vec3(-HALF,-HALF,-HALF), vec3(HALF,-HALF+0.3,HALF));\n    \n    // Carve road from pavement\n    pd = max(pd, -rd);\n    \n    // Carve road down to 0.1\n    rd = max(rd, p.y - (-HALF+0.1));\n    \n    // Combine\n    return rd < pd ? vec2(rd, M_ROAD) : vec2(pd, M_PAVEMENT);\n}\nvec2 blockDist(in vec3 p, in GridCell cell, in vec3 worldp, int y) {\n    \n    if(cell.type==T_BLD) {\n        // Originally this switch called buildingDist explicitly on each case statement.\n        // This caused the shader to take 11s to compile (inlining presumably).\n        // Using this method the shader takes ~2s to compile.\n        return buildingDist(p, cell.sub, y);\n    } else if(cell.type==T_ROAD) {\n        return roadDist(p, cell.sub, worldp);\n    }\n    return vec2(HALF, 0);\n}\n\nvec3 mat(float m, vec3 p, vec3 n) {\n    vec3 an = abs(n);\n    vec2 uv = an.x > an.y && an.x > an.z ? p.yz\n        : an.y > an.z                \t ? p.xz\n        :                                  p.xy;\n    if (m == M_BLD) {\n        return (pow(texture(iChannel3, uv * 0.25,-1.).xyz *\n                    texture(iChannel3, uv * 0.0625,-4.).xyz,\n                    vec3(4)\n                   )*16.\n        ) * 0.4 + 0.6;        \n    }\n    if (m == M_ROAD) {\n        return vec3(0.15) * texture(iChannel2, uv*0.125,-2.).xyz;\n    }\n    if (m == M_PAVEMENT) {\n        return texture(iChannel3, uv * 0.25,-2.).xyz * .6;\n    }\n    //if (m == M_GROUND) {\n        return vec3(.46,.57,.46) * texture(iChannel1, uv*0.5).x;\n    //}\n    //return vec3(0.2);\n}\nfloat luminance(vec3 color) {\nreturn dot(vec3(.3,.5,.2),color);\n}\nfloat matluma(float m, vec3 p, vec3 n) {\n    return luminance(mat(m,p,n));\n}\nvec3 matbump(float m, vec3 p, vec3 n, float ds) {\n    vec2 e = vec2(0.005+0.0005*ds,0);\n    float n0 = matluma(m,p,n);\n    vec3 d = vec3(matluma(m,p+e.xyy,n)-n0, matluma(m,p+e.yxy,n)-n0, matluma(m,p+e.yyx,n)-n0)/e.x;\n    n = normalize(n-d*0.5*inversesqrt(ds));\n    return n;\n}\n\n// Rendering\nfloat erosionStart() {\n    float h = float(LIFESPAN-1-(iFrame % LIFESPAN)) / 60.0;\n    h *= 0.7;\n    h = pow(max(h,0.01),2.0);\n    return h;\n}\nfloat erosion(vec3 p) {\n    vec2 uv = mod(p.xz, vec2(float(GRID_W),float(GRID_L))*BLOCK);\n    float h = 0.0;\n    h += texture(iChannel1, uv * 0.0050).x * 3.0;\n    h += texture(iChannel1, uv * 0.0010).x * 10.0;\n    h += texture(iChannel1, uv * 0.0002).x * 20.0;\n    return h;\n}\nvec3 dist(in vec3 p) {\n    if (p.y > float(GRID_H)*BLOCK + 1.0)\n        return vec2(p.y - float(GRID_H)*BLOCK, 0).xyx;\n    \n    float h = erosionStart();\n    if (h < float(GRID_H) * BLOCK + 33.0) {\n        h = max(h - erosion(p), -0.2);\n        p.y += smoothstep(1.0*BLOCK,0.0,abs(h-p.y))*BLOCK*0.5;\n    }\n\tvec3 b = p/vec3(BLOCK);\n    vec3 b0 = floor(b - vec3(0.5));\n    vec3 b1 = floor(b + vec3(0.5));\n \tvec2 d = vec2(p.y,M_GROUND);\n    for (int x = int(b0.x); x <= int(b1.x); x++) {\n        for (int y = int(b0.y); y <= int(b1.y); y++) {\n            for (int z = int(b0.z); z <= int(b1.z); z++) {\n                GridCell cell = read(x,y,z);\n                vec3 blockp = p - (vec3(float(x),float(y),float(z)) + vec3(0.5)) * vec3(BLOCK);\n                //blockp = orientPos(blockp, cell.orient);\n                d = minDist(d, blockDist(blockp, cell, p, y));\n                //if (y == 0) \n                //    d = minDist(d, vec2(sphere(blockp-vec3(0,-HALF+0.5,0),0.5), M_DEBUG));\n            }\n        }\n    }\n    \n    //if (d.y == M_BLD) {\n        if (h < float(GRID_H) * BLOCK + 33.0) {\n            d = carveDist(d, h-p.y);\n        }\n    //}\n    \n    return d.xyx;\n}\n\nvec3 raycast(in vec3 from, in vec3 dir) {\n    float t = TMIN;\n    vec3 d;\n    for (int i = 0; i < STEPS && t < TMAX; i++) {\n        vec3 p = from + dir * t;\n        d = dist(p);\n        if (abs(d.x) <= LIMIT * t) {\n            d.x = t;\n            return d;\n        }\n        t += d.x;\n    }   \n    if (t < TMAX) {\n        d.x = t;\n        return d;\n    }    \n    \n    return vec2(1000.0, 0.0).xyx;\n}\n\nfloat shadow(in vec3 from, in vec3 dir, float k) {\n    float res = 1.0;\n    float t = 0.2;    \n    for (int i = 0; i < SHADOWSTEPS && t < TMAX; i++) {\n     \tvec3 p = from + dir * t;\n        float d = dist(p).x;\n        if (d <= 0.0)\n            return 0.0;\n        res = min(res, k*d/t);\n        t += d;    \n    }\n    \n    return res;\n}\nvec3 normal(in vec3 p, float t) {    \n    vec2 s = vec2(0.1 / t, 0);\n    s=vec2(t/TMAX*0.125,0);\n    float d = dist(p).x;\t\t\t// Need original distance to compare it to\n    vec3 r = vec3(\n        dist(p + s.xyy).x - d,\n        dist(p + s.yxy).x - d,\n        dist(p + s.yyx).x - d);    \n    return normalize(r);\n}\n\nfloat shading(in vec3 e, in vec3 n, float diffuse, float specular, float shiny) {\n    float d = dot(n, -light) * diffuse;\n    vec3 h = -(normalize(e) + light) / 2.0;\n    float s = pow(dot(n, h), shiny) * specular;\n    return max(d + s, 0.0);\n}\nfloat map(vec3 p) {return dist(p).x;}\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n\nfloat triNoise3d(in vec3 p, in float spd)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+time*spd);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14*(TMAX/FAR);\n\t}\n\treturn rz;\n}\n//IQ - https://iquilezles.org/articles/raymarchingdf\nfloat ambientOcclusion(vec3 p, vec3 n) {\n    float ra = 0., w = 1., d = 0.;\n    for (float i = 1.; i < 8.; i += 1.){\n        d = i / 5.;\n        ra += w * (d - map(p + n * d));\n        w *= .5;\n    }\n    return 1. - clamp(ra, 0., 1.);\n}\n//IQ - https://iquilezles.org/articles/functions\nfloat sinc(float x, float k) {\n    float a = radians(180.)*(k*x-1.0);\n    return sin(a)/a;\n}\nfloat fogmap(in vec3 p, in float d)\n{\n    p.x += time*1.5;\n    p.z += sin(p.x*.5);\n\n    float h = 1.-prog;\n    h = smoothstep(0.,1.,h);\n    h *= 0.5;\n    h *= float(LIFESPAN)/60.0;\n    h *= 0.7;\n    h = pow(max(h,0.01),2.0);\n    h -= 3.*BLOCK;\n    \n    return triNoise3d((p-vec3(0,h,0))*2.2/(d+8.*(TMAX/FAR)),0.2*0.0)*smoothstep(7.5*BLOCK,0.5*BLOCK,abs(h-p.y));\n}\n\nvec3 foggy(in vec3 col, in vec3 ro, in vec3 rd, in float mt)\n{\n    float d = .5*(TMAX/FAR);\n    for(int i=0; i<7; i++)\n    {\n        vec3  pos = ro + rd*d;\n        float rz = fogmap(pos, d);\n\t\tfloat grd = clamp((rz - fogmap(pos+(.8-float(i)*0.1)*(TMAX/FAR),d))*3., 0.1, 1. );\n        vec3 col2 = (vec3(.1,0.8,.5)*.5 + .5*vec3(.5, .8, 1.)*(1.7-grd))*0.55;\n        col = mix(col,col2,rz*smoothstep(d-0.4*(TMAX/FAR),d*1.75+2.*(TMAX/FAR),mt));\n        d *= 1.8;\n        if (d>mt)break;\n    }\n    return col;\n}\nfloat bnoise(vec3 p) {\n    float n = sin(triNoise3d(p*.3,0.0)*11.)*0.6+0.4;\n    n += sin(triNoise3d(p*1.,0.05*0.0)*40.)*0.1+0.9;\n    return (n*n)*0.003;\n}\n\nvec3 bump(vec3 p, vec3 n, float ds) {\n    vec2 e = vec2(0.001+0.002*ds*ds,0);\n    float n0 = bnoise(p);\n    vec3 d = vec3(bnoise(p+e.xyy)-n0, bnoise(p+e.yxy)-n0, bnoise(p+e.yyx)-n0)/e.x;\n    n = normalize(n-d*10.*inversesqrt(ds));\n    return n;\n}\nfloat curv(vec3 p, float w) {\n    vec2 e = vec2(-1., 1.)*w;   \n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return .125/(e.x*e.x) *(t1 + t2 + t3 + t4 - 4. * map(p));\n}\nfloat flip() {\n    const float to = 0.16;\n    const float k = 10.;\n    const float s = 10.0;\n    float x = prog;\n    float am = sinc(6.*s*(x-to),k)+exp2(-10.*s*(x-to))*0.125-0.0625;\n    am = smoothstep(0.005,-0.005,am);\n    return am;\n}\nvec3 renderPixel(in vec3 from, in vec3 dir) {\n#ifdef DEBUG\n    boxCount.y=-boxCount.x;\n#endif    \n    // Trace ray\n    vec3 h = raycast(from, dir);\n#ifdef DEBUG\n    boxCount.y+=boxCount.x;\n#endif    \n    vec3 col;\n    vec3 ro = from;\n    vec3 rd = dir;\n    vec3 ligt = -light;\n    vec3 ligt2 = normalize( ligt * vec3(1,-0.5,1) );\n    float t = h.x;\n    float mode34 = smoothstep(\n        mix(1.0,-0.1,clamp(prog*2.6-0.1,0.,1.)),\n        mix(1.1,-0.0,clamp(prog*2.6-0.1,0.,1.)),\n        0.5+0.5*dot(rd,ligt));\n\n    float mode24 = flip();\n    float mode1 = (1.-mode24)*(1.-mode34);\n    float mode2 = (   mode24)*(1.-mode34)*smoothstep(0.22,0.18,prog);\n    float mode3 = (1.-mode24)*(   mode34);\n    float mode4 = (   mode24)*(   mode34);\n    //vec3 fogb = mix(vec3(.5, .4,.4), vec3(1.,.9,.8), min(pow(max(dot(rd,ligt), 0.0), 1.5)*1.25, 1.0));\n    vec3 fogb = mix(vec3(.7,.8,.8)*0.3, vec3(.9,1.,.77)*.95, pow(dot(rd,ligt2)+1.2, 2.5)*.25);\n    fogb *= clamp(rd.y*.5+.6, 0., 1.);\n//        vec3 col = fogb;\n    vec3 foga = mix(fog,pow(fog,vec3(8.))+ min(1.0-abs(dir.y)*0.5, 1.),mode2);\n    if (t < TMAX && h.z < 1.) {\n \n#ifdef DEBUG\n        boxCount.z=-boxCount.x;\n#endif    \n        vec3 p = ro + t * rd;\n        vec3 n = normal(p, t);\n     \tvec3 col1 = mat(h.y, p, n);\n        float erodeH = erosionStart()-erosion(p);\n        //float i = shading(dir, n, 0.6, 0.5, 8.0);\n        //if (i > 0.0)\n        //    i *= shadow(p, -light, 64.0);\n        //i = clamp(i + 0.3, 0.0, 1.0);\n        //col1 *= i;\n        //col1 = mix(col1, fog, pow(h.x/TMAX,3.0));\n\n        //col1 = mix(col1,vec3(1,0,1),clamp(mod(p.y,BLOCK)-0.,0.,1.));\n        vec3 pos = p;\n        float creep = BLOCK*(0.5+0.5*sin(bnoise(0.25*pos*(FAR/TMAX))*900.));\n        float am1 = smoothstep(-1.0*creep,-0.5*creep,p.y-erodeH+0.0*BLOCK);\n        float am2 = smoothstep(-3.0*creep,-2.5*creep,p.y-erodeH+1.0*BLOCK);\n        float am3 = smoothstep(-4.0*creep,-3.5*creep,p.y-erodeH+2.0*BLOCK);\n        float bno = bnoise(pos*(FAR/TMAX))*900.;\n        float vein = sin(bno);\n        float splatFade = clamp((t/TMAX-0.125)*1.5,0.,1.)*step(5.,bno);\n        col1 = mix(col1,vec3(1,0,0),//vec3(bno<5.,splatFade<=0.,bno>5.),\n                   smoothstep(0.8,0.9,vein-splatFade)*mode24);\n        float d = t;\n        vec3 nor = normalize(mix(matbump(h.y,p,n,d),bump(p,n,d),am3));\n        float ao = pow(ambientOcclusion(p, nor),1.0+3.0*mode2);\n        float crv = 2.0-1.9*clamp(abs(dot( nor, ligt )),0.,1.); // clamp(curv(pos, .4),.0,10.);\n        float shd = ao*shadow(p, ligt, 64.0);//shadow(pos,ligt,0.1,3.);\n        float dif = (1.0+1.5*mode2)*clamp( dot( nor, ligt ), 0.0, 1.0 )*shd;\n        float spe = (1.0+9.0*mode2+9.0*am3)*\n            pow(clamp( dot( reflect(rd,nor), ligt ), 0.0, 1.0 ),\n                50.-30.*mode2-45.*am3)*shd;\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 1.5 );\n        vec3 brdf = ao*vec3(0.10,0.11,0.13) + 1.5*dif*mix(vec3(1,0.9,0.7),vec3(0.7),mode2);\n        vec3 col2 = mix(vec3(0.12,0.14,0.3),vec3(0.25,0.2,0.3),pos.y*.5*(FAR/TMAX))*shd;\n        col1 = mix(col1,0.5*col1+col2,am3);\n        col2 *= mix(1.0,vein*0.2+0.8,am1);\n        col1 = mix(col1,col1*col2,am2);\n        col2 = mix(col1,col1*col2,am1);\n        col = col2*(brdf + spe*0.5) + fre*vec3(0.21,0.3,0.06)*crv*am3;\n\n#ifdef DEBUG\n        boxCount.z+=boxCount.x;\n#endif    \n        \n    } else {\n        col = vec3(0,.2,.4);\n        if (dir.y > .01) {\n            vec2 uv = dir.xz * (5.0 / dir.y);\n        \tfloat cloud = texture(iChannel1, uv * 0.005).x*4. + \n                \t\t  texture(iChannel1, uv * 0.010).x*2. +\n                \t\t  texture(iChannel1, uv * 0.020).x*1.;\n            cloud = clamp(cloud*.13 - .4,0.,1.);\n            col = mix(col,col+cloud,cloud)*4.;\n        }\n        \n        foga = mix(foga, foga+pow(col,vec3(2.+6.*mode2))*(1.0+7.0*mode2), max(dir.y-.01, 0.));\n        col = mix(foga,fogb,mode34);\n        t=-ro.y/rd.y;\n        if(t<0.||t>TMAX) t=TMAX;\n    }\n    \n    //ordinary distance fog first\n    float distFade = mix(pow(t/TMAX,3.0),smoothstep((FAR-7.)*(TMAX/FAR),FAR*(TMAX/FAR),t),mode34);\n    col = mix(col, mix(foga,fogb,mode34), distFade);\n    \n    //then volumetric fog\n    //col = mix(foggy(col, ro, rd, rz), col, distFade);\n    col = mix(col, foggy(col, ro, rd, t),mode34);\n    \n\n    // Fade in/out\n    float fade = float(abs(((iFrame+LIFESPAN/2) % LIFESPAN) - LIFESPAN/2)) * 0.008;\n    fade = clamp(fade,0.0,1.0);    \n\tcol *= fade;\n    \n    // post\n    col = pow(col,vec3(0.8));\n\n    // custom vignette\n    vec2 p = (2.*gl_FragCoord.xy-iResolution.xy)/iResolution.y;\n    float vignette = mix(\n        length(vec2(0.56,1)*p),\n        0.75*length(vec2(-0.4,0.2)+abs(vec2(0.2*sign(0.5-gl_FragCoord.x/iResolution.x),0.1)+p)),\n        mode34);\n\n    col *= 1.-smoothstep(0.6,1.8,vignette+0.6*prog);\n\n    return col;\n}\n\n// Main loop\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n#ifdef DEBUG\n    boxCount=vec4(0);\n#endif    \n    frame = iFrame % LIFESPAN;\n    time = float(frame)/60.;\n    prog = float(frame)/float(LIFESPAN-1);\n\n    int iteration = iFrame/LIFESPAN;\n    \n    // Move camera down alley\n    vec2 s = fragCoord.xy - iResolution.xy / 2.0;\n    vec3 dir = normalize(vec3(s / (SCREENDIST * iResolution.x), 1));\n    dir = rotatey(dir, time * float(((iteration&2)-1)*(1+(iteration&2)))*0.06*1.0+.0);\n    float l = 27.0-25.0*cos(float(iteration));\n    l += floor((l-1.)/(BLOCK-2.))*2.;\n    vec3 from = vec3(HALF, l, time * 10.0* 1.0);        \n    \n    // Render\n    vec3 col = renderPixel(from, dir);\n\n\tfragColor = vec4( col, 1.0 );\n\n#ifdef DEBUG\n    boxCount.w=boxCount.x-boxCount.y-boxCount.z;\n    if(iMouse.z>10.5){\n        vec2 mou = clamp((iMouse.xy-20.)/(iResolution.xy-40.),0.,1.);\n        mou=max(vec2(1),floor(50.*mou)*100.);\n        fragColor = clamp(step(mou.x,boxCount)*(1.-(boxCount.yzwx)/boxCount.x),0.,1.);\n        float line = floor(fragCoord.y*0.5/11.);\n\n        if(line<2.) {\n    \n            float value = line==0.?mou.x:mou.y;\n            fragColor+=printNum2(-1.+vec2(fragCoord.x*0.5,mod(fragCoord.y*0.5,11.)),value);\n        }\n    } else if(iMouse.z>0.5){\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord),0) * 20.0;\n    }\n#endif\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265\n\n#define BLD_GRID_W\t\t8\n#define BLD_GRID_H\t\t8\n#define BLD_GRID_MAX\t2\n#define BLD_GRID_SQUARE\t4\n#define BLD_MAX_TALL\t5\n\n#define GRID_W\t\t\t(BLD_GRID_W*BLD_GRID_SQUARE)\n#define GRID_L\t\t\t(BLD_GRID_H*BLD_GRID_SQUARE)\n#define GRID_H\t\t\tBLD_MAX_TALL\n\n#define T_BLD\t\t\t1\n#define T_EMPTY\t\t\t2\n#define T_ROAD\t\t\t10\n\n// # frames before regenerating\n#define LIFESPAN\t\t2000\n#define iTime donotuse\n\nint idot(ivec4 a, ivec4 b) {\n    return a.x*b.x+a.y*b.y+a.z*b.z+a.w*b.w;\n}\n\nstruct GridCell {\n \tint type;\t\t// T_xxx\n//    int orient;\t\t// 90 degree clockwise rotation\n    int sub;\t\t// S_xxx\n};\n\nGridCell makeCell(int type, int sub/*, int orient*/) {\n \tGridCell c;\n    c.type = type;\n    c.sub = sub;\n//    c.orient = orient;\n    return c;\n}\n\nGridCell makeCell(int type) { return makeCell(type, 0/*, 0*/); }\n\n// Grid access\nGridCell read(sampler2D smp, int x, int y, int z) {    \n    if (y < 0 || y >= GRID_H) \n        return makeCell(0);\n    x = x % GRID_W;\n    z = z % GRID_L;\n    if (x < 0) x += GRID_W;\n    if (z < 0) z += GRID_L;\n    ivec2 uv = ivec2(x + y * GRID_W, z + BLD_GRID_H);\n    //ivec3 frag = ivec3(texelFetch(smp, uv, 0).xyz+0.5);\n    ivec2 frag = ivec2(texelFetch(smp, uv, 0).xy+0.5);\n    return makeCell(frag.x,frag.y/*,frag.z*/);\n}\nvec4 encodeCell(GridCell c) {\n \treturn vec4(c.type, c.sub, 0/*c.orient*/, 0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "struct Building {\n\tint x, y;\n    int w, h;\n    int tall;\n};\n\nfloat rand(vec2 co, float n){\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))+float(iFrame)+n) * 43758.5453);\n}\n\nbool getBldGridCoord(in vec2 fragCoord, out int x, out int y, out int n) {\n\tx = int(fragCoord.x);\n    y = int(fragCoord.y);\n    n = x % BLD_GRID_MAX;\n    x = x / BLD_GRID_MAX;    \n    return x < BLD_GRID_W && y < BLD_GRID_H;\n}\n\nBuilding randomBuilding(vec2 co) {\n\tint x1 = int(rand(co, 1.0) * float(BLD_GRID_SQUARE));\n\tint x2 = int(rand(co, 2.0) * float(BLD_GRID_SQUARE));\n\tint y1 = int(rand(co, 3.0) * float(BLD_GRID_SQUARE));\n\tint y2 = int(rand(co, 4.0) * float(BLD_GRID_SQUARE));\n    Building b;\n    b.x = min(x1, x2);\n    b.y = min(y1, y2);\n    b.w = max(x1, x2) - b.x + 1;\n    b.h = max(y1, y2) - b.y + 1;\n    b.tall = int(rand(co, 5.0) * float(BLD_MAX_TALL)) + 1;\n    return b;    \n}\n\nvec4 encodeBuilding(in Building building) {\n \tint r = building.x | (building.w << 4);\n    int g = building.y | (building.h << 4);\n    int b = building.tall;\n    return vec4(vec3(r,g,b)/255.0,1);\n}\n\nBuilding readBuilding(int x, int y, int n) {\n    ivec2 uv = ivec2(x * BLD_GRID_MAX + n, y);\n    vec4 frag = texelFetch(iChannel0, uv,0);\n    int r = int(frag.r * 255.0);\n    int g = int(frag.g * 255.0);\n    int b = int(frag.b * 255.0);\n    Building building;    \n    building.x = r & 0x0f;\n    building.y = g & 0x0f;\n    building.w = r >> 4;\n    building.h = g >> 4;\n    building.tall = b;\n    return building;\n}\n\nbool getGridCoord(in vec2 fragCoord, out int x, out int y, out int z) {\n \tx = int(fragCoord.x);\n    z = int(fragCoord.y) - BLD_GRID_H;\n    y = x / GRID_W;\n    x = x % GRID_W;\n    return x >= 0 && x < GRID_W && y >= 0 && y < GRID_H && z >= 0 && z < GRID_L;\n}\nGridCell getBuildingCell(bool n, bool s, bool e, bool w) {\n    return makeCell(T_BLD, idot(1-ivec4(n,e,s,w),ivec4(1,2,4,8))/*, 0*/);\n}\nGridCell getRoadCell(bool n, bool s, bool e, bool w) {\n    return makeCell(T_ROAD, idot(ivec4(n,e,s,w),ivec4(1,2,4,8))/*, 0*/);\n}\n\nGridCell read(int x, int y, int z) {return read(iChannel0,x,y,z);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Default to existing colour\n\tfragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    int frame = iFrame % LIFESPAN;\n    \n    if (frame == 0) {\n        // Clear buffer\n    \tfragColor = vec4(0);   \n    }\n    else if (frame == 1) {\n     \t// Seed initial frame     \n        int x, y, n;\n        if (getBldGridCoord(fragCoord, x, y, n)) {\n            if (rand(fragCoord, 0.0) < 0.75) {\n\t\t       \tBuilding building = randomBuilding(fragCoord);\n\t            fragColor = encodeBuilding(building);            \n            }\n        }\n    }\n    else if (frame == 2) {\n        int x, y, z;\n        if (getGridCoord(fragCoord, x, y, z)) {\n            if ((x % (BLD_GRID_SQUARE*2)) == 0 ||\n                (z % (BLD_GRID_SQUARE*2)) == 0)\n            {\n                fragColor = y == 0 || y == 1 && (z % (BLD_GRID_SQUARE*4)) == 0 ? encodeCell(makeCell(T_ROAD)) : vec4(0);\n                return;\n            }                \n            \n     \t\t// Find building grid\n            bool foundBuilding = false;\n        \tint bgx = x / BLD_GRID_SQUARE;\n        \tint bgy = z / BLD_GRID_SQUARE;\n            for (int i = 0; i < BLD_GRID_MAX; i++) {\n            \tBuilding building = readBuilding(bgx, bgy, i);\n                building.x += bgx * BLD_GRID_SQUARE;\n                building.y += bgy * BLD_GRID_SQUARE;\n                foundBuilding = foundBuilding || building.tall > 0;\n                if (building.x <= x && x < building.x + building.w &&\n                    building.y <= z && z < building.y + building.h &&\n                    y < building.tall) {\n                    \n                    // Calculate subtype and orientation\n                    bool n = z+1 < building.y + building.h;\n                    bool s = building.y <= z-1;\n                    bool e = x+1 < building.x + building.w;\n                    bool w = building.x <= x-1;\n                    GridCell cell = getBuildingCell(n,s,e,w);\n                    \n                 \tfragColor = encodeCell(cell);   \n                }                \n            }\n            \n            if (!foundBuilding && y == 0)\n                fragColor = encodeCell(makeCell(T_EMPTY));\n        }        \n    }\n    else if (frame < 400) {\n    \t// Flood fill road\n        int x, y, z;\n        if (getGridCoord(fragCoord, x, y, z)) {\n            int type = read(x, y, z).type;\n            if (type == 0 && y == 0) {\n            \n                int turn = (x%2) + (z%2)*2;\n                if ((iFrame%4) != turn || rand(fragCoord, 2.0) > 0.2) return;\n\n                // Bitmask of neighbouring grid squares\n                int mask = 0;\n                int bit = 1;\n                for (int oz = -1; oz <=1; oz++) {\n                    for (int ox = -1; ox <= 1; ox++) {\n                        if (ox != 0 || oz != 0) {\n                            if (read(x+ox, y, z+oz).type == T_ROAD)\n                                mask |= bit;\n                            bit <<= 1;\n                        }\n                    }\n                }\n\n                if ((mask & 0x5a) == 0) return;\t\t\t// No neighbouring road\n                if ((mask & 0x0b) == 0x0b) return;\t\t// Would make 2x2 square\n                if ((mask & 0x16) == 0x16) return;\t\t// \"\n                if ((mask & 0x68) == 0x68) return;\t\t// \"\n                if ((mask & 0xd0) == 0xd0) return;\t\t// \"\n\n                fragColor = encodeCell(makeCell(T_ROAD));            \n            }\n            else if (type == T_ROAD) {\n                \n             \t// Calculate sub type and orientation based on which neighbours are present\n                bool n = read(x, y, z+1).type == T_ROAD;\n                bool s = read(x, y, z-1).type == T_ROAD;\n                bool e = read(x+1, y, z).type == T_ROAD;\n                bool w = read(x-1, y, z).type == T_ROAD;\n                GridCell cell = getRoadCell(n,s,e,w);\n                \n                fragColor = encodeCell(cell);\n            }\n        }        \n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}