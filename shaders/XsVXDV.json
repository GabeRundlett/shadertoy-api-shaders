{
    "Shader": {
        "info": {
            "date": "1466798782",
            "description": "Some interlocking gears rotating.",
            "flags": 0,
            "hasliked": 0,
            "id": "XsVXDV",
            "likes": 9,
            "name": "2D Rotating Gears",
            "published": 3,
            "tags": [
                "2d",
                "animation"
            ],
            "usePreview": 0,
            "username": "jaburns",
            "viewed": 453
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159\n\n#define BORDER     0.04\n#define BORDER_ANG 0.16\n#define TEETH      5.00\n#define RING0      0.25\n#define RING1      0.40\n#define RING2      0.43\n#define BAR        0.07\n#define GEAR_SIZE  0.61\n#define SMOOTH     5.00\n\nconst vec4 COLOR_0 = vec4(0.2000,0.2471,0.2667,1.0);\nconst vec4 COLOR_1 = vec4(0.2157,0.6667,0.6118,1.0);\nconst vec4 COLOR_2 = vec4(0.5804,0.9529,0.8941,1.0);\n\nvec2 roto( in vec2 p, in float theta )\n{\n    return mat2(cos(theta), -sin(theta), sin(theta), cos(theta)) * p;\n}\n\nfloat gear( in vec2 p, in float angle )\n{\n    float theta = atan(p.y, p.x) - angle;\n    float tooth = mod(theta, PI/TEETH) / (PI/TEETH);\n    float len = length(p);\n    \n    if (len < RING0) {\n        vec2 p1 = roto(p, angle);\n        return max(\n            smoothstep(RING0 - BORDER, RING0, len),\n            smoothstep(BAR, BAR-BORDER, min(abs(p1.x), abs(p1.y)))\n        );\n    }\n    \n    if (len < RING1) {\n        if (len < RING1 - BORDER) return 1.0;\n        \n        float innerBorder = smoothstep(RING1, RING1 - BORDER, len);\n        if (tooth < BORDER_ANG) {\n            return max(innerBorder, smoothstep(BORDER_ANG, 0.0, tooth));\n        }\n        if (tooth > GEAR_SIZE && tooth <= GEAR_SIZE + BORDER_ANG) {\n            return max(innerBorder, smoothstep(GEAR_SIZE, GEAR_SIZE + BORDER_ANG, tooth));\n        }\n        if (tooth < GEAR_SIZE) {\n\t\t\treturn innerBorder;\n        }\n    }\n    \n    float toothBorder = smoothstep(RING2 + BORDER, RING2, len);\n    if (len > RING2 && tooth > GEAR_SIZE + BORDER_ANG) return toothBorder;\n    if (tooth < BORDER_ANG) {\n        return min(toothBorder, smoothstep(BORDER_ANG, 0.0, tooth));\n    }\n    if (tooth > GEAR_SIZE && tooth <= GEAR_SIZE + BORDER_ANG) {\n        return min(toothBorder, smoothstep(GEAR_SIZE, GEAR_SIZE + BORDER_ANG, tooth));\n    }\n    \n    return tooth > GEAR_SIZE ? 1.0 : 0.0;\n}\n\nvec2 texToWorld( in vec2 coord )\n{\n    return (coord.xy / iResolution.yy)\n        - vec2(0.5*iResolution.x/iResolution.y, 0.5);   \n}\n\nvoid placeGear( inout vec4 fragColor, in vec2 p, in float x, in float angle, in float aa )\n{\n    float g = gear(p + vec2(x, 0.0), angle);\n    \n    fragColor = mix(fragColor, COLOR_1, smoothstep(0.00,      aa, g));\n    fragColor = mix(fragColor, COLOR_2, smoothstep(1.00-aa, 1.00, g));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = texToWorld(fragCoord) * 1.1;\n    float t = 4.0*cos(0.25*iTime);\n    float aa = SMOOTH * (abs(dFdx(p.x)) + abs(dFdy(p.y)));\n    \n    fragColor = COLOR_0;\n    placeGear(fragColor, p,  0.42,  t-0.17, aa);\n    placeGear(fragColor, p, -0.42, -t,      aa);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}