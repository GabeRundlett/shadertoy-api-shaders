{
    "Shader": {
        "info": {
            "date": "1650129959",
            "description": "p2003442",
            "flags": 0,
            "hasliked": 0,
            "id": "fljyRK",
            "likes": 0,
            "name": "TP5-6 Montagne",
            "published": 3,
            "tags": [
                "tp5tp6"
            ],
            "usePreview": 0,
            "username": "valentinCuzin",
            "viewed": 152
        },
        "renderpass": [
            {
                "code": "// Texturing\n// Eric Galin\n\nconst float View = 2800.0;  // View distance\nconst float Epsilon = 0.01; // Marching epsilon\nconst int Steps = 400;      // Number of steps\n\n// Lipschitz constant\nconst float K=1.0;\n\n// Structure for objects\n// v : Field value\n// i : Texture index\nstruct V {\n    float v; \n    int i;\n};\n\n// Structure for texture\n// c : Color\n// s : Specular\nstruct T {\n    vec3 c;\n    float s;\n};\n\nvec3 Translation(vec3 p, vec3 T){\n    return p - T;\n}\n\n// Terrain -----------------------------------------------------------------------------------------------\n\nfloat plateau(float h,float altE,float altA){\n    if((h<altE) || (h>altE+altA))return h;\n    float u=(h-altE)/((altE+altA)-altE);\n    float c= u*u;\n    return altE+altA*c;\n}\n\n// Terrain heightfield\n// x : Position in the plane\nfloat Terrain( in vec2 p )\n{\n\t//return 50.*sin(p.x/100.0)*cos(p.y/100.0);\n    //return Fbm(p,50.,30.0,1);\n    return 3.*TurbulenceRidge(p,500.,50.,7,-100.,100.);\n} \n\n// Implicit surface defining the terrain\n// p : Point\nV ImplicitTerrain(in vec3 p,int index)\n{\n    p = Translation(p,vec3(-1500.,900.,0.));//nécessaire pour eviter la symétrie de mon coté, en plus l'endroit est sympa\n    float z = Terrain( p.xy );\n    z = plateau(z,0.,70.);\n    float h = p.z - z; \n    return V(h/2., index);\n}\n\n// Water ------------------------------------------------------------------------------------------------\n\n// Water heightfield\n// x : Position in the plane\nfloat Water( in vec2 p ) {    \n    return 3.*Turbulence(p,200.,5.*cos(iTime*0.2)+20.,2,0.5*iTime) -90.0;\n} \n\n// Implicit surface defining the terrain\n// p : Point\n// index : texture index\nV ImplicitWater(in vec3 p, int index){\n\tfloat h = p.z - Water( p.xy );\n    return V(h,index);\n}\n\n\n// Primitive functions -----------------------------------------------------------------------------------\n\n// Union\n// a,b : field function of left and right sub-trees\nfloat Union(float a,float b)\n{\n    return min(a,b);\n}\nV Union(V a,V b)\n{\n    if (a.v<b.v)\n        return V(a.v,a.i);\n    else \n    {\n        return V(b.v,b.i);\n    }\n}\n\n// Différence\n// a,b : les deux distance de la fonction SDF des deux object\nfloat Differance(float a, float b){\n    return max(a, -b);\n}\n\n//matrice de rotation\n// a : prend en paramÃ¨tre iTime\nmat2 Rotation(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// Intersection, preserve the index of first object\n// a, b : field function of left and right sub-trees\nfloat Intersection(float a,float b)\n{\n    return max(a,b);\n}\nV Intersection(V a,V b)\n{\n    if (a.v>b.v)\n    {\n        return V(a.v,a.i);\n    }\n    else \n    {\n        return V(b.v,a.i);\n    }\n}\n\n// Sphere \n// p : Point\n// c : Center \n// r : Radius\nV Sphere(vec3 p, vec3 c,float r, int index)\n{\n  return V(length(p-c)-r, index);\n}\n\nfloat Plane(vec3 p, vec3 n, vec3 o)\n{\n    return dot((p-o),n);\n}\n\n//la boite\n// p : le point Ã  qui on calcul la distance Ã  la boite\n// S : l'espace entre deux plan de la boite\nfloat Boite(vec3 p, vec3 s){\n    vec3 q = abs(p)-s;\n    return length( max(q , 0.0))+ min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat cylinder (vec3 a, vec3 b, float r, vec3 p)\n{\n    float aq = dot((p-a),(b-a)/length(b-a));\n    float l = sqrt(dot(p-a,p-a)- aq*aq);\n    return l-r;\n}\n\n//DemicylindreFini\n// p : point\n// r : rayon\n// t : taille du cylindre\nfloat DemiCylindreFini(vec3 p, float r, float t)\n{\n    float cylindreInf = cylinder(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, t), r, p);\n    float demiCylindreInf1 = Differance(cylindreInf, Plane( p, vec3(-0.6, 0.0, -1.0) , vec3(0.0, 0.0, t+1.0))); \n    demiCylindreInf1 = Differance(demiCylindreInf1, Plane( p, vec3(0.6 ,0.0 ,-1.0) , vec3(0.0,0.0,t+1.0) ));\n    return demiCylindreInf1;\n    \n}\n\n//moulin\n// p : point\n// t : taille du moulin\nV Moulin(vec3 p, float t,int indexC, int indexP){\n    V Colone = V(DemiCylindreFini(p, 70.0, t),indexC);\n    vec3 ptr= Translation(p,vec3(0.,70.,200.));\n    ptr.xz = ptr.xz * Rotation(iTime);\n    ptr.yz = ptr.yz * Rotation(1.53);\n    float raccord = Boite(ptr,vec3(20.,20.,50.));\n    ptr = Translation(ptr,vec3(0.,0.,30.));\n    float pale1 = Boite(ptr,vec3(150.,30.,10.));\n    ptr.xy = ptr.xy * Rotation(1.53);\n    V pale = V(Union(raccord,Union(pale1, Boite(ptr,vec3(150.,30.,10.)))),indexP);\n    V moulin = Union(Colone, pale);\n    return moulin;\n}\n\nV Bateau(in vec3 p,int indexVoile){\n    V base=V(Boite(p,vec3(50.,27.,4.)),1);\n    p.xy = p.xy*Rotation(cos(iTime)/2.);\n    p = Translation(p,vec3(0.,0.,-30.));\n    V mat=V(Boite(p,vec3(3.,3.,25.)),1);\n    p = Translation(p,vec3(20.,0.,0.));\n    V voile=V(Differance( Boite(p,vec3(20.,2.,15.)) , Plane(p,vec3(-0.6,0.,-1.),vec3(0.0,0.,5.)) ),indexVoile);\n    return Union(base,Union(mat,voile));\n    }\n\n// Scene --------------------------------------------------------------------------\n\n// Potential field of the object\n// p : point\nV Object(vec3 p)\n{\n  V terrain = ImplicitTerrain(p,0);\n  V Limite = Sphere(p,vec3(0.0,0.0,0.0),800.0,0);\n  V surface = Intersection(terrain, Limite);\n  V Ocean = Intersection(ImplicitWater(p,3), Limite);\n  vec3 pt = Translation(p,vec3(320.,0.,0.));\n  pt.xy = pt.xy * Rotation(-1.0);\n  V moulin1 = Moulin(pt,290.,2,1);\n  pt = Translation(p,vec3(150.,250.,Ocean.v+p.z-5.));\n  pt = Translation(pt,vec3(55.*cos(iTime),100.*cos(iTime),0.));\n  V bateau = Bateau(pt,4);\n  moulin1.v = Differance(moulin1.v,terrain.v);\n  V u = Union(moulin1,Union(surface,Ocean));\n  u = Union(u,bateau);\n  return u;\n}\n\n// Analysis of the scalar field --------------------------------------------------------------------------\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.001;\n  vec3 n;\n    float v = Object(p).v;\n  n.x = Object( vec3(p.x+eps, p.y, p.z) ).v - v;\n  n.y = Object( vec3(p.x, p.y+eps, p.z) ).v - v;\n  n.z = Object( vec3(p.x, p.y, p.z+eps) ).v - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance \n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, float e,out bool h,out int s)\n{\n  h = false;\n\n    // Start at the origin\n    float t=0.0;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = Object(p).v;\n    // Hit object\n      if (v < 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,v/K);\n      // Escape marched too far away\n      if (t>e)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Shading and lighting ---------------------------------------------------------------------------\n\nT TextureRock(in vec3 p)\n{\n  return T(mix(vec3(0.92,0.91,0.90),vec3(0.74,0.72,0.72),Fbm(p/50.0)),0.0);   \n}\n\nint convert(float a){\n    if(a<0.0){\n        a= a-1.0;\n    }\n    return int(a);\n}\n\nT TextureDamier(in vec3 p, T a, T b){\n    p.y = p.y+Turbulence(p,150.,10.,13);\n    int x = convert(p.x/20.);//convertion en entier\n    int y = convert(p.y/20.);//correction partie entière des valeurs négatifs pour evité le cas de int(0.4)=int(-0.4)\n    int z = convert(p.z/20.);\n        if( (x+y+z)%2 == 0 ){//modulo 2 pour faire 2 cas: coordonées paire, coordonées impaire\n        return a;//couleur 1\n    }else{\n        return b;//couleur 2\n    }   \n}\n\nT TextureBois(in vec3 p, T a, T b, float E, float bruit){\n    p = p + Translation(p,vec3(460.,0.,360.));\n    //p.xz = p.xz * Rotation(iTime);\n    p.yz = p.yz * Rotation(1.53);\n    \n    p = p + bruit*Noise(p)*(p/E);//perturbation de p en fonction de l'indice bruit et de la longeur d'onde E\n    float d = length(p.xy/50.);//calcul de la distance pour créer les cercles\n    float v = 0.5*cos(d*E) + 1.0;//utilisation de cos pour interpoler les deux couleurs quand v=1 couleur a quand v= 0 couleur b\n    return T( (a.c*v + b.c*(1.0-v)), (a.s*v + b.s*(1.0-v)) );//vrai interpolation de la couleur mais aussi de l'indice spéculaire\n}\n\nT TextureWater(in vec3 p){\n  float eauSombre = smoothstep(-10.,15.,p.z);\n  return T(mix(vec3(0.16,0.29,0.37),TextureRock(p).c,eauSombre),1.);\n}\n\nT TextureBorder(in vec3 p)\n{\n    return T(vec3(0.2,0.2,0.2),1.);   \n}\n\nT TextureTerrain(in vec3 p){\n    float herbe,neige,roche;\n    p.z = p.z+Turbulence(p,100.,50.,1);\n    herbe = smoothstep(-9.0, 10.0, p.z);\n    neige = smoothstep(80., 200., p.z);\n    roche = smoothstep(30.,70.,p.z);\n    if(p.z > 100.) return T(mix(TextureBorder(p).c,vec3(1., 1., 1.), neige),0.);\n\n    if(p.z > -30. && p.z < 40.) return T(mix(vec3(0.8, 0.8, 0.6), vec3(0., 0.6, 0.), herbe),0.);\n    \n    if(p.z > 40. && p.z < 100.) return T(mix(vec3(0.,0.6,0.),TextureBorder(p).c, roche),0.);\n\n    if(p.z > -70. && p.z < -30.) return T(vec3(.8, 0.8, 0.6),0.);\n\n    if(p.z <= -70.) return TextureWater(p);\n}\n\n// Compute color \n// p : Point\n// n : Normal\nT Color(in vec3 p,in vec3 n)\n{\n    V vp= Object(p);\n    if (vp.i==0){\n        return TextureTerrain(p);\n    }\n    else if (vp.i==1){\n        return TextureBois(p, T(vec3(0.87, 0.72, 0.53),0.0), T(vec3(0.54, 0.27, 0.07),0.0), 6.0, 0.1);\n    }\n    else if (vp.i==2){\n        return TextureDamier(p,T(vec3(0.52,0.18,0.11),0.0),T(vec3(0.81,0.28,0.16),0.0));\n    }\n    else if (vp.i==3){\n        return TextureWater(p);\n    }\n    else if (vp.i==4){        \n        return T(vec3(0.9,0.1,0.2),0.);//juste du rouge couleur unie.\n    }\n}\n\n// Rendering \n// ro, rd : Ray origin and direction\n// pip : Picture in picture boolean\nvec4 Render( in vec3 ro, in vec3 rd, bool pip )\n{\n    // Light direction\n    vec3 light1 = normalize( vec3(-0.8,-0.3,0.4) );\n   \n    \n\tvec3 col;\n    int it;\n    bool b;\n    float t = SphereTrace( ro, rd, View,b , it);\n\tvec3 p = ro + t*rd;\n    V vp= Object(p);\n    vec3 n = ObjectNormal( p );\n\n\n    col = Color(p,n).c;\n    // Sky\n    if( b==false )\n    {\n        col = vec3(0.79,0.5,0.43) - rd.z*rd.z*2.5;\n    }\n        vec3 ref = reflect( rd, n );\n        float fre = clamp( 1.0+dot(rd,n), 0.0, 1.0 );\n        vec3 hal = normalize(light1-rd);\n                   \n\n         // Pseudo diffuse lighting\n\t\tfloat dif = 0.5*(1.0+dot( light1, n ));\n        dif*=dif;\n        \n        col = 0.45*col+0.55*dif*vec3(0.35,0.35,0.35);\n    \n    // Shading for iterations\n    if (pip==true)\n    {\n    \tfloat s=float(it)/float(Steps);\n\t\treturn vec4(0.112+0.824*s,0.418+0.556*s,0.611-0.515*s,t);\n    }\n    else\n    {\n    \t// Gamma with square root\n    \treturn vec4( sqrt(col), t );\n    }\n}\n\nvec2 RayDirection(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/5.0;\n    // Picture in picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip=true;\n    }\n       else\n       {\n           pip=false;\n       }\n   }\n   return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   // Time as function of the position of the mouse\n    float a = 3.14*2.0*1.5*iMouse.x/iResolution.x;\n\n    // Camera transform\n    vec3 ro; \n    mat3 cam = Camera( a, ro);   \n\n    // Picture in picture\n    bool pip=true;\n    \n    // Pixel coordinates\n    vec2 p = RayDirection(fragCoord, pip);\n   \n    // Camera ray    \n    vec3 rd = cam * normalize(vec3(p,3.0));\n    \n    // Render\n    vec4 res = Render( ro, rd, pip );\n     \n    fragColor = vec4( res.xyz, 0.0 );\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Texturing\n// Eric Galin\n\n// Texturing and noise ---------------------------------------------------------\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in space\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\nfloat Ridge(in vec3 p){\n    return 1.-2.*abs(Noise(p));\n}\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in the plane\nfloat Hash(in vec2 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix( Hash(i+vec2(0,0)), \n                        Hash(i+vec2(1,0)),f.x),\n                   mix( Hash(i+vec2(0,1)), \n                        Hash(i+vec2(1,1)),f.x),f.y);\n}\nfloat Ridge(in vec2 p){\n    return 1.-2.*abs(Noise(p));\n}\n\nfloat Turbulence(in vec3 p,float longueurOnde ,float coef, int detail){// somme de bruits \n    float somme = coef*Noise(p/longueurOnde);\n    for(int i = 0; i<detail; i++){//boucle pour calculer la somme de bruit\n        coef = coef *0.5;\n        longueurOnde = longueurOnde *0.5;\n        somme = somme + coef*Noise(p/longueurOnde);\n    }\n    return somme;\n}\n\nfloat Turbulence(in vec2 p,float longueurOnde ,float coef, int detail, float temps){// somme de bruits vec2\n    float somme = coef*Noise(p/longueurOnde);;\n    for(int i = 0; i<detail; i++){//boucle pour calculer la somme de bruit\n        coef = coef *0.5;\n        longueurOnde = longueurOnde *0.4;\n        somme = somme + coef*Noise(p/longueurOnde+temps);\n    }\n    return somme;\n}\n\nfloat TurbulenceRidge(in vec2 p,float longueurOnde, float coef, int detail, float amin, float amax){//somme de ridge\n    float somme = coef*Ridge(p/longueurOnde);\n    for(int i=1;i<detail;i++){\n        coef *= 0.5;\n        longueurOnde *= 0.5;\n        float att=smoothstep(amin,amax,somme);\n        somme+= att*coef*Ridge(p/longueurOnde);\n    }\n    return somme;\n}\n\n\n// Fractal brownian motion with 4 frequencies\n// p : Point\nfloat Fbm(in vec3 p)\n{\n    return Noise(p)/2.0+Noise(p*2.0)/4.0+Noise(p*4.0)/8.0+Noise(p*8.0)/16.0;\n}\n\n// Camera\n// a: Rotation angle around z axis\n// ro : Ray origin\nmat3 Camera(float a, out vec3 ro)\n{\n\tfloat range=1350.0;\n    // Origin\n    ro = vec3(range*cos(a),range*sin(a),range/4.0);\n\t\n    // Target\n    vec3 ta = vec3(0.0,0.0,50.0);\n    \n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, 0.0,1.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}