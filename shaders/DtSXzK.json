{
    "Shader": {
        "info": {
            "date": "1676561080",
            "description": "Nice infinite subdivided smooth 2d grid, similar to one used in Blender\n\nClick like if you like it!",
            "flags": 0,
            "hasliked": 0,
            "id": "DtSXzK",
            "likes": 4,
            "name": "Nice subdivided 2d grid",
            "published": 3,
            "tags": [
                "2d",
                "grid",
                "lines",
                "editor",
                "nice",
                "divide"
            ],
            "usePreview": 0,
            "username": "rsk",
            "viewed": 375
        },
        "renderpass": [
            {
                "code": "// Nice subdivided 2d grid\n// author: rsk -> https://twitter.com/rsk\n\n// antialising mode\n#define AA false\n// background color\n#define BG vec3(0.1, 0.2, 0.3)\n// axis color\n#define AXIS_C vec3(0.15, 0.25, 0.44)\n// axis line width\n#define AXIS_W 4.0\n// grid lines color\n#define GRID_C vec3(0.1, 0.27, 0.35)\n// grid lines width (for AA recommended 2.5)\n#define GRID_W 2.0\n// grid step\n#define GRID_STEP 120.0\n// number of subdivisions for main grid\n#define GRID_DIV 10.0\n// minimal visible step size in pixels for grid subdivisions\n#define MIN_VISIBLE_STEP 10.0\n// subgrid lines width (for AA recommended 2.0)\n#define SUB_W 1.0\n// color for sub grid\n#define SUB_C vec3(0.117, 0.225, 0.332)\n\nvec3 srgb(vec3 c) {\n    return pow(c, vec3(1.0 / 2.2));\n}\n\nfloat ilerp(float a, float b, float value) {\n    return clamp((value - a) / (b - a), 0.0, 1.0);\n}\n\nfloat logBase(float value, float base) {\n    return log(value) / log(base);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 r = iResolution.xy;\n    vec2 center = r / 2.0;\n    vec2 d = center - fragCoord;\n    float scale = 1.0 / 10.0 + (sin(iTime / 5.5 - 1.3) + 1.0) * 20.0;\n    float scaledStep = GRID_STEP * scale;\n    // zoom level with fraction\n    float levelF = logBase(MIN_VISIBLE_STEP / scaledStep, GRID_DIV);\n    // zoom level integer\n    float level = floor(levelF);\n    // zoom level fraction\n    float f = fract(levelF);\n    float gridStep = scaledStep * pow(GRID_DIV, level + 2.0);\n    float subStep = scaledStep * pow(GRID_DIV, level + 1.0);\n    float subW = float(f < 0.5) * mix(SUB_W, GRID_W, (0.5 - f) / 0.5) + float(f >= 0.5) * SUB_W;\n    vec3 subStepColor = float(f < 0.5) * mix(SUB_C, GRID_C, (0.5 - f) / 0.5) + float(f >= 0.5) * mix(BG, SUB_C, (1.0 - f) / 0.5);\n\n    float centerC = ilerp(AXIS_W / 2.0, 0.0, min(abs(d.x), abs(d.y)));\n    centerC = float(centerC > 0.0);\n    \n    if (!AA) {\n        float gridC = ilerp(GRID_W, 0.0, min(abs(mod(d.x, gridStep)), abs(mod(d.y, gridStep))));\n        gridC = float(gridC > 0.0);\n        // don't paint over AXIS\n        gridC = (1.0 - centerC) * gridC;\n\n        float subC = ilerp(subW, 0.0, min(abs(mod(d.x, subStep)), abs(mod(d.y, subStep))));\n        subC = float(subC > 0.0);\n        // don't paint over AXIS and over main GRID\n        subC = (1.0 - centerC) * (1.0 - gridC) * subC;\n        float bgC = 1.0 - clamp(centerC + gridC + subC, 0.0, 1.0);\n        fragColor = vec4(srgb(AXIS_C * centerC + GRID_C * gridC + subStepColor * subC + BG * bgC), 1.0);\n    } else {\n        float gridC = min(abs(mod(d.x, gridStep)), abs(mod(d.y, gridStep)));\n        gridC = GRID_W - gridC;\n        gridC = float(gridC < 1.0 && gridC > 0.0) * gridC + float(gridC >= 1.0);\n        // don't paint over AXIS\n        gridC = min(1.0 - centerC, gridC);\n\n        float subC = min(abs(mod(d.x, subStep)), abs(mod(d.y, subStep)));\n        subC = subW - subC;\n        subC = float(subC < 1.0 && subC > 0.0) * subC + float(subC >= 1.0);\n        // don't paint over AXIS and over main GRID\n        subC = min(1.0 - centerC - gridC, subC);\n        float bgC = 1.0 - clamp(centerC + gridC + subC, 0.0, 1.0);\n        fragColor = vec4(srgb(AXIS_C * centerC + GRID_C * gridC + subStepColor * subC + BG * bgC), 1.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}