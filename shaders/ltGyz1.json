{
    "Shader": {
        "info": {
            "date": "1535131676",
            "description": "Adapted from this superb anime-explosion Blender tutorial by Cody Winchester: https://youtu.be/fE-uDqBpXxI",
            "flags": 32,
            "hasliked": 0,
            "id": "ltGyz1",
            "likes": 40,
            "name": "KABOOM!!",
            "published": 3,
            "tags": [
                "raymarching",
                "explosion",
                "npr"
            ],
            "usePreview": 1,
            "username": "TekF",
            "viewed": 2259
        },
        "renderpass": [
            {
                "code": "// KABOOM\n// (c) Hazel Quantock 2018\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n\n// Adapted from https://youtu.be/fE-uDqBpXxI by Cody Winchester\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    fragColour = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n    \n    // add bloom\n    float weights = 0.;\n    vec3 bloom = vec3(0);\n    const int kernel = 10;\n    for ( int j=-kernel; j <= kernel; j++ )\n    {\n        for ( int i=-kernel; i <= kernel; i++ )\n        {\n            float weight = pow( smoothstep(float(kernel+1),0.,length(vec2(i,j))), 1. );\n            bloom += texelFetch( iChannel0, ivec2(fragCoord)+ivec2(i,j), 0 ).rgb * weight;\n            weights += weight;\n        }\n\t}\n    \n    fragColour.rgb += bloom*.3 / weights;\n\n    // gamma correct\n    fragColour.rgb = pow(fragColour.rgb,vec3(1./2.2));\n    fragColour.a = 1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// KABOOM\n// (c) Hazel Quantock 2018\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n\n// Adapted from https://youtu.be/fE-uDqBpXxI by Cody Winchester\n\n\n// Smooth perlin-style noise\nfloat Kapow( vec3 p )\n{\n    p = floor(p) + smoothstep( 0., 1., fract(p) );\n    return texture(iChannel0,(p+.5)/32.).r;\n}\n\n\n// Voronoi pattern, distance to closest node in a field of randomly placed nodes\nfloat Kaboom( vec3 p )\n{\n    ivec3 ip = ivec3(floor(p));\n    p = fract(p);\n    \n    float closest = 10.;\n    \n    float randomness = .7; const int kernel = 2;\n//    float randomness = 1.3; const int kernel = 3; // randomness above .7 need a kernel above 2\n    \n    for ( int k = 0; k <= kernel; k++ )\n    {\n        for ( int j = 0; j <= kernel; j++ )\n        {\n            for ( int i = 0; i <= kernel; i++ )\n            {\n                vec3 rand = texelFetch( iChannel0, (ip + ivec3(i,j,k))&31, 0 ).gba; // 4-channel map seems as slow as the 1 channel map\n                vec3 dp = p - vec3(i,j,k) + float(kernel)*.5 + (rand-.5)*randomness;\n                float d = length(dp);\n                \n                closest = min( closest, d );\n            }\n        }\n    }\n    return closest*closest;\n}\n\n\n// Signed Distance Field\nfloat Fraggaboom( vec3 p, float r, vec3 s )\n{\n    p /= r;\n    return r*((length(p) - 1.)*.8 - .5*mix( Kapow(2.*(p+s)), 1.-Kaboom(1.*(p+s)), .8 ));\n}\n\n\n// Colour Pattern\nfloat Badaboom( vec3 p, float r, vec3 s, float m )\n{\n    p /= r;\n    // return a value from 0 to 1 for colouring\n    // 0 = crevices, 1 = protrusions - but with some noise to make it more interesting\n    return mix(\n        \t\t1.-Kapow(2.*(p+s)), // flip it - so we can push further\n        \t\tmix(\n\t\t\t\t\t1.-Kaboom(1.*(p+s)),\n                    1.-Kaboom(5.*(p+s)),\n                    .2\n                ),\n        \tm );\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    float scale = sqrt(fract(iTime/3.));\n    vec3 uvwOffset = vec3(0,2,-1)*sqrt(fract(iTime/3.))*2.4 + floor(iTime/3.);\n    \n    vec3 pos = vec3(2.*(iMouse.xy-iResolution.xy*.5)/iResolution.y,-3);\n    vec3 ray = vec3((fragCoord-iResolution.xy*.5)/iResolution.y,1.);\n    \n    vec3 camK = normalize(vec3(0)-pos);\n    vec3 camI = normalize(cross(vec3(0,1,0),camK));\n    vec3 camJ = cross(camK,camI);\n    \n    ray = ray.x*camI+ray.y*camJ+ray.z*camK;\n\n    ray = normalize(ray);\n    \n    // find the size in scene units of the gap between adjacent rays, as a factor of distance\n    float pixelSizePerMetre = length(vec2(length(dFdx(ray)),length(dFdy(ray))));\n    \n\tfloat t = 0.;\n\tfloat lastt = 0.;\n    float h = 0.;\n    float smallesth = 1e30;\n    float closestt = 0.;\n    float sdf = 0.;\n    float lastsdf = 0.;\n    for ( int i=0; i < 200; i++ )\n    {\n    \tfloat epsilon = pixelSizePerMetre*t;\n        lastsdf = sdf;\n        sdf = Fraggaboom(pos+ray*t,scale,uvwOffset);\n        h = sdf + epsilon*.5; // shrink sdf by the average of the precision we'll end at\n        if ( h < epsilon ) break;\n        if ( h < smallesth ) { closestt = t; smallesth = h; }\n        lastt = t;\n        t += h;\n    }\n    \n   \tfloat epsilon = pixelSizePerMetre*t;\n    if ( h < epsilon*2. )\n    {\n        // do the last step with improved precision\n        // take the last 2 samples as a guide to where the surface is (assume it's a plane at this scale)\n        t = mix( lastt, t, (0.-lastsdf)/(sdf - lastsdf) );\n    }\n    else if ( t < 1e10 ) // if we didn't reach the sky, pick the best intersection we've got\n    {\n        t = closestt;\n    }\n    else\n    {\n        // background\n        fragColour = vec4(.03,.05,.07,1) * (1.-.6*sin(5.*fragCoord.y/iResolution.y));\n        return;\n    }\n    \n\tpos = pos+ray*t;\n    \n    // rim-lit parts\n    // since we want n.ray, we can just use the last 2 sdf samples! HAHAHA!\n    //        float nDotR = (lastsdf-sdf)/lastsdf; // difference between last 2 samples / distance between them\n    // woah, lots of noise on that!\n    float d = .1;\n    float nDotR = (Fraggaboom(pos-.5*d*ray,scale,uvwOffset) - Fraggaboom(pos+.5*d*ray,scale,uvwOffset))/d;\n    // d = .01 => moire? is that the texture interpolation resolution?        \n\n    //float rim = pow( max(0.,1.-nDotR), 10. ); // this creates a really badly aliased edge\n    float rim = smoothstep(.2,.05,nDotR); // more of an outline\n\n    fragColour.rgb = mix( vec3(.3,.04,0), vec3(10,2.5,1), rim );\n\n    // solid orange bits\n    fragColour.rgb = mix( vec3(.99,.25,0), fragColour.rgb, step( .55, Badaboom( pos, scale, uvwOffset, .7 ) ) );\n    \n    // black parts (slightly different version of the noise\n    fragColour.rgb = mix( vec3(.01), fragColour.rgb, step( .42, Badaboom( pos, scale*1.05, uvwOffset, .5 ) ) );\n    \n    fragColour.a = 1.;\n    \n    // fake a low fps\n//    if ( (iFrame&3) != 0 ) fragColour = texelFetch( iChannel1, ivec2(fragCoord), 0 );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}