{
    "Shader": {
        "info": {
            "date": "1563574570",
            "description": "Testing a simple depth of field and reflections",
            "flags": 32,
            "hasliked": 0,
            "id": "WtlSz2",
            "likes": 24,
            "name": "Alien biome",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 0,
            "username": "loicvdb",
            "viewed": 810
        },
        "renderpass": [
            {
                "code": "#define HalfPi 1.57079632679\n#define FocalDistance .4\n#define Aperture .02\n\nfloat dofRadius(float depth){\n    return Aperture*iResolution.y*atan(abs(depth-FocalDistance), depth);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  //simple DoF\n  float depthCenter = texture(iChannel0, fragCoord.xy/iResolution.xy).a;\n  vec3 color;\n  float samples;\n  int rd = int(Aperture*iResolution.y/HalfPi)+1; //might clip the DoF for close objects\n  for(int y = -rd; y <= rd; y ++){\n    for(int x = -rd; x <= rd; x ++){\n      vec2 d = vec2(x, y);\n      if(length(d) < float(rd)){\n          vec4 p = texture(iChannel0, (fragCoord.xy+d) / iResolution.xy);\n          float influence = clamp(dofRadius(p.a) - length(d) + .5, 0.0, 1.0) / (dofRadius(p.a)+.001);\n          color += influence * p.rgb;\n          samples += influence;\n      }\n    }\n  }\n  color /= samples;\n  fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define Pi 3.14159265359\n#define StepSize 1.5\n#define AngleStepSize 5.0\n#define Steps 300\n#define MaxDist 7.0\n#define MinDist .0005\n#define Iterations 8\n#define Ior 1.5\n#define reflectionRoughness .0075\n#define FogColor vec3(1.0, .5, .75)\n#define FogDensity .075\n\n//camera\nvec3 DirCam = normalize(vec3(-1, 0, -.2));\nvec3 PosCam = vec3(.2, .95, .1);\nfloat FocalLength = 1.5;\n\nvec2 FractalParameters;\n\n\nvec3 background(vec3 dir){\n  return FogColor * FogDensity/max(abs(dir.z), .01);\n}\n\nfloat distanceEstimation(in vec3 p, out vec3 color){\n    vec3 p0 = p;\n    \n    if(p.z > 2.5) return MaxDist; //ignores points above a certain height\n    \n\tvec4 param_min = vec4(-0.8323, -0.694, -0.5045, 1.6478993);\n\tvec4 param_max = vec4(0.8579, 1.0883, FractalParameters);\n    float k1, k2, rp2, rq2;\n    float scale = 1.0;\n    vec3 q = p;\n    for (int i = 0; i < Iterations; i++){\n\t    p = 2.0 * clamp(p, param_min.xyz, param_max.xyz) - p;\n\t    q = 2.0 * fract(0.5 * q + 0.5) - 1.0;\n\t    rp2 = dot(p, p);\n\t    rq2 = dot(q, q);\n\t    k1 = max(param_min.w / rp2, 1.0);\n\t    k2 = max(param_min.w / rq2, 1.0);\n\t    p *= k1;\n\t    q *= k2;\n\t    scale *= k1;\n    }\n    float lxy = length(p.xy);\n    color = vec3(k2/rp2, 0.0, .2*k2)*.4;\n    return 0.5 * max(param_max.w - lxy, lxy * p.z / length(p)) / scale;\n}\n\nfloat distanceEstimation(vec3 p){\n    vec3 placeHolder;\n    return distanceEstimation(p, placeHolder);\n}\n\nvec3 normal(vec3 pos){\n    \n  float normalSmooth = 2.0;\n  float p = normalSmooth*MinDist;\n      \n  vec3 xDir = vec3(p, 0.0, 0.0);\n  vec3 yDir = vec3(0.0, p, 0.0);\n  vec3 zDir = vec3(0.0, 0.0, p);\n\n  float normalX = distanceEstimation(pos + xDir)\n                - distanceEstimation(pos - xDir);\n  float normalY = distanceEstimation(pos + yDir)\n                - distanceEstimation(pos - yDir);\n  float normalZ = distanceEstimation(pos + zDir)\n                - distanceEstimation(pos - zDir);\n\n  return normalize(vec3(normalX, normalY, normalZ));\n}\n\n//traces a ray and returns true if it hit the shape\nbool trace(inout vec3 pos, in vec3 dir, out vec3 hitNormal, out vec3 color){\n    if(distanceEstimation(pos) < 0.0) dir *= -1.0;\n    for(int i = 0; i < Steps; i++){\n        float dist = distanceEstimation(pos, color);\n        if(length(pos-PosCam) > MaxDist) return false;\n        if(abs(dist) < MinDist) break;\n        pos += dir * dist * StepSize;\n    }\n    hitNormal = normal(pos);\n    return true;\n}\n\n//calculates the smallest angle along a ray with the closest point to the fractal\nbool traceAngle(inout vec3 pos, in vec3 dir, out float angleMin){\n    vec3 initialPos = pos;\n    angleMin = Pi;\n    float dist = distanceEstimation(pos);\n    for(int i = 0; i < Steps; i++){\n        pos += dist * dir * AngleStepSize;\n        dist = distanceEstimation(pos);\n        if(length(pos-PosCam) > MaxDist) return false;\n        if(dist < MinDist) break;\n        angleMin = min(asin(dist/length(pos-initialPos)), angleMin);\n    }\n    return true;\n}\n\nfloat fresnel(vec3 dir, vec3 normal, float ior) {\n  float kr;\n  float cosi = dot(dir, normal);\n  float etai = 1.0;\n  float etat = ior;\n  if (cosi > 0.0) {\n    float tmp = etai;\n    etai = etat;\n    etat = tmp;\n  }\n  float sint = etai / etat * sqrt(max(0.0, 1.0 - cosi * cosi));\n  if (sint >= 1.0) {\n    kr = 1.0;\n  } else {\n    float cost = sqrt(max(0.0, 1.0 - sint * sint));\n    cosi = abs(cosi);\n    float sqrtRs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost));\n    float sqrtRp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost));\n    kr = (sqrtRs * sqrtRs + sqrtRp * sqrtRp) / 2.0;\n  }\n  return kr;\n}\n\nvoid addReflections(inout vec3 color, in vec3 pos, in vec3 dir, in vec3 normal){\n    float angleMin;\n    vec3 reflectDir = reflect(dir, normal);\n    if(!traceAngle(pos, reflectDir, angleMin)){\n    \tfloat reflectionAmount = fresnel(dir, normal, Ior) * min(angleMin/reflectionRoughness, 1.0);\n    \tcolor = (1.0-reflectionAmount) * color + reflectionAmount * (background(reflectDir));\n    }\n}\n\n//steps outside of the shape to trace new rays\nvoid stepOutside(inout vec3 pos, in vec3 normal){\n\tfor(int i = 0; i < 3; i++){\n\t\tpos -= normal * (distanceEstimation(pos) - 2.0*MinDist);\n\t}\n}\n\n//returns the color of a ray with the depth (for the DoF)\nvec4 colorAndDepth(vec3 pos, vec3 dir){\n    \n    vec3 hitNormal;\n    vec3 color;\n    if(trace(pos, dir, hitNormal, color)){\n        float depth = length(PosCam - pos);\n        stepOutside(pos, hitNormal);\n        addReflections(color, pos, dir, hitNormal);\n        color += FogColor * FogDensity * depth * 3.0;\n    \treturn vec4(color, depth);\n    }\n    return vec4(background(dir), MaxDist);\n}\n\nvec4 projectRay(vec2 posOnScreen){\n    \n\tvec3 camX = vec3(-DirCam.y, DirCam.x, 0);\n\tvec3 camY = cross(camX, DirCam);\n\tvec3 sensorX = camX * (posOnScreen.x/length(camX));\n\tvec3 sensorY = camY * (posOnScreen.y/length(camY));\n\tvec3 centerSensor = PosCam - DirCam * FocalLength;\n\tvec3 posOnSensor = centerSensor + sensorX + sensorY;\n\tvec3 newDir = normalize(PosCam - posOnSensor);\n\t\n    vec4 cAD = colorAndDepth(PosCam, newDir);\n\treturn vec4(log(cAD.rgb + vec3(1.0)), cAD.a);\t//reduces clipping and desaturates bright colors\n}\n\nvec3 rotateZ(vec3 p, float angle){\n    return vec3(cos(angle) * p.x + sin(angle) * p.y,\n                -sin(angle) * p.x + cos(angle) * p.y,\n                p.z);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    //quick animation ...\n    DirCam = rotateZ(DirCam, -iTime/10.0);\n    PosCam = rotateZ(PosCam, -iTime/10.0);\n    FractalParameters = vec2(cos(iTime)*1.5 + 2.75, sin(iTime)*.05 + 1.35);\n    \n    vec2 uv = (fragCoord.xy - iResolution.xy/2.0)/iResolution.y;\n\n    fragColor = projectRay(uv);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}