{
    "Shader": {
        "info": {
            "date": "1701982840",
            "description": "Something that you can view formulas on, just like a graphing calculator but more interesting(and much more useless).\nKeybinds:\n V/B: Set antialiasing mode(x1, x2, x4, x8, x16, x32)\n Z/X: Zoom +/-\n Q/E: Change view\n Space: Reset view\n WASD: Move camera",
            "flags": 48,
            "hasliked": 0,
            "id": "DlVfWR",
            "likes": 1,
            "name": "Math Visualizer",
            "published": 3,
            "tags": [
                "fractal",
                "math",
                "interactive",
                "visualization"
            ],
            "usePreview": 0,
            "username": "rafa_br34",
            "viewed": 187
        },
        "renderpass": [
            {
                "code": "float Function(in vec2 Coord) {\n    float X = Coord.x, Y = Coord.y;\n    uint ID = RESX * uint(Y) + uint(X) + 1u;\n    \n    // Use any formula/algorithm that you'd like.\n    \n    //return (sin(X) + cos(Y)) * tan(X * Y);\n    //return (sinh(X) * cosh(Y)) / (sqrt(X) * sqrt(X + Y));\n    //return (sin(X) * cos(Y)) * sqrt(Y);\n    //return (sin(X) * cos(Y)) * sqrt(Y*cos(X));\n    //return (sin(X) + cos(Y)) * sqrt(sin(Y)*cos(X));\n    //return (sin(X) + cos(Y)) / sqrt(sin(Y)*cos(X));\n    return (sin(X) + cos(Y)) * sqrt(sin(Y)*cos(X)) * (tanh(Y) * tan(X));\n    //return float(int(X) % int(Y));\n    //return pow(X + 1.0, X)/Y;\n}\n\n\nvec3 ToColor(in float V, in uint T) {\n    int Multiplier = (int[](\n        0x300,\n        0x600,\n        0xFFFFFF,\n        0xFFFFFF,\n        0xFFFFFF\n    ))[T];\n    \n    int VI = int(V * float(Multiplier)) % Multiplier;\n    \n    #define U24ToRGB(A) vec3(FUI8((A >> 0) & 0xFF), FUI8((A >> 8) & 0xFF), FUI8((A >> 16) & 0xFF))\n    switch (T) {\n        case 0u:\n            return vec3(\n                FUI8(int(VI < 256) * VI),\n                FUI8(int(VI >= 256 && VI < 512) * (VI - 256)),\n                FUI8(int(VI >= 512 && VI < 768) * (VI - 512))\n            );\n            \n        case 1u:\n            if (VI < 768) {\n                return vec3(\n                    FUI8(int(VI < 256) * VI),\n                    FUI8(int(VI >= 256 && VI < 512) * (VI - 256)),\n                    FUI8(int(VI >= 512 && VI < 768) * (VI - 512))\n                );\n            }\n            else {\n                VI -= 768;\n                return vec3(\n                    FUI8(255 - int(VI < 256) * VI),\n                    FUI8(255 - int(VI >= 256 && VI < 512) * (VI - 256)),\n                    FUI8(255 - int(VI >= 512 && VI < 768) * (VI - 512))\n                );\n            }\n\n        case 2u:\n            return U24ToRGB(VI);\n            \n        case 3u:\n            return vec3(FUI8((VI*VI*0xFFF) >> 16), FUI8((VI*VI*0xFF) >> 8), FUI8((VI*VI*0xF) >> 0));\n        case 4u:\n            VI = ((VI >> 16) & 0xFF) + 5381;\n            VI = ((VI >> 8) & 0xFF) + (VI * 33);\n            VI = ((VI >> 0) & 0xFF) + (VI * 33);\n            return U24ToRGB(VI);\n    }\n}\n\n\n\nvoid mainImage(out vec4 FragColor, in vec2 FragCoord) {\n    Config C = ParseConfig(READP_V4(C_Storage, vec2(0, 0)));\n    \n    vec2 Ratio = vec2(\n        (RESY > RESX) ? float(RESY) / float(RESX) : 1.0,\n        (RESX > RESY) ? float(RESX) / float(RESY) : 1.0\n    );\n    \n    vec2 UV = (FragCoord / iResolution.xy) - vec2(0.5, 0.5);\n    vec2 PixelSize = 1.0 / iResolution.xy;\n    float Samples = pow(2.0, float(C.AA) * 2.0);\n    \n    \n    if (C.AA == 0u)\n        FragColor = vec4(ToColor(Function(((UV / vec2(C.Zoom)) / Ratio) + C.Offset), C.Mode), 1.0);\n    else {\n        vec3 Color = vec3(0.0);\n        \n        float R = 1.0 / sqrt(Samples);\n        \n        for (float X = -0.5; X < 0.5; X+=R)\n            for (float Y = -0.5; Y < 0.5; Y+=R)\n                Color += ToColor(Function((((UV + (PixelSize * vec2(X, Y))) / vec2(C.Zoom)) / Ratio) + C.Offset), C.Mode);\n            \n        FragColor = vec4(Color / float(Samples), 1.0);\n    }\n    \n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define C_Storage iChannel0\n#define C_Keyboard iChannel3\n\n#define RESX uint(iResolution.x)\n#define RESY uint(iResolution.y)\n\n#define READP_V4(Buffer, Position) texelFetch(Buffer, ivec2(Position), 0)\n\n#define RAND_STATE(Coord) ((RESX * uint(Coord.y) + uint(Coord.x) + 1u) * uint(iFrame))\n\n#define UI8(V) uint(int(V) % 256)\n#define FUI8(V) float(UI8(V)) / 255.0\n\n\nstruct Config {\n    vec2 Offset;\n    float Zoom;\n    uint Mode;\n    uint AA;\n};\n\nConfig ParseConfig(in vec4 Data) {\n    Config NC;\n    NC.Offset = Data.xy;\n    NC.Zoom = Data.z > 0.0 ? Data.z : 1.0;\n    NC.Mode = uint(Data.w) & 0xFFu;\n    NC.AA = (uint(Data.w) >> 8) & 0xFFu;\n    \n    return NC;\n}\n\nvec4 SetConfig(in Config Data) {\n    return vec4(Data.Offset, Data.Zoom, float(Data.Mode + (Data.AA << 8)));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage(out vec4 FragColor, in vec2 FragCoord) {\n    Config C = ParseConfig(READP_V4(C_Storage, vec2(0, 0)));\n    \n    // Initial config\n    if (iFrame == 0) {\n        C.AA = 2u;\n        C.Mode = 1u;\n        C.Zoom = 0.1;\n        C.Offset = vec2(0.0);\n    }\n    \n    // Keycode Space\n    if (READP_V4(C_Keyboard, ivec2(32, 1)).x > 0.0) { C.Offset = vec2(0.0, 0.0); C.Zoom = 0.1; }\n    \n    // Keycode Q\n    if (C.Mode > 0u && READP_V4(C_Keyboard, ivec2(81, 1)).x > 0.0)\n        C.Mode--;\n        \n    // Keycode E\n    if (C.Mode < 4u && READP_V4(C_Keyboard, ivec2(69, 1)).x > 0.0)\n        C.Mode++;\n    \n    \n    // Keycode V\n    if (C.AA > 0u && READP_V4(C_Keyboard, ivec2(86, 1)).x > 0.0)\n        C.AA--;\n    \n    // Keycode B\n    if (C.AA < 4u && READP_V4(C_Keyboard, ivec2(66, 1)).x > 0.0)\n        C.AA++;\n\n    \n    float ZoomDelta = C.Zoom / 2.0;\n    float CameraDelta = 0.25 / ZoomDelta;\n    float Multiplier = float(iTimeDelta);\n    \n    float Zoom = ZoomDelta * Multiplier;\n    // Keycode Z\n    if (READP_V4(C_Keyboard, ivec2(90, 0)).x > 0.0)\n        C.Zoom += Zoom;\n        \n    // Keycode X\n    if (READP_V4(C_Keyboard, ivec2(88, 0)).x > 0.0)\n        C.Zoom -= Zoom;\n    \n    \n    float Camera = CameraDelta * Multiplier;\n    // Keycode W\n    if (READP_V4(C_Keyboard, ivec2(87, 0)).x > 0.0)\n        C.Offset.y += Camera;\n    \n    // Keycode S\n    if (READP_V4(C_Keyboard, ivec2(83, 0)).x > 0.0)\n        C.Offset.y -= Camera;\n        \n    // Keycode D\n    if (READP_V4(C_Keyboard, ivec2(68, 0)).x > 0.0)\n        C.Offset.x += Camera;\n    \n    // Keycode A\n    if (READP_V4(C_Keyboard, ivec2(65, 0)).x > 0.0)\n        C.Offset.x -= Camera;\n\n        \n    FragColor = SetConfig(C);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}