{
    "Shader": {
        "info": {
            "date": "1648320439",
            "description": "finally good drums.",
            "flags": 8,
            "hasliked": 0,
            "id": "7lfyRj",
            "likes": 26,
            "name": "Day 828",
            "published": 3,
            "tags": [
                "sound",
                "music",
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 387
        },
        "renderpass": [
            {
                "code": "// Reese from texture idea from 0b5vr.\n\n// so\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat message(vec2 uv) { // to alter in the icon\n    \n    uv.y += sin(acos(-1.)*iTime/beat + sin(acos(-1.)*iTime/beat*2.)*float(iTime > msr*2.));\n    \n    uv-=vec2(1.,10.); \n    uv -= vec2(16.,1.5);\n    uv.xy *= rot(sin(acos(-1.)*iTime/beat)*0.4*mod(iTime/beat,1.)*float(iTime > msr*2.));\n    \n    if(iTime > msr*4.)\n        uv *= 1. + sin(iTime*4.)*0.4;\n        \n    uv += vec2(16.,1.5);\n    if ((uv.x<0.)||(uv.x>=32.)||(uv.y<0.)||(uv.y>=3.)) return -1.; \n    int i=1, bit=int(pow(2.,floor(32.-uv.x)));\n    if (int(uv.y)==2) i=  928473456/bit; // 00110111 01010111 01100001 01110000\n    if (int(uv.y)==1) i=  626348112/bit; // 00100101 01010101 01010000 01010000\n    if (int(uv.y)==0) i= 1735745872/bit; // 01100111 01110101 01100001 01010000\n \treturn float(i-2*(i/2));\n}    \n   \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //  if (iResolution.y<200.) to display only in the icon \n    if (iResolution.y<2000.) {float c=message(fragCoord.xy/8.);if(c>=0.){fragColor=vec4(c);return;}}\n\t//tGlobal = iTime*2.;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.8+0.5*sin(iTime),1.0);\n    if(iTime > msr*6.)\n        fragColor = 0.5 + 0.5*sin(fragColor + iTime);\n\n}   ",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nfloat gt;\n\n\nFN(kick,\n    Time T = rep(t,bar,4.);\n    //T.te = t;\n    float env = exp(-T.te*14.);\n    float freq = 400. + 2300. * exp(-T.te*16.) + 0.78;\n    //freq = 1400. + 500.*exp(-T.te*10.);\n    freq = 400.*(1.  + exp(-T.te*13.)*3.);\n    float osc = sin(freq*T.te*1.\n        + sin(1200.*T.te)*exp(-T.te*40.)*1.\n    );\n    \n    s += osc*env;\n    /*\n    s = smoothify(s*1.,0.2);\n    s = smoothify(s*1.,0.2);\n    s = mix(s,smoothify(s*3.,1.),0.3 * exp(-T.te*45.));\n    */\n)\n\nFN(snare,\n    \n    Time T;\n    if(gt < msr*3.5)\n        T = rep(t + bar/4.,bar,8.);\n    else if(gt < msr*3.75)\n        T = rep(t + bar/4.,bar,16.);\n    else if(gt < msr*4.)\n        T = rep(t + bar/4.,bar,32.);\n    else\n        T = rep(t + bar/4.,bar,2.);\n    //T.te = t;\n    float env = exp(-T.te*50.);\n    float freq = 400. + 2400. * exp(-T.te*134.);\n    \n    float osc = sin(tau*freq*T.te*0.4 + 0.4*sin(T.te*800.)*exp(-T.te*4.));\n    \n    float oscb = sin(3000.*T.te + sin(7000.*T.te )*exp(-T.te*20.)*1. )*exp(-T.te*24.);\n    \n    float oscc = sin((33000.*exp(-T.te*40.)+ 11000.)*T.te + sin(17000.*T.te )*exp(-T.te*10.)*1. )*exp(-T.te*30.);\n    \n    s += osc*env + oscb*0.4 + oscc*0.1;\n    s -= lpnoise(T.te, 11400.*(0.03 + exp(-T.te*39.4)))*0.4*exp(-T.te*20.);\n    \n    //s = smoothify(s*0.5,0.4);\n    //s = powify(s,1.);\n)\n\nFN(hats,\n    Time T = rep(t,bar,8.);\n    \n    vec2 r = hash21(T.idl);\n    //T.te = t;\n    float env = exp(-T.te*(40. - r.y*10.));\n    float freq = 4400. + 1. * exp(-T.te*134.) + 2000. * float(chop(t,bar,8.) >= 4.) ;\n    vec2 n = lpnoise(T.te, 114400.*(1. + exp(-T.te*9.4)))*0.4*exp(-T.te*40.);\n    \n    vec2 osc = sin(\n        tau*freq*T.te*1. + \n        4.*sin(T.te*82000.)*exp(-T.te*10.) + \n        2.*sin(T.te*182000. - n*10.)*exp(-T.te*1.) + \n        n * 10.\n    );\n    \n    s += osc*env*0.4*smoothstep(0.,0.4,r.x);\n    \n    s = smoothify(s*1.,0.4);\n    //s = powify(s,1.);\n)\n\nFN(rides ,{\n    Time T = rep(t,bar,16.);\n    \n    vec2 r = hash21(T.idl);\n    r = vec2(1);\n    //T.te = t;\n    float env = exp(-T.te*(40. - r.y*10.));\n    float freq = 4400. + 1. * exp(-T.te*134.) + 7000. * float(chop(t,bar/4.,16.) >= 8.);\n    vec2 n = lpnoise(T.te, 114400.*(1. + exp(-T.te*9.4)))*0.4*exp(-T.te*40.);\n    \n    vec2 osc = sin(\n        tau*freq*T.te*1. + \n        4.*sin(T.te*12000.)*exp(-T.te*10.) + \n        2.*sin(T.te*12000. - n*10.)*exp(-T.te*1.) + \n        n * 10.\n    );\n    \n    s += osc*env*0.4*smoothstep(0.,0.4,r.x);\n    \n    s = smoothify(s*1.,0.4);\n    //s = powify(s,1.);\n\n})\n\n\nFN(chord,{\n\n    Time T = rep(t,bar,8.);\n    \n    vec4 chord = getChord(t);\n    for(float i = 0.; i < 4.; i++){\n        float freq = tau*note(chord[int(i)],3. + float(i == 2.));\n        float md = sin(freq*t*3.)*exp(-T.te*13.);\n        float osc = sin(freq*t + md*1.5); \n        s += osc/4.;\n    }\n})\n\nFN(amb,{\n\n    Time T = rep(t,bar,8.);\n    \n    vec4 chord = chords[0];;\n    \n    for(float i = 0.; i < 4.; i++){\n        float freq = note(chord[int(i)],4.);\n        //float md = sin(freq*t)*exp(-T.te*14.);\n        //float osc = sin(freq*t + md*4.); \n        //s += osc/4.;\n        \n        float iters = 3.;\n    \n        for(float i = 1.; i < iters; i++){\n            float idx = tau*freq*t + sin(i*2.3 + t*1.)*8.;\n                \n            vec2 p = (vec2(sin(idx),cos(idx + sin(i*1. - t*1.)*0.)) + 1.)*0.2;\n            vec2 osc = texture(iChannel0,p).xy*2. - 1.; \n            osc = mix(osc,vec2(sin(idx)),0.5); \n\n            //osc = smoothify(osc,vec2);\n            s += osc/iters*0.2;\n        }\n    }\n    \n\n})\n\n\nFN(chordSupersaw,{\n\n    Time T = rep(t,bar,8.);\n    \n    vec4 chord = getChord(t);\n    \n    for(float i = 0.; i < 4.; i++){\n        float freq = note(chord[int(i)],3.);\n        //float md = sin(freq*t)*exp(-T.te*14.);\n        //float osc = sin(freq*t + md*4.); \n        //s += osc/4.;\n        \n        float iters = 3.;\n    \n        for(float i = 1.; i < iters; i++){\n            float idx = tau*freq*t + sin(i*10.3 + t*3.)*2.;\n                \n            vec2 p = (vec2(sin(idx),cos(idx + sin(i*1. - t*1.)*0.)) + 1.)*0.4;\n            vec2 osc = texture(iChannel0,p).xy*2. - 1.; \n            osc = mix(osc,vec2(sin(idx)),0.);\n            \n\n            //osc = smoothify(osc,vec2);\n            s += osc/iters*1.;\n        }\n    }\n    \n    s *= smoothstep(0.,0.01,T.te);\n    s *= smoothstep(bar/8.,bar/8. - 0.05,T.te);\n\n})\n\n\n\nFN(bass,{\n\n    Time T = rep(t,bar,8.);\n    \n    vec4 chord = getChord(t);\n    float freq = note(chord[0],1. + 1.*float(mod(T.idl,3.) == 0.));\n    float md = sin(freq*t*4.)*exp(-T.te*14.);\n    \n    float iters = 150.;\n    \n    float f = 0.05 + 0.75 * exp(-T.te*(10. + sin(t*tau/beat*0.25)* 25.));// * sin(t*freq*0.5);\n    float wiggle = 0.05;\n    float q = 5.;\n    \n    for(float i = 1.; i < iters; i++){\n        float k = i < 10. ? i : i*2.;\n        //float k = i;\n        float osc = sin(tau*freq*t*k)*(mod(k,2.)*2. - 1.)/k; \n        if(i == 1.)\n            osc *= 5.;\n        float att = smoothstep(0. + f + wiggle,0. + f - wiggle,i/iters);\n        att *= 1. + smoothstep(wiggle,0.,abs(i/iters - f))*q;\n        s += osc*att;\n    }\n    \n    //s *= 2.;\n    s = mix(s,smoothify(s*1.,1.),0.2 );\n    s = mix(s,clampify(s*0.5,1.),1.);\n\n})\n\nFN(dubstep,{\n\n    Time T = rep(t,bar,8.);\n    \n    vec4 chord = getChord(t);\n    float freq = note(chord[0],1.);\n    float md = sin(freq*t*4.)*exp(-T.te*14.);\n    \n    float iters = 5.;\n    \n    for(float i = 1.; i < iters; i++){\n        float idx = tau*freq*t + sin(i*0.8 + t*3.)*0.3;\n        \n        vec2 p = (vec2(sin(idx),cos(idx + sin(i*1. - t*1.)*0.)) + 1.)*0.45;\n        vec2 osc = texture(iChannel0,p).xy*2. - 1.; \n        osc = mix(osc,vec2(sin(idx)),0.5); \n        \n        //osc = smoothify(osc,vec2);\n        s += osc/iters*2.;\n    }\n    \n    //s = mix(s,clampifyb(s*1.,1.),0.2);\n    //s *= 2.;\n    //s = mix(s,smoothify(s*1.,2.),1. );\n})\n\n\n\nFN(melody,{\n    Time T = rep(t,bar,16.);\n    \n    vec4 chord = chords[0 + int(T.idg)%4];\n    float freq = note(chord[int(T.idl)%4],3. + 1.*float(mod(T.idl,5.) == 0.)+ 1.*float(mod(T.idl,3.) == 0.));\n    freq *= 0.5;\n    float iters = 1.;\n    for(float i = 0.; i < iters; i++){\n        float idx = tau*freq*t + sin(i*0.5 + t*1.)*1.;\n        \n        idx += 1.*sin(freq*2.*t*tau)*exp(-T.te*4.);\n        //idx += sin(freq*2.*t*tau)*exp(-T.te*4.);\n        \n        vec2 osc = vec2(sin(idx));\n        \n        osc += sin(freq*4.*t*tau)*exp(-T.te*4.)*0.5;\n        osc += sin(freq*8./1.33*t*tau)*exp(-T.te*4.)*0.25;\n        osc += sin(freq*32.*0.75*t*tau)*0.2;\n        \n        osc = mix(osc,osc*sin(freq*t*tau*0.5)*2.,0.7);\n        //asdg\n        //vec2 p = (vec2(sin(idx),cos(idx + sin(i*1. - t*1.)*0.)) + 1.)*0.3;\n        //vec2 osc = texture(iChannel1,p).xy*2. - 1.;\n        //osc = mix(osc,vec2(sin(idx)),0.5); \n        //osc *= 3.;\n        //osc = mix(osc,powify(osc*1.,0.1),0.4 );\n        //osc = mix(osc,powify(osc*1.,0.1),0.4 );\n        //osc = mix(osc,powify(osc*1.,0.1),0.4 );\n        osc = mix(osc,vec2(sin(idx + sin(idx*3.)*2.*exp(-T.te*1.))),1.-exp(-T.te*5.));\n        \n        osc *= exp(-T.te*4.);\n        \n        \n        //osc = smoothify(osc,vec2);\n        s += osc/iters*0.3;\n    }\n    /*\n    float iters = 3.;\n    for(float i = 1.; i < iters; i++){\n        float idx = tau*freq*t + sin(i*0.5 + t*1.)*4.;\n        //asdg\n        vec2 p = (vec2(sin(idx),cos(idx + sin(i*1. - t*1.)*0.)) + 1.)*0.3;\n        vec2 osc = texture(iChannel1,p).xy*2. - 1.;\n        //osc = mix(osc,vec2(sin(idx)),0.5); \n        //osc *= 3.;\n        osc = mix(osc,powify(osc*1.,0.1),0.4 );\n        osc = mix(osc,powify(osc*1.,0.1),0.4 );\n        //osc = mix(osc,powify(osc*1.,0.1),0.4 );\n        osc = mix(osc,vec2(sin(idx + sin(idx*3.)*2.*exp(-T.te*1.))),1.-exp(-T.te*5.));\n        \n        osc *= exp(-T.te*4.);\n        \n        \n        //osc = smoothify(osc,vec2);\n        s += osc/iters*0.7; \n    }\n    */\n})\n\n \nvec2 mainSound( int samp, float t ){    \n    \n    gt = t = t + OFFS;\n    \n    vec2 s = vec2(0);\n\n    if(between(t,msr*11.5,msr*12.)){\n        //t = bitreduction(s,0.2);\n        t = sampleratereduction(t, 0.0002);\n    }\n\n\n    //s += sin(t*540.);\n    \n    // --- DRUMS --- //\n    vec2 k = kick(t);\n    reverb(kick,40.,.05,k,0.4);\n    k *= 1.;\n    float sidechain = 1.-exp(-mod(t,bar/4.)*10.);\n    \n    sidechain = abs(sidechain);\n    sidechain = pow(sidechain,4.);\n    vec2 sn = snare(t)*0.7;\n    reverb(snare,150.,.3,sn,0.2);\n    \n    \n    vec2 h = hats(t)*0.5;\n    reverb(hats,30.,.1,h,0.1);\n    \n    \n    vec2 rd = rides(t)*0.3;\n    reverb(rides,30.,.1,rd,0.1);\n    \n    if(t > msr*4.){\n        s += k;\n        s += sn;\n\n        s += h*sidechain;\n        if(t > msr*5.)\n            s += rd*sidechain;\n    } else if(t > msr*1. && t < msr*2. ){\n        s += rd*sidechain;\n    } else if(t > msr*2. && t < msr*3. ){\n        s += h*sidechain;\n    \n    } else if(t > msr*3. && t < msr*4. ){\n        s += h*sidechain;\n        s += sn*mix(\n            0.2,\n            smoothstep(0.,1.,mod(t/msr,1.)),\n            1.\n        );\n    \n    }\n    \n    \n    s = mix(s,smoothify(s*3.,1.),0.1 );\n    s = mix(s,smoothify(s*110.,1.),0.01 );\n    s = mix(s,smoothify(s*10.,0.5),0.06 );\n    \n    \n    // --- MELODY --- //\n    \n    vec2 ml = melody(t)*0.6*mix(1.,sidechain,0.2);\n    if(!(t < msr*3. || t > msr*7.)){\n        ml *= 0.;\n    } \n    float en = smoothstep(0.,1.,(t - msr*8.)/msr);\n    reverb(melody,40.,.2,ml,0.5 + float(t > msr*4.)*0.2*(1. - en) - float(t > msr*4.)*0.2);\n    ml = ml * smoothstep(0.,50.,t/msr) * (1.-float(t > msr*4.)*pow(1.-en,4.));\n    \n    if(t < msr*12.)\n        s += ml;\n    \n    \n    \n    //chorus(melody,2.,ml,0.5,0.2);\n    //s += ml*pow(sidechain,0.5)*1.;\n    \n    \n    vec2 ch = chord(t)*0.3;\n    chorus(chord,4.,ch,0.5,0.2);\n    vec2 chss = chordSupersaw(t)*0.3;\n    chorus(chordSupersaw,4.,chss,0.5*smoothstep(0.,1.,t/msr),0.2);\n    chss *= 0.5;\n    \n    \n    //reverb(chordSupersaw,10.,1.,chss,0.8);\n    \n    \n    if( chop(t,bar,4.) > 1. ){\n        if( (t > msr*6. && t < msr*8.) || (t > msr*3. && t < msr*3.75 ))\n            s += ch*sidechain*1.;\n    } else {\n        s += chss*pow(sidechain,2.)*1.;\n    \n    }\n    \n    vec2 a = amb(t);\n    \n    reverb(amb,10.,1.,a,1.);\n    s += a*1.*smoothstep(0.,msr,t - msr*3.)*float(t > msr*3.&& t < msr*4.);\n    \n    \n    // --- BASS --- //\n    \n    vec2 bs = bass(t)*0.4;\n    //chorus(bass,4.,bs,0.1);\n    \n    vec2 dbbs = dubstep(t)*0.4;\n    \n    if(between(t,msr*12.,msr*20.)){\n        if( chop(t,bar/1.,2.) > 0. ){\n            s += bs*pow(sidechain,1.5)*1.;\n        } else {\n            s += dbbs*sidechain*1.;\n        }\n    } else if(t > msr*4.){\n        \n        if( chop(t,bar,4.) < 3. ){\n            s += bs*pow(sidechain,1.5)*1.;\n        } else {\n            s += dbbs*sidechain*1.;\n        }\n    }\n    \n    \n    \n    \n    // --- MIX --- //\n    \n    s = mix(s,clampifyb(s,0.6)*1.,0.4);\n    \n    if(t < msr*4.){\n        s *= 0.8*(1.-0.*smoothstep(0.99,1.,t/(msr*4.)));\n    }\n    \n    float eee = smoothstep(0.,msr,t - msr*3.);\n    \n    // AM\n    if(t < msr*7.99)\n        s *= mix(1.,sin(t*(200.)),pow(smoothstep(0.,msr,t - msr*7.),3.));\n    \n    if(t < msr*4.)\n        s *= mix(1.,sin(t*(200. + eee*1500.)),pow(smoothstep(0.,msr,t - msr*3.),4.));\n    \n    \n    \n        \n        \n    s *= 0.6;\n    float clip = 1.;\n    s = clamp(s,-clip,clip)*clip;\n    s *= smoothstep(0.1,0.4,t);\n    //s = sign(s)*pow(abs(s),vec2(0.5));\n    return s;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    }
                ],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "\n\n\n#define OFFS msr*0.\n\n\n\n#define reverb(fn, iters, len, varname, amt) \\\n{                                       \\\n    vec2 res = vec2(0);                 \\\n    for(float i = 0.; i < iters; i++){   \\\n        float nois =  pow(i/iters,4.)*lpnoise(i/iters+1100., 11111.).x; \\\n        res += fn(t - (i/iters)*len - abs(nois)*0.2*len)/iters*pow(i/iters,2.)*(1.-i/iters); \\\n    }\\\n    varname = mix(varname,res/mix(1.,0.5,amt)*10.,amt); \\\n}\n\n#define chorus(fn, iters, varname, amt, len) \\\n{ \\\n    vec2 res = vec2(0);                 \\\n    for(float i = 0.; i < iters; i++){   \\\n        res += fn(t - sin(i/iters*pi*4.*t*0.001*len)*1.)/iters; \\\n    }\\\n    varname = mix(varname,res,amt); \\\n}\n\n\n#define PI acos(-1.)\n#define pi PI\n#define tau 2.*pi\n\n#define between(t,mn,mx) (t > mn && t < mx)\n\n#define bitreduction(s,amt) s = sign(s) * floor(abs(s)/(amt))*(amt)\n#define sampleratereduction(t, amt) t = floor(t/(amt))*(amt)\n//#define smoothify(s, amt) mix(s,sign(s)*smoothstep(0.0,1.,abs(s)), amt)\n#define clampify(s, amt) clamp(s*amt,-1.,1.)/amt\n#define clampifyb(s, amt) clamp(s,-amt,amt)/amt\n\n#define smoothify(s, amt) sign(s)*mix(abs(s),smoothstep(0.,1.,s), amt)\n\n#define powify(s, amt) sign(s)*pow(abs(s),vec2(amt))\n\n\n#define bpm (150.)\n\n#define tick (60./bpm)\n\n#define beat (tick)\n#define bar  (beat*4.)\n#define hbar  (bar/2.)\n#define msr  bar*4.\n#define hbeat tick/2.\n#define qbeat tick/4.\n\n\n#define chop(t,bt,reps) mod(floor(t/(bt/reps)), reps)\n\n\n#define FN(name, code) vec2 name(float t) { \\\n    vec2 s = vec2(0); \\\n    code \\\n    return s; \\\n}\n\n\n\nstruct Time {\n    float tt;\n    float te;\n    float idl;\n    float idg;\n};\n\nTime rep(float t, float period, float reps){\n    Time data;\n    float per = period/reps;\n    data.te = mod(t,per);\n    data.idl = mod(floor(t/per),reps);\n    data.idg = floor(t/period);\n        \n    return data;\n}\n\n\n\n\nfloat note(float note, float octave){ \n\treturn 27.5*exp2(((octave*12. ) + note )/12.);//pow(2., );\n}\n\n\nfloat[] notesLB = float[8](2.,1.,0.,2.,0.,2.,0.,3.);\nint[] notesB = int[8](0,1,2,3,0,1,2,3);\n\nconst float scale = -4.;\n\nconst vec4 cmin9 = vec4(0.,3.,10.,14.) + scale;\n\nconst vec4 cmin510 = vec4(0.,7.,10.,12.) + scale;\nconst vec4 cmin7 = vec4(0.,3.,7.,10.) + scale;\nconst vec4 cmin73 = vec4(0.,7.,10.,3.) + scale;\nconst vec4 cmin11 = vec4(0.,10.,14.,17.) + scale;\nconst vec4 cmaj9 = vec4(0.,4.,7.,14.) + scale;\nconst vec4 cmaj7 = vec4(0.,4.,7.,11.) + scale;\nconst vec4 cmaj14 = vec4(0.,4.,11.,12. + 7.) + scale;\nconst vec4 cmaj7f15 = vec4(0.,4.,6.,11.) + scale;\nconst vec4 cmaj7d = vec4(0.,4.,7.,10.) + scale;\nconst vec4 cmin7maj = vec4(0.,3.,7.,11.) + scale;\n\nconst int chordCnt = 8;\n\n\nvec4[] chords = vec4[chordCnt](\n    cmaj9 - 4.,\n    cmin73 - 7.,\n    cmin11 - 5.,\n    cmin7,\n    cmin11,\n    cmaj14 + 1. - 7.,\n    cmaj7 - 1.,\n    cmaj7 - 5.\n);\n\nvec4[] chordsbb = vec4[chordCnt](\n    cmin11,\n    cmaj14 + 2. - 7.,\n    cmin7 - 2.,\n    cmaj7 + 1.,\n    cmaj14 - 3.,\n    cmaj7f15 + 3.,\n    cmin9 + 2. - 4.,\n    cmaj7f15 - 4.\n);\n\nvec4[] chordsb = vec4[chordCnt](\n    cmin9,\n    cmaj7 + 1.,\n    cmaj7f15 - 2.,\n    cmaj7 - 3.,\n    cmaj14 - 2.,\n    cmaj7f15 + 3.,\n    cmaj9 - 1.,\n    cmaj7f15 - 4.\n);\nvec4[] chordsa = vec4[chordCnt](\n    cmin9,\n    cmaj7f15 - 2.,\n    cmaj9 - 3.,\n    cmin7maj - 5.,\n    cmaj14 - 2.,\n    cmaj7f15 + 3.,\n    cmaj9 - 1.,\n    cmaj7f15 - 2.\n);\n\nvec4 getChord(float t){\n    return chords[ int(t / bar) % 4];\n}\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec2 lpnoise(float t, float fq)\n{\n    t *= fq;\n\n    float ft = fract(t);\n    float tn = floor(t);\n    ft = smoothstep(0.0, 1.0, ft);\n\n    vec2 n0 = hash21(tn / fq*2000.);\n    vec2 n1 = hash21((tn + 1.0) / fq*2000.);\n\n    return mix(n0, n1, ft)*2. - 1.;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}