{
    "Shader": {
        "info": {
            "date": "1609613860",
            "description": " helps you choose the right easing function.",
            "flags": 0,
            "hasliked": 0,
            "id": "wtcczf",
            "likes": 12,
            "name": "Easing functions",
            "published": 3,
            "tags": [
                "learn"
            ],
            "usePreview": 0,
            "username": "bbsuuo",
            "viewed": 2174
        },
        "renderpass": [
            {
                "code": "float PI = 3.1415926;\n\nfloat plot(vec2 uv,float pct){\n return smoothstep(pct - 0.01,pct, uv.y) - smoothstep(pct ,pct + 0.01,uv.y);\n}\n\nfloat lerp(float a, float b, float f) \n{\n    return (a * (1.0 - f)) + (b * f);\n}\n\n//Sine\nfloat EaseInSine(float x)\n{\n    return 1.0 - cos((x * PI) / 2.0);\n}\n\nfloat EaseOutSine(float x)\n{\n    return sin((x * PI) / 2.0);\n}\n\nfloat EaseInOutSine(float x)\n{ \n    return -(cos(PI * x) - 1.0) / 2.0;\n}\n\n//Quad\nfloat EaseInQuad(float x)\n{\n   return x * x;\n}\n\nfloat EaseOutQuad(float x)\n{\n  return 1.0 - (1.0-x) * (1.0 -x );\n}\n\nfloat EaseInOutQuad(float x)\n{\n   //x < 0.5f ? 2 * x* x : 1 - pow(-2 * x + 2,2) /2;\n   float inValue = 2.0 * x  *x;\n   float outValue = 1.0- pow(-2.0 * x + 2.0,2.0) / 2.0;\n   float inStep = step(inValue,0.5) * inValue;\n   float outStep = step(0.5 , outValue ) * outValue;\n   \n   return inStep + outStep;\n}\n\n//Cubic\nfloat EaseInCubic(float x)\n{\n   return x * x * x;\n}\n\nfloat EaseOutCubic(float x)\n{ \n   return 1.0 - pow(1.0 - x,3.0);\n}\n\nfloat EaseInOutCubic(float x)\n{\n  //x < 0.5f ? 4.0f * x * x * x : 1 - Mathf.Pow(-2 *x + 2,3)/2;\n  float inValue = 4.0 * x * x * x;\n  float outValue = 1.0 -pow(-2.0 * x + 2.0 ,3.0) /2.0;\n  return step(inValue , 0.5) * inValue + step(0.5,outValue) * outValue;\n}\n\n//Quart\nfloat EaseInQuart(float x)\n{\n return x * x * x * x;\n}\n\nfloat EaseOutQuart(float x)\n{\n  return 1.0 - pow(1.0 -x, 4.0);\n}\n\nfloat EaseInOutQuart(float x)\n{\n  //x < 0.5 ? 8 * x * x * x * x : 1 - pow(-2 * x + 2, 4) / 2;\n  float inValue = 8.0 * x * x * x * x;\n  float outValue = 1.0 - pow(-2.0 * x + 2.0, 4.0) / 2.0;\n  return step(inValue , 0.5) * inValue + step(0.5,outValue) * outValue;\n}\n\n//Quint\nfloat EaseInQuint(float x)\n{\n   return x * x * x * x * x;\n}\n\nfloat EaseOutQuint(float x)\n{\n   return 1.0 - pow(1.0 - x , 5.0);\n}\n\nfloat EaseInOutQuint(float x)\n{\n  //  x < 0.5 ? 16 * x * x * x * x * x : 1 - pow(-2 * x + 2, 5) / 2;\n  float inValue = 16.0 * x * x * x * x * x;\n  float outValue = 1.0 - pow(-2.0 * x + 2.0, 5.0) / 2.0;\n  return step(inValue , 0.5) * inValue + step(0.5,outValue) * outValue;\n}\n\n//Expo\nfloat EaseInExpo(float x)\n{\n  return pow(2.0, 10.0 * x - 10.0);\n}\n\nfloat EaseOutExpo(float x)\n{  \n  return 1.0 - pow(2.0, -10.0 * x);;\n}\n\nfloat EaseInOutExpo(float x)\n{\n  float inValue = pow(2.0, 20.0 * x - 10.0) / 2.0;\n  float outValue = (2.0 - pow(2.0, -20.0 * x + 10.0)) / 2.0;\n  return step(inValue , 0.5) * inValue + step(0.5,outValue) * outValue;\n}\n\n//Circ\nfloat EaseInCirc(float x)\n{\n return 1.0 - sqrt(1.0 - pow(x, 2.0));\n}\n\nfloat EaseOutCirc(float x)\n{\n return sqrt(1.0 - pow(x - 1.0, 2.0));\n}\n\nfloat EaseInOutCirc(float x)\n{\n  //x < 0.5 ? (1 - sqrt(1 - pow(2 * x, 2))) / 2 : (sqrt(1 - pow(-2 * x + 2, 2)) + 1) / 2;\n  float inValue = (1.0 - sqrt(1.0 - pow(2.0 * x, 2.0))) / 2.0 * step(x,0.5);\n  float outValue = (sqrt(1.0 - pow(-2.0 * x + 2.0, 2.0)) + 1.0) / 2.0 * step(0.5,x);\n  return step(inValue , 0.5) * inValue + step(0.5,outValue) * outValue;\n}\n\n//Back\nfloat backC1 = 1.70158;\nfloat backC2 = 2.5949095;\nfloat backC3 = 2.70158;\n\nfloat EaseInBack(float x)\n{\n  return backC3 * x * x * x - backC1 * x * x;\n}\n\nfloat EaseOutBack(float x)\n{\n   return  1.0 - backC3 * pow(x - 1.0, 3.0) + backC1 * pow(x - 1.0, 2.0);\n}\n\nfloat EaseInOutBack(float x){\n //x < 0.5 ? (pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2: (pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;\n  float inValue = (pow(2.0 * x, 2.0) * ((backC2 + 1.0) * 2.0 * x - backC2)) / 2.0;\n  float outValue = (pow(2.0 * x - 2.0, 2.0) * ((backC2 + 1.0) * (x * 2.0 - 2.0) + backC2) + 2.0) / 2.0;\n  return step(inValue , 0.5) * inValue + step(0.5,outValue) * outValue;\n  \n}\n\n//Elastic\nfloat EaseInElastic(float x)\n{\n float c4 = (2.0 * PI) / 3.0;\n return -pow(2.0, 10.0 * x - 10.0) * sin((x * 10.0 - 10.75) * c4);\n}\n\nfloat EaseOutElastic(float x)\n{\n float c4 = (2.0 * PI) / 3.0;\n return pow(2.0, -10.0 * x) * sin((x * 10.0 - 0.75) * c4) + 1.0;;\n}\n\nfloat EaseInOutElastic(float x)\n{\n//x < 0.5 ? -(pow(2, 20 * x - 10) * sin((20 * x - 11.125) * c5)) / 2: (pow(2, -20 * x + 10) * sin((20 * x - 11.125) * c5)) / 2 + 1;\n  float c5 = (2.0 * PI) / 4.5;\n  float inValue = ( -(pow(2.0, 20.0 * x - 10.0) * sin((20.0 * x - 11.125) * c5)) / 2.0 )* step(x,0.5);\n  float outValue = ((pow(2.0, -20.0 * x + 10.0) * sin((20.0 * x - 11.125) * c5)) / 2.0 + 1.0 )* step(0.5,x);\n  return step(inValue , 0.5) * inValue + step(0.5,outValue) * outValue;\n}\n\n//Bounce\nfloat EaseOutBounce(float x)\n{\n  float n1 = 7.5625;\n  float d1 = 2.75;\n  float step1 = step(x,1.0/d1);\n  float step2 = step(x, 2.0 /d1) - step1;\n  float step3 = step(x, 2.5 / d1) - step2 - step1;\n  float step4 = 1.0 - step3 - step2 - step1;\n   \n  float value = x;\n  float p0 = (n1 * x * x)* step1 ;\n  value = x - (1.5 / d1);\n  float p1 = (n1 * value * value + 0.75) * step2 ;\n  value = x - (2.25 / d1);\n  float p2 = (n1 * value * value + 0.9375) * step3;\n  value = x - (2.625  / d1);\n  float p3 = (n1 * value * value + 0.984375) * step4;\n  return p0 + p1 + p2 + p3;\n}\n\nfloat EaseInBounce(float x)\n{\n  return 1.0 - EaseOutBounce(1.0 - x);\n}\n\nfloat EaseInOutBounce(float x)\n{\n//x < 0.5 ? (1 - easeOutBounce(1 - 2 * x)) / 2: (1 + easeOutBounce(2 * x - 1)) / 2;\n  float inValue = (1.0 - EaseOutBounce(1.0 - 2.0 * x)) / 2.0 * step(x,0.5);\n  float outValue =  (1.0 + EaseOutBounce(2.0 * x - 1.0)) / 2.0 * step(0.5,x);\n  return step(inValue , 0.5) * inValue + step(0.5,outValue) * outValue;\n}\n\n\nfloat RunSineEase(float x){\n  float value = sin(iTime) * 0.5 + 0.5;\n  return lerp(EaseInSine(x) ,EaseOutSine(x) , value);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy)/(iResolution.xy);\n    \n    //change this function and draw ease line\n    float y = RunSineEase(uv.x);\n    \n    \n    \n    vec3 color = vec3(y); \n    //plot a line\n    float pct = plot(uv,y); \n    //line color\n    vec3 green = vec3(0.0,1.0,0.0); \n    //render line and color\n    color = (1.0 - pct) * color +  pct * green;\n   \n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}