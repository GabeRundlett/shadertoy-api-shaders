{
    "Shader": {
        "info": {
            "date": "1583269455",
            "description": "Gravity simulator based on simulating mass body trajectories in 4D according to gravity law. Bodies gradually escape from the system over time as is inevitable for systems with more than 2 bodies.\n\nBackground illustrates 2D gravity force field.",
            "flags": 32,
            "hasliked": 0,
            "id": "3lVXz3",
            "likes": 20,
            "name": "N-body gravity simulation",
            "published": 3,
            "tags": [
                "simulation",
                "physics",
                "gravity"
            ],
            "usePreview": 0,
            "username": "olli666",
            "viewed": 872
        },
        "renderpass": [
            {
                "code": "// Gravity simulator. Written by Olli Parviainen\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n//\n// mainImage() renders the image using trajectory data from iChannel0\n// a.k.a Buffer A that calculates body trajectories according to gravity law\n//\n// data stored to texels, one body per x-coordinate\n// - coord y=0 : body XYZ + size data\n// - coord y=1 : body velocity XYZ data\n\n\nconst int BODIES = 50;\t// note: if change number of bodies, update it also to Buffer A page\n\nconst float PI = 3.1415926536;\nconst float PI2 = 2.0 * PI;\nconst float MINVAL = -1000.0;\n\nconst vec3 AMBIENT_LIGHT = 0.4 * normalize(vec3(0.5, -0.5, -1.0));\n\nconst vec4 SUN_COLOR = vec4(1,1,0,0);\n\n\nvec4 getBodyPosSize(in int bodyNum)\n{\n    return texelFetch(iChannel0, ivec2(bodyNum, 0), 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord/min(iResolution.x, iResolution.y) - vec2(iResolution.x/iResolution.y, 1.0);\n    float grid = iResolution.y / 25.0;\n\n    float min_z = MINVAL;\n    vec2 force = vec2(0.0);\n\n    vec4 body0 = getBodyPosSize(0);\n    // render bodies\n    for (int i = 0; i < BODIES; i ++) {\n        // scale body coords&size according to z\n        // To do: \n        // - could recalculate \"scale\" or \"bodyScaled\" already in Buffer A\n        //   as they're now recalculated here in every pixel \n        vec4 body = getBodyPosSize(i);\n        float scale = 1.0 / (1.0 - body.z);\n        if (scale < 0.0) \n\t        // behind camera\n            continue;\n\n        vec4 bodyScaled = scale * body;\n\n        // calculate body visual radius \n        vec2 diff = bodyScaled.xy - uv;\n        float R = dot(diff,diff);\n        force += scale * pow(body.w,3.0) * diff / R;        \n        float radius2 = bodyScaled.w * bodyScaled.w;\n\n        if (R < radius2) {\n            // calculate z-coordinate of the surface\n            float z = sqrt(radius2 - R);       \n            if (body.z + z < min_z)\n                // surface point is behind what's already rendered\n                continue;\n            min_z = body.z + z;\n\n            // draw body\n            if (i == 0) {\n                // central body\n\t            float lum = (1.0 - R / radius2);\n                fragColor = vec4(lum) + 0.5 * SUN_COLOR;\n            } \n            else \n            {\n                // other bodies: choose color\n                vec3 angle = vec3(i) + vec3(0.0, 0.3333, 0.6666) * PI2;            \n                vec3 color=0.5+0.5*cos(angle);\n                fragColor = vec4(color, 1);\n\n                // diffuse surface lighting from central body + ambient\n                vec3 surface = vec3(diff, -z);\n                vec3 surface_norm = normalize(surface);\n                vec3 bodySurface = body.xyz - surface;\n                vec3 vecToBody0 = bodySurface - body0.xyz;\n                float distToBody0 = clamp(length(vecToBody0) - body0.w, 1e-4,1e4);\n                float intensity = dot(surface_norm, normalize(vecToBody0)) / distToBody0;\n                intensity = 0.5 * clamp(0.2 + intensity, 0.0, 2.0);\n\n                // direct reflection from central body\n                vec3 vreflect = normalize(reflect(vec3(0,0,1), surface_norm));\n                float reflectCrossBody0 = length(vreflect * length(vecToBody0) - vecToBody0);\n                if (reflectCrossBody0 < body0.w) {\n                    intensity += 0.2 / reflectCrossBody0;\n                }\n                \n                fragColor *= dot(surface_norm, AMBIENT_LIGHT) + \n                    intensity;\n            }\n        }\n    }\n    if (min_z == MINVAL) \n    {\n        // render background grid. The force field used to distort background\n        // is not physically quite accurate, yet squared field in 2D looks\n        // nicer than true grabity field\n        vec2 coord = fragCoord - 2e2 * force.xy * grid;\n        coord = mod(coord, grid);\n        float color = 0.0;\n        \n        if (coord.x < 2.0) {\n            color += (coord.x > 1.0) ? 2.0 - coord.x : coord.x;\n        }\n        if (coord.y < 2.0) {\n            color += (coord.y > 1.0) ? 2.0 - coord.y : coord.y;\n        }\n        \n        fragColor=vec4(0.8*sqrt(color));\n        // to display 2D gravity field\n        // fragColor += clamp((round(sqrt(dot(force, force))*2e3)-3.0) * 0.05, 0.0, 0.6);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Gravity simulator. Written by Olli Parviainen\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n//\n// The Buffer A calculates body trajectories according to gravity physics.\n//\n// data stored to texels, one body per x-coordinate\n// - coord y=0 : body XYZ + Size data\n// - coord y=1 : body velocity XYZ data\n\nconst int BODIES = 50; // note: if change number of bodies, update it also to Buffer A page\n\nconst float GRAVITY_COEFF = 1000.0;\nconst float UPDATE_STEP = 0.005;\nconst float PI = 3.1415926536;\n\nvec4 getBodyPosSize(in int bodyNum)\n{\n    return texelFetch(iChannel0, ivec2(bodyNum, 0), 0);\n}\n\n\nvoid getBodyPosVel(in int bodyNum, out vec4 XYZW, out vec3 velXYZ)\n{\n    XYZW = texelFetch(iChannel0, ivec2(bodyNum, 0), 0);\n    velXYZ = texelFetch(iChannel0, ivec2(bodyNum, 1), 0).xyz;\n}\n    \n\n// initialize data\nvoid init(in int body, out vec4 XYZW, out vec3 velXYZ) \n{    \n    vec4 times = vec4(iTime) + vec4(body, float(body) + 0.5 * PI, 4*body, 15*body);\n        \n    XYZW = (cos(times) + vec4(0,0,0,1.5)) * vec4(0.5, 0.5, 0.05, 0.02);\n    velXYZ = 1.4*sin(times.xyz);\n    if (body == 0) {\n        XYZW = vec4(0.0,0.0,0.0,0.1);\n        velXYZ = vec3(0);\n    }\n}\n\n// calculate acceleration due to gravity\nvec3 calculate_gravity_accel(in int curBodyNum, in vec4 bodyXYZW, float dTimeAdvance)\n{\n    vec3 accelVec = vec3(0.0);\n    float bodySize = bodyXYZW.w;\n        \n    for (int i = 0; i < BODIES; i ++) {\n        if (i == curBodyNum) continue;\n        vec4 otherXYZW;\n        vec3 otherVelXYZ;\n        getBodyPosVel(i, otherXYZW, otherVelXYZ);\n        \n        otherXYZW += dTimeAdvance * vec4(otherVelXYZ.xyz, 0);\n        \n        vec3 diff = otherXYZW.xyz - bodyXYZW.xyz;\n        float R = sqrt(dot(diff, diff));\n        float otherSize = pow(otherXYZW.w, 3.0);\n        float accel = otherSize / R; \n        \n        accelVec += normalize(diff) * accel;\n    }\n    return GRAVITY_COEFF * accelVec;\n}\n\n\n// euler: simplest trajectory update method\nvoid update_trajectory_euler(in int body, out vec4 XYZW, out vec3 velXYZ)\n{\n    vec4 bodyXYZW;\n    vec3 bodyVelXyz;\n    getBodyPosVel(body, bodyXYZW, bodyVelXyz);\n    \n    vec3 accelVec = calculate_gravity_accel(body, bodyXYZW, 0.0);\n    \n    velXYZ = bodyVelXyz + UPDATE_STEP * accelVec;\n    XYZW = bodyXYZW + UPDATE_STEP * 0.5 * vec4(bodyVelXyz + velXYZ.xyz, 0.0);\n}\n\n\n// heun: two-stage trajectory update method, better than euler\nvoid update_trajectory_heun(in int body, out vec4 XYZW, out vec3 velXYZ)\n{\n    vec4 bodyXYZW;\n    vec3 bodyVelXyz;\n    getBodyPosVel(body, bodyXYZW, bodyVelXyz);\n    \n    // step 1\n    vec3 accelVec1 = calculate_gravity_accel(body, bodyXYZW, 0.0);       \n    vec3 velXYZ1 = bodyVelXyz + UPDATE_STEP * accelVec1;\n    XYZW = bodyXYZW + UPDATE_STEP * 0.5 * vec4(bodyVelXyz + velXYZ1, 0);\n\n    // step 2\n    vec3 accelVec2 = calculate_gravity_accel(body, XYZW, UPDATE_STEP);    \n    vec3 accelVec_mid = 0.5 * (accelVec1 + accelVec2);\n    \n    velXYZ = bodyVelXyz + UPDATE_STEP * accelVec_mid;       \n    XYZW = bodyXYZW + UPDATE_STEP * 0.5 * vec4(bodyVelXyz + velXYZ, 0.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 XYZW;\n    vec3 velXYZ;\n    ivec2 xy = ivec2(floor(fragCoord));\n\n    if ((xy.y > 1) || (xy.x > BODIES))\n        // nothing to do, release GPU early for other work\n        return;\n    \n    int bodyNum = xy.x;\n    \n    if (iFrame == 0) {\n        // initialize data\n        init(bodyNum, XYZW, velXYZ);\n    } else {\n        // update trajectory\n        update_trajectory_heun(bodyNum, XYZW, velXYZ);\n        \n        if (bodyNum == 0) {\n            // weakly pull the body #0 towards centre to keep the system centralized on display\n            // while minimizing impact to overall system\n            vec3 diff = vec3(0.0) - XYZW.xyz;\n            velXYZ = mix(velXYZ, diff, 0.02);\n        }\n    }\n    \n    // store data to output texels\n    if (xy.y == 0) {\n\t    fragColor = XYZW;\n    } else {\n\t    fragColor = vec4(velXYZ, 0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}