{
    "Shader": {
        "info": {
            "date": "1598383644",
            "description": "One more day.",
            "flags": 0,
            "hasliked": 0,
            "id": "3lBfRD",
            "likes": 5,
            "name": "#857 - Daily Experiments",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "experiments",
                "daily"
            ],
            "usePreview": 0,
            "username": "sixclones",
            "viewed": 261
        },
        "renderpass": [
            {
                "code": "// Inspired by: https://www.youtube.com/watch?v=-adHIyjIYgk\n// From BigWIngs: https://www.shadertoy.com/user/BigWIngs\n\n#define QP 0.785398163397448\n#define TRP 1.047197551196598\n#define HP 1.570796326794897\n#define P 3.141592653589793\n#define TP 6.283185307179586\n\n#define t 1.25 * iTime\n#define ht 0.5 * t\n#define tt 0.1 * t\n\n#define EPS 0.001\n#define STEPS 128.0\n#define DIST 0.01\n\n#define S(a, b, t) smoothstep(a, b, t)\n\nfloat map(float n, float start1, float stop1, float start2, float stop2) {\n  return (n - start1) / (stop1 - start1) * (stop2 - start2) + start2;\n}\n\nfloat map01(float n, float start2, float stop2) {\n  return (0.5 * n + 0.5) * (stop2 - start2) + start2;\n}\n\nvec2 rotate2d(vec2 uv, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat2(c, -s, s, c) * uv;\n}\n\nfloat circleSDF(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat gyroidSDF(vec3 p, float s, float th) {\n  p *= s;\n  return abs(dot(sin(t + p), cos(-t + p.zxy))) / s - th;\n}\n\nfloat sceneSDF(vec3 p) {\n  vec3 _p = p;\n\n  float circle = circleSDF(p, 3.0);\n\n  p.y += t + cos(t);\n  p.z += t + sin(t);\n  float gyroid = gyroidSDF(p, 2.5, 0.025);\n\n  return max(circle, 0.5 * gyroid);\n}\n\nvec3 computeNormal(vec3 p) {\n  float center = sceneSDF(p);\n  vec3 offset = vec3(0.0, EPS, 0.0);\n\n  return normalize(vec3(\n    center - sceneSDF(p + offset.yxx),\n    center - sceneSDF(p + offset.xyx),\n    center - sceneSDF(p + offset.xxy)\n  ));\n}\n\nvec3 computeSurface(vec3 pos, float f) {\n  vec3 normal = computeNormal(pos);\n\n  vec3 lightPos = vec3(1.0, 2.0, 3.0);\n  vec3 lightColor = vec3(0.3922, 0.6157, 0.8275);\n  float light = max(0.0, dot(normal, lightPos));\n\n  vec3 ambient = vec3(0.1255, 0.0039, 0.0667);\n\n  float fog = 5.0 / pow(f, 2.0);\n\n  return fog * light * lightColor + ambient;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n  vec3 color = vec3(0.8235, 0.9608, 0.9373);\n\n  vec3 rd = normalize((vec3(uv, 1.0)));\n  vec3 ro = vec3(0.0, 0.0, -7.5);\n\n  float angle = -0.5 * QP;\n  rd.yz = rotate2d(rd.yz, angle);\n  ro.yz = rotate2d(ro.yz, angle);\n\n  float f = 10.0 / STEPS;\n  for (float i = 0.0; i < STEPS; i++) {\n    vec3 pos = ro + f * rd;\n    float scene = sceneSDF(pos);\n    if (scene < DIST) {\n      color = computeSurface(pos, f);\n      break;\n    }\n    f += scene;\n  }\n\n  fragColor = vec4(pow(color, vec3(1.0/2.2)), 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}