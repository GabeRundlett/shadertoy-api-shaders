{
    "Shader": {
        "info": {
            "date": "1656899122",
            "description": "Today I tried to create a circle, fixed the UV aspect ratio and a bug in the cycle function.\n\nI studied a bit about convert Paremetric to Rectangular functions and tried to implement it, by trying to transform (cos(t), sin(t)) into a Rectangular function.",
            "flags": 0,
            "hasliked": 0,
            "id": "sd3fzX",
            "likes": 1,
            "name": "003 - Trying to create a circle",
            "published": 3,
            "tags": [
                "beginner",
                "sin",
                "circle",
                "cos",
                "learning"
            ],
            "usePreview": 0,
            "username": "PiGIon",
            "viewed": 232
        },
        "renderpass": [
            {
                "code": "// 2022.07.03 rev 1\n\n#define PI 3.14159265\n#define TWOPI 6.2831853\n\n// https://www.wolframalpha.com/input?i=f%28x%29%3D0.5%2B%28cos%28%28%28x%2B0.5%2F1%29*20*1%29%2F%28PI%29%29%2F2.%29\nfloat cycle(float perSecond) {\n    // doing this multiplication, we make the animation % grow by perSecond factor\n    // iTime is the current time + timeDelta for precision\n    // _____________________________\n    // | iTime | perSecond |   d   |\n    // |_______|___________|_______|\n    // |0.1    |1          |0.1    |\n    // |0.2    |1          |0.2    |\n    // |0.45   |1          |0.45   |\n    // |0.5    |1          |0.5    |\n    // |_______|___________|_______|\n    // _____________________________\n    // | iTime | perSecond |   d   |\n    // |_______|___________|_______|\n    // |0.1    |2          |0.2    |\n    // |0.2    |2          |0.4    |\n    // |0.45   |2          |0.9    |\n    // |0.5    |2          |0      |\n    // |_______|___________|_______|\n    // _____________________________\n    // | iTime | perSecond |   d   |\n    // |_______|___________|_______|\n    // |0.1    |0.5        |0.05   |\n    // |0.2    |0.5        |0.1    |\n    // |0.45   |0.5        |0.225  |\n    // |0.5    |0.5        |0.25   |\n    // |_______|___________|_______|\n\n\n    float x = (iTime + iTimeDelta) * perSecond;\n    float d = x - floor(x);\n    \n    if (d > 0.5) {\n        d = (1. - d); // reverse the keyframe, go back to start\n    }\n    \n    // since the cut point is 0.5, we need to get original place (e.g. 1 again) if d is exactly to 0.5\n    // this means that it cycles from 0...1...0 every second\n    d *= 2.;\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2. - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float r,g,b = 0.0;\n\n    // if the coord is inside a circle function...\n    if (step(pow(cos(uv.x*TWOPI), 2.) + pow(sin(uv.y*TWOPI), 2.), 2.*cycle(0.3)) == 1.) {\n        r = 0.;\n        g = 0.64;\n        b = 0.81;\n    } else if (step(cos(uv.x) + sin(uv.y), 2.*cycle(0.1)) == 1.) {\n        r = 0.14;\n        g = 0.63;\n        b = 0.55;\n    } else {\n        r = 0.;\n        g = 0.30;\n        b = 0.39;\n    }\n\n    fragColor = vec4(\n        r,\n        g, \n        b, \n        1\n    );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}