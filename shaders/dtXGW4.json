{
    "Shader": {
        "info": {
            "date": "1672092769",
            "description": "It took a few hours to build, and a few days to adjust everything to balance properly.\n\n",
            "flags": 8,
            "hasliked": 0,
            "id": "dtXGW4",
            "likes": 80,
            "name": "Rough Seas ",
            "published": 3,
            "tags": [
                "3d",
                "waves",
                "raymarch",
                "sound",
                "sea",
                "ocean",
                "foam",
                "rough",
                "spray",
                "whitecaps"
            ],
            "usePreview": 0,
            "username": "Dave_Hoskins",
            "viewed": 2030
        },
        "renderpass": [
            {
                "code": "// Rough Seas, by Dave Hoskins.\n// https://www.shadertoy.com/view/dtXGW4\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// By David Hoskins, 2022.\n\n// Inspiration was from: https://www.istockphoto.com/search/more-like-this/882229368?assettype=film&phrase=rough%20sea\n\n\n#define FAR 1000.\n#define FOG_COLOUR vec3(.33,.3,.3)\n#define SKY_TOP vec3(.1, .13, 0.13)\n\nvec3 camPos;\nfloat time;\nvec3 skyColour;\nconst vec3 sunDir = normalize(vec3(4,8,18));\n//#define EXPORT_VERSON\n\n//------------------------------------------------------------------------------\n// Hashes from here: https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n// Pretty basic smoothed noise overridden as 2D & 3D...\n//------------------------------------------------------------------------------\nfloat noise(in vec2 p)\n{\n\tvec2 f = fract(p);\n    p = floor(p);\n    f = f * f * (3.0 - 2.0 * f);\n    float res = mix(mix(hash12(p),\n\t\t\t\t\t\thash12(p + vec2(1.0, 0.0)), f.x),\n\t\t\t\t\tmix(hash12(p + vec2(0.0, 1.0)),\n\t\t\t\t\t\thash12(p + vec2(1.0, 1.0)), f.x), f.y);\n    return res;\n}\n\nfloat noise(in vec3 p)\n{\n    const vec2 add = vec2(1.0, 0.0);\n\n    vec3 f = fract(p); \n    f *= f * (3.0-2.0*f);\n    p = floor(p);\n\n    float h = mix(\n                    mix(mix(hash13(p), hash13(p + add.xyy),f.x),\n                        mix(hash13(p + add.yxy), hash13(p + add.xxy),f.x), f.y),\n                    mix(mix(hash13(p + add.yyx), hash13(p + add.xyx),f.x),\n                        mix(hash13(p + add.yxx), hash13(p + add.xxx),f.x), f.y),\n                 f.z);\n    return h*h*h*2.;\n}\n\n\n//------------------------------------------------------------------------------\n// A very basic sky...\nvec3 sky(vec3 dir)\n{\n \n    return mix(FOG_COLOUR, SKY_TOP ,abs(dir.y)*2.);\n}\n\n//-----------------------------------------------------------------\n// This creates the sea, it's complexity is governed by the incoming iteration count...\nconst float COSR = cos(.43);\nconst float SINR = sin(.52);\nconst mat2 rot2D = mat2(COSR, SINR, -SINR, COSR) * 1.4;\nfloat oceanFundamental(vec2 p, float tim, float iter)\n{\n    float a =noise(p*.01)*8.+3.0;\n    float h = 0.0;\n    float it = 1./iter;\n    float spr = 0.0;\n    p.x -= tim*5.0;\n\n    p *= .025;// ...Scale it\n\n    for (float i = 0.0; i <= 1.0; i += it)\n    {\n        float t = (1.08-i) * tim;\n        float r =noise(p*2.1+t) * i;\n        vec2 y1 = (cos(p-t)+1.0);\n        vec2 y2 = (1.0-abs(sin(p-t)));\n        \n        y1 = mix(y1, y2, r);\n          \n        float s = y1.x + y1.y;\n        \n        h += s*a;\n        \n        a *= .59;\n        p = p * rot2D;\n        p += 19.9;\n    }\n\n    return h;\n}\n\n// Map the ocean relative to the point...\n//-----------------------------------------------------------------\nfloat map(in vec3 p, float iter)\n{\n    float h = oceanFundamental(p.xz, time, iter);\n    return p.y-h;\n}\n\n// Bog standard ray marching, there's so much noise that any misses get lost...ðŸ¤ž\n//-----------------------------------------------------------------\nvec2 rayMarch(vec3 p, vec3 dir)\n{\n    float d = 0.0;\n    float spr = 0.0;\n    for ( int i = 0; i < 120; i++)\n    {\n        vec3 pos = p + dir*d;\n\n        float hh = oceanFundamental(pos.xz, time, 7.);\n        float h = pos.y-hh;\n        \n        if (h < .11 || d > FAR)\n        {\n            break;\n        }\n        float wind = (noise(pos*.05)) * noise(pos*2.73+vec3(-time*10., time*.11,0));\n        spr += max(25.-h, 0.0) * smoothstep(40.0, .0,max(h, 0.0))*smoothstep(FAR, 0.0,d)*smoothstep(30., 80.0, hh)\n        * wind;\n\n\n        //if (h < 0.0) h *= .5;\n        d+= h*.7;\n    }\n    return vec2(d, min(spr*.03, 1.0));\n}\n\n//------------------------------------------------------------------------------\n// Get a view of pixel using Euler...\nmat3 viewMat (float ay, float az)\n{\n  vec2 o, ca, sa;\n  o = vec2 (ay, az);\n  ca = cos (o);\n  sa = sin (o);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n//------------------------------------------------------------------------------\n\n// I forgot where this came from, it using a higher iteration than the ray march...\nvec3 normal(vec3 pos, float ds)\n{\n    ds *= 2./iResolution.y;\n    ds = max(ds*ds, .1);\n\n    float c = map(pos, 14.);\n    vec2 eps_zero = vec2(ds, 0.0);\n    return normalize(vec3(map(pos + eps_zero.xyy, 14.),\n                          map(pos + eps_zero.yxy, 14.),\n                          map(pos + eps_zero.yyx, 14.)) - c);\n}\n\n//------------------------------------------------------------------------------\n\n// I was using my 2 tweet water caustic here,\n// but some compilers optimised it broken with the rest of the code\n// So I opted for a basic voronoi cell thing...\nfloat waterPattern(vec2 p)\n{\n    p *=.02;\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float wp = 1e10;\n    for (int i = -1;i<=1;i++)\n    {\n        for (int j = -1;j<=1;j++)\n        {\n            vec2 g = vec2(i, j);\n            vec2 o = hash22(n+g);\n            \n            vec2 r = g + o - f;\n            float d = dot(r, r);\n            if (d < wp)\n            {\n                wp = d;\n            }\n        }\n    }\n    return pow(wp, 3.5);\n}\n\n\n//------------------------------------------------------------------------------\nfloat waveDepth(vec3 p, vec3 dir)\n{\n    float d = 0.0;\n    for( float i = 3.0; i <= 23.0; i+=5.)\n    {\n        float h = map(p + dir*i, 7.);\n        if (h > 0.) break;\n        d += -h;\n    }\n    return clamp(1.0-d*.02, 0.0, 1.0);\n}\n\n//------------------------------------------------------------------------------\nvec3 lighting(vec3 pos, vec3 nor, in vec3 dir,in vec3 mat)\n{\n    vec3 col;\n    col = mat * max(dot(sunDir, nor), 0.0);\n    vec3 ref = reflect(dir, nor);\n    float fres = clamp(pow( 1.+dot(nor, dir), 7. ), 0.0, 1.0);\n    col = mix(col, sky(nor), .2);\n    col = mix(col, sky(ref), fres);\n    return col;\n}\n\n//------------------------------------------------------------------------------\nvec3 diffuse(in vec3 pos, in vec3 nor, in float dep)\n{\n    pos.x -= time*1.3;\n    vec3 mat = vec3(.1,.1,.12);\n    float h = smoothstep(0., 1.0,nor.y);\n    \n    mat += h*.1;\n\n    mat = mix(mat, vec3(.3,.7,.7), dep);\n\n\n    // Add different frequencies of voronoi cells...\n    float foam = waterPattern(pos.xz+99.)*25.;\n    foam += waterPattern(pos.xz*(1.5-nor.y)*30.0)*20.;\n    foam += waterPattern(pos.xz*8.)*16.;\n    \n    //foam += *10.;\n    \n    foam = clamp(foam, 0.0, 1.0);\n    \n\n    mat = mat+foam * dep*dep*2.;\n\n    return mat;\n}\n\n//------------------------------------------------------------------------------\n// Exponential fader...\nfloat fader(float edge0, float edge1, float x)\n{\n    float t = (x - edge0) / (edge1 - edge0);\n    return  clamp(exp((t-.9825)*3.)-.0525, 0.0, 1.0);\n}\n\n//------------------------------------------------------------------------------\nvoid mainImage( out vec4 outCol, in vec2 coord )\n{\n    // Take into account non-square viewport to keep aspect ratio of shapes..\n    // Zero in centre and .5 at the max Ys\n    vec2 uv = (coord-iResolution.xy*.5)/iResolution.y;\n\n    vec2 mouse = vec2(0);\n#ifndef EXPORT_VERSON\n    if (iMouse.z > 0.) mouse = (iMouse.xy-iResolution.xy*.5) /iResolution.y;\n#endif\n    \n\n    vec3 colour = vec3(0);\n    // Find a good point in time with time..\n    time = iTime+35.;\n\n    // Set colour to zero then call the rayMarcher to get distant object...\n\n    camPos = vec3(time*.01,100,0);\n    float h = (sin(time*.65)+1.0)*40.+ 30.;\n\n    // Don't go in the water...\n    float oce = oceanFundamental(camPos.xz, time, 8.0)+100.;\n    \n    oce= h-oce;\n    if (oce < 0.0)\n    {\n        h += pow(-oce, .1);\n    }\n\n\n    // Setup camera...\n    vec3 col;\n    vec3 dir  = vec3(0,0, 1.);\n    dir = viewMat (uv.y -.3, uv.x-2.+time*.25 + mouse.x*6.28) * dir;\n\n    camPos.y = h;\n    vec2 dis = rayMarch(camPos, dir);\n\n\n    if (dis.x < FAR)\n    {\n        // The position is the start position plus the normalised direction X distance...\n        vec3  pos = camPos + dir * dis.x; // ...wave hit position\n        vec3  nor = normal(pos, dis.x);   // ... Normal\n         // The depth of the wave in forward direction, it's simple but effective in helping the water transparent effect...\n        float dep = waveDepth(pos, dir);\n        vec3  mat = diffuse(pos, nor, dep);\n\n        col = lighting(pos, nor, dir, mat);\n        //col = mix(col, FOG_COLOUR, smoothstep(250.0, FAR, dis.x));\n        col = mix(FOG_COLOUR, col, exp(-dis.x*.0015));\n    }else\n    {\n        col = sky(dir);\n    }\n    colour += col;\n\n\n    colour = mix(col, vec3(.51,.55,.59),dis.y);\n\n    // Some adjustment..\n    colour = colour*.5 + smoothstep(0.0, 1.0, colour)*.5;\n    \n    vec2 xy = coord/iResolution.xy;\n    colour *= 0.5 + .5*pow( 80.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), .7);  // ...Vignette.\n    // Fade out at five minutes...\n#ifdef EXPORT_VERSON\n    outCol = vec4(fader(0.0, 4.0, iTime) * fader(299.0, 294.0, iTime)*sqrt(colour), 1);\n#else\n    outCol = vec4(fader(0.0, 4.0, iTime) * sqrt(colour), 1);\n#endif\n}\n\n//-----------------------------------------------------------------\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n// Rough Seas ðŸŒŠ, by Dave Hoskins.\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// By David Hoskins, 2022.\n\n\n\nfloat fader(float edge0, float edge1, float x)\n{\n    float t = (x - edge0) / (edge1 - edge0);\n    return  clamp(exp((t-.9825)*3.)-.0525, 0.0, 1.0);\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n/*\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\nvec2 ihash21(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tn = (n.x ^ n.y) * UI2;\n\treturn vec2(n) * UIF;\n}\n*/\n\nvec2 noise2D(in float p)\n{\n\tfloat f = fract(p);\n    p = floor(p);\n    f = f * f * (3.0 - 2.0 * f);\n    vec2 res = mix(hash21(p), hash21(p + 1.0), f);\n    return res-.5;\n}\n\n\nvec2 mainSound( int samp, float time )\n{\n    vec2 v, aud;\n    float t = time;\n    \n    \n    // Add vary volumes of different frequencies...\n    // Magic numbers again, sorry folks...\n    v = noise2D(t*.6)*.5+.5;\n    v = v*v*3.0;\n    aud = noise2D(t*320.+sin(t*.1)*100.) * v;\n    \n    v = noise2D(t*.3)*.8+.2;\n    v = v*v*3.0;\n    aud += noise2D(t*600.)*v;\n\n    v = noise2D(-t*.3)*.8;\n    aud += noise2D(t*1300.)*v;\n\n    v = noise2D(-t*.5)*.6;\n    aud += noise2D(t*2200.)*v;\n\n\n    v = (noise2D(-t*.4)+noise2D(-t*.3))*.3;\n    aud += noise2D(t*4400.)*v;\n\n    v = (noise2D(t*.7) +noise2D(t*.22))*.25;\n    v = v*v*4.0;\n    aud += noise2D(t*7500.)*v;\n    \n    v = (noise2D(t*.4) +noise2D(t*.3))*.25;\n    v = v*v*4.0;\n    aud += noise2D(t*10000.)*v;\n    \n\n\n    aud = clamp(aud*.9, -1.0, 1.0);// Clamp it properly\n    aud = 1.5*aud-.5*aud*aud*aud; // Loudness\n    aud *= fader(.0, 3.0,time) * fader(180.0, 170.0,time); // Fade in and out.\n    \n    return aud;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}