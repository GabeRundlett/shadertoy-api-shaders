{
    "Shader": {
        "info": {
            "date": "1510616193",
            "description": "Threw this together in one hour",
            "flags": 0,
            "hasliked": 0,
            "id": "Xt2cDt",
            "likes": 32,
            "name": "Laserworld",
            "published": 3,
            "tags": [
                "grid",
                "laser",
                "vhs"
            ],
            "usePreview": 1,
            "username": "DrLuke",
            "viewed": 3850
        },
        "renderpass": [
            {
                "code": "// This work is licensed under a Creative Commons Attribution 4.0 International License.\n// https://creativecommons.org/licenses/by/4.0/\n\n// Inspiration: http://kingsanda.tumblr.com/post/166772103767\n\nfloat notsosmoothstep(float edge0, float edge1, float x)\n{\n    x = clamp((x - edge0)/(edge1 - edge0), 0.0, 1.0); \n    return mix(x*x*(3. - 2.*x), x, 0.6);\n}\n\n#define horiz(s, e, p) if(s.x < p.x && p.x <= e.x) return mix(s.y, e.y, notsosmoothstep(0., 1., (p.x - s.x) / (e.x - s.x)));\nfloat horizonHeight1(vec2 pos)\n{\n    horiz( vec2(-1, 0.1), vec2(-0.9, 0.3), pos );\n    horiz( vec2(-0.9, 0.3), vec2(-0.75, 0.5), pos );\n    horiz( vec2(-0.75, 0.5), vec2(-0.6, 0.2), pos );\n    horiz( vec2(-0.6, 0.2), vec2(-0.3, 0.25), pos );\n    horiz( vec2(-0.3, 0.25), vec2(-0., 0.2), pos );\n    horiz( vec2(-0., 0.2), vec2(.1, 0.3), pos );\n    horiz( vec2(.1, 0.3), vec2(.24, 0.32), pos );\n    horiz( vec2(.24, 0.32), vec2(.3, 0.3), pos );\n    horiz( vec2(.3, 0.3), vec2(.34, 0.32), pos );\n    horiz( vec2(.34, 0.32), vec2(.36, 0.31), pos );\n    horiz( vec2(.36, 0.31), vec2(.4, 0.27), pos );\n    horiz( vec2(.4, 0.27), vec2(.47, 0.23), pos );\n    horiz( vec2(.47, 0.23), vec2(.6, 0.15), pos );\n    horiz( vec2(.6, 0.15), vec2(.8, 0.3), pos );\n    horiz( vec2(.8, 0.3), vec2(1., 0.2), pos );\n}\n\nfloat horizonHeight2(vec2 pos)\n{\n    #define P21 vec2(-1, 0.1)\n    #define P22 vec2(-0.93, 0.03)\n    #define P23 vec2(-0.8, -0.3)\n    #define P24 vec2(-0.7, -0.35)\n    #define P25 vec2(-0.3, 0.05)\n    #define P26 vec2(-0.1, -0.05)\n    #define P27 vec2(-0.03, -0.02)\n    #define P28 vec2(-0., 0.07)\n    #define P29 vec2(0.05, 0.1)\n    #define P210 vec2(0.1, 0.14)\n    #define P211 vec2(0.25, 0.1)\n    #define P212 vec2(0.4, 0.24)\n    #define P213 vec2(0.5, 0.2)\n    #define P214 vec2(0.7, 0.3)\n    #define P215 vec2(0.8, 0.1)\n    #define P216 vec2(0.88, 0.14)\n    #define P217 vec2(1., -0.1)\n    \n    horiz( P21, P22, pos );\n\thoriz( P22, P23, pos );\n    horiz( P23, P24, pos );\n    horiz( P24, P25, pos );\n    horiz( P25, P26, pos );\n    horiz( P26, P27, pos );\n    horiz( P27, P28, pos );\n    horiz( P28, P29, pos );\n    horiz( P29, P210, pos );\n    horiz( P210, P211, pos );\n    horiz( P211, P212, pos );\n    horiz( P212, P213, pos );\n    horiz( P213, P214, pos );\n    horiz( P214, P215, pos );\n    horiz( P215, P216, pos );\n    horiz( P216, P217, pos );\n}\n\nfloat horizonHeight3(vec2 pos)\n{\n    #define P31 vec2(-1, -0.04)\n    #define P32 vec2(-0.93, -0.03)\n    #define P33 vec2(-0.8, 0.05)\n    #define P34 vec2(-0.7, 0.07)\n    #define P35 vec2(-0.6, 0.04)\n    #define P36 vec2(-0.4, -0.1)\n    #define P37 vec2(0.5, -0.1)\n    #define P38 vec2(0.72, 0.32)\n    #define P39 vec2(0.78, 0.32)\n    #define P310 vec2(0.81, 0.26)\n    #define P311 vec2(0.85, 0.3)\n    #define P312 vec2(0.92, 0.34)\n    #define P313 vec2(1., 0.4)\n\n    \n    horiz( P31, P32, pos );\n\thoriz( P32, P33, pos );\n    horiz( P33, P34, pos );\n    horiz( P34, P35, pos );\n    horiz( P35, P36, pos );\n    horiz( P36, P37, pos );\n    horiz( P37, P38, pos );\n    horiz( P38, P39, pos );\n    horiz( P39, P310, pos );\n    horiz( P310, P311, pos );\n    horiz( P311, P312, pos );\n    horiz( P312, P313, pos );\n\n}\n\n// Thanks to izutionix\nfloat grid(vec2 uv)\n{\n    #define VANTAGE vec2(0,-0.21)\n    uv = uv - VANTAGE;\n    float m = max(sign(-uv.y),0.); //mask\n    \n    uv /= 1.; //zoom\n    float d = -1./uv.y; //depth\n    vec2 pv = vec2(uv.x*d, d); //perspective\n    pv *= 1.4545; //scale\n    pv.y += iTime; //offset\n    \n\t// https://iquilezles.org/articles/filterableprocedurals\n    const float N = 16.;\n    vec2 w = fwidth(pv) + 0.001;\n    vec2 a = pv + 0.5*w;\n    vec2 b = pv - 0.5*w;\n    vec2 i = (floor(a)+min(fract(a)*N,1.0)-floor(b)-min(fract(b)*N,1.0))/(N*w);\n    return (i.x + i.y - i.x*i.y)*m;\n}\n\nfloat gridAA(vec2 uv)\n{\n    #define Xsamps 2\n    #define Ysamps 2\n    #define Xoff (1./float(2*Xsamps + 1)*float(i))\n    #define Yoff (1./float(2*Ysamps + 1)*float(j))\n    #define PXSIZE ( (vec2(1) / iResolution.xy) * (iResolution.x/iResolution.y) )\n    \n    float v = 0.0;\n    for(int i=-Xsamps; i <= Xsamps; i++)\n    for(int j=-Ysamps; j <= Ysamps; j++)\n    {\n        v += grid(uv + vec2(Xoff, Yoff) * PXSIZE);\n    }\n    \n    return v / float((2*Xsamps + 1) * (2*Ysamps + 1));\n}\n\n\nfloat burst1(vec2 uv)\n{\n    return clamp(-uv.y+0.3-abs(uv.x*0.1), 0., 1.);\n}\n\nfloat burst2(vec2 uv)\n{\n    return clamp(-uv.y+0.8-abs(uv.x*0.1), 0., 1.);\n}\n\nfloat burst3(vec2 uv)\n{\n    return clamp(-uv.y+0.1+cos(uv.x*0.5), 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uvo = (fragCoord.xy * 2. / iResolution.xy) - vec2(1);\n\tvec2 uv = uvo * vec2(iResolution.x/iResolution.y, 1);\t// uv coordinates with corrected aspect ratio\n    \n    #define LASERCOL vec3(1., 0.14, 0.2)\n    \n    float bmask = 0.0;\n    #define sunmaskfeather (7. / iResolution.y)\n    float sunmask1 = smoothstep(-sunmaskfeather, sunmaskfeather, uvo.y - horizonHeight1(uvo)*0.8 + 0.15);\n    bmask += sunmask1 * burst1(uvo);\n    float sunmask2 = smoothstep(-sunmaskfeather, sunmaskfeather, uvo.y - horizonHeight2(uvo) - 0.42);\n    bmask += sunmask1 * sunmask2 * burst2(uvo);\n    float sunmask3 = smoothstep(-sunmaskfeather, sunmaskfeather, uvo.y - horizonHeight3(uvo) - 0.36);\n    bmask += sunmask1 * sunmask2 * sunmask3 * burst3(uvo);\n    \n    bmask *= 1.-texture(iChannel0, fragCoord.xy/iChannelResolution[0].xy).r*0.4*pow((0.9-bmask*0.9), 2.);\n    \n    fragColor.rgb = bmask*LASERCOL;\n    \n    float g = gridAA(uv);\n    g *= 1.-texture(iChannel0, fragCoord.xy/iChannelResolution[0].xy).r*0.1*pow((0.9-bmask*0.9), 2.);\n    fragColor.rgb += g*LASERCOL;\n    \n    fragColor.a = 1.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}