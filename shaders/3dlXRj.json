{
    "Shader": {
        "info": {
            "date": "1551689924",
            "description": "trying to make some interactive fractal animation.\nClick to change color.",
            "flags": 0,
            "hasliked": 0,
            "id": "3dlXRj",
            "likes": 4,
            "name": "2d Mirror Shape",
            "published": 3,
            "tags": [
                "2d",
                "fractal"
            ],
            "usePreview": 0,
            "username": "Minstreams",
            "viewed": 486
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926535\n#define root2 1.41421\n#define root22 root2/2.0\n\n#define M_SIDE_NUM 6.0\n#define M_RADIUS 0.1\n#define MAX_BOUNCE_NUM 2\n#define ROTATE_SPEED 6.0\n#define CAM_SPEED 0.2\n#define DISTORT_POINTER 1.12\n#define COLOR_RANGE 0.1\n#define SATURATION 0.4\n\n//#define MODE0\n\nconst float angleUnit = 2.0*PI/M_SIDE_NUM;\n\nvec2 cam(vec2 uv)\n{\n    float d = length(uv);\n    float a = atan(uv.y,uv.x) + CAM_SPEED * iTime;\n    return vec2(d*cos(a),d*sin(a));\n}\n\nvec2 rotate(vec2 uv)\n{\n    float d = length(uv);\n    float a = atan(uv.y,uv.x);\n    a/=angleUnit;\n#ifdef MODE0\n    a = fract(a);\n#else\n    a = fract(a+0.5)-0.5;\n#endif\n    a*=angleUnit;\n    return vec2(d*cos(a),d*sin(a));\n}\nvec2 bounce(vec2 uv)\n{\n    float f = 0.0;\n    for(int i = 0;i<MAX_BOUNCE_NUM;i++){\n        float a = atan(uv.y,uv.x);\n        float d = length(uv);\n        a/=angleUnit;\n        f += floor(a+0.5);\n        a = fract(a+0.5)-0.5;\n        a*=angleUnit;\n        float x = d*cos(a);\n        float y = d*sin(a);\n        if(x<M_RADIUS)\n        {\n            a +=f*angleUnit;\n            return vec2(d*cos(a),d*sin(a));\n        }\n        x = 2.0*M_RADIUS-x;\n        uv = vec2(x,y);\n    }\n    return uv;\n}\nvec2 distort(vec2 uv){\n    float factor = pow(2.2,DISTORT_POINTER);\n    float d = length(uv);\n    d = pow(d,DISTORT_POINTER)/d * factor;\n    return uv*d;\n}\n\nvec3 mask(vec2 uv){\n    float d = length(uv);\n    return 1.2*vec3(1.0-d*d);\n}\nvec3 render(vec2 uv)\n{\n    if(uv.x>M_RADIUS)uv*=M_RADIUS/length(uv);\n    float ts = iTime*ROTATE_SPEED;\n    vec3 cosOffset = 0.2*cos(ts)+2.75+vec3(0,1,2) + 0.3*angleUnit;\n    vec3 style = vec3(0.9,0.70,0.76);\n    float edge = uv.x<M_RADIUS?max(pow(1.0-uv.x/M_RADIUS,0.1),0.0):1.0;\n    float flow = max(0.5+0.5*cos(uv.y/M_RADIUS*PI+ts ),0.0);\n    float edgeFactor = 0.5-0.5*cos(ts);\n    float flowFactor = 0.0+0.1*cos(ts/3.0-0.5*PI);\n    float shadow = edgeFactor*edge+flowFactor*flow+1.0-edgeFactor-flowFactor;\n    vec3 col =cos(cosOffset+(uv.xyx*COLOR_RANGE/M_RADIUS+COLOR_RANGE)*20.0 + iMouse.xyx/iResolution.y*PI*2.0);\n    col = 1.0-SATURATION*0.5+SATURATION*0.5*col;\n    return style*shadow*col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // aspect ratio\n    float invar = iResolution.y / iResolution.x;\n    vec2 uv = fragCoord / iResolution.xy - .5;\n    vec3 col = mask(uv);\n    uv.y *= invar;\n    \n    uv = cam(uv);\n    uv = distort(uv);\n    uv = bounce(uv);\n    uv = rotate(uv);\n    \n    col *= render(uv);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}