{
    "Shader": {
        "info": {
            "date": "1622685460",
            "description": "Kind of a lot going on here. Lots of learning and lots of rough edges.",
            "flags": 0,
            "hasliked": 0,
            "id": "7llGzs",
            "likes": 7,
            "name": "tubes v4",
            "published": 3,
            "tags": [
                "raymarching",
                "grid",
                "texture",
                "organic",
                "tubes"
            ],
            "usePreview": 0,
            "username": "milkfat",
            "viewed": 323
        },
        "renderpass": [
            {
                "code": "#define SCREEN_D -700.0\n#define RADIUS 500.0\n//#define NO_SHADOWS\n//#define MSAA\n//#define FAKE_NORM\n#define EXPOSURE 1.0\n\n#define MOVEMENT_SPEED 1000.0\n\n#define LIGHT vec3(5000.0+sin(iTime*.5)*100.0,000.0+cos(iTime*.4)*100.0,1000.0-iTime*MOVEMENT_SPEED-18000.0+sin(iTime*.5)*10000.0)\n//#define LIGHT vec3(0,000,-1000.0-iTime*MOVEMENT_SPEED)\n\nfloat hash(float n) {\n    return fract(n*fract(n*.133929));\n}\n\nvec2 rotate(vec2 p, float a) {    \n    return vec2 (cos(a)*p.x - sin(a)*p.y, sin(a)*p.x + cos(a)*p.y);\n}\n\nvec2 irotate(vec2 p, float a) {\n    return rotate(p, -a);\n}\n\nvec3 iproject(vec3 p)\n{\n    p.x -= iResolution.x/2.0;\n    p.y -= iResolution.y/2.0;\n    \n    p.z -= 2000.0;\n    \n    p.x /= iResolution.x/1200.0;\n    p.y /= iResolution.y/675.0;\n    \n    p.x *= (SCREEN_D+p.z);\n    p.y *= (SCREEN_D+p.z);\n    \n    p.x /= (SCREEN_D);\n    p.y /= (SCREEN_D);\n      \n    p.z += 2000.0;\n    \n    //p.z += 1000.0;\n    //p.xy = irotate(p.xy, iTime);\n    p.z += SCREEN_D;\n    p.yz = irotate(vec2(p.y,p.z), 2.0*6.28*sin((-iMouse.y)/iResolution.y));\n    p.xz = irotate(vec2(p.x,p.z), 2.0*6.28*sin((-iMouse.x)/iResolution.x));\n    p.z -= SCREEN_D;\n    //p.z -= 1000.0;\n    p.z -= iTime*MOVEMENT_SPEED;\n    return p; \n}\n\nfloat effect_sin(float a, float cellnum) {\n    return sin(a*.001+iTime*(hash(cellnum)*2.0-1.0))*200.0;\n}\n\nfloat effect_cos(float a, float cellnum) {\n    return cos(a*.001+iTime*(hash(cellnum)*2.0-1.0))*200.0;\n}\n\n//lumpy tube crawler things\nfloat effect_thickness(float a,float cellnum) {\n    float b = sin(iTime*(hash(cellnum)-.5)*1.0+a*.0002);\n    b = b*10.0-9.0;\n    b = max(b,0.0);\n    b = b*b*b*b;\n    b = b*2.0 - 1.0;\n    return b*120.0;\n}\n\n//twisty funhouse effect\nvec3 effect_funhouse(vec3 p) {\n    p.x += sin(p.z*.0005 + iTime*1.0)*300.0;\n    p.y += cos(p.z*.0005 + iTime*1.0)*300.0;\n    return p;\n}\n\n//bulge effect around our light source (sort of unnoticeable at the moment)\nvec3 effect_bulge(vec3 p) {\n    float d = 10000.0-distance(p,LIGHT);\n    d*=.00001;\n    d = clamp(d,0.0,1.0);\n    d = smoothstep(0.0,1.0,d);\n    p.xy -= p.xy*d*.2;\n    return p;\n}\n\n//smooth union\nfloat sdf_union(float a, float b, float amount) {\n    float ab = clamp(amount - abs(a-b), 0.0, amount)/amount;\n    ab*=ab;\n    ab*=ab;\n    return min(a,b)-ab*(amount*.125);\n}\n\nfloat scene(vec3 p, vec3 p_orig) {\n\n    \n    p = effect_bulge(p);  \n    p = effect_funhouse(p);\n    \n    //find distance\n    vec3 cellnum = floor(p/4000.0);\n    \n    //vertical tubes\n    vec3 pa = vec3(mod(p.x,4000.0),p.y,mod(p.z,-4000.0)); //this is our relative position inside a cell                                      \n    vec3 aa = vec3(2000.0+effect_sin(p.y,cellnum.z+cellnum.x*10.0),p.y,-2000.0+effect_cos(p.y,cellnum.z+cellnum.x*10.0)); //this is the target position\n    float a = distance(pa,aa); //distance between us and the target\n    a += -RADIUS-effect_thickness(p.y,cellnum.z+cellnum.x*.8371); //modify thickness/radius\n    \n    //horizontal\n    vec3 pb = vec3(p.x,mod(p.y,4000.0),mod(p.z,-4000.0));\n    vec3 bb = vec3(p.x,2000.0+effect_sin(p.x,cellnum.y+cellnum.z*10.0),-2000.0+effect_cos(p.x,cellnum.y+cellnum.z*10.0)); \n    float b = distance(pb,bb);\n    b += -RADIUS-effect_thickness(p.x,cellnum.z*3.5931+cellnum.y);\n    \n    //z-axis\n    vec3 pc = vec3(mod(p.x,4000.0),mod(p.y,-4000.0),p.z);\n    vec3 cc = vec3(2000.0+effect_sin(p.z,cellnum.x+cellnum.y*10.0),-2000.0+effect_cos(p.z,cellnum.x+cellnum.y*10.0),p.z);\n    float c = distance(pc,cc);\n    c += -RADIUS-effect_thickness(p.z,cellnum.y+cellnum.x*1.037);\n    \n    //smooth union\n    const float fillet = 1200.0;\n    float ab = sdf_union(a,b,fillet);\n    float abc = sdf_union(ab,c,fillet);\n    return abc;\n    //return min(min(a,b),c);\n    \n}\n\n//march them rays\nfloat march(inout vec3 p, vec3 p_orig, vec3 ps) {\n    float dist = 1000.0;\n    for (int i = 0; i < 80; i++) {\n        dist = scene(p,p_orig);\n        if(dist<5.1)break;\n        p+=ps*max(dist*.8,5.1);\n    }\n    return dist;\n}\n\n//march back towards our light source\nfloat march_light(inout vec3 p, vec3 p_orig, vec3 ps, vec3 light, inout float min_dist) {\n    float dist = 1000.0;\n    float dist2 = 1000.0;\n    min_dist = 1000.0;\n    for (int i = 0; i < 50; i++) {\n        dist = scene(p,p_orig);\n        min_dist = min(min_dist, dist);\n        dist2 = length(p-light);\n        p+=ps*min(dist*.8, dist2);\n        if(dist < 15.1 || dist2 < 45.1)break;\n    }\n    return dist2;\n}\n\n\n//this function is one of my least favorite things\n//its purpose is to find:\n//our relative position between tubes (intersection to intersection) (0.0 - 1.0) (0.0 = at one intersection; 1.0 = at the other intersection)\nvec3 distance_from_intersect(vec3 p) {\n\n    p = effect_bulge(p);\n    p = effect_funhouse(p);\n    \n    //horizontal UV (based on the location between vertical and z-axis tubes)\n    vec3 pqa = p;\n        \n    pqa.x+=2000.0;\n    vec3 cellnuma = floor(pqa/4000.0);\n            \n    float pa = mod(pqa.x,4000.0);                                       \n    float aa = effect_sin(p.y,cellnuma.z+(cellnuma.x-1.0)*10.0);\n    float aah = effect_sin(p.z,cellnuma.x-1.0+cellnuma.y*10.0);\n    float a = abs(aa-pa);\n    float ah = abs(aah-pa);\n    a += -RADIUS-effect_thickness(p.y,cellnuma.z+(cellnuma.x-1.0)*.8371);\n    ah += -RADIUS-effect_thickness(p.z,cellnuma.y+(cellnuma.x-1.0)*1.037);\n    \n    float aa2 = effect_sin(p.y,cellnuma.z+cellnuma.x*10.0)+4000.0;\n    float aah2 = effect_sin(p.z,cellnuma.x+cellnuma.y*10.0)+4000.0;\n    float a2 = abs(aa2-pa);\n    float ah2 = abs(aah2-pa);\n    a2 += -RADIUS-effect_thickness(p.y,cellnuma.z+cellnuma.x*.8371);\n    ah2 += -RADIUS-effect_thickness(p.z,cellnuma.y+cellnuma.x*1.037);\n    a = sdf_union(a,ah,1200.0);\n    a2 = sdf_union(a2,ah2,1200.0);\n    \n    \n    //vertical UV (based on the location between horizontal and z-axis tubes)\n    vec3 pqb = p;\n        \n    pqb.y+=2000.0;\n    //pqb.x+=2000.0;\n    //pqb.z-=2000.0;\n    vec3 cellnumb = floor(pqb/4000.0);\n    \n    float pb = mod(pqb.y,4000.0);\n    float bb = effect_sin(p.x,cellnumb.y-1.0+cellnumb.z*10.0); \n    float bbh = effect_cos(p.z,cellnumb.x+(cellnumb.y-1.0)*10.0);\n    float b = abs(bb-pb);\n    float bh = abs(bbh-pb);\n    b += -RADIUS-effect_thickness(p.x,cellnumb.z*3.5931+cellnumb.y-1.0);\n    bh += -RADIUS-effect_thickness(p.z,cellnumb.y-1.0+cellnumb.x*1.037);\n    \n    \n    float bb2 = effect_sin(p.x,cellnumb.y+cellnumb.z*10.0)+4000.0; \n    float bbh2 = effect_cos(p.z,cellnumb.x+cellnumb.y*10.0)+4000.0;\n    float b2 = abs(bb2-pb);\n    float bh2 = abs(bbh2-pb);\n    b2 += -RADIUS-effect_thickness(p.x,cellnumb.z*3.5931+cellnumb.y);\n    bh2 += -RADIUS-effect_thickness(p.z,cellnumb.y+cellnumb.x*1.037);\n    b = sdf_union(b,bh,1200.0);\n    b2 = sdf_union(b2,bh2,1200.0);\n    \n    \n    //z-axis UV (based on the location between horizontal and vertical tubes)\n    vec3 pqc = p;\n        \n    pqc.z-=2000.0;\n    vec3 cellnumc = floor(pqc/4000.0);\n    \n    //z-axis\n    float pc = mod(pqc.z,4000.0);\n    float cc = effect_cos(p.x,cellnumc.y+cellnumc.z*10.0);\n    float cch = effect_cos(p.y,cellnumc.z+cellnumc.x*10.0);\n    float c = abs(cc-pc);\n    float ch = abs(cch-pc);\n    c += -RADIUS-effect_thickness(p.x,cellnumc.z*3.5931+cellnumc.y);\n    ch += -RADIUS-effect_thickness(p.y,cellnumc.z+cellnumc.x*.8371);\n    \n    float cc2 = effect_cos(p.x,cellnumc.y+(cellnumc.z-1.0)*10.0)+4000.0;\n    float cch2 = effect_cos(p.y,cellnumc.z+1.0+cellnumc.x*10.0)+4000.0;\n    float c2 = abs(cc2-pc);\n    float ch2 = abs(cch2-pc);\n    c2 += -RADIUS-effect_thickness(p.x,(cellnumc.z-1.0)*3.5931+cellnumc.y);\n    ch2 += -RADIUS-effect_thickness(p.y,cellnumc.z+1.0+cellnumc.x*.8371);\n    c = sdf_union(c,ch,1200.0);\n    c2 = sdf_union(c2,ch2,1200.0);\n    \n    return vec3(a/(a+a2),b/(b+b2),c/(c+c2));\n}\n\nvec3 cast_ray(vec2 coord) {\n\n    vec3 p = iproject(vec3(coord, 1300));\n    vec3 p_orig = p;\n    vec3 ps = normalize(iproject(vec3(coord, -1000))-p);\n    \n    float dist = march(p,p_orig,ps);\n    \n    vec3 light = LIGHT;\n    vec3 ps2 = normalize(light-p);\n    vec3 p2 = p+ps2*100.0;\n   \n    vec3 out_color = vec3(0,0,0);\n    \n    if(dist<5.1) {\n    \n        //march a few more rays to derive surface normal\n        vec3 pp;\n        pp.x = scene(vec3(p.x+10.0,p.y,p.z),p_orig);\n        pp.y = scene(vec3(p.x,p.y+10.0,p.z),p_orig);\n        pp.z = scene(vec3(p.x,p.y,p.z+10.0),p_orig);\n        vec3 norm = normalize(vec3(pp-dist));\n        \n        //the rotation angle around each axis\n        float rx = atan(norm.y,norm.z) * 1.15;\n        float ry = atan(norm.x,norm.z) * 1.15;\n        float rz = atan(norm.x,norm.y) * 1.15;\n        \n        //our relative position between tubes\n        vec3 rp = distance_from_intersect(p);\n        vec3 rpp = rp*4.0;\n        \n        //convert relative position (0.0 - 1.0 - 0.0) (0.0 = at an intersection; 1.0 = smack between intersections)\n        rp = abs(.5-rp)*2.0;\n        \n        vec3 col=vec3(0,0,0);\n        vec2 uv;\n        float thick;\n        vec3 cellnum = floor(p/4000.0);\n        \n        //apply our texture based on our relative position\n        if(rp.x < rp.y && rp.x < rp.z) {\n            //horizontal texture\n            uv = vec2(rpp.x , rx*1.0);\n            //thickness light amount (translucent effect)\n            thick = effect_thickness(p.x,cellnum.z*3.5931+cellnum.y);\n            //add light from intersecting tubes\n            thick += (1.0-(rp.y-rp.x))*max(effect_thickness(p.y,cellnum.z+cellnum.x*.8371),0.0)*2.0;\n            thick += (1.0-(rp.z-rp.x))*max(effect_thickness(p.z,cellnum.y+cellnum.x*1.037),0.0)*2.0;\n        } else if (rp.y < rp.z) {\n            //vertical texture\n            uv = vec2(rpp.y , ry*1.0);\n            thick = effect_thickness(p.y,cellnum.z+cellnum.x*.8371);\n            thick += (1.0-(rp.x-rp.y))*max(effect_thickness(p.x,cellnum.z*3.5931+cellnum.y),0.0)*2.0;\n            thick += (1.0-(rp.z-rp.y))*max(effect_thickness(p.z,cellnum.y+cellnum.x*1.037),0.0)*2.0;\n        } else  {\n            //z-axis texture\n            uv = vec2(rpp.z , rz*1.0);\n            thick = effect_thickness(p.z,cellnum.y+cellnum.x*1.037);\n            thick += (1.0-(rp.x-rp.z))*max(effect_thickness(p.x,cellnum.z*3.5931+cellnum.y),0.0)*2.0;\n            thick += (1.0-(rp.y-rp.z))*max(effect_thickness(p.y,cellnum.z+cellnum.x*.8371),0.0)*2.0;\n        }\n        \n        uv*=.5;\n        vec3 tex = texture(iChannel0, uv, -1.0).xyz;\n        \n        //normalize our thickness lighting\n        thick+=120.0;\n        thick /= 240.0;\n        thick = (thick < 1.0) ? thick * thick : thick;\n        \n        //find out how close we are to an intersection to \"share\" the thickness lighting\n        float diff = abs(tex.r-tex.g) + abs(tex.r-tex.b) + abs(tex.g-tex.b);\n        diff *= 4.0;\n        \n        if(diff > 1.0) col += tex*thick*0.5; //emissive/translucent glow\n       \n\n        vec3 l = normalize(light-p);\n        \n        #ifdef FAKE_NORM\n        //fake texture normal\n        norm.x -= (texture(iChannel0,uv).g - texture(iChannel0,vec2(uv.x,uv.y+.0003)).g)*80.0;\n        norm.y -= (texture(iChannel0,uv).g - texture(iChannel0,vec2(uv.x+.001,uv.y)).g)*80.0;\n        #endif\n        \n        float bri = clamp(dot(norm,l),0.0,1.0); //directional lighting\n        \n\n        float lbri = 100000.0-length(light-p); //distance to light\n        lbri /= 100000.0;\n        lbri = clamp(lbri,0.0,1.0);\n        lbri *= lbri;\n        \n        bri += lbri*.5; //exceedingly basic global illumination\n        bri *= lbri;\n        \n        bri += .3; //ambient light\n         \n        float dist_;\n        #ifndef NO_SHADOWS\n        float dist2 = march_light(p2,p_orig,ps2,light,dist_); //ray march back to light source\n        if(dist2 > 45.1) {\n            bri*=.7; //shadow hit//soft shadows\n        } else {\n            dist_ = clamp(dist_, 0.0, 65.0);\n            dist_ /= 65.0;\n            dist_ = 1.0 - dist_;\n            dist_ = smoothstep(0.0,1.0,dist_);\n            bri -= dist_*bri*.3;\n        }\n        #endif\n        \n        \n        out_color = col+(bri*tex);\n        \n        \n       \n    }\n    \n    return out_color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord-.5;\n    vec3 col = cast_ray(coord);\n    \n    \n    #ifdef MSAA\n    col += cast_ray(vec2(coord.x+.5,coord.y));\n    col += cast_ray(vec2(coord.x,coord.y+.5));\n    col /= 3.0;\n    #endif\n    \n    fragColor = vec4(col,1.0);\n    fragColor *= EXPOSURE;\n    fragColor.r = pow(fragColor.r,2.2);\n    fragColor.g = pow(fragColor.g,2.2);\n    fragColor.b = pow(fragColor.b,2.2);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}