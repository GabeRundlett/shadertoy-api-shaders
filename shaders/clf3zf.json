{
    "Shader": {
        "info": {
            "date": "1672131940",
            "description": "Color-changing squares whose size changes with relative mouse position",
            "flags": 0,
            "hasliked": 0,
            "id": "clf3zf",
            "likes": 7,
            "name": "Scaling Squares",
            "published": 3,
            "tags": [
                "beginner"
            ],
            "usePreview": 0,
            "username": "rog",
            "viewed": 297
        },
        "renderpass": [
            {
                "code": "#define PI 3.141592\n\n// Number of squares in each axis\nvec2 grid = vec2(32.0, 18.0);\n\n// Margin on each edge of the view, as a proportion of the size of the constraining axis\nfloat padding = 0.00;\n\n// Margin for each square edge, as a proportion of the side length\nfloat spacing = 0.2;\n\nvec4 BLACK = vec4(vec3(0.0), 1.0);\n\n/// Component-wise maximum\nfloat min2(vec2 vec) {\n  return min(vec.x, vec.y);\n}\n\nvec4 fC(in vec2 fragCoord) {\n  // Largest size possible such that the grid elements are squares\n  vec2 usableSize = min2(iResolution.xy / grid) * grid;\n\n  vec2 sizeWithPadding = usableSize * (1.0 - 2.0 * padding);\n\n  // Psuedo-UV coordinate in [-0.5, 0.5]\n  vec2 uv = (fragCoord - iResolution.xy / vec2(2.0)) / sizeWithPadding;\n  vec2 mouseUv = (iMouse.xy - iResolution.xy / vec2(2.0)) / sizeWithPadding;\n  if (iMouse.z < 1.0) {\n    // If user not clicking, the center can move around in a circle\n    mouseUv = vec2(cos(iTime / 2.0), sin(iTime / 2.0)) * vec2(0.5 * 0.6);\n  }\n\n  // Ignore values outside the grid\n  if (any(greaterThan(abs(uv), vec2(0.5)))) {\n    return BLACK;\n  }\n\n  // If even number of elements, screen center is corner between grids\n  // If odd number of elements, screen center is center of a grid box\n  vec2 offset = vec2(0.5) * mod(grid + 1.0, 2.0);\n  vec2 gridPosition = uv * grid + offset;\n  // Position of nearest grid center in psuedo-UV\n  vec2 nearestCellCenter = round(gridPosition) / grid;\n\n  // Vector for fragment from nearest grid center in [-0.5, 0.5]\n  vec2 normVecFromCenter = gridPosition - nearestCellCenter * grid;\n\n  float mouseDist = length((nearestCellCenter - offset / grid) - mouseUv);\n  // As mouse distance from center increases, box size shrinks\n  float scalingFactor = max(0.1, 1.0 - mouseDist);\n\n  // Take spacing into account - padding on both edges, so multiply by 2\n  float normThreshold = 0.5 / (1.0 + 2.0 * spacing) * scalingFactor;\n  if (any(greaterThan(abs(normVecFromCenter), vec2(normThreshold)))) {\n    return BLACK;\n  }\n\n  return vec4(\n    cos(nearestCellCenter.x * PI + iTime) / 2.0 + 0.5,\n    sin(nearestCellCenter.y * PI + iTime) / 2.0 + 0.5,\n    1.0,\n    1.0\n  );\n}\n\n\n// Box-filter by Greg Rostami\n// Add this code to the bottom of any shader that has aliasing problems:\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    float A = 8.,  // Change A to define the level of anti-aliasing (1 to 16) ... higher numbers are REALLY slow!\n          s = 1./A, x, y;\n    \n    for (x=-.5; x<.5; x+=s) for (y=-.5; y<.5; y+=s) fragColor += min ( fC(vec2(x,y)+fragCoord), 1.0);\n        \n\tfragColor /= A*A;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}