{
    "Shader": {
        "info": {
            "date": "1521764833",
            "description": "Using mipmapping on 2D textures to do a sort of mipmapping on cubemaps. Need a PBR exemple badly. Left is cylindrical, right is triplanar.",
            "flags": 0,
            "hasliked": 0,
            "id": "ldyyWh",
            "likes": 2,
            "name": "Mipmapped Cubemaps",
            "published": 3,
            "tags": [
                "3d",
                "mipmap"
            ],
            "usePreview": 0,
            "username": "Klems",
            "viewed": 695
        },
        "renderpass": [
            {
                "code": "\n#define PI 3.14159265359\n#define rot(a) mat2(cos(a+PI*vec4(0,1.5,0.5,0)))\n\n// tweak these values if you need more pixels\n#define CYLINDRICAL_SCALE vec2(2.0, 1.0)\n#define TRIPLANAR_SCALE 0.5\n\n// use a mipmapped 2D texture to mimic a mipmapped cubemap\n// cone is the angle of the cone to sample in\n\n// use cylindrical projection, 1 sample\nvec4 myTextureCylindrical( in vec3 dir, in float cone ) {\n    // transform cone angle back to texture space\n    cone /= 2.0*PI*length(dir.xy)/CYLINDRICAL_SCALE.x;\n    // figure out the lod\n    float lod = log2(cone*iChannelResolution[0].x);\n    // cylindrical mapping\n    float theta = atan(dir.x, dir.y);\n    float alpha = asin(dir.z);\n    theta = (theta + PI) / (2.0*PI);\n    alpha = (alpha + PI*0.5) / (PI);\n    return textureLod(iChannel0, vec2(theta, alpha)*CYLINDRICAL_SCALE, lod);\n}\n\n// use triplanar projection, 3 samples\nvec4 myTextureTriPlanar( in vec3 dir, in float cone ) {\n    // transform cone angle back to texture space\n    cone = sin(clamp(-PI*0.5, PI*0.5, cone))*TRIPLANAR_SCALE;\n    // figure out the lod\n    float lod = log2(cone*iChannelResolution[0].x);\n    // classic triplanar mapping\n    dir *= TRIPLANAR_SCALE;\n    vec4 sampX = textureLod(iChannel0, dir.yz, lod);\n    vec4 sampY = textureLod(iChannel0, dir.xz, lod);\n    vec4 sampZ = textureLod(iChannel0, dir.xy, lod);\n    vec3 adir = abs(dir);\n    float s = adir.x+adir.y+adir.z;\n    return (sampX*adir.x+sampY*adir.y+sampZ*adir.z)/s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.y *= iResolution.y / iResolution.x;\n\t\n\tvec3 dir = normalize(vec3(uv * 3.0, 1.0));\n    \n    dir.zy *= rot(sin(iTime)*0.0845 + iMouse.y*0.01);\n    dir.xz *= rot(iTime*0.1 + iMouse.x*0.01);\n    dir.zy *= rot(PI*0.5);\n    \n    float cone = (sin(iTime*0.5)*0.5+0.5)*0.3;\n    \n    if (fragCoord.x < iResolution.x*0.5)\n    \tfragColor.rgb = myTextureCylindrical(dir, cone).rgb;\n    else\n    \tfragColor.rgb = myTextureTriPlanar(dir, cone).rgb;\n    \n    if (abs(fragCoord.x-iResolution.x*0.5)<1.0)\n        fragColor.rgb = vec3(0);\n    \n    fragColor.a = 1.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}