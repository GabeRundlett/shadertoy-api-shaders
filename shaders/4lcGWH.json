{
    "Shader": {
        "info": {
            "date": "1469380099",
            "description": "MINIMUM RESOLUTION = 480x360\nBest played in fullscreen.\nMove: cursors\nShoot: Z",
            "flags": 48,
            "hasliked": 0,
            "id": "4lcGWH",
            "likes": 24,
            "name": "[SH16C] Bullet Hell",
            "published": 3,
            "tags": [
                "shootemup"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 1348
        },
        "renderpass": [
            {
                "code": "const vec2 RES = vec2(480,360); // vec2(384,288);\n\n//#define SHOW_SPRITE_SHEET 1\n//#define SHOW_ALPHA 1\n#define INTEGER_SCALE 1\n\n#ifdef SHOW_SPRITE_SHEET\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    float scale = 5.;\n    vec2 origin = vec2(0,0);\n    fragColour = texture( iChannel0, (fragCoord/scale+origin)/iResolution.xy);//floor(iResolution.y/256.) );\n\n    vec3 bg = vec3(.3+.2*step(.0,dot(sin(fragCoord*6.28/8.+iTime*8.),vec2(1,1))));\n//    fragColour.rgb = mix( bg, fragColour.rgb, fragColour.a );\n    fragColour.rgb = fragColour.rgb + bg*(1.-fragColour.a); // premultiplied alpha, so I can do additive effects\n}\n#else\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    float scale = iResolution.y/RES.y;\n    \n#ifdef INTEGER_SCALE\n    if ( scale > 1. ) scale = floor( scale );\n#endif\n    \n    fragCoord = floor((fragCoord-iResolution.xy*.5)/scale) + .5;\n    \n    if ( abs(fragCoord.x)*2. > RES.x || abs(fragCoord.y)*2. > RES.y ) { fragColour = vec4(.2); return; }\n    \n    fragColour = texture( iChannel1, (fragCoord+RES*.5)/iResolution.xy );\n    \n#ifdef SHOW_ALPHA\n    fragColour.rgb = .5-.5*cos( vec3(1,2,4)*fragColour.aaa );\n#endif\n}\n\n#endif\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// shared section (can we get #includes or something please?!)\n\nconst vec2 RES = vec2(480,360); // vec2(384,288);\n\nconst float INVINCIBLE = 120.; // how many seconds is the player invincible at the start?\n\nconst float MAX_SHOTS = 10.;\nconst float SHOT_RATE = 8.;\nconst float SHOT_SPEED = 360./(SHOT_RATE*MAX_SHOTS); // screen height\n\n// data layout\nconst float DATA_SHIP = 0.;\nconst float DATA_FIRSTENEMY = 1.;\nconst float DATA_LASTENEMY = 2.;\nconst float DATA_FIRSTSHOT = 3.;\nconst float DATA_END = DATA_FIRSTSHOT + MAX_SHOTS;\n\nvec4 ReadData( float index )\n{\n\treturn texture( iChannel0, vec2(index+.5,0)/iResolution.xy );\n}\n\nbool Bounds( vec2 coord, vec2 _min, vec2 _max )\n{\n    vec2 test = step(_min,coord)*step(coord,_max);\n    return min(test.x,test.y) > .0;\n}\n\n// end of shared section\n\n\n\n// SPRITES\n\n\nfloat Quantize( float a, float b )\n{\n    return floor(a*b+.5)/b;\n}\n\n\n// explosion element\nvoid Explosion( inout vec4 fragColour, in vec2 fragCoord, in vec2 centre, in float radius, in float frame )\n{\n    if ( length( fragCoord-centre ) <= radius )\n    {\n        // shade itsort of like a sphere\n        float shade = Quantize( pow( length( fragCoord-centre )/radius, 2.), 4.);\n        \n        if ( frame < 4.+shade*4. )\n        {\n        \tfragColour = mix( vec4(0,0,0,1), vec4(1), exp2(-(shade+.1)*(frame+.05)*vec4(.8,4,40,0)) ); // todo: quantize\n        }\n    }\n}\n\nfloat linstep ( float a, float b, float c )\n{\n    return clamp( (c-a)/(b-a), 0., 1.);\n}\n\nvoid Gradient( inout vec4 fragColour, in vec2 fragCoord, in vec2 p0, in vec4 col0, in vec2 p1, in vec4 col1, in float steps )\n{\n    vec2 dp = p1-p0;\n    vec4 col = mix( col0, col1, Quantize( linstep( dot(p0,dp), dot(p1,dp), dot(fragCoord,dp) ), steps ) );\n    fragColour = mix( fragColour, col, mix( 1., col.a, fragColour.a ) );\n}\n\n\n// a rectangle, with lighting on the side, filled with techincal looking gubbins\n// gubbins can be varied by a seed, so can create identical gubbins where wanted\nvoid GubbinsRect(\n    inout vec4 fragColour,\n    in vec2 uv,\n    in vec2 _min, in vec2 _max,\n    in vec3 colour,\n    in float seed\n)\n{\n    if ( !Bounds(uv, _min, _max) ) return;\n\n    float left   = step( uv.x, _min.x+1. );\n    float top    = step( _max.y-1., uv.y );\n    float right  = step( _max.x-1., uv.x );\n    float bottom = step( uv.y, _min.y+1. );\n    \n    if ( (left+right)*(top+bottom) > .0 ) return; // \"rounded\" corners\n    \n    fragColour = vec4(colour,1);\n    \n    // light the edges\n    float light = 0.;\n    light += left  ;\n    light += top   ;\n    light -= right ;\n    light -= bottom;\n    \n    // gubbins\n    if ( light == 0. )\n    {\n        light = floor( texture( iChannel2, (uv-_min)*.002+seed ).y*1.2-.1 )*.5;\n    }\n    \n    //fragColour.rgb *= log2( light*.7+2.0 );\n   \tfragColour.rgb = clamp( fragColour.rgb + light*.4, vec3(0), vec3(1) );\n}\n    \n// keys are javascript keycode: https://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes\nconst int Key_Left = 37;\nconst int Key_Up = 38;\nconst int Key_Right = 39;\nconst int Key_Down = 40;\nconst int Key_Fire = 90; // 32 for space\n\nfloat ReadKey( int key )//, bool toggle )\n{\n\tbool toggle = false;\n\tfloat keyVal = texture( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn keyVal;\n}\n\n\n\nvoid RenderSprites( out vec4 fragColour, in vec2 fragCoord )\n{\n    fragColour = vec4(0);\n    \n    // explosion\n    if ( Bounds( fragCoord, vec2(256,0), vec2(288,256) ) )\n    {\n//        int frame = int(mod(iTime*4.,10.));//int(floor(fragCoord.y / 32.));\n        float frame = floor(fragCoord.y / 32.);\n        Explosion( fragColour, mod(fragCoord,32.), vec2(16,16), 16., frame );\n        Explosion( fragColour, mod(fragCoord,32.), vec2(6,6), 5., frame );\n        Explosion( fragColour, mod(fragCoord,32.), vec2(26,24), 6., frame );\n        Explosion( fragColour, mod(fragCoord,32.), vec2(8,28), 4., frame );\n    }\n    \n   \t// hero ship\n    if ( Bounds( fragCoord, vec2(0,16), vec2(32,48) ) )\n    {\n        vec3 wings = vec3(.9,.5,.3);\n        vec3 body = vec3(.1,.2,.6);\n        vec3 glass = vec3(.7,.9,1);\n        vec2 uv = fragCoord - vec2(0,16);\n//        GubbinsRect( fragColour, uv, vec2(14, 0), vec2(18,7), vec3(2,1,.5), 0. );\n  //      GubbinsRect( fragColour, uv, vec2(4, 0), vec2(8,6), vec3(1,.3,0), 0. );\n//        GubbinsRect( fragColour, uv, vec2(4, 3), vec2(8,8), vec3(2,1,.5), 0. );\n\n        // rockets\n        if ( Bounds( fragCoord, vec2(4, 0), vec2(8,7) ) || Bounds( fragCoord, vec2(24, 0), vec2(28,7) ) )\n        {\n        \tGradient( fragColour, uv, vec2(0), vec4(0,0,1,0), vec2(0,7), vec4(1,.9,.5,1), 3. );\n        }\n\n        GubbinsRect( fragColour, uv, vec2( 0,10), vec2( 4,20), wings, 0.4 );\n        GubbinsRect( fragColour, uv, vec2( 8, 8), vec2(13,22), wings, 0.3 );\n        GubbinsRect( fragColour, uv, vec2(19, 8), vec2(24,22), wings, 0.3 );\n        GubbinsRect( fragColour, uv, vec2(28,10), vec2(32,20), wings, 0.4 );\n        GubbinsRect( fragColour, uv, vec2( 4,24), vec2( 8,27), vec3(.7), 0. );\n        GubbinsRect( fragColour, uv, vec2(24,24), vec2(28,27), vec3(.7), 0. );\n        GubbinsRect( fragColour, uv, vec2( 3, 7), vec2( 9,25), body, 0.4 );\n        GubbinsRect( fragColour, uv, vec2(23, 7), vec2(29,25), body, 0.4 );\n        GubbinsRect( fragColour, uv, vec2(12, 6), vec2(20,32), body, 0.1 );\n        GubbinsRect( fragColour, uv, vec2(13,14), vec2(19,20), glass, 0. );\n        GubbinsRect( fragColour, uv, vec2(14, 7), vec2(18,18), body, 0. );\n        GubbinsRect( fragColour, uv, vec2(15, 5), vec2(17,14), wings, 0. );\n    }\n    \n    // bullets\n    if ( Bounds( fragCoord, vec2(0,56), vec2(32,64) ) )\n    {\n        vec2 uv = fragCoord - vec2(0,56);\n\n        vec2 centre = vec2(8.5,4.5);\n        float radius = 2.3;\n        float shade = Quantize( pow( length( uv-centre )/radius, 2.), 2.);\n        if ( shade <= 1. )\n        {\n        \tfragColour = mix( vec4(1,1,.5,1), vec4(.7,0,0,1), shade );\n        }\n\n        GubbinsRect( fragColour, uv, vec2(22,3), vec2(26,6), vec3(.5,1,1.5), 0. );\n        GubbinsRect( fragColour, uv, vec2(23,-1), vec2(25,4), vec3(.5,1,1.5), 0. );\n        GubbinsRect( fragColour, uv, vec2(22,5), vec2(26,8), vec3(.5,1,1.5), 0. );\n    }\n    \n    // weakpoint\n    if ( Bounds( fragCoord, vec2(64,0), vec2(96,32) ) )\n    {\n        vec2 uv = fragCoord - vec2(80,16);\n        float radius = length(uv);\n        if ( radius < 16. )\n        {\n            fragColour = vec4(1,.2,.2,1);\n            fragColour.rgb *= Quantize(smoothstep(15.,14.,radius),2.)*.5+.5;\n\n            float shade = Quantize(smoothstep( 0., 16., length(uv-vec2(.8,-1)*20./radius) ),2.);\n            fragColour.rgb *= shade*.5+.5;\n            \n            float highlight = Quantize(smoothstep( 12., 0., length(uv-vec2(-.8,1)*60./radius) ),2.);\n            fragColour.rgb += highlight;\n        }\n        GubbinsRect( fragColour, uv, vec2(-11,13), vec2(11,16), vec3(.7), .3 );\n        GubbinsRect( fragColour, uv, vec2(-16,4), vec2(-12,14), vec3(.7), .3 );\n        GubbinsRect( fragColour, uv, vec2(12,4), vec2(16,14), vec3(.7), .33 );\n        GubbinsRect( fragColour, uv, vec2(-14,10), vec2(-6,16), vec3(.7), .34 );\n        GubbinsRect( fragColour, uv, vec2(6,10), vec2(14,16), vec3(.7), .12 );\n        GubbinsRect( fragColour, uv, vec2(-3,11), vec2(3,16), vec3(.7), .3 );\n        GubbinsRect( fragColour, uv, vec2(-2,2), vec2(2,14), vec3(.7), .3 );\n    }\n}\n\n\nvoid UpdateShip( inout vec4 data )\n{\n    // position = data.xy\n\t// damage = data.z\n    // deathframe = data.w\n\n    if ( data.w == .0 ) // if not dead\n    {\n        vec2 velocity = vec2(3);\n/*\t  if ( iMouse.z > .0 )\n        {\n            // mouse - really meant for systems that don't have a keyboard\n            //todo: handle scale\n            vec2 delta = iMouse.xy - iResolution.xy*.5-data.xy;\n            //            if ( delta.x != .0 && delta.y != .0 )\n            data.xy += min(abs(delta),velocity)*sign(delta);\n            data.z = 1.; // auto-fire when mouse is used\n        }\n        else*/\n        {\n            // update player position\n            data.x += velocity.x*( ReadKey(Key_Right) - ReadKey(Key_Left));\n            data.y += velocity.y*( ReadKey(Key_Up) - ReadKey(Key_Down) );\n        }\n\n        data.xy = clamp( data.xy, vec2(-220,-160), vec2(220,120) );\n\n\n        // test collisions - if alpha channel of frame buffer is non-zero = collision\n        float damage = texture( iChannel1, (.5+vec2(0,0))/iResolution.xy ).x;\n        \n        data.z += damage/60.; // number of frames in contact with a bullet before you die\n   }\n    \n    if ( data.z >= 1. && data.w == 0. )\n    {\n        data.w = float(iFrame); // dead\n    }\n}\n\n\n\nvoid UpdateEnemy( inout vec4 data, in float index )\n{\n    float damage = texture( iChannel1, (.5+vec2(index,0))/iResolution.xy ).x;\n\n    data.z += damage/200.; // number of frames in contact with a bullet before you die\n    \n    if ( data.z >= 1. && data.w == 0. )\n    {\n        data.w = float(iFrame); // dead\n    }\n}\n\n\n// shots are stored in pairs, with positions in .xy and .zy (they always have the same y)\n// if new shot fired, move the list on by 1\nvoid UpdateShot( inout vec4 data, in float index )\n{\n    if ( mod( float(iFrame), SHOT_RATE ) < .5 && ReadKey(Key_Fire) > .5 ) // fire shot\n    {\n        if ( index == DATA_FIRSTSHOT )\n        {\n            // place shots at ship position\n            vec4 ship = ReadData( DATA_SHIP );\n            data.y = ship.y + 16.;\n            data.x = ship.x - 10.;\n            data.z = ship.x + 10.;\n        }\n        else\n        {\n        \t// read the data for the previous entry\n            data = ReadData( index-1. );\n        }\n    }\n    else\n    {\n\t    data.y += SHOT_SPEED;\n    }\n}\n\nvoid Update( inout vec4 data, in float index )\n{\n    if ( index <= DATA_SHIP ) UpdateShip( data );\n    else if ( index <= DATA_LASTENEMY ) UpdateEnemy( data, index );\n    else if ( index < DATA_FIRSTSHOT + MAX_SHOTS ) UpdateShot( data, index );\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    if ( fragCoord.x < DATA_END && fragCoord.y < 1. )\n    {\n        // compiler seems to be dumb about branching around expensive code\n        if ( fragCoord.y >= 1. ) discard;\n        \n        if ( iFrame < 2 )\n        {\n            float index = floor( fragCoord.x );\n            fragColour = vec4(0); // most things should be fine with this\n            if ( index <= DATA_SHIP )\n                fragColour = vec4(0,-100,0,0);\n            else if ( index <= DATA_FIRSTENEMY )\n                fragColour = vec4(-128,120,0,0);\n            else if ( index <= DATA_LASTENEMY )\n                fragColour = vec4(128,120,0,0);\n            else if ( index < DATA_FIRSTSHOT+MAX_SHOTS )\n            \tfragColour = vec4(0,500,0,0);\n        }\n        else\n        {\n            float index = floor( fragCoord.x );\n\n            fragColour = ReadData( index );\n            Update( fragColour, index );\n        }\n    }\n    else if ( iFrame < 2 ) // seems like Shadertoy double buffers, so we'll need to draw the sprites twice\n    {\n        RenderSprites( fragColour, fragCoord );\n    }\n    else\n    {\n        discard;\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// shared section (can we get #includes or something please?!)\n\nconst vec2 RES = vec2(480,360); // vec2(384,288);\n\nconst float INVINCIBLE = 120.; // how many seconds is the player invincible at the start?\n\nconst float MAX_SHOTS = 10.;\nconst float SHOT_RATE = 8.;\nconst float SHOT_SPEED = 360./(SHOT_RATE*MAX_SHOTS); // screen height\n\n// data layout\nconst float DATA_SHIP = 0.;\nconst float DATA_FIRSTENEMY = 1.;\nconst float DATA_LASTENEMY = 2.;\nconst float DATA_FIRSTSHOT = 3.;\nconst float DATA_END = DATA_FIRSTSHOT + MAX_SHOTS;\n\nvec4 ReadData( float index )\n{\n\treturn texture( iChannel0, vec2(index+.5,0)/iResolution.xy );\n}\n\nbool Bounds( vec2 coord, vec2 _min, vec2 _max )\n{\n    vec2 test = step(_min,coord)*step(coord,_max);\n    return min(test.x,test.y) > .0;\n}\n\n// end of shared section\n\nconst float tau = 6.283185;\n\n\n// Draw sprite\nvoid Sprite(\n    inout vec4 fragColour,\n    in vec2 uv, // pixel position relative to centre of sprite\n    in vec2 spriteCentre,\n    in vec2 spriteDimensions, // half dimensions (i.e. distance from centre)\n    in vec2 drawDimensions    // half dimensions (i.e. distance from centre)\n)\n{\n    if ( abs(uv.x) > drawDimensions.x || abs(uv.y) > drawDimensions.y ) return;\n    \n    vec4 tex = texture( iChannel0, ( uv * spriteDimensions/drawDimensions + spriteCentre )/iResolution.xy );\n    \n    fragColour.rgb = tex.rgb + fragColour.rgb*(1.-tex.a);\n    \n    // add up alphas - for collision detection\n    fragColour.a += ( tex.a==1. ) ? 1. : 0.;\n}\n\n// because we don't seem to be able to do default params\nvoid Sprite( inout vec4 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    Sprite( a, b, c, d, d ); // render sprite unscaled\n}\n\nvoid PlayerShip( inout vec4 fragColour, in vec2 uv )\n{\n    Sprite( fragColour, uv, vec2(16,32), vec2(16) );//, vec2(16.+sin(iTime/1.3)*8.,16.+sin(iTime/1.7)*8.) );\n    \n    if ( float(iFrame) < INVINCIBLE && fragColour.a == 1. && mod( float(iFrame), 6. ) < 2. )\n        fragColour.rgb = vec3(1);\n}\n\nvoid Enemy( inout vec4 fragColour, in vec2 uv )\n{\n    Sprite( fragColour, uv, vec2(80,16), vec2(16) );\n}\n\nvoid Bullet( inout vec4 fragColour, in vec2 uv )\n{\n    Sprite( fragColour, uv, vec2(8.5,60.5), vec2(2.5) );\n}\n\nvoid Shot( inout vec4 fragColour, in vec2 uv )\n{\n    Sprite( fragColour, uv, vec2(24,60), vec2(2,4) );\n}\n\nvoid Explosion( inout vec4 fragColour, in vec2 uv, in float frame, in vec2 scale )\n{\n    frame /= 3.; // don't play at 60Hz!\n    if ( frame >= .0 && frame < 8. )\n    \tSprite( fragColour, uv, vec2(272,16.+32.*floor(frame)), vec2(16,16), scale );\n}\n\nconst float BURST_FRAME = 30.;\n// blow up something that's 32x32 sized, so the whole thing is covered on BURST_FRAME\nvoid MassExplosion( inout vec4 fragColour, in vec2 uv, in float frame )\n{\n    Explosion( fragColour, uv-vec2(0,8), frame, vec2(8) );\n    Explosion( fragColour, uv-vec2(8,-8), frame-10., vec2(8) );\n    Explosion( fragColour, uv-vec2(-8,-4), frame-16., vec2(8) );\n    Explosion( fragColour, uv-vec2(4,-6), frame-20., vec2(12) );\n    Explosion( fragColour, uv-vec2(-12,6), frame-24., vec2(12) );\n\n    // main explosion, covering 32x32 sized thing (roughly)\n    Explosion( fragColour, uv, frame-BURST_FRAME, vec2(23) );\n\n    Explosion( fragColour, uv-vec2(16,8), frame-BURST_FRAME-3., vec2(8) );\n    Explosion( fragColour, uv-vec2(-8,16), frame-BURST_FRAME-3., vec2(8) );\n    Explosion( fragColour, uv-vec2(24,12), frame-BURST_FRAME-6., vec2(4) );\n    Explosion( fragColour, uv-vec2(-12,24), frame-BURST_FRAME-6., vec2(4) );\n}\n\nfloat Cloud ( vec2 uv )\n{\n    return smoothstep(.5,1.,texture( iChannel1, uv/1000. ).g);\n}\n\n\nvec3 Background( in vec2 coord )\n{\n//    return vec3(.3+.2*step(.0,dot(sin((uv+float(iFrame)*vec2(0,1))*6.28/8.),vec2(1,1))));\n    vec2 twist = normalize(vec2(1.68,1));\n    coord += vec2(0,iFrame);\n    vec2 uv = (coord*twist.x + coord.yx*twist.y*vec2(1,-1))/2000.;\n\n    vec3 col = texture( iChannel1, uv ).rgb;\n    float h = texture( iChannel2, uv*.7 ).x;\n    if ( h > col.g ) col = mix( col*vec3(.9,1,1), vec3(.0,.2,.4), pow(h-col.g,.3) );\n    h = .8-h;\n    if ( h > col.g ) col = mix( col, vec3(.5,.5,.3)-col*vec3(2,1,2), pow(h-col.g,.3) );\n    \n    // clouds\n    float cloud = Cloud(coord);\n    float shadow = Cloud(coord+vec2(-1,1)*2.);\n    col *= mix( vec3(1), vec3(.3,.4,.5), smoothstep(.0,.5,shadow) );\n    col = mix( col, vec3((cloud-shadow)*.5+.8), smoothstep(.0,.5,cloud) );\n        \n    // imitate palettised look\n    float dither = .25*abs( mod(coord.x,2.) - 3.*mod(coord.y,2.) ); // xy=00,10,01,11 -> 0,1,3,2 - to get checkerboard\n    float shades = 12.; // would be nice to do a more natural palette, but that's complicated\n    col += dither / shades;\n    col = floor(col*shades)/shades;\n    \n    return col;\n}\n\n// bullet pattern\n// input polar position\n// output negative = no bullet, positive = bullet\nfloat BulletPattern( vec2 p, float seed )\n{\n    p += .0001; // avoid edge cases\n    \n    // rings with holes\n    float ring = ((p.y+.25)/100. + seed*.5)*4./tau;\n    \n    float rings = -cos( ring*tau )-.9; // -p.y/5000.;\n    \n//    rings = min( rings, sin((p.x*2.+floor(mod(ring,3.))+seed)*6.) );\n    rings = min( rings, sin(p.x*2.+floor(mod(ring,3.))+seed)+.5 );\n    rings = min( rings, sin(p.x*8.+floor(mod(ring,3.))+seed) );\n    \n    // sweeps\n    float sweepangle = (sin(p.y/100. + seed*tau*.25)*.25)*tau;\n    float sweepcut = (sin(2.*(p.y/100. + seed*tau*.25+.3))*.25)-.12;\n    \n    float sweeps = step( abs(p.x-sweepangle), .2 );\n    sweeps = min( sweeps, sweepcut );\n    \n    float phase = sin(p.y / 300.)-.3;\n    \n    return mix( sweeps, rings, step(.0, phase) );\n}\n\n\nvoid DrawBullets( inout vec4 fragColour, in vec2 fragCoord, vec4 data, float index )\n{\n\t// find & draw closest bullet\n    const float bulletSpeed = 1.5;\n    const vec2 bulletRates = vec2(120./tau,1./6.); // bullets (per radian, per pixel-length)\n    vec2 source = data.xy;\n    vec2 uv = fragCoord - source;\n    vec2 polar = vec2( atan(-uv.x,-uv.y), length(uv) - float(iFrame)*bulletSpeed);\n    // quantize to possible bullet positions\n    polar = polar * bulletRates;\n    polar = floor(polar+.5);\n    polar = polar / bulletRates;\n    if ( ( polar.x < tau*.25 && polar.x > -tau*.25 )\n        && ( data.w == .0 || -polar.y/bulletSpeed < data.w )\n        && -polar.y/bulletSpeed > 20. ) // first shooting frame\n    {\n        // convert back to a position\n        uv = vec2(-sin(polar.x),-cos(polar.x)) * (polar.y + float(iFrame)*bulletSpeed);\n        uv += source;\n        // index the pattern using polar coord offset by time\n        float pattern = BulletPattern( polar, index );\n        if ( pattern > .0 ) Bullet( fragColour, fragCoord-uv );\n    }\n}\n\n\nvoid EnergyBar(inout vec4 fragColour, in vec2 fragCoord, in vec2 _min, in vec2 _max, in float damage )\n{\n    float range = _max.x-_min.x;\n    if ( Bounds( fragCoord, _min, _max-vec2(damage*range,0.) ) )\n    {\n        fragColour.rgb = mix( vec3(1,0,0), vec3(1,1,0), (fragCoord.x-_min.x)/range );\n    }\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    if ( fragCoord.x > RES.x || fragCoord.y > RES.y ) discard;\n    \n    fragCoord -= RES*.5;\n    fragCoord += .5;\n    \n    fragColour.rgb = Background(fragCoord);\n    \n\n    // collision detection: use alpha to count the number of things drawn\n    fragColour.a = .0;\n    \n    vec4 playerState = ReadData(DATA_SHIP);\n    vec2 uv = fragCoord-playerState.xy;\n    float deathTime = float(iFrame) - playerState.w;\n    if ( playerState.w == .0 || deathTime < BURST_FRAME )\n    {\n\t    PlayerShip( fragColour, uv );\n    }\n    \n    if ( //abs(uv.x) < 32. && abs(uv.y) < 32. &&\n        playerState.w > .0 && deathTime < 120. )\n    {\n        // blow up the ship!\n        MassExplosion( fragColour, uv, deathTime );\n    }\n\n    float isPlayer = step( .9, fragColour.a );\n    fragColour.a = .0;\n    \n    for ( int i = int(DATA_FIRSTENEMY); i <= int(DATA_LASTENEMY); i++ )\n    {\n    \tDrawBullets( fragColour, fragCoord, ReadData(float(i)), float(i) );\n    }\n    \n    float isBullet = step( .9, fragColour.a );\n    fragColour.a = .0;\n    \n//    fragColour.a = .0;\n\n    for ( int i = int(DATA_FIRSTENEMY); i <= int(DATA_LASTENEMY); i++ )\n    {\n        vec4 data = ReadData( float(i) );\n        uv = fragCoord-data.xy;\n        float deathTime = float(iFrame) - data.w;\n        if ( data.w == .0 || deathTime < BURST_FRAME )\n        {\n            Enemy( fragColour, uv );\n        }\n\n        if ( //abs(uv.x) < 32. && abs(uv.y) < 32. &&\n            data.w > .0 && deathTime < 120. )\n        {\n            // blow up the ship!\n            MassExplosion( fragColour, uv, deathTime );\n        }\n    }\n\n    float isEnemy = step( .9, fragColour.a );\n    fragColour.a = .0;\n\n    // find & draw closest shot - or just draw all of them (there's not many)\n    // bullets move faster than the ship, so they're always in a vertically-sorted order\n    vec4 shotData = ReadData( DATA_FIRSTSHOT );\n    for ( float i=DATA_FIRSTSHOT+1.; i < DATA_FIRSTSHOT+MAX_SHOTS; i++ )\n    {\n        vec4 data = ReadData( i );\n        if ( data.y > fragCoord.y + 4. ) break;\n        shotData = data;\n    }\n    Shot( fragColour, fragCoord - shotData.xy );//fragCoord-vec2(-10,-84. + mod(float(iFrame),40.)*8.) );\n    Shot( fragColour, fragCoord - shotData.zy );\n\n    float isShot = step( .9, fragColour.a );\n    \n    // record damage\n    fragColour.a = isPlayer*(isBullet+isEnemy) + isEnemy*isShot;\n\n    \n    // draw UI\n    {\n        EnergyBar( fragColour, fragCoord, vec2(-240,-180), vec2(-120,-170), ReadData(DATA_SHIP).z );\n        vec4 data = ReadData(DATA_FIRSTENEMY);\n        EnergyBar( fragColour, fragCoord, data.xy+vec2(-16,18), data.xy+vec2(15,20), data.z );\n        data = ReadData(DATA_LASTENEMY);\n        EnergyBar( fragColour, fragCoord, data.xy+vec2(-16,18), data.xy+vec2(15,20), data.z );\n    }\n    \n// find & draw closest explosion, or draw each if there's not many\n//  Explosion( fragColour, fragCoord-vec2(0. + sin(float(iFrame/(4*8)))*100.,60), mod(float(iFrame/4),8.), vec2(sin(float(iFrame/(4*8))*1.7)*16.+24.) );\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// shared section (can we get #includes or something please?!)\n\nconst vec2 RES = vec2(480,360); // vec2(384,288);\n\nconst float INVINCIBLE = 120.; // how many seconds is the player invincible at the start?\n\nconst float MAX_SHOTS = 10.;\nconst float SHOT_RATE = 8.;\nconst float SHOT_SPEED = 360./(SHOT_RATE*MAX_SHOTS); // screen height\n\n// data layout\nconst float DATA_SHIP = 0.;\nconst float DATA_FIRSTENEMY = 1.;\nconst float DATA_LASTENEMY = 2.;\nconst float DATA_FIRSTSHOT = 3.;\nconst float DATA_END = DATA_FIRSTSHOT + MAX_SHOTS;\n\nvec4 ReadData( float index )\n{\n\treturn texture( iChannel0, vec2(index+.5,0)/iResolution.xy );\n}\n\nbool Bounds( vec2 coord, vec2 _min, vec2 _max )\n{\n    vec2 test = step(_min,coord)*step(coord,_max);\n    return min(test.x,test.y) > .0;\n}\n\n// end of shared section\n\n\n// COLLISION DETECTION\n\n// I tried doing this in Buf A but the compiler was running this expensive loop on every pixel!\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    if ( fragCoord.y > 1. || fragCoord.x > 3. || float(iFrame) < INVINCIBLE ) discard;\n\n    vec4 data = ReadData(DATA_SHIP+floor(fragCoord.x)); // ship, enemy1, enemy2\n    \n    float damage = .0;\n    for ( int j=0; j < 32; j++ )\n    {\n        float Y = float(j) + data.y - 16.;\n        for ( int i=0; i < 32; i++ )\n        {\n            float X = float(i) + data.x - 16.;\n            damage += texture( iChannel1, (vec2(X,Y) + RES*.5)/iResolution.xy ).a;\n            if ( damage > .0 ) break;\n        }\n        if ( damage > .0 ) break;\n    }\n\n    fragColour = vec4( damage );\n    \n//    fragColour = texture( iChannel1, (mod(fragCoord,32.) + data.xy - 16. + RES*.5)/iResolution.xy );  \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}