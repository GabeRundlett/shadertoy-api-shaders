{
    "Shader": {
        "info": {
            "date": "1442153956",
            "description": "Practice ray tracing.",
            "flags": 0,
            "hasliked": 0,
            "id": "Xt2SRh",
            "likes": 8,
            "name": "Black Pearl",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "yibojiang",
            "viewed": 1997
        },
        "renderpass": [
            {
                "code": "#define pi 3.1415926\n#define intense 1.0\n#define rotspeed 0.5\nvec3 lightDir = vec3(0.0, -3.0, 2.0);\nvec3 ambCol = 0.5 * vec3(0.1, 0.1, 0.1);\nvec3 sphereCol = vec3(1.0, 1., 1.0);\nvec3 spherePos = vec3(0.0, 0.1, 0.0 );\n\nvec3 cylinderCol = vec3(0.1, 0.1, 0.1);\nvec3 cylinderPos = vec3(0.3, 0.1, 0.1);\nvec3 cylinderDir = normalize(vec3(0.1, 0.0, -0.1));\nfloat cylinderHeight = 0.1;\nvec3 eye = vec3(0.0, 0.3, -1.0);\n\nvec2 noise(vec2 tc) {\n    return (2.*texture(iChannel1, tc).xy - 1.0).xy;\n}\n\nvec4 tex(vec2 tc) {\n    return texture(iChannel0, tc, 2.0);\n}\n\nvec4 tex2(vec2 tc) {\n    return texture(iChannel1, tc, 2.0);\n}\n\n\nfloat intersectCylinder(inout vec3 color, in vec3 col, in vec3 eye, in vec3 ray, in vec3 p, in vec3 ndir, in float radius, in float height) {\n    float k = 0.0;\n    vec3 hit = vec3(0.0);\n\n    k = -dot(eye - p - height * ndir, ndir) / dot(ray, ndir);\n    hit = eye + k * ray;\n    if (k >= 0.) {\n        vec3 rr = hit - p - ndir * height;\n        if (length(rr) <  radius) {\n            vec3 normal = ndir;\n            vec3 l = normalize(lightDir);\n            vec3 v = normalize(ray);\n            vec3 n = normalize(normal );\n            vec3 r = reflect(v , n);\n            vec3 refr = refract(v, n, 1.1);\n            float diffuse = max( dot (n , -l ), 0.0);\n            float spec = 3.0 * pow(max(dot(l, -r), 0.0 ), 50.0);\n            vec3 cr = texture(iChannel2, r).xyz;\n            vec3 c = vec3(1.0) * step(length(rr / radius), 0.8);\n            color = intense * (c * diffuse + c * spec + ambCol);\n            color = c;\n            return k;\n        }\n    }\n\n\n\n    vec3 aa = ray - dot( ray , ndir ) * ndir;\n    float a = dot(aa, aa);\n    vec3 deltaP = eye - p;\n    float b = 2.0 * dot(ray - dot(ray, ndir) * ndir , deltaP - dot(deltaP , ndir) * ndir);\n    vec3 cc = deltaP - dot(deltaP, ndir) * ndir;\n    float c = dot(cc, cc) - radius * radius;\n    float delta = b * b - 4.0 * a * c;\n\n    if (delta >= 0.) {\n        k = (-b - sqrt(delta) ) / (2.0 * a);\n        if (k < 0.0) {\n            k = (-b + sqrt(delta) ) / (2.0 * a);\n        }\n\n        if (k >= 0.) {\n            vec3 hit = eye + k * ray;\n            vec3 q = hit - p;\n            float dotQ = dot(q, q);\n            if (dotQ < height * height + radius * radius && dotQ >= 0.0 && dot(q, ndir) > 0.0 ) {\n                vec3 q = hit - p;\n                vec3 normal = q - dot(q, ndir) * q;\n                vec3 l = normalize(lightDir);\n                vec3 v = normalize(ray);\n                vec3 n = normalize(normal);\n                vec3 r = reflect(v , n);\n                vec3 refr = refract(v, n, 1.1);\n                float diffuse = max( dot (n , -l ), 0.0);\n                float spec = 3.0 * pow(max(dot(l, -r), 0.0 ), 50.0);\n                vec3 cr = texture(iChannel2, r).xyz;\n                color = intense * (col * diffuse + c * spec + ambCol);\n                return k;\n            }\n        }\n\n    }\n\n\n    k = -dot(eye - p, ndir) / dot(ray, ndir);\n    hit = eye + k * ray;\n    if (k >= 0.) {\n        vec3 rr = hit - p;\n        if ( length(rr) <  radius) {\n            vec3 normal = ndir;\n            vec3 l = normalize(lightDir);\n            vec3 v = normalize(ray);\n            vec3 n = normalize(normal );\n            vec3 r = reflect( v , n );\n            vec3 refr = refract(v, n, 1.1);\n            float diffuse = max( dot (n , -l ), 0. );\n            float spec = 3.* pow( max(dot(l, -r), 0. ), 50. );\n            vec3 cr = texture(iChannel2, r).xyz;\n            color = intense * (col * diffuse + c * spec + ambCol );\n            return k;\n        }\n    }\n\n\n\n    return k;\n}\n\nfloat intersectSphere(inout vec3 color, in vec3 col, in vec3 eye, in vec3 ray, in vec3 p, in float r) {\n    float k = 0.;\n    vec3 c = p - eye;\n    float rc = dot(ray, c);\n\n    float delta = rc * rc + r * r - dot(c, c );\n    if (delta >= 0.) {\n        k = rc - sqrt(delta);\n        if (k < 0.) {\n            k = rc + sqrt(delta);\n        }\n\n        if (k >= 0.) {\n            vec3 hit = eye + k * ray;\n            vec3 normal = hit - p;\n            vec3 l = normalize(lightDir - p);\n            vec3 v = normalize(ray);\n            vec3 n = normalize(normal );\n\n            vec3 r = reflect( v , n );\n            vec3 refr = refract(v, n, 1.1);\n\n\n            float diffuse = max( dot (n , -l ), 0. );\n            float refrac = 1.0 * max( dot(v, refr), 0. );\n            float spec = 3.* pow( max(dot(l, -r), 0. ), 50. );\n            //float spec=2.* pow( max(dot(-h,n),0. ), 4. );\n            float fre = 1.7 * pow(0.01 + clamp( dot(r, v), 0.0, 1.0), 3. );\n            //float fre =1.0* pow(0.5+ clamp(dot(-refr,v),0.0,1.0), 1.0 );\n            vec3 frecol = texture(iChannel2, r).xyz;\n\n            vec3 c = col;\n            //c=tex2( vec2(normal.x,normal.y) ).xyz;\n            //vec3 cr=texCube(r).xyz;\n\n            vec3 crf = texture(iChannel2, r).xyz;\n\n            //From Shane\n            vec3 bgCol = color;\n            color = intense * (frecol * fre + c * spec + ambCol );\n            float edge = smoothstep(0., .2, dot(-ray, n));\n            color = mix(bgCol, color, edge);\n\n            //color=intense*(frecol * fre+ c*spec  +  ambCol );\n            return k;\n        }\n\n    }\n\n\n    return 0.;\n\n}\n\nfloat intersectPlane(inout vec3 color, in vec3 col, in vec3 eye, in vec3 ray, in vec3 p, in vec3 normal) {\n    float k = 0.;\n    k = -dot(eye, normal) / dot(ray, normal);\n    if (k > 0.) {\n\n        vec3 hit = eye + k * ray;\n\n        vec3 n = normalize(normal);\n        //vec3 n1=2.*texture(iChannel1, vec2( hit.x,hit.z),.9).xyz;\n        // n=tex(1.0*vec2( hit.x,hit.z)).xyz;\n        vec3 v = normalize(ray);\n        vec3 l = normalize(lightDir);\n\n        float fade = smoothstep(0.0, 1.0, k / 2.5 );\n        vec3 c = vec3(0.);\n        c = col * fade;\n        //c=col;\n        //c=1.0*tex(1.0*vec2( hit.x,hit.z)).xyz;\n        //c=0.2*texCube( vec3(hit.x*1.,hit.z*1.,-1.0) ).xyz;\n        float diffuse = max(dot(n , -l ), 0. );\n        vec3 r = reflect(v, n );\n\n\n        //r=-l+v;\n        float spec = 1.* pow( max(dot(l, -r), 1. ), 9. );\n\n        vec3 refcol = vec3(0.);\n        intersectSphere(refcol, sphereCol, hit , r, spherePos, .1 );\n\n        vec3 shadowCol = vec3(1.0);\n        float shadow = 1.0 - intersectSphere(shadowCol, vec3(0.4), hit , -l, spherePos, .1 );\n        //shadowCol=clamp(shadowCol, vec3(0.),vec3(1.) );\n        //shadowCol=clamp(sign(shadowCol-vec3(0.99)),vec3(0.),vec3(1.) );\n        //color=(intense*(c* diffuse +intense*2.*ambCol*fade+ intense*0.2*refcol) )* shadowCol  ;\n        color = intense * (c * diffuse + ambCol + 0.0 * spec * c + 0.2 * refcol) * shadow ;\n        //color=vec3(1.,1.,1.)*v;\n        //color=refcol;\n        return k;\n\n    }\n\n    return 0.;\n}\n\nmat3 rotate(float rx, float ry, float rz) {\n    mat3 rtx = mat3(\n                   1., 0., 0.,\n                   0., cos(rx) , -sin(rx),\n                   0., sin(rx), cos(rx) );\n    mat3 rtz = mat3(\n                   cos(rz) , -sin(rz), 0.,\n                   sin(rz), cos(rz), 0.,\n                   0., 0., 1.);\n    mat3 rty = mat3(\n                   cos(ry), 0. , sin(ry),\n                   0.0, 1.0, 0.0,\n                   -sin(ry), 0., cos(ry) );\n    return rtx * rty * rtz;\n}\n\nmat4 move(float mx, float my, float mz) {\n    return mat4(\n               1., 0., 0., mx,\n               0., 1., 0., my,\n               0., 0., 1., mz,\n               0., 0., 0., 1.\n           );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n    vec2 uv = p - vec2(0.5, 0.5);\n\n\n    uv.y *= iResolution.y / iResolution.x;\n    vec2 q = uv;\n    vec3 color = vec3(1.0);\n\n\n\n    float ligthrt = iTime;\n    ligthrt = 0.;\n    mat3 rtl = rotate(0., ligthrt, 0.);\n\n    float rt = pi * .4 - iTime * rotspeed;\n    //rt=0.0;\n    float rtx = abs(sin(iTime * rotspeed) );\n\n    rtx = pi * .0;\n    rtx = 0.25;\n    if (iMouse.z > 0.) {\n        rt = iMouse.x * 0.01 - pi * .5;\n        //rtx=iMouse.y*0.01-pi*.5;\n    }\n\n\n    vec4 eyepos = vec4(eye.xyz, 1.0);\n    //eyepos*=move( 0.,sin(rtx),1.0-cos(rtx) );\n    eyepos *= move( sin(-rt) , 0., 1.0 - cos(-rt) );\n\n    lightDir *= rtl;\n    eye = eyepos.xyz;\n\n\n    vec3 ray = normalize(vec3(q.x, q.y, 1.3) );\n    ray *= rotate(rtx, 0., 0.);\n    ray *= rotate(0., rt, 0.);\n\n\n\n    //vec3 ww = ray;\n    //vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    //vec3 vv = normalize( cross(uu,ww));\n    //vec3 rd = normalize( q.x*uu + q.y*vv + 4.0*ww );\n    //color = texture(iChannel2, rd).rgb;\n\n\n\n    //spherePos=vec3(0.0, 0.1,0.0 );\n    //spherePos.x=0.+.2*cos(iTime*1.);\n    //spherePos.z=1.0+.2*sin(iTime*1.);\n    //spherePos.y=0.1+abs(0.1*sin(iTime*3.) );\n\n    intersectPlane(color, vec3(.2), eye, ray, vec3(.0, 0.0, .0), vec3(0., 1.0, 0.) );\n    //intersectCylinder(color, cylinderCol  ,eye,ray, cylinderPos,cylinderDir,.1 ,cylinderHeight );\n    intersectSphere(color, sphereCol , eye , ray, spherePos, .1 );\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}