{
    "Shader": {
        "info": {
            "date": "1552847906",
            "description": "Fork of ShaderDojo by antonOTI: [url]https://www.shadertoy.com/view/Ws2Szz[/url]\nUse mouse, arrow keys, shift and ctrl to move around\n\nthis is faster (on my machine) and has perfect geometry intersections and normals.",
            "flags": 48,
            "hasliked": 0,
            "id": "wdjSzz",
            "likes": 10,
            "name": "fork of  ShaderDojo022 ",
            "published": 3,
            "tags": [
                "fork",
                "intersections"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 528
        },
        "renderpass": [
            {
                "code": "#define PI acos(-1.0)\n#define TAU (PI * 2.)\n#define rad1 25.0\n#define rad2 10.0\n#define size1 vec3(6)\n#define size2 vec2(80)\n#define FAR 400.0\n#define STEPS 200\n\nfloat plane(vec3 ro, vec3 rd, vec3 n, float l) {\n    float a = dot(rd, n);\n    float b = dot(ro,n)-l;\n\n    if (b*a > 0.0) return sign(a)*10000.0;\n\n    return b/abs(a);\n\n}\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x ) { // in [0,1]\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.-2.*f);\n\n    float n = p.x + p.y*57. + 113.*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\n    return res;\n}\n\nfloat solid(vec3 p, vec3 rd, float s, inout vec3 n)\n{\n    float distn = 0.0;\n    float distf = 10000.0;\n    vec3 dir = vec3(0.,1.,0.);\n    float h = 3.;\n    float v = 6.;\n    mat2 hr = rot(TAU / h);\n    mat2 vr = rot(TAU / v);\n\n    for(float j = 0.; j < v; ++j)\n    {\n        for(float i = 0.; i < h; ++i)\n        {\n            float ran = (hash(s + j * i)-.5) ;\n\n            float len = plane(p, rd, dir,1.0+ran);\n\n            if (len >= 0.0) {\n\n                if (len > distn) {\n                    distn = len;\n                    n = dir;\n                }\n            } else {\n                distf = min(distf,-len);\n            }\n\n            dir.xz *= hr;\n        }\n\n        dir.yz *= vr;\n    }\n    if (distf < distn) distn = 100000.0;\n    return distn;\n}\n\nvec4 getdata(int index) {\n    ivec2 p;\n    p.x = index%int(iResolution.x);\n    p.y = index/int(iResolution.x);\n    return texelFetch(iChannel0,p,0);\n}\n\nvec2 cylinder(in vec2 ro, in vec2 rd, in float sph )\n{\n    vec2 oc = ro;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph*sph;\n    float h = b*b - c;\n    if( h<0.0) return vec2(-1,-2);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\n#define routine() \\\n    float amount = iTime*0.1+c*0.4; \\\n    mat2 r1 = rot(amount); \\\n    mat2 r2 = rot(-amount); \\\n    vec3 rd2 = rd; \\\n    rd2.xy *= r1; \\\n    lp.xy *= r1; \\\n    lp.y -= rad2; \\\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n\n    vec3 ro = getdata(campos).xyz;\n    ro.z -= iTime*2.0;\n    vec3 rd = normalize(vec3(uv,1));\n\n    vec4 rotcam = getdata(camrot);\n\n    rd.zy *= rot(rotcam.y);\n    rd.zx *= rot(rotcam.x);\n\n    vec3 a = 1.0/max(abs(rd),0.001);\n\n    vec2 boxc = floor(ro.xy/size2+0.5);\n    vec3 rol = ro-vec3(boxc*size2,0);\n    vec2 box = abs(step(0.0,rd.xy)*size2.xy-(rol.xy+size2*0.5))*a.xy;\n\n    vec2 cyl = cylinder(rol.xy,rd.xy/length(rd.xy), rad1)/length(rd.xy);\n\n    cyl.x = max(cyl.x,0.0);\n    cyl.y = min(cyl.y,FAR);\n\n    float d = cyl.x;\n\n    vec3 lp = rol+rd*d;\n\n    float c = floor(lp.z/size1.z);\n    lp.z = lp.z-c*size1.z;\n\n    vec3 n;\n    vec3 nor = vec3(0);\n    float nl = abs(step(0.0,rd.z)*size1.z-lp.z)*a.z;\n\n    routine()\n\n    vec2 b = 1.0/max(abs(rd2.xy),0.001);\n    vec2 e = floor(lp.xy/size1.xy);\n    lp.xy = lp.xy-e*size1.xy;\n    vec2 grid = abs(step(0.0,rd2.xy)*size1.xy-lp.xy)*b;\n\n    for (int i = 0; i < STEPS; i++) {\n\n        float h = step(grid.x,grid.y);\n        vec2 mask1 = vec2(h,1.0-h);\n        float gl = dot(grid,mask1);\n\n        vec3 lp = rol+rd*d;\n        lp.z = lp.z-c*size1.z;\n\n        routine()\n\n        lp.xy = lp.xy-e*size1.xy;\n\n        float sl = 1000.0;\n\n        if ( rad1-rad2-sqrt(2.0) > length((e+0.5)*size1.xy)) {\n\n            lp -= size1*0.5;\n            vec3 rd3 = rd2;\n            mat2 r = rot(iTime);\n            lp.xz *= r;\n            rd3.xz *= r;\n            r = rot(iTime * .5);\n            lp.xy *= r;\n            rd3.xy *= r;\n            r = rot(iTime * .25);\n            lp.yz *= r;\n            rd3.yz *= r;\n\n\n            sl = solid(lp,rd3,c+e.x*PI+e.y*PI*PI,n);\n\n            n.yz *= rot(-iTime * .25);\n            n.xy *= rot(-iTime * .5);\n            n.xz *= rot(-iTime);\n            n.xy *= r2;\n\n        }\n\n        float l = min(min(gl,sl),nl);\n        d += l;\n        grid -= l;\n        nl -= l;\n        box -= l;\n        if (d > FAR) {\n            break;\n        } else if (nl == 0.0||d > cyl.y) {\n            if (d > cyl.y) {\n                float h = step(box.x,box.y);\n                vec2 mask2 = vec2(h,1.0-h);\n                float bl = dot(box,mask2);\n\n                box -= bl;\n                d += bl;\n                box += mask2*a.xy*size2;\n\n                boxc += mask2*sign(rd.xy);\n\n                rol = ro-vec3(boxc*size2,0);\n\n                cyl = cylinder(rol.xy,rd.xy/length(rd.xy), rad1)/length(rd.xy);\n\n                cyl.x = max(cyl.x,0.0);\n                cyl.y = min(cyl.y,FAR);\n\n                d = cyl.x;\n\n\n                lp = rol+rd*d;\n\n                c = floor(lp.z/size1.z);\n                lp.z = lp.z-c*size1.z;\n\n                nl = abs(step(0.0,rd.z)*size1.z-lp.z)*a.z;\n            } else if (nl == 0.0) {\n                c += sign(rd.z);\n                nl = a.z*size1.z;\n                \n                lp = rol+rd*d;\n                lp.z = lp.z-c*size1.z;\n            }\n\n            routine()\n\n            b = 1.0/max(abs(rd2.xy),0.001);\n            e = floor(lp.xy/size1.xy);\n            lp.xy = lp.xy-e*size1.xy;\n            grid = abs(step(0.0,rd2.xy)*size1.xy-lp.xy)*b;\n\n            //break;\n        } else if (l == sl) {\n            nor = n;\n            break;\n        } else if (l == gl) {\n            grid += mask1*b*size1.xy;\n            e += mask1*sign(rd2.xy);\n            //break;\n        }\n\n    }\n\n\n    vec3 p = ro+rd*d;\n\n    // Output to screen\n    fragColor = mix(vec4(0.5,1.,0.4,1.), vec4(.3,.1,.5,1.), pow((rd.x * .3 + 0.5), 1.2));\n    if (nor != vec3(0)) {\n\n        vec3 ld = normalize(vec3(1.,-1.,1.));\n        float li = dot(nor,ld);\n        fragColor = mix(\n            fragColor,\n            mix(vec4(.5,.5,.5,1.), vec4(.1,.1,.2,1.), li),\n            exp(-d * .003));\n\n    }\n    //if (d < FAR) fragColor = vec4(fract(p),1);\n    fragColor = pow(fragColor,vec4(1.0/2.2));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define lastmouse 0\n#define campos 1\n#define camrot 2\n\n#define rot(A) mat2(cos(A),-sin(A),sin(A),cos(A))\n#define sqr(a) (a*a)\n\n#define sensitivity 3.0\n#define movespeed 50.0\n\n//keyboard keys\n#define KEY_UP    38\n#define KEY_DOWN  40\n#define KEY_RIGHT 39\n#define KEY_LEFT  37\n#define KEY_SHIFT 16\n#define KEY_CTRL  17\n\n//movement keys\n#define MOVE_FORW   KEY_UP\n#define MOVE_LEFT   KEY_LEFT\n#define MOVE_RIGHT  KEY_RIGHT\n#define MOVE_BACK   KEY_DOWN\n#define MOVE_UP     KEY_SHIFT\n#define MOVE_DOWN   KEY_CTRL\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "float getkey(int x, int y)\n{\n    return texelFetch(iChannel1,ivec2(x,y),0).x;\n}\n\nvec4 getdata(int index) {\n    ivec2 p;\n    p.x = index%int(iResolution.x);\n    p.y = index/int(iResolution.x);\n    return texelFetch(iChannel0,p,0);\n}\nvec4 updatedata(int index) {\n    vec4 data = getdata(index);\n    \n    vec4 iMouse2 = getdata(lastmouse);\n    \n    \n    bool refresh = iFrame == 0;\n    \n    if (index == lastmouse) {\n        return iMouse;\n    } else if (index == campos) {\n        \n        if (refresh) {\n            return vec4(vec3(-20,20,0),1);\n        }\n        \n        vec4 rotcam = getdata(camrot);\n        \n        vec3 move = vec3(getkey(MOVE_RIGHT,0)-getkey(MOVE_LEFT,0),\n                         getkey(MOVE_UP   ,0)-getkey(MOVE_DOWN,0),\n                         getkey(MOVE_FORW ,0)-getkey(MOVE_BACK,0));\n        \n        move.zy *= rot(rotcam.y);\n        move.zx *= rot(rotcam.x);\n        \n        \n        vec3 newpos = data.xyz+movespeed*move*iTimeDelta;\n        \n        data.xyz = newpos;\n        \n        return data;\n    } else if (index == camrot) {\n        \n        if (refresh) {\n            return vec4(0.5,-0.3,0,0);\n        }\n        \n        if (min(iMouse2.z,iMouse.z) > 0.5) {\n            data.xy += (iMouse.xy-iMouse2.xy)/iResolution.y*sensitivity;\n        }\n        return data;\n    }\n    \n    \n    return data;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    fragColor = updatedata(coord.x+coord.y*int(iResolution.x));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}