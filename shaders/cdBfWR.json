{
    "Shader": {
        "info": {
            "date": "1689578816",
            "description": "example",
            "flags": 0,
            "hasliked": 0,
            "id": "cdBfWR",
            "likes": 0,
            "name": "iscg-2023-sunskyxh",
            "published": 3,
            "tags": [
                "example"
            ],
            "usePreview": 0,
            "username": "SunskyXH",
            "viewed": 144
        },
        "renderpass": [
            {
                "code": "// 単純なレイトレーシングの雛形\n\nstruct Ray\n{\n    vec3 org;\n    vec3 dir;\n};\n\nstruct Hit\n{\n    float distanceToHitpoint;\n    vec3 normal;\n};\n\n// 各種パラメータの例\nfloat FilmWidth() { return iResolution.x / 100.0; }\nfloat FilmHeight() { return iResolution.y / 100.0;  }\nfloat FilmDistance() { return 8.0; }\n\nvec3 CameraFrom() { return vec3(0.0, 0.0, -3.0); }\nvec3 CameraTo() { return vec3(0.0, 0.0, 1.0); }\nvec3 CameraUp() { return vec3(0.0, 1.0, 0.0); }\n\nfloat LargeFloat() { return 1e+6; }\n\n// 正規直交基底を計算する関数の例\nvoid createOrthoNormalBasis(\n    vec3 from, vec3 to, vec3 up,\n    out vec3 u, out vec3 v, out vec3 w, out vec3 e\n)\n{\n    w = normalize(from - to);\n    u = normalize(cross(up, w));\n    v = cross(w, u);\n    e = from;\n}\n\nvec3 convertToCameraCoordinateSystem(\n    vec2 pixelCoordinate\n)\n{\n\n\tfloat time = 32.0 + iTime*1.5;\n    vec3 offset = vec3(2.0 * cos(0.1 * time), 0, 2.0 * sin(0.1 * time));\n    \n    float filmWidth = FilmWidth();\n    float filmHeight = FilmHeight();\n    float filmDistance = FilmDistance();\n    vec3 cameraFrom = CameraFrom();\n    vec3 cameraTo = CameraTo() + offset;\n    vec3 cameraUp = CameraUp();\n\n    vec3 u, v, w, e;\n    createOrthoNormalBasis(cameraFrom, cameraTo, cameraUp, u, v, w, e);\n\n    vec3 filmPlaneCenter = cameraFrom - w * filmDistance;\n    vec3 filmPlaneRight = u * filmWidth * (pixelCoordinate.x - iResolution.x / 2.0) / iResolution.x;\n    vec3 filmPlaneUp = v * filmHeight * (pixelCoordinate.y - iResolution.y / 2.0) / iResolution.y;\n\n    return normalize(filmPlaneCenter + filmPlaneRight + filmPlaneUp - e);\n}\n\nRay generateCameraRay(\n    vec2 pixelCoordinate\n)\n{\n    vec3 dir = convertToCameraCoordinateSystem(pixelCoordinate);\n    vec3 org = CameraFrom();\n    return Ray(org, dir);\n}\n\nbool intersectToSphere(\n    vec3 center, float radius, Ray ray,\n    out Hit hit\n)\n{\n    vec3 oc = ray.org - center;\n    float a = dot(ray.dir, ray.dir);\n    float b = 2.0 * dot(oc, ray.dir);\n    float c = dot(oc, oc) - radius * radius;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0) {\n        return false;\n    }\n    float t = (-b - sqrt(discriminant)) / (2.0 * a);\n    if (t < 0.0) {\n        t = (-b + sqrt(discriminant)) / (2.0 * a);\n        if (t < 0.0) {\n            return false;\n        }\n    }\n    hit.distanceToHitpoint = t;\n    hit.normal = normalize(ray.org + t * ray.dir - center);\n    return true;\n}\n\nbool intersectToPlane(vec3 center, vec2 size, Ray ray, out Hit hit) {\n    vec3 normal = vec3(0.0, 0.0, 1.0);\n    vec3 p = center - ray.org;\n    float t = dot(p, normal) / dot(ray.dir, normal);\n    if (t < 0.0) {\n        return false;\n    }\n    vec3 hitpoint = ray.org + t * ray.dir;\n    vec2 halfSize = size * 0.5;\n    if (abs(hitpoint.x - center.x) > halfSize.x || abs(hitpoint.y - center.y) > halfSize.y) {\n        return false;\n    }\n    hit.distanceToHitpoint = t;\n    hit.normal = normal;\n    return true;\n}\n\n\nbool intersect(Ray ray, out Hit hit)\n{\n    hit.distanceToHitpoint = LargeFloat();\n\n    vec3 plane_center = vec3(0.5, 0.0, 0.0);\n    vec2 plane_size = vec2(0.5, 1.0);\n    \n    vec3 sphere_center = vec3(-0.5, 0.0, 0.0);\n    float radius = 0.5;\n    \n    if(intersectToPlane(plane_center, plane_size, ray, hit)) return true;\n    if(intersectToSphere(sphere_center, radius, ray, hit)) return true;\n    return false;\n}\n\nvec3 shade(Ray ray, Hit hit)\n{\n    return hit.normal * 0.5 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Ray ray = generateCameraRay(fragCoord);\n    float time = 32.0 + iTime*1.5;\n     \n    Hit hit;\n    if (intersect(ray, hit)) {\n        fragColor = vec4(shade(ray, hit), 0.0);\n    } else {\n        fragColor = vec4(0.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}