{
    "Shader": {
        "info": {
            "date": "1717936266",
            "description": "The ADSR curve is a fundamental tool used in all audio synthesizers.\nFeel free to play with the values (see custom_adsr_curve_1() in Common).\n\nRead more: [url]https://en.wikipedia.org/wiki/Envelope_(music)[/url]\n",
            "flags": 8,
            "hasliked": 0,
            "id": "M3VGRK",
            "likes": 8,
            "name": "Attack-Decay-Sustain-Release",
            "published": 3,
            "tags": [
                "audio",
                "utils",
                "adsr"
            ],
            "usePreview": 0,
            "username": "beans_please",
            "viewed": 174
        },
        "renderpass": [
            {
                "code": "// NOTE: this tab is a modification of the following shader:\n// https://www.shadertoy.com/view/mtjyDw\n\n\n\nfloat f(float x)\n{\n    return custom_adsr_curve_1(x);\n}\n\nconst float zoom = 1.;\nconst float max_thickness = .01;\nfloat px2uv; // (defined in main)\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sd_segment(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat dist_f(vec2 p)\n{\n    // We have a line between every something pixels.\n    // The line vertices lie on f(x).\n    int n = int(iResolution.x);\n    \n    // Total horizontal length of the lines (screen length in UV)\n    float total_len = iResolution.x * px2uv;\n    \n    // Distance between the line vertices (in UV)\n    float step_size = total_len / float(n);\n    \n    // Index range of the lines which we want to check\n    int idx0 = int(floor((p.x - max(max_thickness, step_size)) / step_size));\n    int idx1 = int(floor((p.x + max(max_thickness, step_size)) / step_size));\n    \n    // Initial distance\n    float dist = 1e9;\n    \n    // Find the minimum distance from the lines we chose\n    for (int i = idx0; i <= idx1; i++)\n    {\n        // Point A of the line segment\n        float ax = float(i) * step_size;\n        float ay = f(ax);\n        \n        // Point B of the line segment\n        float bx = float(i + 1) * step_size;\n        float by = f(bx);\n        \n        // Distance\n        dist = min(dist, sd_segment(p, vec2(ax, ay), vec2(bx, by)));\n    }\n    \n    return dist;\n}\n\n#define SNAP(X, STEP) ((floor(X / STEP) + .5) * STEP)\n\nvec3 render(vec2 frag_coord)\n{\n    // UV\n    vec2 uv = px2uv * (frag_coord - iResolution.xy * .5);\n    uv += vec2(.5, .45);\n    if (iMouse.z > .2)\n    {\n        uv += px2uv * (abs(iMouse.zw) - iMouse.xy);\n    }\n\n    // Render grid\n    vec3 col = vec3(.024, .038, .064);\n    vec3 col_grid = vec3(0, 0, .02);\n    #if 0\n    {\n        // Snap grid lines to pixels\n        // For this to work you need to disable the paper effect above\n        \n        #define SNAP_PX(X) SNAP(X, px2uv)\n        \n        float d = min(abs(uv.x - SNAP_PX(round(uv.x))), abs(uv.y - SNAP_PX(round(uv.y))));\n        if (d < .5 * px2uv) col = mix(col, col_grid, .5);\n        \n        vec2 t = uv * 4.;\n        d = min(abs(t.x - SNAP_PX(round(t.x))), abs(t.y - SNAP_PX(round(t.y))));\n        if (d < .5 * px2uv * 4.) col = mix(col, col_grid, .2);\n        \n        d = min(abs(uv.x), abs(uv.y));\n        if (d < 1. * px2uv) col = col_grid;\n    }\n    #else\n    {\n        // Don't snap to pixels\n        \n        float d = min(abs(uv.x - round(uv.x)), abs(uv.y - round(uv.y)));\n        if (d < .004) col = mix(col, col_grid, .5);\n        \n        vec2 t = uv * 4.;\n        d = min(abs(t.x - round(t.x)), abs(t.y - round(t.y)));\n        if (d < .004 * 4.) col = mix(col, col_grid, .2);\n        \n        d = min(abs(uv.x), abs(uv.y));\n        if (d < .005) col = col_grid;\n    }\n    #endif\n    \n    // Distance from f(x)\n    float d = dist_f(uv);\n    \n    // Render the graph\n    float thick = max_thickness;\n    float graph_fac = remap01(d, thick, thick - px2uv);\n    col = mix(col, vec3(.3, .6, 0.7), graph_fac);\n    \n    // Highlight the current part in time\n    float highlight_fac = min(\n        remap01(abs(uv.x - mod(iTime, 1.8)), .03, .02),\n        graph_fac\n    );\n    col = mix(col, vec3(.12, 0, .3), highlight_fac);\n    \n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Pixel to UV conversion factor\n    px2uv = 2. * zoom / min(iResolution.x, iResolution.y);\n    \n    // Super-sampling\n    vec3 col = vec3(0);\n    {\n        col += render(frag_coord + vec2(-.25, -.25));\n        col += render(frag_coord + vec2(-.25, +.25));\n        col += render(frag_coord + vec2(+.25, +.25));\n        col += render(frag_coord + vec2(+.25, -.25));\n    }\n    col /= 4.;\n    \n    // Output\n    col = pow(col, vec3(1. / 2.2));\n    frag_col = vec4(col, 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*__________ math utils (INCOMPLETE) __________*/\n\nconst float PI = 3.141592653589793238462643383;\nconst float TAU = 6.283185307179586476925286767;\nconst float PI_OVER_2 = 1.570796326794896619231321692;\nconst float INV_PI = .318309886183790671537767527;\nconst float INV_TAU = .159154943091895335768883763;\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t * (b - a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T v, float start, float end) \\\n{ \\\n    return start + mod(v - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T v, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start \\\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp( \\\n    T v, \\\n    float inp_start, \\\n    float inp_end, \\\n    float out_start, \\\n    float out_end \\\n) \\\n{ \\\n    T t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T v, float inp_start, float inp_end) \\\n{ \\\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n}\n\n#define FUNC_LENGTH_SQ(T) \\\nfloat length_sq(T v) \\\n{ \\\n    return dot(v, v); \\\n}\n\n#define FUNC_DIST_SQ(T) \\\nfloat dist_sq(T a, T b) \\\n{ \\\n    a -= b; \\\n    return dot(a, a); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nFUNC_LENGTH_SQ(vec2)\nFUNC_LENGTH_SQ(vec3)\nFUNC_LENGTH_SQ(vec4)\n\nFUNC_DIST_SQ(vec2)\nFUNC_DIST_SQ(vec3)\nFUNC_DIST_SQ(vec4)\n\n\n\n/*___________________ audio ___________________*/\n\n// C0 = 0, C5 = 60\nfloat note_to_freq(int note)\n{\n    const float a = 440.;\n    return (a / 32.) * pow(2., float(note - 9) / 12.);\n}\n\nfloat db_to_mul(float db)\n{\n    return pow(10., .05 * db);\n}\n\nfloat mul_to_db(float mul)\n{\n    return 8.68588963808 * log(mul);\n}\n\n// curve similar to ones used in automation and envelope curves in most VSTs and\n// DAWs\n// https://www.desmos.com/calculator/kvkzogpxjk\nfloat expow(float t, float p)\n{\n    t = clamp(t, 0., 1.);\n    if (p >= 0.)\n    {\n        return pow(t, pow(2., p));\n    }\n    return 1. - pow(1. - t, pow(2., -p));\n}\n\nstruct Adsr\n{\n    float delay;        // >=0\n    float attack;       // >=0\n    float attack_pow;   // any\n    float hold;         // >=0\n    float decay;        // >=0\n    float decay_pow;    // any\n    float sustain;      // 0-1\n    float release;      // >=0\n    float release_pow;  // any\n};\n\nfloat Adsr_internal_ads(in Adsr self, float t)\n{\n    if (t < 0.)\n    {\n        return 0.;\n    }\n    if (t < self.attack)\n    {\n        return expow(t / self.attack, -self.attack_pow);\n    }\n    t -= self.attack;\n    if (t < self.hold)\n    {\n        return 1.;\n    }\n    t -= self.hold;\n    if (t < self.decay)\n    {\n        return remap(\n            expow(t / self.decay, self.decay_pow),\n            0., 1.,\n            1., self.sustain\n        );\n    }\n    return self.sustain;\n}\n\nfloat Adsr_internal_release(in Adsr self, float t, float v_before_release)\n{\n    if (t < self.release)\n    {\n        return remap(\n            expow(t / self.release, self.release_pow),\n            0., 1.,\n            v_before_release, 0.\n        );\n    }\n    return 0.;\n}\n\nfloat Adsr_eval(in Adsr self, float t, float note_length)\n{\n    t -= self.delay;\n    note_length -= self.delay;\n    if (t < note_length)\n    {\n        return Adsr_internal_ads(self, t);\n    }\n    else\n    {\n        float t_before_release = min(\n            note_length,\n            self.delay + self.attack + self.hold + self.decay\n        );\n        float v_before_release = Adsr_internal_ads(\n            self,\n            t_before_release\n        );\n        return Adsr_internal_release(\n            self,\n            t - note_length,\n            v_before_release\n        );\n    }\n}\n\nfloat custom_adsr_curve_1(float t)\n{\n    Adsr adsr;\n    adsr.delay = 0.02;      // start with 20 ms of delay\n    adsr.attack = .03;      // rise to full volume in 30 ms\n    adsr.attack_pow = 0.;   // rise to full volume linearly\n    adsr.hold = 0.05;       // stay at full volume for 50 ms\n    adsr.decay = .5;        // decay to 65% volume in 0.5 s\n    adsr.decay_pow = -.9;   // start decaying quickly and then slow down\n    adsr.sustain = .65;     // volume to decay to: 65%\n    adsr.release = .2;      // when the key is released, go to 0% in 200 ms\n    adsr.release_pow = -1.; // start going to 0% quickly and then slow down\n\n    return Adsr_eval(\n        adsr,\n        t,\n        1. // the key is released after 1 second\n    );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "const int KEY = 60;\n\nfloat inst_sine(float t, float freq)\n{\n    return sin(TAU * freq * t);\n}\n\nvec2 mainSound(int samp, float t)\n{\n    float v = .05 * inst_sine(note_to_freq(KEY), t + .1);\n    v += .05 * inst_sine(note_to_freq(KEY + 3), t + .2);\n    v += .05 * inst_sine(note_to_freq(KEY + 7), t + .3);\n    v += .05 * inst_sine(note_to_freq(KEY + 12), t + .4);\n    v += .05 * inst_sine(note_to_freq(KEY - 12), t + .5);\n    v += .05 * inst_sine(note_to_freq(KEY - 9), t + .6);\n    v += .05 * inst_sine(note_to_freq(KEY - 5), t + .7);\n    v += .01 * inst_sine(note_to_freq(KEY + 10), t + .8);\n    v += .01 * inst_sine(note_to_freq(KEY + 19), t + .7);\n    v += .005 * inst_sine(note_to_freq(KEY + 24), t + .7);\n    v *= 2.2;\n\n    // scale the volume with the ADSR curve\n    v *= custom_adsr_curve_1(mod(t, 1.8));\n    \n    return vec2(v);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}