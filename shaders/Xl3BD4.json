{
    "Shader": {
        "info": {
            "date": "1539592144",
            "description": "pause time andrag mouse to set AABV corners\n\nprogress on fixing [spartial folding of chords in 4d] of\nhttps://www.shadertoy.com/view/XtdfDH\nwith\nhttps://www.shadertoy.com/view/lsffDM\nis slow but significant\ni did not expect quantum physics to be relevant.",
            "flags": 0,
            "hasliked": 0,
            "id": "Xl3BD4",
            "likes": 11,
            "name": "pmod quantize chord tartan ",
            "published": 3,
            "tags": [
                "starguitar",
                "irrationalstride",
                "arpshepardtone",
                "ditherhairlinequantize",
                "chromaticscalecordtartanweave",
                "euclideanbeats",
                "euclideanrythm"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1235
        },
        "renderpass": [
            {
                "code": "//while this approach is precise, it is allso convoluted.\n//the core function is:   return  floor(u*l/r)-floor((u-1.)*l/r)\n//of                https://www.shadertoy.com/view/7s3SzX\n//as implemented in https://www.shadertoy.com/view/WdGBzR\n//\n//at the cost of some (often irrelevant) imprecuision-artefacts..\n//, mostly due to negative-modulo and symmetry-near-0 (no negative null)\n//tghat THIS more-brute (overly buerocratic) approach does not seem to have.\n//but that https://www.shadertoy.com/view/WdGBzR clearly demoes. \n//error ==> flickering at Rayorigin, because 0.0000 duplicates into -0.00001\n\n//iMouseZwFix is just for backwards compatibility.\nvec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n\n//three voice harmony minor major chord (old)\n//parent: https://www.shadertoy.com/view/lsffDM \n//parent: https://www.shadertoy.com/view/XtdfDH\n/*\nmaking 2 dots at start and end of a line, set by mouse.\nmaking 3rd dot at half way point.\nfloor the points with flc() to get minor or major chords.\n*/\n\n/*\nI thought of a rather simple way to represent longer chords, \nascending and descending melodies.\n\nthis is the simple more constrained approach, only 3 dots.\nsolve a special case BEFORE trying a general case!\n\nThe reason why tesselation of music pitches works is\n...because we fail do distinguish hiigher resolutions of pitches.\nBlack piano keys ARE Moire ARE aliasing:\nhttps://en.wikipedia.org/wiki/Aliasing\nhttps://en.wikipedia.org/wiki/Moir%C3%A9_pattern\n*/\n\n\n/*\na problem suupoptimal case i keep running into is\na sequence of notes on a sheet \n...that are pretty much an ascending or descending line.\nof 4 to 8 notes.\n\ni want a very general case to check \nif(at time [t] note [n] exists in pith [y]) \nfor a linear equation of notes.\nto be checked AFTER applying a floor() tesselation.\nvia pModInterval1() of \nhttp://mercury.sexy/hg_sdf/\n\nthe same can also floor(pModInterval1()) \nto tell which of every 12 piano keys are black.\n*/\n\n#define u5(a) ((a)*.5+.5)\n\n#define vec1 float\n//red circle radius\n#define radius 1.\n//blur of all the lines\n#define hl2 min(iResolution.x,iResolution.y)\n#define viewZoom mix(9.,hl2,u5(-cos(cos(iTime))))\n#define hl (viewZoom/hl2)\n#define fra(u) (u-.5*iResolution.xy)*viewZoom/iResolution.y\n\nfloat ss(vec1 a,vec2 b){return smoothstep(b.x,b.y,a);}\nvec2  ss(vec2 a,vec2 b){return smoothstep(b.x,b.y,a);}\nfloat ss(vec1 a){return ss(a,vec2(1,-1)*hl);}\nvec2  ss(vec2 a){return ss(a,vec2(1,-1)*hl);}\n\n//return distance of [u] to line srgment from [a] to [b]\nfloat Segment(vec2 p,vec2 a,vec2 b){p-=a;b-=a;\n a.x=clamp(dot(p,b)/dot(b,b),0.,1.);return length(p-b*a.x);}\n\n////ss2t(a) changes a seesaw waves output (range [0..1]) to a triangle wave.\n#define ss2t(a) a=abs(a*2.-1.)\n//floor offset,centred \n#define flc(a) floor(a+.5)\n\n//return square tesselaion grod for [u]fragmentPos\nfloat grid(vec2 u){u=fract(u);u=ss2t(u);float r=1.-min(u.x,u.y);\n return smoothstep(hl,-hl,abs(r-1.)-hl);}\n\n//domain-general pmod():\n#define pMOD(d,e) d e(inout d a,d b){d c=floor((a/b)+.5);a=(fract((a/b)+.5)-.5)*b;return c;}\npMOD(vec1,pmod)pMOD(vec2,pmod)pMOD(vec3,pmod)pMOD(vec4,pmod)\n    //repetitive only for less repetitive legacy namespace support.\n\n//because this shader scales and rounds (translates) one invertal into another (quantized) inverval:\n//it takes an excursion into; Maxwellian dimensional relativism:\n#define dd(a) dot(a,a)\n//step 0, the dotproduct of a vector and itself ==dd(a)==is a length*length of the vector.\n//it doesnt matter much what unit you measure distance|length in, what matters is that:\n//step 1, realize that length(a-b)=length(b-a)=sqrt(dd(a-b))=sqrt(dd(b-a))=distance(a,b)=distance(b,a)\n//step 2, the sqrt((a-b)) implies differential calculus:\n//sorting equations like this evades a bias to [systems of length] ie, metric systrems.\n//how often you divide a length by /second\n//, defines what [time-integral of displacement];[length over time] you are calculating in\n//Drop        =length/second/second/second/second/second/second/second/second\n//Lock        =length/second/second/second/second/second/second/second\n//Pop         =length/second/second/second/second/second/second\n//Crackle     =length/second/second/second/second/second\n//jounce      =length/second/second/second/second\n//jerk        =length/second/second/second\n//acceleration=length/second/second\n//velocity    =length/second\n//Displacement=length                        https://en.wikipedia.org/wiki/Displacement_(vector)\n//Absement    =length*second                 https://en.wikipedia.org/wiki/Absement\n//Absity      =length*second*second    \n//Abseleration=length*second*second*second    \n//Abserk      =length*second*second*second*second    \n//Absounce    =length*second*second*second*second*second     \n\n//the fun part of this shader is that it easily extends into 4d\n//, so you can scale (and quantize) a displacement, velocity, an accelleration, and a jerk in one vec4()\n//, useful for [automatic differentiation] shaders?\n\n//length*kilogram is newtonian:\n//newton = kilogram*       length/second/second                  =       kilogram*acceleration\n//joule  = kilogram*length*length/second/second == length*newton =length*kilogram*acceleration\n\n#define coVelEm 2.99792458e8\n#define lightspeed coVelEm\n//commonly known as \"speed of light\" or \"c\"; in in length/second==velocity\n//a better term would be [Electromagnetic velocity]\n//this is a maximum velocity in a vacuum. Usually a straight direct path is obstructed by mass\n//, cuvring spacetime, deforming a straight and shootrest path into a longer line.\n//Without a maximum velocity, causality over time is nonlinear/discontinuous.\n#define coPlanck 6.62607004e-34\n//smallest EM-observable quantity, smallest physically EM-percievable interval \n//;in joule*second==newton*length*second==length*length*kilogram/second/second == length*kilogram*acceleration\n//==length*kilogram*acceleration\n#define coPlanckR (coPlanck/pi/2.)\n//==1.0545718e-34\n//\"reduced PlanckConstant\" is a common scalar, where EM interferrences are about [fourier butterflies]\n//this involves the issue of [squaring an (epi)circle], within limited resolution of DFT|FFT\n#define coGravity 6.674e-11\n//gravitational constant; in newton/kilogram/kilogram/length/length\n//spacetime curvature over inverse_squared_distance to mass\n//gravity is not a force, but an effect of curving spacetime, poportional to squared mass and inverse squared distance.\n//you can model gravity as if it is a force, but that model will not be relativistic.\n#define coPlanckT sqrt(coPlanckR*coGravity/coVelEm/coVelEm/coVelEm/coVelEm/coVelEm)\n//PlanckTime; smallest EM-ovservavle interval over time\n//;5.3911252e-44 == sqrt(1.0545718e-34*6.674e-11/2.99792458e8/2.99792458e8/2.99792458e8/2.99792458e8/2.99792458e8)\n//minimum time that information takes to traverse length(coPlanck) in coMaVelEm\n//whilst smaller units of time can exist, they are so small their effect on our existence is negligible\n#define planckT .0001    \n//smallest measurable distance to an asymptote\n//smallest measurable angle between 1 non-parallel lines\n//smallest feasible epsilon, regardles of contextual scaling, to evade divisions by 0.\n//an ideall model defines planck==coPlanckT or planck=coPlanck, depending on context of your model\n//, but 32bit float precision is not good enough for this.\n//so we chose to scale our model resolution down significantly, with less addressSpace/precision\n\n////\n    // PlanckLengt/PlanckTime =coMaxSpeed\n    \n    \n//[u]FragmentPos, [m]=start [n]=end\nvec3 tripplet(vec2 u, vec2 m, vec2 n\n){//m=vec2(0)//debug overwrite to a null-offset\n ;vec3 r=vec3(0)\n ;r.z=Segment(u,m,n)\n ;//u-=m\n ;float d=length(m-u)\n      ,e=length(n-u)\n      ,f=length(n+m-u*2.)*.5;  //always only do 3 red circles (lazy dumb)\n ;r.x=min(min(d,e),f);\n ;float t=0.;\n ;m=floor(m+.5)\n ;n-=m;u-=m//offset by m\n \n //fraction==number of mod() green squares. within the interval.\n ;float fraction=4. //this splits in thirds, and any other value is fine!\n ;fraction=max(fraction,1.+planckT)\n //the \"fraction of an interval\" is a confucing term\n //, simple if you assert half-open intervals for below function\n //, while a chord of 3 keys is a clodes interval, and the difference is [-=1.]\n ;vec2 a=floor(u+.5),b=(n)/(fraction-1.)//modulate pmod inputs\n ;b=max(vec2(1),abs(b))//contextually worksave agaisntdividing by values <1\n ;u=(fract((a/b)+.5)-.5-planckT)*b//pmod fractional part\n ;u=floor(u+.5)\n ;//if(all(equal(abs(u),vec2(0))))r.y+=.4;//oversimplified dots\n ;//if(any(equal(abs(u),vec2(0))))r.y+=.2;//oversimplified crosses     \n ;if(all(lessThan(abs(u),vec2(planckT))))r.y+=.4;//dots\n ;if(any(lessThan(abs(u),vec2(planckT))))r.y+=.2;//crosses\n\n ;//vec3 r=vec3(d,t,)\n ;r.xz=ss(abs(r.xz-radius*vec2(1,.2))-hl);\n ;return r;}\n\nvec2 cs(float a){return vec2(cos(a),sin(a));}\n\nvoid mainImage(out vec4 O,in vec2 U\n){vec3 c=vec3(0)\n ;vec2 u=fra(U)\n ;vec4 mouse=iMouseZwFix(iMouse,true)\n ;vec2 m=fra(mouse.zw);//start of holding mouse\n ;vec2 n=fra(mouse.xy);//current mouse pos held\n ;if(iMouse.z<=0.\n ){n=vec2(.0)\n  ;vec2 rr=viewZoom*vec2(.3,.1)//.x is average radius .y is distance from averate\n  ;n=cs(iTime*.61).yx*(rr.x-rr.y)\n  ;m=cs(iTime    )   *(rr.x+rr.y)\n  ;c.xy+=.2*ss(abs(abs(length(u)-rr.x)-rr.y)-viewZoom*.5/hl2)//yellow circles show path of red dots\n  ;}\n ;c+=tripplet(u,m,n)//core function, dodo split in 3 parts.\n ;c+=grid(u)*.2;// greyscale grid    \n ;O=vec4(c,1.)\n ;}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n[irrational Stride] explanation:\n\n--- Rational subset:\n\nA [chord] or a [ChromaticScale] are a [stride]:\n\nyou have 2 amount of different (fungible) tokens\n== a deck of [R] redCards and a deck of [B] clueCards\n\nYou want to mix both decks\n,but distribute them as EVENLY as possible. (not random)\n\nFor example 5 black and 7 white cards get you the ChromaticScale\nhttps://en.wikipedia.org/wiki/Chromatic_scale\n\nAny Hairline of 1 pixel width is a stride of [1] and [iResolution.x-1]\nAny [Chord]  of 3 notes is a stride where [R]==3 and [B]=dependsOnChord\n    ... and also, Maj and Minor chords differ in an offset of 0.5\n\nwithout a boundingBox, you get ShepardTones (if you change offset over time)\nhttps://www.youtube.com/watch?v=PwFUwXxfZss\n\nIn 2d, these Strides are [tartan] Weaves.\n\n\n----- Irrational generalization:\n\n[R] and [b] being whole numbers\n,always results in a rational number ratio.\n\nI also wanted to support IttarionalRatios\n,but this only makes sense within a limited epsilon precision.\n\nGiven how this is all about rasterization\n, I label the precision bound planckT\nhttps://en.wikipedia.org/wiki/Planck_units\n\nTags:\nstarguitar,irrationalstride,arpshepardtone,ditherhairlinequantize,chromaticscalecordtartanweave\n*/\n\n\n\n/*\ncopeied from \nhttps://www.shadertoy.com/view/4ttBD4\n\n[4ttBD4] is a more complex(generalized experimental variant \nof [irrationalStride]\nhttps://www.shadertoy.com/results?query=irrationalStride&sort=newest&filter=\n\nfor an explanation of [4ttBD4] read text below:\n(copied from: https://www.shadertoy.com/view/wdGBDW )\n\nI updated the [stride] shaders to [irrationalStride]\nand added a [stride] epxplanation for them in the commonTab of \nhttps://www.shadertoy.com/view/Xl3BD4\n\nA hairline is a rationalStride, much simpler.\nbut my code also dares to quantize for irrational ratios\n, within a limited PlanckLength.\n\nYou may think of a stride input values\nas the 2 sizes of strided lists. \nNumber of Red and blue cards;\nStrideIntuitive(uv,red,blue,offset)\n\nBut my function has 2 different inputs, \ntripplet( uv,start,end,(fraction) )\n(red==fraction == 3 == constant within the function\n, but could be parametric where\n, in case of a (non rational) remainder\n, RED is always shown, and blue is ommitted/overwritten.\n\nI then generalized [4ttBD4] more into:\npmodfM(uv,start,end,fraction,planckPrecision)\nof \nhttps://www.shadertoy.com/view/4ttBD4\npmodfM(...)\nshould work with float, vec2, vec3 , vec4 inputs\n\nyou can use\npmodfM(uv,offset+Red,offset+red+blue,red,planckPrecision)\n\nand for a Jairline, that is\noffset=iTime%iResolution\npmodfM(uv.x,offset+1,offset+iResolution.x,1,0.001)\n\nand the precision is really not needed here\n, because all other inputs are whole numbers. (?)\n\ntags:\nstarguitar, irrationalstride, arpshepardtone, ditherhairlinequantize, chromaticscalecordtartanweave\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}