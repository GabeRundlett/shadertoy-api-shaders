{
    "Shader": {
        "info": {
            "date": "1719317220",
            "description": "You can choose the map mode with the defines.",
            "flags": 0,
            "hasliked": 0,
            "id": "X33XRX",
            "likes": 3,
            "name": "Darkmatter Lines",
            "published": 3,
            "tags": [
                "fbm",
                "plasma",
                "lines",
                "fisheye"
            ],
            "usePreview": 0,
            "username": "WilstonOreo",
            "viewed": 115
        },
        "renderpass": [
            {
                "code": "\n////////////////////////////////////////////////////////////////////////////////////////\n// INFO:\n// - use the mouse to navigate (x is rotation, y is zoom)\n// - play with the defines below to change the visuals\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////// shaders/camera.h //////////\n//#define MAP_DYNAMIC\n//#define MAP_ROTATE\n//#define MAP_SPHERICAL 0\n#define MAP_FISHEYE 1\n//#define MAP_CUBE 2\n\nuniform int map_mode; // 0 MAP_SPHERICAL, 1 = MAP_FISHEYE, 2 = MAP_CUBE\nuniform float cam_roll; // default = 0.0, min = -180.0, max = 180.0\nuniform float cam_pitch; // default = 0.0, min = -180.0, max = 180.0\nuniform float cam_yaw; // default = 0.0, min = -180.0, max = 180.0\n\n//#define TOUCHDESIGNER\n\n#ifdef TOUCHDESIGNER\nuniform float thickness; // default 0.05, min = 0.01, max = 0.5\nuniform float freq; // default = 3.0, min = 1.0, max = 5.0\n#else\nconst float thickness = 0.05;\nconst float freq = 3.0;\n#endif\n\n////////// shaders/direction.h //////////\n////////// shaders/util.h //////////\n\nconst float PI = 3.14159265358979323846264;\n\nstruct Ray\n{\n  vec3 org;\n  vec3 dir;\n};\n\n/// Convert degrees to radians\nfloat deg2rad(in float deg)\n{\n  return deg * PI / 180.0;\n}\n\n\n/// Convert degrees to radians\nfloat rad2deg(in float rad)\n{\n  return rad / PI * 180.0;\n}\n\nfloat sqr(in float a)\n{\n  return a*a;\n}\n\n/// Calculates the rotation matrix of a rotation around X axis with an angle in radians\nmat3 rotateAroundX( in float angle )\n{\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(1.0,0.0,0.0,\n              0.0,  c, -s,\n              0.0,  s,  c);\n}\n\n/// Calculates the rotation matrix of a rotation around Y axis with an angle in radians\nmat3 rotateAroundY( in float angle )\n{\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(  c,0.0,  s,\n              0.0,1.0,0.0,\n               -s,0.0,  c);\n}\n\n/// Calculates the rotation matrix of a rotation around Z axis with an angle in radians\nmat3 rotateAroundZ( in float angle )\n{\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(  c, -s,0.0,\n                s,  c,0.0,\n              0.0,0.0,1.0);\n}\n\n/// Calculate rotation by given yaw and pitch angles (in degrees!)\nmat3 rotationMatrix(in float yaw, in float pitch, in float roll)\n{\n  return rotateAroundZ(deg2rad(yaw)) *\n         rotateAroundY(deg2rad(-pitch)) *\n         rotateAroundX(deg2rad(roll));\n}\n\n#ifdef MAP_FISHEYE\n// Get fisheye camera ray from screen coordinates\nfloat fisheye_direction(in vec2 screenCoord, in vec2 res, out vec3 rd)\n{\n\tvec2 uv = screenCoord.xy / res;\n\tuv = uv - 0.5;\n  float phi = atan(uv.x,uv.y);\n  float l = length(uv);\n\n  if (l > 0.5)\n  {\n    return -1.0;\n  }\n  float theta  = l * PI;\n  rd = normalize(vec3(sin(theta)*cos(phi),sin(theta)*sin(phi),cos(theta)));\n  return 1.0;\n}\n#endif\n\n#ifdef MAP_SPHERICAL\nfloat spherical_direction(in vec2 screenCoord, in vec2 res, out vec3 rd)\n{\n\tvec2 uv = screenCoord.xy / res;\n  float theta = (uv.t) * PI,\n        phi = (uv.s - 0.5)* 2.0 * PI;\n  rd = vec3(sin(theta) * sin(phi), sin(theta) * cos(phi), cos(theta));\n  return 1.0;\n}\n#endif\n#ifdef MAP_CUBE\nfloat cubemap_direction(in vec2 screenCoord, in vec2 res, out vec3 rd)\n{\n\tvec2 uv = screenCoord.xy / res;\n  uv.x *= 6.0;\n\n  if (uv.x < 1.0) // EAST\n  {\n    uv -= 0.5;\n    rd = vec3(2.0*uv.x,1.0,-2.0*uv.y);\n  } else\n  if (uv.x < 2.0) // WEST\n  {\n    uv -= 0.5;\n    uv.x -= 1.0;\n    rd = vec3(-2.0*uv.x,-1.0,-2.0*uv.y);\n  } else\n  if (uv.x < 3.0) // NORTH\n  {\n    uv -= 0.5;\n    uv.x -= 2.0;\n    rd = vec3(1.0,-2.0*uv.xy);\n  } else\n  if (uv.x < 4.0) // SOUTH\n  {\n    uv -= 0.5;\n    uv.x -= 3.0;\n    rd = vec3(-1.0,2.0*uv.x,-uv.y*2.0);\n  } else\n  if (uv.x < 5.0) // Top\n  {\n    uv -= 0.5;\n    uv.x -= 4.0;\n    rd = vec3(2.0*uv,1.0);\n  } else\n  if (uv.x < 6.0) // Bottom\n  {\n    uv -= 0.5;\n    uv.x -= 5.0;\n    rd = vec3(-uv.x*2.0,uv.y*2.0,-1.0);\n  }\n\n  rd = normalize(rd);\n\n  return 1.0;\n}\n#endif\n#ifdef MAP_DYNAMIC\nfloat direction(in vec2 screenCoord, in vec2 res, out vec3 rd)\n{\n#ifdef MAP_SPHERICAL\n  if (map_mode == MAP_SPHERICAL)\n  {\n    return spherical_direction(screenCoord,res,rd);\n  }\n#endif\n#ifdef MAP_FISHEYE\n  if (map_mode == MAP_FISHEYE)\n  {\n    return fisheye_direction(screenCoord,res,rd);\n  }\n#endif\n#ifdef MAP_CUBE\n  if (map_mode == MAP_CUBE)\n  {\n    return cubemap_direction(screenCoord,res,rd);\n  }\n#endif\n  return -1.0;\n}\n\n#endif\n\n#ifndef MAP_DYNAMIC\n#ifdef MAP_SPHERICAL\nfloat direction(in vec2 screenCoord, in vec2 res, out vec3 rd)\n{\n  return spherical_direction(screenCoord,res,rd);\n}\n#endif\n#ifdef MAP_FISHEYE\nfloat direction(in vec2 screenCoord, in vec2 res, out vec3 rd)\n{\n  return fisheye_direction(screenCoord,res,rd);\n}\n#endif\n#ifdef MAP_CUBE\nfloat direction(in vec2 screenCoord, in vec2 res, out vec3 rd)\n{\n  return cubemap_direction(screenCoord,res,rd);\n}\n#endif\n#endif\n\n\n\n\n// Get fisheye camera ray from screen coordinates with rotation\nfloat direction(in vec2 screenCoord, in vec2 res, float rotX, float rotY, float rotZ, out vec3 rd)\n{\n  if (direction(screenCoord,res,rd) < 0.0)\n  {\n    return -1.0;\n  }\n  rd *= rotateAroundZ(rotZ)*rotateAroundY(rotY)*rotateAroundX(rotX);\n  return 1.0;\n}\n\n\n\nfloat setup_camera_ray(in vec2 uv, out vec3 ray)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n  return direction(uv,vec2(1.0),deg2rad(90.0+cam_yaw),deg2rad(cam_roll),deg2rad(cam_pitch),ray);\n}\n\n////////// shaders/time.h //////////\n\n// the more slices the slower\n#define SLICES \t\t\t15.0\n// start amplitude for the noise\n#define START_AMPLITUDE\t0.05\n// start frequency for the noise\n#define START_FREQUENCY\t43.0\n// start density value\n#define START_DENSITY\t0.0\n// animation speed\n#define SLICE_DIST 0.10\n\n#define MAX_DIST 6.0\n\n////////////////////////////////////////////////////////////////////////////////////////\n// iq's 3d noise functions from the elevated shader (incl. modifications where needed)\n////////////////////////////////////////////////////////////////////////////////////////\n\n// rotation matrix for fbm octaves\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n// 3d noise function\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f = noise( p );\n\treturn f;\n}\n\n\n// shader main function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // camera and user input\n\tvec3 o,d;\n\tif (setup_camera_ray(uv, d) < 0.) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    o = vec3(0.0);\n\n\t// render\n\tfloat val = 0.0;\n\tfloat tmin = 0.0, tmax = MAX_DIST*0.1;\n    float inc = 1.0 / SLICES *SLICE_DIST;\n    float t = tmin;\n\t\t// step thoug the sphere with max SLICES steps\n\t\tfor (float i = 0.0; i < 0.125*SLICES; i+=0.25)\n\t\t{\n\t\t\t// stay within the sphere bounds\n\t\t\tt = tmin + i /4.0 *SLICE_DIST;\n\t\t\tif (t > tmax)\n\t\t\t\tbreak;\n\t\t\tvec3 curpos = o + d*t;\n\n\t\t\t// get sphere falloff in s\n\t\t\tfloat s = 0.6-t;\n\t\t\ts*=s;\n\n\t\t\t// get turbulence in d\n\t\t\tfloat a = thickness / 3.0;\n\t\t\tfloat b = freq * 3.0;\n\t\t\tfloat d = START_DENSITY * 4.0;\n\t\t\td += 0.5/abs((noise(5.0*curpos*b+2.0*iTime/b)*2.0-1.0)/a*0.2);\n\n\t\t\t// get gradient color depending on s\n\t\t\tval += max(s*d*s,0.0);\n\t\t}\n\n    val = (val - 0.3)/0.5;\n\n\tfragColor =  vec4(vec3(val),1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}