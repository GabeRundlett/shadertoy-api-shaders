{
    "Shader": {
        "info": {
            "date": "1628627533",
            "description": "Shader are always cuter with ducks.\nUse the mouse to turn around.\nDuck model from Jimmi:\nhttps://www.shadertoy.com/view/4lsSDl",
            "flags": 33,
            "hasliked": 0,
            "id": "7lSSWK",
            "likes": 34,
            "name": "Liquid Planet with Ducks",
            "published": 3,
            "tags": [
                "simulation",
                "water",
                "planet",
                "cubemap",
                "drop",
                "feedback",
                "physics",
                "ducks"
            ],
            "usePreview": 0,
            "username": "xjorma",
            "viewed": 890
        },
        "renderpass": [
            {
                "code": "// Created by David Gallardo - xjorma/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#define AA\n\nconst vec3 lightPosition = vec3(0.,10.,2.);\n\nconst vec3 backgroundColor = vec3(0.4);\nconst vec3 waterColor = vec3(0,0,0.4);\nconst vec3 duckColor = vec3(1, 1, 0);\n\nconst float cref = 0.8;\n\nfloat saturate(float c)\n{\n    return clamp(c,0.,1.);\n}\n\nfloat mapWater(in vec3 p)\n{\n    float d = sdSphere(p, 1.0 + texture(iChannel0, p).x * 0.05);\n    return d;\n}\n\n\n#define NORMALFUNC(NAME, MAPFUNC, EPS)\t\t\t\t\t\t\t\t\\\nvec3 NAME(in vec3 p)\t\t\t\t\t\t\t\t    \t\t\t\\\n{                                                                   \\\n    const vec2 k = vec2(EPS,-EPS);\t\t\t\t                    \\\n    return normalize( k.xyy * MAPFUNC(p + k.xyy) + \t\t\t    \t\\\n                      k.yyx * MAPFUNC(p + k.yyx) + \t\t\t\t    \\\n                      k.yxy * MAPFUNC(p + k.yxy) + \t\t\t\t    \\\n                      k.xxx * MAPFUNC(p + k.xxx) );\t\t\t\t    \\\n}\n\n#define RAYMARCHFUNC(NAME, MAPFUNC, ITER, EPS)\t\t\t\t\t\t\\\nfloat NAME(in vec3 ro, in vec3 rd, in float dist)                   \\\n{                                                                   \\\n    float t = 0.0;                                                  \\\n    for( int i = 0; i < ITER; i++ )                                 \\\n    {                                                               \\\n        vec3\tp = ro + t*rd;                                      \\\n        float\th = MAPFUNC(p);                                     \\\n        if( abs(h) < 0.0001 || t > dist )                          \\\n            break;                                                  \\\n        t += h;                                                     \\\n    }                                                               \\\n    return t;                                                       \\\n}\n\nNORMALFUNC(calcNormalWater,mapWater, 0.02)\nRAYMARCHFUNC(raymarchWater,mapWater, 100, 0.00001)\n\nfloat mapSolidImp(vec3 p)\n{\n    return mapSolid(p, iChannel2);\n}\n\nNORMALFUNC(calcNormalSolid,mapSolidImp, 0.0001)\nRAYMARCHFUNC(raymarchSolid,mapSolidImp, 100, 0.001)\t\n\nNORMALFUNC(calcNormalDuck,duckMap, 0.0001)\n\nfloat rayTraceDucks(in vec3 ro, in vec3 rd, out vec3 normal, out vec3 color, in float maxDist)\n{\n    float d = infinity;\n    bool collide = false;\n    for(int i = 0; i < DuckNum; i++)\n    {\n        vec3 pos = Load(i, CompPosition, iChannel2).xyz;\n        vec2 inter = sphIntersect( ro, rd, pos, 0.1);\n        if(inter.x > 0.0 && inter.x < maxDist)\n        {\n            vec3 dir = Load(i, CompDirection, iChannel2).xyz;\n            \n            vec3 y = pos;\n            vec3 z = dir;\n            vec3 x = cross(z, y);\n            \n            mat4 mr = mat4(\n\t\t\tx.x,\t\ty.x,\t\tz.x,         0,\n\t\t\tx.y,\t\ty.y,\t\tz.y,         0,\n\t\t\tx.z,\t\ty.z,\t\tz.z,         0,\n\t\t\t0,\t        0,\t        0,           1.0 );\n\n            mat4 mt = mat4(\n\t\t\t1.0,\t\t0.0,\t\t0.0,         0.0,\n\t\t\t0.0,\t\t1.0,\t\t0.0,         0.0,\n\t\t\t0.0,\t\t0.0,\t\t1.0,         0.0,\n\t\t\t-pos.x,\t-pos.y,\t-pos.z,     1.0 );\n            \n            mat4 tr= mr * mt;\n            \n            float t = inter.x;\n            vec3 tp;\n            for( int j = 0; j < 16; j++ )\n            {\n                vec3\tp = ro + t*rd;\n                tp = vec3(tr * vec4(p, 1.0));\n                float\th = duckMap(tp);\n                if( abs(h) < 0.0001 || t > inter.y )\n                    break;\n                t += h;\n            }\n            if(t < inter.y)\n            {\n                if(t < d)\n                {\n                    d = t;\n                    collide = true;\n                    normal = (inverse(tr) * vec4(calcNormalDuck(tp), 0)).xyz;\n                    color = duckMapColor(tp).yzw;\n                }\n            }\n        }\n\n    }\n    return d; \n}\n\n\nvec3 Render(vec3 ro,vec3 rd,vec3 cd,float dist)\n{\n    float tWater = raymarchWater(ro, rd, dist);\n    \n    vec3 dn, dc;\n    float tSolid = rayTraceDucks(ro, rd, dn, dc, tWater);\n    \n    vec3 col = backgroundColor;\n\n    if( min(tWater, tSolid) < dist )\n    {\n        if(tSolid < tWater)\n        {\n            // Solid first\n            vec3 p = ro + tSolid * rd;\n            vec3 n = dn;\n            vec3 v = normalize(ro-p);\n            vec3 l = normalize(lightPosition-p);\n            vec3 h = normalize(l+v);\n            col = dc * saturate(max(0.0, dot(n,l) * 0.7) + 0.3);\n        }\n        else\n        {\n            // Water first\n            vec3 p = ro + tWater * rd;\n            vec3 n = calcNormalWater(p);\n            vec3 rdn, rdc;\n            vec3 rdir = reflect(rd, n);\n            float tref = rayTraceDucks(p - 0.15 * rdir, rdir, rdn, rdc, 0.25);\n            if(tref < 0.5)\n            {\n                vec3 p = p - 0.15 * rdir + tref * rdir;\n                vec3 v = normalize(ro-p);\n                vec3 l = normalize(lightPosition-p);\n                vec3 h = normalize(l+v);\n                col = rdc * saturate(max(0.0, dot(rdn,l) * 0.7) + 0.3);\n                return mix(waterColor, col, 0.65);\n            }\n            col = waterColor;\n            float spec = length(texture(iChannel1, reflect(ro, n) * vec3(1,-1,1)).rgb);\n            col += 0.15 * spec * smoothstep(0.0, 0.1, dist);\n        }\n    }\n    \n    return col;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    fragColor = vec4(Render(ro/3. + vec3(0.0,.0,4.0),rd ,rd,14.) ,1);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n        \n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        \n        float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5);\n        float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5)-1.;\n        vec3 ro = 2.*vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        //vec3 ro = vec3(0.0,.2,4.0);\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col = Render(ro ,rd ,ca[2], 4.0);\n\n\t    tot += col;\n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n\n    tot = vignette(tot, fragCoord / iResolution.xy, 0.6);\n\n\tfragColor = vec4( sqrt(tot), 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec3 minComponent(in vec3 v)\n{\n    v = abs(v);\n    if(v.x < v.y)\n    {\n        if(v.x < v.z)\n        {\n            return vec3(1, 0, 0);\n        }\n    }\n    else\n    {\n        if(v.y < v.z)\n        {\n            return vec3(0, 1, 0);\n        }\n    }\n    return vec3(0, 0, 1);\n}\n\n\nmat3 rotationMatrix(in vec3 axis, in float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    if(iFrame == 0)\n    {\n        fragColor = vec4(0, 0, 0, 1);\n        return;\n    }\n    \n    \n    vec3 up = minComponent(rayDir);\n    vec3 right = normalize(cross(rayDir, up)) ;\n    right /= (iResolution.x * 0.5);\n   \n\n    mat3 rot = rotationMatrix(rayDir, radians( 360.0 / float(nbSample)));\n\n    vec2 center = texture(iChannel0, rayDir).xy;\n    \n    float sum = 0.0;   \n    for(int i = 0; i < nbSample; i++)\n    {\n        sum += texture(iChannel0, rayDir + right).x;\n        right = rot * right;\n    }\n    \n    float new = (sum * (2.0 / float(nbSample)) - center.y) * dampening; \n    \n    // Random point\n    if((iFrame % 6) == 0)\n    {\n        float d = dot(rayDir, randomPointOnSphere(float(iFrame)));\n        new -= d * smoothstep(0.999, 1.0, d) * 0.1; \n    }\n\n    // solid\n    float ds = mapSolid(rayDir, iChannel2);\n    new -= smoothstep(0.0, -0.01, ds) * 0.007;   \n\n    fragColor = vec4(vec2(new, center.x), 0 , 1);\n    \n    //fragColor = vec4(0);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            },
            {
                "code": "// Duck Simulation\nconst int DuckNum\t\t= 48;\nconst int MaxCompPerRow\t= 256;\nconst int CompPosition\t= 0;\nconst int CompDirection\t= 1;\nconst int CompNum\t\t= 3;\n\nconst float duckSpeed = 0.005;\nconst float duckScale = 0.1;\n\n// Physics simulation parameters\nconst int nbSample = 6;\nconst float dampening = 0.98;\n\n\nconst float infinity = 100000.0;\n\n// Hash by Dave Hoskins from https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Box SDF by IQ https://iquilezles.org/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// Fog by IQ https://iquilezles.org/articles/fog\nvec3 applyFog( in vec3  rgb, vec3 fogColor, in float distance)\n{\n    float fogAmount = exp( -distance );\n    return mix( fogColor, rgb, fogAmount );\n}\n\n// Sphere intersect form IQ https://iquilezles.org/articles/intersectors\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec4 Load(in int id, in int comp, in sampler2D sampler)\n{\n    int off = id * CompNum + comp;\n\treturn texelFetch(sampler, ivec2(off % MaxCompPerRow, off / MaxCompPerRow), 0);\n}\n\nfloat duckBody(vec3 p) {\n    float k = 6.0;\n    float a = 0.;\n    \n    //p.x = abs(p.x);\n    \n    a += exp(-k * sdSphere(p + vec3(0.11, 0, 0.1), 0.06));\n    a += exp(-k * sdSphere(p + vec3(-0.11, 0, 0.1), 0.06));\n    a += exp(-k * sdSphere(p + vec3(0.2, 0, 0.3), 0.1));\n    a += exp(-k * sdSphere(p + vec3(-0.2, 0, 0.3), 0.1));\n    a += exp(-k * sdSphere(p + vec3(0.2, 0, 0.55), 0.07));\n    a += exp(-k * sdSphere(p + vec3(-0.2, 0, 0.55), 0.07));\n    a += exp(-k * sdSphere(p + vec3(-0.00, 0, 0.72), 0.1));\n    \n    a += exp(-k * sdSphere(p + vec3(0, -0.39, 0.8), 0.01));\n\n    a += exp(-k * sdSphere(p + vec3(0, -0.7, 0.1), 0.15));\n    a += exp(-k * sdSphere(p + vec3(0, -0.65, -0.05), 0.07));\n\n    return -log(a) / k;\n}\n\nfloat beak(vec3 p, float s)\n{\n    float k = max(length(p)-s, -(length(p+vec3(-0.15,-0.2,-0.1))-0.25));\n    k = max(k, -(length(p+vec3(0.12,-0.2,-0.1))-0.25));\n    return k < 0.0 ? 0.0 : k;\n}\n\nfloat duckBeak(vec3 p)\n{\n    float k = 12.0;\n    float a = 0.;\n    \n    a += exp(-k * beak(p + vec3(0, -0.55, -0.1), 0.15));\n\n    return -log(a) / k;\n}\n\nfloat duckMap(in vec3 p)\n{\n    p /= duckScale;\n    return min(duckBody(p), duckBeak(p)) * duckScale;\n}\n\n\nvec4 nearest(vec4 d1, vec4 d2)\n{\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\nvec4 duckMapColor(vec3 p)\n{\n    p /= duckScale;\n    p.x = abs(p.x);\n    vec4 res = vec4(duckBody(p), vec3(1, 1, 0));\n    res = nearest(res, vec4(duckBeak(p), vec3(1, 0, 0)));\n    res = nearest(res, vec4(sdSphere(p-vec3(0.09, 0.62, 0.14), 0.06), vec3(0.0, 0, 0.3)));\n    res.x *= duckScale;\n    return res;\n}\n\n\nfloat mapSolid(vec3 p, sampler2D sampler)\n{\n    float d = infinity;\n    for(int i = 0; i < DuckNum; i++)\n    {\n        vec3 pos = Load(i, CompPosition, sampler).xyz;\n        float dbs = sdSphere( p - pos, 0.1);\n        if(dbs > 0.1)\n        {\n            d = min(d , dbs);\n        }\n        else\n        {\n        \n            vec3 dir = Load(i, CompDirection, sampler).xyz;\n                        \n            vec3 y = pos;\n            vec3 z = dir;\n            vec3 x = cross(z, y);\n            \n            mat4 r = mat4(\n\t\t\tx.x,\t\ty.x,\t\tz.x,         0,\n\t\t\tx.y,\t\ty.y,\t\tz.y,         0,\n\t\t\tx.z,\t\ty.z,\t\tz.z,         0,\n\t\t\t0,\t        0,\t        0,           1.0 );\n\n            mat4 t = mat4(\n\t\t\t1.0,\t\t0.0,\t\t0.0,         0.0,\n\t\t\t0.0,\t\t1.0,\t\t0.0,         0.0,\n\t\t\t0.0,\t\t0.0,\t\t1.0,         0.0,\n\t\t\t-pos.x,\t-pos.y,\t-pos.z,     1.0 );\n            \n            mat4 tr= r * t;\n            \n            d = min(d , duckMap( (tr * vec4(p, 1)).xyz));\n        }\n    }\n    return d;\n}\n\nvec3 randomPointOnSphere(float key)\n{\n    vec2 rand = hash21(key);\n    float theta = radians(360.0) * rand.x;\n    float phi = acos(2.0 * rand.y - 1.0);\n    return vec3 (cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi));    \n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec4 Load(in int id, in int comp)\n{\n    int off = id * CompNum + comp;\n\treturn texelFetch(iChannel0, ivec2(off % MaxCompPerRow, off / MaxCompPerRow), 0);\n}\n\nvoid Store(in vec4 v, in int comp, in int curComp, inout vec4 o)\n{\n    if(comp == curComp)\n    {\n        o = v;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    int\tpixId = int(fragCoord.x + float(MaxCompPerRow) * fragCoord.y);\n    int curComp = pixId % CompNum;\n    pixId /= CompNum;\n    if( fragCoord.x >= float(MaxCompPerRow) || pixId >= DuckNum * CompNum)\n    {\n        discard;\n    }\n    vec3\tpos;\n    vec3\tdir;\n    if(iFrame == 0)\n    {\n        pos = randomPointOnSphere(float(pixId + 1) * 7.0);\n        dir = randomPointOnSphere(float(pixId + 4) * 3.0);\n    }\n     else\n    {\n        pos = Load(pixId, CompPosition).xyz;\n        dir = Load(pixId, CompDirection).xyz;\n    }\n    \n    //vec3 right = normalize(cross(dir, pos));\n    \n\n    \n    vec3 npos = pos + dir * duckSpeed;\n    \n    for(int i = 0; i < DuckNum; i++)\n    {\n        if(i != pixId)\n        {\n            vec3 opos = Load(i, CompPosition).xyz;\n            float d = distance(pos, opos);\n            npos -= normalize(opos - npos) * smoothstep(0.4, 0.0, d) * 0.0005;\n        }\n    }\n    \n    npos = normalize(npos);\n    \n    vec3 ndir = normalize(npos - pos);\n    \n    Store(vec4(npos, 0), CompPosition, curComp, fragColor);\n    Store(vec4(ndir, 0), CompDirection, curComp, fragColor);   \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}