{
    "Shader": {
        "info": {
            "date": "1593450546",
            "description": "THEY are watching us.",
            "flags": 40,
            "hasliked": 0,
            "id": "WllyWH",
            "likes": 33,
            "name": "Brief history of the pyramids",
            "published": 3,
            "tags": [
                "raymarching",
                "glow",
                "neon",
                "pyramid",
                "ufo"
            ],
            "usePreview": 0,
            "username": "friol",
            "viewed": 621
        },
        "renderpass": [
            {
                "code": "\n//\n// THEY are seeing us\n//\n\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel1, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n\nfloat message(vec2 U,int w) \n{\n    vec4 T = vec4(0);\n    if (w==0) { C(116);C(111);C(32);C(98);C(101);C(32);C(99);C(111);C(110);C(116);C(105);C(110);C(117);C(101);C(100);C(46);C(46);C(46); }\n    return length(T.yz)==0. ? -1. : T.x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n\tvec2 screenPos = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    if (iTime>=88.0)\n    {\n        float c=message((fragCoord/iResolution.y-vec2(0.78,.01))*vec2(10.,10.5),0);\n        if (c>0.2){fragColor=vec4(c*1.0);return;}\n    }\n    \n    // vignette\n\tvec2 uv2 = fragCoord.xy / iResolution.xy;\n    uv2 *=  1.0 - uv2.yx;\n    float vig = uv2.x*uv2.y * 38.0;\n    vig = pow(vig, 0.05);\n    \n    vec2 uv = fragCoord / iResolution.xy;\n\tfragColor = vec4(texture(iChannel0, uv).rgb*vig, 0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n//\n// THEY are scripting us\n//\n\n// point in time for the various scenes\n\n// scene 1\n#define sceneFadeInBegin 0.0\n#define sceneFadeInEnd 5.0\n#define sceneSpaceWarpEnd 7.5\n#define ufoWarpInEnd 9.5\n#define sceneMovementEnd 19.0\n#define fadeOutEarthBegin 22.0\n#define ufoBehindEarth 25.0\n\n// scene 2\n#define fogSceneFadeIn 28.0\n#define fogFadeoutBegin 31.5\n\n// scene 3\n\n#define ufoDownBegin 35.0\n#define ufoDownEnd 38.0\n#define rayDownEnd 42.0\n#define rayQuadEnd 46.0\n#define pyrGrowingEnd 53.0\n#define blackPyrEnd 58.0\n\n#define fourRaysReturn 62.0\n#define vertRayReturn 64.0\n\n#define zoomInEnd 66.0\n\n#define warpOutBegin 75.5\n#define warpOutEnd 76.5\n#define ufoRunsAway 81.0\n\n#define finalFadeOut 83.0\n#define thatsAllFolks 84.50001\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n\n// Deep Space \n// Star Nest by Kali\n// https://www.shadertoy.com/view/4dfGDM\n\n#define iterations 17\n#define formuparam 0.33\n#define volsteps 10\n#define stepsize 0.1\n#define tile   0.550\n#define brightness 0.0011\n#define darkmatter 1.100\n#define distfading .530\n#define saturation 0.4545\n\nvec4 space(vec3 rd,float time,int mode)\n{\n\tvec3 dir=rd;\n\tvec3 from=vec3(1.,.5,0.5);\n\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) \n    {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\t\n        float multFactor;\n        if (time<sceneFadeInEnd) multFactor=0.04;\n        else multFactor=max(mix(1.4,0.01,time/sceneSpaceWarpEnd),0.01);\n        for (int i=0; i<iterations; i++) \n        { \n\t\t\tif (mode==0) p=abs(p)/dot(p,p)-0.45+sin(time/sceneFadeInEnd)*multFactor;\n\t\t\tif (mode==1) p=abs(p)/dot(p,p)-0.45+0.30;\n            \n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation)*vec3(0.5,0.5,0.86);\n\treturn vec4(v*.01,1.);\t\n}\n\n// from https://www.shadertoy.com/view/Msl3WH\nvec4 spaceWarp(float tm,in vec2 uv)\n{\n\tfloat time = tm*60.0;\n\n    float s = 0.0, v = 0.0;\n\tfloat t = time*0.005;\n\tuv.x += sin(t) * 0.5;\n\tfloat si = 0.0;\n\tfloat co = cos(t);\n\tuv *= mat2(co, si, -si, co);\n\tvec3 col = vec3(0.0);\n\tvec3 init = vec3(0.25, 0.25 + sin(time * 0.001) * 0.4, floor(time) * 0.0008);\n\tfor (int r = 0; r < 100; r++) \n\t{\n\t\tvec3 p = init + s * vec3(uv, 0.143);\n\t\tp.z = mod(p.z, 2.0);\n\t\tfor (int i=0; i < 10; i++)\tp = abs(p * 2.04) / dot(p, p) - 0.75;\n\t\tv += length(p * p) * smoothstep(0.0, 0.5, 0.9 - s) * .002;\n\t\tcol +=  vec3(v * 0.02, 0.1 - s * 0.12, .2 + v * 0.13) * v * 0.013;\n\t\ts += .01;\n\t}\n\treturn vec4(col, 1.0);\n}\n\n//\n// desert dream\n//\n\n#define PI 3.14159265359\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat terrainH( in vec2 p)\n{\n    //small\n\tfloat valS = noise(p * 0.5) + 0.5;//0~1\n    valS = 1.0 - abs(valS - 0.5) * 2.0;\n    valS = pow(valS,2.0);\n\n    //middle\n    float valM = noise(p * 0.26) + 0.5;//0~1\n    valM = 1.0 - abs(valM - 0.5) * 8.0;\n    //valM = pow(valM,1.0);\n    \n    //big\n    float valB = smoothstep(0.0,1.0,noise(p * 0.2) + 0.5);//0~1\n\n    float val = valS * 0.01 + valM * 0.19 + valB * 0.7;\n\n    return val * 1.3 - 0.3;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n//\n// THEY are hearing us\n//\n\n#define soundDelayRepetitions 6\n#define soundDelayTime 0.25\n#define soundDelayFeedback 0.85\n#define soundDelayWet 0.55\n\nfloat freqFromMidiNote(float n) {return pow(2.,(n-69.)/12.)*440.0;}\n\n// percussions\n\nfloat modfix(float phase) {\n    return mod(phase, 6.28);\n}\n\nfloat sinf(float t, float freq) {\n\treturn sin(modfix(3.141592*2.0 * t * freq));\n}\n\nfloat kick(float t) \n{\n    return clamp(0.55 * sinf(t, 520. * exp(-t * 15.0)) * exp(-t * 5.), -1.0, 1.0) * smoothstep(0.001, 0.003, t);\n}\n\n// hihat\n\nvec2 hihat(float time,float panning)\n{\n    float tb = mod(time,(60.0/120.0)*1.0);\n    float hihat=(fract(cos(time * 32234.523) * 134.) * exp(mod(tb, 1. / 2.0) / 2.0 * -120.)*(fract(tb) + .2));\n\n    float tbr = mod(time+0.135,(60.0/120.0)*1.0);\n    float hihatr=(fract(cos((time+0.135) * 32234.523) * 134.) * exp(mod(tbr, 1. / 2.0) / 2.0 * -120.)*(fract(tbr) + .2));\n    hihat+=hihatr*0.5;\n    \n    float tb2 = mod(time+0.25,(60.0/120.0)*1.0);\n    float hihat2=(fract(cos((time+0.25) * 32234.523) * 134.) * exp(mod(tb2, 1. / 2.0) / 2.0 * -120.)*(fract(tb2) + .2));\n    hihat2*=0.5;\n    return vec2(\n        (hihat*panning)+(hihat2*(1.0-panning)),\n        hihat*(1.0-panning)+hihat2*panning)*.55;\n}\n\n\n// snare\n\nfloat baseFreq=1.0;\n \n#define TT(d) mod(mod(time,1.0)-d,1.0)\n\nfloat rand(float t){\n    return fract(sin(t*1793.326) * 43758.5453);\n}\n\nfloat ws(float x,float a)\n{\n\treturn x*(abs(x) + a)/(x*x + (a-1.0)*abs(x) + 1.0);\n}\n\nfloat snareDrum(float _time)\n{\n    float freq=680.0*baseFreq;\n\tfloat c=0.0;\n    const int  num=7;\n    for (int i=0;i<num;i++)\n    {\n        float time=_time-float(i)*(0.09+float(i)*0.01);\n\n        if (time<0.0)\n            continue;\n        \n        float t=1.0-(time*1.0);\n        t=max(t,0.0);\n        t=pow(t,2.0);\n\n        float f=sin(t*freq)/PI;\n\n    \tf=ws(f,2.9);\n        t=time*baseFreq;\n        f*=pow(max(0.0,1.0-(t*6.0)),4.0);\n        f+=rand(time)*0.4*pow(1.0-t,20.0);\n    \tf=ws(f,1.9);\n\t    f= clamp(f,-1.0,1.0);\n        f*=0.7;\n        c+=f/float(1+(i*i*4));\n        \n    }\n    \n    return c*0.35;        \n}\n\n// drone/ambient synth by nabr\n\n#define tau 6.2831\nfloat synth(float rt)\n{\n    float sn = .001,sn1 = .001;\n    float m0 = float[](10., 50., 80., 40., 60.)[uint(2. * rt) % 5u];\n    float mrt6 = mod(6. * rt, 1.);\n    float mrt2 = mod(2. * rt, 1.);\n    for (uint n = 0u; n < 5u; n++)\n    {\n        sn += (2. * sin(m0 * tau * rt));\n        sn1 = (.5 + sn) + (1. - sqrt((sn-.527) * (sn-.527)));\n        sn*= min(1., 2. * mrt6) * max(0., 1. - mrt6);;\n        m0 *= 3.;\n    }\n    sn1 *= min(1., 2. * mrt2) * max(0., 1. - mrt2);\n    \n    return  .5 * sn + .25 * sn1;\n}\n\nfloat usynth(float rt)\n{\n    rt = mod(rt, 15.);\n    float sn = .001;\n    float mrt2 = mod(2. * rt, 1.);\n    if (mod(5. * rt, 4.) < 1.)\n    {\n        float sna = \n              (1. - sin(2600. * tau * rt)) \n            + (1. - sin(1600. * tau * rt))\n            + (1. - sin(1300. * tau * rt))\n            + (1. - sin(867. * tau * rt));\n        sn = floor(abs(sna)) * pow(4., 1. - 6. * mod(rt, 1.));\n        sn *= .25 * min(1., mrt2) * max(0., 1. - mrt2);\n    }\n    //return 1e-6; \n\treturn .15 * sn;\n}\n\nvec2 nabrSynth(float time)\n{\n    float dt0[]= float[](0.947288, 0.878126, 0.796571, 0.707107, 0.614240, 0.522137, 0.434333, 0.353553);\n    float dt1[] = float[](1.089587, 0.911173, 1.005095, 1.079870, 0.721942, 0.987824, 1.022421, 0.439581, 1.225677, 0.360320, 0.178849, 1.739190, 0.145721, 0.345178, 2.554054, 0.138851);\n\n    vec2 uni = vec2(0), rev = vec2(0);\n\n    float tick = time * .016667;\n    float t0 = (38.88 * tick), t1 = (7.776 * tick);    \n\n    for (uint i = 0u; i < 7u; i++)\n    {\n        vec2 usy = vec2(usynth(t0 + 1.01 * dt0[i]), usynth(t0 + 1.00 * dt0[i]));\n        uni = (uni - usy);\n    }\n    for (uint j = 0u; j < 16u; j++)\n    {\n        vec2 rsy = vec2(synth(t1 + 1.025 * dt1[j]), synth(t1 + 1.010 * dt1[j]));\n        rev = (rev + uni);\n        rev = (rev + rsy);\n    }\n    \n    rev*=min(1.,time/24.);\n\treturn rev;\n}\n\n// synthie\n\nfloat pulse( float morph, float pulse, float phase )\n{\n\tfloat a, b;\n    if( pulse < 0.5 )\n        a = morph * pulse * 0.5;\n    else\n        a = morph * ( 1.0 - pulse ) / 2.0;\n    if( phase < pulse )\n    {\n        if( phase < a )\n        {\n            b = phase / a - 1.0;\n            return 1.0 - b * b;\n        }\n        if( phase < pulse - a )\n            return 1.0;\n        b = ( phase - pulse + a ) / a;\n        return 1.0 - b * b;\n    }\n    if( phase < pulse + a )\n    {\n        b = ( phase - pulse ) / a - 1.0;\n        return b * b - 1.0;\n    }\n    if( phase <= 1.0 - a )\n        return -1.0;\n    b = ( phase - 1.0 + a ) / a;\n    return b * b - 1.0;\n}\n\nvec2 synthie(float time,float note1,float note2)\n{\n\tfloat y=time*60.0/240.0;\n    float a=8.0;\n    float s=1.0;\n    float b=16.0;\n    float bi=floor(b*y);\n    float w=b*y-bi;\n    float sqe=pow(min(1.0,min(s-s*w,a*w)),2.0)*(3.0-mod(bi,3.0));\n    float x=time*note1;\n    float x2=time*note2;\n    \n    float fltr=0.5+abs(sin(time))*5.0;\n    float wave=\n        pulse(0.75, 1.75, fract(x))+pulse(0.9+sin(y*2.0/16.0)*0.1-sqe*fltr, 0.5+0.45*sin(y*4.0), fract(x))+\n        pulse(1.75, 0.75, fract(x2))+pulse(0.9+sin(y*2.0/16.0)*0.1-sqe*fltr, 0.5+0.45*sin(y*2.0), fract(x2));\n        \n    \n    return ((1.0+0.5*sin(time))/2.0)*vec2(\n        (wave*sqe*0.07)*clamp((1.0+sin(time))/2.,0.25,0.75),\n        (wave*sqe*0.07)*clamp((1.0+cos(time))/2.,0.25,0.75)\n    )*vec2(0.6);\n}\n\n// bass\n\nvec2 bass(float time, float tt, float freq, float parm1,float parm2)\n{\n    float freqTime = 3.141592*2.0*time*freq;\n    parm1=.5; parm2=0.29;\n    \n    return vec2(( sin(     freqTime\n                      +sin(freqTime)*7.0*exp(parm1*tt)\n                     )+\n                  sin(     freqTime*2.0\n                      +cos(freqTime*2.0)*1.0*sin(time*3.14)\n                      +sin(freqTime*8.0)*0.25*sin(1.0+time*3.14)\n                    )*exp(parm2*tt)+\n                  cos(     freqTime*4.0\n                      +cos(freqTime*2.0)*3.0*sin(time*3.14+0.3)\n                    )*exp(-2.0*tt)\n                )\n                \n                *exp(-1.0*tt) );\n}\n\n// initial swirl\n\nfloat rand(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat warpNoise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat fbm8(vec2 n) {\n    float total = 0.0, amplitude = 1.0;\n    for (int i = 0; i < 16; i++) {\n        total += warpNoise(n)/2. * amplitude;\n        n += n;\n        amplitude *= 0.5;\n    }\n    return total;\n}\n\nfloat fbm16(vec2 n) {\n    float total = 0.0, amplitude = 1.0;\n    for (int i = 0; i < 16; i++) {\n        total += warpNoise(n)/2. * amplitude;\n        n += n;\n        amplitude *= 0.25;\n    }\n    return total;\n}\n\nvec2 initialSwirl( float time )\n{\n    vec2 s1 = vec2(sin(440.+fbm8(vec2(time/2.))*70.*exp(fract(time/20.)*12.))+fbm16(vec2(time)))*2.;\n    vec2 s2 = vec2(sin(220.+fbm8(vec2(time))*70.*exp(fract(time/40.)*12.))+fbm8(vec2(time)))*1.;\n    s1 = mix(s1, s2, 0.5);\n    s1 = vec2(s1.x)*0.15;  \n    return s1;\n}\n\n//\n//\n//\n\nvec2 mainSound( in int samp, float time )\n{\n    vec2 soundOutput=vec2(0.0);\n    \n    float bassTime=mod(time/2.0,4.0);\n    if ((time>8.0)&&(time<16.0)) soundOutput+=bass(bassTime,bassTime *2.4,freqFromMidiNote(37.0),-2.0,-2.0)*0.5;\n    else if ((time>16.0)&&(time<24.0)) soundOutput+=bass(bassTime,bassTime *2.4,freqFromMidiNote(42.0),-2.0,-2.0)*0.5;\n\telse if ((time>=24.0)&&(time<40.0)) soundOutput+=bass(bassTime,bassTime *2.4,freqFromMidiNote(37.0),-2.0,-2.0)*0.5;    \n\telse if ((time>=40.0)&&(time<48.0)) soundOutput+=bass(bassTime,bassTime *2.4,freqFromMidiNote(42.0),-2.0,-2.0)*0.5;    \n\telse if ((time>=48.0)&&(time<64.0)) soundOutput+=bass(bassTime,bassTime *2.4,freqFromMidiNote(44.0),-2.0,-2.0)*0.5;              \n\telse if ((time>=64.0)&&(time<96.0)) soundOutput+=bass(bassTime,bassTime *2.4,freqFromMidiNote(37.0),-2.0,-2.0)*0.5;    \n    \n    if ((time>8.0)&&(time<64.0))\n    {\n\t\tif (time<16.0) soundOutput+=     synthie(time,35.0*11.9,44.0*11.9);\n        else if (time<24.0) soundOutput+=synthie(time,35.0*12.1,46.0*12.1);\n        else if (time<40.0) soundOutput+=synthie(time,35.0*11.9,44.0*11.9);\n        else if (time<48.0) soundOutput+=synthie(time,35.0*12.1,46.0*12.1);\n        else if (time<64.0) soundOutput+=synthie(time,35.0*12.0,52.0*12.0);\n    }\n\n    if ((time>8.0)&&(time<64.0))\n    {\n        if (time>=32.0) soundOutput+=snareDrum(mod(time+0.5,1.0));\n        soundOutput+=kick(mod(time,.5)*0.125);\n        soundOutput+=hihat(time,0.25);\n    }\n    \n    if (time<88.0) soundOutput+=nabrSynth(time)*0.065;\n    \n    if (time<sceneSpaceWarpEnd) soundOutput+=initialSwirl(time*1.4);\n    \n    return soundOutput;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "\n/* \n\t\"Don't you believe in flying saucers, they ask me? Don't you believe in \n\ttelepathy? — in ancient astronauts? — in the Bermuda triangle? — in life after death?\n\tNo, I reply. No, no, no, no, and again no.\n\tOne person recently, goaded into desperation by the litany of unrelieved negation, \n\tburst out \"Don't you believe in anything?\"\n\t\"Yes\", I said. \"I believe in evidence. I believe in observation, measurement, and reasoning, \n\tconfirmed by independent observers. I'll believe anything, no matter how wild and ridiculous, \n\tif there is evidence for it. The wilder and more ridiculous something is, however, \n\tthe firmer and more solid the evidence will have to be.”\n*/\n\n#define GETFAR 999999.0\n\nconst int numRaymarchSteps=64;\n\nvec3 rotx(in vec3 p, float a) \n{\n\treturn vec3(p.x,\n                cos(a) * p.y + sin(a) * p.z,\n                cos(a) * p.z - sin(a) * p.y);\n}\n\nvec3 roty(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.z,\n                p.y,\n                cos(a) * p.z - sin(a) * p.x);\n}\n\nvec3 rotz(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.y,\n                cos(a) * p.y - sin(a) * p.x,\n                p.z);\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat s_min(in float x, in float y, in float s) {\n\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return min(x,y) - 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\nfloat s_max(in float x, in float y, in float s) {\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return max(x,y) + 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\n// planet code by iq\nvec3 textureEarth(vec3 ro,vec3 rd,float t,vec3 N)\n{\n    vec3 pos = ro + t*rd;\n    vec3 nor = N;\n    vec3 col = vec3(0.1);\n\n    vec2 uv;\n    uv.x = atan(0.5+nor.x,nor.z)/6.2831 - 0.003*iTime;\n    uv.y = 0.5+acos(nor.y*0.9999)/3.141521;\n    uv.y *= 0.5;\n\n    col = vec3(0.1,0.2,0.3);\n    vec3 te  = 1.0*texture( iChannel1, 0.5*uv.yx ).xyz;\n    te += 0.3*texture( iChannel1, 2.5*uv.yx ).xyz;\n    col = mix( col, (vec3(0.2,0.2,0.1)*0.55 + 0.45*te + 0.5*texture( iChannel0, 15.5*uv.yx ).xyz)*0.4, smoothstep( 0.45,0.5,te.x) );\n\n    vec3 cl = texture( iChannel0, 2.0*uv ).xxx;\n    col = mix( col, vec3(0.9), 0.75*smoothstep( 0.55,0.8,cl.x) );\n\n    float dif = max(nor.x*1.5+nor.z,0.0);\n    float fre = 1.0-clamp(nor.z,0.0,1.0);\n    float spe = clamp( dot( nor,normalize(vec3(0.9,0.92,.92)) ), 0.0, 1.0 );\n    spe=pow(spe,64.0);\n    col *= 0.03 + 0.75*dif;\n    \n    return col*0.5;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  float multf=1.0;\n  if ((iTime>=sceneSpaceWarpEnd)&&(iTime<ufoWarpInEnd)) multf=mix(0.01,1.0,(iTime-sceneSpaceWarpEnd)/(ufoWarpInEnd-sceneSpaceWarpEnd));\n  if ((iTime>=warpOutEnd)&&(iTime<ufoRunsAway)) multf=mix(1.0,0.01,(iTime-warpOutEnd)/(ufoRunsAway-warpOutEnd));\n  vec2 q = vec2(length(p.xz)-t.x,p.y*multf);\n  return length(q)-t.y;\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdDiagonalCapsule( vec3 p, float h, float r )\n{\n  p=rotz(p,-0.6);\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdVertTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*(0.5+1.5*abs(sin(iTime*5.0)))+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdEgyptianPyramid( vec3 p, float s)\n{\n    float basepyr=GETFAR;\n    if (iTime>=pyrGrowingEnd)\n    {\n      p=roty(p,0.775);\n      p = abs(p);\n      basepyr=(p.x+p.y+p.z-s)*0.57735027;\n\n      float cutbox1=sdBox(p-vec3(0.0,1.2,0.0),vec3(6.0,max(mix(2.2,0.2,(iTime-pyrGrowingEnd)/(blackPyrEnd-pyrGrowingEnd)),0.0),6.0));\n      basepyr=opSubtraction(cutbox1,basepyr);\n\n      float cutbox2=sdBox(p-vec3(0.0,2.4,0.0),vec3(6.0,max(mix(2.2,0.2,(iTime-pyrGrowingEnd)/(blackPyrEnd-pyrGrowingEnd)),0.0),6.0));\n      basepyr=opSubtraction(cutbox2,basepyr);\n\n      float cutbox3=sdBox(p-vec3(0.0,3.6,0.0),vec3(6.0,max(mix(2.2,0.2,(iTime-pyrGrowingEnd)/(blackPyrEnd-pyrGrowingEnd)),0.0),6.0));\n      basepyr=opSubtraction(cutbox3,basepyr);\n    }\n  \treturn basepyr;\n}\n\nfloat sdPyramid( vec3 p, float s)\n{\n  p=roty(p,0.775);\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdfUfo(in vec3 loc) \n{\n    float mult=40.0;\n    float rangle=atan(abs(loc.z),loc.x);\n\tvec3 loc2=vec3(loc.x,loc.y+0.002*(sin((rangle+iTime)*50.0)),loc.z);\n    float ball1 = length(loc2 - vec3(0.0, -1.8, 0.0)) - 2.;\n    float ball2 = length(loc - vec3(0.0, 2.0, 0.0)) - 2.1;\n    float disc = s_max(ball1, ball2, 0.05);\n    float ball3 = length(loc - vec3(0.0, 0.43, 0.0)) - 0.4;\n    float result=opSubtraction(ball3,disc);\n    return result;\n}\n\nvec2 SDFDesertDream(vec3 r,bool onlyTransp)\n{\n\tfloat t=GETFAR;\n\n    vec3 ufo1Center=vec3(0.0,8.5,0.0);\n\tif ((iTime>=ufoDownBegin)&&(iTime<ufoDownEnd))\n    {\n        ufo1Center=mix(vec3(0.0,12.5,0.0),vec3(0.0,8.5,0.0),(iTime-ufoDownBegin)/(ufoDownEnd-ufoDownBegin));\n    }\n    else if (iTime>=zoomInEnd)\n    {\n        ufo1Center=vec3(0.0,8.5+(iTime-zoomInEnd),0.0);\n        if (iTime>=ufoRunsAway) \n        {\n            ufo1Center.x-=(iTime-ufoRunsAway)*3.0;\n            ufo1Center.y+=((iTime-ufoRunsAway))*15.;\n            ufo1Center.z+=8.0*(iTime-ufoRunsAway);\n        }\n    }\n\n    if (onlyTransp)\n    {\n        float cup=sdSphere(r-vec3(ufo1Center.x,ufo1Center.y-0.1,ufo1Center.z),0.45);\n        float cut=sdBox(r-vec3(ufo1Center.x,ufo1Center.y-0.3,ufo1Center.z),vec3(10.0,.4,10.0));\n        cup=opSubtraction(cut,cup);\n        t=min(t,cup);\n        if (t==cup) return vec2(t,-1.0);\n        return vec2(GETFAR);\n    }\n    \n    float ufo=sdfUfo(r-ufo1Center);\n    t=min(t,ufo);\n    \n\tfloat sand=r.y-terrainH(r.xz);    \n    t=min(t,sand);\n    \n    float pyrone=sdEgyptianPyramid(r-vec3(-0.,-0.0,0.0),5.5);\n    t=min(pyrone,t);\n    \n    if (t==sand) return vec2(t,3.0);\n    if (t==pyrone) return vec2(t,4.0);\n    if (t==ufo) return vec2(t,2.0);\n\n\treturn vec2(GETFAR,-1.0);\n}\n\nvec2 SDFDesertGlow(vec3 r)\n{\n\tfloat t=GETFAR;\n\n    float vertray=GETFAR;\n    \n    float multfact=0.76;\n    if ((iTime>=ufoDownEnd)&&(iTime<rayDownEnd))\n    {\n    \tvertray=sdVerticalCapsule(r-vec3(0.0,8.5-((iTime-ufoDownEnd)*multfact),0.0),\n                                  (iTime-ufoDownEnd)*multfact,0.04);\n    }\n    else if ((iTime>=rayDownEnd)&&(iTime<fourRaysReturn))\n    {\n        vertray=sdVerticalCapsule(r-vec3(0.0,8.5-((rayDownEnd-ufoDownEnd)*multfact),0.0),\n                                  (rayDownEnd-ufoDownEnd)*multfact,0.04);\n    }\n    else if ((iTime>=fourRaysReturn)&&(iTime<zoomInEnd))\n    {\n    \tvertray=sdVerticalCapsule(r-vec3(0.0,8.5-((zoomInEnd-iTime)*multfact),0.0),\n                                  (zoomInEnd-iTime)*multfact,0.04);\n    }\n    t=min(t,vertray);\n\n    float pyrone=GETFAR;\n    \n    if ((iTime>=rayQuadEnd)&&(iTime<blackPyrEnd))\n    {\n        pyrone=sdPyramid(r-vec3(-0.,-0.0,0.0),min((iTime-rayQuadEnd),5.0));\n        float cutBox=sdBox(r-vec3(0.0,-2.5,0.0),vec3(4.0,3.0,4.0));\n        pyrone=opSubtraction(cutBox,pyrone);\n    }\n    t=min(pyrone,t);\n \n    r.x=-abs(r.x);\n    r.z=-abs(r.z);\n    float angray1=GETFAR;\n    if ((iTime>=rayDownEnd)&&(iTime<rayQuadEnd))\n    {\n    \tangray1=udTriangle(r-vec3(0.0,0.0,0.0),\n                            vec3(0.0,5.5,0.0),\n                            mix(vec3(-.4,5.0,-.4),vec3(-3.6,0.5,-3.6),clamp((iTime-rayDownEnd)/4.0,0.0,1.0)),\n                            vec3(0.0,5.51,0.0))-0.02;\n    }\n    else if ((iTime>=rayQuadEnd)&&(iTime<blackPyrEnd))\n    {\n    \tangray1=udTriangle(r-vec3(0.0,0.0,0.0),\n                            vec3(0.0,5.5,0.0),\n                            vec3(-3.6,0.5,-3.6),\n                            vec3(0.0,5.51,0.0))-0.02;\n    }\n    else if ((iTime>=blackPyrEnd)&&(iTime<fourRaysReturn))\n    {\n        angray1=udTriangle(r-vec3(0.0,0.0,0.0),\n                            vec3(0.0,5.5,0.0),\n                            mix(vec3(-3.6,0.5,-3.6),\n                                vec3(-.4,5.0,-.4),\n                                clamp((iTime-blackPyrEnd)/4.0,0.0,1.0)),\n                            vec3(0.0,5.51,0.0))-0.02;\n    }\n    \n    t=min(t,angray1);\n\n    vec3 ringCenter=vec3(0.0,8.56,0.0);\n\tif ((iTime>=ufoDownBegin)&&(iTime<ufoDownEnd))\n    {\n        ringCenter=mix(vec3(0.0,12.56,0.0),vec3(0.0,8.56,0.0),(iTime-ufoDownBegin)/(ufoDownEnd-ufoDownBegin));\n    }\n    else if (iTime>=zoomInEnd)\n    {\n        ringCenter=vec3(0.0,8.56+(iTime-zoomInEnd),0.0);\n        if (iTime>=ufoRunsAway) \n        {\n            ringCenter.x-=(iTime-ufoRunsAway)*3.0;\n            ringCenter.y+=((iTime-ufoRunsAway))*15.;\n            ringCenter.z+=8.0*(iTime-ufoRunsAway);\n        }\n    }\n    \n    float glowring=sdTorus(r-ringCenter,vec2(0.75,0.02));\n    t=min(t,glowring);\n    \n    if (t==vertray) return vec2(t,1. / ( 1.0 + pow(abs(t*20.0),.63)));\n    if (t==pyrone) return vec2(t,1. / ( 1.0 + pow(abs(t*20.0),.63)));\n    if (t==angray1) return vec2(t,1. / ( 1.0 + pow(abs(t*20.0),.63)));\n    if (t==glowring) return vec2(t,1. / ( 1.0 + pow(abs(t*20.0),.63)));\n    \n    return vec2(GETFAR,1. / ( 1.0 + pow(abs(t*20.0),.63)));\n}\n\nvec2 SDFOpeningGlow(vec3 r)\n{\n\tfloat t=GETFAR;\n\n    vec3 grPos=vec3(6.0,0.,5.5);\n\tif ((iTime>=sceneSpaceWarpEnd)&&(iTime<sceneMovementEnd))\n    {\n        grPos=mix(vec3(0.0,0.86,-14.0),vec3(3.0,0.86,3.5),(iTime-sceneSpaceWarpEnd)/(sceneMovementEnd-sceneSpaceWarpEnd));\n    }\n    else if (iTime<ufoBehindEarth)\n    {\n        grPos=mix(vec3(3.0,0.86,3.5),vec3(6.0,0.86,6.5),(iTime-sceneMovementEnd)/(ufoBehindEarth-sceneMovementEnd));\n    }\n    \n    float glowring=sdTorus(r-grPos,vec2(0.75,0.025));\n    t=min(t,glowring);\n    \n    if (t==glowring) return vec2(t,1. / ( 1.0 + pow(abs(t*20.0),.63)));\n    \n    return vec2(GETFAR,1. / ( 1.0 + pow(abs(t*20.0),.63)));\n}\n\nvec2 SDFOpeningScene(vec3 r,bool onlyTransp)\n{\n\tfloat t=GETFAR;\n    vec3 origR=r;\n\n    vec3 ufo1Center=vec3(6.0,0.,5.5);\n\tif ((iTime>=sceneSpaceWarpEnd)&&(iTime<sceneMovementEnd))\n    {\n        ufo1Center=mix(vec3(0.0,0.8,-14.0),vec3(3.0,0.8,3.5),(iTime-sceneSpaceWarpEnd)/(sceneMovementEnd-sceneSpaceWarpEnd));\n    }\n    else if (iTime<ufoBehindEarth)\n    {\n        ufo1Center=mix(vec3(3.0,0.8,3.5),vec3(6.0,0.8,6.5),(iTime-sceneMovementEnd)/(ufoBehindEarth-sceneMovementEnd));\n    }\n    \n    if (onlyTransp)\n    {\n        float cup=sdSphere(r-vec3(ufo1Center.x,ufo1Center.y-0.1,ufo1Center.z),0.45);\n        float cut=sdBox(r-vec3(ufo1Center.x,ufo1Center.y-0.3,ufo1Center.z),vec3(10.0,.4,10.0));\n        cup=opSubtraction(cut,cup);\n        t=min(t,cup);\n        if (t==cup) return vec2(t,-1.0);\n        return vec2(GETFAR);\n    }\n    else\n    {\n        float ufo=sdfUfo(r-ufo1Center);\n        t=min(t,ufo);\n\n        float planetEarth=sdSphere(r-vec3(5.,-1.,1.0),2.5);\n        t=min(t,planetEarth);\n\n        if (t==planetEarth) return vec2(t,1.0);\n        if (t==ufo) return vec2(t,2.0);\n        return vec2(GETFAR,-1.0);    \n    }\n}\n\nvec2 SDFDescentGlow(vec3 r)\n{\n\tfloat t=GETFAR;\n\n    vec3 grPos=vec3(0.0,25.05,-0.5);\n    if (iTime>=fogSceneFadeIn)\n    {\n        grPos=vec3(0.0,25.05-((iTime-fogSceneFadeIn)*3.0),-0.5);\n    }\n    \n    float glowring=sdTorus(r-grPos,vec2(0.75,0.025));\n    t=min(t,glowring);\n    \n    if (t==glowring) return vec2(t,1. / ( 1.0 + pow(abs(t*20.0),.63)));\n    \n    return vec2(GETFAR,1. / ( 1.0 + pow(abs(t*20.0),.63)));\n}\n\nvec2 SDFDescentScene(vec3 r,bool onlyTransp)\n{\n\tfloat t=GETFAR;\n    vec3 origR=r;\n\n    vec3 ufo1Center=vec3(0.0,25.,-0.5);\n    if (iTime>=fogSceneFadeIn)\n    {\n        ufo1Center=vec3(0.0,25.-((iTime-fogSceneFadeIn)*3.0),-0.5);\n    }\n    \n    if (onlyTransp)\n    {\n        float cup=sdSphere(r-vec3(ufo1Center.x,ufo1Center.y-0.1,ufo1Center.z),0.45);\n        float cut=sdBox(r-vec3(ufo1Center.x,ufo1Center.y-0.3,ufo1Center.z),vec3(10.0,.4,10.0));\n        cup=opSubtraction(cut,cup);\n        t=min(t,cup);\n        if (t==cup) return vec2(t,-1.0);\n        return vec2(GETFAR);\n    }\n    else\n    {\n        float ufo=sdfUfo(r-ufo1Center);\n        t=min(t,ufo);\n\n        float sand=r.y-terrainH(r.xz);    \n        t=min(t,sand);\n\n        if (t==sand) return vec2(t,3.0);\n        \n        if (t==ufo) return vec2(t,2.0);\n        return vec2(GETFAR,-1.0);    \n    }\n}\n\nvec3 calcNormal(vec3 pos,bool onlyTransp)\n{\n\tvec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3(( mod(float((i+3)/2),2.0) ),(mod(float(i/2),2.0)),(mod(float(i),2.0)))-1.0);\n        if (iTime<ufoBehindEarth) n += e*SDFOpeningScene(pos+0.0005*e,onlyTransp)[0];\n        else if ((iTime>=ufoBehindEarth)&&(iTime<ufoDownBegin)) n += e*SDFDescentScene(pos+0.0005*e,onlyTransp)[0];\n        else n += e*SDFDesertDream(pos+0.0005*e,onlyTransp)[0];\n    }\n    return normalize(n);\n}\n\nvec2 rayMarch(vec3 rayOrigin, vec3 rayDir)\n{\n    float t = 0.0;\n\n    for (int i = 0; i < 128; i++)\n    {\n        vec2 res;\n        if (iTime<ufoBehindEarth) res = SDFOpeningScene(rayOrigin + rayDir * t,false);\n        else if ((iTime>=ufoBehindEarth)&&(iTime<ufoDownBegin)) res = SDFDescentScene(rayOrigin + rayDir * t,false);\n        else res = SDFDesertDream(rayOrigin + rayDir * t,false);\n\n        if (res[0] < (0.0001*t))\n        {\n            return vec2(t,res[1]);\n        }\n        t += res[0];\n    }\n     \n    return vec2(GETFAR,-1.0);\n}\n\nfloat rayMarchTransp(vec3 rayOrigin,vec3 rayDir)\n{\n    float t = 0.0;\n\n    for (int i = 0; i < numRaymarchSteps; i++)\n    {\n        vec2 res;\n        if (iTime<ufoBehindEarth) res = SDFOpeningScene(rayOrigin + rayDir * t,true);\n        else if ((iTime>=ufoBehindEarth)&&(iTime<ufoDownBegin)) res = SDFDescentScene(rayOrigin + rayDir * t,true);\n        else res = SDFDesertDream(rayOrigin + rayDir * t,true);\n        \n        if (res[0] < (0.0001*t))\n        {\n            return t;\n        }\n        t += res[0];\n    }\n     \n    return -1.0;\n}\n\nvec2 rayMarchNeon(vec3 rayOrigin, vec3 rayDir)\n{\n    float glow=0.0;\n    float t=0.0;\n    bool hit=false;\n    float thit=GETFAR;\n\n    for (int i=0;i<numRaymarchSteps;i++)\n    {\n        vec2 sdfRes;\n        if (iTime<ufoBehindEarth) sdfRes = SDFOpeningGlow(rayOrigin+rayDir*t);\n        else if ((iTime>=ufoBehindEarth)&&(iTime<ufoDownBegin)) sdfRes = SDFDescentGlow(rayOrigin+rayDir*t);\n        else sdfRes = SDFDesertGlow(rayOrigin+rayDir*t);\n        \n        if ((sdfRes[0] < (0.0001*t))&&(!hit))\n        {\n            hit=true; \n            thit=t;\n        }\n        t += sdfRes[0];\n        \n        float d=distance(rayOrigin+rayDir*t,rayOrigin);\n        glow+=sdfRes[1]/((d*0.08+1.0)*(d*0.08+1.0));\n    }\n    \n    return vec2(thit,glow);\n}\n\nvec2 rayMarchFog(vec3 rayOrigin, vec3 rayDir,vec2 fragCoord)\n{\n    float totalfog=0.0;\n\n    vec2 screenPos = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    screenPos.x=-screenPos.x;\n\n    vec3 r = normalize(vec3(screenPos,.1))*.2;\n    vec3 p = vec3(rayOrigin.x,rayOrigin.y,rayOrigin.z+iTime*4.0);\n    \n\tfloat q=30.;\n\tfor(int i=0;i<100;i++)\n    {\n        vec4 t=texture(iChannel3,(p.xy+vec2(37,17)*floor(p.z)+iTime*1.5)/1000.);\n        totalfog+=mix(t.x*t.y,cos(t.y)*t.x,fract(p.z))/q;\n        q*=1.01;\n        p+=r;\n    }    \n    \n    return vec2(0.0,totalfog);\n}\n\nfloat fresnel(float bias, float scale, float power, vec3 I, vec3 N)\n{\n    return bias + scale * pow(1.0 + dot(I, N), power);\n}\n\nvec4 reflekt(vec3 rayOrigin, vec3 rayDir)\n{\n    vec3 col=vec3(0.);\n\tvec3 L = normalize(vec3(.61, 0.9, -1.23 ));\n\n    vec3 finalColor=vec3(0.0);\n    vec2 rayHit = rayMarch(rayOrigin, rayDir);\n    float dist=rayHit[0];\n    float mat=rayHit[1];\n    vec3 pHit=rayOrigin+rayDir*dist;\n    \n    vec3 N=calcNormal(pHit,false);\n    float NoL = max(dot(N, L), 0.0);\n  \n    finalColor=space(rayDir,iTime,1).rgb*0.1;\n\n    return vec4(finalColor,1.0);    \n}\n\nvec4 rayMarchCycle(vec3 rayOrigin, vec3 rayDir,vec2 fragCoord,out vec3 outPhit)\n{\n    vec3 col=vec3(0.);\n\tvec3 L = normalize(vec3(.8, 1.4, -1.23 ));\n    vec3 fogcol=vec3(0.1,0.02,0.02);\n\n    vec3 finalColor=vec3(0.0);\n    \n    vec2 rayHit = rayMarch(rayOrigin, rayDir);\n    float tTransp=rayMarchTransp(rayOrigin, rayDir);\n    vec2 tNeon=rayMarchNeon(rayOrigin, rayDir);\n    vec2 tFog=rayMarchFog(rayOrigin, rayDir,fragCoord);\n    \n    float dist=rayHit[0];\n    float mat=rayHit[1];\n    vec3 pHit=rayOrigin+rayDir*dist;\n    outPhit=pHit;\n    \n    vec3 N=calcNormal(pHit,false);\n    float NoL = max(dot(N, L), 0.0);\n    float frsnl = fresnel(0.01, 2.0, 8.0, normalize(pHit - rayOrigin), N);\n\n    if (mat==1.0) // earth\n    {\n        finalColor=vec3(0.1,0.3,0.5)*frsnl*NoL;\n        finalColor+=textureEarth(rayOrigin,rayDir,rayHit[0],N);\n    }\n    else if (mat==2.0) // ufo\n    {\n        vec4 refcol=reflekt(pHit,reflect(rayDir,N));\n        //NoL=pow(NoL,64.0);\n        //finalColor=vec3(0.1,0.3,0.5)*NoL*frsnl;\n        finalColor=vec3(0.1,0.1,0.3)*NoL*frsnl;\n        //finalColor+=vec3(0.12,0.23,0.33);\n        finalColor=mix(finalColor,refcol.rgb,0.4);\n        //finalColor*=sqrt(0.17*mix(vec4(0.0),texture(iChannel2,reflect(rayDir,N)),step(dist, 1e1))).rgb;\n        finalColor*=sqrt(0.17*mix(vec4(0.0),texture(iChannel2,reflect(rayDir,N)),0.5)).rgb;\n    }\n    else if (mat==3.0) // desert\n    {\n        vec3 L = normalize( vec3(0.8,0.3,-0.3) );\n\n        vec3 lightColor = vec3(1.0);\n        vec3 sandColor = vec3(0.79,0.50,0.24);        \n    \tvec3 ambientColor = vec3(0.5);\n        \n\t\t//float shadow = desertShadow(pHit + L *0.01,L);\n        \n        vec3 normal = N;\n        normal = normalize(normal + vec3(sin(pHit.x * 100.0 + sin(pHit.z * 31.0) + sin(pHit.y) * 200.0) * 0.02,0,0));\n        vec3 viewDir = -rayDir;\n\n        float lambertian = max(dot(L,normal), 0.0);\n\n        float shininess =  20.0;\n        vec3 halfDir = normalize(L + viewDir);\n        float specAngle = max(dot(halfDir, normal), 0.0);\n        float specular1 = pow(specAngle, shininess);\n        float specular2 = pow(specAngle, shininess / 2.0) * pow(texture(iChannel0,pHit.xz * 10.0).x,3.0);\n\n        vec3 diff = sandColor * lambertian * lightColor;\n        vec3 spec = (specular1 *0.3 + specular2 * 0.2) * lightColor;\n        vec3 ambient = ambientColor * sandColor;\n        finalColor = .2 *( (diff + spec) + ambient);        \n\n        //vec3 spaceColor=space(rayDir,iTime).rgb*0.1;\n        //spaceColor=clamp(spaceColor,vec3(0.0),vec3(1.0));\n        \n        //vec3 shDir=normalize(L-pHit);\n        //vec2 shray=rayMarch(pHit+shDir*0.01,shDir);\n        //if ((shray[0]!=GETFAR)&&(shray[1]!=3.0)) finalColor*=0.5;\n        \n        finalColor=mix(vec3(0.0),finalColor,max(0.0,4.0/dist));\n\n        // fog over desert\n        if ((iTime>=ufoBehindEarth)&&(iTime<ufoDownBegin))\n        {\n            //fog for the descent scene\n            if (tFog[1]!=0.0)\n            {\n                if (iTime<fogFadeoutBegin) finalColor=vec3(pow(tFog[1],3.2))*.1;\n                else finalColor=mix(vec3(pow(tFog[1],3.2))*.1,finalColor,(iTime-fogFadeoutBegin)/(ufoDownBegin-fogFadeoutBegin));\n            }\n        }\n        \n    }\n    else if (mat==4.0) // pyramid\n    {\n        finalColor=vec3(0.1)*0.05*NoL;\n    }\n    else\n    {\n        // for desert scene\n\t\tvec3 pdir=normalize(pHit);\n        vec3 pstraight=normalize(vec3(0.0,1.0,0.0));\n        float nol2=dot(pdir,pstraight);\n        \n        finalColor=space(rayDir,iTime,0).rgb*0.1;\n        \n        vec2 uv = (-iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n        if ((iTime>=warpOutBegin)&&(iTime<thatsAllFolks)) \n        {\n            vec3 sw=spaceWarp(iTime+4.5,uv).rgb;\n            finalColor=mix(finalColor,\n                           sw,\n                           min((iTime-warpOutBegin)/(warpOutEnd-warpOutBegin),1.0));\n        }\n        \n        if ((iTime>=ufoDownBegin)) finalColor*=nol2;\n\t}\n    \n    if (tNeon[1]>0.0)\n    {\n        if ((tNeon[0]==GETFAR)&&((mat==4.0)||(mat==2.0)||(mat==1.0))) ;\n        else if ((tNeon[0]==GETFAR)||(tNeon[0]<dist)||(dist==GETFAR))\n        {\n            finalColor+=vec3(0.04,0.04,0.16)*tNeon[1];\n        }\n    }\n    \n    if (tTransp!=-1.0)\n    {\n        if ((tTransp<dist)||(dist==GETFAR))\n        {\n    \t\tvec3 N2=calcNormal(rayOrigin+rayDir*tTransp,true);\n        \tfloat frsnl = fresnel(.2, 8.0, 7.0, normalize((rayOrigin+rayDir*tTransp) - rayOrigin), N2);\n            //float dot2=max(dot(N2,L),0.0);\n            //dot2=pow(dot2,24.0);\n            finalColor+=vec3(0.01)+vec3(0.32,0.2,0.2)*frsnl;\n        }\n    }\n    \n    return vec4(finalColor,1.0);    \n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 screenPos = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    screenPos.x=-screenPos.x;\n  \n    vec3 camPos;\n\tvec3 camTarget;\n    float camRot=0.0;\n \n    if ((iTime>=sceneFadeInBegin)&&(iTime<sceneSpaceWarpEnd))\n    {\n        camPos=vec3(-1.01,2.5,-5.5);\n        camTarget = vec3(0.0,0.8,-14.0);\n    }\n    else if ((iTime>=sceneSpaceWarpEnd)&&(iTime<sceneMovementEnd))\n    {\n        // camera follows ufo\n        camPos=vec3(-1.01,2.5,-5.5);\n        camTarget=mix(vec3(0.0,0.8,-14.0),vec3(3.0,0.8,3.5),(iTime-sceneSpaceWarpEnd)/(sceneMovementEnd-sceneSpaceWarpEnd));\n    }\n    else if (iTime<ufoBehindEarth)\n    {\n        // camera follows ufo\n        camPos=vec3(-1.01+(iTime-sceneMovementEnd),2.5-(iTime-sceneMovementEnd),-5.5);\n        camTarget=mix(vec3(3.0,0.8,3.5),vec3(6.0,0.8,6.5),(iTime-sceneMovementEnd)/(ufoBehindEarth-sceneMovementEnd));\n    }\n    // descent scene\n    else if ((iTime>=ufoBehindEarth)&&(iTime<fogFadeoutBegin))\n    {\n        camPos=vec3(0.0,28.5-(ufoBehindEarth-sceneMovementEnd),-1.);\n        camTarget=vec3(0.0,2.0,1.0);\n    }\n    else if ((iTime>=fogFadeoutBegin)&&(iTime<ufoDownBegin))\n    {\n    \tcamPos=vec3(0.0,28.5-(ufoBehindEarth-sceneMovementEnd)-((iTime-fogFadeoutBegin)*3.0),-1.0-(iTime-fogFadeoutBegin));\n    \tcamTarget=vec3(0.0,2.0,1.0);\n    }\n    // desert dream scene\n    else if ((iTime>=ufoDownBegin)&&(iTime<ufoDownEnd))\n    {\n    \tcamPos=vec3(0.0,6.0+((iTime-ufoDownBegin)*2.0),-5.0);\n    \tcamTarget=vec3(0.0,8.5,0.0);\n    }\n    else if ((iTime>=ufoDownEnd)&&(iTime<rayQuadEnd))\n    {\n    \tcamPos=vec3(sin(iTime/2.0)*8.0,10.0-(iTime-ufoDownEnd),cos(iTime/2.0)*6.0);\n    \tcamTarget=vec3(0.0,5.0,0.0);\n    }\n    else if ((iTime>=rayQuadEnd)&&(iTime<pyrGrowingEnd))\n    {\n    \tcamPos=vec3(sin(iTime/2.0)*8.0,10.0-(rayQuadEnd-ufoDownEnd),cos(iTime/2.0)*6.0);\n    \tcamTarget=vec3(0.0,5.0,0.0);\n    }\n    else if ((iTime>=pyrGrowingEnd)&&(iTime<blackPyrEnd))\n    {\n    \tcamPos=vec3(sin(iTime/2.0)*8.0,10.0-(rayQuadEnd-ufoDownEnd)+(iTime-pyrGrowingEnd),cos(iTime/2.0)*6.0);\n    \tcamTarget=vec3(0.0,5.0,0.0);\n    }\n    else if ((iTime>=blackPyrEnd)&&(iTime<zoomInEnd))\n    {\n    \tcamPos=vec3(-4.0+(iTime-blackPyrEnd),3.0+(iTime-blackPyrEnd),-13.0);\n    \tcamTarget=vec3(0.0,3.0,0.0);\n    }\n    else\n    {\n    \tcamPos=vec3(0.0,3.0+(iTime-zoomInEnd),-13.0+(iTime-zoomInEnd)*0.5);\n    \tcamTarget=vec3(0.0,3.0+(iTime-zoomInEnd)*1.5,0.0);\n    }\n    \n    mat3 ca = setCamera( camPos, camTarget, camRot );\n    vec3 rayDir = ca * normalize( vec3(screenPos.xy,1.5));\n    \n    vec3 outPhit;\n    \n    vec4 marchCol=rayMarchCycle(camPos, rayDir,fragCoord,outPhit);\n    marchCol.xyz*=0.65;\n    marchCol.xyz=ACESFilm(marchCol.xyz);\n    marchCol.xyz=LinearToSRGB(marchCol.xyz*1.2);\n    marchCol=pow(marchCol,vec4(0.45454));\n \n    if (iTime<sceneFadeInEnd) marchCol=mix(vec4(0.0),marchCol,iTime/(sceneFadeInEnd-sceneFadeInBegin));\n\tif ((iTime>=fadeOutEarthBegin)&&(iTime<ufoBehindEarth)) marchCol=mix(marchCol,vec4(0.0),(iTime-fadeOutEarthBegin)/(ufoBehindEarth-fadeOutEarthBegin));\n\tif ((iTime>=ufoBehindEarth)&&(iTime<fogSceneFadeIn)) marchCol=vec4(0.0);\n    if ((iTime>=fogSceneFadeIn)&&(iTime<fogFadeoutBegin)) marchCol=mix(vec4(0.0),marchCol,(iTime-fogSceneFadeIn)/(fogFadeoutBegin-fogSceneFadeIn));\n    if (iTime>=finalFadeOut) marchCol=mix(marchCol,vec4(0.0),(iTime-finalFadeOut)/(thatsAllFolks-finalFadeOut));\n    if (iTime>=thatsAllFolks) marchCol=vec4(0.0);\n    fragColor = marchCol;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}