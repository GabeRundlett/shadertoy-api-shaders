{
    "Shader": {
        "info": {
            "date": "1636757868",
            "description": "Numerically calculating the euclidean distance to a cubic bezier curve.",
            "flags": 0,
            "hasliked": 0,
            "id": "sdjXRy",
            "likes": 23,
            "name": "Distance to Cubic Bezier",
            "published": 3,
            "tags": [
                "2d",
                "bezier",
                "distance",
                "cubic",
                "numerical"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 527
        },
        "renderpass": [
            {
                "code": "vec2 posBezier(in vec2 a, in vec2 b, in vec2 c, in vec2 d, in float t) {\n    float tInv = 1.0 - t;\n    return a * tInv * tInv * tInv + b * 3.0 * t * tInv * tInv + c * 3.0 * tInv * t * t + d * t * t * t;\n}\n\n// https://www.shadertoy.com/view/st33Wj\nvec2 cmul(in vec2 z, in vec2 w) { return mat2(z, -z.y, z.x) * w; }\nvec2 cdiv(in vec2 z, in vec2 w) { return cmul(z, vec2(w.x, -w.y)) / dot(w, w); }\nint solveQuintic(in float a, in float b, in float c,\n    in float d, in float e, in float f, out float[5] realRoots) {\n    float p = (5.0 * a * c - 2.0 * b * b) / (5.0 * a * a);\n    float q = (25.0 * a * a * d - 15.0 * a * b * c + 4.0 * b * b * b) / (25.0 * a * a * a);\n    float r = (125.0 * a * a * a * e - 50.0 * a * a * b * d + 15.0 * a * b * b * c - 3.0 * b * b * b * b) / (125.0 * a * a * a * a);\n    float s = (3125.0 * a * a * a * a * f - 625.0 * a * a * a * b * e + 125.0 * a * a * b * b * d - 25.0 * a * b * b * b * c + 4.0 * b * b * b * b * b) / (3125.0 * a * a * a * a * a);\n\n    float bound = 1.0 + max(1.0, max(abs(p), max(abs(q), max(abs(r), abs(s)))));\n    //bound *= 0.414213562373; // Correction if perturbing with random([-1...1])\n    bound *= 0.5;\n\n    vec2[5] roots;\n    roots[0] = vec2(bound, 0.0);\n    roots[1] = vec2(0.309016994375, 0.951056516295) * bound;\n    roots[2] = vec2(-0.809016994375, 0.587785252292) * bound;\n    roots[3] = vec2(-0.809016994375, -0.587785252292) * bound;\n    roots[4] = vec2(0.309016994375, -0.951056516295) * bound;\n\n    for (int iter=0; iter < 25; iter++) {\n        float maxEval = -1e20;\n        for (int root=0; root < 5; root++) {\n            vec2 z = roots[root];\n            vec2 quinticVal = cmul(cmul(cmul(cmul(z, z) + vec2(p, 0.0), z) + vec2(q, 0.0), z) + vec2(r, 0.0), z) + vec2(s, 0.0);\n            maxEval = max(maxEval, max(abs(quinticVal.x), abs(quinticVal.y)));\n\n            vec2 denom = z - roots[(root + 1) % 5];\n            denom = cmul(denom, z - roots[(root + 2) % 5]);\n            denom = cmul(denom, z - roots[(root + 3) % 5]);\n            denom = cmul(denom, z - roots[(root + 4) % 5]);\n\n            roots[root] -= cdiv(quinticVal, denom);\n        }\n\n        if (maxEval < 1e-7) break;\n    }\n\n    int numRealRoots = 0;\n    float offs = b / (5.0 * a);\n    for (int root=0; root < 5; root++) {\n        vec2 z = roots[root];\n        if (abs(z.y) < 1e-7) {\n            realRoots[numRealRoots] = z.x - offs;\n            numRealRoots++;\n        }\n    }\n\n    return numRealRoots;\n}\n\nfloat dot2(in vec2 v) { return dot(v, v); }\nvec4 sdCubicBezier(in vec2 p, in vec2 v1, in vec2 v2, in vec2 v3, in vec2 v4) {\n    // Convert to power basis\n    vec2 a = v4 + 3.0 * (v2 - v3) - v1;\n    vec2 b = 3.0 * (v1 - 2.0 * v2 + v3);\n    vec2 c = 3.0 * (v2 - v1);\n    vec2 d = v1 - p;\n\n    // Quintic coefficients (derivative of distance-for-t with 2 factored out)\n    float qa = 3.0 * dot(a, a);\n    float qb = 5.0 * dot(a, b);\n    float qc = 4.0 * dot(a, c) + 2.0 * dot(b, b);\n    float qd = 3.0 * (dot(b, c) + dot(d, a));\n    float qe = dot(c, c) + 2.0 * dot(d, b);\n    float qf = dot(d, c);\n\n    float distSq = dot2(p - v1);\n    float tNear = 0.0;\n    vec2 pNear = v1;\n\n    float distSq2 = dot2(p - v4);\n    if (distSq2 < distSq) {\n        distSq = distSq2;\n        tNear = 1.0;\n        pNear = v4;\n    }\n\n    float[5] roots;\n    int numRoots = solveQuintic(qa, qb, qc, qd, qe, qf, roots);\n    for (int n=0; n < numRoots; n++) {\n        float t = roots[n];\n        if (0.0 < t && t < 1.0) {\n            vec2 pos = posBezier(v1, v2, v3, v4, t);\n            float distSq2 = dot2(p - pos);\n            if (distSq2 < distSq) {\n                distSq = distSq2;\n                pNear = pos;\n                tNear = t;\n            }\n        }\n    }\n\n    return vec4(pNear, tNear, sqrt(distSq));\n}\n\n/*\n// Plain and simple version (nearest point and parameter are not recorded)\nfloat dot2(in vec2 v) { return dot(v, v); }\nfloat sdCubicBezier(in vec2 p, in vec2 v1, in vec2 v2, in vec2 v3, in vec2 v4) {\n    // Convert to power basis\n    vec2 a = v4 + 3.0 * (v2 - v3) - v1;\n    vec2 b = 3.0 * (v1 - 2.0 * v2 + v3);\n    vec2 c = 3.0 * (v2 - v1);\n    vec2 d = v1 - p;\n\n    // Quintic coefficients (derivative of distance-for-t with 2 factored out)\n    float qa = 3.0 * dot(a, a);\n    float qb = 5.0 * dot(a, b);\n    float qc = 4.0 * dot(a, c) + 2.0 * dot(b, b);\n    float qd = 3.0 * (dot(b, c) + dot(d, a));\n    float qe = dot(c, c) + 2.0 * dot(d, b);\n    float qf = dot(d, c);\n\n    float[5] roots;\n    int numRoots = solveQuintic(qa, qb, qc, qd, qe, qf, roots);\n    float distSq = min(dot2(p - v1), dot2(p - v4));\n    for (int n=0; n < numRoots; n++) {\n        float t = roots[n];\n        if (0.0 < t && t < 1.0) {\n            distSq = min(distSq, dot2(p - posBezier(v1, v2, v3, v4, t)));\n        }\n    }\n\n    return sqrt(distSq);\n}\n*/\n\n// For visualizing the distance mnimizing quintic\nfloat sdMinimizerPoly(in vec2 pos, in vec2 p, in vec2 v1, in vec2 v2, in vec2 v3, in vec2 v4) {\n    // Convert to power basis\n    vec2 a = v4 + 3.0 * (v2 - v3) - v1;\n    vec2 b = 3.0 * (v1 - 2.0 * v2 + v3);\n    vec2 c = 3.0 * (v2 - v1);\n    vec2 d = v1 - p;\n\n    // Quintic coefficients (derivative of distance-for-t with 2 factored out)\n    float t5 = 3.0 * dot(a, a);\n    float t4 = 5.0 * dot(a, b);\n    float t3 = 4.0 * dot(a, c) + 2.0 * dot(b, b);\n    float t2 = 3.0 * (dot(b, c) + dot(d, a));\n    float t1 = dot(c, c) + 2.0 * dot(d, b);\n    float t0 = dot(d, c);\n\n    float y = ((((t5 * pos.x + t4) * pos.x + t3) * pos.x + t2) * pos.x + t1) * pos.x + t0;\n    float dx = (((5.0 * t5 * pos.x + 4.0 * t4) * pos.x + 3.0 * t3) * pos.x + 2.0 * t2) * pos.x + t1;\n\n    return abs(pos.y - y) / sqrt(1.0 + dx * dx);\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 3.0;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 3.0;\n    float unit = 6.0 / iResolution.y;\n    float time = iTime;//610.94;\n\n    float t1 = time * 0.5, t2 = time, t3 = time * 1.25;\n\n    float c1 = cos(t1), s1 = sin(t1);\n    float c2 = cos(t2), s2 = sin(t2);\n    float c3 = cos(t3), s3 = sin(t3);\n\n    /*\n    vec2 a = vec2(-1.0, -0.75);\n    vec2 b = vec2(s1, s2);\n    vec2 c = vec2(c3, c1);\n    vec2 d = vec2(1.0, -0.75);\n    */\n\n    vec2 a = vec2(c2 * 0.5, s3);\n    vec2 b = vec2(-2.0, 1.0);\n    vec2 c = vec2(2.0, 1.0);\n    vec2 d = vec2(s2 * 0.5, c3);\n\n    float sdf = sdCubicBezier(uv, a, b, c, d).w - 0.1;\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(sdf) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(sdf));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * sdf);\n\tcolor = mix(color, vec3(1.0), smoothstep(unit, 0.0, abs(sdf)));\n\n    // Hull\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, sdLine(uv, a, b) - 0.01));\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, sdLine(uv, b, c) - 0.01));\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, sdLine(uv, c, d) - 0.01));\n\n    // Control points\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - a) - 0.03));\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - b) - 0.03));\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - c) - 0.03));\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - d) - 0.03));\n\n    // Draw shortest segment between the mouse and curve\n    vec3 nearest = sdCubicBezier(mouse, a, b, c, d).xyz;\n    color = mix(color, vec3(0.0, 1.0, 0.0), smoothstep(unit, 0.0, sdLine(uv, mouse, nearest.xy) - 0.01));\n    color = mix(color, vec3(1.0, 0.8, 0.0), smoothstep(unit, 0.0, length(uv - mouse) - 0.05));\n    color = mix(color, vec3(1.0, 0.8, 0.0), smoothstep(unit, 0.0, length(uv - nearest.xy) - 0.05));\n\n    // Draw the distance minimizing quintic for the mouse position\n    //color = mix(color, vec3(0.0, 0.5, 1.0), smoothstep(unit, 0.0, sdMinimizerPoly(uv, mouse, a, b, c, d) - 0.001));\n    //color = color = mix(color, vec3(0.0), smoothstep(unit, 0.0, length(uv - vec2(nearest.z, 0.0)) - 0.03));\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}