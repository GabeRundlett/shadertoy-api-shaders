{
    "Shader": {
        "info": {
            "date": "1587709458",
            "description": "Foam Noise! Really this is just value noise, rotated to match a corner of the appropriate simplex, and domain-warping the next rotation, averaging all results at the end. It's pretty simple but gives nice results with just one octave.",
            "flags": 0,
            "hasliked": 0,
            "id": "wssBz8",
            "likes": 8,
            "name": "Foam Noise",
            "published": 3,
            "tags": [
                "noise",
                "hash",
                "foam",
                "continuous"
            ],
            "usePreview": 0,
            "username": "TEttinger",
            "viewed": 557
        },
        "renderpass": [
            {
                "code": "// This Shadertoy ( https://www.shadertoy.com/view/wssBz8 ) shows \"Foam Noise\" by Tommy Ettinger.\n// It's just value noise that's rotated and domain warps the next result.\n\n// Based on a Shadertoy: https://www.shadertoy.com/view/4dS3Wd\n// By Morgan McGuire @morgan3d, http://graphicscodex.com\n// Reuse permitted under the BSD license.\n// The improved value noise is also from a Shadertoy: https://www.shadertoy.com/view/MllBRr\n// By afl_ext, public domain.\n\n// For a single octave\n#define NOISE foam\n\n// For multiple octaves\n//#define NOISE fbm\n#define NUM_NOISE_OCTAVES 1\n\nconst highp float pi          = 3.1415926535;\nconst highp float pi2         = 2.0 * pi;\nconst highp float inf         = 1.0 / 0.0;\nfloat square(float x) { return x * x; }\nfloat infIfNegative(float x) { return (x >= 0.0) ? x : inf; }\n\nconst highp float PHI = 1.61803398874989484820459; // (phi = Golden Ratio)\nconst highp vec2 H2 = vec2(1.324717957244746, 1.754877666246693); // harmonious number for 2D, then its square\nconst highp vec3 H3 = vec3(1.8191725134, 1.6710436067, 1.5497004779); // harmonious 3D\n\nfloat bounce(float x) {\n    float y = fract(x);\n    return mix(y, 1.0 - y, step(fract(x * 0.5), 0.5));\n}\n\nvec2 bounce(vec2 x) {\n    vec2 y = fract(x);\n    return mix(y, 1.0 - y, step(fract(x * 0.5), vec2(0.5)));\n}\n\nfloat hash(float seed, float p) {\n    return bounce(fract((p - seed) * PHI + seed) * (PHI - p));\n//    return fract(fract((p - seed) * PHI + seed) * (PHI - p));\n//    return fract((cos(p * seed + PHI) - sin(p * PHI - seed)) * (31.0 + seed));\n//    float f = floor(p);\n//    float start = sin((cos(f * seed) + sin(f * 1024.)) * 345. + seed);\n//    float end   = sin((cos((f+1.) * seed) + sin((f+1.) * 1024.)) * 345. + seed);\n//    return mix(start, end, smoothstep(0., 1., p - f)) * 0.5 + 0.5;\n}\n\n    //////////WIP comments, feel free to ignore\n    //// old, slow\n//    return fract(dot(sin(seed + hm + p), cos(seed + hm * p)));\n//    const float scale = -1.0 / log(2.125);\n    //// thanks mgsx! https://www.mgsx.net/2015/07/21/006-011-fm-3D-WIP.html\n//    return fract(sin(p * 12.9898 + seed) * 43758.5453 - p - seed);\n\n    //    return acos(fract(sin(p * 12.9898 + seed) * 43758.5453 - p - seed) * 2.0 - 1.0) * (1.0 / pi);\n//    return scale * log(fract(sin(p * 12.9898 + seed) * 43758.5453 - seed) + 1.0) + 1.0;\n    //return pow(0.61803, 3.14159 * fract(sin((p+seed) * 12.9898) * 43758.5453 + (p+seed) * 2.6180339887498949));\n//    return pow(0.61803, 3.14159 * fract(sin(p * 12.9898 + seed) * 43758.5453 - p - seed));\n\n\nfloat hash(float seed, vec2 p) {\n/*\n    p = (fract((p - seed) * PHI + seed) * (PHI - p.yx));\n    p = (fract((p.yx - seed) * PHI + seed) * (PHI - p));\n    return bounce(p.x - p.y);\n*/\n    return fract(4768.1232345456 * sin((p.x+p.y*43.0+seed*137.0)));\n\t//return fract(4768.1232345456 * sin((p.x+p.y*43.0+p.z*137.0+p.w*2666.0)));\n}\n//    return fract((dot((p + seed), HAR) + seed) * (0.5 + fract(length(HAR.yx * p - seed))));\n\n    //////////WIP comments, feel free to ignore\n    //return fract(dot((seed * hm + p.xyx), (seed + hm * p.yxy)) * (0.5 - fract(length(p - seed))));\n    //// faster way, seems better-distributed than the 1D noise, thanks again mgsx\n//    return fract(sin(seed + dot(p, vec2(12.9898,78.233))) * 43758.5453 - length(p + seed));\n//    return acos(fract(sin(seed + dot(p, vec2(12.9898,78.233))) * 43758.5453 - length(p + seed)) * 2.0 - 1.0) * (1.0 / pi);\n    //return pow(0.61803, 3.14159 * fract(sin(seed + dot(p, vec2(12.9898,78.233))) * 43758.5453 - seed));\n    //return pow(0.61803, 3.14159 * fract(sin(seed + dot(p, vec2(12.9898,78.233))) * 43758.5453 + length(p - seed)));\n\nhighp float noise(float seed, float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(seed, i), hash(seed, i + 1.0), u);\n}\n\nhighp float noise(float x) {\n    return noise(42.0, x);\n}\n/*\nfloat noise(float seed, vec2 p)\n{    \n    vec2 i = floor(p);\n\tvec2 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(sin(pi*dot(p,g(seed,i+vec2(0.000000,0.000000)))),\n               \t   sin(pi*dot(p,g(seed,i+vec2(1.000000,0.000000)))),f.x),\n               mix(sin(pi*dot(p,g(seed,i+vec2(0.000000,1.000000)))),\n               \t   sin(pi*dot(p,g(seed,i+vec2(1.000000,1.000000)))),f.x),f.y) * 0.5 + 0.5;\n}\n*/\nhighp float noise(float seed, vec2 x) {\n/*    x.x -= seed;\n    x.y += seed;\n    x *= 0.125;\n    vec2 y = bounce(x.yx + H2);\n    y += (bounce(x * H2 + seed) * (PHI - y));\n    //y -= (bounce(x * H2 - seed) * (PHI - y));\n    return bounce(y.x - y.y + 0.5);\n//    return sin(pi * (y.x - y.y)) * 0.5 + 0.5;\n*/\n/*\n    vec2 y = sin(x * H2) * pi2;\n    y += cos(y * H2 - x.yx);\n    return sin(pi2 * ((y.x - y.y + 0.5) + (PHI + sin((x.y - x.x - 0.5) * pi2)))) * 0.5 + 0.5;\n*/    \n//    const highp vec2 step = vec2(43.0, 59.0);\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(seed, i);\n    float b = hash(seed, i + vec2(1.0, 0.0));\n    float c = hash(seed, i + vec2(0.0, 1.0));\n    float d = hash(seed, i + vec2(1.0, 1.0));\n/*\n    float n = dot(i, step);\n\n    float a = hash(seed, n);\n    float b = hash(seed, n + dot(step, vec2(1.0, 0.0)));\n    float c = hash(seed, n + dot(step, vec2(0.0, 1.0)));\n    float d = hash(seed, n + dot(step, vec2(1.0, 1.0)));\n*/\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nhighp float noise(vec2 x) {\n    return noise(42.0, x);\n}\n\n\nhighp float noise(float seed, vec3 x) {\n    const highp vec3 step = vec3(59.0, 43.0, 37.0);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(seed, n                              ), hash(seed, n + dot(step, vec3(1., 0., 0.))), u.x),\n                   mix( hash(seed, n + dot(step, vec3(0., 1., 0.))), hash(seed, n + dot(step, vec3(1., 1., 0.))), u.x), u.y),\n               mix(mix( hash(seed, n + dot(step, vec3(0., 0., 1.))), hash(seed, n + dot(step, vec3(1., 0., 1.))), u.x),\n                   mix( hash(seed, n + dot(step, vec3(0., 1., 1.))), hash(seed, n + dot(step, vec3(1., 1., 1.))), u.x), u.y), u.z);\n}\n\nhighp float noise(vec3 x) {\n    return noise(42.0, x);\n}\n\nhighp float foam(float seed, float x) {\n    return noise(seed, x);\n}\n\nhighp float foam(float x) { return foam(61.0, x); }\n\nhighp float foam(float seed, vec2 x) {\n    highp vec3 p = vec3(x.x, dot(x, vec2(-0.5, 0.8660254037844386)), dot(x, vec2(-0.5, -0.8660254037844386)));\n    float a = noise(seed, p.yz);\n    float b = noise(seed + 1.0, p.xz + a * 0.5);\n    float c = noise(seed + 2.0, p.xy + b * 0.5);\n    return smoothstep(0.0, 1.0, (a + b + c) * (1.0 / 3.0));\n}\n\nhighp float foam(vec2 x) { return foam(61.0, x); }\n\nhighp float foam(float seed, vec3 x) {\n    highp vec4 p = vec4(x.x, \n                  dot(x.xy, vec2(-0.3333333333333333, 0.9428090415820634)),\n                  dot(x, vec3(-0.3333333333333333, -0.4714045207910317, 0.816496580927726)),\n                  dot(x, vec3(-0.3333333333333333, -0.4714045207910317, -0.816496580927726)));\n    float a = noise(seed, p.yzw);\n    float b = noise(seed + 42.0, p.xzw + a * 0.5);\n    float c = noise(seed + 84.0, p.xyw + b * 0.5);\n    float d = noise(seed + 126.0, p.xyz + c * 0.5);\n    return smoothstep(0.0, 1.0, \n           smoothstep(0.0, 1.0, (a + b + c + d) * 0.25)\n           );\n}\n\nhighp float foam(vec3 x) { return foam(61.0, x); }\n\nfloat fbm(float x) {\n\tfloat v = 0.0;\n\tfloat a = 0.6666;\n\tfloat seed = 61.0;\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * foam(seed, x);\n        seed += 42.0;\n\t\tx = x * 2.0 + seed;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.6666;\n\tfloat seed = 61.0;\n\t// Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * foam(seed, x);\n        seed += 42.0;\n\t\tx = rot * x * 2.0 + seed;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.6666;\n\tfloat seed = 61.0;\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * foam(seed, x);\n        seed += 42.0;\n\t\tx = x * 2.0 + seed;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Visualization:\n\n// C = sphere center, r = sphere radius, P = ray origin, w = ray direction\nfloat  intersectSphere(vec3 C, float r, vec3 P, vec3 w) {\t\n\tvec3 v = P - C;\n\tfloat b = -dot(w, v);\n\tfloat c = dot(v, v) - square(r);\n\tfloat d = (square(b) - c);\n\tif (d < 0.0) { return inf; }\t\n\tfloat dsqrt = sqrt(d);\n\t\n\t// Choose the first positive intersection\n\treturn min(infIfNegative((b - dsqrt)), infIfNegative((b + dsqrt)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\thighp float v = 0.0;\n\t\n\t// Visualize 1D, 2D, and 3D\n\tif (fragCoord.y > iResolution.y / 2.0) {\n\t\tif (fragCoord.x < iResolution.x / 2.0) {\n\t\t\t// 1D\n\t\t    float coord = fragCoord.x * 0.05 + iTime * 5.0 - 10.0;\n\t\t\tfloat height = NOISE(coord) * iResolution.y / 2.0;\n\t\t\tv = clamp((height - fragCoord.y + iResolution.y / 2.0) / (iResolution.y * 0.02), 0.0, 1.0);\n\t\t} else if (fragCoord.x < iResolution.x / 2.0 + 1.0) {\n\t\t\tfragColor.rgb = vec3(1.0);\n\t\t\treturn;\n\t\t} else {\n\t\t\t// 2D\n\t\t\tvec2 coord = fragCoord.xy * 0.125 - vec2(iTime * 5.0, iResolution.y * 0.5);\n\t\t\tv = NOISE(coord);\n\t\t}\n\t} else if (fragCoord.y > iResolution.y / 2.0 - 1.0) {\n\t\tfragColor.rgb = vec3(1.0);\n\t\treturn;\n\t} else {\n\t\t// Ray-sphere\n\t\tconst float verticalFieldOfView = 25.0 * pi / 180.0;\n\t\t\t\n\t    vec3 P = vec3(sin(iTime) * 2.0, 0, 5.0);\n\t\tvec3 w = normalize(vec3(fragCoord.xy - iResolution.xy / vec2(2.0, 4.0), \n\t\t\t\t\t\t\t\t(iResolution.y / 2.0) / (-2.0 * tan(verticalFieldOfView / 2.0))));\n\n\t\tfloat t = min(intersectSphere(vec3(0, 0, 0), 1.0, P, w),\n\t\t\t\t\t  intersectSphere(vec3(0, -2000, 0), 2000.0 - 1.0, P, w));\n\t\tif (t < inf) {\n\t\t\tvec3 X = P + w * t;\n\t\t\t// Fake lighting to make surfaces appear nicely\n\t\t\tv = NOISE(X * 10.0) * clamp(X.y * 0.75 + 1.0 - min(X.z * 0.05, 0.0), 0.0, 1.0) + \n\t\t\t\tclamp((length(X.xz) - 0.75) * 0.15, 0.0, 0.1);\n\t\t} else {\n\t\t\t// Background\n\t\t\tv = 0.5;\n\t\t}\n\t}\n\n    fragColor.rgb = vec3(v);\n//    fragColor.rgb = vec3(pow(v, 0.375));\n//    fragColor.rg += foam(1999.0, fragCoord.xy * 0.25) * 0.0625;\n//    fragColor.g += foam(97.0, fragCoord.xy * 0.375) * 0.0625;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}