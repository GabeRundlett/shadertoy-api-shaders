{
    "Shader": {
        "info": {
            "date": "1520747332",
            "description": "getting CSG going",
            "flags": 0,
            "hasliked": 0,
            "id": "XdycRz",
            "likes": 2,
            "name": "hungry cube",
            "published": 3,
            "tags": [
                "raymarching",
                "csg"
            ],
            "usePreview": 0,
            "username": "expertmouser",
            "viewed": 454
        },
        "renderpass": [
            {
                "code": "\nvec4 oColor;\nvec2 vTexcoord;\nfloat iAspect;\n\n//-----------------------------------------------------------\n\n\nfloat myTime = 0.0;\n\nconst float kMaxFloat = 1000000000.; // lol\n\nconst float maxDist  = 4.0;\n\nconst float floorAmt    = -0.02;\nconst float floorHeight = 3.0;\n\nconst float MYPI = 3.14159265359;\nconst float degToRad = MYPI * 2.0 / 360.0;\nconst float radToDeg = 360.0 / MYPI / 2.0;\n\nvec3 rotZ(vec3 v, float radians) {\n  float c = cos(radians);\n  float s = sin(radians);\n  return vec3( v.x * s - v.y * c,\n               v.x * c + v.y * s,\n               v.z);\n}\n\nvec3 rotY(vec3 v, float radians) {\n  float c = cos(radians);\n  float s = sin(radians);\n  return vec3( v.x * s - v.z * c,\n               v.y,\n               v.x * c + v.z * s);\n}\n\nvec2 msdfUnion(vec2 A, vec2 B) {\n  return A.x < B.x ? A : B;\n}\n\nvec2 msdfInter(vec2 A, vec2 B) {\n  return A.x > B.x ? A : B;\n}\n\nvec2 msdfMinus(vec2 A, vec2 B) {\n  return A.x > -B.x ? A : -B;\n}\n\n// cube of \"radius\" 1.\n// a sphere of radius 1 fits inside.\nfloat sdfCube(vec3 p) {\n  const float radius = 0.5;\n  float distxn  =  -p.x - radius;\n  float distxp  =   p.x - radius;\n  float distyn  =  -p.y - radius;\n  float distyp  =   p.y - radius;\n  float distzn  =  -p.z - radius;\n  float distzp  =   p.z - radius;\n\n  float distx   = max(distxn, distxp);\n  float disty   = max(distyn, distyp);\n  float distz   = max(distzn, distzp);\n\n  float distxy  = max(distx , disty);\n  float distxyz = max(distxy, distz);\n\n  return distxyz;\n}\n\nfloat sdfSphere(vec3 p) {\n  return length(p) - 1.0;\n}\n\nfloat sdfModSphere(vec3 p) {\n  return sdfSphere(fract(p / 3.0));\n}\n\nfloat sdfWarpSphere(vec3 p) {\n  float f = myTime * 0.1;\n  vec3 q = p;\n  const float overallDistortionMagnitude = 0.1;\n  const float mag2 = .2;\n  const float freq = 20.;\n  float mag = sin(myTime * 0.1) * overallDistortionMagnitude;\n  q.x += cos(p.z         * mag * 0.9 + f) * 0.1;\n  q.y += sin(p.z         * mag * 0.8 + f) * 0.1;\n  q.z += sin((p.x * p.y) * mag * 1.0 + f * 10.) * 0.1;\n  float dx = sin(p.z * freq) * mag2;\n  float dy = sin(p.x * freq) * mag2;\n  float dz = sin(p.y * freq) * mag2;\n  dx *= dx * dx * dx;\n  dy *= dy * dy * dy;\n  dz *= dz * dz * dz;\n  q.x += dx;\n  q.y += dy;\n  q.z += dz;\n  return length(q) - 0.75;\n}\n\nvec2 msdfSceneSingle(vec3 p) {\n  vec2 ret = vec2(sdfCube(p), 1.0);\n  return ret;\n}\n\nvec2 msdfScene(vec3 pt) {\n  // return sdfSceneSingle(pt);\n  pt = rotZ(pt, myTime * 0.11);\n  pt = rotY(pt, myTime * 0.13);\n\n\n  // return vec2(sdfModSphere(pt), 8.0);\n\n  vec2 c1 = vec2(sdfCube(pt), 3.0);\n  pt = rotY(pt, myTime * 0.321);\n  pt = rotZ(pt, myTime * 0.4321);\n  const float orbit = 0.65;\n  const float orbitSpeed = 0.5;\n  vec3 p2 = vec3(\n    sin(myTime * orbitSpeed * 1.0),\n    sin(myTime * orbitSpeed * 1.0),\n    sin(myTime * orbitSpeed * 1.1)\n  ) * orbit;\n  vec2 c2 = vec2(sdfSphere((pt + p2) * 3.0) / 3.0, 2.0);\n  vec2 d3 = msdfMinus(c1, c2);\n  d3 = msdfInter(d3, vec2(sdfSphere(pt * 1.42) / 1.42, 5.0));\n  d3 = msdfMinus(d3, vec2(sdfSphere(pt * 1.65) / 1.65, 7.0));\n  d3 = msdfUnion(d3, vec2(sdfCube(rotY((pt + p2) * 8.0, myTime * 2.0)) / 8.0, 6.0));\n  return d3;\n}\n\nvec3 sdfNormal(vec3 p) {\n  const float epsilon = 0.001;\n  vec3 v = vec3(\n    msdfScene(vec3(p.x + epsilon, p.y, p.z)).x - msdfScene(vec3(p.x - epsilon, p.y, p.z)).x,\n    msdfScene(vec3(p.x, p.y + epsilon, p.z)).x - msdfScene(vec3(p.x, p.y - epsilon, p.z)).x,\n    msdfScene(vec3(p.x, p.y, p.z + epsilon)).x - msdfScene(vec3(p.x, p.y, p.z - epsilon)).x\n  );\n\n  return normalize(v);\n}\n\nbool approximatelyEqualEps(float a, float b, float epsilon) {\n  float d = abs(a - b);\n  return d < epsilon ? true : false;\n}\n\nbool approximatelyEqual(float a, float b) {\n  const float epsilon = 0.0001;\n  return approximatelyEqualEps(a, b, epsilon);\n}\n\n// todo: generalize to any plane\nvec3 intersectRayXZPlane(vec3 pt, vec3 dir) {\n  if (approximatelyEqual(dir.y, 0.)) {\n    return vec3(kMaxFloat, 0, kMaxFloat);\n  }\n\n  float s = pt.y / dir.y;\n  return pt + dir * s;\n}\n\nfloat subfloor(vec3 groundPt) {\n  groundPt = rotY(groundPt, 45.0 * degToRad);\n  groundPt += vec3(\n    sin(myTime * 0.12  ) * 10.,\n    1,\n    sin(myTime * 0.1211) * 10.\n  );\n  float f = sin(groundPt.x * 1.2) * sin(groundPt.z * 1.2);\n  f *= f * f;\n  return f * 1.9 + 1.5;\n}\n\nfloat floorCheck(vec3 pt, vec3 rayDir) {\n  rayDir = rotY(rayDir, myTime * 0.031);\n  vec3 floorOffset = vec3(0, floorHeight, myTime * -4.1);\n  vec3 groundPt = intersectRayXZPlane(pt + floorOffset, rayDir);\n  float f = sin(groundPt.x) + sin(groundPt.z) - sin(myTime * 0.51) * 0.8;\n  float rf;\n  if (approximatelyEqualEps(f, 0., 0.07)) {\n    rf = 0.18;\n  }\n  else if (f < 0.) {\n    rf = 0.12;\n  }\n  else {\n    rf = subfloor(groundPt) * 0.1;\n  }\n\n  return rf;\n}\n\nvoid otherMain(void)\n{\n  vec3  lightDir = normalize(vec3(iMouse.x / iResolution.x * 2.0 - 1.0, iMouse.y / iResolution.y * 2.0 - 1.0, -0.2));\n\n  lightDir = normalize(vec3(\n    cos(myTime * 1.13) * 2.0,\n    sin(myTime * 1.13) * 2.0,\n    sin(myTime * 0.5 ) * 1.2));\n\n  vec3  camPos = vec3(0, 0, -4.0);\n  float screenDist = 3.0;\n\n  vec2 tmp = vTexcoord * 2.0 - 1.0;\n  vec3 pxlPos;\n  if (iAspect > 1.0) {\n    pxlPos = vec3(tmp.x * iAspect, tmp.y, camPos.z + screenDist);\n  }\n  else {\n    pxlPos = vec3(tmp.x, tmp.y / iAspect, camPos.z + screenDist);\n  }\n\n  const float zoom = 0.75;\n  pxlPos.x *= zoom;\n  pxlPos.y *= zoom;\n\n  vec3 rayDir = normalize(pxlPos - camPos);\n\n  float maxZ = pxlPos.z + maxDist;\n\n  vec3 pt = pxlPos;\n\n  float finalDist;\n\n  int steps = 0;\n\n  bool hitSomething = false;\n\n  const float skyBrightness = 0.2;\n\n  oColor = vec4(skyBrightness);\n\n  while (length(pt) < maxZ) {\n    vec2 sdf = msdfScene(pt);\n    finalDist = sdf.x;\n    if (finalDist <= 0.0001) {\n      hitSomething = true;\n      vec3  n = sdfNormal(pt);\n      float d = dot(n, lightDir);\n      vec3 refl = reflect(rayDir, n);\n      float edgeness = 1. - abs(dot(n, rayDir));\n      float rf = 0.;\n      if (refl.y < floorAmt) {\n        rf = floorCheck(pt, refl) * 0.96;\n      }\n      oColor = vec4 (\n        d,\n        d,\n        d,\n        1.0\n      );\n      // oColor = vec4(\n      //   (sin(sdf.w * 60.) * 0.2 + 0.7) * d,\n      //   (sin(sdf.x * 80.) * 0.2 + 0.7) * d,\n      //   (sin(sdf.y * 60.) * 0.2 + 0.6) * d,\n      //   1.0);\n      // oColor = vec4(\n      //   max(oColor.x, rf),\n      //   max(oColor.y, rf),\n      //   max(oColor.z, rf),\n      //   1\n      // );\n      oColor.xyz += rf;\n\n      oColor *= vec4(\n        sdf.y == 5.0 ? 0.5 : 1.0,\n        sdf.y == 3.0 ? 0.5 : 1.0,\n        sdf.y / 3.0,\n        1.0\n      );\n\n      float e = edgeness;\n      // e = e * e * e * e;\n      // e = e * e;\n      // oColor -= vec4(e);\n      break;\n    }\n    const float minStep = 0.0001;\n    float step = max(finalDist, minStep);\n    // pt.z += step;\n    pt += rayDir * step;\n  }\n\n  if (!hitSomething) {\n    if (rayDir.y < floorAmt) {\n      float rf = floorCheck(camPos, rayDir);\n      oColor = vec4(rf, rf, rf, 1);\n\n    }\n  }\n}\n\n\n\n//-----------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    iAspect     = iResolution.x / iResolution.y;\n    myTime      = iTime;\n    vTexcoord = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    otherMain();\n    fragColor = oColor;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}