{
    "Shader": {
        "info": {
            "date": "1635163502",
            "description": "Extruded pixelated spiral",
            "flags": 0,
            "hasliked": 0,
            "id": "fsGXzG",
            "likes": 53,
            "name": "Extruded Pixelated Spiral",
            "published": 3,
            "tags": [
                "grid",
                "pixel",
                "spiral",
                "design",
                "extrude"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 861
        },
        "renderpass": [
            {
                "code": "/*\n\n    Extruded Pixelated Spiral\n    -------------------------\n\n\tOn Shadertoy I often come across very simple 2D examples that I like.\n    Sometimes, if I think the base pattern is interesting enough, I might\n    extrude it just to see what it looks like. Extruded imagery is a bit\n    of a computer graphics cliche, but I like it.\n    \n    This particular image is loosely based on a minimal spiral image by\n    Foxic -- The link is below, for anyone interested. To adhere to the \n    spirit of the original, I've extruded it in a pixelized manner and kept \n    roughly the same palette. However, it looks pretty interesting in other \n    colors too.\n    \n    Technically, there's not a lot to this. Hopefully, it'll run fine on\n    most systems. It'd be a lot more efficient to render the 2D spiral on\n    a backbuffer first, but I wanted to keep things simple.\n    \n\n\n\tInspired by:\n    \n\t// I like the minimal design.\n    Pixelized IceCreamSwirl - foxic\n\thttps://www.shadertoy.com/view/NdVXWz\n    \n    // Tater's been putting up some pretty nice shaders lately.\n    Spiraled Layers - Tater\n    https://www.shadertoy.com/view/Ns3XWf\n\n\n*/\n\n\n// Global tile scale.\nvec2 scale = vec2(1./8., 1./8.);\n\n// Off the rows by half a cell to produce a brickwork feel. The staggered \n// effect can also make a quantized image look smoother.\n#define ROW_OFFSET\n\n// Use hexagon pylons instead of squares.\n//#define HEXAGON\n\n// Boring out holes on alternate blocks to give it more of a tech feel and\n// to provide a little extra visual stimuli. Without the holes, the image\n// looks cleaner, but less interesting, I feel.\n#define HOLES\n\n// Raising the faces of the pylon tops. I find it can help bounce the light \n// off the surface in a more reflective way.\n//#define RAISED\n\n// Putting a ridge decoraction on the pylon tops.        \n//#define RIDGES\n\n\n// The hexagons must use offset rows.\n#ifdef HEXAGON\n#ifndef ROW_OFFSET\n#define ROW_OFFSET\n#endif\n#endif\n\n// Max ray distance.\n#define FAR 20.\n\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n// Height map value.\nfloat hm(in vec2 p){ \n\n    \n    // Render the swirl by adding polar coordinates. You can apply the logarithm to\n    // the length for a different kind of feel, but I'll leave it in its current form.\n    float swirl = fract(atan(p.y, p.x)/6.2831 + length(p)*1.25 - iTime/4.);\n    \n    /*\n    // Alternative square or octagon swirl -- Other metrics are also possible.\n    vec2 ap = abs(p);\n    float shp = max(ap.x, ap.y);\n    //float shp = max(max(ap.x, ap.y), (ap.x + ap.y)*.7071);\n    float swirl = fract(atan(p.y, p.x)/6.2831 + shp*1.5 - iTime/4.);\n    */\n\n    //swirl = abs(swirl - .5)*2.; swirl = smoothstep(.15, .85, swirl);\n    swirl = sin(swirl*6.2831)*.5 + .5;\n    \n    \n    // In the form above, the height transitions between zero and one.\n    // The following simply manipulates the way in which that happens.\n    \n    // Number of quantization levels.\n    #define lNum 4.\n    float iswirl = floor(swirl*lNum*.9999)/lNum;\n\n    // Arrange for the pylons to smoothly transition between quantization\n    // levels whilst honoring the pixelated look... I could have described\n    // that better, but hopefully, you know what I mean. :D\n    return mix(iswirl, iswirl + 1./lNum, smoothstep(0., 1., swirl));\n    // Popping unnaturally from one state to the next.\n    //return iswirl*lNum/(lNum - 1.); \n    // Continuous, smooth motion.\n    //return swirl; \n    \n    \n}\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .015;\n    vec2 w = vec2( sdf, abs(pz) - h - sf/2.);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w + sf, 0.)) - sf;\n    */\n}\n\n#ifdef HEXAGON\n// Signed distance to a regular hexagon, with a hacky smoothing variable thrown\n// in. -- It's based off of IQ's more exact pentagon method.\nfloat sHexS(in vec2 p, float r, in float sf){\n    \n    \n      const vec3 k = vec3(-.8660254, .5, .57735); // pi/6: cos, sin, tan.\n     \n      // X and Y reflection.  \n      p = abs(p); \n      p -= 2.*min(dot(k.xy, p), 0.)*k.xy;\n\n      r -= sf;\n      // Polygon side.\n      return length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r) - sf;\n    \n}\n#endif\n\n/*\n// IQ's unsigned box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n*/\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n\n \n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed square pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n\nvec4 blocks(vec3 q3){\n    \n    \n\n    // Brick dimension: Length to height ratio with additional scaling.\n    vec2 l = scale;\n\tvec2 s = scale*2.;\n    #ifdef HEXAGON\n    vec2 hSc = vec2(1, scale.y/scale.x*2./1.732);\n    #endif\n    \n    float minSc = min(scale.x, scale.y);\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0); \n    \n    // Four block corner postions.\n    #ifdef ROW_OFFSET\n    // Offset rows.\n    vec2[4] ps4 = vec2[4](vec2(-.25, .25), vec2(.25), vec2(.5, -.25), vec2(0, -.25)); \n    #else\n    vec2[4] ps4 = vec2[4](vec2(-.25, .25), vec2(.25), vec2(.25, -.25), vec2(-.25)); \n    #endif\n    \n    float data = 0.; // Extra data.\n    \n    for(int i = min(0, iFrame); i<4; i++){\n\n\n        // Local coordinates.\n        p = q3.xy;\n        ip = floor(p/s - ps4[i]) + .5; // Local tile ID.\n        \n        // Correct positional individual tile ID.\n        vec2 idi = (ip + ps4[i])*s;\n        \n        p -= idi; // New local position.\n\n\n        // The extruded block height. See the height map function, above.\n        float h = hm(idi);\n        \n        h *= .1;\n            \n         \n        #ifdef HEXAGON\n        // Hexagon option: Multiply scale by \"vec2(1, 1.732/2.),\"\n        // and have the ROW_OFFSET define turned on.\n        float di2D = sHexS(p.yx, minSc/1.732 - .008, .02);\n        #else\n        float di2D = sBoxS(p, l/2. - .008, .02);        \n        //float di2D = length(p) - l.x/2. + .004;\n        #endif\n        \n        \n        #ifdef HOLES\n        // Boring out some of the boxes.\n        if((i&1)==0) di2D = max(di2D, -(di2D + minSc/4.));\n        #endif\n        \n        // The extruded distance function value.\n        float di = opExtrusion(di2D, (q3.z + h - .5), h + .5);\n        \n        \n        #ifdef RAISED\n        // Raised tops.\n        di += di2D*.25;\n        #endif\n        \n        #ifdef RIDGES\n        // Putting ridges on the faces.\n        di += sin(di2D/minSc*6.2831*3.)*.005;\n        #endif\n        \n        /*\n        // Lego.\n        float cap = length(p) - scale.x/4.;\n        cap = opExtrusion(cap, (q3.z + h - .5 + .035), h + .5);\n        di = min(di, cap); //di = max(di, -cap)\n        */\n        \n        \n\n        // If applicable, update the overall minimum distance value,\n        // ID, and box ID. \n        if(di<d){\n            d = di;\n            id = idi;\n            // Extra data. In this case, the 2D distance field.\n            data = di2D;\n        }\n        \n    }\n    \n    // Return the distance, position-base ID and box ID.\n    return vec4(d, id, data);\n}\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec4 gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor.\n    float fl = -p.z + .1;\n\n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4; // Individual block ID.\n    \n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded object.\n    return  min(fl, d4.x);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = min(0, iFrame); i<96; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        t += d*.7; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    //const vec2 e = vec2(.001, 0);\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n     \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not always affordable. :)\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015; // Coincides with the hit condition in the \"trace\" function.  \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, \n    // the lowest number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += clamp(d, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    #ifdef HEXAGON\n    scale *= vec2(2./1.732, 1);\n\t#endif\n    \n\t// Camera Setup.\n    // Tilted camera, just to prove it's 3D. :)\n\t//vec3 ro = vec3(0, -1.3, -2.2); // Camera position, doubling as the ray origin.\n\t//vec3 lk = ro + vec3(0, .12, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n\t// Front on camera.\n    vec3 ro = vec3(0, 0, -2.2); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, 0, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(-.25, .5, 1);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.333; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera about the XY-plane.\n\trd.xy *= rot2( sin(iTime)/32. );\n    \n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block field value, block ID and 2D data field value.\n    vec4 svGID = gID;\n    \n    float svObjID = objID;\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n        vec3 sn = getNormal(sp, t);\n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        //sh = min(sh + ao*.25, 1.);\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 2.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough. \n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol = vec3(.6);   \n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n            float h = hm(svGID.yz);\n            \n            //texCol = mix(vec3(.05), vec3(1), h); // White.\n            texCol = mix(vec3(.05), vec3(1.4, .2, .6), h); // Pink.\n            //texCol = mix(vec3(.05), vec3(.5, 1, .25), h); // Green.\n            //texCol = mix(vec3(.05), vec3(.25, .7, 1.5), h); // Blue.\n            //texCol = mix(vec3(.05), mix(vec3(1.4, .2, .6), vec3(2, .3, .3), diff*diff*1.5), h);\n            \n            // Extra blending options.\n            //texCol = mix(texCol, texCol.xzy, h);\n            //texCol = mix(texCol, texCol.zyx, clamp((ld.y - ld.x) - .5, 0., 1.));\n            //texCol = mix(texCol.zyx, texCol, diff*diff*1.5);\n             \n            \n            /*\n            // Dark edges.\n            //vec2 lCoord = sp.xy - svGID.yz;\n            vec2 sc = scale;\n            float lw = .006;\n            float dS = abs(svGID.w) - lw; // 2D face field value.\n            //texCol = mix(texCol, min(texCol.xzy*1.35 + .1, 1.), (1. - smoothstep(0., .005, dS + lw)));\n            dS = max(dS, abs(sp.z + h*.1*2.) - lw/2.); // Just the rim.\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., .005, dS))*.8);\n            */\n \n        }\n        else {\n            \n            // The dark floor in the background. Hidden behind the pylons, but\n            // you still need it.\n            texCol = vec3(0);\n        }\n       \n\n        \n        // Combining the above terms to produce the final color.\n        col = texCol*(diff*sh + .3 + vec3(.25, .5, 1)*fre*0. + vec3(1, .97, .92)*spec*freS*2.*sh);\n      \n        // Shading.\n        col *= ao*atten;\n        \n          \n\t\n\t}\n          \n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}