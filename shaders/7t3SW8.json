{
    "Shader": {
        "info": {
            "date": "1638990293",
            "description": "Just some more noodling with dispersion",
            "flags": 0,
            "hasliked": 0,
            "id": "7t3SW8",
            "likes": 179,
            "name": "Shuffle box",
            "published": 3,
            "tags": [
                "refraction",
                "dispersion"
            ],
            "usePreview": 1,
            "username": "tdhooper",
            "viewed": 3618
        },
        "renderpass": [
            {
                "code": "\n#if HW_PERFORMANCE==1\n    const float MAX_DISPERSE = 10.;\n    const float MAX_BOUNCE = 5.;\n#else\n    const float MAX_DISPERSE = 5.;\n    const float MAX_BOUNCE = 5.;\n#endif\n\n//#define ALTERNATIVE\n//#define ALTERNATIVE2\n\n\n\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n\n#define PI 3.14159265359\n\n#define saturate(x) clamp(x, 0., 1.)\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smax(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat fBox(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat sdLine( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n// Spectrum palette\n// IQ https://www.shadertoy.com/view/ll2GD3\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n//========================================================\n// Modelling\n//========================================================\n\n\nfloat time;\n\nfloat invertg;\n\nfloat sin3(vec3 v) {\n    return sin(v.x) * sin(v.y) * sin(v.z);\n}\n\nvec2 map(vec3 p) {\n\n    float scl = 1.3;\n    p /= scl;\n\n    pR(p.yz, .2 * PI);\n    pR(p.xz, -.25 * PI);\n    \n    float flr = p.y+.5;\n    \n    #ifdef ALTERNATIVE\n    p += sin(p * 08. + (time * vec3(-1,-1,-1) + vec3(0,.5,.75)) * PI * 2.) * .1;\n    #else \n    p += sin(p * 08. + time * vec3(1,3,2) * PI * 2. + vec3(0,.5,3)) * .1;\n    #endif\n    // p += sin(p * 07. + (time * vec3(-1,1,1) + vec3(0)) * PI * 2.) * .1;\n\n    vec3 p2 = p;\n    \n    p += sin3(p * 80.) * .0015;\n    \n    float b = length(p) - .66;\n    b = fBox(p, vec3(.5 - .01)) - .01;\n    \n    float d3 = 1e12;\n    float rr = .0025;\n    p2 = abs(p2);\n    p2 = vec3(vmin(p2.xz), p2.y, vmax(p2.xz));\n    d3 = min(d3, sdLine(p2.xzy - vec3(.5,.7,.5), .2, rr));\n    d3 = max(d3, -vmax(p*vec3(1,-1,-1)));\n\n    #ifdef ALTERNATIVE\n    float e = .1;\n    p.x += sin(p.x * 04. + (time * -1. + .0) * PI * 2.) * e;\n    p.z += sin(p.z * 04. + (time * -1. + sign(p.x) * .25 + .25) * PI * 2.) * e;\n    p.y += sin(p.y * 04. + (time * -1. + sign(p.z) * .25) * PI * 2.) * e;\n    #else\n    p += sin(p * 06. + time * vec3(-3,2,1) * PI * 2. * 1. + vec3(.1,.5,.6)) * .1;\n    #endif\n\n    b = smax(b, -vmin(abs(p)) + .0125, .01);\n\n    float d2 = b + .1;\n    \n    float d = max(b, -d2 + .01);\n    \n    d *= invertg;\n    \n    d2 = max(d2+.001, b);\n    \n    float id = 1.;\n    \n    if (d2 < d) \n    {\n        id = 3.;\n        d = d2;\n    }\n    \n    #ifndef ALTERNATIVE2\n    if (d3 < d) {\n        d = d3;\n        id = 4.;\n    }\n    #endif\n   \n    d *= scl;\n    return vec2(d, id);\n}\n\n//========================================================\n// Lighting\n//========================================================\n\nvec3 BGCOL = vec3(.86,.8,1);\n\nfloat intersectPlane(vec3 rOrigin, vec3 rayDir, vec3 origin, vec3 normal, vec3 up, out vec2 uv) {\n    float d = dot(normal, (origin - rOrigin)) / dot(rayDir, normal);\n  \tvec3 point = rOrigin + d * rayDir;\n\tvec3 tangent = cross(normal, up);\n\tvec3 bitangent = cross(normal, tangent);\n    point -= origin;\n    uv = vec2(dot(tangent, point), dot(bitangent, point));\n    return max(sign(d), 0.);\n}\n\nmat3 envOrientation;\n\nvec3 light(vec3 origin, vec3 rayDir) {\n    origin = -origin;\n    rayDir = -rayDir;\n\n    origin *= envOrientation;\n    rayDir *= envOrientation;\n\n    vec2 uv;\n    vec3 pos = vec3(-6);\n    float hit = intersectPlane(origin, rayDir, pos, normalize(pos), normalize(vec3(-1,1,0)), uv);\n    float l = smoothstep(.75, .0, fBox(uv, vec2(.5,2)) - 1.);\n    l *= smoothstep(6., 0., length(uv));\n\treturn vec3(l) * hit;\n}\n\nvec3 env(vec3 origin, vec3 rayDir) {    \n    origin = -(vec4(origin, 1)).xyz;\n    rayDir = -(vec4(rayDir, 0)).xyz;\n\n    origin *= envOrientation;\n    rayDir *= envOrientation;\n\n    float l = smoothstep(.0, 1.7, dot(rayDir, vec3(.5,-.3,1))) * .4;\n   \treturn vec3(l) * BGCOL;\n}\n\n\n//========================================================\n// Marching\n//========================================================\n\n#define ZERO (min(iFrame,0))\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal( in vec3 pos )\n{\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e).x;\n    }\n    return normalize(n);\n}\n\nstruct Hit {\n    vec2 res;\n    vec3 p;\n    float len;\n    float steps;\n};\n\nHit march(vec3 origin, vec3 rayDir, float invert, float maxDist, float understep) {\n    vec3 p;\n    float len = 0.;\n    float dist = 0.;\n    vec2 res = vec2(0.);\n    vec2 candidate = vec2(0.);\n    float steps = 0.;\n    invertg = invert;\n\n    for (float i = 0.; i < 800.; i++) {\n        len += dist * understep;\n        p = origin + len * rayDir;\n        candidate = map(p);\n        dist = candidate.x;\n        steps += 1.;\n        res = candidate;\n        if (dist < .00005) {\n            break;\n        }\n        if (len >= maxDist) {\n            len = maxDist;\n            res.y = 0.;\n            break;\n        }\n    }   \n\n    return Hit(res, p, len, steps);\n}\n\nmat3 sphericalMatrix(vec2 tp) {\n    float theta = tp.x;\n    float phi = tp.y;\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(\n        cy, -sy * -sx, -sy * cx,\n        0, cx, sx,\n        sy, cy * -sx, cy * cx\n    );\n}\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\n// Hex tiling, FabriceNeyret2\n// https://www.shadertoy.com/view/4dKXR3\nfloat hex(vec2 U) { \n    \n    U *= mat2(1,-1./1.73, 0,2./1.73) *5.;      // conversion to\n    vec3 g = vec3(U,1.-U.x-U.y), g2,           // hexagonal coordinates\n        id = floor(g);                         // cell id\n\n    g = fract(g);                              // diamond coords\n    if (length(g)>1.) g = 1.-g;                // barycentric coords\n    g2 = abs(2.*fract(g)-1.);                  // distance to borders\n    // length(g2)     = distance to center  \n    return length(1.-g2);\n\n}\n\n// http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 tonemap2(vec3 texColor) {\n    texColor /= 2.;\n   \ttexColor *= 16.;  // Hardcoded Exposure Adjustment\n   \tvec3 x = max(vec3(0),texColor-0.004);\n   \treturn (x*(6.2*x+.5))/(x*(6.2*x+1.7)+0.06);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef ALTERNATIVE\n    float duration = 4.;\n    #else\n    float duration = 8.;\n    #endif\n    time = mod(iTime / duration + .1, 1.);\n    //time= 0.;\n    \n    envOrientation = sphericalMatrix(((vec2(81.5, 119) / vec2(187)) * 2. - 1.) * 2.);\n\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    #ifdef ALTERNATIVE2\n    uv /= 3.;\n    #endif\n    \n    #ifdef ALTERNATIVE\n    float h = hex(uv.yx * 1.08 + time * vec2(.1,.172) * -2.);\n    #else\n    float h = hex(uv.yx * 1.08 + time * vec2(.1,.172) * 2.);\n    #endif\n    h -= .03;\n    h /= length(fwidth(uv * 10.));\n    h = 1. - saturate(h);\n\n    Hit hit, firstHit;\n    vec2 res;\n    vec3 p, rayDir, origin, sam, ref, raf, nor, camOrigin, camDir;\n    float invert, ior, offset, extinctionDist, maxDist, firstLen, bounceCount, wavelength;\n    \n    vec3 col = vec3(0);\n\n    vec3 bgCol = BGCOL * .08 * .5;\n    vec3 bgCol2 = bgCol * .3;\n    bgCol = mix(bgCol, bgCol2, h);\n\n    invert = 1.;\n    maxDist = 15.; \n    \n    float fl = 20.;\n    \n\tcamOrigin = vec3(0,0,9.5 * fl);\n   \tcamDir = normalize(vec3(uv * .168, -fl));\n\n\n    firstHit = march(camOrigin, camDir, invert, maxDist * fl, .6);\n    firstLen = firstHit.len;\n\n    float steps = 0.;\n    \n    for (float disperse = 0.; disperse < MAX_DISPERSE; disperse++) {\n        invert = 1.;\n    \tsam = vec3(0);\n\n        origin = camOrigin;\n        rayDir = camDir;\n\n        extinctionDist = 0.;\n        wavelength = disperse / MAX_DISPERSE;\n\t\tfloat rand = texture(iChannel0, (fragCoord + floor(iTime * 60.) * 10.) / iChannelResolution[0].xy).r;\n        wavelength += (rand * 2. - 1.) * (.5 / MAX_DISPERSE);\n        \n\t\tbounceCount = 0.;\n        vec3 nor;\n\n        for (float bounce = 0.; bounce < MAX_BOUNCE; bounce++) {\n\n            if (bounce == 0.) {\n                hit = firstHit;\n            } else {\n                hit = march(origin, rayDir, invert, 1.2, .6);\n            }\n            \n            steps += hit.steps;\n            \n            res = hit.res;\n            p = hit.p;\n            \n            if (invert < 0.) {\n\t            extinctionDist += hit.len;\n            }\n\n            // hit background\n            if ( res.y == 0.) {\n                break;\n            }\n            \n            if ( res.y == 4.) {\n                break;\n            }\n            \n            nor = normal(p);            \n            ref = reflect(rayDir, nor);\n            \n            if (res.y > 1.) {\n                break;\n            }\n\n            // shade\n            sam += light(p, ref) * .5;\n            sam += pow(max(1. - abs(dot(rayDir, nor)), 0.), 5.) * .1;\n            sam *= vec3(.85,.85,.98);\n\n\n            // refract\n            float ior = mix(1.2, 1.8, wavelength);\n            ior = invert < 0. ? ior : 1. / ior;\n            raf = refract(rayDir, nor, ior);\n            bool tif = raf == vec3(0); // total internal reflection\n            rayDir = tif ? ref : raf;\n            offset = .01 / abs(dot(rayDir, nor));\n            origin = p + offset * rayDir;\n            //invert = tif ? invert : invert * -1.;\n            invert *= -1.; // not correct but gives more interesting results\n\n            bounceCount = bounce;\n            \n        }\n        \n        if (res.y > 1.) {\n            sam = vec3(0);\n            sam += light(p, ref) * .5;\n            sam += pow(max(1. - abs(dot(rayDir, nor)), 0.), 5.) * .1;\n            sam *= vec3(.85,.85,.98);\n            vec3 cc = res.y == 2. ? vec3(1) : vec3(.033);\n            rayDir = refract(rayDir, nor, 1./1.3);\n            sam += env(p, rayDir) * cc;\n        }\n\n        if (bounceCount == 0.) {\n            // didn't bounce, so don't bother calculating dispersion\n            col += sam * MAX_DISPERSE;\n            break;\n        }\n        \n        if (res.y < 2.) {\n            sam += env(p, rayDir);\n        }\n\n        vec3 extinction = vec3(.5,.5,.5) * .0;\n        extinction = 1. / (1. + (extinction * extinctionDist));\t\n        col += sam * extinction * spectrum(-wavelength+.25);\n\t}\n    \n    col /= MAX_DISPERSE;\n\n    if (bounceCount == 0. && res.y == 0.) {\n        col = bgCol;\n    }\n\n    if (res.y == 4.) {\n        col = bgCol2;\n    }\n    \n    col = pow(col, vec3(1.19)) * 2.5;\n    \n    col = tonemap2(col);\n        \n    fragColor = vec4(col, 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}