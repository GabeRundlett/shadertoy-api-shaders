{
    "Shader": {
        "info": {
            "date": "1669922128",
            "description": "还原桌面效果\ni just removed the use of the buffer and fixed to center clock, add 12 hour time option  -tmm\ncustomize with :\n#define TWELVE_HOUR_CLOCK\n#define HOUR_LEADING_ZERO\n",
            "flags": 0,
            "hasliked": 0,
            "id": "msjXzh",
            "likes": 9,
            "name": "watchish",
            "published": 3,
            "tags": [
                "shaderlearn"
            ],
            "usePreview": 0,
            "username": "timmaffett",
            "viewed": 247
        },
        "renderpass": [
            {
                "code": "#define TWELVE_HOUR_CLOCK\n//#define HOUR_LEADING_ZERO\n\n//#define SHOW_GRID\n\nfloat pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\nconst float scale = 1.0 / 23.;\n\nvec2 digitSize = vec2(1.0,1.5) * scale;\nvec2 digitSpacing = vec2(1.5,1.6) * scale;\nvec2 positon=vec2(0.035,0.02);\nvec3 glowColor=vec3(0.23,0.26,1.0);\n//Distance to a line segment,\nfloat dfLine(vec2 start, vec2 end, vec2 uv)\n{\n\tstart *= scale;\n\tend *= scale;\n\n\tvec2 line = end - start;\n\tfloat frac = dot(uv - start,line) / dot(line,line);\n\treturn distance(start + line * clamp(frac, 0.0, 1.0), uv);\n}\n\n//Distance to the edge of a circle.\nfloat dfCircle(vec2 origin, float radius, vec2 uv)\n{\n\torigin *= scale;\n\tradius *= scale;\n\n\treturn abs(length(uv - origin) - radius);\n}\n\n//Distance to an arc.\nfloat dfArc(vec2 origin, float start, float sweep, float radius, vec2 uv)\n{\n\torigin *= scale;\n\tradius *= scale;\n\n\tuv -= origin;\n\tuv *= mat2(cos(start), sin(start),-sin(start), cos(start));\n\n\tfloat offs = (sweep / 2.0 - pi);\n\tfloat ang = mod(atan(uv.y, uv.x) - offs, tau) + offs;\n\tang = clamp(ang, min(0.0, sweep), max(0.0, sweep));\n\n\treturn distance(radius * vec2(cos(ang), sin(ang)), uv);\n}\n\n//Distance to the digit \"d\" (0-9).\nfloat dfDigit(vec2 origin, float d, vec2 uv)\n{\n\tuv -= origin;\n\td = floor(d);\n\tfloat dist = 1e6;\n\n\tif(d == 0.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,1.000), vec2(1.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.000,1.000), vec2(0.000,0.500), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,1.000),0.000, 3.142, 0.500, uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 3.142, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 1.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.500,1.500), vec2(0.500,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 2.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,0.000), vec2(0.000,0.000), uv));\n\t\tdist = min(dist, dfLine(vec2(0.388,0.561), vec2(0.806,0.719), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,1.000),0.000, 3.142, 0.500, uv));\n\t\tdist = min(dist, dfArc(vec2(0.700,1.000),5.074, 1.209, 0.300, uv));\n\t\tdist = min(dist, dfArc(vec2(0.600,0.000),1.932, 1.209, 0.600, uv));\n\t\treturn dist;\n\t}\n\tif(d == 3.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.000,1.500), vec2(1.000,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.500,1.000), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 4.712, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 4.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.700,1.500), vec2(0.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.000,0.500), vec2(1.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.700,1.200), vec2(0.700,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 5.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.300,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.300,1.500), vec2(0.200,0.900), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 5.356, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 6.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.067,0.750), vec2(0.500,1.500), uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,0.500), 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 7.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.000,1.500), vec2(1.000,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.500,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 8.0)\n\t{\n\t\tdist = min(dist, dfCircle(vec2(0.500,0.400), 0.400, uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,1.150), 0.350, uv));\n\t\treturn dist;\n\t}\n\tif(d == 9.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.933,0.750), vec2(0.500,0.000), uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,1.000), 0.500, uv));\n\t\treturn dist;\n\t}\n\n\treturn dist;\n}\n\n//Distance to a number\nfloat dfNumber(vec2 positon, float num, vec2 uv)\n{\n\tuv -= positon;\n\tfloat dist = 1e6;\n\tfloat offs = 0.;\n\tfloat space=1.1;\n\tfor(float i = 5.0;i > -3.0;i--)\n\t{\n        float a=num / pow(10.0,i);\n\t\tfloat d = mod(a,10.0);\n\n\t\tvec2 pos = digitSpacing * vec2(offs,0.0);\n\n\t\tif(i == 0.0)\n\t\t{\n\t\t\tdist = min(dist, dfCircle(vec2(offs+.9,0.1)*1.46, 0.04,uv));\n\t\t}\n        if(i==2.&&floor(a)>=0.){\n            \n            \n        \tdist = min(dist, dfCircle(vec2(offs+.9,0.1)*1.46, 0.04,uv));\n        }\n\n\t\tif(num > pow(10.0,i) || i == 0.0)\n\t\t{\n\n\t\t\tdist = min(dist, dfDigit(pos, d, uv));\n\t\t\toffs+=space;\n\t\t} else if (i==3.||i==2.) {\n#ifdef HOUR_LEADING_ZERO\n            dist = min(dist, dfDigit(pos, 0., uv));\n\t\t\toffs+=space;\n#else\n            if(i==2.&&floor(d)==0.) {\n                dist = min(dist, dfDigit(pos, 0., uv));\n                offs+=space;\n            } else {\n                offs+=space/2.0;\n            }\n#endif\n        }\n\t}\n\n\tfloat shade = 0.0;\n\n\t\tshade = 0.004 / (dist);\n\treturn shade;\n}\n\nfloat CalTime( vec2 origin, float num, vec2 uv){\n\n\tfloat shade ;\n\tfloat h=floor(num/3600.)*100.;\n#ifdef TWELVE_HOUR_CLOCK\n    //h = 0.; //test\n    if(h==0.) h=1200.0;\n    if( h>1200. ) {\n        h -= 1200.;\n    }\n#endif\n\tfloat t=floor( fract(num/3600.)*60.);\n\tfloat s= fract(fract(num/3600.)*60.)*60./100.;\n\tshade=dfNumber(origin,h+t+s,uv);\n\t//shade+=dfNumber(origin+vec2(0.3,0),t,uv);\n//\tshade+=dfNumber(origin+vec2(0.6,0),s,uv);\n\n\n\treturn shade;\n}\n\n\n\n//Length of a number in digits\nfloat numberLength(float n)\n{\n\treturn floor(max(log(n) / log(10.0), 0.0) + 1.0) + 2.0;\n}\n\nvoid timeFont( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy-0.5;\n\n\tuv-=positon;\n\tfloat n = iDate.w;\n\n\tvec3 color = vec3(0);\n\n\tfloat nsize = numberLength(n);\n\tvec2 pos = -digitSpacing * vec2(nsize,1.0)/2.0;\n\n\n\n\tfloat time=CalTime(pos, n, uv);\n\tcolor += glowColor * time;\n\n\n    #ifdef SHOW_GRID\n    float grid = 0.5-max(abs(mod(uv.x*64.0,1.0)-0.5), abs(mod(uv.y*64.0,1.0)-0.5));\n\n    color *= 0.25+vec3(smoothstep(0.0,95.0 / iResolution.y,grid))*0.75;\n    #endif\n\n\tfragColor = vec4( color , 1.0 );\n}\n\n\n\n\n\n// Fork of \"myscreen\" by hswangrui. https://shadertoy.com/view/3tdGWS\n// 2022-12-01 19:11:56\n\n\n\n#define S(a,b,t) smoothstep(a,b,t)\n\n\n\n\nfloat N21(vec2 i){\n\n\n\treturn fract(sin(i.x*45.+i.y*281.)*2363.);\n\n}\n\nvec2 N22(vec2 i){\n\n\tfloat n=N21(i);\n\treturn vec2(n,N21(vec2(n+i+1.)));\n}\n\n\nvec2 GetPos(vec2 id,vec2 offset){\n\tvec2 t =iTime*N22(id+offset)+sin(2.*iTime+sin(iTime))+cos(2.*iTime+cos(iTime));\n\tvec2 dir=vec2(sin(t.x+sin(t.x+sin(t.x))),cos(t.y+cos(t.y-cos(t.x))))*.4;\n\n\treturn dir+offset;\n}\n\nfloat calLineDis(vec2 uv,vec2 p1,vec2 p2){\n\n\t vec2 dir=normalize( p2-p1);\n\t vec2 s=uv-p1;\n\t float l=dot(s,dir);\n\t float d=1.;\n\tvec2 p=l*dir+p1;\n\tvec2 pp1=p-p1;\n\tvec2 pp2=p-p2;\n\t if(dot(pp1,pp2)<0.)\n\t\t  d=sqrt(dot(s,s)-l*l);\n\t float c=S(0.015,0.004,d)*S(1.6,1.1,length(p1-p2));\n\n\n\t return c;\n\n}\n\nvec3 drawLines(vec2 uv,vec2 id){\n\tvec3 col=vec3(0.);\n\t vec2 ray[9];\n\t\t\t int i=0;\n\t\t\t for(int y=-1;y<=1;y++){\n\t\t\t\t for(int x=-1;x<=1;x++){\n\t\t\t\t\t ray[i++]=GetPos(id,vec2(x,y));\n\n\t\t\t\t }\n\n\t\t\t }\n\t\t\t for(int k=0;k<=8;k++){\n\t\t\t\t if(k==4) continue;\n\t\t\t\t col+= calLineDis(uv,ray[4],ray[k]);\n\n\t\t\t }\n\t\t\t col+= calLineDis(uv,ray[3],ray[1]);\n\t\t\t col+= calLineDis(uv,ray[3],ray[7]);\n\t\t\t col+= calLineDis(uv,ray[5],ray[1]);\n\t\t\t col+= calLineDis(uv,ray[5],ray[7]);\n\treturn col;\n\n}\n\nvec3 drawPoints(vec2 uv,vec2 id){\n\n\tvec3 col=vec3(0.);\n\n\tfloat dis=length(uv-GetPos(id,vec2(0.)));\n\tfloat p=S(0.07,0.03,dis); //Point\n\t//glow\n\tvec3 glow=pow(S(0.35,0.01,dis),3.)*vec3(0.3,0.4,1.)*0.64;\n\n\t col=vec3(p);\n\treturn col+glow;\n}\n\nvec3 Background(vec2 uv){\n\n\tvec3 col=vec3(0.);\n\n\tvec3 color1=vec3(vec3(sin(iTime/2.)*0.19,0.2,.35));\n\tvec3 color2=vec3(cos(iTime/2.)*0.42,0.35,0.7);\n\tcol=mix(color1,color2,S(-0.9,0.35,uv.y)) ;\n\n\n\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragcolor,in vec2 fragcoord){\n\n\tvec2 tile=vec2(15.);\n\tfloat maskradius=0.14;\n\tfloat blur=0.1;\n\n\t\tvec3 col;\n\t\tvec2 uv=(fragcoord/iResolution.xy-.5)* 0.6;\n\t\tuv.x*=iResolution.x/iResolution.y;\n\n\t\tvec2 tileuv=uv*tile;\n\t\tvec2 id=floor(tileuv);\n\t\t  tileuv=fract(tileuv)-0.5;\n\t\t  //mask\n\t\t  vec2 mousepos=iMouse.xy/iResolution.xy-0.5;\n\t\t  mousepos.x*=iResolution.x/iResolution.y;\n\n         vec4 fontfragcolor = vec4(0.);\n\n         timeFont(fontfragcolor,fragcoord);\n         col += fontfragcolor.rgb;\n#ifdef TWOCHANNEL\n\t\t  //font\n\t\t  vec4 font= texture( iChannel0, vec2(uv+0.5) );\n\t\t  \tcol+=font.rgb;\n#endif\n\n\t\t  float mask=S(maskradius+blur,maskradius-blur-0.01,length(uv-mousepos));\n\t\tcol+=drawPoints(tileuv,id)*mask*0.6; //Point\n\t\tcol+=drawLines(tileuv,id)*mask*0.4;\n\n\n\t\t col+=Background(uv);\n\n\t\t  //grid\n\t\tfloat grid = 0.5-max(abs(mod(uv.x*50.0,1.0)-0.5), abs(mod(uv.y*50.0,1.0)-0.5));\n\t\tcol *= 0.95*(uv.y+.9)+vec3(S(-1.5,1.5- uv.y,grid))*0.15;\n\n\n\t\t//circle\n\t\tfloat g=S(0.25,0.3,length(uv));\n\t\tfloat circle1=S(0.30,0.29,length(uv))*g*0.2;\n\t\tfloat circle=S(0.35,0.03,length(uv))*pow(g*3.,2.);\n\t\tcol+=vec3(circle)*vec3(0.5,0.7,1.)*0.5+circle1;\n\t\t//move\n\n\t\tvec2 dir=vec2(0.29*sin(iTime),0.29*cos(iTime));\n\t\tfloat m=pow(S(0.02,0.0001,length(uv+dir)),2.)*0.3;\n\t\t m+=pow(S(0.02,0.0001,length(uv-dir)),2.)*0.3;\n\t\tcol+=m;\n\t\tfragcolor=vec4(col,1.);\n\n\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}