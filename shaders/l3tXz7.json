{
    "Shader": {
        "info": {
            "date": "1718835101",
            "description": "Click on the screen to override the specular manifold target point. Numerically calculates solutions, play around with any parametric specular surface without worrying about derivatives.",
            "flags": 0,
            "hasliked": 0,
            "id": "l3tXz7",
            "likes": 5,
            "name": "Differential Geometry 3 - 2D SMS",
            "published": 3,
            "tags": [
                "specular",
                "sampling",
                "parametric",
                "sms",
                "differential",
                "manifold",
                "catacaustic",
                "evolute",
                "orthotomic",
                "mnee"
            ],
            "usePreview": 0,
            "username": "KylBlz",
            "viewed": 153
        },
        "renderpass": [
            {
                "code": "\n/*\n\nThis one is fully numerical, feel free to play around inside any_fn()\nNotice there is no explicit reflect() or any ray tracing in here.\n\nThe green shape is your input function\nThe blue shape is the orthotomic of the function and incident point.\nThe red shape is the slope function, at zero crossings there exist a specular path between two points.\nThe orange shape is an illustration of the catacaustic, the envelope of all reflections.\n    -Orange rays are a naive numerical approximation of the solution(s)\n\nNumerical instabilities are cropping up near the tip of the catacaustic, probably from large sample domain.\nLooking into Paniq's Dual Automatic Differentiation shader still...\n\n*/\n\n\n\n// start with any explicit parametric function\nfloat tMin = 1.0;\nfloat tMax = 3.0;\n\nvec2 any_fn(in float t) {\n    // the caustic solver always sees a zero at t=0 ...\n    float _t = t - 2.0;\n    // lets play around near the focus of a parabola\n    return vec2(\n        _t*_t,\n        (2.0 - EPS)*_t\n    );\n}\n\n// draw any parametric function using numerical evaluation\nfloat density = 25.0;\n\nvec3 graphAnyFunction(in vec3 col, in vec2 ndc, in float lm, in float lw, in vec2 p1, in vec2 p2) {\n\n\n    float lastT = tMin;\n    \n    // 7 taps!\n    vec2 fm3 = any_fn(lastT-3.0*EPS);\n    vec2 fm2 = any_fn(lastT-2.0*EPS);\n    vec2 fm1 = any_fn(lastT-EPS);\n    vec2 f_0 = any_fn(lastT);\n    vec2 fp1 = any_fn(lastT+EPS);\n    vec2 fp2 = any_fn(lastT+2.0*EPS);\n    vec2 fp3 = any_fn(lastT+3.0*EPS);\n\n    // begin point of envelope line segments\n    vec2 last_any_fn = f_0;\n    vec2 last_any_fn_evolute = evolute(fm1, f_0, fp1);\n    vec2 last_any_fn_orthotomic = orthotomic(fm1, f_0, fp1, p1);\n    vec2 last_any_fn_catacaustic = evolute(\n        orthotomic(fm2, fm1, f_0, p1),\n        orthotomic(fm1, f_0, fp1, p1),\n        orthotomic(f_0, fp1, fp2, p1)\n    );\n    vec2 last_any_fn_catacaustic_1t = fn_d1(\n        evolute(\n            orthotomic(fm3, fm2, fm1, p1),\n            orthotomic(fm2, fm1, f_0, p1),\n            orthotomic(fm1, f_0, fp1, p1)\n        ),\n        evolute(\n            orthotomic(fm1, f_0, fp1, p1),\n            orthotomic(f_0, fp1, fp2, p1),\n            orthotomic(fp1, fp2, fp3, p1)\n        )\n    );\n    vec2 last_v_t = vec2(lastT, ((last_any_fn.y - p2.y) / (last_any_fn.x - p2.x)) - (last_any_fn_catacaustic_1t.y / last_any_fn_catacaustic_1t.x));\n    \n    // draw this many bundle rays and line segments\n    float tStep = (tMax - tMin - EPS) / density;\n\n    //*/ draw tangent bundles\n    for (float t = tMin; t < tMax; t += tStep) {\n\n        // 7 taps!\n        vec2 tm3 = any_fn(t-3.0*EPS);\n        vec2 tm2 = any_fn(t-2.0*EPS);\n        vec2 tm1 = any_fn(t-EPS);\n        vec2 t_0 = any_fn(t);\n        vec2 tp1 = any_fn(t+EPS);\n        vec2 tp2 = any_fn(t+2.0*EPS);\n        vec2 tp3 = any_fn(t+3.0*EPS);\n\n        // use our explicit parametric function as input\n        vec2 any_fn_0t = t_0;\n        // numerically calculate d/dt fn(t) using finite difference\n        vec2 any_fn_1t = fn_d1(tm1, tp1);\n        // numerically calculate evolute of our explicit parametric function\n        vec2 any_fn_evolute_0t = evolute(tm1, t_0, tp1);\n        // numerically calculate d/dt evolute(t) using finite difference\n        vec2 any_fn_evolute_1t = fn_d1(\n            evolute(tm2, tm1, t_0), \n            evolute(t_0, tp1, tp2)\n        );\n        // numerically calculate orthotomic of our explicit parametric function\n        vec2 any_fn_orthotomic_0t = orthotomic(tm1, t_0, tp1, p1);\n        // numerically calculate the catacaustic\n        vec2 any_fn_catacaustic_0t = evolute(\n            orthotomic(tm2, tm1, t_0, p1),\n            orthotomic(tm1, t_0, tp1, p1),\n            orthotomic(t_0, tp1, tp2, p1)\n        );\n        // numerically calculate catacaustic first derivative\n        vec2 any_fn_catacaustic_1t = fn_d1(\n            evolute(\n                orthotomic(tm3, tm2, tm1, p1),\n                orthotomic(tm2, tm1, t_0, p1),\n                orthotomic(tm1, t_0, tp1, p1)\n            ),\n            evolute(\n                orthotomic(tm1, t_0, tp1, p1),\n                orthotomic(t_0, tp1, tp2, p1),\n                orthotomic(tp1, tp2, tp3, p1)\n            )\n        );\n        // try to very lazily solve for a catacaustic path when any_fn_catacaustic_1t is the incident ray\n        vec2 v_t = vec2(t, ((any_fn_0t.y - p2.y) / (any_fn_0t.x - p2.x)) - (any_fn_catacaustic_1t.y / any_fn_catacaustic_1t.x));\n\n        // sorry about this XD interpolating didnt work as well\n        if (sign(v_t.y) * sign(last_v_t.y) < 0.0) {\n            // one step linear refinement\n            float m = v_t.x + tStep * v_t.y / -(v_t.y - last_v_t.y);\n            // 7 taps!\n            vec2 mm3 = any_fn(m-3.0*EPS);\n            vec2 mm2 = any_fn(m-2.0*EPS);\n            vec2 mm1 = any_fn(m-EPS);\n            vec2 m_0 = any_fn(m);\n            vec2 mp1 = any_fn(m+EPS);\n            vec2 mp2 = any_fn(m+2.0*EPS);\n            vec2 mp3 = any_fn(m+3.0*EPS);\n            // here we go again!\n            vec2 any_fn_0m = m_0;\n            vec2 any_fn_1m = fn_d1(mm1, mp1);\n            vec2 any_fn_evolute_0m = evolute(mm1, m_0, mp1);\n            vec2 any_fn_evolute_1m = fn_d1(\n                evolute(mm2, mm1, m_0), \n                evolute(m_0, mp1, mp2)\n            );\n            vec2 any_fn_orthotomic_0m = orthotomic(mm1, m_0, mp1, p1);\n            vec2 any_fn_catacaustic_0m = evolute(\n                orthotomic(mm2, mm1, m_0, p1),\n                orthotomic(mm1, m_0, mp1, p1),\n                orthotomic(m_0, mp1, mp2, p1)\n            );\n            vec2 any_fn_catacaustic_1m = fn_d1(\n                evolute(\n                    orthotomic(mm3, mm2, mm1, p1),\n                    orthotomic(mm2, mm1, m_0, p1),\n                    orthotomic(mm1, m_0, mp1, p1)\n                ),\n                evolute(\n                    orthotomic(mm1, m_0, mp1, p1),\n                    orthotomic(m_0, mp1, mp2, p1),\n                    orthotomic(mp1, mp2, mp3, p1)\n                )\n            );\n            // graph solution incident ray\n            col = mix(vec3(1.0, 0.6, 0.0), col, smoothstep(lm, lw, sd_line( ndc, any_fn_0m - p1, p1 )));\n            // graph solution catacaustic ray\n            col = mix(vec3(1.0, 0.6, 0.0), col, smoothstep(lm, lw, sd_line( ndc, any_fn_catacaustic_1m, any_fn_catacaustic_0m )));\n        }\n        \n        // graph function tangent bundle\n        //col = mix(vec3(0.0, 0.6, 0.0), col, 0.8 + 0.2 * smoothstep(lm, lw, sd_line( ndc, any_fn_1t, any_fn_0t )));\n        // graph evolute tangent bundle\n        //col = mix(vec3(1.0, 0.0, 0.0), col, 0.8 + 0.2 * smoothstep(lm, lw, sd_line( ndc, any_fn_evolute_1t, any_fn_evolute_0t )));\n        // graph incident bundle\n        //col = mix(vec3(1.0, 0.5, 0.7), col, 0.6 + 0.4 * smoothstep(lm, lw, sd_line( ndc, any_fn_0t - p, p )));\n        // graph orthotomic envelope of curvatures\n        col = mix(vec3(0.0, 0.0, 1.0), col, 0.9 + 0.1 * smoothstep(lm, lw, sd_circle( ndc, any_fn_0t, distance(any_fn_0t, p1) )));\n        // graph catacaustic tangent bundle where the dot is positive with the evolute\n        col = mix(vec3(1.0, 0.7, 0.5), col, 0.7 + 0.3 * smoothstep(lm, lw, sd_line( ndc, any_fn_catacaustic_1t, any_fn_catacaustic_0t )));\n\n        // graph function envelope a little bolder\n        col = mix(vec3(0.0, 0.6, 0.0), col, smoothstep(lm * 2.0, lw * 2.0, sd_segment( ndc, last_any_fn, any_fn_0t )));\n        // graph evolute function envelope\n        //col = mix(vec3(1.0, 0.0, 0.0), col, smoothstep(lm, lw, sd_segment( ndc, last_any_fn_evolute, any_fn_evolute_0t )));\n        // graph orthotomic function envelope\n        col = mix(vec3(0.0, 0.0, 1.0), col, smoothstep(lm, lw, sd_segment( ndc, last_any_fn_orthotomic, any_fn_orthotomic_0t )));\n        // graph catacaustic function envelope, lazily filter out the discontinuity (it's supposed to be there)\n        //if (distance(last_any_fn_catacaustic, any_fn_catacaustic_0t) < 10.0)\n        //    col = mix(vec3(1.0, 0.6, 0.0), col, smoothstep(lm, lw, sd_segment( ndc, last_any_fn_catacaustic, any_fn_catacaustic_0t )));\n        // graph the catacaustic incident slope function\n        col = mix(vec3(1.0, 0.0, 0.0), col, smoothstep(lm, lw, sd_segment( ndc, last_v_t, v_t )));\n\n        last_any_fn = any_fn_0t;\n        last_any_fn_evolute = any_fn_evolute_0t;\n        last_any_fn_orthotomic = any_fn_orthotomic_0t;\n        last_any_fn_catacaustic = any_fn_catacaustic_0t;\n        last_v_t = v_t;\n\n    }//*/\n\n    return col;\n}\n\n// aspect, zoom, etc\nvec2 setupViewport(in vec2 fragCoord, in float zoom) {\n    // ndc with aspect\n    vec2 ndc = fragCoord/iResolution.xy * 2.0 - 1.0;\n    ndc.x *= iResolution.x / iResolution.y;\n    // graph zoom\n    return ndc * zoom;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // set up viewport\n    float zoom = PI;\n    vec2 ndc = setupViewport(fragCoord, zoom);\n\n    // AA line width\n    float px = zoom / iResolution.x;\n    float lw = 5.0 * px;\n    float lm = max(lw - px * 5.0, 0.0);\n\n    // blank canvas\n    vec3 col = vec3(1.0);\n\n    // graph axes\n    col = min(col, smoothstep(lm, lw, distance( ndc, ndc*vec2(1.0, 0.0) )));\n    col = min(col, smoothstep(lm, lw, distance( ndc, ndc*vec2(0.0, 1.0) )));\n    // graph lighter grid lines\n    col = min(col, 0.8 + 0.2 * smoothstep(lm * 2.0, lw * 2.0, fract(distance( ndc, ndc*vec2(1.0, 0.0) ))));\n    col = min(col, 0.8 + 0.2 * smoothstep(lm * 2.0, lw * 2.0, fract(distance( ndc, ndc*vec2(0.0, 1.0) ))));\n\n    // incident point P animation\n    float frameTime = float(iFrame) * 0.01666;\n    vec2 p1 = vec2(3.0 + EPS + cos(frameTime), sin(frameTime));\n    // some other point to connect specular paths to\n    vec2 p2 = vec2(4.0, -EPS);\n\n    // input from user mouse\n    if (iMouse.z > 0.0 || iMouse.w > 0.0) {\n        p2 = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n        p2.x *= iResolution.x / iResolution.y;\n        p2 *= zoom;\n    }\n    p2.x = max(1.0 + EPS, p2.x);\n    \n    // draw points\n    col = min(col, smoothstep(lm, lw, distance(ndc, p1) - 0.05));\n    col = min(col, smoothstep(lm, lw, distance(ndc, p2) - 0.05));\n    \n    //col = graphAnyFunction(col, ndc, lm, lw, p1, p2);\n    col = graphAnyFunction(col, ndc, lm, lw, p2, p1);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float EPS = (1.0 / 128.0);\nconst float PI =  3.141592;\nconst float TAU = 6.283185;\n\nfloat wedge(in vec2 a, in vec2 b) {\n    return a.x*b.y - b.x*a.y;\n}\n\n// drawing utilities\n\nfloat sd_segment(vec2 xy, vec2 pt1, vec2 pt2) {\n    vec2 a = pt2 - pt1;\n\tvec2 b = xy - pt1;\n\tfloat h = dot(b, a) / dot(a, a);\n\treturn length(b - clamp(h, 0.0, 1.0) * a);\n}\n\nfloat sd_line(vec2 xy, vec2 m, vec2 b) {\n    vec2 c = xy - b;\n    float h = dot(c, m) / dot(m, m);\n    return length(c - h * m);\n}\n\nfloat sd_circle(vec2 xy, vec2 c, float r) {\n    return abs(distance(xy, c) - r);\n}\n\n// differential geometry toolkit\n\n// finite difference degree 1, fn_i should be fn(t - EPS), fn_f should be fn(t + EPS)\nvec2 fn_d1(in vec2 fn_i, in vec2 fn_f) {\n    return 0.5 * (fn_i - fn_f) / EPS;\n}\n\n// finite difference degree 2, fn_i should be fn(t - EPS), fn should be fn(t), fn_f should be fn(t + EPS)\nvec2 fn_d2(in vec2 fn_i, in vec2 fn, in vec2 fn_f) {\n    return (((fn_i - fn) / EPS) - ((fn - fn_f) / EPS)) / EPS;\n}\n\n// Evolute curve: locus of centers of curvature (sitches between envelopes of tangents and normals), is its own inverse.\n// implementation started from here: https://mathworld.wolfram.com/Evolute.html\n// https://resources.wolframcloud.com/FunctionRepository/resources/EvoluteCurve\n\n// this version takes derivatives explicitly\nvec2 _evolute(in vec2 d0, in vec2 d1, in vec2 d2) {\n    float d1s = dot(d1, d1);\n    float norm = 1.0 / wedge(d1, d2);\n    return d0 + vec2(-d1s, d1s) * d1.yx * norm;\n}\n\n// this version numerically differentiates given 3 taps of the function.\nvec2 evolute(in vec2 fn_i, in vec2 fn, in vec2 fn_f) {\n    return _evolute(fn, fn_d1(fn_i, fn_f), fn_d2(fn_i, fn, fn_f));\n}\n\n// Orthotomic curve: locus of reflections from point source illuminating parametric curve.\n// Implementation derived starting from here: https://mathworld.wolfram.com/PedalCurve.html\n// https://resources.wolframcloud.com/FunctionRepository/resources/Orthotomic\n// WARNING, INCORRECT SOURCE: https://mathworld.wolfram.com/Orthotomic.html\n\n// this version takes derivatives and incident point P\nvec2 _orthotomic(in vec2 d0, in vec2 d1, in vec2 p) {\n    vec2 d1s = d1 * d1;\n    vec2 d1yx = d1.yx * d1;\n    float norm = 1.0 / (d1s.x + d1s.y);\n    vec2 petal = p * d1s + d0 * d1s.yx + (p.yx - d0.yx) * d1yx;\n    return 2.0 * petal * norm - p;\n}\n\n// this version numerically differentiates given 3 taps of the function.\nvec2 orthotomic(in vec2 fn_i, in vec2 fn, in vec2 fn_f, in vec2 p) {\n    return _orthotomic(fn, fn_d1(fn_i, fn_f), p);\n}\n\n// Inverse Orthotomic Curve: takes envelope of reflections and point source, reconstructs reflecting surface\n// Same as above, start here: https://mathworld.wolfram.com/NegativePedalCurve.html\n// https://resources.wolframcloud.com/FunctionRepository/resources/NegativePedalCurve\n\n// this version takes derivatives and incident point P\nvec2 _inverseOrthotomic(in vec2 d0, in vec2 d1, in vec2 p) {\n    vec2 pd = d0 - p;\n    vec2 N = d0 - p*d1;\n    float norm = N.x - N.y;\n    vec2 iPetal =  ((pd*pd).yx - pd*d0) * d1.yx + (2.0*d0 - p) * pd.yx * d1;\n    return 0.5 * (vec2(-1.0, 1.0) * ( iPetal / norm ) + p);\n}\n\n// this version numerically differentiates given 3 taps of the function.\nvec2 _inverseOrthotomic(in vec2 fn_i, in vec2 fn, in vec2 fn_f, in vec2 p) {\n    return _inverseOrthotomic(fn, fn_d1(fn_i, fn_f), p);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}