{
    "Shader": {
        "info": {
            "date": "1635801176",
            "description": "2D analog of Light Propagation Volumes. right side is a raymarched projected 1D view of the scene",
            "flags": 32,
            "hasliked": 0,
            "id": "fld3R4",
            "likes": 36,
            "name": "2D Light Propagation Volume",
            "published": 3,
            "tags": [
                "2d",
                "light",
                "propagation",
                "lpv"
            ],
            "usePreview": 1,
            "username": "paniq",
            "viewed": 1375
        },
        "renderpass": [
            {
                "code": "\nfloat shade(vec3 sh, vec3 dV, SD sd, int ch, bool proj) {\n    vec3 dZ = vec3(0,0,1) * SH1_Basis;\n    float W = max(0.0, dot(sh, dZ));\n    float L = max(0.0, dot(sh, dV));\n    \n    float d = sd.d/pixel_radius;\n    float w = fwidth(d);\n    float b = clamp(d*0.5+0.5,0.0,1.0);\n    \n    float albedo = sd.albedo[ch];\n    if (sd.emissive && (abs(d) <= 1.0)) {\n        L = albedo;\n    } else {\n        L *= albedo;\n    }\n\n    if (proj) {\n        return L;\n    } else {\n        return mix(L, W, b);\n    }\n    //return W + L*(1.0 - b);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    setup_mouse_pos();\n    set_resolution(iResolution.xy);\n    ivec2 p = ivec2(fragCoord);\n    fragColor = vec4(0,0,0,1);\n    \n    vec2 uv = (fragCoord / iResolution.xy)*2.0 - 1.0;\n    uv *= vec2(iResolution.x/iResolution.y, 1.0);\n    \n    bool proj = uv.x > 1.5; \n    if (proj) {\n        // raymarch 2D surface\n        vec2 ro = vec2(-2.0, 0.0);\n        vec2 rd = normalize(vec2(0.0, uv.y) - ro);\n        \n        ro += vec2(0.0, 1.2);\n        rd = rotate(rd, radians(-37.0));\n        \n        float t = 0.0;\n        vec2 q;\n        int S = 0;\n        for (int i = 0; i < 32; ++i) {\n            S += 1;\n            q = ro + rd * t;\n            float d = map(q).d;\n            if (d <= 1e-5)\n                break;\n            t = t + abs(d);\n        }\n        if (t > 10.0) {\n            fragColor = vec4(0.0);\n            return;\n        }\n\n        uv = q;\n    }\n    vec2 tuv = ((uv * vec2(iResolution.y/iResolution.x,1.0))*0.5 + 0.5);\n    vec3 shr = texture(iChannel0, tuv).xyz;\n    vec3 shg = texture(iChannel1, tuv).xyz;\n    vec3 shb = texture(iChannel2, tuv).xyz;\n#if 0\n    vec3 dV = vec3(-normal_map(uv, pixel_radius),1) * SH1_Basis;\n    dV = sh_irradiance_probe(dV);    \n#else\n    vec3 dV = lambert(-normal_map(uv, pixel_radius)) * SH1_Basis;\n#endif\n\n#ifdef SHOW_GRADIENT\n    vec3 dX0 = vec3(-1,0,1) * SH1_Basis;\n    vec3 dX1 = vec3(1,0,1) * SH1_Basis;\n    vec3 dY0 = vec3(0,-1,1) * SH1_Basis;\n    vec3 dY1 = vec3(0,1,1) * SH1_Basis;\n    vec3 dZ = vec3(0,0,1) * SH1_Basis;\n    float dx0 = max(0.0,dot(dX0, sh));\n    float dx1 = max(0.0,dot(dX1, sh));\n    float dy0 = max(0.0,dot(dY0, sh));\n    float dy1 = max(0.0,dot(dY1, sh));\n    float dz = dot(dZ, sh);\n    vec3 W =\n          vec3(1.0,0.0,0.0) * dx0\n        + vec3(0.0,1.0,1.0) * dx1\n        + vec3(0.0,1.0,0.0) * dy0\n        + vec3(1.0,0.0,1.0) * dy1\n        + vec3(1.0,1.0,0.0) * dz\n    ;\n    vec3(vec2(dx0+dx1,dy0+dy1), dz);\n#endif\n    SD sd = map(uv);\n\n    vec3 col = vec3(\n        shade(shr, dV, sd, 0, proj),\n        shade(shg, dV, sd, 1, proj),\n        shade(shb, dV, sd, 2, proj));\n    \n    fragColor = vec4(linear_srgb(ACESFitted(max(col * 1.0,vec3(0.0)))),1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "USE_LPV_KERNEL(0)",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n//#define SHOW_GRADIENT\n#define BOUNCE\n\n// for more information, please see my writeup on the 3D case\n// https://gist.github.com/paniq/9e1043134de8184df33b3cbf29fcaf37\n\nconst float pi = 3.14159265359;\nconst float tau = 6.28318530718;\nconst float unit_sphere_area = 2.0 * tau;\nconst float unit_circle_area = 2.0 * pi;\n#if 1\n\n// circular harmonics\n// see also https://blackpawn.com/texts/ch/default.html\n// and https://valdes.cc/articles/ch.html\n\nconst float unit_area = unit_circle_area;\nconst vec3 SH1_Basis = sqrt(vec3(vec2(2.0),1.0) / unit_circle_area);\n\nvec3 ambient () {\n    return vec3(0,0,2.0 * pi);\n}\n\nvec3 lambert (vec2 n) {\n    return vec3(n * 0.5 * pi, 2.0);\n}\n\nvec3 half_lambert (vec2 n) {\n    return vec3(n * 0.5 * pi, pi);\n}\n\nvec3 light (vec2 n, float sa) {\n    return vec3(n * 2.0 * sin(sa / 2.0), sa);\n}\n\n#define SHSharpness 1.0 // 2.0\nvec3 sh_irradiance_probe(vec3 v) {\n    const float sh_c0 = (2.0 - SHSharpness) * 1.0;\n    const float sh_c1 = SHSharpness * 2.0 / 3.0;\n    return vec3(v.xy * sh_c1, v.z * sh_c0);\n}\n#else // 3d basis, not going to work here\n\n// for a simulation in 3D, see\n// https://www.shadertoy.com/view/XdtSRn\n\nconst float unit_area = unit_sphere_area;\nconst vec4 SH1_Basis = sqrt(vec4(vec3(3.0),1.0) / unit_sphere_area);\n\nvec4 ambient () {\n    return vec4(0,0,0,2.0 * tau);\n}\n\nvec4 light (vec3 n, float sa) {\n    float k = (cos (sa / 4.0));\n    return vec4(n * (pi * (1.0 - k * k)), tau * (1.0 - k));\n}\n\n#define SHSharpness 1.0 // 2.0\nvec4 sh_irradiance_probe(vec4 v) {\n    const float sh_c0 = (2.0 - SHSharpness) * 1.0;\n    const float sh_c1 = SHSharpness * 2.0 / 3.0;\n    return vec4(v.xyz * sh_c1, v.w * sh_c0);\n}\n#endif\n\n//---------------------------------------------------------------------------------\n\nvec2 rotate(vec2 p, float r) {\n    float c = cos(r); float s = sin(r);\n    return mat2(c,s,-s,c) * p;\n}\n\n// shaded distance\nstruct SD {\n    float d;\n    vec3 albedo;\n    bool emissive;\n};\n\nSD sd_min(SD a, SD b) {\n    if (a.d <= b.d)\n        return a;\n    else\n        return b;\n}\n\nSD sd_max(SD a, SD b) {\n    if (a.d >= b.d)\n        return a;\n    else\n        return b;\n}\n\nSD sd_neg(SD a) {\n    return SD(-a.d, a.albedo, a.emissive);\n}\n\nSD shade(float d, vec3 albedo) {\n    return SD(d, albedo, false);\n}\n\nSD emitter(float d, vec3 light) {\n    return SD(d, light, true);\n}\n\nfloat box(vec2 p, vec2 r) {\n    p = abs(p) - r;\n    return max(p.x, p.y);\n}\n\nfloat sphere(vec2 p, float r) {\n    return length(p) - r;\n}\n\nSD slitlight(vec2 p) {\n    const vec3 color = vec3(0.01, 0.5, 0.95);\n    float angle = max(0.0,cos(atan(p.y, p.x)*6.0));\n    if (angle < 0.5)\n        angle = 0.0;\n    SD d2 = emitter(sphere(p, 0.1),color * angle * 20.0);\n    return d2;\n}\n\nvec2 mouse_pos;\n#define setup_mouse_pos() \\\n    mouse_pos = ((iMouse.xy / iResolution.xy)*2.0 - 1.0) * vec2(iResolution.x/iResolution.y, 1.0);\n\n\nSD map(vec2 p) {\n    const vec3 color1 = vec3(0.8);\n    const vec3 color3 = vec3(0.95, 0.5, 0.01);\n    const vec3 color4 = vec3(0.01, 1.0, 0.8);\n\n    SD d = shade(sphere(p, 0.5),color1);\n    \n    SD d2 = slitlight(p - vec2(-0.8,-0.1));\n    \n    SD d3 = shade(box(p - vec2(-0.5,-0.2), vec2(0.52,0.05)),color1);\n    \n    SD d4 = shade(box(rotate(p, radians(90.0+30.5)) - vec2(0.0, 0.0), vec2(0.05,0.8)),color3);\n    SD d5 = shade(box(p - vec2(0.0, 0.0), vec2(0.05,0.4)),color3);\n    SD d7 = shade(box(p - vec2(0.20, 0.1), vec2(0.05,0.2)),color4);\n    \n    SD d6 = emitter(box(rotate(p - vec2(0.25, -0.2),radians(30.5)), vec2(0.01,0.04)),20.0*vec3(1.0,0.9,0.8));\n    \n    SD d8 = shade(sphere(p - mouse_pos, 0.05),vec3(1.0));\n    \n    return sd_min(d8,sd_min(d6,sd_min(d3,sd_min(d2, sd_max(d,sd_neg(sd_min(d7,sd_min(d4,d5))))))));\n}\n\nvec2 normal_map(vec2 p, float eps) {\n    return normalize(vec2(\n        (map(p + vec2(eps, 0.0)).d - map(p - vec2(eps, 0.0)).d),\n        (map(p + vec2(0.0, eps)).d - map(p - vec2(0.0, eps)).d)));\n}\n\n//---------------------------------------------------------------------------------\n\nvec2 resolution;\nfloat pixel_radius;\n\nvec2 pixel2uv(ivec2 p) {\n    vec2 uv = ((vec2(p) + 0.5) / resolution.xy)*2.0-1.0;\n    uv.x *= resolution.x/resolution.y;\n    return uv;\n}\n\nvec3 occluder(ivec2 p, out SD sd) {\n    vec2 uv = pixel2uv(p);\n    float r = pixel_radius;\n    sd = map(uv);\n    float d = sd.d / r;\n    if (d > 1.0)\n        return vec3(0.0);\n    vec2 n = normal_map(uv, r);\n    // orthodox: solid angle goes from 100% to 50%, then drops\n    // to 0% when the point is inside the surface\n    //float opacity = step(0.0,d)*(d*0.5+0.5);\n    // benevolent: no discontinuity, 50% visibility on the surface\n    //float opacity = max(0.0,(d*0.5+0.5));\n    // smooth: no discontinuity, sine curve\n    float opacity = sin(max(-1.0,d)*pi*0.5)*0.5+0.5;\n    \n    return light(-n, opacity * 2.0 * pi) * SH1_Basis;\n}\n\nvec3 propagate(sampler2D iChannel0, ivec2 p, vec2 n, float sa, SD sd, int ch) {\n    ivec2 R = ivec2(resolution.xy);\n    if ((p.x < 0)||(p.y < 0)||(p.x >= R.x)||(p.y >= R.y))\n        return vec3(0.0);\n    if (sd.d < -pixel_radius)\n        return vec3(0.0);\n    // get occluder of neighbor\n    SD occ_sd;\n    vec3 occ = occluder(p, occ_sd);\n        \n    vec3 F = texelFetch(iChannel0, p, 0).xyz;    \n    vec3 dV = vec3(n,1) * SH1_Basis;\n    // light hitting our interior cell wall\n    float L = max(0.0, dot(F, dV * sa));\n    // how much of their cell wall is occupied?\n    float E = max(0.0, dot(occ, dV * sa));\n    float O =\n#ifdef BOUNCE\n        min(E, 1.0);\n#else\n        0.0;\n#endif\n    // subtract occluder from light\n    vec3 outsh = dV * L * (1.0 - O);\n    vec3 dRV = vec3(-n,1) * SH1_Basis;\n    float ref = 0.0;\n    if (sd.emissive) {\n        if (abs(occ_sd.d) <= pixel_radius) {\n            ref = sd.albedo[ch] * E;\n        }\n    } else {\n        ref = O * L * sd.albedo[ch];\n    }\n    // add emission\n    outsh += ref * dRV;\n    return outsh;\n}\n\nfloat solid_angle(vec2 a, vec2 b) {\n    return acos(dot(normalize(a),normalize(b)));\n}\n\nvoid set_resolution(vec2 res) {\n    resolution = res;\n    //pixel_radius = 0.5 * sqrt(2.0) /resolution.y;\n    pixel_radius = 1.0 * sqrt(2.0) /resolution.y;\n}\n\n#define USE_LPV_KERNEL(CH) \\\n    void mainImage( out vec4 fragColor, in vec2 fragCoord ) \\\n    { \\\n        setup_mouse_pos(); \\\n        set_resolution(iResolution.xy); \\\n        lpv_kernel(fragColor, fragCoord, iChannel0, CH); \\\n    }\n\nvoid lpv_kernel( out vec4 fragColor, in vec2 fragCoord, sampler2D channel, int ch )\n{\n    ivec2 p = ivec2(fragCoord);\n    \n    fragColor = vec4(0.0);\n    \n    SD sd = map(pixel2uv(p));\n    \n#define PROPAGATE(OFS, N, SA) \\\n     propagate(channel, p + OFS, N, SA, sd, ch)\n#if 1\n    int d = 1;\n    float x = 2.0;\n    float sa1 = solid_angle(vec2(x,-1.0),vec2(x,1.0)); // ~53.13°, projecting to the right side of our pixel\n    float sa2 = solid_angle(vec2(x-1.0,1.0),vec2(x,1.0)); // ~18.43°, projecting to the top/bottom side of our pixel\n    // note that sa2 = (90° - sa1) / 2, and analog in the 3D case, sa2 = (4*pi/6 - sa1) / 4\n    vec2 dn1 = normalize(vec2(x - 0.5, 1.0)); // normal to the center of the top side of our pixel\n    vec2 dn0 = normalize(vec2(x - 0.5, -1.0)); // normal to the center of the bottom side of our pixel\n    fragColor.xyz +=\n         PROPAGATE(ivec2(-d, 0), vec2(1,0), sa1)\n        +PROPAGATE(ivec2(-d, 0), dn1, sa2)\n        +PROPAGATE(ivec2(-d, 0), dn0, sa2)\n        +PROPAGATE(ivec2(d, 0), vec2(-1,0), sa1)\n        +PROPAGATE(ivec2(d, 0), -dn0, sa2)\n        +PROPAGATE(ivec2(d, 0), -dn1, sa2)\n        +PROPAGATE(ivec2(0,-d), vec2(0,1), sa1)\n        +PROPAGATE(ivec2(0,-d), dn1.yx, sa2)\n        +PROPAGATE(ivec2(0,-d), dn0.yx, sa2)\n        +PROPAGATE(ivec2(0, d), vec2(0,-1), sa1)\n        +PROPAGATE(ivec2(0, d), -dn1.yx, sa2)\n        +PROPAGATE(ivec2(0, d), -dn0.yx, sa2);\n#else\n    float x = 1.0;\n    float sa1 = solid_angle(vec2(x,-1.0),vec2(x,1.0)); // 90°, projecting to the left side of our pixel\n    fragColor.xyz +=\n         PROPAGATE(ivec2(-1, 0), vec2(1,0), sa1)\n        +PROPAGATE(ivec2(1, 0), vec2(-1,0), sa1)\n        +PROPAGATE(ivec2(0,-1), vec2(0,1), sa1)\n        +PROPAGATE(ivec2(0, 1), vec2(0,-1), sa1);\n#endif\n#undef PROPAGATE\n}\n\n//---------------------------------------------------------------------------------\n\n// ACES fitted\n// from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color)\n{\n    color = color * ACESInputMat;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n\n    color = color * ACESOutputMat;\n\n    // Clamp to [0, 1]\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n\n//---------------------------------------------------------------------------------\n\nfloat linear_srgb(float x) {\n    return mix(1.055*pow(x, 1./2.4) - 0.055, 12.92*x, step(x,0.0031308));\n}\nvec3 linear_srgb(vec3 x) {\n    return mix(1.055*pow(x, vec3(1./2.4)) - 0.055, 12.92*x, step(x,vec3(0.0031308)));\n}\n\nfloat srgb_linear(float x) {\n    return mix(pow((x + 0.055)/1.055,2.4), x / 12.92, step(x,0.04045));\n}\nvec3 srgb_linear(vec3 x) {\n    return mix(pow((x + 0.055)/1.055,vec3(2.4)), x / 12.92, step(x,vec3(0.04045)));\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "USE_LPV_KERNEL(1)",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "USE_LPV_KERNEL(2)",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}