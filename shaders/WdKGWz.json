{
    "Shader": {
        "info": {
            "date": "1570288782",
            "description": "Mouseable, #define tinkerable.\n\nI know I'm late to the party, but I will try to catch up with the calendar. My goal for this challenge is to keep the style consistent (simple, monochrome, instagram-friendly, loopable, antialiased) throughout the shaders.",
            "flags": 0,
            "hasliked": 0,
            "id": "WdKGWz",
            "likes": 43,
            "name": "Inktober2019 01: ring",
            "published": 3,
            "tags": [
                "torus",
                "ring",
                "inktober",
                "shadertober",
                "inktober2019"
            ],
            "usePreview": 0,
            "username": "s23b",
            "viewed": 790
        },
        "renderpass": [
            {
                "code": "#define AA 4.\n#define NUM_STRIPES 10.\n#define PERIOD 10.\n#define COLOR vec3(1., .9, .75)\n\n#define MAX_STEPS 100\n#define NEAR .001\n#define FAR 5.\n#define PI 3.14159265359\n\nvec3 hash(float p) {\n    return fract(cos(p) * vec3(12345.6, 23456.7, 34567.8));\n}\n\nvoid tRotate(inout vec2 p, float angle) {\n    float s = sin(angle), c = cos(angle);\n\tp *= mat2(c, -s, s, c);\n}\n\nfloat sdTorus(vec3 p, float r1, float r2) {\n    return length(vec2(length(p.xz) - r1, p.y)) - r2;\n}\n\nfloat map(vec3 p) {\n    return sdTorus(p.xzy, 1., .2);\n}\n\nfloat trace(vec3 o, vec3 r) {\n\n    float t = 0.;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        float d = map(o + r * t);\n        t += d;\n        if (d < NEAR || t > FAR) break;\n    }\n    \n    return t;\n}\n\nfloat render(vec2 fragCoord) {\n\tvec2 uv = (fragCoord.xy * 2. - iResolution.xy) / min(iResolution.y, iResolution.x);\n    \n    vec3 r = normalize(vec3(uv, 1.5));\n    vec3 o = vec3(.1, -.1, -3);\n    \n    vec2 rot = iMouse.z > 0. ? iMouse.xy / iResolution.xy * 2. : vec2(-.2, .2);\n    rot *= PI;\n    tRotate(r.yz, -rot.y);\n    tRotate(r.xz, -rot.x);\n    tRotate(o.yz, -rot.y);\n    tRotate(o.xz, -rot.x);\n    \n    float f = trace(o, r);\n    \n    if (f > FAR) return 1.;\n    \n    vec3 p = o + f * r;\n    \n    vec2 tp = atan(vec2(p.x, length(p.xy)-1.), p.yz) / PI / 2. + .5;\n    tp.y = fract(tp.y + tp.x + iTime / PERIOD);\n    vec3 h = hash(floor(tp.y * NUM_STRIPES));\n    float offset = h.x,\n          speed = ceil(h.y * PERIOD) / PERIOD,\n          size = h.z * .25 + .125;\n    \n    tp.y = mod(tp.y, 1. / NUM_STRIPES) - .5 / NUM_STRIPES;\n    tp.x = fract(tp.x + offset + speed * iTime) - .5;\n    tp = abs(tp);\n    \n   \treturn step(smoothstep(size, 0., tp.x), tp.y / .4 * NUM_STRIPES);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    float color = 0.;\n    \n    vec2 uv = abs(fragCoord - iResolution.xy / 2.) / min(iResolution.y, iResolution.x);\n    \n    if (uv.x > .45 || uv.y > .45) {\n        color = 0.;\n    } else {\n        for (float x = 0.; x < AA; ++x) {\n            for (float y = 0.; y < AA; ++y) {\n                color += render(fragCoord + vec2(x, y) / AA);\n            }\n        }\n    \tcolor /= AA * AA;\n    }\n    \n        \n\tfragColor = vec4(mix(vec3(0), COLOR, color), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}