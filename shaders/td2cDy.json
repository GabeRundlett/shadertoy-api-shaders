{
    "Shader": {
        "info": {
            "date": "1587300959",
            "description": "First step towards building a renderer for https://youtu.be/BtYKDamqo2I?t=334\n\nStep two: https://www.shadertoy.com/view/tsjyWV\nStep three: https://www.shadertoy.com/view/wdXfzN#",
            "flags": 0,
            "hasliked": 0,
            "id": "td2cDy",
            "likes": 2,
            "name": "Single Layer Glitter",
            "published": 3,
            "tags": [
                "glitter"
            ],
            "usePreview": 0,
            "username": "qwert33",
            "viewed": 303
        },
        "renderpass": [
            {
                "code": "\n#define TAU 6.28318530718\n#define PI TAU/2\n    \n// biases x to be closer to 0 or 1\n// can act like a parameterized smoothstep\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat bias(float x, float b) {\n    x = clamp(x, 0., 1.);\n    b = -log2(1.0 - b);\n    return 1.0 - pow(1.0 - pow(x, 1./b), b);\n}\n\n// Dave Hoskins hash\nfloat hash13( in vec3 p3 ) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nconst vec3 default_debug = vec3(-100, -20, -10);\nvec3 debug = default_debug;\nconst vec3 orange = vec3(1., .5, 0.);\nconst vec3 cornflowerblue = vec3(100./255., 149./255., 237./255.);\n\nvec2 domsMouse;\n\nvec2 project(vec2 pixel) {\n    vec2 uv = pixel/iResolution.xy - vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv;\n}\n\n\nfloat circle(vec2 uv) {\n    //uv *= 2.;\n    if (length(uv)< 0.9) {\n        if (abs(uv.y) < .1) return .8;\n        return 0.3;\n    }\n    if (length(uv)< 1.) {\n        return 1.;\n    }\n    return 0.;\n    return clamp(length(uv)-8., 0., 1.);\n    return bias(1.-(abs(length(uv) - 1. +.018) / .02), .8);\n}\n// Returns a unit-length vector at a given rotation.\n// Analogous to e^(-i*theta)\n// i.e. rotate (1,0) anticlockwise for theta radians. (+y means facing up)\nvec2 e(float theta) {\n    return vec2(cos(theta), sin(theta));\n}\nfloat monochrome(vec2 uv) {\n    float height = 4.;\n    \n    const float cell_wd = 1.;\n    vec2 inner_uv = mod(uv+cell_wd, 2.*cell_wd) - cell_wd;  // position within grid cell.\n\tvec2 outer_uv = floor((uv+cell_wd)/ 2.*cell_wd);      // index of grid cell.\n    \n    \n    //vec2 angular_vel = vec2(outer_uv.yx);\n    vec2 outer_hash_pos = outer_uv + vec2(1030., 0);\n    float yaw = TAU * hash13(vec3(outer_hash_pos, 2.));\n    float angular_speed = 3. + hash13(vec3(outer_hash_pos, 3.));\n    vec2 angular_vel = angular_speed* vec2(cos(yaw), sin(yaw));\n    //if ( outer_uv.y < -1.1) debug = cornflowerblue;\n    float pitch = length(angular_vel) * (iTime+100.)*0.1;\n    vec2 a = normalize(angular_vel);  // axis of rotation\n    mat2 rot = mat2(a.x, a.y,\n                    -a.y, a.x);\n    inner_uv = rot * inner_uv;\n    inner_uv.y /= cos(pitch);\n    inner_uv = transpose(rot) * inner_uv;  // note: could be removed when our object is rotationally symmetric..\n    inner_uv *= 1.5; // don't make the circles take up the entire inner square\n\n    vec3 normal = vec3(0.0, sin(pitch), cos(pitch));\n    mat3 rot3 = mat3(a.x, a.y, 0.,\n                     -a.y, a.x, 0.,\n                     0., 0., 1.);\n    normal = transpose(rot3) * normal;\n    const vec3 LIGHT_DIR = normalize(vec3(1.5, -1.0, 2.0));\n    float light = \n        .2 + // ambient\n        .8 * smoothstep(.98, .99, abs(dot(normal, LIGHT_DIR)));  // cheap (wrong-ish) specular\n           \n    float acc = 0.;\n    acc += light * circle(inner_uv);\n    \n\treturn clamp(acc, 0., 1.);\n}\n\nfloat f(vec2 fragCoord) {\n    vec2 uv = project(fragCoord);\n    uv /= project(domsMouse.xy).xx / 3.;\n    return monochrome(uv);\n}\n\n// antialiasing\nfloat sampleSubpixel(vec2 pixels) {\n\tconst int size = 1; \n\tfloat disp = 1.0 / (float(size) + 2.0);\n\tfloat contrb = 0.0;\n\tfloat maxContrb = 0.0;\n\tfor (int j = -size; j <= size; j++) {\n\t\tfor (int i = -size; i <= size; i++) {\n\t\t\tcontrb += f(pixels + vec2(float(i) * (disp / 3.0), float(j) * disp));\n\t\t\tmaxContrb += 1.0;\n\t\t}\n\t}\n\treturn contrb / maxContrb;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    domsMouse = iMouse.xy;\n    if (iMouse.x == 0.) { domsMouse.x = iResolution.x * .5 + 30.; }\n    fragColor = vec4(orange * sampleSubpixel(fragCoord), 1.0);\n    if (debug != default_debug) fragColor.rgb = debug;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}