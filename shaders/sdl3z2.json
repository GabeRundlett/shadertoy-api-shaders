{
    "Shader": {
        "info": {
            "date": "1616320958",
            "description": "Many people use the ultra deprecated mod289 trick to generate random gradients for Perlin noise.\non some shader my OpenGL got the left half screen very wrong: this was only the iceberg tip of the ultra-loss of precision along calculus. See comments.",
            "flags": 0,
            "hasliked": 0,
            "id": "sdl3z2",
            "likes": 9,
            "name": "illustration of precision loss",
            "published": 3,
            "tags": [
                "procedural",
                "2d",
                "perlin"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 397
        },
        "renderpass": [
            {
                "code": "#if 0                                    // integer version \n\n  #define hash(v)  float( int (v) % 289 )\n  #define hashV(v) vec2( ivec2(v) % 289 )\n\n#else                                    // slight difference in the float version\n\n  #define hash(v)  mod(  floor(v), 289.)\n  #define hashV(v) hash(v)\n\n#endif\n\n// Added wrongness on OpenGL, not showing on Windows where \n// signed mod or % differs from OpenGL + silent abs() are added here and there.\n// This cause x to grow up to 1e9 on OpenGL for uv.x<0 instead of \"just\" 1e5 on Windows.\n// â†’ fract on ~ 1e5 only have 1-2 bits remaining.\n// past 1e7, fract = 0 : there are no longer any remaining bits.\n// But here even on Windows it is a problem:\n// Note the vertical bands in red: indeed, U.y influence was in the lowest bits.\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U =  10.* ( 2.*u - R ) / R.y,\n\n         p = hashV(U);\n    float x = (34. * p.x + 1.) * hash(p.x) + p.y;\n    x = (34. * x + 1.) * hash(x);\n    x /= 41.;\n    \n    O = U.y > 0. \n          ?  vec4( fract(x) )           // top: random value\n          : vec4(x/5e5,0,0,1);          // red: show x content\n    \n    if ( U.y < -8. ) \n        O = vec4( fract(1e7*u.x/R.x) ); // bottom: show fract( 0 ... 1e7 )\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}