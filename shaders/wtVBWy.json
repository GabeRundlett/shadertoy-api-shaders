{
    "Shader": {
        "info": {
            "date": "1614999848",
            "description": "The left side is 1x resolution and the right hand side is SSAA - adjust at the top",
            "flags": 0,
            "hasliked": 0,
            "id": "wtVBWy",
            "likes": 6,
            "name": "1x Resolution vs. SSAA",
            "published": 3,
            "tags": [
                "camera",
                "rotation",
                "ssaa",
                "rotationmatrix",
                "comparison"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 524
        },
        "renderpass": [
            {
                "code": "#define pi 3.1415926535897932384626433832795028841971693993751058209749445923078164\n\n#define mousesensitivity 4.0\n#define camfov 1.0\n\n#define maxmarches 1024U\n#define maxdist 8.0\n#define collisiondist 1e-2\n\n// Super-Sample Anti-Aliasing Level\n// 1 - The minimum is 1 which multiplies viewport dimensions by 2x - 4x as many pixels as normal resolution\n// 2 - multiplies viewport dimensions by 4x  - 16x  as many pixels as normal resolution\n// 4 - multiplies viewport dimensions by 8x  - 64x  as many pixels as normal resolution\n// 8 - multiplies viewport dimensions by 16x - 256x as many pixels as normal resolution\n#define SSAA 1\n\n// Rotation Matrix\nmat3 rotMat(vec3 rotation){\n    vec3 s = sin(rotation), c = cos(rotation);\n    mat3 rx = mat3(\n    1.0, 0.0, 0.0,\n    0.0, c.x,-s.x,\n    0.0, s.x, c.x);\n    mat3 ry = mat3(\n    c.y, 0.0,-s.y,\n    0.0, 1.0, 0.0,\n    s.y, 0.0, c.y);\n    mat3 rz = mat3(\n    c.z,-s.z, 0.0,\n    s.z, c.z, 0.0,\n    0.0, 0.0, 1.0);\n    return rx*ry*rz;\n}\n\n// Scene Distance Estimator\n#define iterations 4U\n#define power 8.0\nfloat de(vec3 pos){\n    if(length(pos) > 1.5){return length(pos)-1.25;}\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor(uint i = 0U; i < iterations; i++){\n\t\tr = length(z);\n\t\tif(r > 4.0){break;}\n\t\t// Convert to Polar Coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr = pow(r, power-1.0)*power*dr+1.0;\n\t\t// Scale and Rotate the Point\n\t\tfloat zr = pow(r, power);\n\t\ttheta = theta*power;\n\t\tphi = phi*power;\n\t\t\n\t\t// Convert back to Cartesian Coordinates\n\t\tz  = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz += pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n// Numerical Normals\nvec3 calcNormal(vec3 p){\n    const vec2 k = vec2(1.0, -1.0);\n    return normalize(\n    k.xyy*de(p+k.xyy*collisiondist)+\n    k.yyx*de(p+k.yyx*collisiondist)+\n    k.yxy*de(p+k.yxy*collisiondist)+\n    k.xxx*de(p+k.xxx*collisiondist));\n}\n\n// Fresnel Reflectance\nvec3 fresnel(vec3 raydir, vec3 normal){\n    vec3 F0 = vec3(1.0);\n    return F0+(1.0-F0)*pow(1.0-dot(-raydir, normal), 5.0);\n}\n\n// Ray-Marching\nvec3 raymarch(vec3 raydir, vec3 rayori){\n    vec3 raypos = rayori;\n    float distest;\n    for(uint i = 0U; i < maxmarches; i++){\n        if(length(raypos-rayori) > maxdist){break;}\n        distest = de(raypos);\n        if(distest < collisiondist){\n            vec3 normal = calcNormal(raypos);\n            vec3 reflectance = fresnel(raydir, normal);\n            raydir = reflect(raydir, normal);\n            return reflectance*texture(iChannel0, raydir).rgb;\n        }\n        raypos += raydir*distest*0.25;\n    }\n    return texture(iChannel0, raydir).rgb;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = vec4(0.0);\n    if(abs(fragCoord.x-0.5*iResolution.x) < 1.0){\n        fragColor = vec4(1.0);\n        return;\n    }\n    vec2 uv     = 2.0*(fragCoord-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n    vec2 mouse  = vec2(iTime*pi*0.125, 0.0);\n    mat3 rotmat = rotMat(vec3(0.0, mouse.x, 0.0));\n    // Super-Sampled Half of Screen\n    if(fragCoord.x > iResolution.x/2.0 && length(uv) < 0.4){\n    for(int y = -SSAA; y < SSAA; y++){\n    for(int x = -SSAA; x < SSAA; x++){\n        vec2 uv     = 2.0*((fragCoord+(vec2(x, y)/float(SSAA*2)))-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n        vec3 raydir = normalize(camfov*(uv.x*rotmat[0]+uv.y*rotmat[1])+rotmat[2]);\n        vec3 color  = raymarch(raydir, vec3(-sin(mouse.x)*4.0, 0.0, -cos(mouse.x)*4.0));\n        fragColor  += vec4(color, 1.0);\n    }\n    }\n    }\n    // 1x Resolution Half of Screen\n    else{\n        vec3 raydir = normalize(camfov*(uv.x*rotmat[0]+uv.y*rotmat[1])+rotmat[2]);\n        vec3 color  = raymarch(raydir, vec3(-sin(mouse.x)*4.0, 0.0, -cos(mouse.x)*4.0));\n        fragColor   = vec4(color, 1.0);\n        return;\n    }\n    fragColor = vec4(fragColor.rgb/fragColor.a, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}