{
    "Shader": {
        "info": {
            "date": "1632807608",
            "description": "An extension of the voxel shaderby jt: Cast Voxels March Sub-Objects\nhttps://www.shadertoy.com/view/7sdSzH\nThis(my code) is not an efficient example of a voxel renderer. Just a proof of \nconcept, here showing clearly that the reflections are accurate. ",
            "flags": 0,
            "hasliked": 0,
            "id": "7sdSzN",
            "likes": 6,
            "name": "Voxel Sub-Object Relfections #3",
            "published": 3,
            "tags": [
                "reflection",
                "voxel",
                "subobject"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 267
        },
        "renderpass": [
            {
                "code": "/*\n\nVoxel Sub-Object Reflections\nAn extension of the voxel shader by jt:\n\nCast Voxels March Sub-Objects\nhttps://www.shadertoy.com/view/7sdSzH\n\nThis shader demonstrates reflections within\na voxel shader, that reflect the image based on\nwhat objects (SDFs in this case) are stored\ninside each voxel.\n\nThere is another purely voxel relflection shader\nby wildniklin:\nVoxel Reflections\nhttps://www.shadertoy.com/view/NsjSWy\n\nand iq has another voxel shader with sub-voxel\nobjects with emissive objects (so multiple light \nbounces)\n\nBTW this could be way faster. I did everything \nin the voxel marching the slowest way with branching.\n\nIt was more for me to review what is actually going\non. \n\nThe code is bloated over all.\n*/\n#define far 50.\n\nfloat formID = 0.;\nfloat sdSphere(vec3 p, float d)\n{\n    return length(p) - d;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat Sphere_Box_LERP(vec3 p){\n\n    float id = formID;\n    \n    float left = (sdBox(p,vec3(0.3)) - id/6.)*(step(0.,p.x));\n    float right = (sdSphere(p,0.5))*(step(p.x,0.));\n    //return  right;\n    return mix(sdSphere(p,0.5),\n               sdBox(p,vec3(id*0.4)) \n               - (1.-id*0.3)/4., id);\n    \n}\nbool getVoxel(vec3 c) {\n    //c.xz *= rot(iTime);\n    vec3 p = vec3(c) + vec3(0.5);\n    float d = min(sdSphere(p-vec3(-4.,0.,0.), 2.5), \n                  sdBox(p-vec3(4.,0.,0.), vec3(2.0)));\n    //float d = min(max(-sdSphere(p, 7.5), sdBox(p, vec3(6.0))), -sdSphere(p, 25.0));\n    return d < 0.0;\n}\n\n\n\nbool map(vec3 p){\n    return getVoxel(p);\n    //return length(p) - 1.5 < 0.;//\n    return (5.-length(p.xy + vec2(sin(p.z/8.)*6., 0.))) < 0.00;\n}\n\nfloat fMap(vec3 p){\n    \n    return Sphere_Box_LERP(p);\n    return length(p)-0.5;\n}\n\n\nvec3 ray(vec2 uv, vec3 ro, vec3 lk){\n    vec3 fwr = normalize(lk - ro);\n    vec3 uu = vec3(0.,1.,0.);\n    vec3 ri = cross(uu,fwr);\n    vec3 up = cross(fwr,ri);\n    return normalize(ri * uv.x + up * uv.y + fwr);\n}\n\nvec3 normal(vec3 p){\n\n    vec2 e = vec2(0.001,0.);\n    return normalize(vec3(\n    fMap(p - e.xyy) - fMap(p + e.xyy),\n    fMap(p - e.yxy) - fMap(p + e.yxy),\n    fMap(p - e.yyx) - fMap(p + e.yyx)\n    ));\n}\n\nfloat trace(vec3 ro,vec3 rd){\n    float t = 0., d;\n    \n    for(float i = 0.; i < 50.; i++){\n        d = fMap(ro + rd*t);\n        \n        if(d < 0.001 ) return t;\n        \n        t += d;\n    }\n    return far;\n}\n\nfloat voxelTrace(inout vec3 ro, \n                 inout vec3 rd,\n                 inout vec3 col){\n\n    vec3 pos = floor(ro);\n    vec3 delta = abs(1./rd + 0.001);\n    vec3 steps = vec3(0.);\n    \n    vec3 light1 = vec3(0.,sin(iTime)*8.,0.);\n    \n    steps.x = rd.x < 0. ? \n      (ro.x - pos.x)*delta.x : \n      (pos.x + 1. - ro.x)*delta.x;\n    \n    steps.y = rd.y < 0. ? \n      (ro.y - pos.y)*delta.y : \n      (pos.y + 1. - ro.y)*delta.y;\n      \n    steps.z = rd.z < 0. ? \n      (ro.z - pos.z)*delta.z : \n      (pos.z + 1. - ro.z)*delta.z;\n    \n    vec3 richtung = sign(rd);\n    \n    float t = 100.;\n    \n    for(int i = 0; i < 100; i++ ){\n    \n        if(map(pos)) {\n            //throw this in here, make a global\n            //id for the shape of the  sub-object.\n            float id = rnd(pos);\n            formID = id;\n            \n            // this: ro - pos - 0.5; shifts the \n            // null forward because we always check \n            // the space around 0.,0.! \n            // and -0.5 is for the same reason \n            // because we always shoot rays in from \n            // a place on a cube, it's like \n            // shooting into a square screen and \n            // we need to shift the world \n            // 0.5 in every dimention \n            vec3 shift = pos + 0.5;\n            //  the - shift is then \n            // -(pow + 0.5) = -pos - 0.5\n            \n            \n                   \n                   \n            float h = trace(ro - shift, rd);\n            \n               if( h < far && h > 0.){\n                   \n                   t = h;\n                   vec3 p = (ro - shift + rd*t);\n                   \n                   vec3 l = light1 - shift;\n                   vec3 ldir = l - p;\n                   vec3 n = normal(p);\n                   \n                   float ldist = max(length(l),0.);\n                   ldir/=ldist;\n                   \n                   float diff = max(dot(-ldir,n),0.);\n                   float spec = pow(max(dot(reflect(-ldir,n),-rd),0.),8.);\n                   \n                   col += diff*vec3(0.5,id,id*id)*1.+ spec;\n                   \n                   //needed a plus five here to work!\n                   //wow\n                   ro = pos + 0.5;// + n*.01;//nothing changes\n                   rd = reflect(rd, n);\n                   // + n*0.01;\n                   \n                   return h;\n            }\n            \n        }\n        \n        if(min(steps.x,min(steps.y,steps.z)) \n            == steps.x){\n            //adding 1's and -1's to the position\n            pos.x += richtung.x;\n            //adding delta components to the t line\n            steps.x += delta.x;\n        }\n        else if(min(steps.x,min(steps.y,steps.z)) \n                    == steps.y){    \n            pos.y += richtung.y;\n            steps.y += delta.y;\n        }\n        else\n        {\n            pos.z += richtung.z;\n            steps.z += delta.z;\n        }\n    }\n    return far;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0.,0., -4.);\n    ro.xz*= rot(iTime/8.);\n    vec3 lk = vec3(0.,0.,0.);\n    vec3 rd = ray(uv, ro, lk);\n    //rd.xz*= rot(iTime);\n    vec3 col = vec3(0.);\n    vec3 rcol = vec3(0.);\n    // Time varying pixel color\n   float t = voxelTrace(ro,rd,col);\n   if(t < far) voxelTrace(ro,rd,rcol);\n   //col = vec3((1.-t)*vec3(0.7,0.37,0.0));\n   col += rcol*0.38;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "mat2 rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat rnd(vec3 st){\n    return fract(sin(dot(vec2(12.44,74.92),st.xz) + st.y)*43134.0);\n    }\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}