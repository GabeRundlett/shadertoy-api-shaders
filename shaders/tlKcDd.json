{
    "Shader": {
        "info": {
            "date": "1612041271",
            "description": "pot",
            "flags": 0,
            "hasliked": 0,
            "id": "tlKcDd",
            "likes": 21,
            "name": "Day 410",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 553
        },
        "renderpass": [
            {
                "code": "\n// Cyclic Noise from nimitz. \n// fwidth analytic SDF AA suggested by Fabrice (another solution suggested before that by mla, who afaik found it from iq)\n\n// check out triangle mode in common\n\n\nconst float slices = 124.;\n\nconst float sliceDepth = 2.;\n\nfloat yOffs = 1.5;\n\nconst float width = 0.;\n\nconst float aaSteps = 1.; // aa unused\n\n\nfloat fun(vec3 p){\n    float f = 0.;\n    \n    p.z += iTime;\n    f += cyclicNoise(p*2. + vec3(0,iTime*0.2,0), true, iTime*0.1)\n        - mix(-0.5,2.,smoothstep(0.,1.,-p.y))\n        + mix(2.,0.,smoothstep(0.,1.,-abs(p.y )+ yOffs ));\n        \n    f = max(f,-dot(p.xy,p.xy) + 0.);\n\n\n    return f;\n}\n\n\n\n\nvec3 get(in vec2 fragCoord){\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0,yOffs,0);\n    \n    vec3 rd = normalize(vec3(uv,3));\n    rd.yz *= rot(0.4);\n    \n    for(float i = 0.; i < slices; i++ ){\n        \n        float t = plaIntersect( ro - vec3(0,i/slices*sliceDepth,0.), rd, vec4(0,1,0,1.) );\n        t = abs(t);\n        vec3 p = ro + rd*t;\n        \n        float fn = fun(p);\n        \n        \n        float fw = fwidth(fn) ;\n        \n        \n        vec3 c = pal(0.5,vec3(0.6,0.05,.15),vec3(4.9,1.,9),1.,i/slices*22. + iTime*1.);\n        \n        float d = (fn)/fw;\n        \n        float g = smoothstep(1.,0.,abs(d)- width);\n        float gb = smoothstep(1.,0.,d - width);\n        \n        \n        col = mix(col, c*c*0.7*1. + 0.*smoothstep(1.51,0.,abs(fn)*20.0005), gb);\n        col = mix(col, c*2., g);\n        col = max(col,0.);\n\n\n         \n        \n        /*\n            col = mix(col, c*c*0.7, gb);\n            col = mix(col, c*2., g);\n        \n        }*/\n        \n    }\n    \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    \n    for(float i =0.; i < aaSteps*aaSteps + min(float(iFrame),0.)   ; i++){\n    \tcol += get(fragCoord + vec2(mod(i,aaSteps),floor(i/aaSteps))/aaSteps);\n    }\n    col /= aaSteps*aaSteps;\n    \n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    col = mix(col,col*col*0.1,exp(-dot(uv,uv)*5422.));\n    \n    col = max(col, 0.);\n\t\n    \n    col = pow(col,vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n#define pal(a,b,c,d,e) ((a) +(b)*sin((c)*(d) + (e)))\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n\n// TRIANGLE MODE - substitutes sine for tri \n//#define sin(a) (asin(sin(a))*1.)\n\n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\nfloat cyclicNoise(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    float amp = 1.;\n    float gain = 0.8 + sin(p.z*0.2)*0.2;\n    const float lacunarity = 1.4;\n    const int octaves = 5;\n    \n    const float warp = 1.2;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .2;\n    \n    vec3 seed = vec3(-4,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\n\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}