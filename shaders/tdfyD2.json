{
    "Shader": {
        "info": {
            "date": "1585593227",
            "description": "Animal Crossing\nBase on\nhttps://github.com/libretro/common-shaders/blob/master/xbrz/shaders/4xbrz.cg",
            "flags": 0,
            "hasliked": 0,
            "id": "tdfyD2",
            "likes": 17,
            "name": "Animal Crossing xBR 4x",
            "published": 3,
            "tags": [
                "pixel",
                "pixelated",
                "xbr",
                "animalcrossing"
            ],
            "usePreview": 0,
            "username": "yuchengzhong",
            "viewed": 1091
        },
        "renderpass": [
            {
                "code": "//Base on\n//https://github.com/libretro/common-shaders/blob/master/xbrz/shaders/4xbrz.cg\n\n#define LUMINANCE_WEIGHT 1.0\n#define EQUAL_COLOR_TOLERANCE 20.0/255.0\n#define DOMINANT_DIRECTION_THRESHOLD 2.6\n#define STEEP_DIRECTION_THRESHOLD 4.6\nfloat DistYCbCr(const vec3 pixA, const vec3 pixB)\n{\n\tconst vec3 w = vec3(0.2627, 0.6780, 0.0593);\n\tconst float scaleB = 0.5 / (1.0 - w.b);\n\tconst float scaleR = 0.5 / (1.0 - w.r);\n\tvec3 diff = pixA - pixB;\n\tfloat Y = dot(diff, w);\n\tfloat Cb = scaleB * (diff.b - Y);\n\tfloat Cr = scaleR * (diff.r - Y);\n\t\t\n\treturn sqrt( ((LUMINANCE_WEIGHT * Y) * (LUMINANCE_WEIGHT * Y)) + (Cb * Cb) + (Cr * Cr) );\n}\n\t\nbool IsPixEqual(const vec3 pixA, const vec3 pixB)\n{\n\treturn (DistYCbCr(pixA, pixB) < EQUAL_COLOR_TOLERANCE);\n}\nfloat reduce(const vec3 color)\n{\n\treturn dot(color, vec3(65536.0, 256.0, 1.0));\n}\t\nbool IsBlendingNeeded(const int blend0,const int blend1,const int blend2,const int blend3)\n{\n\t//return any(!(blend == int4(BLEND_NONE,BLEND_NONE,BLEND_NONE,BLEND_NONE)));\n    return blend0 != 0||blend1 != 0||blend2 != 0||blend3 != 0;\n}\n\t\n\t//---------------------------------------\n\t// Input Pixel Mapping:  --|21|22|23|--\n\t//                       19|06|07|08|09\n\t//                       18|05|00|01|10\n\t//                       17|04|03|02|11\n\t//                       --|15|14|13|--\n\t//\n\t// Output Pixel Mapping:  06|07|08|09\n\t//                        05|00|01|10\n\t//                        04|03|02|11\n\t//                        15|14|13|12\n\n\n/* FRAGMENT SHADER */\nvec3 four_xBRZ(vec2 texture_size,vec2 texCoord)\n{\n\n\tvec2 f = fract(texCoord*texture_size);\n\n\t//---------------------------------------\n\t// Input Pixel Mapping:  20|21|22|23|24\n\t//                       19|06|07|08|09\n\t//                       18|05|00|01|10\n\t//                       17|04|03|02|11\n\t//                       16|15|14|13|12\n    float dx = 1.0/texture_size.x;\n    float dy = 1.0/texture_size.y;\n    vec4 t1 = texCoord.xxxy + vec4( -dx, 0, dx,-2.0*dy); // A1 B1 C1\n\tvec4 t2 = texCoord.xxxy + vec4( -dx, 0, dx, -dy); // A B C\n\tvec4 t3 = texCoord.xxxy + vec4( -dx, 0, dx, 0); // D E F\n\tvec4 t4 = texCoord.xxxy + vec4( -dx, 0, dx, dy); // G H I\n\tvec4 t5 = texCoord.xxxy + vec4( -dx, 0, dx, 2.0*dy); // G5 H5 I5\n\tvec4 t6 = texCoord.xyyy + vec4(-2.0*dx,-dy, 0, dy); // A0 D0 G0\n\tvec4 t7 = texCoord.xyyy + vec4( 2.0*dx,-dy, 0, dy); // C4 F4 I4\n\tvec3 src[25];\n  \n\tsrc[21] = texture(iChannel0, floor(t1.xw*texture_size)/texture_size).rgb;\n\tsrc[22] = texture(iChannel0, floor(t1.yw*texture_size)/texture_size).rgb;\n\tsrc[23] = texture(iChannel0, floor(t1.zw*texture_size)/texture_size).rgb;\n\tsrc[ 6] = texture(iChannel0, floor(t2.xw*texture_size)/texture_size).rgb;\n\tsrc[ 7] = texture(iChannel0, floor(t2.yw*texture_size)/texture_size).rgb;\n\tsrc[ 8] = texture(iChannel0, floor(t2.zw*texture_size)/texture_size).rgb;\n\tsrc[ 5] = texture(iChannel0, floor(t3.xw*texture_size)/texture_size).rgb;\n\tsrc[ 0] = texture(iChannel0, floor(t3.yw*texture_size)/texture_size).rgb;\n\tsrc[ 1] = texture(iChannel0, floor(t3.zw*texture_size)/texture_size).rgb;\n\tsrc[ 4] = texture(iChannel0, floor(t4.xw*texture_size)/texture_size).rgb;\n\tsrc[ 3] = texture(iChannel0, floor(t4.yw*texture_size)/texture_size).rgb;\n\tsrc[ 2] = texture(iChannel0, floor(t4.zw*texture_size)/texture_size).rgb;\n\tsrc[15] = texture(iChannel0, floor(t5.xw*texture_size)/texture_size).rgb;\n\tsrc[14] = texture(iChannel0, floor(t5.yw*texture_size)/texture_size).rgb;\n\tsrc[13] = texture(iChannel0, floor(t5.zw*texture_size)/texture_size).rgb;\n\tsrc[19] = texture(iChannel0, floor(t6.xy*texture_size)/texture_size).rgb;\n\tsrc[18] = texture(iChannel0, floor(t6.xz*texture_size)/texture_size).rgb;\n\tsrc[17] = texture(iChannel0, floor(t6.xw*texture_size)/texture_size).rgb;\n\tsrc[ 9] = texture(iChannel0, floor(t7.xy*texture_size)/texture_size).rgb;\n\tsrc[10] = texture(iChannel0, floor(t7.xz*texture_size)/texture_size).rgb;\n\tsrc[11] = texture(iChannel0, floor(t7.xw*texture_size)/texture_size).rgb;\n\n\t\tfloat v[9];\n\t\tv[0] = reduce(src[0]);\n\t\tv[1] = reduce(src[1]);\n\t\tv[2] = reduce(src[2]);\n\t\tv[3] = reduce(src[3]);\n\t\tv[4] = reduce(src[4]);\n\t\tv[5] = reduce(src[5]);\n\t\tv[6] = reduce(src[6]);\n\t\tv[7] = reduce(src[7]);\n\t\tv[8] = reduce(src[8]);\n\t\t\n\t\tint blendResult0 = 0;\n\t\tint blendResult1 = 1;\n\t\tint blendResult2 = 2;\n\t\tint blendResult3 = 3;\n\t\t\n\t\t// Preprocess corners\n\t\t// Pixel Tap Mapping: --|--|--|--|--\n\t\t//                    --|--|07|08|--\n\t\t//                    --|05|00|01|10\n\t\t//                    --|04|03|02|11\n\t\t//                    --|--|14|13|--\n\t\t\n\t\t// Corner (1, 1)\n\t\tif ( !((v[0] == v[1] && v[3] == v[2]) || (v[0] == v[3] && v[1] == v[2])) )\n\t\t{\n\t\t\tfloat dist_03_01 = DistYCbCr(src[ 4], src[ 0]) + DistYCbCr(src[ 0], src[ 8]) + DistYCbCr(src[14], src[ 2]) + DistYCbCr(src[ 2], src[10]) + (4.0 * DistYCbCr(src[ 3], src[ 1]));\n\t\t\tfloat dist_00_02 = DistYCbCr(src[ 5], src[ 3]) + DistYCbCr(src[ 3], src[13]) + DistYCbCr(src[ 7], src[ 1]) + DistYCbCr(src[ 1], src[11]) + (4.0 * DistYCbCr(src[ 0], src[ 2]));\n\t\t\tbool dominantGradient = (DOMINANT_DIRECTION_THRESHOLD * dist_03_01) < dist_00_02;\n\t\t\tblendResult2 = ((dist_03_01 < dist_00_02) && (v[0] != v[1]) && (v[0] != v[3])) ? ((dominantGradient) ? 2 : 1) : 0;\n\t\t}\n\t\t\n\t\t\n\t\t// Pixel Tap Mapping: --|--|--|--|--\n\t\t//                    --|06|07|--|--\n\t\t//                    18|05|00|01|--\n\t\t//                    17|04|03|02|--\n\t\t//                    --|15|14|--|--\n\t\t// Corner (0, 1)\n\t\tif ( !((v[5] == v[0] && v[4] == v[3]) || (v[5] == v[4] && v[0] == v[3])) )\n\t\t{\n\t\t\tfloat dist_04_00 = DistYCbCr(src[17], src[ 5]) + DistYCbCr(src[ 5], src[ 7]) + DistYCbCr(src[15], src[ 3]) + DistYCbCr(src[ 3], src[ 1]) + (4.0 * DistYCbCr(src[ 4], src[ 0]));\n\t\t\tfloat dist_05_03 = DistYCbCr(src[18], src[ 4]) + DistYCbCr(src[ 4], src[14]) + DistYCbCr(src[ 6], src[ 0]) + DistYCbCr(src[ 0], src[ 2]) + (4.0 * DistYCbCr(src[ 5], src[ 3]));\n\t\t\tbool dominantGradient = (DOMINANT_DIRECTION_THRESHOLD * dist_05_03) < dist_04_00;\n\t\t\tblendResult3 = ((dist_04_00 > dist_05_03) && (v[0] != v[5]) && (v[0] != v[3])) ? ((dominantGradient) ? 2 : 1) : 0;\n\t\t}\n\t\t\n\t\t// Pixel Tap Mapping: --|--|22|23|--\n\t\t//                    --|06|07|08|09\n\t\t//                    --|05|00|01|10\n\t\t//                    --|--|03|02|--\n\t\t//                    --|--|--|--|--\n\t\t// Corner (1, 0)\n\t\tif ( !((v[7] == v[8] && v[0] == v[1]) || (v[7] == v[0] && v[8] == v[1])) )\n\t\t{\n\t\t\tfloat dist_00_08 = DistYCbCr(src[ 5], src[ 7]) + DistYCbCr(src[ 7], src[23]) + DistYCbCr(src[ 3], src[ 1]) + DistYCbCr(src[ 1], src[ 9]) + (4.0 * DistYCbCr(src[ 0], src[ 8]));\n\t\t\tfloat dist_07_01 = DistYCbCr(src[ 6], src[ 0]) + DistYCbCr(src[ 0], src[ 2]) + DistYCbCr(src[22], src[ 8]) + DistYCbCr(src[ 8], src[10]) + (4.0 * DistYCbCr(src[ 7], src[ 1]));\n\t\t\tbool dominantGradient = (DOMINANT_DIRECTION_THRESHOLD * dist_07_01) < dist_00_08;\n\t\t\tblendResult1 = ((dist_00_08 > dist_07_01) && (v[0] != v[7]) && (v[0] != v[1])) ? ((dominantGradient) ? 2 : 1) : 0;\n\t\t}\n\t\t\n\t\t// Pixel Tap Mapping: --|21|22|--|--\n\t\t//                    19|06|07|08|--\n\t\t//                    18|05|00|01|--\n\t\t//                    --|04|03|--|--\n\t\t//                    --|--|--|--|--\n\t\t// Corner (0, 0)\n\t\tif ( !((v[6] == v[7] && v[5] == v[0]) || (v[6] == v[5] && v[7] == v[0])) )\n\t\t{\n\t\t\tfloat dist_05_07 = DistYCbCr(src[18], src[ 6]) + DistYCbCr(src[ 6], src[22]) + DistYCbCr(src[ 4], src[ 0]) + DistYCbCr(src[ 0], src[ 8]) + (4.0 * DistYCbCr(src[ 5], src[ 7]));\n\t\t\tfloat dist_06_00 = DistYCbCr(src[19], src[ 5]) + DistYCbCr(src[ 5], src[ 3]) + DistYCbCr(src[21], src[ 7]) + DistYCbCr(src[ 7], src[ 1]) + (4.0 * DistYCbCr(src[ 6], src[ 0]));\n\t\t\tbool dominantGradient = (DOMINANT_DIRECTION_THRESHOLD * dist_05_07) < dist_06_00;\n\t\t\tblendResult0 = ((dist_05_07 < dist_06_00) && (v[0] != v[5]) && (v[0] != v[7])) ? ((dominantGradient) ? 2 : 1) : 0;\n\t\t}\n\t\t\n\t\tvec3 dst[16];\n\t\tdst[ 0] = src[0];\n\t\tdst[ 1] = src[0];\n\t\tdst[ 2] = src[0];\n\t\tdst[ 3] = src[0];\n\t\tdst[ 4] = src[0];\n\t\tdst[ 5] = src[0];\n\t\tdst[ 6] = src[0];\n\t\tdst[ 7] = src[0];\n\t\tdst[ 8] = src[0];\n\t\tdst[ 9] = src[0];\n\t\tdst[10] = src[0];\n\t\tdst[11] = src[0];\n\t\tdst[12] = src[0];\n\t\tdst[13] = src[0];\n\t\tdst[14] = src[0];\n\t\tdst[15] = src[0];\n\t\t\n\t\t// Scale pixel\n\t\tif (IsBlendingNeeded(blendResult0,blendResult1,blendResult2,blendResult3))\n\t\t{\n\t\t\tfloat dist_01_04 = DistYCbCr(src[1], src[4]);\n\t\t\tfloat dist_03_08 = DistYCbCr(src[3], src[8]);\n\t\t\tbool haveShallowLine = (STEEP_DIRECTION_THRESHOLD * dist_01_04 <= dist_03_08) && (v[0] != v[4]) && (v[5] != v[4]);\n\t\t\tbool haveSteepLine   = (STEEP_DIRECTION_THRESHOLD * dist_03_08 <= dist_01_04) && (v[0] != v[8]) && (v[7] != v[8]);\n\t\t\tbool needBlend = (blendResult2 != 0);\n\t\t\tbool doLineBlend = (  blendResult2 >= 2 ||\n\t\t\t\t\t\t\t   !((blendResult1 != 0 && !IsPixEqual(src[0], src[4])) ||\n\t\t\t\t\t\t\t\t (blendResult3 != 0 && !IsPixEqual(src[0], src[8])) ||\n\t\t\t\t\t\t\t\t (IsPixEqual(src[4], src[3]) && IsPixEqual(src[3], src[2]) && IsPixEqual(src[2], src[1]) && IsPixEqual(src[1], src[8]) && !IsPixEqual(src[0], src[2])) ) );\n\t\t\t\n\t\t\tvec3 blendPix = ( DistYCbCr(src[0], src[1]) <= DistYCbCr(src[0], src[3]) ) ? src[1] : src[3];\n\t\t\tdst[ 2] = mix(dst[ 2], blendPix, (needBlend && doLineBlend) ? ((haveShallowLine) ? ((haveSteepLine) ? 1.0/3.0 : 0.25) : ((haveSteepLine) ? 0.25 : 0.00)) : 0.00);\n\t\t\tdst[ 9] = mix(dst[ 9], blendPix, (needBlend && doLineBlend && haveSteepLine) ? 0.25 : 0.00);\n\t\t\tdst[10] = mix(dst[10], blendPix, (needBlend && doLineBlend && haveSteepLine) ? 0.75 : 0.00);\n\t\t\tdst[11] = mix(dst[11], blendPix, (needBlend) ? ((doLineBlend) ? ((haveSteepLine) ? 1.00 : ((haveShallowLine) ? 0.75 : 0.50)) : 0.08677704501) : 0.00);\n\t\t\tdst[12] = mix(dst[12], blendPix, (needBlend) ? ((doLineBlend) ? 1.00 : 0.6848532563) : 0.00);\n\t\t\tdst[13] = mix(dst[13], blendPix, (needBlend) ? ((doLineBlend) ? ((haveShallowLine) ? 1.00 : ((haveSteepLine) ? 0.75 : 0.50)) : 0.08677704501) : 0.00);\n\t\t\tdst[14] = mix(dst[14], blendPix, (needBlend && doLineBlend && haveShallowLine) ? 0.75 : 0.00);\n\t\t\tdst[15] = mix(dst[15], blendPix, (needBlend && doLineBlend && haveShallowLine) ? 0.25 : 0.00);\n\t\t\t\n\t\t\t\n\t\t\tdist_01_04 = DistYCbCr(src[7], src[2]);\n\t\t\tdist_03_08 = DistYCbCr(src[1], src[6]);\n\t\t\thaveShallowLine = (STEEP_DIRECTION_THRESHOLD * dist_01_04 <= dist_03_08) && (v[0] != v[2]) && (v[3] != v[2]);\n\t\t\thaveSteepLine   = (STEEP_DIRECTION_THRESHOLD * dist_03_08 <= dist_01_04) && (v[0] != v[6]) && (v[5] != v[6]);\n\t\t\tneedBlend = (blendResult1 != 0);\n\t\t\tdoLineBlend = (  blendResult1 >= 2 ||\n\t\t\t\t\t\t  !((blendResult0 != 0 && !IsPixEqual(src[0], src[2])) ||\n\t\t\t\t\t\t\t(blendResult2 != 0 && !IsPixEqual(src[0], src[6])) ||\n\t\t\t\t\t\t\t(IsPixEqual(src[2], src[1]) && IsPixEqual(src[1], src[8]) && IsPixEqual(src[8], src[7]) && IsPixEqual(src[7], src[6]) && !IsPixEqual(src[0], src[8])) ) );\n\t\t\t\n\t\t\tblendPix = ( DistYCbCr(src[0], src[7]) <= DistYCbCr(src[0], src[1]) ) ? src[7] : src[1];\n\t\t\tdst[ 1] = mix(dst[ 1], blendPix, (needBlend && doLineBlend) ? ((haveShallowLine) ? ((haveSteepLine) ? 1.0/3.0 : 0.25) : ((haveSteepLine) ? 0.25 : 0.00)) : 0.00);\n\t\t\tdst[ 6] = mix(dst[ 6], blendPix, (needBlend && doLineBlend && haveSteepLine) ? 0.25 : 0.00);\n\t\t\tdst[ 7] = mix(dst[ 7], blendPix, (needBlend && doLineBlend && haveSteepLine) ? 0.75 : 0.00);\n\t\t\tdst[ 8] = mix(dst[ 8], blendPix, (needBlend) ? ((doLineBlend) ? ((haveSteepLine) ? 1.00 : ((haveShallowLine) ? 0.75 : 0.50)) : 0.08677704501) : 0.00);\n\t\t\tdst[ 9] = mix(dst[ 9], blendPix, (needBlend) ? ((doLineBlend) ? 1.00 : 0.6848532563) : 0.00);\n\t\t\tdst[10] = mix(dst[10], blendPix, (needBlend) ? ((doLineBlend) ? ((haveShallowLine) ? 1.00 : ((haveSteepLine) ? 0.75 : 0.50)) : 0.08677704501) : 0.00);\n\t\t\tdst[11] = mix(dst[11], blendPix, (needBlend && doLineBlend && haveShallowLine) ? 0.75 : 0.00);\n\t\t\tdst[12] = mix(dst[12], blendPix, (needBlend && doLineBlend && haveShallowLine) ? 0.25 : 0.00);\n\t\t\t\n\t\t\t\n\t\t\tdist_01_04 = DistYCbCr(src[5], src[8]);\n\t\t\tdist_03_08 = DistYCbCr(src[7], src[4]);\n\t\t\thaveShallowLine = (STEEP_DIRECTION_THRESHOLD * dist_01_04 <= dist_03_08) && (v[0] != v[8]) && (v[1] != v[8]);\n\t\t\thaveSteepLine   = (STEEP_DIRECTION_THRESHOLD * dist_03_08 <= dist_01_04) && (v[0] != v[4]) && (v[3] != v[4]);\n\t\t\tneedBlend = (blendResult0 != 0);\n\t\t\tdoLineBlend = (  blendResult0 >= 2 ||\n\t\t\t\t\t\t  !((blendResult3 != 0 && !IsPixEqual(src[0], src[8])) ||\n\t\t\t\t\t\t\t(blendResult1 != 0 && !IsPixEqual(src[0], src[4])) ||\n\t\t\t\t\t\t\t(IsPixEqual(src[8], src[7]) && IsPixEqual(src[7], src[6]) && IsPixEqual(src[6], src[5]) && IsPixEqual(src[5], src[4]) && !IsPixEqual(src[0], src[6])) ) );\n\t\t\t\n\t\t\tblendPix = ( DistYCbCr(src[0], src[5]) <= DistYCbCr(src[0], src[7]) ) ? src[5] : src[7];\n\t\t\tdst[ 0] = mix(dst[ 0], blendPix, (needBlend && doLineBlend) ? ((haveShallowLine) ? ((haveSteepLine) ? 1.0/3.0 : 0.25) : ((haveSteepLine) ? 0.25 : 0.00)) : 0.00);\n\t\t\tdst[15] = mix(dst[15], blendPix, (needBlend && doLineBlend && haveSteepLine) ? 0.25 : 0.00);\n\t\t\tdst[ 4] = mix(dst[ 4], blendPix, (needBlend && doLineBlend && haveSteepLine) ? 0.75 : 0.00);\n\t\t\tdst[ 5] = mix(dst[ 5], blendPix, (needBlend) ? ((doLineBlend) ? ((haveSteepLine) ? 1.00 : ((haveShallowLine) ? 0.75 : 0.50)) : 0.08677704501) : 0.00);\n\t\t\tdst[ 6] = mix(dst[ 6], blendPix, (needBlend) ? ((doLineBlend) ? 1.00 : 0.6848532563) : 0.00);\n\t\t\tdst[ 7] = mix(dst[ 7], blendPix, (needBlend) ? ((doLineBlend) ? ((haveShallowLine) ? 1.00 : ((haveSteepLine) ? 0.75 : 0.50)) : 0.08677704501) : 0.00);\n\t\t\tdst[ 8] = mix(dst[ 8], blendPix, (needBlend && doLineBlend && haveShallowLine) ? 0.75 : 0.00);\n\t\t\tdst[ 9] = mix(dst[ 9], blendPix, (needBlend && doLineBlend && haveShallowLine) ? 0.25 : 0.00);\n\t\t\t\n\t\t\t\n\t\t\tdist_01_04 = DistYCbCr(src[3], src[6]);\n\t\t\tdist_03_08 = DistYCbCr(src[5], src[2]);\n\t\t\thaveShallowLine = (STEEP_DIRECTION_THRESHOLD * dist_01_04 <= dist_03_08) && (v[0] != v[6]) && (v[7] != v[6]);\n\t\t\thaveSteepLine   = (STEEP_DIRECTION_THRESHOLD * dist_03_08 <= dist_01_04) && (v[0] != v[2]) && (v[1] != v[2]);\n\t\t\tneedBlend = (blendResult3 != 0);\n\t\t\tdoLineBlend = (  blendResult3 >= 2 ||\n\t\t\t\t\t\t  !((blendResult2 != 0 && !IsPixEqual(src[0], src[6])) ||\n\t\t\t\t\t\t\t(blendResult0 != 0 && !IsPixEqual(src[0], src[2])) ||\n\t\t\t\t\t\t\t(IsPixEqual(src[6], src[5]) && IsPixEqual(src[5], src[4]) && IsPixEqual(src[4], src[3]) && IsPixEqual(src[3], src[2]) && !IsPixEqual(src[0], src[4])) ) );\n\t\t\t\n\t\t\tblendPix = ( DistYCbCr(src[0], src[3]) <= DistYCbCr(src[0], src[5]) ) ? src[3] : src[5];\n\t\t\tdst[ 3] = mix(dst[ 3], blendPix, (needBlend && doLineBlend) ? ((haveShallowLine) ? ((haveSteepLine) ? 1.0/3.0 : 0.25) : ((haveSteepLine) ? 0.25 : 0.00)) : 0.00);\n\t\t\tdst[12] = mix(dst[12], blendPix, (needBlend && doLineBlend && haveSteepLine) ? 0.25 : 0.00);\n\t\t\tdst[13] = mix(dst[13], blendPix, (needBlend && doLineBlend && haveSteepLine) ? 0.75 : 0.00);\n\t\t\tdst[14] = mix(dst[14], blendPix, (needBlend) ? ((doLineBlend) ? ((haveSteepLine) ? 1.00 : ((haveShallowLine) ? 0.75 : 0.50)) : 0.08677704501) : 0.00);\n\t\t\tdst[15] = mix(dst[15], blendPix, (needBlend) ? ((doLineBlend) ? 1.00 : 0.6848532563) : 0.00);\n\t\t\tdst[ 4] = mix(dst[ 4], blendPix, (needBlend) ? ((doLineBlend) ? ((haveShallowLine) ? 1.00 : ((haveSteepLine) ? 0.75 : 0.50)) : 0.08677704501) : 0.00);\n\t\t\tdst[ 5] = mix(dst[ 5], blendPix, (needBlend && doLineBlend && haveShallowLine) ? 0.75 : 0.00);\n\t\t\tdst[ 6] = mix(dst[ 6], blendPix, (needBlend && doLineBlend && haveShallowLine) ? 0.25 : 0.00);\n\t\t}\n\t\t\n\t\tvec3 res = mix( mix( mix( mix(dst[ 6], dst[ 7], step(0.25, f.x)), mix(dst[ 8], dst[ 9], step(0.75, f.x)), step(0.50, f.x)),\n\t\t                             mix( mix(dst[ 5], dst[ 0], step(0.25, f.x)), mix(dst[ 1], dst[10], step(0.75, f.x)), step(0.50, f.x)), step(0.25, f.y)),\n\t\t                        mix( mix( mix(dst[ 4], dst[ 3], step(0.25, f.x)), mix(dst[ 2], dst[11], step(0.75, f.x)), step(0.50, f.x)),\n\t\t                             mix( mix(dst[15], dst[14], step(0.25, f.x)), mix(dst[13], dst[12], step(0.75, f.x)), step(0.50, f.x)), step(0.75, f.y)),\n\t\t                                                                                                                                    step(0.50, f.y));\n\n\n\t\treturn res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col1 = four_xBRZ(vec2(256.0,32.0),vec2(-0.042,0.0)+ uv*vec2(0.25,1.0)+vec2(floor(iTime*8.0)*0.156+0.064*floor(iTime*8.0/6.0),0.0));\n    vec3 col2 = texture(iChannel0,vec2(-0.042,0.0)+ uv*vec2(0.25,1.0)+vec2(floor(iTime*8.0)*0.156+0.064*floor(iTime*8.0/6.0),0.0)).xyz;\n    float split = 0.5+0.5*sin(iTime);\n    fragColor = vec4(uv.x>0.18&&uv.x<0.82?(uv.x>split?uv.x<split+0.01?vec3(0.0,0.0,0.0):col2:col1):vec3(1.0),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}