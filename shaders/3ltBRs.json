{
    "Shader": {
        "info": {
            "date": "1613273965",
            "description": "Solving for the closest point on two SDFs using gradient descent.",
            "flags": 0,
            "hasliked": 0,
            "id": "3ltBRs",
            "likes": 13,
            "name": "Closest Point on 2 SDFs",
            "published": 3,
            "tags": [
                "sdf",
                "rootfinding",
                "gradientdescent",
                "closest"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 461
        },
        "renderpass": [
            {
                "code": "/*\nFinding the closest point between two SDFs using gradient descent.\n\nNote: for specific cases it is best to use analytic gradients (or better yet, solve for the\nclosest point analytically, I have no clue how to go about doing that btw)\n\nUses: I've only thought of one, collision detection, if (and only if) the closest point to both SDFs\nis inside either SDF, they are colliding. The closest point should also be the contact point (unless\nthey are intersecting).\n\nSome optimizations made here: https://www.shadertoy.com/view/3t3fWB\n*/\n\n////////////////////////////////////////////////// SDFs /////////////////////////////////////////////////\n\nfloat sdf1(in vec2 p) {\n    float c = cos(iTime), s = sin(iTime);\n    p += vec2(s, s * c) * 0.4 + vec2(0.4, 0.0);\n    Rotate(p, iTime);\n    return sdBox(p, vec2(0.25 + 0.125 * s, 0.1 + 0.075 * c));\n}\n\nfloat sdf2(in vec2 p) {\n    p.x -= 0.45;\n    float frac = fract(iTime);\n    p.y -= frac * (1.0 - frac) - 0.1;\n    Rotate(p, -2.0 * iTime);\n    float a = 0.25;\n    return sdHorseshoe(p, vec2(sin(a), cos(a)), vec2(0.2, 0.1), 0.2);\n}\n\n//////////////////////////////////////// SDF Gradients //////////////////////////////////////////////////\n\nvec2 grad1(in vec2 p) {\n    return vec2(sdf1(p + vec2(DELTA, 0.0)) - sdf1(p - vec2(DELTA, 0.0)),\n                sdf1(p + vec2(0.0, DELTA)) - sdf1(p - vec2(0.0, DELTA))) / (2.0 * DELTA);\n}\n\nvec2 grad2(in vec2 p) {\n    return vec2(sdf2(p + vec2(DELTA, 0.0)) - sdf2(p - vec2(DELTA, 0.0)),\n                sdf2(p + vec2(0.0, DELTA)) - sdf2(p - vec2(0.0, DELTA))) / (2.0 * DELTA);\n}\n\n////////////////////////////////////// Solver (gradient descent) ////////////////////////////////////////\n\n// Seed is somewhat arbitrary but will affect performance in some cases\n// If the object positions are known (or can be estimated), its probably best\n// to just pick the midway point\n#define fmax(p) max(sdf1(p), sdf2(p))\nvec2 grad(in vec2 p) {\n    return vec2(fmax(p + vec2(DELTA, 0.0)) - fmax(p - vec2(DELTA, 0.0)),\n                fmax(p + vec2(0.0, DELTA)) - fmax(p - vec2(0.0, DELTA))) / (2.0 * DELTA);\n}\n\nvec2 findClosest(in vec2 seed) {\n    vec2 closest = seed; // Current guess\n    for (int i=0; i < ITERATIONS; i++) {\n        vec2 g = grad(closest);\n        closest -= g * DESCENT_RATE; // Move down slope\n        if (length(g) < EPSILON) { // Alternatively, all(lessThan(abs(g), vec2(EPSILON))) to avoid square roots\n            break; // Exit loop if under the error margin\n        }\n    }\n\n    return closest;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n\n    float d = min(sdf1(uv), sdf2(uv));\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    vec2 closest = findClosest(vec2(0.0));\n    vec2 proj1 = closest - normalize(grad1(closest)) * sdf1(closest); // Project onto first SDF\n    vec2 proj2 = closest - normalize(grad2(closest)) * sdf2(closest); // Project onto second SDF\n\n    color = mix(color, vec3(0.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.015, sdLine(uv, proj1, proj2)));\n    color = mix(color, vec3(1.0, 0.0, 0.0), 1.0 - smoothstep(0.0, 0.015, length(uv - closest) - 0.01));\n    color = mix(color, vec3(0.0, 0.0, 1.0), 1.0 - smoothstep(0.0, 0.015, length(uv - proj1) - 0.01));\n    color = mix(color, vec3(0.0, 0.0, 1.0), 1.0 - smoothstep(0.0, 0.015, length(uv - proj2) - 0.01));\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//////////////////////////////////////// Solver Hyperparameters /////////////////////////////////////////\n\n// Maximum iterations\n#define ITERATIONS 75\n\n// Controls how fast the algorithm steps (don't make too large!)\n#define DESCENT_RATE 0.02\n\n// Error margin\n#define EPSILON 0.001\n\n// Small number\n#define DELTA 0.001\n\n///////////////////////////////////////////// Utilities /////////////////////////////////////////////////\n\nvoid Rotate(inout vec2 p, in float r) {\n    float c = cos(r), s = sin(r);\n    p *= mat2(c, -s, s, c);\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdHorseshoe(in vec2 p, in vec2 c, in vec2 w, in float r) {\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, c.y, c.x) * p;\n    p = vec2((p.y > 0.0) ? p.x : -l * sign(c.x), (p.x > 0.0) ? p.y : l);\n    p = vec2(p.x, abs(p.y - r)) - w;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}