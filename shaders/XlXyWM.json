{
    "Shader": {
        "info": {
            "date": "1504935092",
            "description": "mouse sets points.\nforsimplicity, create only 2 points by pausing time and overlapping 2 of 3 points.\n\nforked:\nhttps://www.shadertoy.com/view/llscW4\nfor efficiency",
            "flags": 0,
            "hasliked": 0,
            "id": "XlXyWM",
            "likes": 3,
            "name": "sawtoth gradient B",
            "published": 3,
            "tags": [
                "circles",
                "fract",
                "phi",
                "parabola",
                "sawtooth"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 708
        },
        "renderpass": [
            {
                "code": "\n//suddenly, tripple parabola pairs!\n//#define  ModeParabola\n\n//fallof without clamp(), doesnt look too good\n//#define falloff\n\nconst float stepWidth = 10.; \n\n//View.Zoom\n#define ViewZoom 2.\n//View.Frame (centric view frame has best precision)\n#define fra(u) (u-.5*iResolution.xy)*ViewZoom/iResolution.y\n\n#define sc(a) vec2(sin(a),cos(a))\n//goden ratio >1\n#define phi (sqrt(5.)*.5+.5)\n#define u5(a) ((a)*.5+.5)\n#define u2(a) ((a)*2.-1.)\n#define dd(a) dot(a,a)\n\n//sawtoothGradient() should possibly be 2 seperate functions, \n//seperating its 2 iutputs, allowing them to be n-dimensional as #define\n//i need to sleep over this, as it confuses me more than it should.\n#ifdef falloff\n #define sgx(u)  u5(fract((u)*stepWidth ))*(1.-dd(u))\n //float sgx(vec2 u){return u5(fract(length(u)*stepWidth ))*(1.-dd(u));}\n#else\n #define sgx(u) u5(fract((u)*stepWidth))\n// float sgx(vec2 u){return u5(fract(length(u)*stepWidth ));}\n#endif\n#ifdef ModeParabola\n #define sgy(u) (1.-fract((u)*stepWidth)/stepWidth)\n //float sgy(vec2 u){return 1.-fract(length(u)*stepWidth)/stepWidth;}\n#else\n #define sgy(u) (1.-floor((u)*stepWidth)/stepWidth)\n //float sgy(vec2 u){return 1.-floor(length(u)*stepWidth)/stepWidth;}\n#endif\n//vec2 sawtoothGradient(vec2 u){return vec2(sgx(length(u)),sgy(length(u)));}\n//fork of: https://www.shadertoy.com/view/llscW4\n\nvoid mainImage( out vec4 fragColor, in vec2 U ) {\n\tvec2 u=fra(U);//fragCoord.xy / iResolution.xy;\n    vec4 m=vec4(fra(iMouse.xy),fra(iMouse.zw));// vec4(iMouse.xyzw/ iResolution.xyxy);\n    //m-=.5;    \n    //m.yz*=iResolution.x/iResolution.y;\n    if(iMouse.z<=.0)m=.25*vec4(sc(iTime+acos(0.)),sc(-iTime*phi));//mouse overwrite\n    \n    #if 1\n     #define ledd length\n    #else\n     #define ledd dd\n    #endif\n    \n    vec2 tt=sc(iTime*acos(0.));//tt=vec2(tt.y,-tt.x);\n    //d and e may be better off as matrix?\n    vec3 d=vec3(sgy(ledd(u-m.xy)),\n                sgy(ledd(u-m.zw)),\n                sgy(ledd(u-tt)));\n    vec3 e=vec3(sgx(ledd(u-m.xy)),\n                sgx(ledd(u-m.zw)),\n                sgx(ledd(u-tt)));\n    \n    //d=sqrt(d); e=sqrt(e);//complex plane wotld?\n    \n    //i think [a] and [b] are just a poorly structured matrix.\n    //sawtoothGradient() is better of being 2 functions,for less repetition in vectors.\n    \n    vec4 c=vec4(0);\n    d-=d.yzx;    //this is the fun part of my vector rearranment\n    //e-=e.yzx;   //nope \n    vec3 t=step(d,vec3(0));\n    c.x= mix(e.x,-e.y,t.x);\n    c.y= mix(e.y,-e.z,t.y);\n    c.z= mix(e.z,-e.x,t.z);\n    //seems like here; swiveling/permutations are equal o \"order of operations\"\n    //as in          ; swiveling implies causality.\n    //no wait, of course it does not:\n    c.xyz*=-(c.yzx+1.)*.5;//nope, not too pretty, but ill keep it!\n    \n    c.xyz=mix(c.xyz,c.yzx,.5);\n    c=c*2.;\n    //this color mix is faster, but i fail to permute it into something more monochrome.\n    //my simpler solution just got overly confusing, visually.\n    \n    \n    /*\n    //backup of a MUCH simpler 2-dot mix\n    vec2 a=vec2(d.x,e.x),b=vec2(d.y,e.y);//silly you and your flipped matrix.\n    float t=step(a.y-b.y,.0);\n    //t=u5(sign(b.y-a.y+.1));\n    c.x= mix(.0 ,b.x,t);\n    c.y= mix(a.x,0. ,t);\n    c.z= mix(a.x,b.x,t);\n*/\n    \n    //c.xyz=vec3(mix(a.x,b.x,step(a.y-b.y,.0)));//grey\n    c.w=1.;\n    fragColor=c;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}