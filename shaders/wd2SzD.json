{
    "Shader": {
        "info": {
            "date": "1553157006",
            "description": "A 3D version of Life (see source)",
            "flags": 32,
            "hasliked": 0,
            "id": "wd2SzD",
            "likes": 16,
            "name": "Cellular Sculpture",
            "published": 3,
            "tags": [
                "automata",
                "life",
                "reduction",
                "cellmarch"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 543
        },
        "renderpass": [
            {
                "code": "// \"Cellular Sculpture\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n 3D cellular automaton based on the game of Life. Cell alive if 13 or 15+\n live neighbors (out of 27, including itself), otherwise dead.\n Use mouse to halt process and choose best view angle; click ring to\n restart (else automatic).\n Live cell count shown (x1000).\n Grid size depends on window (texture) size.\n Cell-marching from \"Mandelcity\".\n*/\n\n#define AA  1   // optional antialiasing\n\nvec3 HsvToRgb (vec3 c);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\nvec4 Loadv4 (int idVar);\n\nvec3 ltDir;\nfloat dstFar, gSize;\nconst float pi = 3.14159;\n\nvec4 CellRay (vec3 ro, vec3 rd)\n{\n  vec3 gCel, ig, fcHit, gb, s, cp, rdi;\n  float occ;\n  rdi = 1. / rd;\n  gCel = floor (ro);\n  gb = (max (sign (rd), vec3 (0.)) - ro) * rdi;\n  occ = 0.;\n  for (int i = 0; i < 400; i ++) {\n    s = gCel * rdi + gb;\n    cp = step (s, s.yzx);\n    fcHit = cp * (1. - cp.zxy);\n    gCel += sign (rd) * fcHit;\n    ig = gCel + 0.5 * gSize;\n    if (Minv3 (ig) >= 0. && Maxv3 (ig) < gSize) {\n      occ = Loadv4 (int ((ig.z * gSize + ig.y) * gSize + ig.x)).x;\n      if (occ > 0.) break;\n    }\n  }\n  return (occ > 0.) ? vec4 (dot (s - abs (rdi), fcHit), fcHit) : vec4 (dstFar, 0., 0., 0.);\n}\n\nfloat BlkHit (vec3 ro, vec3 rd, vec3 blkSize)\n{\n  vec3 v, tm, tp;\n  float dn, df;\n  v = ro / rd;\n  tp = blkSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  return (df > 0. && dn < df) ? dn : dstFar;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 dc4;\n  vec3 col, vn;\n  float dBlk, sh;\n  rd += 0.00001;\n  col = vec3 (0.6, 0.6, 0.7) * (0.8 + 0.2 * rd.y);\n  dBlk = BlkHit (ro, rd, vec3 (0.5 * gSize + 1.));\n  if (dBlk < dstFar) {\n    ro += dBlk * rd;\n    dc4 = CellRay (ro, rd);\n    if (dc4.x < dstFar) {\n      ro += rd * dc4.x;\n      vn = - dc4.yzw * sign (rd);\n      col = HsvToRgb (vec3 (1. - mod (length (floor (ro)) / (0.5 * gSize), 1.), 0.8, 1.));\n      sh = 0.1 + 0.9 * smoothstep (0.1, 0.6, CellRay (ro + 0.01 * vn, ltDir).x / gSize);\n      col = col * (0.2 + 0.8 * sh * max (dot (ltDir, vn), 0.) + 0.3 * max (dot (- ltDir, vn), 0.)) +\n         0.2 * step (0.9, sh) * sh * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n    }\n  }\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col, wgBxC;\n  vec2 canvas, uv, ori, ca, sa;\n  float tCur, asp, dVu, sr, el, az, zmFac, nStep;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  tCur += 10.;\n  asp = canvas.x / canvas.y;\n  wgBxC = vec3 (0.48 * asp, 0.46, 0.022);\n  nStep = Loadv4 (0).z;\n  az = 0.3 * pi;\n  el = -0.2 * pi;\n  mPtr.xy = Loadv4 (1).zw;\n  mPtr.z = Loadv4 (2).z;\n  if (mPtr.z > 0. && length (mPtr.xy * vec2 (asp, 1.) - wgBxC.xy) > wgBxC.z) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.0006 * pi * nStep;\n    el -= 0.00022 * pi * nStep;\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  gSize = Loadv4 (0).w;\n  dVu = 2.5 * gSize;\n  ro = vuMat * vec3 (0., 0., - dVu);\n  zmFac = 4. - cos (2. * (az - 0.25 * pi));\n  dstFar = dVu + 2. * gSize + 3.;\n  ltDir = normalize (vec3 (0., 1., 1.)); //normalize (vec3 (0.6, 1.1, -1.));\n  ltDir.xz = Rot2D (ltDir.xz, pi * sin (0.1 * pi * tCur));\n  ltDir.yz = Rot2D (ltDir.yz, 0.5 * pi * sin (0.07 * pi * tCur));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  if (abs (length (0.5 * uv - wgBxC.xy) - wgBxC.z) * canvas.y < 2.) col = vec3 (1., 1., 0.7);\n  col = mix (col, vec3 (0.2), ShowInt (0.5 * uv - vec2 (0.45 * asp, - 0.45),\n     vec2 (0.04 * asp, 0.02), 4., floor (Loadv4 (1).y / 1000. + 0.5)));\n  fragColor = vec4 (col, 1.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat DigSeg (vec2 q)\n{\n  return (1. - smoothstep (0.13, 0.17, abs (q.x))) *\n     (1. - smoothstep (0.5, 0.57, abs (q.y)));\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log (val + 0.01) / log (10.), 0.)) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (sgn < 0.) {\n      if (idChar == mxChar - nDig - 1.) s = ShowDig (q, -1);\n      else ++ v;\n    }\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txSize.x), floor (fi / txSize.x)) + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Cellular Sculpture\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat Hashfv3 (vec3 p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nfloat todCur;\nconst float pi = 3.14159;\n\n#define MAX_GRID  120.\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat;\n  vec3 gCel, gsv, wgBxC;\n  vec2 canvas, iFrag;\n  float v, sv, ip, gSize, nStep, asp, nsi, frSkip;\n  int pxId;\n  bool init, doStep;\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  iFrag = floor (fragCoord);\n  ip = floor (iFrag.x + txSize.x * iFrag.y);\n  pxId = int (ip);\n  init = (iFrame <= 5);\n  gSize = min (floor (floor (pow (txSize.x * txSize.y, 1./3.)) / 2.) * 2., MAX_GRID);\n  if (! init  && gSize != Loadv4 (0).w) init = true; \n  if (ip >= gSize * gSize * gSize) discard;\n  frSkip = (gSize <= 64.) ? 5. : 2.;\n  doStep = (mPtr.z <= 0. && mod (float (iFrame), frSkip) == 0.);\n  asp = canvas.x / canvas.y;\n  wgBxC = vec3 (0.48 * asp, 0.46, 0.022);\n  gsv = vec3 (1., gSize, gSize * gSize);\n  gCel = mod (floor (vec3 (ip) / gsv), vec3 (gSize));\n  nStep = Loadv4 (0).z;\n  if (! init && (nStep > 20. * gSize || nStep > 40. && Loadv4 (1).y == 0.)) init = true;\n  mPtrP.z = Loadv4 (2).z;\n  if (mPtr.z > 0.) {\n    if (length (mPtr.xy * vec2 (asp, 1.) - wgBxC.xy) < wgBxC.z) {\n      if (mPtrP.z <= 0.) init = true;\n    }\n  }\n  v = 0.;\n  if (init) nStep = 0.;\n  else if (doStep) ++ nStep;\n  if (Minv3 (gCel) > 0. && Maxv3 (gCel) < gSize - 1.) {\n    if (init) {\n      v = step (0.5, Hashfv3 (17.17 * gCel + 41.41 * gCel.yzx + 69.69 * gCel.zxy +\n         mod (todCur, 1.)));\n    } else if (doStep) {\n      sv = 0.;\n      for (float iz = -1.; iz <= 1.; iz ++) {\n        for (float iy = -1.; iy <= 1.; iy ++) {\n          for (float ix = -1.; ix <= 1.; ix ++) {\n            sv += Loadv4 (int (dot (gCel + vec3 (ix, iy, iz), gsv))).x;\n          }\n        }\n      }\n      v = (sv == 13. || sv >= 15.) ? 1. : 0.;\n    } else {\n      v = Loadv4 (int (dot (gCel, gsv))).x;\n    }\n  }\n  stDat = vec4 (v, Loadv4 (pxId).y, 0., 0.);\n  if (pxId == 0) stDat.zw = vec2 (nStep, gSize);\n  else if (pxId == 1) stDat.zw = mPtr.xy;\n  else if (pxId == 2) stDat.z = mPtr.z;\n  if (doStep) {\n    nsi = mod (nStep, 10.);\n    if (nsi == 1.) {\n      if (gCel.x == 0.) {\n        sv = 0.;\n        for (float ix = 0.; ix < MAX_GRID; ix ++) {\n          if (ix >= gSize) break;\n          sv += Loadv4 (int (dot (gCel + vec3 (ix, 0., 0.), gsv))).x;\n        }\n        stDat.y = sv;\n      }\n    } else if (nsi == 2.) {\n      if (gCel.x == 0. && gCel.y == 0.) {\n        sv = 0.;\n        for (float iy = 0.; iy < MAX_GRID; iy ++) {\n          if (iy >= gSize) break;\n          sv += Loadv4 (int (dot (gCel + vec3 (0., iy, 0.), gsv))).y;\n        }\n        stDat.y = sv;\n      }\n    } else if (nsi == 3.) {\n      if (pxId == 1) {\n        sv = 0.;\n        for (float iz = 0.; iz < MAX_GRID; iz ++) {\n          if (iz >= gSize) break;\n          sv += Loadv4 (int (dot (vec3 (0., 0., iz), gsv))).y;\n        }\n        stDat.y = sv;\n      }\n    }\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txSize.x), floor (fi / txSize.x)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txSize.x), floor (fi / txSize.x)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}