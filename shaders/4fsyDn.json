{
    "Shader": {
        "info": {
            "date": "1721373547",
            "description": "Note, you might need to press the Reset Time button to hear the music, and if you experience any out-of-sync issues, try to reset time once more. :)",
            "flags": 8,
            "hasliked": 0,
            "id": "4fsyDn",
            "likes": 27,
            "name": "Oxygene IV",
            "published": 3,
            "tags": [
                "terrain",
                "music",
                "aurora",
                "glacier",
                "arctic",
                "oxygene",
                "jeanmicheljarre"
            ],
            "usePreview": 0,
            "username": "Espeset",
            "viewed": 345
        },
        "renderpass": [
            {
                "code": "#define EPSILON 0.001\n#define DEFAULT_OCTAVES 7\n#define LAKE_HEIGHT 0.045\n\nvec2 applyTurbulence(vec2 uv) {\n    float turbulenceFactor = 5.0;\n    vec2 initialUV = uv;\n\n    for (float i = 1.0; i < 3.0; i += 1.0) {\n        float sinValue = sin(uv.x * i) / turbulenceFactor;\n        uv.y += sinValue;\n        float cosValue = cos(uv.y * i) / turbulenceFactor;\n        uv.x += cosValue;\n        uv = uv.yx;\n    }\n    return (uv - initialUV).yx;\n}\n\nfloat terrainHeight(vec2 uv, int octaves, bool useLake) {\n    float heightValue = 0.0;\n    float amplitude = 0.85;\n\n    for (int i = 0; i < octaves; i++) {\n        vec2 turbulenceValue = applyTurbulence(uv).yx;\n        uv += turbulenceValue;\n        float noiseSum = turbulenceValue.x + turbulenceValue.y;\n        heightValue -= abs(noiseSum) * amplitude;\n        heightValue = sqrt(heightValue * heightValue + 0.0001);\n        amplitude *= 0.35;\n        uv += uv;\n    }\n    float h=heightValue;\n    if (useLake && h<LAKE_HEIGHT)\n    {\n        float delta=LAKE_HEIGHT-h;\n        return LAKE_HEIGHT-delta/4.0;\n    }\n    return h;\n}\n\nfloat terrainHeight(vec3 position, int octaves,bool useLake) {   \n    return terrainHeight(position.xz, octaves,useLake);\n}\n\nvec3 calculateNormal(vec3 position) {\n    float height = terrainHeight(position, DEFAULT_OCTAVES,true);\n    float heightX = terrainHeight(position - vec3(EPSILON, 0.0, 0.0), DEFAULT_OCTAVES,true);\n    float heightZ = terrainHeight(position - vec3(0.0, 0.0, EPSILON), DEFAULT_OCTAVES,true);\n    return normalize(vec3(heightX - height, EPSILON, heightZ - height));\n}\n\nfloat performRayMarching(vec3 rayOrigin, vec3 rayDirection, float tMin, float tMax) {\n    float t = tMin;\n    for (int i = 0; i < 300; i++) {\n        vec3 position = rayOrigin + t * rayDirection;\n        float heightDifference = position.y - terrainHeight(position, DEFAULT_OCTAVES - 2,true);\n        if (abs(heightDifference) < (0.0015 * t) || t > tMax) \n            break;\n        t += 0.4 * heightDifference;\n    }\n    return t;\n}\n\nmat2 mm2(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nmat2 m2 = mat2(0.95534, 0.29552, -0.29552, 0.95534);\n\nfloat tri(float x) {\n    return clamp(abs(fract(x) - 0.5), 0.01, 0.49);\n}\n\nvec2 tri2(vec2 p) {\n    return vec2(tri(p.x) + tri(p.y), tri(p.y + tri(p.x)));\n}\n\nfloat triNoise2d(vec2 p, float spd) {\n    float z = 1.8;\n    float rz = 0.0;\n    vec2 bp = p;\n    for (int i = 0; i < 5; i++) {\n        vec2 dg = tri2(bp * 1.85) * 0.75;\n        dg *= mm2(iTime * spd);\n        p -= dg / (z * 1.39);\n        bp *= 1.3;\n        z *= 0.45;\n        p *= 1.21 + (rz - 1.0) * 0.02;\n        rz += tri(p.x + tri(p.y)) * z;\n        p *= -m2;\n    }\n    return clamp(1.0 / pow(rz * 29.0, 1.3), 0.0, 0.55);\n}\n\nfloat hash21(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n//Thanks to WilstonOreo\nvec4 aurora(vec3 rd) {\n    vec4 col = vec4(0.0);\n    vec4 avgCol = vec4(0.0);\n    \n    for (float i = 0.0; i < 20.0; i++) {\n        float of = 0.006 * hash21(gl_FragCoord.xy) * smoothstep(0.0, 15.0, i);\n        float pt = (0.8 + pow(i, 1.4) * 0.002) / (rd.y * 2.0 + 0.4) - of;\n        vec3 bpos = pt * rd;\n        float rzt = triNoise2d(bpos.zx, 0.5);\n        vec4 col2 = vec4((sin(1.0 - vec3(2.15, -0.5, 1.2) + i * 0.043) * 0.5 + 0.5) * rzt, rzt);\n        avgCol = mix(avgCol, col2, 0.5);\n        col += avgCol * exp2(-i * 0.065 - 2.5) * smoothstep(0.0, 5.0, i);\n    }\n    \n    col *= clamp(rd.y * 15.0 + 0.4, 0.0, 1.0);\n    return col * 1.8;\n}\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 getSky(vec3 ray) {\n    vec3 color = aurora(ray).rgb;\n    vec3 hsv = rgb2hsv(color);\n    float audio=getCurrentAudio(mod(iTime,100.0));\n    float hueShift = iTime * 0.1 + (ray.x + ray.y) * 0.8;\n    hsv.x = mod(hsv.x + hueShift+audio, 1.0);\n    color = hsv2rgb(hsv);\n    return color;\n}\n\nvec3 computeLighting(vec3 position, vec3 normal, vec3 lightDir, vec3 viewDir) {\n    vec3 reflected = normalize(reflect(-viewDir, normal));\n    vec3 skyColor = getSky(reflected);\n\n    // Smooth transition parameters\n    float transitionRange = 0.005;\n    float transitionFactor = smoothstep(LAKE_HEIGHT - transitionRange, LAKE_HEIGHT + transitionRange, position.y);\n\n    // Calculate terrain lighting\n    vec3 directLightColor = vec3(0.1);\n    vec3 albedo = vec3(0.8);\n    vec3 ambientLight = vec3(0.01)+skyColor * 0.05;\n    \n    float d = dot(normal, lightDir);\n    vec3 diffuse = max(d, 0.0) * albedo;\n\n    vec3 terrainColor = ambientLight + diffuse * directLightColor;\n\n    // Mix the sky color and terrain lighting based on transition factor\n    vec3 finalColor = mix(skyColor, terrainColor, max(0.6, transitionFactor));\n\n    return finalColor;\n}\n\n\nmat3 createLookAtMatrix(vec3 origin, vec3 target, float roll) {\n    vec3 rollRotation = vec3(sin(roll), cos(roll), 0.0);\n    vec3 forward = normalize(target - origin);\n    vec3 right = normalize(cross(forward, rollRotation));\n    vec3 up = normalize(cross(right, forward));\n    return mat3(right, up, forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec3 lightDir = normalize(vec3(-0.8, 0.15, -0.3));\n    vec3 cameraStep = vec3(lightDir.x, 0.0, lightDir.z) * (iTime / 2.5);\n    vec3 cameraPos = vec3(8.0, 2.0, 5.0) + cameraStep;\n    vec3 cameraTarget = vec3(1.0, 1.0, 4.0) + cameraStep;\n\n    mat3 viewMatrix = createLookAtMatrix(cameraPos, cameraTarget, 0.0);\n    vec3 rayOrigin = cameraPos;\n    rayOrigin.y += terrainHeight(rayOrigin.xz, 1,false) - 1.8;\n    vec3 rayDirection = normalize(viewMatrix * vec3(uv.xy, 1.0));\n\n    float tMin = 0.1;\n    float tMax = 20.0;\n    float t = performRayMarching(rayOrigin, rayDirection, tMin, tMax);\n    vec3 color = vec3(0.0);\n\n    if (t > tMax) {\n         color=getSky(rayDirection);\n    } else {\n        vec3 position = rayOrigin + rayDirection * t;\n        vec3 normal = calculateNormal(position);\n        vec3 viewDir = normalize(rayOrigin - position);\n        color = computeLighting(position, normal, lightDir, viewDir);\n    }\n\n    color = pow(clamp(color, 0.0, 1.0), vec3(0.45));\n    fragColor = vec4(vec3(color), 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Main player and song data\n\nfloat rythmLoop(float time) {\n    currentTime = mod(time, tick_to_second * ( 12.0 * 1.0 / 3.0));\n    timeOffset=0.0;\n    float combinedWaveform = 0.0;\n\n    // Play rythm\n    combinedWaveform += bassdrumPlay();    // O....xx..x.x\n    combinedWaveform += largeBongoPlay();  // O.....x..x..\n    combinedWaveform += hihatPlay();       // Oxxxxxxxxxxx\n    sleep(1.0 / 3.0);\n\n    combinedWaveform += hihatPlay();       // xOxxxxxxxxxx\n    sleep(1.0 / 3.0);\n\n    combinedWaveform += cymbalPlay();      // ..O.........\n    combinedWaveform += smallBongoPlay();  // ..O..x..x..x\n    combinedWaveform += hihatPlay();       // xxOxxxxxxxxx\n    sleep(1.0 / 3.0);\n\n    combinedWaveform += rimshotPlay();     // ...O.....x..\n    combinedWaveform += hihatPlay();       // xxxOxxxxxxxx\n    sleep(1.0 / 3.0);\n\n    combinedWaveform += hihatPlay();       // xxxxOxxxxxxx\n    sleep(1.0 / 3.0);\n\n    combinedWaveform += bassdrumPlay();    // x....Ox..x.x\n    combinedWaveform += smallBongoPlay();  // ..x..O..x..x\n    combinedWaveform += hihatPlay();       // xxxxxOxxxxxx\n    sleep(1.0 / 3.0);\n\n    combinedWaveform += bassdrumPlay();    // x....xO..x.x\n    combinedWaveform += largeBongoPlay();  // x.....O..x..\n    combinedWaveform += hihatPlay();       // xxxxxxOxxxxx\n    sleep(1.0 / 3.0);\n\n    combinedWaveform += hihatPlay();       // xxxxxxxOxxxx\n    sleep(1.0 / 3.0);\n\n    combinedWaveform += hihatPlay();       // xxxxxxxxOxxx\n    combinedWaveform += smallBongoPlay();  // ..x..x..O..x\n    sleep(1.0 / 3.0);\n\n    combinedWaveform += bassdrumPlay();    // x....xx..O.x\n    combinedWaveform += largeBongoPlay();  // x.....x..O..\n    combinedWaveform += rimshotPlay();     // ...x.....O..\n    combinedWaveform += congaPlay();       // .........O.x\n    combinedWaveform += quijadaPlay();     // .........O..\n    combinedWaveform += hihatPlay();       // xxxxxxxxxOxx\n    sleep(1.0 / 3.0);\n\n    combinedWaveform += hihatPlay();       // xxxxxxxxxxOx\n    sleep(1.0 / 3.0);\n\n    combinedWaveform += bassdrumPlay();    // x....xx..x.O\n    combinedWaveform += smallBongoPlay();  // ..x..x..x..O\n    combinedWaveform += congaPlay();       // .........x.O\n    combinedWaveform += hihatPlay();       // xxxxxxxxxxxO\n    sleep(1.0 / 3.0);\n\n    return combinedWaveform;\n}\n\nfloat bassLoop(float time) {\n    const int PAT0_LENGTH = 12, PAT1_LENGTH = 12, PAT2_LENGTH = 12, PAT3_LENGTH = 16, SEQ_LENGTH = 55;\n\n    // Calculate current time within the loop duration\n    const float TOTAL_DURATION = 1320.0; // Precalculated total tick duration for all sequences together\n    currentTime = mod(time, (TOTAL_DURATION / 3.0)*tick_to_second);\n    timeOffset = 0.0;\n    float combinedWaveform = 0.0;\n\n    // Define offset and length for each pattern\n    ivec2 offsets[4] = ivec2[4](\n        ivec2(0, PAT0_LENGTH),\n        ivec2(PAT0_LENGTH, PAT1_LENGTH),\n        ivec2(PAT0_LENGTH + PAT1_LENGTH, PAT2_LENGTH),\n        ivec2(PAT0_LENGTH + PAT1_LENGTH + PAT2_LENGTH, PAT3_LENGTH));\n\n    // Combine all patterns into a single array, pairs of notes and durations\n    vec2 pat[PAT0_LENGTH + PAT1_LENGTH + PAT2_LENGTH + PAT3_LENGTH] = vec2[](\n        vec2(c2, 3.0), vec2(as1, 2.0), vec2(c2, 3.0), vec2(g1, 1.0), vec2(as1, 2.0), vec2(g1, 1.0), vec2(c2, 3.0), vec2(as1, 2.0), vec2(c2, 3.0), vec2(c2, 1.0), vec2(as1, 2.0), vec2(g1, 1.0),\n        vec2(d2, 3.0), vec2(c2, 2.0), vec2(d2, 3.0), vec2(d2, 1.0), vec2(c2, 2.0), vec2(a1, 1.0), vec2(d2, 3.0), vec2(c2, 2.0), vec2(d2, 3.0), vec2(d2, 1.0), vec2(c2, 2.0), vec2(a1, 1.0),\n        vec2(f2, 3.0), vec2(ds2, 2.0), vec2(c2, 3.0), vec2(f2, 1.0), vec2(ds2, 2.0), vec2(c2, 3.0), vec2(f2, 1.0), vec2(ds2, 2.0), vec2(c2, 3.0), vec2(c2, 1.0), vec2(ds2, 2.0), vec2(c2, 1.0),\n        vec2(f2, 3.0), vec2(ds2, 2.0), vec2(c2, 3.0), vec2(f2, 1.0), vec2(ds2, 3.0), vec2(c2, 1.0), vec2(f2, 1.0), vec2(ds2, 1.0), vec2(c2, 1.0), vec2(ds2, 1.0), vec2(c2, 1.0), vec2(as1, 1.0), vec2(g1, 1.0), vec2(as1, 1.0), vec2(g1, 1.0), vec2(as1, 1.0)\n    );\n\n    // Define sequence of patterns to play\n    int seq[SEQ_LENGTH] = int[](0, 0, 0, 0, 1, 0, 0, 1, 2, 0, 0, 1, 3, 0, 0, 1, 2, 0, 1, 2, 0, 1, 3, 0, 1, 2, 0, 0, 1, 2, 0, 0, 1, 3, 0, 1, 2, 0, 1, 3, 0, 1, 2, 0, 1, 3, 0, 1, 2, 0, 1, 3, 0, 1, 3);\n\n    // Iterate through the sequence\n    for (int j = 0; j < SEQ_LENGTH; ++j) {\n        int patternIndex = seq[j];\n        ivec2 offset = offsets[patternIndex];\n        int patternStart = offset.x, patternLength = offset.y;\n\n        // Iterate through the notes in the current pattern\n        for (int i = 0; i < patternLength; ++i) {\n            combinedWaveform += bassPlay(pat[patternStart+i].x);\n            sleep(pat[i].y / 3.0);\n        }\n    }\n    return combinedWaveform;\n}\n\nfloat noiseLoop(float time) {\n    const int SEQ_LENGTH = 55;\n\n    currentTime = mod(time, tick_to_second * (float(SEQ_LENGTH) * 8.0));\n    timeOffset = 0.0;\n    float combinedWaveform = 0.0;\n\n    int pat[SEQ_LENGTH] = int[SEQ_LENGTH]( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0 );\n \n    for(int i = 0; i < SEQ_LENGTH; ++i) {\n        sleep(4.0);\n        if(pat[i]>0) {\n            combinedWaveform+=noisePlay();\n            sleep(1.0);\n            combinedWaveform+=noisePlay();\n            sleep(3.0);\n        }\n        else\n            sleep(4.0);\n    }\n    return combinedWaveform;\n}\n\nfloat stringsLoop(float time) {\n    const int PAT_LENGTH = 4, SEQ_LENGTH = 55;\n\n    // Calculate current time within the loop duration\n    currentTime = mod(time, tick_to_second * (float(SEQ_LENGTH) * 8.0));\n    timeOffset = 0.0;\n    float combinedWaveform = 0.0;\n\n    // Define offset and length for each pattern\n    ivec2 offsets[3] = ivec2[](\n        ivec2(0, PAT_LENGTH),\n        ivec2(PAT_LENGTH, PAT_LENGTH),\n        ivec2(PAT_LENGTH * 2, PAT_LENGTH)\n    );\n\n    // Combine all patterns into a single array with notes, the second parameter is reserved for future use. WIP\n    vec2 pat[PAT_LENGTH * 3] = vec2[](\n        vec2(c4, 0.0), vec2(ds4, 0.0), vec2(g4, 0.0), vec2(c5, 0.0),\n        vec2(d4, 0.0), vec2(g4, 0.0), vec2(as4, 0.0), vec2(d5, 0.0),\n        vec2(c4, 0.0), vec2(f4, 0.0), vec2(a4, 0.0), vec2(c4, 0.0)\n    );\n\n    // Define sequence of patterns to play\n    int seq[SEQ_LENGTH] = int[]( -1, -1, 0, 0, 1, 0, 0, 1, 2, 0, 0, 1, 2, 0, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 0, 1, 2, 0, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2 ); \n\n    // Iterate through the sequence\n    for (int j = 0; j < SEQ_LENGTH; ++j) {\n        int patternIndex = seq[j];\n        if (patternIndex == -1) {\n            sleep(8.0);\n            continue;\n        }\n        ivec2 offset = offsets[patternIndex];\n        int patternStart = offset.x, patternLength = offset.y;\n\n        // Iterate through the notes in the current pattern\n        for (int i = 0; i < patternLength; ++i) {\n            vec2 note = pat[patternStart + i];\n            combinedWaveform += stringsPlay(note.x - 12.0);\n            sleep(0.05);\n        }\n        sleep(8.0 - float(PAT_LENGTH) * 0.05);\n    }\n\n    return combinedWaveform;\n}\n\nfloat pluckLoop(float time) {\n    const int PAT_LENGTH = 12, SEQ_LENGTH = 55;\n    const int TOTAL_LENGTH = SEQ_LENGTH * PAT_LENGTH * 2;\n\n    // Calculate current time within the loop duration\n    currentTime = mod(time, tick_to_second * (float(TOTAL_LENGTH) / 3.0));\n    timeOffset = 0.0;\n    float combinedWaveform = 0.0;\n\n    // Define offset and length for each pattern\n    ivec2 offsets[2] = ivec2[](\n        ivec2(0, PAT_LENGTH),\n        ivec2(PAT_LENGTH, PAT_LENGTH)\n    );\n\n    // Combine all patterns into a single array with notes and amplitudes\n    vec2 pat[PAT_LENGTH * 2] = vec2[](\n        vec2(c5, 0.0), vec2(c5, 0.0), vec2(c4, 1.0), vec2(c5, 0.0), vec2(c4, 1.0), vec2(c5, 0.0), vec2(c4, 1.0), vec2(c5, 0.0), vec2(c5, 0.0), vec2(c4, 1.0), vec2(c5, 0.0), vec2(c4, 1.0),\n        vec2(d5, 0.0), vec2(d5, 0.0), vec2(d4, 1.0), vec2(d5, 0.0), vec2(d4, 1.0), vec2(d5, 0.0), vec2(d4, 1.0), vec2(d5, 0.0), vec2(d5, 0.0), vec2(d4, 1.0), vec2(d5, 0.0), vec2(d4, 1.0)\n    );\n\n    // Define sequence of patterns to play\n    int seq[SEQ_LENGTH] = int[](0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0);\n\n    // Iterate through the sequence, note each one is played twice\n    for (int j = 0; j < SEQ_LENGTH * 2; j++) {\n        int patternIndex = seq[j/2];\n        ivec2 offset = offsets[patternIndex];\n        int patternStart = offset.x, patternLength = offset.y;\n\n        // Iterate through the notes in the current pattern\n        for (int i = 0; i < patternLength; ++i) {\n            vec2 note = pat[patternStart + i];\n            float cutoff = 0.2 + note.y * 0.4;\n            combinedWaveform += pluckPlay(note.x, cutoff);\n            sleep(1.0 / 3.0);\n        }\n    }\n\n    return combinedWaveform;\n}\n\nfloat synth1Loop(float time) {\n    // Calculate current time within the loop duration. No need to loop time as we will never reach the end due to shadertoys audio time limit\n    currentTime = time;\n    timeOffset = 0.0;\n    float combinedWaveform = 0.0;\n\n    // Iterate through the sequence\n    for (int j = 0; j < SYNTH1_SEQ_LENGTH; ++j) {\n        int patternIndex = SYNTH1_SEQ[j];\n        if (patternIndex == -1) {\n            sleep(8.0);\n            continue;\n        }\n        ivec2 offset = SYNTH1_OFFSETS[patternIndex];\n        int patternStart = offset.x, patternLength = offset.y;\n\n        // Iterate through the notes in the current pattern\n        for (int i = 0; i < patternLength; ++i) {\n            vec2 note = SYNTH1_PAT[patternStart + i];\n            combinedWaveform += synth1Play(note.x - 12.0, note.y / 3.0 - 0.1);\n            sleep(note.y / 3.0);\n        }\n    }\n\n    return combinedWaveform;\n}\n\n\nfloat synth2Loop(float time) {\n    const int PAT0_LENGTH = 5, PAT1_LENGTH = 5, PAT2_LENGTH = 4, PAT3_LENGTH = 7, PAT4_LENGTH = 7, PAT5_LENGTH = 8, PAT6_LENGTH = 9, PAT7_LENGTH = 8, PAT8_LENGTH = 11, PAT9_LENGTH = 7, PAT10_LENGTH = 5, PAT11_LENGTH = 7, PAT12_LENGTH = 8, PAT13_LENGTH = 7, PAT14_LENGTH = 5, PAT15_LENGTH = 9, PAT16_LENGTH = 8, PAT17_LENGTH = 6, PAT18_LENGTH = 6, PAT19_LENGTH = 9, PAT20_LENGTH = 7, PAT21_LENGTH = 8, PAT22_LENGTH = 7, PAT23_LENGTH = 8, PAT24_LENGTH = 4;\n    const int SEQ_LENGTH = 78;\n\n    // Calculate current time within the loop duration. No need to loop time as we will never reach the end due to shadertoys audio time limit\n    currentTime = time;\n    timeOffset = 0.0;\n    float combinedWaveform = 0.0;\n\n    // Define offset and length for each pattern\n\tivec2 offsets[25] = ivec2[](\n\t\tivec2(0, PAT0_LENGTH),\n\t\tivec2(PAT0_LENGTH, PAT1_LENGTH),\n\t\tivec2(PAT0_LENGTH + PAT1_LENGTH, PAT2_LENGTH),\n\t\tivec2(PAT0_LENGTH + PAT1_LENGTH + PAT2_LENGTH, PAT3_LENGTH),\n\t\tivec2(PAT0_LENGTH + PAT1_LENGTH + PAT2_LENGTH + PAT3_LENGTH, PAT4_LENGTH),\n\t\tivec2(PAT0_LENGTH + PAT1_LENGTH + PAT2_LENGTH + PAT3_LENGTH + PAT4_LENGTH, PAT5_LENGTH),\n\t\tivec2(PAT0_LENGTH + PAT1_LENGTH + PAT2_LENGTH + PAT3_LENGTH + PAT4_LENGTH + PAT5_LENGTH, PAT6_LENGTH),\n\t\tivec2(PAT0_LENGTH + PAT1_LENGTH + PAT2_LENGTH + PAT3_LENGTH + PAT4_LENGTH + PAT5_LENGTH + PAT6_LENGTH, PAT7_LENGTH),\n\t\tivec2(PAT0_LENGTH + PAT1_LENGTH + PAT2_LENGTH + PAT3_LENGTH + PAT4_LENGTH + PAT5_LENGTH + PAT6_LENGTH + PAT7_LENGTH, PAT8_LENGTH),\n\t\tivec2(PAT0_LENGTH + PAT1_LENGTH + PAT2_LENGTH + PAT3_LENGTH + PAT4_LENGTH + PAT5_LENGTH + PAT6_LENGTH + PAT7_LENGTH + PAT8_LENGTH, PAT9_LENGTH),\n\t\tivec2(PAT0_LENGTH + PAT1_LENGTH + PAT2_LENGTH + PAT3_LENGTH + PAT4_LENGTH + PAT5_LENGTH + PAT6_LENGTH + PAT7_LENGTH + PAT8_LENGTH + PAT9_LENGTH, PAT10_LENGTH),\n\t\tivec2(PAT0_LENGTH + PAT1_LENGTH + PAT2_LENGTH + PAT3_LENGTH + PAT4_LENGTH + PAT5_LENGTH + PAT6_LENGTH + PAT7_LENGTH + PAT8_LENGTH + PAT9_LENGTH + PAT10_LENGTH, PAT11_LENGTH),\n\t\tivec2(PAT0_LENGTH + PAT1_LENGTH + PAT2_LENGTH + PAT3_LENGTH + PAT4_LENGTH + PAT5_LENGTH + PAT6_LENGTH + PAT7_LENGTH + PAT8_LENGTH + PAT9_LENGTH + PAT10_LENGTH + PAT11_LENGTH, PAT12_LENGTH),\n\t\tivec2(PAT0_LENGTH + PAT1_LENGTH + PAT2_LENGTH + PAT3_LENGTH + PAT4_LENGTH + PAT5_LENGTH + PAT6_LENGTH + PAT7_LENGTH + PAT8_LENGTH + PAT9_LENGTH + PAT10_LENGTH + PAT11_LENGTH + PAT12_LENGTH, PAT13_LENGTH),\n\t\tivec2(PAT0_LENGTH + PAT1_LENGTH + PAT2_LENGTH + PAT3_LENGTH + PAT4_LENGTH + PAT5_LENGTH + PAT6_LENGTH + PAT7_LENGTH + PAT8_LENGTH + PAT9_LENGTH + PAT10_LENGTH + PAT11_LENGTH + PAT12_LENGTH + PAT13_LENGTH, PAT14_LENGTH),\n\t\tivec2(PAT0_LENGTH + PAT1_LENGTH + PAT2_LENGTH + PAT3_LENGTH + PAT4_LENGTH + PAT5_LENGTH + PAT6_LENGTH + PAT7_LENGTH + PAT8_LENGTH + PAT9_LENGTH + PAT10_LENGTH + PAT11_LENGTH + PAT12_LENGTH + PAT13_LENGTH + PAT14_LENGTH, PAT15_LENGTH),\n\t\tivec2(PAT0_LENGTH + PAT1_LENGTH + PAT2_LENGTH + PAT3_LENGTH + PAT4_LENGTH + PAT5_LENGTH + PAT6_LENGTH + PAT7_LENGTH + PAT8_LENGTH + PAT9_LENGTH + PAT10_LENGTH + PAT11_LENGTH + PAT12_LENGTH + PAT13_LENGTH + PAT14_LENGTH + PAT15_LENGTH, PAT16_LENGTH),\n\t\tivec2(PAT0_LENGTH + PAT1_LENGTH + PAT2_LENGTH + PAT3_LENGTH + PAT4_LENGTH + PAT5_LENGTH + PAT6_LENGTH + PAT7_LENGTH + PAT8_LENGTH + PAT9_LENGTH + PAT10_LENGTH + PAT11_LENGTH + PAT12_LENGTH + PAT13_LENGTH + PAT14_LENGTH + PAT15_LENGTH + PAT16_LENGTH, PAT17_LENGTH),\n\t\tivec2(PAT0_LENGTH + PAT1_LENGTH + PAT2_LENGTH + PAT3_LENGTH + PAT4_LENGTH + PAT5_LENGTH + PAT6_LENGTH + PAT7_LENGTH + PAT8_LENGTH + PAT9_LENGTH + PAT10_LENGTH + PAT11_LENGTH + PAT12_LENGTH + PAT13_LENGTH + PAT14_LENGTH + PAT15_LENGTH + PAT16_LENGTH + PAT17_LENGTH, PAT18_LENGTH),\n\t\tivec2(PAT0_LENGTH + PAT1_LENGTH + PAT2_LENGTH + PAT3_LENGTH + PAT4_LENGTH + PAT5_LENGTH + PAT6_LENGTH + PAT7_LENGTH + PAT8_LENGTH + PAT9_LENGTH + PAT10_LENGTH + PAT11_LENGTH + PAT12_LENGTH + PAT13_LENGTH + PAT14_LENGTH + PAT15_LENGTH + PAT16_LENGTH + PAT17_LENGTH + PAT18_LENGTH, PAT19_LENGTH),\n\t\tivec2(PAT0_LENGTH + PAT1_LENGTH + PAT2_LENGTH + PAT3_LENGTH + PAT4_LENGTH + PAT5_LENGTH + PAT6_LENGTH + PAT7_LENGTH + PAT8_LENGTH + PAT9_LENGTH + PAT10_LENGTH + PAT11_LENGTH + PAT12_LENGTH + PAT13_LENGTH + PAT14_LENGTH + PAT15_LENGTH + PAT16_LENGTH + PAT17_LENGTH + PAT18_LENGTH + PAT19_LENGTH, PAT20_LENGTH),\n\t\tivec2(PAT0_LENGTH + PAT1_LENGTH + PAT2_LENGTH + PAT3_LENGTH + PAT4_LENGTH + PAT5_LENGTH + PAT6_LENGTH + PAT7_LENGTH + PAT8_LENGTH + PAT9_LENGTH + PAT10_LENGTH + PAT11_LENGTH + PAT12_LENGTH + PAT13_LENGTH + PAT14_LENGTH + PAT15_LENGTH + PAT16_LENGTH + PAT17_LENGTH + PAT18_LENGTH + PAT19_LENGTH + PAT20_LENGTH, PAT21_LENGTH),\n\t\tivec2(PAT0_LENGTH + PAT1_LENGTH + PAT2_LENGTH + PAT3_LENGTH + PAT4_LENGTH + PAT5_LENGTH + PAT6_LENGTH + PAT7_LENGTH + PAT8_LENGTH + PAT9_LENGTH + PAT10_LENGTH + PAT11_LENGTH + PAT12_LENGTH + PAT13_LENGTH + PAT14_LENGTH + PAT15_LENGTH + PAT16_LENGTH + PAT17_LENGTH + PAT18_LENGTH + PAT19_LENGTH + PAT20_LENGTH + PAT21_LENGTH, PAT22_LENGTH),\n\t\tivec2(PAT0_LENGTH + PAT1_LENGTH + PAT2_LENGTH + PAT3_LENGTH + PAT4_LENGTH + PAT5_LENGTH + PAT6_LENGTH + PAT7_LENGTH + PAT8_LENGTH + PAT9_LENGTH + PAT10_LENGTH + PAT11_LENGTH + PAT12_LENGTH + PAT13_LENGTH + PAT14_LENGTH + PAT15_LENGTH + PAT16_LENGTH + PAT17_LENGTH + PAT18_LENGTH + PAT19_LENGTH + PAT20_LENGTH + PAT21_LENGTH + PAT22_LENGTH, PAT23_LENGTH),\n\t\tivec2(PAT0_LENGTH + PAT1_LENGTH + PAT2_LENGTH + PAT3_LENGTH + PAT4_LENGTH + PAT5_LENGTH + PAT6_LENGTH + PAT7_LENGTH + PAT8_LENGTH + PAT9_LENGTH + PAT10_LENGTH + PAT11_LENGTH + PAT12_LENGTH + PAT13_LENGTH + PAT14_LENGTH + PAT15_LENGTH + PAT16_LENGTH + PAT17_LENGTH + PAT18_LENGTH + PAT19_LENGTH + PAT20_LENGTH + PAT21_LENGTH + PAT22_LENGTH + PAT23_LENGTH, PAT24_LENGTH)\n\t);\n\n\n\t// Pattern data array\n    vec2 patterns[PAT0_LENGTH + PAT1_LENGTH + PAT2_LENGTH + PAT3_LENGTH + PAT4_LENGTH + PAT5_LENGTH + PAT6_LENGTH + PAT7_LENGTH + PAT8_LENGTH + PAT9_LENGTH + PAT10_LENGTH + PAT11_LENGTH + PAT12_LENGTH + PAT13_LENGTH + PAT14_LENGTH + PAT15_LENGTH + PAT16_LENGTH + PAT17_LENGTH + PAT18_LENGTH + PAT19_LENGTH + PAT20_LENGTH + PAT21_LENGTH + PAT22_LENGTH + PAT23_LENGTH + PAT24_LENGTH] = vec2[](\n\t\tvec2(ds5, 1.0), vec2(d5, 1.0), vec2(ds5, 1.0), vec2(c5, 2.0), vec2(g4, 7.0),\n\t\tvec2(as4, 1.0), vec2(a4, 1.0), vec2(as4, 1.0), vec2(g4, 2.0), vec2(d4, 7.0),\n\t\tvec2(a4, 1.0), vec2(g4, 1.0), vec2(f4, 1.0), vec2(c5, 7.0),\n\t\tvec2(a4, 1.0), vec2(g4, 1.0), vec2(f4, 1.0), vec2(a4, 1.0), vec2(g4, 1.0), vec2(f4, 1.0), vec2(c5, 6.0),\n\t\tvec2(ds5, 1.0), vec2(d5, 1.0), vec2(ds5, 1.0), vec2(c5, 2.0), vec2(g4, 3.0), vec2(ds5, 3.0), vec2(g4, 1.0),\n\t\tvec2(ds5, 1.0), vec2(d5, 1.0), vec2(ds5, 1.0), vec2(c5, 2.0), vec2(g4, 3.0), vec2(ds5, 1.0), vec2(d5, 2.0), vec2(c5, 1.0),\n\t\tvec2(as4, 1.0), vec2(a4, 1.0), vec2(g4, 1.0), vec2(as4, 1.0), vec2(a4, 1.0), vec2(g4, 1.0), vec2(d5, 2.0), vec2(g4, 3.0), vec2(g4, 1.0),\n\t\tvec2(as4, 1.0), vec2(a4, 1.0), vec2(g4, 1.0), vec2(as4, 2.0), vec2(d4, 3.0), vec2(as4, 1.0), vec2(a4, 2.0), vec2(g4, 1.0),\n\t\tvec2(a4, 2.0), vec2(f4, 2.0), vec2(a4, 2.0), vec2(c5, 2.0), vec2(a4, 2.0), vec2(c5, 2.0), vec2(f5, 2.0), vec2(c5, 2.0), vec2(f5, 2.0), vec2(a5, 2.0), vec2(f5, 4.0),\n\t\tvec2(ds6, 1.0), vec2(d6, 1.0), vec2(ds6, 1.0), vec2(c6, 2.0), vec2(g5, 3.0), vec2(ds6, 3.0), vec2(g5, 1.0),\n\t\tvec2(ds6, 2.0), vec2(g5, 1.0), vec2(d6, 2.0), vec2(c6, 3.0), vec2(g5, 4.0),\n\t\tvec2(as5, 1.0), vec2(a5, 1.0), vec2(as5, 1.0), vec2(g5, 2.0), vec2(d5, 3.0), vec2(as5, 3.0), vec2(d5, 1.0),\n\t\tvec2(as5, 1.0), vec2(a5, 1.0), vec2(g5, 1.0), vec2(as5, 1.0), vec2(a5, 1.0), vec2(g5, 1.0), vec2(d6, 2.0), vec2(g5, 4.0),\n\t\tvec2(a5, 1.0), vec2(g5, 1.0), vec2(f5, 1.0), vec2(f5, 2.0), vec2(c6, 3.0), vec2(f5, 3.0), vec2(f5, 1.0),\n\t\tvec2(a5, 2.0), vec2(g5, 1.0), vec2(f5, 2.0), vec2(c6, 3.0), vec2(f5, 4.0),\n\t\tvec2(d6, 1.0), vec2(c6, 1.0), vec2(as5, 1.0), vec2(d6, 1.0), vec2(c6, 1.0), vec2(as5, 1.0), vec2(d6, 2.0), vec2(g5, 3.0), vec2(g5, 1.0),\n\t\tvec2(d6, 1.0), vec2(c6, 1.0), vec2(d6, 1.0), vec2(as5, 2.0), vec2(g5, 3.0), vec2(d6, 1.0), vec2(c6, 2.0), vec2(as5, 1.0),\n\t\tvec2(a5, 2.0), vec2(g5, 1.0), vec2(f5, 2.0), vec2(c6, 3.0), vec2(f5, 3.0), vec2(f5, 1.0),\n\t\tvec2(a5, 1.0), vec2(g5, 1.0), vec2(a5, 1.0), vec2(f5, 2.0), vec2(c6, 3.0), vec2(f5, 4.0),\n\t\tvec2(ds5, 1.0), vec2(d5, 1.0), vec2(c5, 1.0), vec2(ds5, 1.0), vec2(d5, 1.0), vec2(c5, 1.0), vec2(ds5, 2.0), vec2(g4, 3.0), vec2(g4, 1.0),\n\t\tvec2(as4, 1.0), vec2(a4, 1.0), vec2(as4, 1.0), vec2(g4, 2.0), vec2(d4, 3.0), vec2(as4, 3.0), vec2(d4, 1.0),\n\t\tvec2(d5, 1.0), vec2(c5, 1.0), vec2(as4, 1.0), vec2(d5, 1.0), vec2(c5, 1.0), vec2(as4, 1.0), vec2(d5, 2.0), vec2(g4, 4.0),\n\t\tvec2(a4, 1.0), vec2(g4, 1.0), vec2(f4, 1.0), vec2(f4, 2.0), vec2(c5, 3.0), vec2(f4, 3.0), vec2(f4, 1.0),\n\t\tvec2(a4, 1.0), vec2(g4, 1.0), vec2(f4, 1.0), vec2(a4, 1.0), vec2(g4, 1.0), vec2(f4, 1.0), vec2(c5, 2.0), vec2(f4, 4.0),\n\t\tvec2(a4, 2.0), vec2(g4, 2.5), vec2(f4, 1.56), vec2(c5, 6.0)\n\t);\n\n    // Define sequence of patterns to play\n    int seq[SEQ_LENGTH] = int[]( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 1, 1, 2, 3, 0, 0, 1, 1, 2, 24, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 9, 10, 15, 16, 17, 18, 4, 19, 20, 21, 22, 23, 9, 10, 15, 16, 17, 18);     \n\n\t// Iterate through the sequence\n    for (int j = 0; j < SEQ_LENGTH; ++j) {\n        int patternIndex = seq[j];\n        if (patternIndex == -1) {\n            sleep(8.0);\n            continue;\n        }\n        ivec2 offset = offsets[patternIndex];\n        int patternStart = offset.x, patternLength = offset.y;\n\n        // Iterate through the notes in the current pattern\n        for (int i = 0; i < patternLength; ++i) {\n            vec2 note = patterns[patternStart + i];\n            combinedWaveform += synth2Play(note.x - 12.0, note.y / 3.0 * 0.9);\n            sleep(note.y / 3.0);\n        }\n\t}\n\n    return combinedWaveform;\n}\n\nfloat renderSounds(float time)\n{\n    timeOffset=0.0;\n    currentTime = time;\n\n    float combinedWaveform=0.0;\n    combinedWaveform += rythmLoop(time);\n    combinedWaveform += noiseLoop(time);\n    combinedWaveform += bassLoop(time);\n    combinedWaveform += stringsLoop(time)*0.5; //TODO: Make it not suck\n    combinedWaveform += pluckLoop(time);\n    combinedWaveform += synth1Loop(time);\n    combinedWaveform += synth2Loop(time);\n\n    return combinedWaveform;\n}\n\nvec2 mainSound(int samp, float time) {\n\n    //Do a controlled repeat, seems Shadertoy will overflow these registers after some time due to the high sample frequency? This happens on my computer anyway.\n    //Unfortunately this means we cannot play the entire 4 min+ song, however all the song data is present in the shader in case this changes in the future. Will have to QA the later parts of the song in that case, channels might have gone off sync a bit in the end\n    time=mod(time,100.0);\n    currentSample=samp % 65536;\n\n    float combinedWaveform = 0.0;\n    combinedWaveform+=renderSounds(time);\n    \n    combinedWaveform = softClip(combinedWaveform)*0.5;\n    vec2 audio=vec2(combinedWaveform,combinedWaveform);\n    return audio;\n    \n    // Optional loudness curve adjustment\n    //return 1.5*audio-.5*audio*audio*audio;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "// Soundfonts and helper methods\n// Thanks to Srtuss for his Ditty's\n\n// Define MIDI note numbers for readability\n#define c0 12.\n#define cs0 13.\n#define d0 14.\n#define ds0 15.\n#define e0 16.\n#define f0 17.\n#define fs0 18.\n#define g0 19.\n#define gs0 20.\n#define a0 21.\n#define as0 22.\n#define b0 23.\n#define c1 24.\n#define cs1 25.\n#define d1 26.\n#define ds1 27.\n#define e1 28.\n#define f1 29.\n#define fs1 30.\n#define g1 31.\n#define gs1 32.\n#define a1 33.\n#define as1 34.\n#define b1 35.\n#define c2 36.\n#define cs2 37.\n#define d2 38.\n#define ds2 39.\n#define e2 40.\n#define f2 41.\n#define fs2 42.\n#define g2 43.\n#define gs2 44.\n#define a2 45.\n#define as2 46.\n#define b2 47.\n#define c3 48.\n#define cs3 49.\n#define d3 50.\n#define ds3 51.\n#define e3 52.\n#define f3 53.\n#define fs3 54.\n#define g3 55.\n#define gs3 56.\n#define a3 57.\n#define as3 58.\n#define b3 59.\n#define c4 60.\n#define cs4 61.\n#define d4 62.\n#define ds4 63.\n#define e4 64.\n#define f4 65.\n#define fs4 66.\n#define g4 67.\n#define gs4 68.\n#define a4 69.\n#define as4 70.\n#define b4 71.\n#define c5 72.\n#define cs5 73.\n#define d5 74.\n#define ds5 75.\n#define e5 76.\n#define f5 77.\n#define fs5 78.\n#define g5 79.\n#define gs5 80.\n#define a5 81.\n#define as5 82.\n#define b5 83.\n#define c6 84.\n#define cs6 85.\n#define d6 86.\n#define ds6 87.\n#define e6 88.\n#define f6 89.\n#define fs6 90.\n#define g6 91.\n#define gs6 92.\n#define a6 93.\n#define as6 94.\n#define b6 95.\n#define c7 96.\n#define cs7 97.\n#define d7 98.\n#define ds7 99.\n#define e7 100.\n#define f7 101.\n#define fs7 102.\n#define g7 103.\n#define gs7 104.\n#define a7 105.\n#define as7 106.\n#define b7 107.\n#define c8 108.\n#define cs8 109.\n#define d8 110.\n#define ds8 111.\n#define e8 112.\n#define f8 113.\n#define fs8 114.\n#define g8 115.\n#define gs8 116.\n#define a8 117.\n#define as8 118.\n#define b8 119.\n#define c9 120.\n#define cs9 121.\n#define d9 122.\n#define ds9 123.\n#define e9 124.\n#define f9 125.\n#define fs9 126.\n#define g9 127.\n\n#define PI 3.14159265359\n#define PI2 (PI * 2.0)\n#define BPM 123.0\n\n#define tick_to_second (60.0 / BPM)\n#define second_to_tick (1.0 / (60.0 / BPM))\n\nint currentSample;\nfloat currentTime = 0.0;\nfloat timeOffset = 0.0;\n\nstruct Envelope {\n    float attack;\n    float decay;\n    float sustain;\n    float release;\n    float durationTicks;\n};\n\nEnvelope createDefaultEnvelope() {\n    Envelope env;\n    env.attack = 0.01;\n    env.decay = 0.0;\n    env.sustain = 1.0;\n    env.release = 0.5;\n    env.durationTicks = 0.0;\n    return env;\n}\n\nvoid sleep(float ticks) {\n    timeOffset += ticks * tick_to_second;\n}\n\n// Convert frequency to MIDI note number\nfloat hz_to_midi(float hz) {\n    return (69.0 + 12.0 * log2(hz / 440.0));\n}\n\n// Convert MIDI note number to frequency\nfloat midi_to_hz(float midi) {\n    return 440.0 * pow(2.0, (midi - 69.0) / 12.0);\n}\n\nfloat softClip(float x) {\n    return x / 2.0;\n}\n\nfloat softClip2(float x) {\n    return x < -1.0 ? -1.0 : x > 1.0 ? 1.0 : 1.5 * (1.0 - x * x / 3.0) * x;\n}\n\nfloat varsaw(float p, float formant) {\n    float x = mod(p, 1.0);\n    return (x - 0.5) * softClip2(formant * x * (1.0 - x));\n}\n\nfloat smoooth(float f){\n    f = 6.0 * pow(f, 5.0) - 15.0 * pow(f, 4.0) +  10.0 * pow(f, 3.0);\n    return fract(f);\n}\n\nfloat hash(float p) {\n\tvec3 p3 = fract(vec3(p) * 0.1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat fade(float t) { return t*t*t*(t*(6.*t-15.)+10.); } // interpolation\nfloat grad(float hash, float p) { // gradient\n    int i = int(mod(floor(1e4 * hash), 2.0));\n    return i == 0 ? p : -p;\n}\n\n//By using a perlin noise generator we can play noise with varying pitch for the wind effects\nfloat perlin(float p) {\n\tfloat pi = floor(p);\n\tfloat pf = p - pi;\n\tfloat w = fade(pf);\n    return mix(grad(hash(pi), pf), grad(hash(pi + 1.0), pf - 1.0), w) * 2.0;\n}\n\nfloat random(int seed) {\n    int n = (seed << 13) ^ seed;\n    int nn = (n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff;\n    float res = float(nn) / float(0x7fffffff);\n    return res;\n}\n\n// DurationTicks is attack + decay or more\nfloat adsr(float t, Envelope env) {\n    if (t < 0.0) return 0.0;\n    float minDuration = env.attack + env.decay;\n    float duration = max(minDuration, env.durationTicks * tick_to_second);\n    if (t > duration + env.release) return 0.0;\n    if (t < env.attack) {\n        return t / env.attack;\n    }\n    t -= env.attack;\n    if (t < env.decay) {\n        return 1.0 - (1.0 - env.sustain) * (t / env.decay);\n    }\n    t -= env.decay;\n    if (t < (duration - minDuration)) {\n        return env.sustain;\n    }\n    t -= (duration - minDuration);\n    if (t < env.release) {\n        return env.sustain * (1.0 - t / env.release);\n    }\n    return 0.0;\n}\n\nstruct Tank {\n    float freq;\n    float amp;\n};\n\nTank createTank(float freq, float amp) {\n    Tank tank;\n    tank.freq = freq;\n    tank.amp = amp;\n    return tank;\n}\n\nfloat tankPlay(float time, Envelope env, Tank tank) {\n    float phase = time * tank.freq;\n    float envValue = adsr(time, env);\n    return sin(phase * PI2) * envValue * tank.amp;\n}\n\nfloat bassdrumPlay() {\n    float time = currentTime - timeOffset;\n    if (time < 0.0) return 0.0;\n    Tank bassdrum = createTank(65.0, 1.0);\n    Envelope env = createDefaultEnvelope();\n    env.attack = 0.001;\n    env.release = 0.165;\n    return tankPlay(time, env, bassdrum);\n}\n\nfloat congaPlay() {\n    float time = currentTime - timeOffset;\n    if (time < 0.0) return 0.0;\n    Tank conga = createTank(195.0, 0.5);\n    Envelope env = createDefaultEnvelope();\n    env.attack = 0.001;\n    env.release = 0.165;\n    return tankPlay(time, env, conga);\n}\n\nfloat smallBongoPlay() {\n    float time = currentTime - timeOffset;\n    if (time < 0.0) return 0.0;\n    Tank smallbongo = createTank(600.0, 0.5);\n    Envelope env = createDefaultEnvelope();\n    env.attack = 0.001;\n    env.release = 0.05;\n    return tankPlay(time, env, smallbongo);\n}\n\nfloat largeBongoPlay() {\n    float time = currentTime - timeOffset;\n    if (time < 0.0) return 0.0;\n    Tank largebongo = createTank(400.0, 0.5);\n    Envelope env = createDefaultEnvelope();\n    env.attack = 0.001;\n    env.release = 0.08;\n    return tankPlay(time, env, largebongo);\n}\n\nfloat clavesPlay() {\n    float time = currentTime - timeOffset;\n    if (time < 0.0) return 0.0;\n    Tank claves = createTank(2200.0, 1.0);\n    Envelope env = createDefaultEnvelope();\n    env.attack = 0.001;\n    env.release = 0.05;\n    return tankPlay(time, env, claves);\n}\n\nfloat rimshotPlay() {\n    float time = currentTime - timeOffset;\n    if (time < 0.0) return 0.0;\n    Tank rimshot = createTank(1860.0, 0.3);\n    Envelope env = createDefaultEnvelope();\n    env.attack = 0.0005;\n    env.release = 0.01;\n    return tankPlay(time, env, rimshot);\n}\n\nfloat hihatPlay() {\n    float time = currentTime - timeOffset;\n    if (time < 0.0) return 0.0;\n    Envelope env = createDefaultEnvelope();\n    env.attack = 0.0;\n    env.release = 0.04;\n    float envValue = adsr(time, env);\n    return (random(currentSample) - 0.5) * envValue * 0.4;\n}\n\nfloat cymbalPlay() {\n    float time = currentTime - timeOffset;\n    if (time < 0.0) return 0.0;\n    Envelope env = createDefaultEnvelope();\n    env.attack = 0.0;\n    env.release = 0.2;\n    float envValue = adsr(time, env);\n    return (random(currentSample) - 0.5) * envValue * 0.3;\n}\n\nfloat quijadaPlay() {\n    float time = currentTime - timeOffset;\n    if (time < 0.0) return 0.0;\n    Envelope env = createDefaultEnvelope();\n    env.attack = 0.055;\n    env.durationTicks = 2.0;\n    float p = mod((time * 25.0 + 0.75), 1.0) / 25.0;  // Pulses at 25Hz\n    float p2 = mod((time * 25.0), 1.0) / 25.0;  // Pulses at 25Hz\n    float v = sin(p * PI2 * 2700.0) * pow(0.6, max(p * 2750.0 - 2.0, 0.0)) * exp(-time * 10.0);  // Main vibration\n    v -= sin(p2 * PI2 * 2700.0) * pow(0.6, max(p2 * 2750.0 - 2.0, 0.0)) * 0.25 * exp(-time * 20.0);  // Secondary vibration dampened\n    float envValue = adsr(time, env);\n    return v * envValue;\n}\n\nfloat bassPlay(float note) {\n    float time = currentTime - timeOffset;\n    if (time<0.0) return 0.0;\n    Envelope env = createDefaultEnvelope();\n    env.attack = 0.01;\n    \n    float freq = midi_to_hz(note);\n    float bass_phase = freq * time;\n\n    float formant = 4.0 + (500.0 * exp(-time * 5.0) + 10.0 * env.sustain) * 0.1;\n    float waveform = varsaw(bass_phase, formant);\n\n    float envValue = adsr(time, env);\n\n    return waveform * envValue;\n}\n\nstruct Analog {\n    int nuni;\n    float cutoff;\n    float fa;\n    float fd;\n    float detune;\n    float amp;\n};\n\nfloat playAnalog(float note, Analog params, Envelope env) {\n    float time = currentTime - timeOffset;\n    if (time < 0.0) return 0.0;\n\n    float freq = midi_to_hz(note);\n    float phase = mod(time * freq, 1.0);  // Normalized phase\n    float dynamicCutoff = 4.0 + min(1.0, time / params.fa) * exp(-max(0.0, time - params.fa) * params.fd) * params.cutoff * 100.0;\n    float waveform = varsaw(phase, dynamicCutoff * 0.008 / (freq / iSampleRate));\n    float envValue = adsr(time, env);\n    \n    return waveform * envValue * params.amp;\n}\n\nfloat pluckPlay(float note, float cutoff) {\n    Analog params;\n    params.nuni = 2;\n    params.cutoff = cutoff;\n    params.fa = 0.01;\n    params.fd = 30.0;\n    params.detune = 0.3;\n    params.amp = 0.3;\n\n    Envelope env = createDefaultEnvelope();\n    env.attack = 0.005;\n    env.release = 0.3;\n    env.durationTicks = 0.1;\n\n    return playAnalog(note, params, env);\n}\n\nfloat synth1Play(float note, float duration) {\n    Analog params;\n    params.nuni = 4;\n    params.cutoff = 0.3;\n    params.fa = 0.15;\n    params.fd = 4.0;\n    params.detune = 0.3;\n    params.amp = 0.3;\n\n    Envelope env = createDefaultEnvelope();\n    env.attack = 0.1;\n    env.decay = 0.5;\n    env.sustain = 0.6;\n    env.release = 1.0;\n    env.durationTicks = duration;\n\n    return playAnalog(note, params, env);\n}\n\nfloat synth2Play(float note, float duration) {\n    float time = currentTime - timeOffset;\n    if (time < 0.0) return 0.0;\n\n    Envelope env = createDefaultEnvelope();\n    env.release = 0.1;\n    env.durationTicks = duration;\n\n    float envValue = adsr(time, env);\n    if (envValue>0.0)\n    {\n        float freq = midi_to_hz(note-12.0);\n        float p=currentTime*freq;\n        float sam=varsaw(p,10.6)*envValue;\n        sam = mod(p, 1.0)-0.5;\n        return sam*0.6;\n    }\n    return 0.0;\n\n}\n\nfloat noisePlay() {\n    float time = currentTime - timeOffset;\n    if (time < 0.0) return 0.0;\n\n    Envelope env = createDefaultEnvelope();\n    env.attack = 0.1;\n    env.decay = 1.0;\n    env.sustain = 0.8;\n    env.release = 5.0;\n    env.durationTicks = 1.0;\n\n    float envValue = adsr(time, env);\n    if (envValue>0.0)\n    {\n        float tick = time * second_to_tick;\n        float s=(time/2.0)+1.0;\n        float noise = perlin(time*(15000.0/s))/2.0;\n        return noise * envValue * 0.12;\n    }\n    return 0.0;\n}\n\n\n// TODO:--------------------------------------------------------------------------------\n// Making state-based filters and sounds in state-less GLSL is tricky, WIP\nfloat phaserFilter(float time, float s) {\n    // Phaser parameters\n    float rate = 0.01;      // LFO rate in Hz\n    float depth = 0.7;     // Depth of the phaser effect\n    float feedback = 0.4;  // Feedback amount\n    int stages = 3;        // Number of phaser stages\n\n    // Low-frequency oscillator (LFO) for phase modulation\n    float lfo = sin(2.0 * PI * rate * time);\n\n    // Initialize variables\n    float phase = s;\n    float modulatedFreq;\n\n    // Apply multiple stages of the phaser effect\n    for (int i = 0; i < stages; ++i) {\n        // Calculate the modulated frequency with LFO\n        modulatedFreq = phase + depth * lfo;\n\n        // Create the notch effect\n        phase = sin(2.0 * PI * modulatedFreq);\n\n        // Apply feedback\n        s += feedback * phase;\n    }\n\n    return s;\n}\n\nfloat stringsPlay(float note) {\n    float time = currentTime - timeOffset;\n    if (time < 0.0) return 0.0;\n\n    Envelope env = createDefaultEnvelope();\n    env.attack = 3.0;\n    //env.decay = 1.0;\n    //env.sustain = 0.8;\n    env.release = 3.0;\n    //env.durationTicks = 8.0;\n\n    float envValue = adsr(time, env);\n    if (envValue>0.0)\n    {\n        float freq = midi_to_hz(note);\n        float sam=varsaw(currentTime*freq,1.2)*envValue;\n        return phaserFilter(time, sam)*0.1;\n    }\n    return 0.0;\n\n}\n//--------------------------------------------------------------------------------\n\n\n// We declare these audiotrack data in Common since it is shared by both the audio renderer and the image renderer\nconst int SYNTH1_PAT0_LENGTH = 5, SYNTH1_PAT1_LENGTH = 5, SYNTH1_PAT2_LENGTH = 4, SYNTH1_PATB0_LENGTH = 6, SYNTH1_PATB1_LENGTH = 6, SYNTH1_PATB2_LENGTH = 6;\nconst int SYNTH1_SEQ_LENGTH = 87;\n// Define offset and length for each SYNTH1 pattern\nivec2 SYNTH1_OFFSETS[6] = ivec2 [](\n    ivec2(0, SYNTH1_PAT0_LENGTH),\n    ivec2(SYNTH1_PAT0_LENGTH, SYNTH1_PAT1_LENGTH),\n    ivec2(SYNTH1_PAT0_LENGTH + SYNTH1_PAT1_LENGTH, SYNTH1_PAT2_LENGTH),\n    ivec2(SYNTH1_PAT0_LENGTH + SYNTH1_PAT1_LENGTH + SYNTH1_PAT2_LENGTH, SYNTH1_PATB0_LENGTH),\n    ivec2(SYNTH1_PAT0_LENGTH + SYNTH1_PAT1_LENGTH + SYNTH1_PAT2_LENGTH + SYNTH1_PATB0_LENGTH, SYNTH1_PATB1_LENGTH),\n    ivec2(SYNTH1_PAT0_LENGTH + SYNTH1_PAT1_LENGTH + SYNTH1_PAT2_LENGTH + SYNTH1_PATB0_LENGTH + SYNTH1_PATB1_LENGTH, SYNTH1_PATB2_LENGTH)\n);\n// SYNTH1 pattern data array\nvec2 SYNTH1_PAT[SYNTH1_PAT0_LENGTH + SYNTH1_PAT1_LENGTH + SYNTH1_PAT2_LENGTH + SYNTH1_PATB0_LENGTH + SYNTH1_PATB1_LENGTH + SYNTH1_PATB2_LENGTH] = vec2[](\n    vec2(c6, 5.0), vec2(g5, 1.0), vec2(ds5, 2.0), vec2(g5, 3.0), vec2(c5, 13.0),\n    vec2(as5, 5.0), vec2(a5, 1.0), vec2(g5, 2.0), vec2(a5, 3.0), vec2(d5, 13.0),\n    vec2(a5, 2.0), vec2(g5, 1.0), vec2(f5, 2.0), vec2(c5, 7.0),\n    vec2(c6, 1.0), vec2(g6, 1.0), vec2(c6, 1.0), vec2(g6, 1.0), vec2(c6, 1.0), vec2(g6, 7.0),\n    vec2(d6, 1.0), vec2(as6, 1.0), vec2(d6, 1.0), vec2(as6, 1.0), vec2(d6, 1.0), vec2(as6, 7.0),\n    vec2(f6, 1.0), vec2(c7, 1.0), vec2(f6, 1.0), vec2(c7, 1.0), vec2(f6, 1.0), vec2(c7, 7.0)\n);\n\n// Define SYNTH1 sequence of patterns to play\nint SYNTH1_SEQ[SYNTH1_SEQ_LENGTH] = int[](-1, -1, 0, 0, 1, 0, 0, 1, 2, 2, 0, 0, 1, 2, 2, 0, 0, 1, 2, 2, 3, 3, 4, 4, 5, 5, 3, 3, 4, 4, 5, 5, 3, 3, 4, 4, 5, 5, 0, 0, 1, 2, 2, 0, 0, 1, 2, 2, 3, 3, 4, 4, 5, 5, 3, 3, 4, 4, 5, 5, 3, 3, 4, 4, 5, 5, 3, 3, 4, 4, 5, 5, 3, 3, 4, 4, 5, 5, 3, 3, 4, 4, 5, 5, -1, -1, -1 );\n\n//For the visual sync only\nfloat getCurrentAudio(float time) {\n\n    // Calculate current time within the loop duration. No need to loop time as we will never reach the end due to shadertoys audio time limit\n    float currentTime = time;\n    float timeOffset = 8.0 * 2.0 * tick_to_second;\n\n    // Iterate through the SYNTH1 sequence. Skipping the silent parts to avoid costly branching\n    for (int j = 2; j < SYNTH1_SEQ_LENGTH-3; ++j) {\n        int patternIndex = SYNTH1_SEQ[j];\n        ivec2 offset = SYNTH1_OFFSETS[patternIndex];\n        int patternStart = offset.x, patternLength = offset.y;\n\n        // Iterate through the notes in the current pattern and find the active one\n        for (int i = 0; i < patternLength; ++i) {\n            vec2 note = SYNTH1_PAT[patternStart + i];\n            timeOffset += (note.y / 3.0) * tick_to_second;\n            if (currentTime - timeOffset<0.0)\n                return -timeOffset/4.0;\n        }\n    }\n    return 0.0;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}