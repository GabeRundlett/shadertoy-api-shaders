{
    "Shader": {
        "info": {
            "date": "1494825396",
            "description": "Probabilisticly generated music",
            "flags": 40,
            "hasliked": 0,
            "id": "ldXBzH",
            "likes": 13,
            "name": "Jammin",
            "published": 3,
            "tags": [
                "sound",
                "music",
                "random",
                "audio",
                "chiptune",
                "chords",
                "jammin"
            ],
            "usePreview": 0,
            "username": "tehsauce",
            "viewed": 1028
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(texture(iChannel0, uv).rgb,1.0);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define C 1046.50\n#define D 1174.66\n#define E 1318.51\n#define F 1396.91\n#define G 1567.98\n#define A 1760.00\n#define B 1975.53\n#define C2 2093.00\n\n#define HASHSCALE1 .1031\n\nfloat[] notes = float[](C, D, E, F, G, A, B, C2); \nint[] C135 = int[](0, 2, 4);\n\nfloat note(int idx, int octave, float amp, float t) {\n\treturn amp*sin(exp2(float(octave))*notes[idx%8]*mod(t,2.0)*6.28318*0.2);   \n}\n\nfloat noteSaw(int idx, int octave, float amp, float t) {\n\treturn amp*tan(sin(exp2(float(octave))*notes[idx%8]*mod(t,2.0)*6.28318*0.2));   \n}\n\nfloat noteSquare(int idx, int octave, float amp, float t) {\n\treturn 3.0*amp*pow(fract(exp2(float(octave))*notes[idx%8]*floor(mod(4.0*t,2.0)+1.0)*mod(t,2.0)*0.05)-0.5,1.0);   \n}\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nint rand1To8( float time ) {\n\treturn int(hash11(time)*8.0);   \n}\n\nfloat chordSaw(int idx, float t) {\n    return noteSquare( idx+C135[0], 0, 0.3, t) + \n           noteSaw( idx+C135[1], 1, 0.3, t) +\n           noteSaw( idx+C135[2], 0, 0.15, t); \n}\n\nint melody( float time, int chord ) {\n    int note;\n    time = mod(time,64.)< 32. ? mod(time,32.0)-94. : time;\n    float speed = floor(2.0*hash11(floor(time*2.0+241.0)))+1.0;\n    time *= .25*speed;\n    if (speed == 2.0 && hash11(floor(time*4.0+738.))>0.7) time *=2.0; \n\tint accend = int(mod(4.0*time,8.0))+0;\n    int descend = int(mod(-4.0*time,8.0))+0;\n    float noteRand = hash11(floor(time-3280.0));\n    if (noteRand>0.8) {\n        note = chord;\n    } else if (noteRand>0.4) {\n        note = accend;\n    } else {\n    \tnote = descend;   \n    }\n    return note;\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    \n    int chordInterval = 4;\n    float chordsLength = mod(time,64.)< 32. ? 4. : 32.;\n   \tint chord = rand1To8(mod(floor(time*2./(float(chordInterval))),chordsLength)-900.0);\n    \n    int noteIdx = int(mod(2.0*time,4.0))+0;\n    int noteIdx2 = melody( time, chord );\n    \n    //noteIdx = rand1To10(floor(time));\n    \n    float val = 0.8*chordSaw(chord, time);\n    \n    if (fract(0.125*time) > 0.5) {\n    //\tval += note(noteIdx+0, 2, 0.1, time);\n    }\n    \n    val += noteSaw(noteIdx2, 2, 0.1, time);\n    \n    // Get wild\n    //float mousex = 0.5;//texture(iChannel0, vec2(0.5)).x;\n    //float mousey = 0.5;//texture(iChannel0, vec2(0.5)).y;\n    //val = sin(sin(sin(time*70.0*time)+time*time)/cos(time*sin(time*sin(time*50.0*time))));\n    \n    return vec2(val);\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "#define C 1046.50\n#define D 1174.66\n#define E 1318.51\n#define F 1396.91\n#define G 1567.98\n#define A 1760.00\n#define B 1975.53\n#define C2 2093.00\n\n#define HASHSCALE1 .1031\n\nfloat[] notes = float[](C, D, E, F, G, A, B, C2); \nint[] C135 = int[](0, 2, 4);\n\nfloat note(int idx, int octave, float amp, float t) {\n\treturn amp*sin(exp2(float(octave))*notes[idx%8]*mod(t,2.0)*6.28318*0.2);   \n}\n\nfloat noteSaw(int idx, int octave, float amp, float t) {\n\treturn amp*tan(sin(exp2(float(octave))*notes[idx%8]*mod(t,2.0)*6.28318*0.2));   \n}\n\nfloat noteSquare(int idx, int octave, float amp, float t) {\n\treturn 3.0*amp*pow(fract(exp2(float(octave))*notes[idx%8]*floor(mod(4.0*t,2.0)+1.0)*mod(t,2.0)*0.05)-0.5,1.0);   \n}\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nint rand1To8( float time ) {\n\treturn int(hash11(time)*8.0);   \n}\n\nfloat chordSaw(int idx, float t) {\n    return noteSaw( idx+C135[0], 0, 0.3, t) + \n           noteSaw( idx+C135[1], 1, 0.3, t) +\n           noteSaw( idx+C135[2], 0, 0.15, t); \n}\n\nint melody( float time, int chord ) {\n    int note;\n    time = mod(time,64.)< 32. ? mod(time,32.0)-94. : time;\n    float speed = floor(2.0*hash11(floor(time*2.0+241.0)))+1.0;\n    time *= .25*speed;\n    if (speed == 2.0 && hash11(floor(time*4.0+738.))>0.7) time *=2.0; \n\tint accend = int(mod(4.0*time,8.0))+0;\n    int descend = int(mod(-4.0*time,8.0))+0;\n    float noteRand = hash11(floor(time-3280.0));\n    if (noteRand>0.8) {\n        note = chord;\n    } else if (noteRand>0.4) {\n        note = accend;\n    } else {\n    \tnote = descend;   \n    }\n    return note;\n}\n\nvec4 sound( float time )\n{\n    int chordInterval = 4;\n    float chordsLength = mod(time,64.)< 32. ? 4. : 32.;\n   \tint chord = rand1To8(mod(floor(time*2./(float(chordInterval))),chordsLength)-900.0);\n    \n    int noteIdx = int(mod(2.0*time,4.0))+0;\n    int noteIdx2 = melody( time, chord );\n    \n    //noteIdx = rand1To10(floor(time));\n    \n    float val = 0.8*chordSaw(chord, time);\n    \n    if (fract(0.125*time) > 0.5) {\n    //\tval += note(noteIdx+0, 2, 0.1, time);\n    }\n    \n    val += noteSaw(noteIdx2, 2, 0.1, time);\n    \n    //val = atan(cos(sin(time*700.0))/sin(sin(700.0*time)));\n    \n    return vec4( float(chord)-(floor(mod(4.0*time+4.0,2.0))+1.0)*8.0, float(chord+4), float(chord+9), float(noteIdx2+24));\n    \n}\n\nfloat colorNote(vec4 n, float y) {\n    return min( min(abs(n.x-y),\n           \t\tabs(n.y-y)),\n           \t\tmin(abs(n.z-y),\n           \t\tabs(n.w-y)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //uv += -0.5;\n   \n    \n    /*\n    float s = sound(iTime*0.01+uv.x*0.01);\n    \n    float weight = abs(uv.y*2.0 - s);\n    fragColor = vec4(\n        mix( vec3(smoothstep(weight,0.0, 0.05)), texture(iChannel0, uv+0.5).rgb,0.0), \n        1.0);\n    */\n    \n    vec4 notes = sound(iTime+uv.x-1.0);\n   // notes = vec4(27.0, 2.0, 15.,17.0);\n    fragColor = vec4( vec3(1.0)-(colorNote(notes, uv.y*60.0-20.0)), 1.0);\n   \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(iMouse.x/iResolution.x,iMouse.y/iResolution.y,1.0,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}