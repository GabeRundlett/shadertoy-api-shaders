{
    "Shader": {
        "info": {
            "date": "1670485139",
            "description": "A printed circuit board is assembled by nanobots, while a three-color optical scanner looks on, checking for defects.\n*mouse to reset tiles*\n*WASD/QE/RF to fly*\n*space to reset*",
            "flags": 48,
            "hasliked": 0,
            "id": "mdjSDz",
            "likes": 30,
            "name": "Raymarched Circuit Board WFC",
            "published": 3,
            "tags": [
                "raymarch",
                "shadow",
                "lights",
                "circuit",
                "wfc",
                "wavefunctioncollapse"
            ],
            "usePreview": 1,
            "username": "fenix",
            "viewed": 487
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Another experiement with my interpretation of Wave Function Collapse, this time with\n//  a 3D raymarched renderer.\n//\n//      https://github.com/mxgmn/WaveFunctionCollapse\n//\n//  My other WFC shaders (all 2D):\n//\n//      Simple Wave Function Collapse     https://shadertoy.com/view/DdfSzj\n//      Circuit Board WFC                 https://shadertoy.com/view/mdBSRW\n//      Roguelike Dungeon WFC             https://shadertoy.com/view/ddSXzW\n//      Tiny Town WFC                     https://www.shadertoy.com/view/ds2XzD\n//\n//  The wave function collapse didn't change much here, only the rendering. Starting with\n//  the tiles in Circuit Board WFC, I just added a few (CHIP2, RESISTOR, CAPACITOR) to\n//  complement the new look.\n//\n//  The rendering has nothing really revolutionary either. I started by with this:\n//\n//      Slime Mold Terrain                https://www.shadertoy.com/view/Dd23z3\n//\n//  because it already had raymarching against a \"terrain texture\". Then I replaced the\n//  height field with consulting an SDF per tile type. After that I implemented materials\n//  and multiple local light sources. The tilt-shift lens effect is borrowed from my\n//  Dynamic Editable Terrain series:\n//\n//      Dynamic Editable Terrain          https://www.shadertoy.com/view/flVBRw\n//      Dynamic Editable Terrain 2        https://www.shadertoy.com/view/7tKBDm\n//\n//  Buffer A computes the wave function collapse\n//  Buffer B handles camera controls\n//  Buffer C does the main scene render\n//  Image applies blur effect and renders lights on top\n//\n// ---------------------------------------------------------------------------------------\n\n// based on gaussian blur from FabriceNeyret2's smart gaussian blur: https://www.shadertoy.com/view/WtKfD3\n\nint           N =  7;                              // target sampling rate\nfloat         w,                                   // filter width\n              z;                                        // LOD MIPmap level to use for integration \n#define init  z = ceil(max(0.,log2(w*R.y/float(N))));   // N/w = res/2^z\n#define R     iResolution.xy\n\n\nvec4 convol2D(vec2 U) {                                                     \n    vec4  O = vec4(0.0);  \n    float r = float(N-1)/2., g, t=0.;                                       \n    for( int k=0; k<N*N; k++ ) {                                            \n        vec2 P = vec2(k%N,k/N) / r - 1.;                                    \n        t += g = exp(-2.*dot(P,P) );                                        \n        O += g * textureLod(iChannel0, (U+w*P) *R.y/R, z );  \n    }                                                                       \n    return O/t;                                                             \n}      \n\nvoid swap(inout vec3 a, inout vec3 b)\n{\n    vec3 temp = a;\n    a = b;\n    b = temp;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float centerDepth = texelFetch(iChannel0, ivec2(iResolution.xy*vec2(0.5, .6)), 0).w;\n    vec4 pixel = texelFetch(iChannel0, ivec2(u), 0);\n    float depth = pixel.w;\n    \n    // Blur based on depth, the farther from the depth of the center pixel, the more blur,\n    // to create a tilt-shift lens effect.\n    w = (abs(depth-centerDepth)) * iResolution.y / 2000.;\n    \n    if (w > 0.002)\n    {\n        init\n        vec2 p = (u - iResolution.xy * 0.5) / iResolution.y;\n        {\n            vec2 U = u / R.y;  \n            O = convol2D(U);\n        }\n    }\n    else\n    {\n        O = pixel;\n    }\n    \n    fxState state = fxGetState();\n    \n    // render lights after blur\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(state, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\tvec3 rayDir = fxCalcRay(u, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    vec3 lightPos[3] = calcLightPos(iTime, iResolution, cameraPos, cameraFwd);\n    mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n    mat4 w2c = inverse(c2w);\n\n    lightPos[0] = (w2c * vec4(lightPos[0],1.0)).xyz;\n    lightPos[0].xy = lightPos[0].xy / lightPos[0].z;\n    lightPos[1] = (w2c * vec4(lightPos[1],1.0)).xyz;\n    lightPos[1].xy = lightPos[1].xy / lightPos[1].z;\n    lightPos[2] = (w2c * vec4(lightPos[2],1.0)).xyz;\n    lightPos[2].xy = lightPos[2].xy / lightPos[2].z;\n    \n    vec3 lightColors[3] = LIGHT_COLORS;\n\n    for (int i = 0; i < 3; ++i)\n    {\n        float d= distance(lightPos[i].xy, (u - .5*iResolution.xy) / iResolution.y);\n        O.xyz = max(O.xyz, lightColors[i] * smoothstep(.04, .02, d));\n    }\n    \n    O.a = 1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define SHADOW 1\nconst float MAX_Y = 0.01;\nconst float CHIP_NOISE_SCALE = 15000.;\nconst float CHIP_NOISE_HEIGHT = .003;\nconst float TRACE_SMIN_K = .05;\nconst float MAX_T = 2.2;\nconst float SDF_EPSILON = 0.00001;\nconst int MAX_MARCH_ITER = 100;\n\n// symmetry types\n#define S_X 0x1\n#define S_I 0x3\n#define S_L 0xf\n\nstruct Tile\n{\n    mat3 shape; // defines how this tile matches to neighbors\n    float prob; // lower numbers will cause this tile to be chosen less often\n    int sym; // symmetry type\n    bool selfConnect; // can connect to self\n};\n\n// tile definitions\nconst Tile T_EMPTY =\n    Tile(mat3(0, 0, 0,\n              0, 0, 0,\n              0, 0, 0),\n         0., S_X, true);\n         \nconst Tile T_BOARD =\n    Tile(mat3(1, 1, 1,\n              1, 1, 1,\n              1, 1, 1),\n         .9, S_X, true);\n                \nconst Tile T_CHIP =\n    Tile(mat3(3, 3, 3,\n              3, 3, 3,\n              3, 3, 3),\n         .2, S_X, true);\n                \nconst Tile T_CHIP2 =\n    Tile(mat3(3, 3, 3,\n              3, 3, 3,\n              3, 3, 3),\n         .02, S_X, true);\n                \nconst Tile T_NODE =\n    Tile(mat3(1, 1, 1,\n              1, 1, 2,\n              1, 1, 1),\n         0., S_L, false);\n                \nconst Tile T_WIRE =\n    Tile(mat3(1, 1, 1,\n              4, 4, 4,\n              1, 1, 1),\n         0.03, S_I, true);\n                \nconst Tile T_EDGE =\n    Tile(mat3(3, 1, 1,\n              3, 2, 2,\n              3, 1, 1),\n         .1, S_L, true);\n                \nconst Tile T_CORNER =\n    Tile(mat3(3, 1, 1,\n              1, 1, 1,\n              1, 1, 1),\n         .001, S_L, false);\n                \nconst Tile T_TRACE =\n    Tile(mat3(1, 1, 1,\n              2, 2, 2,\n              1, 1, 1),\n         0.5, S_I, true);\n                \nconst Tile T_CROSS =\n    Tile(mat3(1, 4, 1,\n              2, 4, 2,\n              1, 4, 1),\n         0.1, S_I, true);\n                \nconst Tile T_JUNCT =\n    Tile(mat3(1, 4, 1,\n              1, 4, 1,\n              1, 2, 1),\n         0.03, S_L, false);\n                \nconst Tile T_T =\n    Tile(mat3(1, 2, 1,\n              2, 2, 2,\n              1, 1, 1),\n         0.2, S_L, false);\n                \nconst Tile T_ACROSS =\n    Tile(mat3(1, 2, 1,\n              1, 2, 2,\n              1, 1, 1),\n         .2, S_L, true);\n                \nconst Tile T_ACROSS2 =\n    Tile(mat3(1, 2, 1,\n              2, 1, 2,\n              1, 2, 1),\n         .2, S_I, true);\n         \nconst Tile T_INODE =\n    Tile(mat3(1, 1, 1,\n              2, 1, 2,\n              1, 1, 1),\n         0.2, S_I, false);\n                \nconst Tile T_CAPACITOR =\n    Tile(mat3(1, 1, 1,\n              2, 1, 5,\n              1, 5, 1),\n         0.1, S_L, true);\n                \nconst Tile T_RESISTOR =\n    Tile(mat3(1, 1, 1,\n              6, 1, 2,\n              1, 1, 1),\n         0.1, S_L, true);\n                \nconst int EMPTY = 0;\nconst int BOARD = 1;\nconst int CHIP = 2;\nconst int CHIP2 = 3;\nconst int NODE = 4;\nconst int WIRE = 5;\nconst int EDGE = 6;\nconst int CORNER = 7;\nconst int TRACE = 8;\nconst int CROSS = 9;\nconst int JUNCT = 10;\nconst int T = 11;\nconst int ACROSS = 12;\nconst int ACROSS2 = 13;\nconst int INODE = 14;\nconst int CAPACITOR = 15;\nconst int RESISTOR = 16;\nconst int NUM_TILES = 17;\n\nconst Tile[NUM_TILES] TILES =\n    Tile[](\n        T_EMPTY,\n        T_BOARD,\n        T_CHIP,\n        T_CHIP2,\n        T_NODE,\n        T_WIRE,\n        T_EDGE,\n        T_CORNER,\n        T_TRACE,\n        T_CROSS,\n        T_JUNCT,\n        T_T,\n        T_ACROSS,\n        T_ACROSS2,\n        T_INODE,\n        T_CAPACITOR,\n        T_RESISTOR\n    );\n\n// material definitions\n#define M_BLACK 0\n#define M_BOARD 1\n#define M_CHIP 2\n#define M_WIRE 3\n#define M_TRACE 4\n#define M_BASE 5\n\nvec3 matColor(int m)\n{\n    if (m == M_BLACK) return vec3(0);\n    if (m == M_BOARD) return vec3(.05, .4, .05);\n    if (m == M_CHIP)  return vec3(.05);\n    if (m == M_WIRE)  return vec3(1.);\n    if (m == M_TRACE) return vec3(.3,.8,.3);//vec3(.6,.5,.0);\n    if (m == M_BASE)  return vec3(.3,.3,.2);//vec3(.6,.5,.0);\n}\n\nfloat matShiny(int m)\n{\n    if (m == M_BLACK) return 0.;\n    if (m == M_BOARD) return .3;\n    if (m == M_CHIP)  return .6;\n    if (m == M_WIRE)  return .99;\n    if (m == M_TRACE) return .9;\n    if (m == M_BASE)  return .3;\n}\n\nmat2 rot2(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, sc.x, -sc.x, sc.y);\n}\n\nfloat length2(vec2 v) { return dot(v, v); }\nfloat length2(vec3 v) { return dot(v, v); }\nvec2 rot90(vec2 v) { return v.yx * vec2(1, -1); }\n\nconst float PI = 3.141592653589793;\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n\n#define KEY_W 87\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n#define KEY_R 82\n#define KEY_F 70\n#define KEY_Q 81\n#define KEY_E 69\n\nstruct fxState\n{\n    vec3 camPos;\n    vec2 lastMouse;\n    float camDir;\n    float resolution;\n    bool attract;\n};\n\nfxState fxGetStateInternal(sampler2D sampler)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(1, 0), 0);\n    fxState state;\n    state.resolution = data0.x;\n    state.attract = data0.y != 0.;\n    state.lastMouse = data0.zw;\n    state.camPos = data1.xyz;\n    state.camDir = data1.w;\n    return state;\n}\n\n#define fxGetState() fxGetStateInternal(iChannel1)\n\nvec4 fxPutState(fxState state, ivec2 ifc)\n{\n    if (ifc == ivec2(0))\n    {\n        return vec4(state.resolution, state.attract ? 1. : 0., state.lastMouse);\n    }\n    \n    return vec4(state.camPos, state.camDir);\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nstruct Result \n{\n    float dist;\n    int mat;\n};\n\nResult minResult(Result a, Result b)\n{\n    if (a.dist < b.dist) return a;\n    return b;\n}\n\n// https://iquilezles.org/articles/smin/\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// distance functions\nResult sdEmpty(vec3 p, bool forShadow)\n{\n    if (forShadow) return Result(1e6, M_BLACK);\n    return Result(sdBox(p + vec3(0,.8,0), vec3(1.,.2,.5)), M_BLACK);\n}\n\nResult sdBoard(vec3 p, bool forShadow)\n{\n    if (forShadow) return Result(1e6, M_BLACK);\n    return Result(sdBox(p + vec3(0,.8,0), vec3(1.,.2,.5)), M_BOARD);\n}\n\nResult sdChip(vec3 p, vec3 gp, bool forShadow)\n{\n    vec3 noise = hash3(uvec3(abs(gp)*CHIP_NOISE_SCALE)) * CHIP_NOISE_HEIGHT;\n    return Result((sdBox(p + vec3(0,.4,0), vec3(1.,.2,.5)) + noise.x), M_CHIP);\n}\n\nResult sdChip2(vec3 p, vec3 gp, bool forShadow)\n{\n    vec3 noise = hash3(uvec3(abs(gp)*CHIP_NOISE_SCALE)) * CHIP_NOISE_HEIGHT;\n    float dHole = sdCappedCylinder(p + vec3(0,.03,0), .4, .2);\n    return Result(max(-dHole, sdBox(p + vec3(0,.4,0), vec3(1.,.2,.5)) + noise.x), M_CHIP);\n}\n\nResult sdNode(vec3 p, bool forShadow)\n{\n    if (forShadow) return Result(1e6, M_BLACK);\n    float dBoard = sdBox(p + vec3(0,.7,0), vec3(1.,.1,.5));\n    float dTrace = sdBox(p + vec3(0,.6,.35), vec3(0.09,.005,.2));\n    float dBT = smin(dBoard, dTrace, TRACE_SMIN_K);\n    Result result = Result(sdCappedCylinder(p + vec3(0,1.07,0), .2, .5), M_WIRE);\n    if (dBT < result.dist)\n    {\n        result.dist = dBT;\n        result.mat = dBoard < dTrace ? M_BOARD : M_TRACE;\n    }\n    float dHole = sdCappedCylinder(p + vec3(0,1.0,0), .1, 1.);\n    if (-dHole > result.dist)\n    {\n        result.dist = -dHole;\n        result.mat = M_BLACK;\n    }\n    return result;\n}\n\nResult sdWire(vec3 p, bool forShadow)\n{\n    float dWire = sdCappedCylinder(p.xzy + vec3(0,0,.403), .11,.6);\n    if (forShadow) return Result(dWire, M_WIRE);\n    float dBoard = sdBox(p + vec3(0,.8,0), vec3(1.,.2,.5));\n    if (dBoard < dWire) return Result(dBoard, M_BOARD);\n    return Result(dWire, M_WIRE);\n}\n\nResult sdEdge(vec3 p, vec3 gp, bool forShadow)\n{\n    vec3 pr = p;\n    pr.yz *= rot2(PI*.25);\n    float dChip = max(sdBox(p + vec3(0,.4,-.3), vec3(1.,.2,.3)), -sdBox(pr + vec3(0,.1,.1), vec3(1.2,.2,.3)));\n    Result rWire1 = Result(sdBox(p + vec3(0,.35,.1), vec3(0.15,.01,.2)), M_WIRE);\n    Result rWire2 = Result(sdBox(p + vec3(0,.55,.3), vec3(0.15,.2,.01)), M_WIRE);\n    if (forShadow) return minResult(minResult(rWire1, rWire2), Result(dChip, M_CHIP));\n    vec3 noise = hash3(uvec3(abs(gp)*CHIP_NOISE_SCALE)) * CHIP_NOISE_HEIGHT;\n    Result rChip = Result(noise.x + dChip, M_CHIP);\n    Result rSolder = Result(sdSphere(p + vec3(0,.67,.3), .2), M_WIRE);\n    float dBoard = sdBox(p + vec3(0,.8,0), vec3(1.,.2,.5));\n    float dTrace = sdBox(p + vec3(0,.6,.4), vec3(0.08,.005,.1));\n    float dBT = smin(dBoard, dTrace, TRACE_SMIN_K);\n    Result rBT = Result(dBT, dBoard < dTrace ? M_BOARD : M_TRACE);\n    return minResult(minResult(minResult(minResult(rBT, rChip), rWire1), rWire2), rSolder);\n}\n\nResult sdCorner(vec3 p, vec3 gp, bool forShadow)\n{\n    vec3 pra = p;\n    pra.yz *= rot2(PI*.25);\n    vec3 prb = p;\n    prb.xy *= rot2(PI*.25);\n    float dChip = max(max(\n        sdBox(p + vec3(-.3,.4,-.3), vec3(.3,.2,.3)),\n        -sdBox(pra + vec3(0,.1,.1), vec3(.675,.2,.3))),\n        -sdBox(prb + vec3(.1,.0,0), vec3(.11,.2,1.2)));\n    if (forShadow) return Result(dChip, M_CHIP);        \n    vec3 noise = hash3(uvec3(abs(gp)*CHIP_NOISE_SCALE)) * CHIP_NOISE_HEIGHT;\n    float dBoard = sdBox(p + vec3(0,.8,0), vec3(1.,.2,.5));\n    dChip += noise.x;\n    if (dBoard < dChip) return Result(dBoard, M_BOARD);\n    return Result(dChip, M_CHIP);\n}\n\nResult sdTrace(vec3 p, bool forShadow)\n{\n    if (forShadow) return Result(1e6, M_BLACK);\n    float dBoard = sdBox(p + vec3(0,.8,0), vec3(1.,.2,.5));\n    float dTrace = sdBox(p + vec3(0,.6,0), vec3(0.09,.005,.55));\n    float dist = smin(dBoard, dTrace, TRACE_SMIN_K);\n    if (dBoard < dTrace) return Result(dist, M_BOARD);\n    return Result(dist, M_TRACE);\n}\n\nResult sdCross(vec3 p, bool forShadow)\n{\n    float dWire = sdCappedCylinder(p.zxy + vec3(0,0,.403), .11,.5);\n    if (forShadow) return Result(dWire, M_WIRE);\n    float dBoard = sdBox(p + vec3(0,.8,0), vec3(1.,.2,.5));\n    float dTrace = sdBox(p + vec3(0,.6,0), vec3(0.09,.005,.5));\n    float dBT = smin(dBoard, dTrace, 1e-5);\n    if (dBoard < dTrace && dBoard < dWire) return Result(dBT, M_BOARD);\n    if (dTrace < dWire) return Result(dBT, M_TRACE);\n    return Result(dWire, M_WIRE);\n}\n\nResult sdJunct(vec3 p, bool forShadow)\n{\n    const vec2 sc = vec2(sin(.25*PI), cos(.25*PI));\n    vec3 pr = p;\n    pr.xy *= rot2(PI*.25);\n    float dWire = sdCappedTorus(pr + vec3(.05,.8,.0), sc, .2, .11);\n    if (forShadow) return Result(dWire, M_WIRE);\n    float dBoard = sdBox(p + vec3(0,.8,0), vec3(1.,.2,.5));\n    float dTrace = sdBox(p + vec3(.25,.6,0), vec3(0.5,.005,.09));\n    float dBT = smin(dBoard, dTrace, TRACE_SMIN_K);\n    if (dBoard < dTrace && dBoard < dWire) return Result(dBT, M_BOARD);\n    if (dTrace < dWire) return Result(dBT, M_TRACE);\n    return Result(dWire, M_WIRE);\n}\n\nResult sdT(vec3 p, bool forShadow)\n{\n    if (forShadow) return Result(1e6, M_BLACK);\n    float dBoard = sdBox(p + vec3(0,.8,0), vec3(1.,.2,.5));\n    float dTrace1 = sdBox(p + vec3(0,.6,0), vec3(0.09,.005,.54));\n    float dTrace2 = sdBox(p + vec3(-.25,.6,0), vec3(.3,.005,.09));\n    float dBT1 = smin(dBoard, dTrace1, TRACE_SMIN_K);\n    float dBT2 = smin(dBoard, dTrace2, TRACE_SMIN_K);\n    int mat = dBoard < dTrace1 && dBoard < dTrace2 ? M_BOARD : M_TRACE;\n    if (dBT1 < dBT2) return Result(dBT1, mat);\n    return Result(dBT2, mat);\n}\n\nResult sdAcross(vec3 p, bool forShadow)\n{\n    if (forShadow) return Result(1e6, M_BLACK);\n    float dBoard = sdBox(p + vec3(0,.8,0), vec3(1.,.2,.5));\n    p.xz *= rot2(PI*-.25);\n    float dTrace = sdBox(p + vec3(-.355,.6,.0), vec3(0.055,.005,.55));\n    float dBT = smin(dBoard, dTrace, TRACE_SMIN_K);\n    if (dBoard < dTrace) return Result(dBT, M_BOARD);\n    return Result(dBT, M_TRACE);\n}\n\nResult sd2Across(vec3 p, bool forShadow)\n{\n    if (forShadow) return Result(1e6, M_BLACK);\n    float dBoard = sdBox(p + vec3(0,.8,0), vec3(1.,.2,.5));\n    p.xz *= rot2(PI*-.25);\n    float dTrace1 = sdBox(p + vec3(-.353,.6,.0), vec3(0.055,.005,.5));\n    float dTrace2 = sdBox(p + vec3(.35,.6,.0), vec3(0.055,.005,.5));\n    float dBT1 = smin(dBoard, dTrace1, TRACE_SMIN_K);\n    float dBT2 = smin(dBoard, dTrace2, TRACE_SMIN_K);\n    int mat = dBoard < dTrace1 && dBoard < dTrace2 ? M_BOARD : M_TRACE;\n    if (dBT1 < dBT2) return Result(dBT1, mat);\n    return Result(dBT2, mat);\n}\n\nResult sdINode(vec3 p, bool forShadow)\n{\n    if (forShadow) return Result(1e6, M_BLACK);\n    float dBoard = sdBox(p + vec3(0,.7,0), vec3(1.,.1,.5));\n    float dTrace = sdBox(p + vec3(0,.6,0), vec3(0.09,.005,.5));\n    float dBT = smin(dBoard, dTrace, TRACE_SMIN_K);\n    int mat = dBoard < dTrace ? M_BOARD : M_TRACE;\n    Result result = Result(sdCappedCylinder(p + vec3(0,1.05,0), .2, .5), M_WIRE);\n    if (dBT < result.dist)\n    {\n        result.dist = dBT;\n        result.mat = mat;\n    }\n    float dHole = sdCappedCylinder(p + vec3(0,1.0,0), .1, 1.);\n    if (-dHole > result.dist)\n    {\n        result.dist = -dHole;\n        result.mat = M_BLACK;\n    }\n    return result;\n}\n\nResult sdCapacitor(vec3 p, bool forShadow)\n{\n    Result result = Result(sdCappedCylinder(p + vec3(.5,.25,.5), .4, 1.) -.0001, M_WIRE);\n    if (forShadow) return result;\n    float dBoard = sdBox(p + vec3(0,.7,0), vec3(1.,.1,.5));\n    float dBase = sdBox(p + vec3(.1,.6,.1), vec3(.45,.1,.45));\n    float dTrace = sdBox(p + vec3(0,.6,0), vec3(0.09,.005,.5));\n    float dBT = smin(smin(dBoard, dBase, TRACE_SMIN_K), dTrace, TRACE_SMIN_K);\n    int mat = dBoard < dTrace && dBoard < dBase ? M_BOARD : (dTrace < dBase ? M_TRACE : M_BASE);\n    if (dBT < result.dist)\n    {\n        result.dist = dBT;\n        result.mat = mat;\n    }\n    return result;\n}\n\nResult sdResistor(vec3 p, bool forShadow)\n{\n    Result rChip = Result(sdBox(p + vec3(0,.5,-.3), vec3(.3,.1,.2)), M_CHIP);\n    float dWire = sdBox(p + vec3(0,.5,.0), vec3(0.33,.11,.1));\n    float dSolder = sdSphere(p + vec3(0,.7,.2), .27);\n    Result rMetal = Result(smin(dWire, dSolder, .0001), M_WIRE);\n    if (forShadow) return minResult(rMetal, rChip);\n\n    float dBoard = sdBox(p + vec3(0,.8,0), vec3(1.,.2,.5));\n    float dTrace = sdBox(p + vec3(0,.6,.4), vec3(0.1,.01,.1));\n    float dBT = smin(smin(dBoard, dTrace, 1e-5), dTrace, 1e-5);\n    Result rBT = Result(dBT, dBoard < dTrace ? M_BOARD : M_TRACE);\n    return minResult(minResult(rMetal, rChip), rBT);\n}\n\nResult sdCell(vec4 value, vec3 p, vec3 gp, bool forShadow)\n{\n    p.xz = rot90(p.xz);\n    if (value.y == 1.) p.xz = rot90(p.xz);\n    if (value.y == 2.) p.xz = rot90(rot90(p.xz));\n    if (value.y == 3.) p.xz = rot90(rot90(rot90(p.xz)));\n    \n    if (int(value.x) == EMPTY)     return sdEmpty(p, forShadow);\n    if (int(value.x) == BOARD)     return sdBoard(p, forShadow);\n    if (int(value.x) == CHIP)      return sdChip(p, gp, forShadow);\n    if (int(value.x) == CHIP2)     return sdChip2(p, gp, forShadow);\n    if (int(value.x) == NODE)      return sdNode(p, forShadow);\n    if (int(value.x) == WIRE)      return sdWire(p, forShadow);\n    if (int(value.x) == EDGE)      return sdEdge(p, gp, forShadow);\n    if (int(value.x) == CORNER)    return sdCorner(p, gp, forShadow);\n    if (int(value.x) == TRACE)     return sdTrace(p, forShadow);\n    if (int(value.x) == CROSS)     return sdCross(p, forShadow);\n    if (int(value.x) == JUNCT)     return sdJunct(p, forShadow);\n    if (int(value.x) == T)         return sdT(p, forShadow);\n    if (int(value.x) == ACROSS)    return sdAcross(p, forShadow);\n    if (int(value.x) == ACROSS2)   return sd2Across(p, forShadow);\n    if (int(value.x) == INODE)     return sdINode(p, forShadow);\n    if (int(value.x) == CAPACITOR) return sdCapacitor(p, forShadow);\n    if (int(value.x) == RESISTOR)  return sdResistor(p, forShadow);\n        \n    return Result(1e6, M_BLACK);\n}\n\nResult scene(sampler2D sampler, vec3 res, vec3 p, bool forShadow)\n{\n    vec2 addr = (p.xz + .5) * res.y;\n    vec2 subaddr = (fract(addr) - .5);\n    vec3 subp = vec3(subaddr.x, p.y * res.y, subaddr.y);\n    vec4 value = texelFetch(sampler, ivec2(addr), 0);\n    Result minDist = sdCell(value, subp, p, forShadow);\n    minDist.dist /= res.y;\n    return minDist;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 grad( sampler2D sampler, vec3 res, in vec3 pos )\n{\n    const vec2 e = vec2(1.0,-1.0)*0.000005773;\n    return normalize( e.xyy*scene(sampler, res, pos + e.xyy, false ).dist + \n\t\t\t\t\t  e.yyx*scene(sampler, res, pos + e.yyx, false ).dist + \n\t\t\t\t\t  e.yxy*scene(sampler, res, pos + e.yxy, false ).dist + \n\t\t\t\t\t  e.xxx*scene(sampler, res, pos + e.xxx, false ).dist );\n}\n\nResult rayMarch(sampler2D sampler, vec3 res, vec3 pos, vec3 dir, bool forShadow, out vec3 hitPos)\n{\n    float t = 0.;\n    \n    if (pos.y > MAX_Y) // skip immediately down to the max Y so we don't do unnecessary texture fetches\n    {\n        if (dir.y > 0.) { t = MAX_T; return Result(1e6, M_BLACK); }\n        t = (MAX_Y - pos.y) / dir.y;\n        pos += dir * t;\n    }\n    \n    int mat = M_BLACK;\n    for (int i = 0; i < MAX_MARCH_ITER; ++i)\n    {\n        Result d = scene(sampler, res, pos, forShadow);\n        mat = d.mat;\n        \n        if (d.dist < SDF_EPSILON || t > MAX_T)\n        {\n            break;\n        }\n        \n        t += d.dist * .5;\n        pos += dir * d.dist * .5;\n    }\n    \n    hitPos = pos;\n    return Result(t, mat);\n}\n\nvec3[3] calcLightPos(float time, vec3 res, vec3 cameraPos, vec3 cameraFwd)\n{\n    vec3 lightCenter = cameraPos;\n    lightCenter.y = 10. / res.y;\n    lightCenter.xz += cameraFwd.xz * 40. / res.y;\n\n    vec3[3] pos = vec3[]((15. / res.y) * vec3(sin(time),.0,cos(time)),\n                          (15. / res.y) * vec3(sin(time + PI*2./3.),.0,cos(time + PI*2./3.)),\n                          (15. / res.y) * vec3(sin(time + PI*4./3.),.0,cos(time + PI*4./3.)));\n    \n    pos[0].xy *= rot2(.2 * sin(time*.5));\n    pos[0].yz *= rot2(.2 * cos(time*.5));\n    pos[1].xy *= rot2(.2 * sin(time*.5));\n    pos[1].yz *= rot2(.2 * cos(time*.5));\n    pos[2].xy *= rot2(.2 * sin(time*.5));\n    pos[2].yz *= rot2(.2 * cos(time*.5));\n\n    pos[0] += lightCenter;\n    pos[1] += lightCenter;\n    pos[2] += lightCenter;\n\n    return pos;\n}\n\nconst vec3 LIGHT_COLORS[3] = vec3[](vec3(.7,0,0), vec3(0,.3,0), vec3(0,0,1));\n//const vec3 LIGHT_COLORS[3] = vec3[](vec3(1), vec3(1), vec3(1));  // white lights\n\nvec4 pixelInternal(sampler2D sampler, float time, vec3 res, vec3 cameraPos, vec3 cameraFwd, vec3 rayDir, out vec3 hitPos, out vec3 normal)\n{    \n    Result r = rayMarch(sampler, res, cameraPos, rayDir, false, hitPos);\n    normal = grad(sampler, res, hitPos);\n\n    // compute color\n    vec3 mColor = matColor(r.mat);\n    float mShiny = matShiny(r.mat);\n    \n    const float AMBIENT = .02;\n    vec3 color = (1.-mShiny) * mColor * AMBIENT;    \n\n    // apply light and shadow\n    vec3 lightPos[3] = calcLightPos(time, res, cameraPos, cameraFwd);\n                              \n    vec3 lightDir[3] = vec3[](normalize(lightPos[0] - hitPos),\n                              normalize(lightPos[1] - hitPos),\n                              normalize(lightPos[2] - hitPos));\n                              \n    for (int i = 0; i < 3; ++i)\n    {\n#if SHADOW\n        float shadowT = MAX_T;    \n        vec3 offsetPos = hitPos + normal * SDF_EPSILON * 3.;\n        vec3 shadowHit;\n        Result sResult = rayMarch(sampler, res, offsetPos, lightDir[i], true, shadowHit);\n        shadowT = sResult.dist;\n\n        if (shadowT >= MAX_T)\n#endif // SHADOW\n        {\n            float dp = max(0., dot(normal, lightDir[i]));\n            color += (1.-mShiny)*LIGHT_COLORS[i] * mColor * dp / (res.y * length2(lightPos[i] - hitPos));\n\n            vec3 reflection = reflect(lightDir[i], normal);\n            dp = max(0., dot(cameraFwd, reflection));\n\n            color.rgb += LIGHT_COLORS[i] * mShiny * .1 * pow(abs(dp), 15.0) / (res.y * length2(lightPos[i] - hitPos));\n        }\n    }\n    \n    // fade at distance\n    if (r.dist >= MAX_T*.75)\n    {\n        vec3 sky = vec3(.01);\n        color = mix(color, sky, smoothstep(MAX_T*.75, MAX_T, r.dist));\n    }\n    \n    return vec4(color.xyz, r.dist);\n    return vec4(normal, r.dist)*vec4(1,.1,1,1);\n}\n\n#define pixel(A, B, C, D, E) pixelInternal(iChannel0, iTime, iResolution, A, B, C, D, E)\n\nvoid fxCalcCamera(fxState state, out vec3 cameraLookAt, out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraPos = state.camPos;\n    vec3 delta = vec3(0,-.01,.015);\n    delta.xz *= rot2(state.camDir);\n    cameraLookAt = cameraPos + delta;\n\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft = -normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\nmat4 fxCalcCameraMat(vec3 resolution, vec3 cameraLeft, vec3 cameraUp, vec3 cameraFwd, vec3 cameraPos)\n{\n    return mat4(vec4(-cameraLeft, 0.0),\n        vec4(-cameraUp, 0.0),\n        vec4(cameraFwd, 0.0),\n        vec4(cameraPos, 1.0));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// The room where it happens\n// ---------------------------------------------------------------------------------------\n\nint g_NumValidTiles;\nconst int MAX_VALID_TILES = NUM_TILES * 4;\nint g_ValidTiles[MAX_VALID_TILES];\nint g_ValidTileRs[MAX_VALID_TILES];\n\n#define R1(m) mat3(m[0][2], m[1][2], m[2][2], m[0][1], m[1][1], m[2][1], m[0][0], m[1][0], m[2][0])\n\n// rotate a shape matrix r times to the right\nmat3 rotShape(mat3 s, int r)\n{\n    while (r < 0) r += 4;\n    r = r % 4;\n    if (r == 1) s = R1(s);\n    else if (r == 2) s = R1(R1(s));\n    else if (r == 3) s = R1(R1(R1(s)));\n    \n    return s;\n}\n\nbool tilesMatch(mat3 a, mat3 b) { return a[0][0] == b[2][0] && a[0][1] == b[2][1] && a[0][2] == b[2][2]; }\n\n// find the full array of tiles that could be compatible with a particular tile already placed\nvoid findValidTiles(vec4 n, int r)\n{\n    mat3 nShape = rotShape(TILES[int(n.x)].shape, int(n.y) + r);\n    \n    for (int i = 0; i < NUM_TILES; ++i)\n    {\n        if (TILES[i].selfConnect == false && int(n.x) == i) continue;\n        \n        mat3 myShape = TILES[i].shape;\n        for (int d = 0; d < 4; ++d)\n        {\n            if ((TILES[i].sym & (1 << ((d + 4 - r) % 4))) != 0 && tilesMatch(rotShape(myShape, d), nShape))\n            {\n                g_ValidTiles[g_NumValidTiles] = i;\n                g_ValidTileRs[g_NumValidTiles] = (d + 4 - r) % 4;\n                g_NumValidTiles++;\n            }\n        }\n    }\n}\n\n// remove any tiles from the array that do not match the particular tile already placed\nvoid removeInvalidTiles(vec4 n, int r)\n{\n    mat3 nShape = rotShape(TILES[int(n.x)].shape, int(n.y) + r);\n\n    for (int i = 0; i < g_NumValidTiles; ++i)\n    {\n        mat3 myShape = rotShape(TILES[g_ValidTiles[i]].shape, g_ValidTileRs[i] + r);\n        if (TILES[g_ValidTiles[i]].selfConnect == false && int(n.x) == g_ValidTiles[i]\n            || !tilesMatch(myShape, nShape))\n        {\n            g_ValidTiles[i] = g_ValidTiles[g_NumValidTiles - 1];\n            g_ValidTileRs[i] = g_ValidTileRs[g_NumValidTiles - 1];\n            g_NumValidTiles--;\n            i--;\n        }        \n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxState state = fxGetState();\n    ivec2 ifc = ivec2(fragCoord);\n    if (iFrame == 0 || state.resolution < 0.)// || distance(fragCoord, vec2(0)) > 100.)\n    {\n        // reset\n        fragColor = vec4(0);\n        \n        return;\n    }\n    \n    fragColor = texelFetch(iChannel0, ifc, 0);\n\n    // update in an alternating checkerboard pattern, so no tile is updating on the same tick as any neighbor\n    if (((ifc.x + ifc.y) & 1) == (iFrame & 1)) return;\n\n    vec4 ns[4] = vec4[]( texelFetch(iChannel0, ifc + ivec2(0, 1), 0),\n                         texelFetch(iChannel0, ifc + ivec2(1, 0), 0),\n                         texelFetch(iChannel0, ifc + ivec2(0, -1), 0),\n                         texelFetch(iChannel0, ifc + ivec2(-1, 0), 0) );\n\n    vec3 h = hash3(uvec3(fragCoord, iFrame));\n\n    // reset when requested by neighbor that can't find a solution\n    if (ns[0].z > 0. || ns[1].z > 0. || ns[2].z > 0. || ns[3].z > 0. || fragColor.z > 0.)\n    {\n        if (h.x > .5)\n        {\n            fragColor.x = 0.;\n            fragColor.y = 0.;\n            fragColor.z = max(0., max(max(max(max(fragColor.z, ns[0].z), ns[1].z), ns[2].z), ns[3].z) - 1.);\n        }\n        return;\n    }\n    \n    // empty cells with no neighbors have a chance to spontaneously collapse\n    if (fragColor.x == 0. && ns[0].x == 0. && ns[1].x == 0. && ns[2].x == 0. && ns[3].x == 0.)\n    {\n       if (h.x < 1e-5)\n        {\n            fragColor.x = floor(h.y * float(NUM_TILES));\n            fragColor.y = floor(h.y * 4.);\n            fragColor.z = 0.;\n        }\n        return;\n    }\n    \n    // Handle mouse input\n    if (iMouse.z > 0. && iMouse.w < 0. && state.lastMouse != vec2(0))\n    {\n        vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n        fxCalcCamera(state, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n        vec3 rayTo = fxCalcRay(iMouse.xy, iResolution, cameraFwd, cameraUp, cameraLeft);\n        float toT = cameraPos.y / rayTo.y;\n        vec3 toHit = cameraPos - toT * rayTo;\n        vec2 proj = (toHit.xz + .5) * iResolution.y;\n\n        if (distance(proj, fragCoord) < 5.)\n        {\n            fragColor.x = 0.;\n            fragColor.y = 2.;\n            return;\n        }\n    }\n\n    if (fragColor.x == 0.)\n    {\n        // we're empty but one of our neighbors is not, look for a value for ourselves\n        g_NumValidTiles = 0;\n        bool noSolution = false;\n        for (int d = 0; d < 4; ++d)\n        {\n            if (ns[d].x != 0.)\n            {\n                if (g_NumValidTiles == 0)\n                {\n                    // whichever direction is first non-empty will find all its valid tiles\n                    findValidTiles(ns[d], d);\n                }\n                else\n                {\n                    // every other direction then gets a chance to remove invalid options\n                    removeInvalidTiles(ns[d], d);\n                    if (noSolution = g_NumValidTiles == 0) break;\n                }\n            }\n        }\n\n        if (noSolution)\n        {\n            // if we're stuck, ask our neighbors to revert\n            fragColor.z = fragColor.z + 1.1;\n        }\n        else if (g_NumValidTiles > 0)\n        {\n            vec3 h = hash3(uvec3(fragCoord, iFrame));\n            int choice = int(h.y * float(g_NumValidTiles));\n            \n            // last chance rejection by probability, just try again next frame\n            if (g_NumValidTiles == 1 || h.z < TILES[g_ValidTiles[choice]].prob)\n            {\n                // install the chosen valid tile\n                fragColor.x = float(g_ValidTiles[choice]);\n                fragColor.y = float(g_ValidTileRs[choice]);\n            }\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Just for handling persistent state: camera position and direction\n// ---------------------------------------------------------------------------------------\n\nvoid updateCamera(inout fxState state)\n{\n    const float MOVE_SPEED = 0.0002;\n    vec3 camMove = vec3(0);\n    if (keyDown(KEY_W))\n    {\n        camMove.z += MOVE_SPEED;\n        state.attract = false;\n    }\n    if (keyDown(KEY_S))\n    {\n        camMove.z -= MOVE_SPEED;\n        state.attract = false;\n    }\n    if (keyDown(KEY_A))\n    {\n        camMove.x += MOVE_SPEED;\n        state.attract = false;\n    }\n    if (keyDown(KEY_D))\n    {\n        camMove.x -= MOVE_SPEED;\n        state.attract = false;\n    }\n    if (keyDown(KEY_R))\n    {\n        camMove.y += MOVE_SPEED;\n        state.attract = false;\n    }\n    if (keyDown(KEY_F))\n    {\n        camMove.y -= MOVE_SPEED;\n        state.attract = false;\n    }\n\n    if (state.attract)\n    {\n        state.camPos.x = .25*sin(iTime*.02);\n        state.camPos.z = .25*cos(iTime*.01);\n        state.camDir = iTime*.01*PI;\n    }\n\n    const float TURN_RATE = 0.02;\n    if (keyDown(KEY_Q))\n    {\n        state.camDir += TURN_RATE;\n        state.attract = false;\n    }\n    if (keyDown(KEY_E))\n    {\n        state.camDir -= TURN_RATE;\n        state.attract = false;\n    }\n\n    camMove.xz *= rot2(state.camDir);\n    state.camPos += camMove;\n\n    float MAX_HEIGHT = 0.6;\n    state.camPos.y = clamp(state.camPos.y, -MAX_HEIGHT, MAX_HEIGHT);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    if (ifc != ivec2(0) && ifc != ivec2(1, 0)) { fragColor = vec4(0); return; }\n    \n    fxState state = fxGetState();\n    if (iFrame == 0 || keyClick(KEY_SPACE) || iResolution.x * iResolution.y != abs(state.resolution))\n    {\n        state.resolution = -iResolution.x * iResolution.y;\n        state.attract = true;\n        state.camPos = vec3(0, 20. / iResolution.y, 0);\n        state.camDir = 0.;\n    }\n    else\n    {\n        state.resolution = abs(state.resolution);\n        \n        updateCamera(state);\n    }\n    \n    state.lastMouse = iMouse.xy;\n    \n    fragColor = fxPutState(state, ifc);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Main render: RGB color A depth\n// ---------------------------------------------------------------------------------------\n\nvec4 render(vec2 u, fxState state)\n{\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(state, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n\tvec3 rayDir = fxCalcRay(u, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    vec3 hitPos, normal;\n    return pixel(cameraPos, cameraFwd, rayDir, hitPos, normal);\n}\n\n// From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{    \n    fxState state = fxGetState();\n\n    vec4 colorDepth = render(fragCoord, state);\n    fragColor.xyz = pow(ACESFilm(colorDepth.xyz), vec3(1./2.2));\n    fragColor.w = colorDepth.w;\n\n    // debug terrain texture\n    //fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0) * 10.;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}