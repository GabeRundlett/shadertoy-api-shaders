{
    "Shader": {
        "info": {
            "date": "1504442037",
            "description": "I really love this raymarch stuff. As a graphics artist, I wanted to try making a real model out of raymarch shapes. Hope you like the outcome.\nI decided to come up with my own design for the gamepad to not break any design-copyrights. ENJOY!",
            "flags": 0,
            "hasliked": 0,
            "id": "ltXcDr",
            "likes": 23,
            "name": "Retro Gaming",
            "published": 3,
            "tags": [
                "3d",
                "reflection",
                "game",
                "raymarch",
                "raycast",
                "shadows",
                "raytrace",
                "lightning",
                "shapes",
                "controller",
                "pad"
            ],
            "usePreview": 0,
            "username": "ingagard",
            "viewed": 1377
        },
        "renderpass": [
            {
                "code": "//////////////////////////////////////////////////////////////////////////////////////\n///////////////////// CREATED BY KIM BERKEBY, SEP 2017 ///////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////\n////// BIG THANKS TO Inigo Quilez FOR PROVIDING THE SHAPE DISTANCE FUNCTIONS /////////\n//////////////////////////////////////////////////////////////////////////////////////\n\nstruct RayHit\n{\n  bool hit;  \n  vec3 hitPos;\n  vec3 normal;\n  float dist;\n  float depth;\n  float steps;\n  int hitID;\n};\n\n\nRayHit marchResult;\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y, max(q.x*0.866025+p.y*0.5, -p.y)-h.x*0.5);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa, ba)/dot(ba, ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n#define rotate(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat Cable( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a;\n  b.xz = mix(b.xz, b.xz*rotate(1.1), smoothstep(1.0, 6.0, pa.z));\n  b.xz = mix(b.xz, b.xz*rotate(-1.20), smoothstep(1.0, 14.0, pa.z));\n  b.y = mix(b.y, -1.55, smoothstep(.0, 1.0, pa.z));\n\n  vec3 ba = b - a;\n  float h = clamp( dot(pa, ba)/dot(ba, ba), 0.0, 1.0 );\n\n  return length( pa - ba*h ) - r;\n}\n\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n  return (length( p/r ) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\n\nvec3 opRotXY( vec3 pos, vec3 rayPos, float rad )\n{\n  vec3 sPos = rayPos-pos;\n  sPos.xy *= rotate(rad);\n  return sPos+rayPos;\n}\nvec3 opRotXZ( vec3 pos, vec3 rayPos, float rad )\n{\n  vec3 sPos = rayPos-pos;\n  sPos.xz *= rotate(rad);\n  return sPos+rayPos;\n}\nvec3 opRotYZ( vec3 pos, vec3 rayPos, float rad )\n{\n  vec3 sPos = rayPos-pos;\n  sPos.yz *= rotate(rad);\n  return sPos+rayPos;\n}\n\n\n\nfloat ControllerBase(in vec3 p, vec3 oPos, float oScale)\n{\n\n  float d = sdCappedCylinder(p-oPos-vec3(1.40, -0.04, 0.0), vec2(1.0, 0.12)*oScale);\n  d = min(d, sdCappedCylinder(p-oPos-vec3(-1.40, -0.04, 0.0), vec2(1.0, 0.12)*oScale));\n  d = min(d, sdCappedCylinder(p-oPos-vec3(-.35, 0.0, -.40), vec2(0.5, 0.08)*oScale));\n  d = min(d, sdCappedCylinder(p-oPos-vec3(.35, 0.0, -.40), vec2(0.5, 0.08)*oScale));\n\n\n  d=min(d, sdBox(p-oPos-vec3(.0, 0.0, 0.2), vec3(1.0, .08, 0.7)*oScale));\n  d = min(d, sdBox(p-oPos-vec3(.0, 0.0, 0.2), vec3(0.50, .07, 0.79)*oScale));\n  d=max(d, -sdBox(p-oPos-vec3(.0, 0.0, 1.1), vec3(0.20, 1.08, 0.15)*oScale));   \n\n  return d;\n}\n\nfloat ShoulderButtons(in vec3 p, float controllBase, vec3 oPos, float oScale)\n{\n  float d = sdCappedCylinder(p-oPos-vec3(1.45, -0.1, 0.10), vec2(1.0, 0.12)*oScale);\n  d = min(d, sdCappedCylinder(p-oPos-vec3(-1.45, -0.1, 0.10), vec2(1.0, 0.12)*oScale));\n  d =  min(d, sdBox(p-oPos-vec3(.0, -0.1, 0.2), vec3(1.60, .08, 0.8)*oScale));\n\n  d=  max(d, -sdBox(p-oPos-vec3(.0, 0.0, 0.42), vec3(1.2, 1.08, 2.9)*oScale));\n  d=  max(d, -sdBox(p-oPos-vec3(2.50, 0.0, 0.42), vec3(0.4, 1.08, 2.9)*oScale));\n  d=  max(d, -sdBox(p-oPos-vec3(-2.50, 0.0, 0.42), vec3(0.4, 1.08, 2.9)*oScale));\n\n  d=  max(d, -sdBox(p-oPos-vec3(0, 0.0, -0.42), vec3(3.0, 0.68, 1.)*oScale));\n\n  return d;\n}\n\n\nfloat d,d1,d2,d3,d4,d5,d6,d7,d8,d9;\n\nfloat Map( in vec3 p)\n{\n    d,d1,d2,d3,d4,d5,d6,d7,d8,d9 = 100000.0;\n    \n  d8 = ControllerBase(p, vec3(0, -0.51, 1.0), 1.05);\n  d = ControllerBase(p, vec3(0, -0.3, 1.0), 1.0);\n\n  // button ring\n  d=  max(d, -sdCappedCylinder(p-vec3(-1.45, -0.22, 1.0), vec2(0.8, 0.02)));\n  d8=  min(d8, sdCappedCylinder(p-vec3(-1.45, -0.25, 1.0), vec2(0.765, 0.03)));\n  d8=  min(d8, sdEllipsoid(p-vec3(-1.45, -0.25, 1.0), vec3(0.7, 0.1, 0.7)));\n\n  // button holes\n  d8=  max(d8, -sdEllipsoid(p-vec3(-1.45, -0.18, 1.40), vec3(0.32, 0.06, 0.32)));\n  d8=  max(d8, -sdEllipsoid(p-vec3(-1.45, -0.18, .60), vec3(0.32, 0.06, 0.32)));\n  d8=  max(d8, -sdEllipsoid(p-vec3(-1.90, -0.18, 1.0), vec3(0.32, 0.06, 0.32)));\n  d8=  max(d8, -sdEllipsoid(p-vec3(-1.00, -0.18, 1.0), vec3(0.32, 0.06, 0.32)));\n\n  // buttons\n  d2= sdCappedCylinder(p-vec3(-1.45, -0.3, 1.40), vec2(0.18, 0.12));\n  d9= sdCappedCylinder(p-vec3(-1.45, -0.3, 0.60), vec2(0.18, 0.12));\n  d2= min(d2, sdCappedCylinder(p-vec3(-1.90, -0.3, 1.0), vec2(0.18, 0.12)));\n  d9= min(d9, sdCappedCylinder(p-vec3(-1.0, -0.3, 1.0), vec2(0.18, 0.12)));\n\n  // button details       \n  d2=  max(d2, -sdEllipsoid(p-vec3(-1.45, -0.16, 1.40), vec3(0.25, 0.04, 0.25)));\n  d9=  max(d9, -sdEllipsoid(p-vec3(-1.45, -0.16, .60), vec3(0.25, 0.04, 0.25)));\n  d2=  max(d2, -sdEllipsoid(p-vec3(-1.90, -0.16, 1.0), vec3(0.25, 0.04, 0.25)));\n  d9=  max(d9, -sdEllipsoid(p-vec3(-1.0, -0.16, 1.0), vec3(0.25, 0.04, 0.25)));\n\n  // cross cutout\n  d=  max(d, -sdEllipsoid(p-vec3(1.55, -0.22, 1.0), vec3(0.7, 0.1, 0.7)));\n  d=  max(d, -sdEllipsoid(p-vec3(1.55, -0.22, 1.0), vec3(1.0, 0.03, 1.0)));\n  d3 = sdEllipsoid(p-vec3(1.55, -0.265, 1.0), vec3(.46, 0.06, .46));\n\n  // cross\n  d3 = min(d3, sdBox(p-vec3(1.55, -0.22, 1.0), vec3(0.4, 0.06, 0.13)));\n  d3 = min(d3, sdBox(p-vec3(1.55, -0.22, 1.0), vec3(0.13, 0.06, 0.4)));\n\n  // cross details\n  d3=  max(d3, -sdEllipsoid(p-vec3(1.55, -0.2, 1.0), vec3(0.16, 0.04, 0.16)));\n\n  // calculate button arrows and perform boolean\n  vec3 pPos = p-vec3(1.55, -0.13, 1.25);\n  pPos.xz *=rotate(radians(120.0));\n  pPos.zy *=rotate(radians(90.0));\n  d3 = max(d3, -sdTriPrism(pPos, vec2(.15, 0.05)));\n\n  pPos = p-vec3(1.55, -0.13, 0.75);\n  pPos.xz *=rotate(radians(300.0));\n  pPos.zy *=rotate(radians(90.0));\n  d3 = max(d3, -sdTriPrism(pPos, vec2(.15, 0.05)));\n\n  pPos = p-vec3(1.8, -0.13, 1.0);\n  pPos.xz *=rotate(radians(210.0));\n  pPos.zy *=rotate(radians(90.0));\n  d3 = max(d3, -sdTriPrism(pPos, vec2(.15, 0.05)));\n\n  pPos = p-vec3(1.3, -0.13, 1.0);\n  pPos.xz *=rotate(radians(30.0));\n  pPos.zy *=rotate(radians(90.0));\n  d3 = max(d3, -sdTriPrism(pPos, vec2(.15, 0.05)));\n\n  // cable input\n  d=max(d, -sdCapsule(p-vec3(.0, -0.4, 2.1), vec3(0.0, 0.0, -0.5), vec3(0.0, 0.0, 3.0), 0.13));   \n  d=min(d, sdCapsule(p-vec3(.0, -0.39, 2.07), vec3(0.0, 0.0, -0.1), vec3(0.0, 0.0, -0.1), 0.11));   \n\n  // cable\n  d4 = sdCapsule(p-vec3(.0, -0.39, 2.07), vec3(0.0, 0.0, 0), vec3(0.0, 0.0, 0), 0.11);       \n  d4=min(d4, Cable(p-vec3(.0, -0.4, 2.1), vec3(0., 0., -1.0), vec3(0., 0., 70.0), 0.072));   \n\n  // analog buttons\n  d= max(d, -sdEllipsoid(p-vec3(0.35, -0.15, .50), vec3(0.4, 0.2, 0.4)));\n  d= max(d, -sdEllipsoid(p-vec3(-0.35, -0.15, .50), vec3(0.4, 0.2, 0.4)));\n\n  d5=  sdEllipsoid(p-vec3(0.35, -0.35, .50), vec3(0.3, 0.18, 0.3));\n  d5= min(d5, sdCappedCylinder(p-vec3(0.35, -0.35, .50), vec2(0.15, 0.3)));\n  d5=  min(d5, sdEllipsoid(p-vec3(0.35, -0.05, .50), vec3(0.22, 0.03, 0.22)));\n\n  d5=  min(d5, sdEllipsoid(p-vec3(-0.35, -0.35, .50), vec3(0.3, 0.18, 0.3)));\n  d5= min(d5, sdCappedCylinder(p-vec3(-0.35, -0.35, .50), vec2(0.15, 0.3)));\n  d5=  min(d5, sdEllipsoid(p-vec3(-0.35, -0.05, .50), vec3(0.22, 0.03, 0.22)));\n\n  // start select cutouts\n  d=max(d, -sdCapsule(p-vec3(-.1, -.06, 1.4), vec3(0., 0., -0.15), vec3(-0.22, 0., 0.05), 0.2));   \n  d=max(d, -sdCapsule(p-vec3(.45, -.06, 1.4), vec3(0., 0., -0.15), vec3(-0.22, 0., 0.05), 0.2));   \n\n  // start select buttons\n  d7=sdCapsule(p-vec3(-.1, -.25, 1.4), vec3(0., 0., -0.15), vec3(-0.22, 0., 0.05), 0.095);   \n  d7=min(d7, sdCapsule(p-vec3(.45, -.25, 1.4), vec3(0., 0., -0.15), vec3(-0.22, 0., 0.05), 0.095));   \n\n  d6 = ShoulderButtons(p, d, vec3(0, -0.3, 1.0), 1.0);\n\n    \n  return  min(d,min(d2,min(d3,min(d4,min(d5,min(d6,min(d7,min(d8,min(d9,p.y+0.75)))))))));\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{   \n    const vec3 eps = vec3(0.02, 0.0, 0.0);\n  return normalize( vec3(Map(pos+eps.xyy) - Map(pos-eps.xyy), 0.5*2.0*eps.x, Map(pos+eps.yyx) - Map(pos-eps.yyx) ) );\n}\n\nfloat SoftShadow( in vec3 origin, in vec3 direction )\n{\n  float res = 2.0;\n  float t = 0.0;\n  float hardness = 6.50;\n  for ( int i=0; i<10; i++ )\n  {\n    float h = Map(origin+direction*t);\n    res = min( res, hardness*h/t );\n    t += clamp( h, 0.02, 0.075 );\n    if ( h<0.002 ) break;\n  }\n  return clamp( res, 0.0, 1.0 );\n}\n\n\nRayHit March(in vec3 origin, in vec3 direction, float maxDist, float precis, int maxSteps)\n{\n  RayHit result;\n\n  float t = 0.0, dist = 0.0, distStep = 1.0;\n  vec3 rayPos =vec3(0);\n\n  for ( int i=0; i<maxSteps; i++ )\n  {\n    rayPos =origin+direction*t;\n    dist = Map( rayPos);\n\n    if (abs(dist)<precis || t>maxDist )\n    {    \n        result.hitID =10;\n        \n        if(d == dist){  result.hitID =1;}\n        else if(d2 == dist){  result.hitID =2;}\n        else if(d3 == dist){  result.hitID =3;}\n        else if(d4 == dist){  result.hitID =4;}\n        else if(d5 == dist){  result.hitID =5;}\n        else if(d6 == dist){  result.hitID =6;}\n        else if(d7 == dist){  result.hitID =7;}\n        else if(d8 == dist){  result.hitID =8;}\n        else if(d9 == dist){  result.hitID =9;}\n   \n      result.depth = t; \n      result.dist = dist;                              \n      result.hitPos = origin+((direction*t)*0.99);   \n      result.steps = float(i);\n      break;\n    }\n    t += dist*distStep;\n  }\n\n\n  return result;\n}\n\n// Thanks to Inigo Quilez\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\nvec3 GetSceneLight(float specLevel, vec3 normal, vec3 pos, vec3 rayDir)\n{      \n  vec3 light1 = normalize(vec3(-1.0, 2.8, 1.0));\n    \n  vec3 reflectDir = reflect( rayDir, normal );\n  specLevel *= pow(clamp( dot( reflectDir, light1 ), 0.0, 1.0 ), 16.0);\n\n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n  float diffuse = clamp( dot( normal, light1 ), 0.0, 1.0 );\n  float skyLight = smoothstep( -0.1, 0.1, reflectDir.y );\n  float fill = pow( clamp(1.0+dot(normal, rayDir), 0.0, 1.0), 1.0 )*1.0;\n  float backLight = clamp( dot( normal, normalize(vec3(-light1.x, 0.0, -light1.z))), 0.0, 1.0 )*5.0;\n\n  diffuse *= SoftShadow( pos, light1);\n  skyLight *= SoftShadow( pos, reflectDir);\n\n  vec3 lightTot = 1.30*diffuse*vec3(1.00, 0.80, 0.55);\n  lightTot += specLevel*vec3(1.00, 0.90, 0.70)*diffuse;\n  lightTot += 0.40*amb*vec3(0.40, 0.60, 1.00);\n  lightTot += 0.50*skyLight*vec3(0.40, 0.60, 1.00);\n  lightTot += 0.50*backLight*vec3(0.25, 0.25, 0.25);\n\n  return lightTot+(0.25*fill*vec3(1.00, 1.00, 1.00));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n  vec2 mo = iMouse.xy/iResolution.xy;\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))/iResolution.y;\n\n  float camrot = 0.5*iTime;\n  if (iMouse.w>0.1) camrot=0.0; \n\n  vec3 rayOrigin = vec3( -0.5+3.5*cos(camrot + 6.0*mo.x), 1.0 + 2.0, 0.5 + 4.0*sin(camrot + 6.0*mo.x) );\n  mat3 ca = setCamera( rayOrigin, vec3( 0.0, -0.9, 0.5 ), 0.0 );\n  vec3 rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n  vec4 color =vec4(0);\n\n   marchResult = March(rayOrigin, rayDir, 110.0, 0.001, 128);\n   marchResult.normal = calcNormal(marchResult.hitPos); \n    \n      // pad top, buttons, cross, cable, sticks, shoulder buttons\n  const vec4[10] partColor = vec4[] (vec4(.65, 0.14, 0.14, 0.6), // pad top\n  vec4(0.5, 0.14, .14, 0.6), //buttons\n  vec4(.3, 0.3, 0.3, 0.5), //cross\n  vec4(0.2, 0.2, 0.2, 0.35), //cable\n  vec4(.3, 0.3, 0.3, 0.4), //sticks\n  vec4(0.5, 0.5, .5, 0.6), // shoulder buttons\n  vec4(.3, 0.3, 0.3, 0.5), // start/select\n  vec4(.3, 0.3, 0.3, 0.4), // pad bottom\n  vec4(0.5, 0.5, .5, 0.6), //buttons left\n  vec4(.35, .35, .34, 0.3)); // ground\n   vec4 col =partColor[marchResult.hitID-1];\n   vec3 light = GetSceneLight(col.a, marchResult.normal, marchResult.hitPos, rayDir);   \n    \n    // reflections in floor\n    if (marchResult.hitID==10)\n    {\n      vec3 refDir = normalize(reflect(rayDir, marchResult.normal));\n      RayHit reflectResult = March(marchResult.hitPos + (refDir*0.001), refDir, 30.0, 0.03, 64); \n\n      if (reflectResult.hit==true)\n      {\n        col = mix(col, col+(col* partColor[reflectResult.hitID-1]), .65);\n      }\n    }\n\n    float rim = clamp(1.0+dot(marchResult.normal, rayDir), 0.0, 1.0);\n    vec4 ref = vec4(texture( iChannel0, marchResult.normal+rayDir).rgb, 1.0); \n    ref += rim*pow(0.5, 2.0);\n    ref /= pow(2.0, col.a);\n\n    // apply lightning\n    color = col*vec4(light, 1.0);\n    color.rgb= mix((color.rgb+(color.rgb*ref.rgb))*col.a, (color.rgb+vec3(1.4))*col.a, pow(marchResult.normal.r, 2.0));\n  \n\n  fragColor = vec4(pow(color.rgb, vec3(1.0/0.9)), 1.0 ) * (0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.2 ));\n  //  fragColor = vec4(marchResult.normal,1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}