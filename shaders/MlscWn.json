{
    "Shader": {
        "info": {
            "date": "1504436531",
            "description": "Mouse sets coefficients;... swiveled sideways  ...\nMouse.x sets cubic        == cubic change over x\nMouse.y sets null           == baseline height.y at x=0;\nMouse.z sets linear        == linear change\nMouse.w sets quadratic == a*a change\n\n+hash() for fun.",
            "flags": 0,
            "hasliked": 0,
            "id": "MlscWn",
            "likes": 4,
            "name": "kerning a hash for Euler+Euclid",
            "published": 3,
            "tags": [
                "mod",
                "optimization",
                "hash",
                "overlap",
                "polynomial",
                "euler",
                "euclid",
                "calculus",
                "bisymmetry",
                "polynom",
                "halfspace",
                "tapping",
                "kerning"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1363
        },
        "renderpass": [
            {
                "code": "/* start.Head:hash_for_Euler+Euclid\n\noptimization,mod,fract,integral,hash,polynom,analysis,euler,euclid,calculus,\nbisymmetry,polynomial,set\n\nself         : https://www.shadertoy.com/view/MlscWn\nrandom father: https://www.shadertoy.com/view/4llcWn\nmother       : https://www.shadertoy.com/view/Xtscz7\n replaced a hash with a Polynomial_3rd_deg, then mixed the hash back in.\n\nInclides lots of commented code and links on (a)symmetry & optimization:\nLibrary: Lib.Frames.8\nGuide  : Bisymmetry.4\nGuide  : Bisymmetry.4+1 (optimization pointers)\n*/\n\n/* end__.Head\n   start.Manual\n/*\nMouse sets coefficients; ...swiveled sideways  ...\nMouse.x sets cubic     == cubic change over x\nMouse.y sets null      == baseline height.y at x=0;\nMouse.z sets linear    == linear change\nMouse.w sets quadratic == a*a change\n\nFor hased bands of [bounding volumes] to be filled with dots or moons.\n\nThis turns any y=f(x) curve (including HASH,noise) into a dotted line.\n of any (homogeneous) period.x,interval.x \n WITHOUT A LOOP, by using fract()\np4() returns y=f(x) where f(x) is a (general) cubic polynomial.\n\nThis generalization blurs some lines between analysis, hashes and RNG.LCG.PCG\n ==Random/Linear/Permuted Number/Congruential/Congruential Generator\nThis makes me wonder what loops can be converted into single passes with fract()\n And what the constrains to types of loops are that can be turned to fract().\n And when it is worth it, and when not. (I bet it is worth it for binary trees).\n\nThe gradient is good within the mod() interval, \nJust make sure that the visible parts (dots) are within boundingVolume==interval==[i]\nLeonard Euler: \"The best inverval is [i]==0;\n...\n*/\n/* end__.Manual\n   start.Manual.Parameters\n*/\n//  set period,interval==[i]~0, not just VERY small, but actually divide by 0.\n//   Just to screw with (or implement basiccalculus) analysis on a fundamental level!\n//   TestDivideByZeroCase==0 will calculate; .0*vec2(fract(a/.0),floor(a/.0));\n//  Effects of settings depend on implementation:\n//              Leonard Euler : ==0  \"This is fine, I invented this\"\n//fract(Congruental Generator): ==0  \"No it is not fine! Null-State equals death!\"\n//          Low IEEE precision: ==1  \"Where is my hash! Screw you, all of you!\"\n//     Heuristic large epsilon: ==2  \"Whatever, this is as close as we can get!\"\n//       Euclidean Unit circle: ==-1 \"Null-State-death only affects me tangentially\"\n#define TestDivideByZeroCase -1\n\n//control speed of time, to make time static or negative.\n#define TimeS (iTime-1.)\n//-1. makes a better thumbnail for the first frame\n//-1. also offsets from [the initial VOID-state]:\n// Because Shadertoy has the PATHETIC error that iTime and iGlobalTime are not initialized.\n// iTime and iGlobalTime are initially ==NullPointer != 0. \n// This confuses many webgl implementations, eg: when using i=cos(acos(-1.)+iTime);\n// cos(acos(-1.)+0.)==-1. is fine.\n// (NullPointer +0.)!= 0. confuses many implementations. -> black screen on iTime==0.\n\n//  ColorgGradient==x>0, shows different gradients, index[1..4], points to a 2*2 matrix:\n//   2 gradients are euclidean sqrt(a), 2 of them 1/dot(a,a)\n//   2 gradients them are fract(a), 2 of them are not.\n//  ColorgGradient==0  is, by your powers combined, Captain Planet, all of the above.\n//  ColorgGradient==-1 is, a (disappearing) ring-variant of ColorgGradient==0\n//  ColorgGradient==-1 shows a spherical [Bounding Volume] in white/yellow\n#define ColorGradient 0\n\n//  HasMix linear interpolates between a hasn and a PolynomialWithExponent3\n#define MixHashPoly3 u5(cos(TimeS*0.61))\n//#define MixHashPoly3 .0\n\n//sub-pixel blur\n#define fsaa 14./min(iResolution.x,iResolution.y)\n\n//swivel view, make .y horizontal, more horizontal ScreenSpace for higher exponents.\n#define ViewSvivel\n//View.Zoom\n#define ViewZoom 5.\n//View.Frame\n#define fra(u) (u-.5*iResolution.xy)*ViewZoom/iResolution.y\n\n\n\n/* end__.Manual.Parameters\n   start.Lib.Frame.8\n*/\n//library of often used functions: //ounting, index starts at 0!\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define u5(a) (a*.5+.5)\n#define u2(a) (a*2.-1.)\n//dot(1,a) is a faster sum_of_vector_components in most implements:\nv0 suv(v3 a){return dot(v3(1),a);}v0 suv(v2 a){return dot(v2(1),a);}\nv0 suv(v1 a){return a.x+a.y;}//sum_of_vector_components\nv0 mav(v1 a){return max(a.y,a.x);}//max of vector\nv0 mav(v2 a){return max(a.z,mav(a.xy));}\nv0 mav(v3 a){return max(mav(a.zw),mav(a.xy));}\n#define miv(a) -mav(-a)\n//triangle wave //euclidean grid\n#define tri(a) a=abs(u2(fract(a)))\n#define grid(a) mav(tri(a))\n//clamp().special clamp.general; //clamp().pseudo.inverse\n#define sat(a) clamp(a,0.,1.)\nv0 sat2(v0 a,v1 m){a=.5*(sign(a)+m.x)*a+m.y;a=(sign(2.-a)+1.)*(a-2.)+2.;return a*.5;}\n//stretch, sphere to pill; mirror_centric, most common, atomic;\n#define stretch(u,m) .5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretchMinus; positive values do not change; stretchPlus; negatives do not change.\n#define stretchM(u,m) stretch((u*2.+m),m)*.5\n#define stretchP(u,m) stretch((u*2.-m),m)*.5\n#define dd(a) dot(a,a)\n//perpendicular ==90deg rotation\nv1 perp(v1 a){return v1(-a.y,a.x);}\n//return [perpendicular dot product], relevant for distance to line\nv0 dotp(v1 a,v1 b){return dot(perp(a),b);}\n//return distance of [u] from segment, from [a] to [b]\nv0 dSegment(v1 p,v1 a,v1 b){p-=a;b-=a;return length(p-b*sat(dot(p,b)/dd(b)));}\n//---trigonometry, rotations and (distance to) Quadratic functions.\n//(distance to quadratic is a cubic with less than 2 intersections==roots)\n#define cs(a) vec2(cos(a),sin(a))\n//mirror p at half rotated axis == cheap SINGLE 2d rotation.\n#define rs(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n//golden ratios are the best factors for hashes; phi.xy-1.=1/phi.xy\nconst v1 phi=v1(sqrt(5.)*.5)+v1(-.5,.5);\n//Not too work-save plotter for quadratic functions.\nv1 evalQuad(v1 t,v1 A,v1 B,v1 C){A=(1.-t)*(A/B+C/A);return A*A;}\n//return all x where y=f(x)=0.; Solve quadratic equation for roots \nv2 SolveQuad(v2 a){v0 e=-a.x/3.;v0 p=a.y+a.x*e,t=p*p*p,\n q=-(2.*a.x*a.x-9.*a.y)*e/9.+a.z,d=q*q+4.*t/27.;if(d>.0){v1 x=(v1(1,-1)*sqrt(d)-q)*.5;\n return v2(suv(sign(x)*pow(abs(x),v1(1./3.)))+e);}v1 m=cs(acos(-sqrt(-27./t)*q*.5)/3.)\n  *v1(1,sqrt(3.));return v2(m.x+m.x,-suv(m),m.y-m.x)*sqrt(-p/3.)+e;}\n//return squared distance to line segment, no normalization needed.\nv0 dLine(v1 a,v1 b,v1 p){a=a-p;b-=p;p=b-a;return dd(a+p*sat(-dot(a,p)/dd(p)));}\n#define ddb(a) (dd(d+(c+b*t.a)*t.a))\n//Get distance of [p] to palnar bezier curve (ellipse) trough Cv[A,B,C]\nv0 dBezier(v1 p,v1 A,v1 B,v1 C){   \n //B=mix(B+v1(1e-4), B, abs(sign(B * 2.0 - A - C)));//colinear CV triviality\n v1 a=B-A,b=A-B*2.+C,c=a*2.,d=A-p;v2 k=v2(3.*dot(a,b),2.*dd(a)+dot(d,b),dot(d,a))/dd(b),\n t=sat(SolveQuad(k));return sqrt(miv(v2(ddb(x),ddb(y),ddb(z))));}\n//---window function & curve fittings.y:  https://www.shadertoy.com/view/Xtscz7\n#define bma(b,a,c) (((b)-(a))*(c)+a)\n// float Cosine(float x, float a, float b){return (b-a)*(1.-cos(x*acos(-1.)))*.5 + a;}\n#define wCosine(x,a,b) (bma(b,a,(1.-cos(x*acos(-1.)))*.5)\n// float Linear(float x, float a, float b){return  a*(x*(b/a-1.)+1.);}//doesnt look too good.\n#define wLinear(x,a,b) a*(x*(b/a-1.)+1.)\n//Smoothstep(0,1,x), without sat(a), unclamped scaled Hermite3;\n#define wSs2(x) (x)*(x)*(3.-2.*(x))\n#define wSs(x,a,b) wSs2((x)-(a)/((b)-(a)))\n//this is not too useful, without sat it sucks, unless you tsselate with simple interval.\n//\n//lower lipschitz == less likely spheretracking overestimation.\n//most general, smoothest most excessive, most zigzag, lowest lipschitz\n#define wHermiteD(x,a,b,e,f) (b+.5*x*(e+b-a+x*(a-b+e+x*3.*(e*3.+f+x*5./3.*(-e*3.-f+x*.4*(e*3.+f))))))\n#define wHermite(x,a,b,c,d) HermiteD(x,a,b,(c-b),(a-d))\n//special case of Hermite(), with a smooth .5 average. medium zigzag\n#define wCatmullRom(x,a,b,c,d) ((((d-a+3.*(b-c))*x+(2.*(a+c+c)-d-5.*b))*x+(c-a))*.5*x+b)\n//efficient and smooth 2nd derivative, least zigzag, highest lipschitz \n#define wCubic(x,a,b,c,d) ((((d-c-a+b)*(x-1.)+a-b)*x+(c-a))*x+b)\n//Cosine() is smoother than Cubic()\n//fast good monochrome distance field visualization.\nv3 rg(v3 c){v3 b=smoothstep(fsaa,-fsaa,c);\n return mix(fract(c*4.),b,.5+(atan(c))/acos(-1.));}\n//return y=f(a,m); m.xyzw coefficients of GeneralPoynomWithExponent3==f();\nv0 p3(v0 a,v3 m){\n //return m.x+a*m.y+a*a*m.z+a*a*a*m.w;//lazy, worst\n //return dot(vec4(1),m*vec4(1.,a*vec3(1,a*vec2(1.,a))));//overly explicit vector processor\n return dot(vec4(1),m*vec4(1.,a,a*a,a*a*a));//explicit vector processor\n return m.x+a*(m.y+a*(m.z+a* m.w));//explixit MAD() (better precision)\n ;}//#define p3(u,f) (f.x+u*f.y+(u*u)*f.z+(u*u*u)*f.w)\n//---hash\n#define hs vec4(1031,.1030,.0973,.1099)\n//h* hashes, fast mediocre, better for mobile gpu, Sans Euclid, without trigonometry.\nv0 h11(v0 p){v2 f=fract(v2(p)*hs.y);f+=dot(f,f.yzx+19.19);\n return fract((f.x+f.y)*f.z);}\nv2 hash33(v2 a){a=fract(a*hs.xyz);a+=dot(a,a.yxz+19.19);\n return fract(a.zyx*(a.xxy+a.yzz));}//https://www.shadertoy.com/view/4djSRW\n\nv3 h44(v3 a){a=fract(a*hs);a+=dot(a,a.wzxy+19.19);\n return fract(a.zywx*(a.xxyz+a.yzzw));\n}//https://www.shadertoy.com/view/4djSRW\n\n/* End__.Lib.Frame.8\n   Start.Special\n*/\n//subroutines that are too special to enter the Library,\n// to not be generalized or specialized (for now).\n\n//a mix (interpolate between) a polynom.y and a hash.y\nfloat ph(float a,vec4 m){return mix(h11(a),p3(a,m),MixHashPoly3);}\n\n/* End__.Special\n   Start.Main\n*/\nvoid mainImage( out vec4 O,in vec2 U){\n vec2 u =fra(U);vec4 m=vec4(fra(iMouse.xy),fra(iMouse.zw));  \n #ifdef ViewSvivel\n  u=u.yx;m=m.yxwz;//swivel view, use horizontal space to show higher exponentials.\n #endif\n    \n float i=u5(cos(acos(-1.)+TimeS));\n //i=interval of dots, goes all the way to 0, maybe not on linux.\n //testing limited precision (of IEEE float)\n #if   TestDivideByZeroCase==0\n  i=.000000;\n #elif TestDivideByZeroCase==1 \n  i=.000001;\n #elif TestDivideByZeroCase==2\n  i=.000020;\n #endif\n vec2 x=i*vec2(fract(u.x/i),floor(u.x/i));//dividing by 0, or very small values, here.\n //and then multiplying by the same (asmall number).\n \n //m=vec4(-1);//static debug overwrite\n m.xyzw=m.ywzx;//swivel coefficients to something that makes more sense \n               // for mouse.xy inputs.\n vec2 a=vec2(ph(x.y  ,m),\n             ph(x.y+i,m));//position.y of \n a=u.y-a;\n float f=min(dd(vec2(x.x  ,a.x)), //halfDot on the left  side of a period.\n             dd(vec2(x.x-i,a.y)));//halfDot on the right side of a period.\n //Above [f] stores a squared distance, \n // to have th option to not squaretroot it below.\n\n vec4 c=vec4(0);\n #if ColorGradient<1\n  //ColorgGradient==0 combines all of the other 4 gradients below.\n  c.y=smoothstep(fsaa,-fsaa,f -5./fsaa);//faster, gradient is NOT Euclidean distance.\n  //gradiend it inverse square, good enough for circles!\n  c.z=fract(f);\n  f=sqrt(f);\n  #if ColorGradient==-1\n   c.x=smoothstep(fsaa,-fsaa,abs(f-i+fsaa*2.)-fsaa);//gradient is Euclidean distance.\n  #else\n   c.x=smoothstep(fsaa,-fsaa,   (f*.5       )-fsaa);//gradient is Euclidean distance.\n  #endif\n  c.w=fract(f);\n  c=mix(c,c.xxxx,u5(sin(iTime*acos(-1.))));//oscillate between showing; c.x; or; c\n #elif ColorGradient==1\n  c.x=smoothstep(fsaa,-fsaa,sqrt(f)-fsaa)      ;//gradient is Euclidean distance.\n #elif ColorGradient==2\n  c.y=smoothstep(fsaa,-fsaa,f  -5./fsaa);//faster, gradient is NOT Euclidean distance.\n  //gradiend it inverse square, good enough for circles!\n #elif ColorGradient==3\n  c.z=fract(f);\n #else \n  c.w=fract(sqrt(f));\n #endif\n\n c.rg=mix(c.rg,c.aa,.5);//mix a as yellow;\n O=vec4(c.xyz,1);}\n/* End__.Main\n   Start.Bisymmetry.4\n*/\n\n/*\nBISYMETRY PRINCIPLEs:\n- Bisymmetry is a m,ethod to define and optimize ANY distance field, with biases.\n- Bisymmety is \"A set that I made up\" for lack of a better more common namespace.\n-  the Bisymmetry set overlaps with; Topology, Galois, Lie; Is mostly root solving.\n- Bisymmetry is \"code golf\". Best substitution,soluion depends on the functions context.\n- Bisymmetry is mostly about finding the differences between multiple Polinomials.\n-  to cancel or factorize out shared sums and fators.\n-  To increase symmetry-awareness. (in multiple contexts)\n-   transform your function into binomials with sign() where ever it is possible...\n- - This is possible where your gradient,topology has (hidden) symmetry.\n- - This is possible where your (polynomial) gradient can be reduced to binomials.\n- - This simplifies root solving a lot, calculating distance of points to isolines.\n-  Utilize  https://en.wikipedia.org/wiki/List_of_planar_symmetry_groups\n-  Utilize borders, defined by linear-algebra-deformed, as (branchless) branches.\n-  Only write atomic special cases and transformations, \n-   to construct general functions from.\n-  Instead of writing a general function, \n-   to be fed with a lot of parameters set to 0 or 1 to turn them into \"special cases\"\n- - This way general functions can be made into special \"shortcut\" functions more easily.\n- - This way special functions can more easily be extended, generalized.\n---\n- If(any loop only accumulates over some iterations of a loop)\n- - Your loop can be subdivided into overlapping fract()ions,\n- - ... like it is done for non-uniform_non-Rational_splines.\n- - ... like it is done for tesselated Voronoi.\n- - ... like it is done for fundamental calculus  https://www.shadertoy.com/view/MlscWn\n- - ... like it is doable for a lot of smin() smooth minimum functions.\n- - ... ... you only accumulate the (min) distance of nearby sums,prducts).\n- - - This transforms any loop into a (single pass) recursion\n- - ... ... of non-recursive subroutines! \n- - - This is Different from unrolling a loop or transforming a loop into a recursion.\n- - - This is closer to calculating a bezier curve with N recursive functions,\n- - - where; N=ControlVectors-2\n---\n--- Example of a \"bisymmetrically optimized function\":\nfloat demo(vec2 u,vec4 m){//u= uv position; m=iMouse.xyzw , parameters.\n u.x=abs(u.x-1.); u.y=-u.y*.5; //symmetry modifiers are likely \"outsourced\"\n float a=sign(m.x-1.)+1.;\n float b=sign(m.y+1.)+u.x;\n float c=sign(m.z+m.x)-m.y;\n float c=-sign(m.z-u.x);\n //parameters tent to mostly end up inside of sign()\n //above are all sign-factors, below is the final binomial,both rarely are shared subroutines.\n return u.x*(a+b)*(c+2.)*d*0.5-u.y\n //the *.5 and -u-y can likely be \"outsourced\"\n}\n- Contextual Bias constrains how you \"best\" transform binomials and branches.\n- Knowing your bias/context         limits  \"arbituarity of your choices\".\n- Knowing possible generalizations, extends \"arbituarity of your choices\".\n- In general, it makes sense to delay sqrt() or length() as much as possible.\n-  while also keeping brnches that are shortcuts \n-  Eg: usually abs(length()) begs to be a shortcut.\n...\n- This whole PRINCIPLE screams FRACTAL and SUPERPRIM !\n- - https://www.shadertoy.com/results?query=superprim\n- this PRINCIPLE more easily delays sqrt() or length() till the end of a function, \"outsource\"able\n\nHOW TO\n- Rearrange your branches so that sqrt() or length() is delayed as much as possible.\n- - This equates to segmenting a shape into sub-spahes with different exponents.\n- -  then sorting them by highest exponent.\n- -  then sorting them by shared binomial coeficcients.\n- -  ... (a more general case is still too vague to write here)\n-  abs(length()) can not be delayed, polynomialited, \n-   therefore it may as well be treated like a [Bounding Box,Volume] shortcut.\n-   If(your shape contains abs(length())) that branch stays as if() branch!\n- All other brahcnes usually end up being equally complex trees of equally complex branches.\n-  In that case, an openCL coders eyes open to reveal how to make long pipelines:\n- Substitute functions with identities to reveal their underlying bisymmetries.\n- - substitute max() to if()then() to mix(step)) to mix(sign()) to sums of sign()\n- - - for details on identities see - https://www.shadertoy.com/view/ldBfzc\n- - because there is often a lot of symmetry performance \"lost\" in if-branches, or max()=-min(-)\n- End up precalculating the specifics of a function, \n- Get a sum that you can easily modify. Than transform the sum into binominals\n-  of precalculated variabls, that make sense in the context.\n- - To get the factor of 2. transform a binimial into a non-binomial;\n- -  (a+b)*(c-b)=2.(a*b+a*c)=2.(a*(b+c));\n- - where ever an if() branch ends up as a branchless; .5*n*( binomial );\n\n...\n- Using only fullRotation*N/24 , makes it more likely that terms cancel each other out.\n- if (symmetry) 2 symmetric subroutine-values tend to cancel factors out, \n- ... down to sign(a)*sign(a)=1.\n- Your function(s) turns into a \"family of bisymmetrical functions\" \n- ... that are more easily generalized or specialized.\n- ... that are more easily made work-save against undefineds like: \n- ... a=atan(0.,0.)*tan(acos(.0))*log2(0.)*pow(0,0)*a/0.\n*/\n\n/* End__.Bisymmetry.4\n   Start.Bisymmetry.4+1 (optimization pointers)\n*/\n\n/*\nPreamble Warning; \n This has losts of pointers to overlapping sets of topics that can be studied for decades.\n But often a quick sloppy inefficient (heuristic analysis), \n  solution without years of study and application for optimization, \n  is just as efficient on the most limited resource, that is Time.\n   You may waste too much time just by reading the text below.\n   That may just be spent better socializing with family.\n   In the end, natural selection is a deadly bitch, sharing is caring,\n    and Analysis is just a compforting model.\n   The text below is mostly about isoline/contour, simplifying analysis by seperation.\n    https://www.shadertoy.com/results?query=isoline\n    https://en.wikipedia.org/wiki/Boundary_(topology)\n    https://en.wikipedia.org/wiki/Syllogism\n   Natural selection cares more about (reproductive) unification and maintenance\n    than about seperation.\n\nThis was first created in a shader called \"hash for Euler+Euclid\"\n because it wants to mix \"dope\" with [analysis] and [trigonometry]\n and because it includes hash functions;\n http://www.urbandictionary.com/define.php?term=Dope\n http://www.urbandictionary.com/define.php?term=So%20dope\n http://www.urbandictionary.com/define.php?term=hella%20dope\n\nAnyways:\nOptimization includes Bias and context, your biggest question ends up being, \n what you are optimizing for;\nFlexibility and Specialization end up likely being mutually exclusive.\n...\nOptimization includes what I poorly label as \"Bisymmetry\", \n which seems to be a messy set of all of the below, that i am still (re)structuring;\nhttps://www.shadertoy.com/results?query=bisymmetry\n...\nOptimization includes mostly being good at categorizing, using set theory.\nThis automatically ends up being more about arbitiary intuition \n than you will ever be able to be aware of. \nIt shows you that you are (more) biased and constrained by your personal experiences \n (than you CAN be aware of):\nhttps://www.youtube.com/watch?v=F7yLL5fJxT4\nIn geneal, do not assume an easily Categorizable universe.\nA model (of a world) Where everything has its frame without overlap, \n or where strong forces lead to hard Boolean boundaries between black and white\n is overly specific and overly exclusive. Boolean algebra is a VERY simplified model.\nIn reality, everything appears to be a fuzzy grey gradient (between black and white), \n a waveform that collapses into a single value just by measuring anything, \n and we arbitiarily define [isoline] boundaries \n for the sake of simpler comprehension \n from what we (believe to) have measured in the past.\nThe problem of our brains awareness is that \n we can not read information from our own memory without modifying the same information.\nOn the bright erside, a gradient just EXACTLY what a (signed) distance function returns.\nOptimization developes a skill of generalizing and specializing a function \n by applying set theory and by being more aware of generalalizing gradients, \n by modifying isolines arbitiaryly.\n Ask yourself WHY any point on that shader a specific color, on one side of a border: \nhttps://www.shadertoy.com/view/ldfBzs\n...\nCreating an isoline in shadertoy, with roughly even thickness, from a deformed gradient \n (where the ratios between 2 domains is strethced) is pretty simple; \n You end up dividing by the (smaller) gradients(s) to normalize it, \n which comes down to dividing by a first derivative. Which comes down to a substraction.\n There are different types of gradients though, euclidean, linear ... \n The functions a/=cross(dFdx(a),dFdy(a)) \n or a/=fWidth(a)=min(abs(dFdx(p)),abs(dFdy(p))) \n are VERY FAST rough approximations for the first derivative \n over the fragments by their position.\n It is good enough to estimate a curvature (2nd derivative), \n or to make a >=2 pixel wide nearly UNIFORMLY blurred isoline, border.\nAs such it is a lot about [Window function]s and [basis function]s \n for [Approximation theory]\n...\nOptimization includes [Galois Theory], \n as a bridge between [set theory] and [field theory].\nGalois basically solves roots of polynomials, (where y=f(x)=0)\n but cares more about the GENERAL corellations between the roots \n than the actual numerical value.xy of the roots. (a complex _plane root.y!=0);\nIn that sense it focuses on the first derivative of the roots, or on \n the local extrema of a function \n == the roots of the first derivative of a function.\nhttps://www.shadertoy.com/view/MdXBzB\nThus it bridges isolines and root solving.\n...\nOptimization often includes [Analysis, Calculus] \n often boiling down to [Fourier Analysis], \n because it is often more efficient and heuristically clsoe enough\n to calculate a good enough approximation, \n generally for an upper bound, than a more analytical [gradient descent].\nThis generally gets you to the [Taylor series] \n and the a long set of identities that transform [convergent infinite series] \n into an [convergent (in)finite sum, product] \n to approximate anything. Especially to approximate irrational values,\n that can not be expressed as finite fractions. \n  https://en.wikipedia.org/wiki/Topology\n  https://en.wikipedia.org/wiki/Window_function\n  https://en.wikipedia.org/wiki/Basis_function\n  https://en.wikipedia.org/wiki/List_of_continuity-related_mathematical_topics\n  https://en.wikipedia.org/wiki/B%C3%A9zier_curve\n  https://en.wikipedia.org/wiki/Parametric_equation\n  https://en.wikipedia.org/wiki/Approximation_theory\n...\nMore Basic optimization includes, being good at [boolean algebra] and inequalities, \n because after you arbitiarily divide a field into smapller segments \n (mostly with a biass to seperate high exponents from lower exponents)\n you will end up comparing 2 values for bounding volumes \n to calculate if a point is on the left or right side of a border (or isoline):\nhttps://i.imgur.com/XtzqimN.gif     \n even 16 BASIC boolean algebra operands are VERY arbitiarily ordered and named, \n showing there is NO BETTER structure.\nhttps://en.wikipedia.org/wiki/Boolean_algebra\nhttps://en.wikipedia.org/wiki/Algebraic_structure\nwith\nhttps://en.wikipedia.org/wiki/Equivalence_relation\nhttps://en.wikipedia.org/wiki/Congruence\nhttps://en.wikipedia.org/wiki/Isometry\nhttps://en.wikipedia.org/wiki/Glide_reflection   \n ==  https://www.shadertoy.com/view/XsfBDH\nhttps://en.wikipedia.org/wiki/Symmetrization\nhttps://en.wikipedia.org/wiki/List_of_planar_symmetry_groups\nhttps://en.wikipedia.org/wiki/Permutation\nhttps://en.wikipedia.org/wiki/Homeomorphism\nhttps://en.wikipedia.org/wiki/Coxeter_notation\nIn general, with [partially ordered set]s, [semigroup]s, \n and often [shared prime factors] of 2 values.\noptimization includes [homology] of algebraeic [topology];\n Similarities in multiple topologies.\n...\nGood optimization quickly includes Bounding Volume (Hierarchy); \n You must not get rid of an if-branch when it is a shortcut\n that is statistically worth being calculated and likely taken.\n Such a shortcut is almost always a \"bounding volume\",\n where you know that a point of ray is just too far from something\n to need to measure that thing in detail,\n and you can skip that thing, especially in fractal geometry, \n where this comes down to determining orbitals of fractals, \n == too slowly or non converging functions.\nhttps://en.wikipedia.org/wiki/Bounding_volume\nhttps://en.wikipedia.org/wiki/Bounding_volume_hierarchy\nA GPU is a parallel vector processor \n who deals almost only with 16x16 matrix transformations,\n and its hardware is optimized for type float32. \n This means, multiple functions can be unified into a single 16x16 matrix,\n and newer GPUs have no problem doing calculating multiple matrixes in a pipeline,\n meaning, it will calculate 4 matrices in the time of calculating 1 matrix,\n because there are 4 workers in a seamless assembly line,\n each doing their on unique modification in a\nhttps://en.wikipedia.org/wiki/Pipeline_(computing)\nThe problem here is that any if-branch is a branch in the pipeline\n and multiple shorter pipelines are usually slower (on newer hardware)\n than longer pipelines. Older hardware benefits less from that\n and benefits more from overly excessive bounding volumes.\n For newer hardware it can make sense to have LESS bounding volumes and less if-branches, \n even when that adds 2 more multiplications and more substractions,\n because it iis better at longer pipelines than at smaller more branching pipelines.\nA GPU makes a bad turing machine.\nAGPU is better for convergent deterministic convergent tasks,\n mostly boiling down to [root solving] and catching (arbitiarily defining) orbitals \n BEFORE you even come close to a\nhttps://en.wikipedia.org/wiki/Halting_problem\n== https://en.wikipedia.org/wiki/Undecidable_problem\n...\nOptimization often includes (or tuches) Symmetry topics;\n https://en.wikipedia.org/wiki/Similarity_(geometry)\n https://en.wikipedia.org/wiki/Lie_group\n https://en.wikipedia.org/wiki/Codomain\n https://en.wikipedia.org/wiki/Extensionality\n https://en.wikipedia.org/wiki/Radial_basis_function\n https://en.wikipedia.org/wiki/Diophantine_equation \n https://en.wikipedia.org/wiki/Lambda_calculus\n*/\n\n/* end__.Bisymmetry.4+1 (optimization pointers)\n   start.Dump.Memos\n*/\n\n//memo on bezier bounding volume: http://i.imgur.com/b4q3r2n.jpg\n//if a bezier is meant to define a surface, and i want to trace the BoundingVolume first\n//but the *.tricky points for the BV possibly make the BV not worth calculating.\n//still worth buffering for a static object?\n\n\n\n\n/*\n[halfspace tapping] link collection (v3) (may only be correlated, not even using the method, but SHOULD use the method)\n//\nsawblade serrated disk inversion  \nhttps://www.shadertoy.com/view/4t3fz7\nparent of the above is below\nhttps://www.shadertoy.com/view/XtSczV\n//\nwhich contains links to\ni tried to make this a sawblade\n, and noticed that i would need an insideout rounded box gradient for this: \nhttps://www.shadertoy.com/view/4t3fz7 \n//\nwe need a label for this [overlapping tile/slice] [typesetting] [CircleOfConfusion] \nstuff first time i see it in polar coordinates: \nprevious instances where linear or square lattice (and often only partially overlappin CoC's) \nhttps://www.shadertoy.com/view/4tjcWR\nhttps://www.shadertoy.com/view/MlscWn \n//\nI suggest [halfspace tapping]\n, where CoC implies bokeh, this generalizes it to \"overlapping of dark areas with lit areas\" \nthat may even not overlap completely (or at not overlap at all) :\ntoon clouds (very similar to / MlscWn ):\nhttps://www.shadertoy.com/view/4t23RR\nhttps://www.shadertoy.com/view/MltyR7 \nhttps://www.shadertoy.com/view/ltVcWt\nconcept of a non-monoispaced tree structure (branching a dualGlpyhString into 2 non monospaced sub-glyphs, branchless tree element)\nhttps://www.shadertoy.com/view/ltVcWt\n//\nolder and simpler [halfspace] shaders, closer to \nhttps://www.shadertoy.com/view/Md2cWK\nmodulo-gears:\nhttps://www.shadertoy.com/view/Msl3Rn\npavement:\nhttps://www.shadertoy.com/view/XsKXz3\npolar grid motion does 3-tap, and wopuld be great for half-space overlap:\nhttps://www.shadertoy.com/view/XtcfRH\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}