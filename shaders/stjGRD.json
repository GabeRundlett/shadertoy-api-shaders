{
    "Shader": {
        "info": {
            "date": "1623478856",
            "description": "a visualization of the winding number field for a 2d shape with a discontinuity.\n\nClick for an alternative visualization.\n\nsimilar to the 2d sample provided in \"robust inside outside segmentation using generalized winding numbers\" by jacobson et al (2013)",
            "flags": 0,
            "hasliked": 0,
            "id": "stjGRD",
            "likes": 16,
            "name": "winding number of a 2d shape",
            "published": 3,
            "tags": [
                "math"
            ],
            "usePreview": 0,
            "username": "copperbotte",
            "viewed": 480
        },
        "renderpass": [
            {
                "code": "\n//build an sdf for visualization purposes.\nfloat sdf_point(in vec2 point, in vec2 pos)\n{\n    vec2 delta = point - pos;\n    return length(delta);\n}\n\nfloat sdf_line(in vec2 normal, in float offset, in vec2 pos)\n{\n    float proj_dist = dot(normal, pos);\n    proj_dist -= offset;\n    \n    return abs(proj_dist);\n}\n\nfloat sdf_segment(in vec2 p1, in vec2 p2, in vec2 pos)\n{\n    //move pos into the coordinate system of the line, where the line is the x axis from 0 to 1.\n    //If it's x coordinate is outside the line range, use the shortest point sdf.\n    //else, use the line sdf.\n\n    //gather data for the line sdf\n    vec2 dp = p2 - p1;\n    //vec2 normal = normalize(cross(vec3(dp, 0), vec3(0,0,1)).xy);\n    vec2 normal = normalize(vec2(dp.y, -dp.x)); // complex rotation is valid in 2d\n    float offset = dot(p1, normal);\n    \n    //find the tangent coordinate\n    vec2 tangent = normalize(dp);\n    float t_1 = dot(tangent, p1);\n    float t_2 = dot(tangent, p2);\n    float dt = t_2 - t_1;\n    \n    //manually project the x axis instead of a matrix, sdf_line handles the y.\n    //maybe this is slower, but for this demo it shouldn't matter.\n    float t_pos = dot(tangent, pos);\n    \n    //inverse lerp\n    t_pos = (t_pos - t_1) / dt;\n    \n    //test within line\n    if(t_pos < 0.0)\n        return sdf_point(p1, pos);\n    \n    if(1.0 < t_pos)\n        return sdf_point(p2, pos);\n    \n    return sdf_line(normal, offset, pos);\n}\n\n//find the winding number usint a pair of vertices and a point.\nfloat wind_segment(in vec2 p1, in vec2 p2, in vec2 pos)\n{\n    //the winding number is the signed path length of the projeciton of a curve onto a unit circle of radius r.\n    //this number is divided by its circumference, and means how many times the circle has gone around the point.\n    \n    vec2 d_p1 = normalize(p1 - pos);\n    vec2 d_p2 = normalize(p2 - pos);\n    \n    //winding number starts at p1, ends at p2.\n    //this can either be done via atan difference (probably has issues near the negative y direction)\n    //float w1 = atan(d_p1.y, d_p1.x);\n    //float w2 = atan(d_p2.y, d_p2.x);\n    //return w2 - w1;\n    \n    //or, by acos of a normalized dot.\n    float d = dot(d_p1, d_p2);\n    float ac = acos(d);\n    if(isnan(ac))\n        return 0.0;\n        \n    //find winding sign\n    float s = cross(vec3(d_p1, 0.0), vec3(d_p2, 0.0)).z;\n    ac *= sign(s);\n    \n    return ac / (2.0 * 3.141592);\n}\n\n\n\n\n//this demo has one of the line segments move.\nfloat moving_discontinuity(in vec2 uv, out float sdf)\n{\n\n    vec2[] verts = vec2[] (\n        vec2( 0.5, 0.5),\n        vec2(-0.5, 0.5),\n        vec2(-0.5,-0.5),\n        vec2( 0.5,-0.5)\n    );\n    \n    //adjust the last line\n    vec2 disp = vec2(0.2*sin(iTime / 2.0), 0.0);\n    \n    //display lines and generate winding number\n    sdf = 100000.0;\n    float wind = 0.0;\n    for(int i=0; i<4; ++i)\n    {\n        vec2 v1 = verts[i];\n        vec2 v2 = verts[(i+1)%4];\n        \n        if(i == 3)\n        {\n            v1 += disp;\n            v2 += disp;\n        }\n        \n        float t_sdf = sdf_segment(v1, v2, uv);\n        if(t_sdf < sdf) sdf = t_sdf;\n        \n        wind += wind_segment(v1, v2, uv);\n    }\n\n    return wind;\n}\n\n//this demo has the line segment grow.\nfloat growing_discontinuity(in vec2 uv, out float sdf)\n{\n\n    const int vert_count = 4;\n    vec2[vert_count] verts = vec2[] (\n        vec2( 0.5, 0.5),\n        vec2(-0.5, 0.5),\n        vec2(-0.5,-0.5),\n        vec2( 0.5,-0.5)\n    );\n    \n    //make a value grow for 3 seconds, and stop for two.\n    float time = min(mod(iTime, 5.0), 3.0) / 3.0;\n    \n    //find the distance between each segment\n    float[vert_count] dists;\n    for(int i=0; i<vert_count; ++i)\n        dists[i] = length(verts[(i+1)%vert_count] - verts[i]);\n        \n    //find the total distance for each segment\n    //include a zero sum for comparisons later\n    float[vert_count+1] sum_dists;\n    sum_dists[0] = 0.0;\n    for(int i=0; i<vert_count; ++i)\n        sum_dists[i+1] = sum_dists[i] + dists[i];\n    \n    //normalize the dists by the total distance\n    float[vert_count+1] pct_dists;\n    for(int i=0; i<vert_count+1; ++i)\n        pct_dists[i] = sum_dists[i] / sum_dists[vert_count];\n    \n    //convert time to the percentage path around a specific path segment\n    //default is 100% of the polygon\n    int segment = 4;\n    float pct = 0.0;\n    for(int i=0; i<vert_count; ++i)\n    {\n        if(pct_dists[i+1] <= time) continue;\n        segment = i;\n        \n        //inverse lerp\n        pct = (time - pct_dists[i]) / (pct_dists[i+1] - pct_dists[i]);\n        break;\n    }\n    \n    sdf = 100000.0;\n    float wind = 0.0;\n    \n    //display points and winding number before the segment\n    for(int i=0; i<segment; ++i)\n    {\n        vec2 v1 = verts[i];\n        vec2 v2 = verts[(i+1)%vert_count];\n    \n        float t_sdf = sdf_segment(v1, v2, uv);\n        if(t_sdf < sdf) sdf = t_sdf;\n        \n        wind += wind_segment(v1, v2, uv);\n    }\n\n    //display the next point to a calculated point (lerp)\n    if(segment != vert_count)\n    {\n        vec2 v1 = verts[segment];\n        vec2 v2 = mix(verts[segment], verts[(segment+1)%vert_count], pct);\n        float t_sdf = sdf_segment(v1, v2, uv);\n        if(t_sdf < sdf) sdf = t_sdf;\n\n        wind += wind_segment(v1, v2, uv);\n    }\n\n    return wind;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = mix(vec2(-1,-1), vec2(1,1), uv);\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    //sdf testing\n    //col *= 1.0 - exp(-50.0*sdf_line(normal, offset, uv));\n    //col *= 1.0 - exp(-50.0*sdf_point(verts[0], uv));\n    \n    float sdf = 100000.0;\n    //float wind = moving_discontinuity(uv, sdf);\n    float wind = growing_discontinuity(uv, sdf);\n    \n    //alternative visualizations\n    if(iMouse.z < 0.5)\n        col = vec3(1.0);\n    else\n        col = 0.5 + 0.5*cos((2.0*3.141592) *5.0*wind + iTime+uv.xyx+vec3(0,2,4));\n    \n    col *= 0.5 * wind + 0.5;\n    \n    //col *= 1.0 - exp(-100.0*sdf);\n    if(sdf < 0.005) col *= 0.0;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    //fragColor = vec4(uv, 0.0, 1.0);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}