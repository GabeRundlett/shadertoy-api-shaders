{
    "Shader": {
        "info": {
            "date": "1515044626",
            "description": "Draw a sphere",
            "flags": 0,
            "hasliked": 0,
            "id": "MlScWd",
            "likes": 0,
            "name": "Old_Sphere",
            "published": 3,
            "tags": [
                "sphere"
            ],
            "usePreview": 0,
            "username": "ragotpaul",
            "viewed": 348
        },
        "renderpass": [
            {
                "code": "// Infini\nconst float infini = 1.0 / 0.0;\n\n#define MAX_REFLECT 20\n\n// Material\nstruct Material {\n\tfloat Ka;\n\tfloat Kd;\n\tfloat Ks;\n\tfloat Shininess;\n};\n    \n// Shade\nstruct Shade {\n    vec3 color;\n    float ks;\n};\n\n// Light color\nconst vec3 ambientColor = vec3(1.0, 1.0, 1.0);\nconst vec3 diffuseColor = vec3(1.0, 1.0, 1.0);\nconst vec3 specularColor = vec3(1.0, 1.0, 1.0);\n\n// LookAt\n      vec3 eye = vec3(0.0, 2.0, -5.0);\nconst vec3 center = vec3(0.0, 0.0, 0.0);\nconst vec3 up = vec3(0.0, 1.0, 0.0);\n\n// Sky\nconst vec3 skyColor = vec3(0.1, 0.2, 0.3);\nconst int skyId = 0;\n\n// Sphere\nconst vec3 sphereColor = vec3(1.0, 0.0, 1.0);\n      vec3 spherePosition = vec3(0.0, 0.0, 0.0);\nconst float sphereRadius = 1.0;\nconst int sphereId = 1;\nconst Material sphereMaterial = Material(0.1, 0.8, 0.5, 64.0);\n\n// Plane\nconst vec3 planeColorDark = vec3(0.0, 0.2, 0.2);\nconst vec3 planeColorLight = vec3(1.0, 1.0, 1.0);\nconst vec3 planePosition = vec3(0.0, -1.0, 0.0);\nconst vec3 planeNormal = vec3(0.0, 1.0, 0.0);\nconst int planeId = 2;\nconst Material planeMaterial = Material(0.1, 0.8, 0.1, 1024.0);\n\n// Key\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst float fov = 90.0;\n\nvoid pixelToCamera(in vec2 pixelCoord, out vec3 rayPosition, out vec3 rayDirection)\n{\n    float focal = 1.0 / tan(radians(fov) / 2.0);\n    \n    vec3 cameraZ = normalize(center - eye);\n    vec3 cameraX = normalize(cross(- up, cameraZ));\n    vec3 cameraY = normalize(cross(cameraZ, cameraX));\n    \n    // float ratio = iResolution.x / iResolution.y;\n    \n    vec2 position = (2.0 * pixelCoord - iResolution.xy) / iResolution.y;\n    \n    rayPosition = eye;\n    rayDirection = normalize(position.x * cameraX - position.y * cameraY + focal * cameraZ);\n}\n\nfloat computeSphere(in vec3 rayPosition, in vec3 rayDirection, out vec3 intersectPosition, out vec3 normal)\n{\n    float a = dot(rayDirection, rayDirection);\n    float b = 2.0 * dot(rayPosition - spherePosition, rayDirection);\n    float c = dot(rayPosition - spherePosition, rayPosition - spherePosition) - sphereRadius * sphereRadius;\n    \n    float square_lenght = b * b - 4.0 * a * c;\n    \n    if (square_lenght >= 0.0)\n    {\n        float lenght = sqrt(square_lenght);\n        float t1 = (- b - lenght) * 1.0 / (2.0 * a);\n        float t2 = (- b + lenght) * 1.0 / (2.0 * a);\n        \n        float t = -1.0;\n        float direction = 1.0;\n        \n        if (t1 > 0.0)\n        {\n            t = t1;\n        }\n        else if (t2 > 0.0)\n        {\n            t = t2;\n            direction = -1.0;\n        }\n        else\n        {\n            return t;\n        }\n        \n        intersectPosition = rayPosition + t * rayDirection;\n        normal = normalize(intersectPosition - spherePosition) * direction;\n        \n        return t;\n        \n    }\n    return -1.0;\n}\n\nfloat computePlane(in vec3 rayPosition, in vec3 rayDirection, out vec3 intersectPosition, out vec3 normal)\n{\n    float d = dot(planeNormal, rayDirection);\n    if (abs(d) <= 0.0001) {\n        return -1.0;\n    }\n    \n    float t = dot(planeNormal, planePosition - rayPosition) / d;\n    \n    intersectPosition = rayPosition + t * rayDirection;\n    \n    normal = - sign(d) * planeNormal;\n    \n    return t;\n}\n\nfloat computeIntersection(in vec3 rayPosition, in vec3 rayDirection, out int id, out vec3 intersectPosition, out vec3 normal)\n{\n    float minDistance = infini;\n    id = skyId;\n    \n    vec3 intersectSphere;\n    vec3 normalSphere;\n    float distanceSphere = computeSphere(rayPosition, rayDirection, intersectSphere, normalSphere);\n    if ((distanceSphere > 0.0) && (distanceSphere < minDistance))\n    {\n        id = sphereId;\n        minDistance = distanceSphere;\n        intersectPosition = intersectSphere;\n        normal = normalSphere;\n    }\n    \n    vec3 intersectPlane;\n    vec3 normalPlane;\n    float distancePlane = computePlane(rayPosition, rayDirection, intersectPlane, normalPlane);\n    if ((distancePlane > 0.0) && (distancePlane < minDistance))\n    {\n        id = planeId;\n        minDistance = distancePlane;\n        intersectPosition = intersectPlane;\n        normal = normalPlane;\n    }\n    \n    if (id == skyId)\n    {\n        minDistance = -1.0;\n    }\n    \n    return minDistance;\n}\n\nvec3 getSphereColor()\n{\n    return sphereColor;\n}\n\nvec3 getPlaneColor(in vec3 position)\n{\n    vec3 axisX  = normalize(vec3(1.0, 0.0, 0.0) - dot(vec3(1.0, 0.0, 0.0), planeNormal) * planeNormal);\n    vec3 axisY  = normalize(cross(planeNormal, axisX));\n\n    vec3 diff = position - planePosition; \n    float u = dot(diff, axisX);\n    float v = dot(diff, axisY);\n    \n    return mod(floor(u * 0.5) + floor(v * 0.5), 2.0) < 1.0  ? planeColorDark : planeColorLight;\n}\n\nvec3 getObjectColor(in int id, in vec3 position)\n{\n    if (id == sphereId)\n    {\n        return getSphereColor();\n    }\n    else if (id == planeId)\n    {\n        return getPlaneColor(position);\n    }\n        \n    return skyColor;\n}\n\nMaterial getObjectMaterial(in int id)\n{\n    Material mat;\n    if (id == sphereId) {\n        mat = sphereMaterial;\n    } else if (id == planeId) {\n    \tmat = planeMaterial;\n    }\n    \n    return mat;\n}\n\nfloat getShadowFactor(in int id, in vec3 intersectPosition, in vec3 normal, in vec3 L, in float Ldist)\n{\n    int tmpId;\n    vec3 tmpPosition;\n    vec3 tmpNormal;\n    intersectPosition += normal * 0.0001;\n    float dist = computeIntersection(intersectPosition, L, tmpId, tmpPosition, tmpNormal);\n    if (dist < 0.0 || dist > Ldist) {\n        return 1.0;\n    }\n    \n    Material mat;\n    if (id == sphereId) {\n        mat = sphereMaterial;\n    } else if (id == planeId) {\n    \tmat = planeMaterial;\n    }\n    return mat.Ka;\n}\n\nvec3 shadowPhongShading(in int id, in vec3 objectColor, in vec3 N, in vec3 L, in vec3 R, in vec3 V, in float shadowFactor)\n{\n    Material mat;\n    if (id == sphereId) {\n        mat = sphereMaterial;\n    } else if (id == planeId) {\n    \tmat = planeMaterial;\n    }\n    vec3 ambient = mat.Ka * ambientColor;\n    vec3 diffuse = mat.Kd * diffuseColor * objectColor * max(dot(N, L), 0.0) * shadowFactor;\n    vec3 specular = mat.Ks * specularColor * pow(max(dot(R, V), 0.0), mat.Shininess) * ((shadowFactor < 1.0) ? 0.0 : 1.0);\n    \n    return ambient + diffuse + specular;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    eye = vec3(5.0 * cos(iTime * 0.1), 1.0, 5.0 * sin(iTime * 0.1));\n    spherePosition.y = sin(iTime * 0.1) + sphereRadius;\n    \n    \n    vec3 rayPosition;\n    vec3 rayDirection;\n    \n    pixelToCamera(fragCoord, rayPosition, rayDirection);\n    \n    vec4 m = iMouse;\n    m.x -= (iResolution.x / 2.0);\n    m.y -= (iResolution.y / 2.0);\n    m /= iResolution.xyxy;\n\tvec3 lightPosition = vec3(- m.x * 100.0, m.y * 100.0, 0.0);\n    \n    Shade shade[MAX_REFLECT];\n    \n    int nbReflect = 0;\n    \n    int id;\n    vec3 intersectPosition;\n    vec3 normal;\n    \n    do\n    {\n        \n        float dist = computeIntersection(rayPosition, rayDirection, id, intersectPosition, normal);\n\n        if (dist > 0.0)\n        {\n            vec3 L = normalize(lightPosition - intersectPosition);\n            vec3 R = 2.0 * dot(normal, L) * normal - L;\n            vec3 V = - rayDirection;\n\n            vec3 objectColor = getObjectColor(id, intersectPosition);\n\n            float shadowFactor = getShadowFactor(id, intersectPosition, normal, L, dist);\n\n            shade[nbReflect].color = shadowPhongShading(id, objectColor, normal, L, R, V, shadowFactor);\n            Material mat = getObjectMaterial(id);\n            shade[nbReflect].ks = mat.Ks;\n            \n            rayPosition = intersectPosition + 0.0001 * normal;\n            rayDirection = - 2.0 * dot(normal, rayDirection) * normal + rayDirection;\n        }\n        else\n        {\n            shade[nbReflect].color = skyColor;\n            shade[nbReflect++].ks = 0.0;\n            break;\n        }\n        nbReflect++;\n    } while (nbReflect < MAX_REFLECT);\n    \n    vec3 finalColor = vec3(0.0, 0.0, 0.0);\n    \n    for (int i = nbReflect - 1; i >= 0; --i)\n    {\n        finalColor *= shade[i].ks;\n        finalColor += shade[i].color;\n    }\n    \n    fragColor = vec4(finalColor, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}