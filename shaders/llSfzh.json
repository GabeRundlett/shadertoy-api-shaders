{
    "Shader": {
        "info": {
            "date": "1514543902",
            "description": "Mapping the flat craters of NickWest: https://www.shadertoy.com/view/ldtXWf to a sphere and fixing a bug on HD4000.  Usage: ---> Drag the mouse horizontally (left button) to adjust the scale of the craters. <---\n",
            "flags": 0,
            "hasliked": 0,
            "id": "llSfzh",
            "likes": 2,
            "name": "Craters on Craters on a Sphere",
            "published": 3,
            "tags": [
                "sphere",
                "moon",
                "mapping",
                "surface",
                "crates",
                "lunar",
                "crater"
            ],
            "usePreview": 0,
            "username": "twenkid",
            "viewed": 905
        },
        "renderpass": [
            {
                "code": "/* [Final author]: Twenkid (Todor \"Tosh\" Arnaudov)\n                   Mapping the craters to the sphere + antialiasing and a bug fix (on Intel HD4000/Win).\n                   Version: 29.12.2017\n\n   [Author of the craters shader]: NickWest \"Craters on craters\": https://www.shadertoy.com/view/ldtXWf\n   [Credits]: also to BigWing, DaveHoskins (noise, remap),\n             tudordot (sample ray tracing and mapping to sphere coordinates),\n             the mathematicians and graphics programmers from the past.\n\n    [Future work]\n         It will be way faster with one additional buffer: the craters should be rendered flat to a texture in the first frame,\n     then sampled from there. I didn't have enough \"passion\" now to complete it, though.\n                                     \n Antialiasing: AA3 - 3 samples, AA5 - 5 samples.\n If none is defined it's fast, but there's annoying \"point noise\" flickering in windowed mode.\n There is still noise/flickering in window, though.\n The edges should be smoother - maybe returning the angle/spherical coordinates and reducing the details?\n ...\n There was an annoying bug on an HD4000, maybe something with small numbers and precision. \n The shader runs slowly, but looks smoother on an old WebGL 1.0-level integrated Intel GPU/Linux (late Core 2 Duo era).\n\n On an Intel HD4000/Windows/Chrome it requires the iTime to be incremented, say: (#54)\n    pos.x += 1000. + iTime * animSpeed;\n    pos.y -=  1000.. + iTime * animSpeed * 0.25;\n\n Otherwise the picture is a strange \"griddy liney noise\" or has \"phantom\" flickering black circles when the constants are not big enough.\n \n+ Buggy also on: GF8600, Win7/Chrome\n*/\n\n//#define FLAT //original look by NickWest\n//#define SHADOW //shadows from NickWest, commented in his shader\n#define AA3\n\n\nconst vec3 circlePos = vec3(0.0);\nconst float circleRad = 0.9;\n\nconst vec3 lightPos = vec3(-0.3, -0.7, 2.5);\nconst vec3 viewerPos = vec3(-2, -0.7, 3.0);\nconst vec3 ambientCol = vec3(0.3);\nconst vec3 lightCol = vec3(0.23, 0.2, 0.22);\n\n\n\n//BigWing's noise\nfloat N1(float t) { \treturn fract(sin(t*10234.324)*123423.23512); }\nvec3 N31(float p) {\n    //  3 out, 1 in... DAVE HOSKINS\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n\nfloat N2(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 N22(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n    //modified to vec2, vec2\n\tvec2 p2  = fract(vec2(p.xyx) * vec2(443.897, 441.423)); // 437.195));\n    p2 += dot(p2, p2.yx + 19.19);\n    return fract(vec2((p2.x + p2.y)*p2.x, (p2.y+p2.y)*p2.x));\n}\n\nvec2 fbm(vec2 v){\n    return N22(v)*0.5 + vec2(0.25*N1(v.x)) + vec2(0.25*N1(v.y));\n}\n\n// Crater in -1.0 to 1.0 space\nfloat crater(in vec2 pos) {\n    float len = length(pos);\n    float pi = 3.1415926535;\n    float x = clamp(pow(len, 4.0) * 8.0, pi*0.5, pi*2.5);\n    float t = clamp(len, 0.0, 1.0);        \n    //x=0.5; t=0.5;\n    return sin(-x) + 0.5 - 0.5 * cos(t * pi);\n}\n\nvec2 pseudoRand(in vec2 uv) {\n    // from http://gamedev.stackexchange.com/questions/32681/random-number-hlsl\n    float noiseX = (fract(sin(dot(uv, vec2(12.9898,78.233)      )) * 43758.5453));\n    float noiseY = (fract(sin(dot(uv, vec2(12.9898,78.233) * 2.0)) * 43758.5453));\n    return vec2(noiseX, noiseY);}\n\nvec2 pseudoRand1(in vec2 uv) {\n   // uv/=abs(fract(uv));\n   // return -texture(iChannel0, uv).rg*2.;\n    // from http://gamedev.stackexchange.com/questions/32681/random-number-hlsl \n    //Changed consts:\n    float noiseX = (fract(sin(dot(uv, vec2(12.9898,78.433)      )) * 4375894.5453));\n    float noiseY = (fract(sin(dot(uv, vec2(12.9898,78.433) * 2.0)) * 4375894.5453));\n  //  float noiseX = (fract(sin(dot(uv, vec2(12.9898,78.233)      )) * 43758.5453));\n  //  float noiseY = (fract(sin(dot(uv, vec2(12.9898,78.233) * 2.0)) * 43758.5453));\n    \n    //noiseX = texture(iChannel0, vec2(noiseX, noiseY)).x;\n    //noiseY = texture(iChannel0, vec2(noiseY, noiseX)).x;\n    return vec2(noiseX, noiseY);\n}\n\nfloat repeatingCraters(in vec2 pos, in float repeat, in float scaleWeight) {\n    vec2 pos01 = fract(pos * vec2(repeat));\n    vec2 index = (pos * vec2(repeat) - pos01) / repeat;\n    vec2 scale = pseudoRand(index);\n    float craterY = crater(vec2(2.0) * (pos01 - vec2(0.5)));\n    return mix(1.0, pow(0.5*(scale.x + scale.y), 4.0), scaleWeight) * craterY; \n}\n\nfloat remap(float a, float b, float c, float d, float t) {\n\treturn ((t-a) / (b-a)) * (d-c) + c;\n}\n\nfloat getY(in vec2 pos, float scale) {    \n    float r = 0.5;\n    float y = 0.5;\n    y=0.;\n       \n    //WebGL 1.0       \n    for(int i=0;i<int(100);++i) {\n        float f01 = float(i) / float(99.);\n        float magnitude = f01*f01*scale;\n        vec2 offs = pseudoRand(vec2(float(i+2), float(i+7)*float(i+7)));       \n        float repeat = 0.5 / (magnitude + 0.0001/scale);\n        y += magnitude * repeatingCraters(pos+offs, repeat, 1.0);       \n    }                  \n  return y;\n}\n\nvec3 spherePos(vec2 pos, vec2 center, float rad)\n{\n    vec2 dir = pos - center;\n    return vec3(dir, sqrt(rad * rad - dot(dir, dir)));\n}\n\nvec2 sphereMap(vec3 pos, float rad)\n{\n    return vec2(atan(pos.z, pos.x), acos(pos.y / rad));\n}\n\nvec3 light(vec3 pos, vec3 inColor)\n{\n    vec3 norm = normalize(pos);\n    vec3 lightDir = normalize(lightPos - pos);\n    \n    float cosIncidence = dot(lightDir, norm);\n    float diffuse = clamp(cosIncidence, 0., 1.);\n    \n    vec3 refl = reflect(lightDir, norm);\n    vec3 viewDir = normalize(pos - viewerPos);\n\n    float specularTerm = clamp(dot(viewDir, refl), 0., 1.);\n    float specular = pow(specularTerm, 4.);\n    \n    return vec3(ambientCol * inColor.xyz + lightCol * (diffuse + specular));\n}\n\nvec4 craters(vec2 fragCoord){\n    float animSpeed = 0.22;\n    vec4 fragColor;\n    vec2 pos = (fragCoord.xy - iResolution.xy*0.5) / vec2(iResolution.y);\n    pos += vec2(1.0); // avoid negative coords\n\n    fragColor = vec4(0.);\n    fragColor.a = 1.;\n   // if ((pos.x > 0.5)||(pos.y > 1.)) return;\n    \n    //~Depth of craters/bumpyness\n    vec2 offs = vec2(0.001, -0.001);\n    //vec2(0.003 -0.003);\n    \n    //After certain tenths of seconds - glitches in the image\n    //if iTime is not < .0 glitchy lines\n    ///*\n   // pos.x += fract(iTime) * animSpeed;\n   // pos.y -= fract(iTime) * animSpeed * 0.25;\n    \n     float t = iTime+18000. ;//55555.;\n    \n     pos.x += t/5. * animSpeed;\n     pos.y -= t/5. * animSpeed * 0.25;\n        \n    // pos.x +=  0.; //fract(iTime)*10. * animSpeed;\n    // pos.y -= 0.0 ;//fract(iTime)*10.0 * animSpeed * 0.25;\n    \n    //Adjust the scale of the craters\n    float scale=0.15+iMouse.x/iResolution.x; // + 0.5;//0.25;\n        \n    float y = getY(pos, scale);\n    float y1 = getY(pos - offs, scale);\n    \n    //float y2 = getY(pos + offs);\n\n    vec3 normal = normalize(vec3(0.002, y-y1, 0.01)); //0.002 - depth\n\n    float d = 0.5 + 0.5 * dot(normal, normalize(vec3(2.0, 1.1, 2.0))); //2.0  1.1 - \"bumpyness\n    \n    float shadeScale = 1.0;\n\n    // shadows\n    #ifdef SHADOWS\n    {\n        \n        for(int i=0;i<int(40);++i) {\n            float f01 = float(i+1) / float(40.0);\n            f01 = pow(f01, 2.0);\n\n            vec2 posTest = pos - vec2(f01, -f01) * 0.5;\n\n            float yTest = getY(posTest, 1.);\n\n            float over = yTest - (y + f01 * 3.0);\n            \n            if(over > 0.0)\n                shadeScale = min(shadeScale, mix(1.0, 0.7, clamp(over*0.5,0.0,1.0)));\n        }\n    }\n    \n    d *= shadeScale;\n    #endif\n  \n    \n    float c = y * 0.02 - 0.5 + d * 1.3;\n    c = max(0.2,c); //fixes a bit of the bad black circles #21-11-2017\n    \n    vec3 rgb = vec3(mix(mix(vec3(0.0,0.0,0.0), vec3(0.3,0.2,0.1), c), vec3(1.0,0.95,0.90), c));\n    \n    fragColor = vec4(rgb,1.0);\n    return fragColor;\n}\n\n//#define FLAT 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef FLAT   //original craters look\n    fragColor = craters(fragCoord); return;\n    #endif\n    \n    vec2 defaultFragCoord = fragCoord;    \n    vec2 pos = 2.0 * vec2(fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    float ln = length(circlePos.xy - pos);\n    float bgMask = smoothstep(ln, ln + 0.015, circleRad); //second param - blur on the edge    \n    vec3 sphereP = spherePos(circlePos.xy, pos, circleRad);\n    vec4 sphereColor = texture(iChannel0, sphereMap(sphereP, circleRad));    \n    vec4 craterColor = craters(sphereMap(sphereP, circleRad)*iResolution.y); //OK!\n        \n    float aa = 1.0/iResolution.x; // 0.002; //shift for the antialiasing calculation\n         \n    #ifdef AA3\n    craterColor +=craters(sphereMap(sphereP+vec3(aa,0.,0.)*0.5, circleRad)*iResolution.y);\n    craterColor +=craters(sphereMap(sphereP+vec3(00.,aa,0.)*0.5, circleRad)*iResolution.y);\n    craterColor/=3.;\n    #endif\n    \n    #ifdef AA5\n     //vec4 anti = craters(sphereMap(sphereP, circleRad)*iResolution.y)\n    craterColor+= craters(sphereMap(sphereP+vec3(aa,0.,0.), circleRad)*iResolution.y)    \n       + craters(sphereMap(sphereP-vec3(-aa,0.,0.), circleRad)*iResolution.y)         \n       + craters(sphereMap(sphereP+vec3(0.,aa,0.), circleRad)*iResolution.y) \n       + craters(sphereMap(sphereP-vec3(0.,-aa,0.), circleRad)*iResolution.y);\n       craterColor /=5.;\n    #endif\n  \n    sphereColor = craterColor; //craters(fragCoord);\n\tfragColor =  fragColor * (1.0 - bgMask) + sphereColor * bgMask; \n                     \n    //Some stars\n    if (fragColor.r < 0.001)\n    {\n        vec2 n1 = N22(pos);\n        float star = n1.x < 0.06 ? 0.1 : 0.;\n        //star+= n1.y > 0.9 ? 0.15 : 0.0;\n        //star+= n1.y > 0.97 ? N1(n1.x)/1.0*(max(star, sin(iTime))) : 0.0;\n        float vary=1.0;\n        star+= n1.y > 0.97 ? N1(n1.x)/1.0*vary : 0.0;\n        vec2 fb = fbm(pos);\n        star*=max(fb.x, fb.y);\n        \n    fragColor += star;\n    }\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}