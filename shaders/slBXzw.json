{
    "Shader": {
        "info": {
            "date": "1627305704",
            "description": "first glimpse of a tesseract. very experimental rendering method. click and drag to find a good angle. the fuzzier it is, the more of the shape is not well aligned along w. obvs there's a lot of room for improvement, but I'm pretty excited!",
            "flags": 0,
            "hasliked": 0,
            "id": "slBXzw",
            "likes": 4,
            "name": "my first tesseract",
            "published": 3,
            "tags": [
                "raymarching",
                "4d",
                "learning",
                "tesseract",
                "hypercube"
            ],
            "usePreview": 0,
            "username": "xertrov",
            "viewed": 340
        },
        "renderpass": [
            {
                "code": "#define u_resolution iResolution\n#define u_mouse iMouse\n#define u_time iTime\n#define gl_FragColor fragColor\n\n#define PI 3.141592653589\n#define TAU 6.28318530718\n\n#define S(a, b, t)smoothstep(a, b, t)\n\n#define BLACK vec3(0.0)\n#define WHITE vec3(1.0)\n\n#define GROW_SHRINK 0.3\n#define ROTATE_IDLE 0.2\n#define BASE_TWINKLE 99.0\n#define STAR_RARITY 0.95\n// set to 5k+ for a hyperspace bungee; curious noise patterns at 2000.\n#define BG_SCALE 100.0\n\n/* lib/util stuff */\n\nfloat N21b(vec2 p) {  // from an art of code video i think\n  vec3 a = fract(vec3(p.xyx) * vec3(213.897, 653.453, 253.098));\n  a += dot(a, a.yzx + 79.76);\n  return fract((a.x + a.y) * a.z);\n}\n\n\nfloat sdBox(in vec3 p, in vec3 b) {\n  vec3 d = abs(p) - b;\n  return length(max(d, 0.0)) + min(max(d.z, max(d.x, d.y)), 0.0);\n}\n\n\nvec2 best2(vec3 p) {\n  vec2 r = p.x > p.y ? vec2(p.x, p.y) : vec2(p.y, p.x);\n  if (p.z > r.x) { return vec2(p.z, r.x);}\n  if (p.z > r.y) { return vec2(r.x, p.z);}\n  return r;\n}\n\nfloat minOf(vec2 v) {\n  return min(v.x, v.y);\n}\nfloat minOf(vec3 v) {\n  return min(minOf(v.xy), v.z);\n}\nfloat minOf(vec4 v) {\n  return min(minOf(v.xyz), v.w);\n}\n\nvec2 sinCos(in vec2 ab) {\n  return vec2(sin(ab.x), cos(ab.y));\n}\n\n// roll from XY to XZ or YZ (0 no roll, 1=XZ, 2=YZ)\nmat3 rot3XY(float angle, int roll) {\n  float s = sin(angle), c = cos(angle);\n  mat3 r = mat3(c, - s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n  if (roll == 1) {\n    r = mat3(r[0].xzy, r[2].xzy, r[1].xzy);\n  } else if (roll == 2) {\n    r = mat3(r[2].zxy, r[0].zxy, r[1].zxy);\n  }\n  return r;\n}\n\n\n// warning, this is mostly untested -- written by me for this. fyi if you copy paste.\nmat4 rot4(float angle, int axis) {\n  float s = sin(angle), c = cos(angle);\n  mat4 r = mat4(\n    c, -s, 0, 0,\n    s, c, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1\n  );\n  // XY, XZ, XW\n  return axis == 0 ? r\n    : axis == 1 ? mat4(r[0].xzyw, r[2].xzyw, r[1].xzyw, r[3].xzyw)\n    : axis == 2 ? mat4(r[0].xwzy, r[3].xwzy, r[2].xwzy, r[1].xwzy)\n    // YZ, YW\n    : axis == 3 ? mat4(r[3].wxyz, r[0].wxyz, r[1].wxyz, r[2].wxyz)\n    : axis == 4 ? mat4(r[3].wxzy, r[0].wxzy, r[1].wxzy, r[2].wxzy)\n    // ZW\n    : axis == 5 ? mat4(r[3].wzxy, r[2].wzxy, r[0].wzxy, r[1].wzxy) : mat4(0.);\n}\n    /* Ahh! That bug isn't going to make sensible rotations. */\n    //axis == 5 ? mat4(r[2].wzxy, r[3].wzxy, r[1].wzxy, r[2].wzxy)\n\n\n\nvec3 best3(vec4 p) {\n  vec2 zw = vec2(max(p.z, p.w), min(p.z, p.w));\n  // p.z > p.w ? vec2(p.z, p.w) : vec2(p.w, p.z);\n  vec2 xy = vec2(max(p.x, p.y), min(p.x, p.y));\n  if (xy.y > zw.x) {return vec3(xy, zw.x);} // testme\n  if (zw.y > xy.x) {return vec3(zw, xy.x);}\n  return vec3(max(xy.x, zw.x), min(xy.x, zw.x), max(xy.y, zw.y));\n\n  /* tests\n  col = best2(zoth.xyz) == vec2(2., 1.) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.zywx) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.wxzy) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.wxyz) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.xywz) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  */\n}\n\nvec3 rainbow(vec2 uv, float time) {\n  return sin(vec3(time) + uv.xyx * vec3(1.0, 1.0, 1.0) + vec3(0, 2, 4)) * 0.49 + 0.5;\n}\n\n\nfloat sdBoxEdge(in vec3 p, in vec3 b) {\n  return length(best2(abs(p) - b));\n}\n\n// purely a guess based on the one for a cube\nfloat sdTesseractEdge(in vec4 p, in vec4 b) {\n  vec4 d = abs(p) - b;\n  //d.w /= 5.;\n  vec3 db = best3(d);\n  return length(db);\n}\n\nvec4 getIDGV(vec2 uv, float scale) {\n  vec2 id = floor(uv * scale);\n  vec2 gv = fract(uv * scale) - 0.5;\n  return vec4(id, gv);\n}\n\nfloat mkNoise(vec2 uv, float t, float minDS) {\n  float scale = fwidth(uv.x) * 100.0 * BG_SCALE;\n  vec4 idgv = getIDGV(uv, scale);\n  vec2 id = idgv.xy;\n  vec2 gv = idgv.zw;\n  float n = N21b(id);\n  float transFreq = BASE_TWINKLE * n + 0.01;\n  t -= 3877.627 * n;\n  float transProgress = fract(t * transFreq);\n  float transId = floor(t * transFreq);\n  float lastIdOffset = N21b(vec2(n, transId - 1.0));\n  float idOffset = N21b(vec2(n, transId));\n  float nextIdOffset = N21b(vec2(n, transId + 1.0));\n  float noiseThresh = STAR_RARITY;\n  float noise = S(1.0, 0.0, transProgress) * S(noiseThresh, 1.0, N21b(id + lastIdOffset));\n  noise += S(noiseThresh, 1.0, N21b(id + idOffset));\n  noise += S(0.0, 1.0, transProgress) * S(noiseThresh, 1.0, N21b(id + nextIdOffset));\n  return S(0.0, 0.2, minOf(0.5 - abs(gv))) * (noise * S(0.1, 2.0, minDS));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (gl_FragCoord.xy - .5 * u_resolution.xy) / u_resolution.y;\n  vec2 mouse = (u_mouse.xy - 0.5 * u_resolution.xy) / u_resolution.y;\n  float t = u_time / 9.0;\n  vec3 col = BLACK;\n  uv *= 4.0;\n\n  float fw = max(fwidth(uv.x), fwidth(uv.y));\n\n  float grow_shrink = GROW_SHRINK * sin(t * PI) * 0.1 + 0.9;\n\n  vec4 s = vec4(1.0, 1.0, 1.0, 1.0) * grow_shrink;\n\n  vec4 p = vec4(uv, - 4.0, N21b(uv) * 4. - 2.);\n\n  mat4 boxTrans = rot4(mouse.x * TAU / 2.0 + .347856, 1) * rot4(mouse.y * TAU / 2.0 + .37465, 4);\n  boxTrans *= rot4(t * 13.0 / 17.0 * ROTATE_IDLE + PI / 3.0, 1) * rot4(t * 13.0 / 11.0 * ROTATE_IDLE - 17.0 * PI / 7.0, 2);\n  boxTrans *= rot4(t * 11.0 / 17.0 * ROTATE_IDLE + PI / 3.0, 2) * rot4(t * 13.0 / 11.0 * ROTATE_IDLE - 17.0 * PI / 7.0, 3);\n  boxTrans *= rot4(t * 12.0 / 17.0 * ROTATE_IDLE + PI / 3.0, 4);\n  boxTrans *= rot4(t * 13.0 / 17.0 * ROTATE_IDLE, 5);\n\n  // raymarch over the orthogonal scene\n  vec2 sc = sinCos(vec2(t));\n  vec4 rd = normalize(vec4(0.0, 0.0, 1.0, 0.0));\n  float d = 0.0, dS = 999.0, minDS = 999.0, ed;\n  float steps = 0.0;\n  for(int i = 0; i < 50; i ++ ) {\n    ed = 999.;\n    steps ++ ;\n    float w = 0.0;\n    for (float w = -1.3; w < 1.3; w += .1) {\n        //if (w < minOf(s * boxTrans)) continue;\n        vec4 p_ = vec4(p.xyz, p.w + w) * boxTrans;\n        ed = min(ed, sdTesseractEdge(p_, s) - 0.01);\n    }\n    \n    dS = ed;\n    // dS = min(edgeDist, sdBox(p*boxTrans, s));\n    minDS = min(minDS, dS);\n    p = p + dS * rd * .5;\n    d += dS;\n    if (dS < 0.0001 || d > 100.0)break;\n  }\n\n\n  float noise = mkNoise(uv * grow_shrink, t, 1.);\n  col += noise;\n  col += S(0.01, 0.0, dS) * WHITE;\n  col += S(0.023, 0.005, minDS) * rainbow(uv, u_time + 2.0);\n  //col = minDS == 0. ? WHITE : RED;\n  \n  vec4 idgv = getIDGV(uv, 1.0);\n  vec2 id = idgv.xy, gv = idgv.zw;\n\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}