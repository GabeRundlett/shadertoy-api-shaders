{
    "Shader": {
        "info": {
            "date": "1673224543",
            "description": "Tea time!",
            "flags": 48,
            "hasliked": 0,
            "id": "Dtl3WS",
            "likes": 138,
            "name": "Path Tracing (Disney BSDF)",
            "published": 3,
            "tags": [
                "pathtracing",
                "pbr",
                "ggx",
                "disney",
                "bsdf"
            ],
            "usePreview": 1,
            "username": "XT95",
            "viewed": 4277
        },
        "renderpass": [
            {
                "code": "// ----------------------------------------------------------------\n// Path Tracing (Disney BSDF)\n// ----------------------------------------------------------------\n// \n// This is not optimized, I tried to keep it clear.\n// The BSDF has only the diffuse, specular and transmitance parts\n// for now.\n// \n//\n// You can move the camera with the mouse\n// and zoom in/out with 'w' and 's'.\n//\n// - Buffer A : Draw a raw frame\n// - Buffer B : Accumulate frame\n//              You can change the mode to get TAAish output\n// - Image : Basic ACES tonemapping\n// ----------------------------------------------------------------\n\nvec3 ACES(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    col = ACES(col*1.2);\n    \n    // vignetting\n    col *= vec3(1.) * smoothstep(1.8,.5, length(uv*2.-1.))*.5+.5;\n    \n    fragColor = vec4(pow(col, vec3(1./2.2)),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ----------------------------------------------------------------\n// Defines\n// ----------------------------------------------------------------\n// - Scene can go from 0 to 2\n// - The furnace_test show the energy loss, the image should be\n//   all white in a perfect pathtracer\n//   \n// ----------------------------------------------------------------\n#define CAMERA_SENSITIVTY .01\n#define FOCAL_LENGTH 3.\n\n\n// ---------------------------------------------\n// Hash & Random - From iq\n// ---------------------------------------------\nint   seed = 1;\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand() { return float(rand())/32767.0; }\nvec2 frand2() { return vec2(frand(), frand()); }\nvec3 frand3() { return vec3(frand(), frand(), frand()); }\nvoid  srand( ivec2 p, int frame )\n{\n    int n = frame;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589; // by Hugo Elias\n    n += p.y;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    n += p.x;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    seed = n;\n}\nvec3 hash3(vec3 p) {\n    uvec3 x = uvec3(floatBitsToUint(p));\n    const uint k = 1103515245U; \n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n\n\n\n// ---------------------------------------------\n// Maths\n// ---------------------------------------------\n#define saturate(x) clamp(x,0.,1.)\n#define PI 3.141592653589\n\nmat3 lookat(vec3 ro, vec3 ta)\n{\n    const vec3 up = vec3(0.,1.,0.);\n    vec3 fw = normalize(ta-ro);\n\tvec3 rt = normalize( cross(fw, normalize(up)) );\n\treturn mat3( rt, cross(rt, fw), fw );\n}\n\nmat2 rot(float v) {\n    float a = cos(v);\n    float b = sin(v);\n    return mat2(a,b,-b,a);\n}\n\n// From Fizzer - https://web.archive.org/web/20170610002747/http://amietia.com/lambertnotangent.html\nvec3 cosineSampleHemisphere(vec3 n)\n{\n    vec2 rnd = frand2();\n\n    float a = PI*2.*rnd.x;\n    float b = 2.0*rnd.y-1.0;\n    \n    vec3 dir = vec3(sqrt(1.0-b*b)*vec2(cos(a),sin(a)),b);\n    return normalize(n + dir);\n}\n\n// From Pixar - https://graphics.pixar.com/library/OrthonormalB/paper.pdf\nvoid basis(in vec3 n, out vec3 b1, out vec3 b2) \n{\n    if(n.z<0.){\n        float a = 1.0 / (1.0 - n.z);\n        float b = n.x * n.y * a;\n        b1 = vec3(1.0 - n.x * n.x * a, -b, n.x);\n        b2 = vec3(b, n.y * n.y*a - 1.0, -n.y);\n    }\n    else{\n        float a = 1.0 / (1.0 + n.z);\n        float b = -n.x * n.y * a;\n        b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\n        b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\n    }\n}\n\nvec3 toWorld(vec3 x, vec3 y, vec3 z, vec3 v)\n{\n    return v.x*x + v.y*y + v.z*z;\n}\n\nvec3 toLocal(vec3 x, vec3 y, vec3 z, vec3 v)\n{\n    return vec3(dot(v, x), dot(v, y), dot(v, z));\n}\n\n\n\n\n\n\n\n\n\n// ---------------------------------------------\n// Color\n// ---------------------------------------------\nvec3 RGBToYCoCg(vec3 rgb)\n{\n\tfloat y  = dot(rgb, vec3(  1, 2,  1 )) * 0.25;\n\tfloat co = dot(rgb, vec3(  2, 0, -2 )) * 0.25 + ( 0.5 * 256.0/255.0 );\n\tfloat cg = dot(rgb, vec3( -1, 2, -1 )) * 0.25 + ( 0.5 * 256.0/255.0 );\n\treturn vec3(y, co, cg);\n}\n\nvec3 YCoCgToRGB(vec3 ycocg)\n{\n\tfloat y = ycocg.x;\n\tfloat co = ycocg.y - ( 0.5 * 256.0 / 255.0 );\n\tfloat cg = ycocg.z - ( 0.5 * 256.0 / 255.0 );\n\treturn vec3(y + co-cg, y + cg, y - co-cg);\n}\n\nfloat luma(vec3 color) {\n    return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\n\n\n\n\n\n\n\n\n// ---------------------------------------------\n// Microfacet\n// ---------------------------------------------\nfloat Fresnel(float n1, float n2, float VoH, float f0, float f90)\n{\n    float r0 = (n1-n2) / (n1+n2);\n    r0 *= r0;\n    if (n1 > n2)\n    {\n        float n = n1/n2;\n        float sinT2 = n*n*(1.0-VoH*VoH);\n        if (sinT2 > 1.0)\n            return f90;\n        VoH = sqrt(1.0-sinT2);\n    }\n    float x = 1.0-VoH;\n    float ret = r0+(1.0-r0)*pow(x, 5.);\n    \n    return mix(f0, f90, ret);\n}\nvec3 F_Schlick(vec3 f0, float theta) {\n    return f0 + (1.-f0) * pow(1.0-theta, 5.);\n}\n\nfloat F_Schlick(float f0, float f90, float theta) {\n    return f0 + (f90 - f0) * pow(1.0-theta, 5.0);\n}\n\nfloat D_GTR(float roughness, float NoH, float k) {\n    float a2 = pow(roughness, 2.);\n    return a2 / (PI * pow((NoH*NoH)*(a2*a2-1.)+1., k));\n}\n\nfloat SmithG(float NoV, float roughness2)\n{\n    float a = pow(roughness2, 2.);\n    float b = pow(NoV,2.);\n    return (2.*NoV) / (NoV+sqrt(a + b - a * b));\n}\n\nfloat GeometryTerm(float NoL, float NoV, float roughness)\n{\n    float a2 = roughness*roughness;\n    float G1 = SmithG(NoV, a2);\n    float G2 = SmithG(NoL, a2);\n    return G1*G2;\n}\n\nvec3 SampleGGXVNDF(vec3 V, float ax, float ay, float r1, float r2)\n{\n    vec3 Vh = normalize(vec3(ax * V.x, ay * V.y, V.z));\n\n    float lensq = Vh.x * Vh.x + Vh.y * Vh.y;\n    vec3 T1 = lensq > 0. ? vec3(-Vh.y, Vh.x, 0) * inversesqrt(lensq) : vec3(1, 0, 0);\n    vec3 T2 = cross(Vh, T1);\n\n    float r = sqrt(r1);\n    float phi = 2.0 * PI * r2;\n    float t1 = r * cos(phi);\n    float t2 = r * sin(phi);\n    float s = 0.5 * (1.0 + Vh.z);\n    t2 = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;\n\n    vec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * Vh;\n\n    return normalize(vec3(ax * Nh.x, ay * Nh.y, max(0.0, Nh.z)));\n}\n\nfloat GGXVNDFPdf(float NoH, float NoV, float roughness)\n{\n \tfloat D = D_GTR(roughness, NoH, 2.);\n    float G1 = SmithG(NoV, roughness*roughness);\n    return (D * G1) / max(0.00001, 4.0f * NoV);\n}\n\n\n// ---------------------------------------------------------------------------------\n// Triplanar & bump mapping! \n// clever code taken from Shane\n// https://www.shadertoy.com/view/MscSDB\n// ---------------------------------------------------------------------------------\nvec3 tex3D( sampler2D tex, vec3 p, vec3 n )\n{\n    n = abs(n);\n    vec4 col = texture(tex, p.yz)*n.x + texture(tex, p.xz)*n.y + texture(tex, p.xy)*n.z;\n    return pow(col.rgb,vec3(2.2));\n}\nvec3 bumpMapping( sampler2D tex, vec3 p, vec3 n, float bf )\n{\n    const vec2 e = vec2(0.001, 0);\n    \n    mat3 m = mat3( tex3D(tex, p - e.xyy, n).rgb,\n                   tex3D(tex, p - e.yxy, n).rgb,\n                   tex3D(tex, p - e.yyx, n).rgb);\n    \n    vec3 g = vec3(0.299, 0.587, 0.114) * m;\n    g = (g - dot( tex3D(tex,  p , n).rgb, vec3(0.299, 0.587, 0.114)) )/e.x;\n    g -= n * dot(n, g);\n                      \n    return normalize( n + g*bf );\n    \n}\n\n\n\n// ---------------------------------------------\n// Data IO\n// ---------------------------------------------\nstruct Data {\n    float theta;\n    float phi;\n    float r;\n    \n    vec3 ro;\n    vec3 ta;\n    \n    vec3 oldRo;\n    vec3 oldTa;\n    \n    vec4 oldMouse;\n    \n    float refreshTime;\n};\n\nfloat readData1(sampler2D tex, int id) {\n    return texelFetch(tex, ivec2(id,0), 0).r;\n}\nvec3 readData3(sampler2D tex, int id) {\n    return texelFetch(tex, ivec2(id,0), 0).rgb;\n}\nvec4 readData4(sampler2D tex, int id) {\n    return texelFetch(tex, ivec2(id,0), 0);\n}\nvec4 writeData(vec4 col, vec2 fragCoord, int id, float value) {\n    if (floor(fragCoord.x) == float(id))\n        col.r = value;\n        \n    return col;\n}\nvec4 writeData(vec4 col, vec2 fragCoord, int id, vec3 value) {\n    if (floor(fragCoord.x) == float(id))\n        col.rgb = value.rgb;\n        \n    return col;\n}\nvec4 writeData(vec4 col, vec2 fragCoord, int id, vec4 value) {\n    if (floor(fragCoord.x) == float(id))\n        col = value;\n        \n    return col;\n}\nData initData() {\n\tData data;\n    \n    data.theta = -.5;\n    data.phi = .6;\n    data.r = 3.;\n    \n    data.ro = normalize(vec3(cos(data.theta), data.phi, sin(data.theta)))*data.r;\n    data.ta = vec3(0.,0.35,.5);\n    \n    data.oldRo = data.ro;\n    data.oldTa = data.ta;\n    \n    data.oldMouse = vec4(0.);\n    \n    data.refreshTime = 0.;\n    \n    return data;\n}\nData readData(sampler2D tex, vec2 invRes) {\n\tData data;\n    \n    data.theta = readData1(tex, 0);\n    data.phi = readData1(tex, 1);\n    data.r = readData1(tex, 2);\n    \n    data.ro = readData3(tex, 3);\n    data.ta = readData3(tex, 4);\n    \n    data.oldRo = readData3(tex, 5);\n    data.oldTa = readData3(tex, 6);\n    \n    data.oldMouse = readData4(tex, 7);\n    data.refreshTime = readData1(tex, 8);\n    \n    return data;\n}\nvec4 writeData(vec4 col, vec2 fragCoord, Data data) {\n    col = writeData(col, fragCoord.xy, 0, data.theta);\n    col = writeData(col, fragCoord.xy, 1, data.phi);\n    col = writeData(col, fragCoord.xy, 2, data.r);\n    col = writeData(col, fragCoord.xy, 3, data.ro);\n    col = writeData(col, fragCoord.xy, 4, data.ta);\n    col = writeData(col, fragCoord.xy, 5, data.oldRo);\n    col = writeData(col, fragCoord.xy, 6, data.oldTa);\n    col = writeData(col, fragCoord.xy, 7, data.oldMouse);\n    col = writeData(col, fragCoord.xy, 8, data.refreshTime);\n    return col;\n}\n\n\n\n\n\n\n\n\n\n// ---------------------------------------------\n// Distance field \n// ---------------------------------------------\nfloat box( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\nfloat teapot(vec3 p) {\n    p.y -= .02;\n    float scale = 1.2;\n    p *= scale;\n    \n    // body\n    float body;\n    {\n        body = length(p-vec3(0.,.5,0.))-.5+smoothstep(0.1,.8,p.y)*.5;// - smoothstep(0.,.02, p.y)*.01;\n    }\n    \n    //nose\n    float nose;\n    {\n        nose = length(p.xz-vec2(0.0,0.1+smoothstep(0.,.45,p.y)*.45))-.04;\n        nose = max(nose, -p.y+.15);\n    } \n    \n    //grip\n    float grip;\n    {\n        vec2 pos = vec2(-.35,.34);\n        grip = length(p.zy-pos)-.12;\n        grip = smax(grip, -(length(p.zy-pos)-.1), .005);\n        grip = smax(grip, abs(p.x)-.03, .05);\n    } \n    \n    //lid\n    float lid;\n    {\n        vec3 r= vec3(.2,.025,.2);\n        vec3 pp = p - vec3(0.,.51,0.);\n        float k0 = length(pp/r);\n        float k1 = length(pp/(r*r));\n        lid = k0*(k0-1.0)/k1;\n        lid = smin(lid, length(pp-vec3(0.,.05,0.))-.03, 0.01);\n    }\n    \n    float d = smin(body, nose, .1);\n    d = smin(d, grip, .05);\n    d = abs(d)-0.005;\n    d = max(d, p.y-.5);    \n    d = max(d, min(p.z-.3,p.y-.4));\n    d = min(d, lid);\n    \n    \n    return d/scale*.65;\n}\nfloat teapot2(vec3 p) {\n    float s = .4;\n    p -= vec3(.3,-.05,1.5);\n    p.xz = rot(-2.3)*p.xz;\n    return teapot(p*s)/s;\n}\n\nfloat bowl(vec3 p) {\n    p.y -= .42;\n    float d = length(p)-.45;\n    d = abs(d)-.025;\n    d = smax(d, p.y, .05);\n    \n    float grip;\n    {\n        vec2 pos = vec2(-.45,-.18);\n        grip = length(p.zy-pos)-.15;\n        grip = smax(grip, -(length(p.zy-pos)-.1), .05);\n        grip = smax(grip, abs(p.x)-.03, .05);\n        grip = max(grip, -(length(p)-.45));\n    } \n    d = smin(d, grip, .05);\n    d = smax(d, -p.y-.5, .2);\n    return d;\n\n}\n\nfloat tea(vec3 p) {\n    p.y -= .43;\n    float d = length(p)-.4;\n    d = max(d, p.y+.1);\n    d = smax(d, -p.y-.5, .2);\n    return d;\n}\n\n\nfloat boxLight(vec3 p) {\n    return box(p-vec3(-5.,1.,0.), vec3(.5,.5,2.));\n}\n\n\nfloat map(vec3 p) {\n\n    float d = p.y;\n    d = min(d, teapot2(p));\n    d = min(d, min(bowl(p), tea(p)));\n    d = min(d, boxLight(p));\n    \n    return d;\n}\n\n\n\n\n\n\n\n\n\n// ---------------------------------------------\n// Ray tracing \n// ---------------------------------------------\nfloat trace(vec3 ro, vec3 rd, vec2 nf) {\n    float t = nf.x;\n    float s = sign(map(ro));\n    for(int i=0; i<256; i++) {\n        float d = map(ro+rd*t) * s;\n        if (t > nf.y || abs(d)<0.001) break;\n        t += d;\n    }\n    \n    return t;\n}\n\nvec3 normal(vec3 p, float t) {\n    vec2 eps = vec2(0.0001,0.0);\n    float d = map(p);\n    vec3 n;\n    n.x = d - map(p - eps.xyy);\n    n.y = d - map(p - eps.yxy);\n    n.z = d - map(p - eps.yyx);\n    n = normalize(n);\n    return n;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ---------------------------------------------\n// Raw Frame\n// ---------------------------------------------\n\n\n// ---------------------------------------------\n// Material\n// ---------------------------------------------\nstruct Material {\n    vec3 albedo;\n    float metallic;\n    float roughness;\n    vec3 emissive;\n    \n    float specTrans;\n    float ior;\n    float absorption;\n};\nMaterial newMaterial() {\n    Material mat;\n    mat.albedo = vec3(1.);\n    mat.metallic = 0.;\n    mat.roughness = .0;\n    mat.emissive = vec3(0.);\n    mat.specTrans = 0.;\n    mat.ior = 1.33;\n    mat.absorption = 1.;\n    \n    return mat;\n}\nMaterial getMaterial(vec3 p, inout vec3 n) {\n    \n    Material mat = newMaterial();\n        \n    \n    float d = map(p);\n    if (d == bowl(p)) { // Bowl\n        mat.metallic = 0.0;\n        mat.albedo = vec3(1.);\n        mat.specTrans = 1.;\n        mat.absorption = 0.;\n        mat.roughness = .1;\n        mat.ior = 1.5;\n    } else if (d == teapot2(p)) { // Teapot\n        mat.metallic = 0.0;\n        mat.albedo = vec3(1.);\n        mat.specTrans = 0.;\n        mat.absorption = 0.;\n        mat.roughness = .1;\n        mat.ior = 1.5;\n    } else if (d == tea(p)) { // Tea\n        mat.metallic = 0.0;\n        mat.albedo = vec3(0.,-1.,-2.);\n        mat.specTrans = 1.;\n        mat.absorption = 5.;\n        mat.roughness = .05;\n        mat.ior = 1.33;\n    } else if (d == boxLight(p)) { // Area light\n        mat.emissive = vec3(3.0);\n    } else { // Ground\n        mat.metallic = 1.;\n        mat.specTrans = 0.;\n        mat.albedo = texture(iChannel2,p.zx).rgb;\n        n = bumpMapping(iChannel2, p.zyx,n, 0.01);\n        mat.roughness = luma(mat.albedo);\n    }\n    \n    return mat;\n}\n\n// ---------------------------------------------\n// State\n// ---------------------------------------------\nstruct State {\n    bool isRefracted;\n    bool hasBeenRefracted;\n    float lastIOR;\n};\n\nState initState() {\n    State s;\n    s.hasBeenRefracted = false;\n    s.isRefracted = false;\n    s.lastIOR = 1.;\n    \n    return s;\n}\n\n\n// ---------------------------------------------\n// BSDF\n// ---------------------------------------------\nvec3 evalDisneyDiffuse(Material mat, float NoL, float NoV, float LoH, float roughness) {\n    float FD90 = 0.5 + 2. * roughness * pow(LoH,2.);\n    float a = F_Schlick(1.,FD90, NoL);\n    float b = F_Schlick(1.,FD90, NoV);\n    \n    return mat.albedo * (a * b / PI);\n}\n\nvec3 evalDisneySpecularReflection(Material mat, vec3 F, float NoH, float NoV, float NoL) {\n    float roughness = pow(mat.roughness, 2.);\n    float D = D_GTR(roughness, NoH,2.);\n    float G = GeometryTerm(NoL, NoV, pow(0.5+mat.roughness*.5,2.));\n\n    vec3 spec = D*F*G / (4. * NoL * NoV);\n    \n    return spec;\n}\n\nvec3 evalDisneySpecularRefraction(Material mat, float F, float NoH, float NoV, float NoL, float VoH, float LoH, float eta, out float pdf) {\n    float roughness = pow(mat.roughness, 2.);\n    float D = D_GTR(roughness, NoH, 2.);\n    float G = GeometryTerm(NoL, NoV, pow(0.5+mat.roughness*.5, 2.));\n    float denom = pow(LoH + VoH*eta, 2.);\n\n    float jacobian = abs(LoH) / denom;\n    pdf = SmithG(abs(NoL), roughness*roughness) * max(0.0, VoH) * D * jacobian / NoV;\n    \n    vec3 spec = pow(1.-mat.albedo, vec3(0.5))  * D * (1.-F) * G * abs(VoH) * jacobian * pow(eta, 2.) / abs(NoL * NoV);\n    return spec;\n}\n\nvec4 sampleDisneyBSDF(vec3 v, vec3 n, in Material mat, out vec3 l, inout State state) {\n    state.hasBeenRefracted = state.isRefracted;\n    \n    float roughness = pow(mat.roughness, 2.);\n\n    // sample microfacet normal\n    vec3 t,b;\n    basis(n,t,b);\n    vec3 V = toLocal(t,b,n,v);\n    vec3 h = SampleGGXVNDF(V, roughness,roughness, frand(), frand());\n    if (h.z < 0.0)\n        h = -h;\n    h = toWorld(t,b,n,h);\n\n    // fresnel\n    float VoH = dot(v,h);\n    vec3 f0 = mix(vec3(0.04), mat.albedo, mat.metallic);\n    vec3 F = F_Schlick(f0, VoH);\n    float dielF = Fresnel(state.lastIOR, mat.ior, abs(VoH), 0., 1.);\n    \n    // lobe weight probability\n    float diffW = (1.-mat.metallic) * (1.-mat.specTrans);\n    float reflectW = luma(F);\n    float refractW = (1.-mat.metallic) * (mat.specTrans) * (1.-dielF);\n    float invW = 1./(diffW + reflectW + refractW);\n    diffW *= invW;\n    reflectW *= invW;\n    refractW *= invW;\n    \n    // cdf\n    float cdf[3];\n    cdf[0] = diffW;\n    cdf[1] = cdf[0] + reflectW;\n    //cdf[2] = cdf[1] + refractW;\n    \n    \n    vec4 bsdf = vec4(0.);\n    float rnd = frand();\n    if (rnd < cdf[0]) // diffuse\n    {\n        l = cosineSampleHemisphere(n);\n        h = normalize(l+v);\n        \n        float NoL = dot(n,l);\n        float NoV = dot(n,v);\n        if ( NoL <= 0. || NoV <= 0. ) { return vec4(0.); }\n        float LoH = dot(l,h);\n        float pdf = NoL/PI;\n        \n        vec3 diff = evalDisneyDiffuse(mat, NoL, NoV, LoH, roughness) * (1.-F);\n        bsdf.rgb = diff;\n        bsdf.a = diffW * pdf;\n    } \n    else if(rnd < cdf[1]) // reflection\n    {\n        l = reflect(-v,h);\n        \n        float NoL = dot(n,l);\n        float NoV = dot(n,v);\n        if ( NoL <= 0. || NoV <= 0. ) { return vec4(0.); }\n        float NoH = min(0.99,dot(n,h));\n        float pdf = GGXVNDFPdf(NoH, NoV, roughness);\n        \n        vec3 spec = evalDisneySpecularReflection(mat, F, NoH, NoV, NoL);\n        bsdf.rgb = spec;\n        bsdf.a = reflectW * pdf;\n    }\n    else // refraction\n    {\n        state.isRefracted = !state.isRefracted;\n        float eta = state.lastIOR/mat.ior;\n        l = refract(-v,h, eta);\n        state.lastIOR = mat.ior;\n        \n        float NoL = dot(n,l);\n        if ( NoL <= 0. ) { return vec4(0.); }\n        float NoV = dot(n,v);\n        float NoH = min(0.99,dot(n,h));\n        float LoH = dot(l,h);\n        \n        float pdf;\n        vec3 spec = evalDisneySpecularRefraction(mat, dielF, NoH, NoV, NoL, VoH, LoH, eta, pdf);\n        \n        bsdf.rgb = spec;\n        bsdf.a = refractW* pdf;\n    }\n    \n    bsdf.rgb *= abs(dot(n,l));\n\n    return bsdf;\n}\n\n\n// ---------------------------------------------\n// Pathtrace\n// ---------------------------------------------\nvec4 pathtrace(vec3 ro, vec3 rd) {\n    \n    State state = initState();\n    float firstDepth = 0.;\n    vec3 acc = vec3(0.);\n    vec3 abso = vec3(1.);\n    \n    for(int i=0; i<8; i++) {\n        // raytrace\n        float t = trace(ro,rd, vec2(0.01, 1000.));\n        vec3 p = ro + rd * t;\n        if (i == 0) firstDepth = t;\n        \n        // sky intersection ?\n        if (t >= 1000.) {\n            //acc += skyColor(rd, sundir) * abso;\n            acc += pow(texture(iChannel3, rd).rgb, vec3(2.2)) * abso;\n            break;\n        }\n        \n        // info at intersection point\n        vec3 n = normal(p, t);\n        if (state.isRefracted) n = -n;\n        Material mat = getMaterial(p,n);\n        \n        // sample BSDF\n        vec3 outDir;\n        vec4 bsdf = sampleDisneyBSDF(-rd,n, mat, outDir, state);\n        \n        // add emissive part of the current material\n        acc += mat.emissive * abso;\n            \n        // bsdf absorption (pdf are in bsdf.a)\n        if ( bsdf.a > 0.)\n            abso *= bsdf.rgb / bsdf.a;\n        \n        // medium absorption\n        if (state.hasBeenRefracted) {\n            abso *= exp(-t * ((vec3(1.)-mat.albedo)*mat.absorption));\n        }\n        \n        // next direction\n        ro = p;\n        rd = outDir;\n        if (state.isRefracted ) {\n            ro += -n*0.01;\n        } else if (state.hasBeenRefracted && !state.isRefracted) {\n            ro += -n*0.01;\n            state.lastIOR = 1.;\n        } else {\n            ro += n*0.01;\n        }\n        \n        // random early exit taking account energy loss\n        #if 1\n        {\n            float q = max(abso.r, max(abso.g, abso.b));\n            if (frand() > q)\n                break;\n\n            abso /= q;\n        }\n        #endif\n        \n    }\n\n    return vec4(acc, firstDepth);\n}\n\n\n// ---------------------------------------------\n// Entrypoint\n// ---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 invRes = vec2(1.) / iResolution.xy;\n    srand(ivec2(fragCoord), iFrame);\n    \n    // read data\n    Data data = readData(iChannel0, invRes);\n    if (iFrame == 0) data = initData();\n    \n    // setup ray\n    vec2 uv = (fragCoord + frand2()-.5) * invRes;\n    vec3 ro = data.ro;\n    vec2 v = uv*2.-1.;\n    v.x *= iResolution.x * invRes.y;\n    \n    // setup camera\n    const vec3 up = vec3(0.,1.,0.);\n    vec3 fw = normalize(data.ta-data.ro);\n    vec3 uu = normalize(cross(fw, up));\n    vec3 vv = normalize(cross(uu, fw));\n    vec3 er = normalize(vec3(v,FOCAL_LENGTH));\n    vec3 rd = uu * er.x + vv * er.y + fw * er.z;\n    \n    // depth of field with autofocus\n    #if 1\n    float focusDistance = trace(ro,  fw, vec2(0.01, 100.));\n    vec3 focalPoint = ro + rd * focusDistance;\n    \n    float blurAmount = 0.015;\n    vec3 go = blurAmount*vec3( normalize(frand2()*2.-1.)*sqrt(frand()), 0.0 );\n    ro += go.x*uu + go.y*vv;\n    \n    rd = normalize(focalPoint - ro);\n    #endif\n    \n    \n    // pathtrace\n    vec4 col = pathtrace(ro, rd);\n    \n    fragColor = vec4(min(col.rgb,vec3(10.)), col.a > 1000. ? -1. : col.a);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------\n// - Camera/data IO + Frames accumulation\n//\n//\n// MODE 0 - Raw frame\n// MODE 1 - Accumulate frames\n// MODE 2 - Temporal reprojection\n// ---------------------------------------------\n#define MODE 1\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 seed = hash3(vec3(fragCoord.xy, float((iFrame+1) % 10000)));\n    vec2 invRes = vec2(1.) / iResolution.xy;\n    vec2 uv = (fragCoord + seed.xy-.5) * invRes;\n    \n    // read input buffer\n    vec2 rawUv = fragCoord*invRes;\n    vec4 rawCol = texture(iChannel1, rawUv);\n    vec4 col = rawCol;\n    \n    // read data\n    bool needRefresh = false;\n    Data data = readData(iChannel0, invRes);\n    if (iFrame == 0) data = initData();\n    \n    // camera\n    if (iMouse.zw == data.oldMouse.zw) {\n        data.theta += (data.oldMouse.x - iMouse.x)  * CAMERA_SENSITIVTY;\n        data.phi += (data.oldMouse.y - iMouse.y)  * CAMERA_SENSITIVTY;\n        if (texelFetch( iChannel2, ivec2(87,0), 0 ).x > 0.) { // w\n            data.r *= 1.-CAMERA_SENSITIVTY;\n            needRefresh = true;\n        }\n        if (texelFetch( iChannel2, ivec2(83,0), 0 ).x > 0.) { // s\n            data.r *= 1.+CAMERA_SENSITIVTY;\n            needRefresh = true;\n        }\n        if (texelFetch( iChannel2, ivec2(32,0), 0 ).x > 0.) { // space\n            needRefresh = true;\n        }\n        if (iMouse.z > .5)\n            needRefresh = true;\n    }\n    data.phi = clamp(data.phi, 0.01, 3.);\n    \n    data.ro = normalize(vec3(cos(data.theta), data.phi, sin(data.theta)))*data.r;\n    \n    \n    // MODE 1 - accumulate frame\n    #if MODE == 1\n    vec4 lastCol = texture(iChannel0, fragCoord*invRes);\n    if (!needRefresh) {\n        float w = 1. / (float(iFrame)-data.refreshTime + 1.);\n        col = lastCol*(1.-w) + col * w;\n    }\n    else {\n        data.refreshTime = float(iFrame);\n    }\n    #endif\n    \n    // MODE 2 - temporal reprojection\n    #if MODE == 2\n    if (col.a > 0.) {\n        // reconstruct world space position\n        vec3 ro = data.ro;\n        vec2 v = uv*2.-1.;\n        v.x *= iResolution.x * invRes.y;\n        vec3 rd = lookat(data.ro, data.ta) * normalize(vec3(v,FOCAL_LENGTH));\n        float t = rawCol.a;\n        vec3 p = ro + rd * t;\n        \n        // reprojection\n        mat3 oldCam = lookat(data.oldRo, data.oldTa);\n        mat3x4 invOldCam = mat3x4( vec4( oldCam[0], -dot(oldCam[0],data.oldRo) ),\n                                   vec4( oldCam[1], -dot(oldCam[1],data.oldRo) ),\n                                   vec4( oldCam[2], -dot(oldCam[2],data.oldRo) ));\n        vec4 wpos = vec4(p,1.0);\n        vec3 cpos = wpos*invOldCam;\n        vec2 npos = FOCAL_LENGTH*cpos.xy/cpos.z;\n        vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y/iResolution.x,1.0) - (seed.xy-.5)*invRes;\n        vec2 rpos = spos * iResolution.xy;\n        vec4 lastCol = texture(iChannel0, spos);\n\n        float w = .0;\n        vec3 oldRd = lookat(data.oldRo, data.oldTa) * normalize(vec3(v,FOCAL_LENGTH));\n        vec3 oldwp = data.oldRo + oldRd * lastCol.w;\n\n        // depth rejection\n        for(int x=-1; x<=1; x++){\n            for(int y=-1; y<=1; y++){\n                float lastT = texture(iChannel0, spos + vec2(x, y) * invRes).a;\n                w = max(w, smoothstep(t*t*.005,0.,abs(t-lastT)));\n            }\n        }\n        w -= 0.01;\n        \n        // color clamping\n        #if 1\n        const int kernelSize = 2;\n        vec3 minCol = vec3(99999.);\n        vec3 maxCol = vec3(0.);\n        for(int x=-kernelSize; x<=kernelSize; x++){\n            for(int y=-kernelSize; y<=kernelSize; y++){\n                vec4 c = texture(iChannel1, spos + vec2(x, y) * invRes);\n                c.rgb = RGBToYCoCg(c.rgb);\n                minCol = min(minCol, c.rgb);\n                maxCol = max(maxCol, c.rgb);\n            }\n        }\n        lastCol.rgb = RGBToYCoCg(lastCol.rgb);\n        lastCol.rgb = clamp(lastCol.rgb, minCol, maxCol);\n        lastCol.rgb = YCoCgToRGB(lastCol.rgb);\n        #endif\n\n        //w = 0.99;\n        if (rpos.x < 7. && rpos.y < 1.) w = 0.;\n        if (abs(spos.x-.5) > .5) w = 0.;\n        if (abs(spos.y-.5) > .5) w = 0.;\n        \n        if (iFrame > 1)\n            col = mix(col, lastCol, saturate(w));\n    }\n    #endif\n   \n    \n    // write data\n    data.oldRo = data.ro;\n    data.oldTa = data.oldTa;\n    data.oldMouse = iMouse;\n    if (fragCoord.y < 1.)\n    col = writeData(col, fragCoord, data);\n    \n    // output pixel color\n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}