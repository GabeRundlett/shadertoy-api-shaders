{
    "Shader": {
        "info": {
            "date": "1695274069",
            "description": "15k particles behaving like rigid bodies. The stability depends on a technique inspired by the \"shock propagation\" idea of Professor Kenny Erleben.\n\n*shift to render velocities*\n*alt to render local wall velocity field*\n*space to reset*",
            "flags": 48,
            "hasliked": 0,
            "id": "ds3cDn",
            "likes": 48,
            "name": "Shock Propagation ala Erleben",
            "published": 3,
            "tags": [
                "2d",
                "voronoi",
                "collision",
                "simulation",
                "particles",
                "dynamics",
                "tracking",
                "physics"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 496
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Inspired by Kenny Erleben's 2007 paper \"Velocity-Based Shock Propagation for Multibody\n//  Dynamics Animation\"\n//\n//      https://dl.acm.org/doi/10.1145/1243980.1243986\n//\n//  This is definitely only inspired by the original shock propagation idea. As described\n//  in the paper, the way I understand it, it would fit into an traditional iterative\n//  solver, freezing objects sequentially as you get farther from a boundary. But to use\n//  this idea in a shader, I have to manage with a single iteration.\n//\n//  So, the way it works is that each particle keeps track of a \"shock direction\" that\n//  tells it the direction to the nearest wall. Green is to the right, blue to the left,\n//  and red is supported from below. The shock direction is seeded from the walls and\n//  diffuses through the particles. Particles resist collision impules and position\n//  correction against their shock direction. That's where the stability comes from:\n//  particles \"below\" other particles are heavier. When particles get compressed in\n//  an area, they are able to flow along the shock directions to a clear space.\n//\n//  I claim this is at least conceptually similar to the original shock propagation idea.\n//  In both cases, we're giving solver priority to objects closer to the ground. Maybe\n//  there's a better name for this method, but until I find one I'll keep comparing it to\n//  Erleben's shock propagation. :) I've used a more primitive method for stability in\n//  some shaders already, like\n//\n//      Candy Avalanche                https://shadertoy.com/view/dlfSz4\n//\n//  In that shader, solver priority is determined entirely by particle height. This works\n//  for that application, but it creates artifacts when you try to use it for a bunch of\n//  particles resting in a container with walls on all sides; the particles can end up\n//  pushing each other up the walls. With the shock directions, the particles near the\n//  side walls can resist motions towards the walls instead of only downwards. The\n//  smoothness of the shock direction field can then prevent artifacts.\n//\n//  An additional hack is needed to handle the moving boundary. The \"local wall velocity\"\n//  is also seeded at wall collisions and diffused through the particles. This prevents\n//  us from relying on collisions only to move around the particles in the bucket and in\n//  front of the bulldozer wall. Hold down the alt key to see the wall velocities.\n//\n//      *shift to render velocities*\n//      *alt to render local wall velocity field*\n//      *space to reset*\n//\n//  Buffer A, B, and C perform particle simulation. Only A updates the particle neighbors.\n//  Buffer D computes screen-space voronoi for render.\n//\n// ---------------------------------------------------------------------------------------\n\nvoid renderParticle(fxParticle v, vec2 p, uint id, inout vec4 O)\n{\n    float e = 2. / R.y;\n    float d = fxLinePointDist(v.pos, v.pos - v.vel, p);\n    \n    vec3 color = v.sd == vec2(0) ? vec3(1, 0, 0) : sin(atan(abs(v.sd.y * .1), v.sd.x) + vec3(0, 11, 33));\n    color *= (id % 2U == 0U) ? .7 : 1.;\n    color = mix(color, vec3(1), .3);\n    if (keyDown(KEY_ALT))\n        color = 5000. * length(v.wv) * sin(atan(v.wv.y, abs(v.wv.x)) + vec3(0, 11, 33));\n    if (keyDown(KEY_SHIFT))\n        color = pow(abs(v.vel.yxx) * 1e3, vec3(.3));\n    O.xyz = mix(O.rgb, color, smoothstep(PARTICLE_SIZE + e, PARTICLE_SIZE - e, d));\n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    computeMaxParticles();\n    vec2 p = (u - .5 * R.xy) / R.y;\n    uvec4 old = fxGetClosest(ivec2(u));\n    fxState s = fxGetState();\n    O = vec4(.2);\n\n    // render particles\n    for (int i = 0; i < 4; ++i)\n    {\n        uint id = old[i];\n        if (id == -1U || id >= g_MaxParticles) break;\n        fxParticle v = fxGetParticle(id);\n        renderParticle(v, p, id, O);\n    }\n    \n    float d = sdScene(p, R, s.t);\n    \n    O = mix(O, vec4(1), smoothstep(0., -1. / R.y, d));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tParticle simulation\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 O, vec2 fragCoord )\n{\n    uvec2 ufc = uvec2(fragCoord);\n    \n    computeMaxParticles();\n    uint index = ufc.x + ufc.y * uint(R.x); // \"1D array\" index\n    uint id = index / NUM_PARTICLE_DATA_TYPES; // which particle\n    uint dataType = index - id * NUM_PARTICLE_DATA_TYPES; // which field of particle structure\n    if (id >= g_MaxParticles) return;\n    \n    fxParticle p = fxGetParticle(id);\n    fxState s = fxGetState();\n    \n    if (dataType >= POS)\n        O = updateParticle(s, p, id, dataType, 0.);\n    else\n        O = voronoiParticle(p, id, dataType);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tParticle simulation\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 O, vec2 fragCoord )\n{\n    uvec2 ufc = uvec2(fragCoord);\n    \n    computeMaxParticles();\n    uint index = ufc.x + ufc.y * uint(R.x); // \"1D array\" index\n    uint id = index / NUM_PARTICLE_DATA_TYPES; // which particle\n    uint dataType = index - id * NUM_PARTICLE_DATA_TYPES; // which field of particle structure\n    if (id >= g_MaxParticles) return;\n    \n    fxParticle p = fxGetParticle(id);\n    fxState s = fxGetState();\n    \n    if (dataType >= POS)\n        O = updateParticle(s, p, id, dataType, DT / 3.);\n    else\n        O = fxSaveParticle(p, dataType); // skip voronoi update on buffers B and C (only one is needed)\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const uint IDEAL_MAX_PARTICLES = 15000U;\nconst float PARTICLE_SIZE = .003;\nconst float PI = 3.141592653589793;\nconst float DT = .0002; // bucket animation increment (t cycles from 0 to 1)\n\n// If not applied carefully, the shock direction can create the a situation where\n// the particles get shoved towards the center of a container. This hack biases\n// the shock direction towards vertical, ensuring we get smaller green and blue\n// areas and more red, and preventing particles from being shoved towards the center.\nconst vec2 SHOCK_BIAS = vec2(1, 1.1);\n\n#define R iResolution.xy\n\n// PERSISTENT STATE\n\nstruct fxState\n{\n    float res;  // tracks resolution changes\n    float t;    // animation time\n};\n\n#define fxGetState() fxGetStateImpl(iChannel1)\nfxState fxGetStateImpl(sampler2D sampler)\n{\n    vec4 data = texelFetch(sampler, ivec2(0), 0);\n    \n    fxState s;\n    s.res = data.x;\n    s.t = data.y;\n    \n    return s;\n}\n\nvec4 fxPutState(fxState s)\n{\n    return vec4(s.res, s.t, 0, 0);\n}\n\nbool fxIsStatePixel(vec2 u)\n{\n    return ivec2(u) == ivec2(0);\n}\n\n//returns the ids of the four closest particles from the input\n#define fxGetClosest(X) fxGetClosestImpl(iChannel1, X)\nuvec4 fxGetClosestImpl(sampler2D sampler, ivec2 xy)\n{\n    return floatBitsToUint(texelFetch(sampler, xy, 0));\n}\n\n// PARTICLE STRUCTURE\n\n#define UL_NEIGHBORS 0U\n#define UR_NEIGHBORS 1U\n#define LL_NEIGHBORS 2U\n#define LR_NEIGHBORS 3U\n#define POS 4U\n#define SDAV 5U\n#define NUM_PARTICLE_DATA_TYPES 6U\n\nuint g_MaxParticles = 0U;\n\n// must be called in each buffer before g_MaxParticles is correct\n#define computeMaxParticles() computeMaxParticlesImpl(R)\nvoid computeMaxParticlesImpl(vec2 res)\n{\n    g_MaxParticles = min(IDEAL_MAX_PARTICLES, uint(res.x * res.y) / NUM_PARTICLE_DATA_TYPES);\n}\n\n//returns the location of the particle within the particle buffer corresponding with the input id \n#define fxLocFromID(X, Y) fxLocFromIDImpl(int(R.x), X, Y)\nivec2 fxLocFromIDImpl(uint width, uint id, uint dataType)\n{\n    uint index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\nstruct fxParticle\n{\n    vec2 pos;     // position\n    vec2 vel;     // velocity\n    vec2 sd;      // shock direction\n    vec2 wv;      // local wall velocity\n    \n    uvec4 nbs[4]; // neighbors\n};\n\n//get the particle corresponding to the input id\n#define fxGetParticle(X) fxGetParticleImpl(iChannel0, uint(R.x), X)\nfxParticle fxGetParticleImpl(sampler2D sampler, uint resolutionWidth, uint id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, POS), 0);\n    vec4 particleData5 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, SDAV), 0);\n\n    fxParticle particle;\n    particle.nbs[0] = floatBitsToUint(particleData0);\n    particle.nbs[1] = floatBitsToUint(particleData1);\n    particle.nbs[2] = floatBitsToUint(particleData2);\n    particle.nbs[3] = floatBitsToUint(particleData3);\n    particle.pos = particleData4.xy;\n    particle.vel = particleData4.zw;\n    particle.sd = particleData5.xy;\n    particle.wv = particleData5.zw;\n    \n    return particle;\n}\n\nvec4 fxSaveParticle(fxParticle p, uint dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[0]);\n    case UR_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[1]);\n    case LL_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[2]);\n    case LR_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[3]);\n    case POS:  \n        return vec4(p.pos, p.vel);\n    case SDAV:  \n        return vec4(p.sd, p.wv);\n    }\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataImpl(iChannel0, uint(R.x), X, Y)\nvec4 fxGetParticleDataImpl(sampler2D sampler, uint resolutionWidth, uint id, uint dataType)\n{\n    return texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, dataType), 0);\n}\n\n// UTILITIES\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_ALT 18\n#define KEY_SPACE 32\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat length2(vec2 v) { return dot(v, v); }\nfloat sqr(float x) { return x * x; }\n\nfloat fxLinePointDist(vec2 a, vec2 b, vec2 p)\n{\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);// proj coord on line\n    return sqrt(length2(p - b * h)); // squared dist to segment\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb )\n{\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\nmat2 rot2(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, sc.x, -sc.x, sc.y);\n}\n\n// insert new particle at distance d_ with index i_ into i, d arrays, sorting by d\nvoid insertionSort(inout uvec4 i, inout vec4 d, uint i_, float d_)\n{\t\n    if(any(equal(uvec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = uvec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = uvec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = uvec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = uvec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\n// SCENE FUNCTIONS\n\n// the animation of the buckets\nvec2 path(float t)\n{\n    // piecewise, linear for beginning and end\n    if (t < .25) return vec2(.5, -3. * t + .65);\n    if (t > .5) return vec2(1.6 - 3. * t, -.4);\n    \n    // bezier to turn the corner smoothly\n    t *= 4.;\n    t -= 1.;\n    vec2 a = vec2(.5, t * -.2 - .1);\n    vec2 b = vec2(.5 - .4 * t, -.4);\n    return mix(a, b, t);\n}\n\n// signed distance field of one bucket\nfloat sdBucket(vec2 p, float t)\n{\n    vec2 cp = path(t); // bucket location\n    \n    float r = max(0., t - .35); // rotation angle\n    r = -4. * sqrt(r);\n    \n    const float theta = 2.0;\n    const vec2 sc = vec2(sin(theta), cos(theta));\n    return sdArc((p * vec2(1, -1) - cp) * rot2(r), sc, 0.2, 0.01);\n}\n\nconst float BULLDOZER_HEIGHT = .25;\n\n// scene (walls) signed distance field, for rendering and collision\nfloat sdScene(vec2 p, vec2 res, float t)\n{\n    // walls and floor\n    float d = p.x + .5 * res.x / res.y;\n    d = min(d, .5 * res.x / res.y - p.x);\n    d = min(d, p.y + .5);\n    \n    // square leaky bucket\n    d = min(d, sdBox(p - vec2(-.75, -.05), vec2(.01,  .1 )));\n    d = min(d, sdBox(p - vec2(-.45, -.05), vec2(.01,  .1 )));\n    d = min(d, sdBox(p - vec2(-.685, -.15), vec2(.075, .01)));\n    d = min(d, sdBox(p - vec2(-.515, -.15), vec2(.075, .01)));\n    \n    // slanted walls\n    d = min(d, sdBox((p - vec2(-.28,  .03)) * rot2(-.8), vec2(.2, .01)));\n    d = min(d, sdBox((p - vec2( .05, -.05)) * rot2(.8), vec2(.2, .01)));\n    \n    // moving buckets\n    float t2 = fract(t + .5);\n    d = min(d, min(sdBucket(p, t), sdBucket(p, t2)));\n    \n    // bulldozer walls\n    float t3 = fract(t + .9);\n    float t4 = fract(t + .4);\n    d = min(d, sdBox(p - vec2(-1. + t3 * 1.8, min(-.5, 1.05 - 2. * t3)), vec2(.01, BULLDOZER_HEIGHT)));\n    d = min(d, sdBox(p - vec2(-1. + t4 * 1.8, min(-.5, 1.05 - 2. * t4)), vec2(.01, BULLDOZER_HEIGHT)));\n \n    return d;\n}\n\n// the outward normal of the scene at a point\nvec2 normScene( vec2 p, vec2 res, float t )\n{\n\tconst vec2 d = vec2(.001, 0);\n    \n   \tfloat x1 = sdScene(p + d.xy, res, t); \n    float x0 = sdScene(p - d.xy, res, t); \n    float dx = x1 - x0;\n    \n    float y1 = sdScene(p + d.yx, res, t); \n    float y0 = sdScene(p - d.yx, res, t); \n    float dy = y1 - y0;\n    \n\treturn normalize(vec2(dx, dy));\n}\n\n// the velocity of the scene at a point\nvec2 velScene(vec2 p, float t)\n{\n    // bucket 1\n    if (sdBucket(p, t) < .01)\n        return (path(t) - path(t + DT / 3.)) * vec2(-1, 1);\n\n    // bucket 2\n    float t2 = fract(t + .5);\n    if(sdBucket(p, t2) < .01)\n        return (path(t2) - path(t2 + DT / 3.)) * vec2(-1, 1);\n        \n    // bulldozer walls\n    float t3 = fract(t + .9);\n    float t4 = fract(t + .4);\n    if (sdBox(p - vec2(-0.995 + t3 * 1.8, -.5), vec2(.02, BULLDOZER_HEIGHT)) < 0. ||\n        sdBox(p - vec2(-0.995 + t4 * 1.8, -.5), vec2(.02, BULLDOZER_HEIGHT)) < 0.)\n        return vec2(7e-5, 0);\n        \n    return vec2(0);\n}\n\n// PARTICLE SIM\n\nconst vec2 GRAVITY = vec2(0., -.00001);\nconst float COLLISION_STIFFNESS = .3;\nconst float BOUNDARY_ELASTICITY = 1.5;\nconst float BOUNDARY_DIST = PARTICLE_SIZE;\nconst float MAX_SPEED = PARTICLE_SIZE * .5;\n\n#define updateParticle(A, B, C, D, E) updateParticleImpl(A, B, C, D, E, iFrame, R, iChannel0, iMouse)\nvec4 updateParticleImpl(fxState s, fxParticle p, uint id, uint dataType, float toff, int iFrame, vec2 res, sampler2D par, vec4 iMouse)\n{\n    if (iFrame == 0 || s.res < 0.)\n    {\n        // init particles\n        vec3 h1 = hash3((id + uvec3(iFrame)) * uvec3(3, 6, 9));\n        //h1.x = pow(h1.x, 1.3);\n        h1 -= .5;\n        h1.y = h1.y * .3 - .2;\n        h1.x *= res.x / res.y;\n\n        p.pos = h1.xy;\n        p.vel = vec2(0);\n        p.sd = vec2(0, 1);\n        p.wv = vec2(0);\n    }\n    else\n    {\n        p.vel = p.vel + GRAVITY; // integrate velocity\n        \n        if (length(p.vel) > MAX_SPEED)\n            p.vel = normalize(p.vel) * MAX_SPEED; // clamp velocity\n\n        p.pos += p.vel; // integrate position\n        p.sd *= .5; // dissipate shock direction\n\n        vec2 imp = vec2(0); // collision impulse\n        vec2 nsd = p.sd; // new support direction\n        vec2 wv = p.wv; // wall velocity\n        float nt = 1.01; // wall velocity normalization factor (above one to create damping)\n        bool col = false; // was there a collision\n        for(int i = 0; i < 4; i++)\n        {\n            uvec4 nbs = p.nbs[i];\n            for (int j = 0; j < 4; ++j)\n            {\n                uint cid = nbs[j];\n                if(cid==id || cid == -1U || cid >= g_MaxParticles) continue;\n\n                fxParticle n = fxGetParticleImpl(par, uint(res.x), cid);\n\n                vec2 dp = p.pos - n.pos;\n                float d2 = length2(dp) + PARTICLE_SIZE * 1e-4;\n\n                if (d2 < sqr(PARTICLE_SIZE * 5.))\n                {\n                    vec2 dir = dp / sqrt(d2);\n                    \n                    nsd += n.sd; // diffuse shock direction\n                    \n                    float wv2 = length2(n.wv);\n                    if (wv2 > 1e-12)\n                    {\n                        float x = max(0., dot(n.wv / sqrt(wv2), dir) + .3);\n                        nt += x;    // normalization\n                        wv += n.wv * x;  // diffuse wall velocity\n                    }\n                    \n                    if (d2 < sqr(PARTICLE_SIZE * 2.))\n                    {\n                        col = true;\n                        \n                        // position correction (ignore if shock direction disagrees)\n                        if (dot(p.sd, dir) > -.2)\n                            p.pos = mix(p.pos, n.pos + 2. * PARTICLE_SIZE * dir, COLLISION_STIFFNESS);\n                        \n                        // collision impulse\n                        vec2 rv = n.vel - p.vel;\n                        imp += max(0., dot(rv, dir)) * dir;\n                    }\n                }\n            }\n        }\n\n        float sd2 = length2(nsd);\n        if (sd2 > 1e-9)\n            p.sd = mix(p.sd, nsd * SHOCK_BIAS / sqrt(sd2), .9); // record new shock direction\n\n        p.wv = wv / nt; // record new local wall velocity\n        \n        if (dot(p.sd, imp) < -.2) // resist impulses against the shock direction\n            imp *= .5;\n\n        p.vel += imp; // apply collision impulse\n        \n        // handle mouse input\n        if (iMouse.z > 0.)\n        {\n            vec2 m = (iMouse.xy - .5 * res) / res.y;\n            const float MOUSE_RANGE = .05;\n            if (distance(m, p.pos) < MOUSE_RANGE)\n            {\n                const float MOUSE_STRENGTH = .01;\n                p.vel += (p.pos - m) * MOUSE_STRENGTH;\n            }\n        }\n\n        // handle boundary\n        float ds = sdScene(p.pos, res, s.t + toff);\n        if (ds < BOUNDARY_DIST * 2.)\n        {\n            vec2 n = normScene(p.pos, res, s.t + toff);\n            p.sd = n; // seed shock direction\n            p.wv = velScene(p.pos, s.t + toff); // seed wall velocity\n            \n            if (ds < BOUNDARY_DIST) // collide with boundary\n            {\n                p.pos -= n * (ds - BOUNDARY_DIST);\n                p.vel -= BOUNDARY_ELASTICITY * min(0., dot(p.vel, n)) * n;\n                col = true;\n            }            \n        }\n        \n        if (col) p.pos += p.wv; // travel with local wall velocity if we collided with anything\n    }\n    \n    return fxSaveParticle(p, dataType);\n}\n\n// PARTICLE NEIGHBOR UPDATE\n\nbool iscoincidence(uvec4 bestIds, uint currentId, uint id)\n{\n    return id == -1U || id >= g_MaxParticles ||\n      \tid == currentId ||\n        any(equal(bestIds,uvec4(id)));\n}\n\nvoid sort0(sampler2D par, uint wd, inout uvec4 bestIds, inout vec4 bestDists, uint currentId, uint searchId, uint dataType, vec2 myPos)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec2 nbX = fxGetParticleDataImpl(par, wd, searchId, POS).xy; \n\n    vec2 dx = nbX - myPos;\n    uint dir = uint(2.*(atan(dx.y, dx.x)+PI)/PI); \n\n    if(dir != dataType) return; //not in this sector\n    \n    float t = length2(dx);\n    \n    insertionSort(bestIds, bestDists, searchId, t);\n}\n\n#define voronoiParticle(A, B, C) voronoiParticleImpl(iChannel0, iChannel1, R, iFrame, A, B, C)\nvec4 voronoiParticleImpl(sampler2D par, sampler2D vor, vec2 res, int iFrame, fxParticle p, uint id, uint dataType)\n{\n    uvec4 closest = fxGetClosestImpl(vor, ivec2(p.pos * res.y + .5 * res));\n    uvec4 bestIds = uvec4(-1);\n    vec4 bestDists = vec4(1e6);\n\n    for (int i = 0; i < 4; ++i)\n    {\n        sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[0][i], dataType, p.pos);\n        sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[1][i], dataType, p.pos);\n        sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[2][i], dataType, p.pos);\n        sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[3][i], dataType, p.pos);\n        sort0(par, uint(res.x), bestIds, bestDists, id, closest[i], dataType, p.pos);\n    }\n\n    uint searchIterations = 4U;\n    for(uint k = 0U; k < searchIterations; k++)\n    {\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash3(uvec3(id + k, id * k, k * uint(iFrame))).x;\n        //pick random id of particle\n        uint s = uint(mod(h*34534.0, float(g_MaxParticles)));\n        sort0(par, uint(res.x), bestIds, bestDists, id, s, dataType, p.pos);  //sort this\n    }\n    \n    return uintBitsToFloat(bestIds);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tParticle simulation\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 O, vec2 fragCoord )\n{\n    uvec2 ufc = uvec2(fragCoord);\n    \n    computeMaxParticles();\n    uint index = ufc.x + ufc.y * uint(R.x); // \"1D array\" index\n    uint id = index / NUM_PARTICLE_DATA_TYPES; // which particle\n    uint dataType = index - id * NUM_PARTICLE_DATA_TYPES; // which field of particle structure\n    if (id >= g_MaxParticles) return;\n    \n    fxParticle p = fxGetParticle(id);\n    fxState s = fxGetState();\n    \n    if (dataType >= POS)\n        O = updateParticle(s, p, id, dataType, 2. * DT / 3.);\n    else\n        O = fxSaveParticle(p, dataType); // skip voronoi update on buffers B and C (only one is needed)\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tVoronoi tracking buffer and persistent state\n// ---------------------------------------------------------------------------------------\n\nvec4 voronoiScreen(vec2 u);\nvec4 updateState(fxState s);\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    fxState s = fxGetState();\n    computeMaxParticles();\n\n    if (fxIsStatePixel(u))\n        O = updateState(s);\n    else\n        O = voronoiScreen(u);\n}\n\nvec4 updateState(fxState s)\n{\n    if (iFrame == 0 || R.x * R.y != abs(s.res) || keyDown(KEY_SPACE))\n    {\n        s.res = -R.x * R.y;\n        s.t = 0.;\n    }\n    else\n    {\n        s.res = abs(s.res);\n        s.t = fract(s.t + DT);\n    }\n\n    return fxPutState(s);\n}\n\n// find the squared distance from the screen position to a particular particle\nfloat distance2Particle(uint id, vec2 u)\n{\n    fxParticle v = fxGetParticle(id);\n    \n    return min(length2(v.pos - u), length2(v.pos - v.vel - u));\n}\n\n// get all the existing neighbors of a cell and consider them as possible improvements for ourselves\nvoid sortNbs(uvec4 old, vec2 p, inout uvec4 new, inout vec4 dis)\n{\n    for (int j = 0; j < 4; j++)\n    {\n        uint id = old[j];\n        if (id == -1U || id >= g_MaxParticles) break;\n        float dis2 = distance2Particle(id, p);\n        insertionSort( new, dis, id, dis2 );\n    }\n}\n\nvec4 voronoiScreen(vec2 u)\n{\n\tvec2 p = (u - .5 * R.xy) / R.y;\n    uvec4 new = uvec4(-1); // the four new closest particles\n    vec4 dis = vec4(1e6);  // the distances of the four newest particles\n\n    if (iFrame > 0 && !keyClick(KEY_SPACE))\n    {\n        uvec4 old = fxGetClosest(ivec2(u));\n                \n        sortNbs(old, p, new, dis); // start with our previous frame's values, and look up the distances\n        \n        int SEARCH_STEPS = int(2e4 / R.y);\n        const float SEARCH_RANGE = 20.;\n\n        for(int i = 0; i < SEARCH_STEPS; ++i)\n        {\n            vec2 h = hash3(uvec3(u, iFrame * 4 + i)).xy - .5;\n\n            sortNbs(fxGetClosest(ivec2(u + vec2(h * SEARCH_RANGE))), p, new, dis);\n        }\n\n        // random searching to kick start the process\n        float h = hash3(uvec3(u, iFrame)).x;\n        uint id = uint(h*float(g_MaxParticles));\n        insertionSort(new, dis, id, distance2Particle(id, p));\n    }\n    \n    return uintBitsToFloat(new);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}