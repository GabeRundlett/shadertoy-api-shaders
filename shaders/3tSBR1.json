{
    "Shader": {
        "info": {
            "date": "1598499573",
            "description": "Explore the caves. Use W, A, S, D, LSHIFT, SPACE keys to move. Press arrow keys to rotate the camera. To increase/decrease the speed, hold the C/V buttons. The mouse can also be used to rotate. Click and drag to change the camera orientation.",
            "flags": 48,
            "hasliked": 0,
            "id": "3tSBR1",
            "likes": 8,
            "name": "Cave exploration WASD+Arrow Keys",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "terrain",
                "cave",
                "generation"
            ],
            "usePreview": 0,
            "username": "vipiao",
            "viewed": 937
        },
        "renderpass": [
            {
                "code": "\nGET_CUBE_SIZE\n\nfloat DEBUG_MARKER = 0.;\nbool DEBUG_BOOL = false;\nbool DEBUG_CALLING_NORMAL = false;\nvec3 DEBUG_COLOR_MARKER = vec3(-1);\n\nfloat getDensityBufB(vec3 pos){\n    int cubeSize = getCubeSize();\n    \n    vec3 mPos = mod(pos, float(cubeSize));\n    \n    ivec3 iMPos = ivec3(mPos);\n    int flatCoord = iMPos.x + iMPos.y * cubeSize + iMPos.z * cubeSize * cubeSize;\n    ivec2 twoDCoord = ivec2(flatCoord % int(iResolution.x), flatCoord / int(iResolution.x));\n    \n    vec4 samp = texelFetch(iChannel1, twoDCoord, 0);\n    \n    float s000, s100, s010, s110, s001, s101, s011, s111;\n    \n    /* Unpack data.*/\n    unPack(samp.x, s000, s100);\n    unPack(samp.y, s010, s110);\n    unPack(samp.z, s001, s101);\n    unPack(samp.w, s011, s111);\n    float shift = 0.;\n    s000 -= 0.5+shift; s100 -= 0.5+shift; s010 -= 0.5+shift; s110 -= 0.5+shift;\n    s001 -= 0.5+shift; s101 -= 0.5+shift; s011 -= 0.5+shift; s111 -= 0.5+shift;\n    \n    vec3 frac = fract(mPos);\n    float h = mix(\n    \tmix( /* x=0*/\n        \tmix(s000, s001, frac.z), /* x=0, y=0, z=[0,1]*/\n        \tmix(s010, s011, frac.z), /* x=0, y=1, z=[0,1]*/\n            frac.y\n        ),\n    \tmix(/* x=1*/\n        \tmix(s100, s101, frac.z), /* x=1, y=0, z=[0,1]*/\n        \tmix(s110, s111, frac.z), /* x=1, y=1, z=[0,1]*/\n            frac.y\n        ),\n        frac.x\n    );\n    \n    return h;\n}\nfloat getDensityBufC(vec3 pos){\n    int cubeSize = getCubeSize();\n    \n    vec3 mPos = mod(pos, float(cubeSize));\n    \n    ivec3 iMPos = ivec3(mPos);\n    int flatCoord = iMPos.x + iMPos.y * cubeSize + iMPos.z * cubeSize * cubeSize;\n    ivec2 twoDCoord = ivec2(flatCoord % int(iResolution.x), flatCoord / int(iResolution.x));\n    \n    vec4 samp = texelFetch(iChannel2, twoDCoord, 0);\n    \n    float s000, s100, s010, s110, s001, s101, s011, s111;\n    \n    /* Unpack data.*/\n    unPack(samp.x, s000, s100);\n    unPack(samp.y, s010, s110);\n    unPack(samp.z, s001, s101);\n    unPack(samp.w, s011, s111);\n    float shift = 0.;\n    s000 -= 0.5+shift; s100 -= 0.5+shift; s010 -= 0.5+shift; s110 -= 0.5+shift;\n    s001 -= 0.5+shift; s101 -= 0.5+shift; s011 -= 0.5+shift; s111 -= 0.5+shift;\n    \n    vec3 frac = fract(mPos);\n    float h = mix(\n    \tmix( /* x=0*/\n        \tmix(s000, s001, frac.z), /* x=0, y=0, z=[0,1]*/\n        \tmix(s010, s011, frac.z), /* x=0, y=1, z=[0,1]*/\n            frac.y\n        ),\n    \tmix(/* x=1*/\n        \tmix(s100, s101, frac.z), /* x=1, y=0, z=[0,1]*/\n        \tmix(s110, s111, frac.z), /* x=1, y=1, z=[0,1]*/\n            frac.y\n        ),\n        frac.x\n    );\n    \n    return h;\n}\nfloat getLayeredDensityBufC(vec3 pos, float resolution){\n    int numIte = int(ceil(resolution));\n    float scale = 1.;\n    float density = 0.;\n    for(int i=0;i<numIte;i++){\n        //if(threshold - density > scale*0.05){\n        //\tbreak;\n        //}\n        float factor = min(resolution - float(i), 1.);\n        float d = getDensityBufC(pos * scale);\n        d = d/scale * factor;\n    \tdensity += d;\n        scale *= 8.;\n    }\n    return density;\n}\n\n// Cave sd.\nfloat sdCave(in vec3 pos, float resolution){\n    float density = getDensityBufB(pos);\n    const float caveWidth = 0.02;\n    float nextDist = density - caveWidth;\n    \n    /* Add noise.*/\n    if(abs(nextDist)-0.002 < 0.006){\n    \tfloat noise = getLayeredDensityBufC(pos*16., resolution);\n    \tnextDist += noise*0.01;\n    }\n    \n    nextDist = abs(nextDist)-0.002;\n    \n    return nextDist*20.;\n}\nvoid sdCaveNormal(in vec3 pos, float diff, float resolution, inout vec3 normal, inout float sd){\n    DEBUG_CALLING_NORMAL = true;\n\tsd = sdCave(pos, resolution);\n    vec2 e = vec2(diff, 0.);\n    normal = normalize(sd - vec3(\n    \tsdCave(pos - e.xyy, resolution),\n    \tsdCave(pos - e.yxy, resolution),\n    \tsdCave(pos - e.yyx, resolution)\n    ));\n    DEBUG_CALLING_NORMAL = false;\n}\n\n// Cave gradient.\nfloat sdCaveGradient(in vec3 pos){\n    float density = getDensityBufB(pos);\n    float nextDist = density;\n    \n    return nextDist;\n}\nvoid sdCaveGradientNormal(in vec3 pos, float diff, inout vec3 normal, inout float sd){\n    DEBUG_CALLING_NORMAL = true;\n\tsd = sdCaveGradient(pos);\n    vec2 e = vec2(diff, 0.);\n    normal = normalize(sd - vec3(\n    \tsdCaveGradient(pos - e.xyy),\n    \tsdCaveGradient(pos - e.yxy),\n    \tsdCaveGradient(pos - e.yyx)\n    ));\n    DEBUG_CALLING_NORMAL = false;\n}\n\n// March\n# define INTERSECTED 0\n# define TOO_FAR 1\n# define TOO_MANY_STEPS 2\nvoid marchWorld(\n    inout vec3 pos, inout vec3 dir,\n    out float dist, in float maxDist, in float minDist,\n    out int numSteps, in int maxNumSteps,\n    out vec4 color, out vec3 normal, out int returnCode\n){\n    dist = 0.;\n    float prevDist = dist;\n    numSteps = 0;\n    color = vec4(0);\n    vec3 prevPos = pos;\n    float prevSd;\n    float sd = 0.;\n    \n    //\n    const float res = 2.;\n    \n    // Trace.\n    for(int i=0; i<maxNumSteps; i++) {\n        //\n        numSteps++;\n        \n        // Calc sd.\n        prevSd = sd;\n        \n        //float sdSphere = sdSphere(/*in vec3 pos=*/pos, /*in vec3 center=*/vec3(0), /*in float radius=*/1.);\n        //float sdDensity = sdDensity(/*in vec3 pos=*/pos, /*in float resolution=*/res);\n        float sdCave = sdCave(/*in vec3 pos=*/pos, /*in float resolution=*/res);\n\n        //sd = sdDensity;\n        sd = sdCave;\n        \n        if(dist + sd > maxDist){\n        \tsd = maxDist-dist;\n            dist += sd;\n            pos += dir*sd;\n            \n            color = vec4(0);\n            normal = vec3(0);\n            \n            returnCode = TOO_FAR;\n        \treturn;\n        }\n        if(sd <= minDist + dist*0.001){\n            \n            //if(i==2) DEBUG_MARKER = 1.;\n            //if(sd < 0.0) DEBUG_MARKER = 1.;\n            \n            // Linearly interpolate position.\n            float fac = (minDist + dist*0.001 - sd) / (prevSd - sd);\n            pos = mix(pos, prevPos, fac);\n            \n            //sdDensityNormal(\n            //    /*in vec3 pos=*/pos, /*float diff=*/max(dist*3./iResolution.x, 0.002), /*float resolution=*/res+1.,\n            //    /*inout vec3 normal=*/normal, /*inout float sd=*/sd\n            //);\n            sdCaveNormal(\n                /*in vec3 pos=*/pos, /*float diff=*/max(dist*3./iResolution.x, 0.002), /*float resolution=*/res+0.5,\n                /*inout vec3 normal=*/normal, /*inout float sd=*/sd\n            );\n            \n            color = vec4(155., 155., 154., 0.)/255.;\n            \n            float f = clamp(getLayeredDensityBufC(pos*5., 1.)*20.-5., 0., 1.);\n            color = mix(color, vec4(255, 215, 0, 32)/255., f);\n            //color = mix(color, vec4(100, 255, 0, 92)/255., f);\n            \n            vec3 towardsMiddle;\n            float sdTowardsMiddle;\n            //sdCaveCenterNormal(pos, 0.004, /*out vec3 normal=*/towardsMiddle, /*inout float sd=*/sd);\n            sdCaveGradientNormal(\n                /*in vec3 pos=*/pos, /*float diff=*/0.1,\n                /*inout vec3 normal=*/towardsMiddle, /*inout float sd=*/sdTowardsMiddle\n            );\n            towardsMiddle = normalize(-towardsMiddle);\n            float grassFactor = min(pow(dot(towardsMiddle, normal)+0.1, 8.), 1.);\n            color = mix(color, vec4(146., 116., 32., 0)/255., grassFactor);\n            \n            //float noise = getLayeredDensityBufC(pos, 1.);\n            //color.r += noise*1.;\n\n            returnCode = INTERSECTED;\n            return;\n            \n            //if(sd < 0.){\n            //\tcolor = vec3(1,0,0);\n            //}\n            \n            //color=vec3(1,1,0);\n\n            \n        }\n        \n        //\n        prevDist = dist;\n        dist += sd;\n        prevPos = pos;\n        pos += dir*sd;\n       \t\n    }\n    returnCode = TOO_MANY_STEPS;\n    return;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(CAMERA_POS, 0), 0).xyz;\n    vec3 forward = normalize(texelFetch(iChannel0, ivec2(CAMERA_DIRECTION_FORWARD, 0), 0).xyz);\n    vec3 right = normalize(texelFetch(iChannel0, ivec2(CAMERA_DIRECTION_RIGHT, 0), 0).xyz);\n    vec3 up = cross(right, forward);\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    vec3 camPos = vec3(cameraPos.x, cameraPos.y, cameraPos.z);\n    vec3 viewDir = normalize(forward*0.3 + right * uv.x + up * uv.y);\n    \n    // Light cone.\n    float coneFactor = max(pow(min(dot(viewDir, forward) + 0.15, 1.), 16.), 0.);\n    coneFactor = (coneFactor*0.6 + 0.4);\n    \n    //\n    vec3 pos = camPos;\n    vec3 dir = viewDir;\n    float dist = 0.;\n    float maxDist = 50.;\n    float minDist = 0.002;\n    int numSteps;\n    int maxNumSteps = int(75. * coneFactor);\n    vec4 color;\n    vec3 normal;\n    int returnCode;\n    marchWorld(\n        /*inout vec3 pos=*/pos, /*inout vec3 dir=*/dir,\n        /*out float dist=*/dist, /*in float maxDist=*/maxDist, /*in float minDist=*/minDist,\n        /*out int numSteps=*/numSteps, /*in int maxNumSteps=*/maxNumSteps,\n        /*out vec3 color=*/color, /*out vec3 normal=*/normal, /*out int returnCode=*/returnCode\n    );\n    \n    //vec3 lightDir = normalize(vec3(5.,-1,3.));\n    vec3 lightDir = viewDir;\n    \n    // Ambient occlusion.\n    vec3 occlusionColor = vec3(0.,0.,0.);\n    float occlusionFactor = float(numSteps)/log(dist+10.) * max(dot(-viewDir, normal), 0.);\n    occlusionFactor = max(1.-occlusionFactor*0.025, 0.);\n    \n    float diff = max(dot(-lightDir, normal), 0.)*0.75;\n    \n    vec3 reflectDir = reflect(lightDir, normal); // reflect(I, N) = I - 2.0 * dot(N, I) * N.\n    float spec = pow(max(dot(reflectDir, -viewDir), 0.0), 8.) * 0.25;\n    \n    float ambient = 0.125*occlusionFactor;\n    \n    color = mix(\n        (color*diff + color*spec)*coneFactor + color*ambient,\n        color, color.w\n    );\n    \n    // Mist.\n    //vec3 mistColor = vec3(0.5,0.6,0.9);\n    vec4 mistColor = vec4(0., 0., 0., 0);\n    float mistFactor = max(float(numSteps)/float(maxNumSteps), float(dist)/float(maxDist));\n    mistFactor = pow(mistFactor, 1.);\n    color = mix(color, mistColor, mistFactor);\n    \n    // The sun.\n    float d = dist/maxDist * 2.*max(mistFactor*mistFactor*mistFactor-0.5, 0.)*min(pow(max(dot(dir, -lightDir), 0.), 1024.), 1.);\n    color = min(color + vec4(d), 1.);\n    \n    //color.r = float(numSteps);\n    //if(numSteps == 3){\n    //\tcolor.r = 1.;\n    //}\n    //color.r += DEBUG_MARKER;\n    if(DEBUG_COLOR_MARKER != vec3(-1)){\n    \t//color += DEBUG_COLOR_MARKER;\n    }\n    \n    // Output to screen\n    fragColor = vec4(color.xyz,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n//#define iResolution vec3(640,370,1) \n\n// Math.\n# define PI 3.1415926538\n\n// Input.\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL  = 17;\nconst int KEY_SPACE  = 32;\nconst int KEY_W  = 87;\nconst int KEY_A = 65;\nconst int KEY_S  = 83;\nconst int KEY_D  = 68;\nconst int KEY_C  = 67;\nconst int KEY_V  = 86;\nconst int KEY_Q  = 81;\nconst int KEY_E  = 69;\nconst int KEY_R  = 82;\nconst int KEY_1  = 49;\nconst int KEY_2  = 50;\nconst int KEY_3  = 51;\n\n# define MAP_WIDTH 30.\nconst int CAMERA_POS = 0;\nconst int CAMERA_SENSITIVITY = 1;\nconst int CAMERA_DIRECTION_FORWARD = 2;\nconst int CAMERA_DIRECTION_RIGHT = 3;\nconst int CHANGE_SEED = 4;\nconst int SCREEN_RESOLUTION = 5;\nconst int DO_BUFFER_UPDATE = 6;\nconst int MOVEMENT_MODE = 7;\nconst int MOUSE_TEMP = 8;\nconst int MOUSE_PREVIOUS = 9;\n\nconst int MOVEMENT_MODE_AUTO = 0;\nconst int MOVEMENT_MODE_FREE = 1;\n    \n// Auto parameters.\n# define AUTO_MOVEMENT_SPEED 0.04\n# define START_TIME 40.\n\n//\n# define ALTERNATIVE_CAVE\n\n//\nfloat sigmoid(float x) { return 2./(1. + exp(-x)) - 1.; }\n\n// --Hash function--\n/*\nInspired by Adam Smith.\nsource: https://groups.google.com/forum/#!msg/proceduralcontent/AuvxuA1xqmE/T8t88r2rfUcJ\n*/\n# define PRECISION 3\n// 2^32-1\n# define LARGEST_UINT 4294967295u\n# define LARGEST_UINT_AS_FLOAT 4294967295.\n// 2^31-1 = 2147483647\n# define LARGEST_INT 2147483647\n# define LARGEST_INT_AS_FLOAT 2147483647.\n# define SMALLEST_INT -2147483648\n# define SMALLEST_INT_AS_FLOAT -2147483648.\n// 2^32 = 4294967296\n# define LARGEST_SMALLEST_INT_DIFFERENCE_AS_FLOAT 4294967296.\n\nint rotate (int x, int b) {\n    return (x << b) ^ (x >> (32-b));\n}\n\nint pcg (int a) {\n    int b = a;\n    for (int i = 0; i < PRECISION; i++) {\n        a = rotate((a^0xcafebabe) + (b^0xfaceb00c), 23);\n        b = rotate((a^0xdeadbeef) + (b^0x8badf00d), 5);\n    }\n    return a^b;\n}\n\nfloat pcgUnit (int a) {\n    return (float(pcg(a))-SMALLEST_INT_AS_FLOAT) / LARGEST_SMALLEST_INT_DIFFERENCE_AS_FLOAT;\n}\n\nint pcg (int a, int b) {\n    for (int i = 0; i < PRECISION; i++) {\n        a = rotate((a^0xcafebabe) + (b^0xfaceb00c), 23);\n        b = rotate((a^0xdeadbeef) + (b^0x8badf00d), 5);\n    }\n    return a^b;\n}\n\nfloat pcgUnit (int a, int b) {\n    return (float(pcg(a,b))-SMALLEST_INT_AS_FLOAT) / LARGEST_SMALLEST_INT_DIFFERENCE_AS_FLOAT;\n}\n\nint pcg (int a, int b, int c) {\n    for (int i = 0; i < PRECISION; i++) {\n        a = rotate((a^0xcafebabe) + (b^0xfaceb00c) + (c^0xcabba6e5), 23);\n        b = rotate((a^0xdeadbeef) + (b^0x8badf00d) + (c^0x0b5e55ed), 5);\n        c = rotate((a^0x5eaf00d5) + (b^0xdecea5ed) + (c^0xba5eba11), 16);\n    }\n    // https://www.dcode.fr/words-containing\n    return a^b^c;\n}\n\nfloat pcgUnit (int a, int b, int c) {\n    return (float(pcg(a,b,c))-SMALLEST_INT_AS_FLOAT) / LARGEST_SMALLEST_INT_DIFFERENCE_AS_FLOAT;\n}\n\n// --Noise functions--\nfloat boxNoise(vec3 pos, int seed){\n\tivec3 ind = ivec3(floor(pos));\n    \n    vec3 f = fract(pos);\n    \n    vec3 u = f * f * (3.0 - 2.0 * f);\n    \n    //return mix(mix(mix( pcgUnit(ind.x+0, ind.y+0, ind.z+0), pcgUnit(ind.x+1, ind.y+0, ind.z+0), u.x),\n    //               mix( pcgUnit(ind.x+0, ind.y+1, ind.z+0), pcgUnit(ind.x+1, ind.y+1, ind.z+0), u.x), u.y),\n    //           mix(mix( pcgUnit(ind.x+0, ind.y+0, ind.z+1), pcgUnit(ind.x+1, ind.y+0, ind.z+1), u.x),\n    //               mix( pcgUnit(ind.x+0, ind.y+1, ind.z+1), pcgUnit(ind.x+1, ind.y+1, ind.z+1), u.x), u.y), u.z);\n    \n    // Optimized version.\n    // 15485863 and 179424673 are primes.\n    ivec2 yS = ivec2(ind.y*15485863, (ind.y+1)*15485863);\n    ivec2 zS = ivec2(ind.z*179424673, (ind.z+1)*179424673);\n    return mix(mix(mix( pcgUnit(ind.x + yS.x + zS.x, seed), pcgUnit(ind.x+1 + yS.x + zS.x, seed), u.x),\n                   mix( pcgUnit(ind.x + yS.y + zS.x, seed), pcgUnit(ind.x+1 + yS.y + zS.x, seed), u.x), u.y),\n               mix(mix( pcgUnit(ind.x + yS.x + zS.y, seed), pcgUnit(ind.x+1 + yS.x + zS.y, seed), u.x),\n                   mix( pcgUnit(ind.x + yS.y + zS.y, seed), pcgUnit(ind.x+1 + yS.y + zS.y, seed), u.x), u.y), u.z);\n}\nfloat boxNoise(vec3 pos){\n    return boxNoise(pos, 0);\n}\n\nfloat layeredBoxNoise(vec3 pos, int numLayers, int seed){\n    seed = pcg(seed);\n\tfloat result = 0.;\n    float scale = 1.;\n    float denominator = 0.;\n    for (int i = 0; i < numLayers; i++) {\n        result += scale * boxNoise(pos, ++seed);\n        denominator += scale;\n        pos *= 2.;\n        pos += PI*0.;\n        scale *= 0.5;\n    }\n    return result/denominator;\n}\n\nfloat perlinNoise(vec3 pos, int seed, int tileSize){\n    ivec3 ind = ivec3(floor(pos));\n    \n    vec3 f = fract(pos);\n    \n    vec3 u = f * f * (3.0 - 2.0 * f);\n    \n    f = f;\n    \n    // 2038074743 and 179424673 are primes.\n    //ivec2 yS = ivec2(ind.y*15485863, (ind.y+1)*15485863);\n    //ivec2 zS = ivec2(ind.z*179424673, (ind.z+1)*179424673);\n    // 7907 and 7919 are primes.\n    ivec3 modInd = ivec3(mod(vec3(ind), float(tileSize)));\n    ivec3 modIndP = ivec3(mod(vec3(ind+1), float(tileSize)));\n    modInd.y *= 7907;\n    modIndP.y *= 7907;\n    modInd.z *= 7919;\n    modIndP.z *= 7919;\n    \n    float nf = 2./float(0x3ff);\n    \n    int x0y0z0H = pcg(modInd.x + modInd.y + modInd.z, seed);\n    float x0y0z0 = dot(\n        vec3(\n            (float(0x000003ff & x0y0z0H)*nf-1.),\n            (float((0x000ffc00 & x0y0z0H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x0y0z0H) >> 20)*nf-1.)\n        ),\n        f\n    );\n    \n    int x1y0z0H = pcg(modIndP.x + modInd.y + modInd.z, seed);\n    float x1y0z0 = dot(\n        vec3(\n            (float(0x000003ff & x1y0z0H)*nf-1.),\n            (float((0x000ffc00 & x1y0z0H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x1y0z0H) >> 20)*nf-1.)\n        ),\n        vec3(f.x-1., f.y, f.z)\n    );\n    \n    int x0y1z0H = pcg(modInd.x + modIndP.y + modInd.z, seed);\n    float x0y1z0 = dot(\n        vec3(\n            (float(0x000003ff & x0y1z0H)*nf-1.),\n            (float((0x000ffc00 & x0y1z0H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x0y1z0H) >> 20)*nf-1.)\n        ),\n        vec3(f.x, f.y-1., f.z)\n    );\n    \n    int x1y1z0H = pcg(modIndP.x + modIndP.y + modInd.z, seed);\n    float x1y1z0 = dot(\n        vec3(\n            (float(0x000003ff & x1y1z0H)*nf-1.),\n            (float((0x000ffc00 & x1y1z0H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x1y1z0H) >> 20)*nf-1.)\n        ),\n        vec3(f.x-1., f.y-1., f.z)\n    );\n    \n    int x0y0z1H = pcg(modInd.x + modInd.y + modIndP.z, seed);\n    float x0y0z1 = dot(\n        vec3(\n            (float(0x000003ff & x0y0z1H)*nf-1.),\n            (float((0x000ffc00 & x0y0z1H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x0y0z1H) >> 20)*nf-1.)\n        ),\n        vec3(f.x, f.y, f.z-1.)\n    );\n    \n    int x1y0z1H = pcg(modIndP.x + modInd.y + modIndP.z, seed);\n    float x1y0z1 = dot(\n        vec3(\n            (float(0x000003ff & x1y0z1H)*nf-1.),\n            (float((0x000ffc00 & x1y0z1H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x1y0z1H) >> 20)*nf-1.)\n        ),\n        vec3(f.x-1., f.y, f.z-1.)\n    );\n    \n    int x0y1z1H = pcg(modInd.x + modIndP.y + modIndP.z, seed);\n    float x0y1z1 = dot(\n        vec3(\n            (float(0x000003ff & x0y1z1H)*nf-1.),\n            (float((0x000ffc00 & x0y1z1H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x0y1z1H) >> 20)*nf-1.)\n        ),\n        vec3(f.x, f.y-1., f.z-1.)\n    );\n    \n    int x1y1z1H = pcg(modIndP.x + modIndP.y + modIndP.z, seed);\n    float x1y1z1 = dot(\n        vec3(\n            (float(0x000003ff & x1y1z1H)*nf-1.),\n            (float((0x000ffc00 & x1y1z1H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x1y1z1H) >> 20)*nf-1.)\n        ),\n        vec3(f.x-1., f.y-1., f.z-1.)\n    );\n    \n    return mix(mix(mix( x0y0z0, x1y0z0, u.x),\n                   mix( x0y1z0, x1y1z0, u.x), u.y),\n               mix(mix( x0y0z1, x1y0z1, u.x),\n                   mix( x0y1z1, x1y1z1, u.x), u.y), u.z);\n}\n\nfloat layeredPerlinNoise(vec3 pos, int numLayers, int seed, int tileSize){\n    seed = pcg(seed);\n\tfloat result = 0.;\n    float scale = 1.;\n    float denominator = 0.;\n    for (int i = 0; i < numLayers; i++) {\n        result += scale * perlinNoise(pos, ++seed, tileSize);\n        tileSize *= 2;\n        denominator += scale;\n        pos *= 2.;\n        pos += PI*0.;\n        scale *= 0.5;\n    }\n    return result/denominator;\n}\n\n// --Signed distance functions. (SDF)--\nfloat sdSphere(in vec3 pos, in vec3 center, in float radius){\n   \treturn length(pos-center) - radius;\n}\nvoid sdSphereNormal(in vec3 pos, in vec3 center, in float radius, inout vec3 normal, inout float sd){\n\tsd = sdSphere(pos, center, radius);\n    vec2 e = vec2(0.01, 0.);\n    normal = normalize(sd - vec3(\n    \tsdSphere(pos - e.xyy, center, radius),\n    \tsdSphere(pos - e.yxy, center, radius),\n    \tsdSphere(pos - e.yyx, center, radius)\n    ));\n}\n\nconst float shiftExponent = 4096.;\nconst int shiftNum = 12;\nconst int shiftMask = 0xfff;\nfloat pack(float v1, float v2){\n    return floor(clamp(v1, 0., 1.)*shiftExponent) + floor(clamp(v2, 0., 1.)*shiftExponent)*shiftExponent;\n}\nvoid unPack(in float data, out float v1, out float v2){\n    v1 = float(int(data) & shiftMask)/shiftExponent;\n    v2 = float((int(data) >> shiftNum) & shiftMask)/shiftExponent;\n}\n\n// Density functions.\n# define GET_CUBE_SIZE \\\nint getCubeSize(){\\\n\tint maximum =  int(pow(iResolution.x * iResolution.y, 1./3.));\\\n    return min(70, maximum);\\\n}\\\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n// This buffer is used to store global variables, like camera position and such.\n\nGET_CUBE_SIZE\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 prevColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // Mouse previous.\n    vec4 mousePrevious = texelFetch(iChannel0, ivec2(MOUSE_TEMP,0), 0);\n    if(ivec2(fragCoord) == ivec2(MOUSE_PREVIOUS,0)){\n        prevColor = mousePrevious;\n    }\n    if(ivec2(fragCoord) == ivec2(MOUSE_TEMP,0)){\n        prevColor = iMouse;\n    }\n    \n    \n    // Change movement mode.\n    int movementMode = int(texelFetch(iChannel2, ivec2(MOVEMENT_MODE,0), 0).x);\n    if(ivec2(fragCoord) == ivec2(MOVEMENT_MODE,0)){\n        bool key1IsDown = texelFetch(iChannel2, ivec2(KEY_1,0), 0).x > 0.5;\n    \tbool key2IsDown = texelFetch(iChannel2, ivec2(KEY_2,0), 0).x > 0.5;\n        if(key1IsDown){\n        \tprevColor.r = 0.;\n            movementMode = 0;\n        } else if(key2IsDown){\n        \tprevColor.r = 1.;\n            movementMode = 1;\n        }\n    }\n    \n    // Accelerate.\n    float sensitivity = texelFetch(iChannel0, ivec2(CAMERA_SENSITIVITY, 0), 0).x;\n    if(ivec2(fragCoord) == ivec2(CAMERA_SENSITIVITY,0)){\n        if(sensitivity == 0.){\n            sensitivity = 0.02;\n            prevColor.r = 0.02;\n        }\n        if(texelFetch( iChannel2, ivec2(KEY_C,0), 0 ).x > 0.5 && prevColor.r < 100.){\n            prevColor.r *= 1.05;\n        }\n        if(texelFetch( iChannel2, ivec2(KEY_V,0), 0 ).x > 0.5 && prevColor.r > 0.0001){\n            prevColor.r /= 1.05;\n        }\n    }\n    \n    // Rotate.\n    vec3 forward = texelFetch(iChannel0, ivec2(CAMERA_DIRECTION_FORWARD, 0), 0).xyz;\n    if(length(forward) == 0.){\n        forward = vec3(0,0,-1);\n    }\n    forward = normalize(forward);\n    //vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 right = texelFetch(iChannel0, ivec2(CAMERA_DIRECTION_RIGHT, 0), 0).xyz;\n    if(length(right) == 0.){\n        right = vec3(1,0,0);\n    }\n    right = normalize(right);\n    vec3 up = cross(right, forward);\n    if(\n        ivec2(fragCoord) == ivec2(CAMERA_DIRECTION_FORWARD,0) ||\n        ivec2(fragCoord) == ivec2(CAMERA_DIRECTION_RIGHT,0)\n    ){\n        bool arrowRight = texelFetch( iChannel2, ivec2(KEY_RIGHT,0), 0 ).x > 0.5;\n        bool arrowLeft = texelFetch( iChannel2, ivec2(KEY_LEFT,0), 0 ).x > 0.5;\n        bool arrowUp = texelFetch( iChannel2, ivec2(KEY_UP,0), 0 ).x > 0.5;\n        bool arrowDown = texelFetch( iChannel2, ivec2(KEY_DOWN,0), 0 ).x > 0.5;\n        float rotationSpeed = 0.04;\n        \n        // Arrow key movement.\n        if(arrowRight){\n            forward = normalize(forward + right*rotationSpeed);\n        }\n        if(arrowLeft){\n            forward = normalize(forward - right*rotationSpeed);\n        }\n        if(arrowUp){\n            forward = normalize(forward + up*rotationSpeed);\n        }\n        if(arrowDown){\n            forward = normalize(forward - up*rotationSpeed);\n        }\n        \n        // Mouse movement.\n        if(mousePrevious.z > 0.){\n        \tforward = normalize(forward + up * (iMouse.y - mousePrevious.y)*0.003);\n        \tforward = normalize(forward + right * (iMouse.x - mousePrevious.x)*0.003);\n        }\n        \n        //\n    \tvec3 up = cross(right, forward);\n    \tvec3 right = cross(forward, up);\n        if(ivec2(fragCoord) == ivec2(CAMERA_DIRECTION_FORWARD,0)){\n        \tprevColor.xyz = normalize(forward);\n        }else{\n        \tprevColor.xyz = normalize(right);\n        }\n    }\n    \n    // Translate.\n    if(ivec2(fragCoord) == ivec2(CAMERA_POS,0)){\n        bool dDown = texelFetch( iChannel2, ivec2(KEY_D,0), 0 ).x > 0.5;\n        bool aDown = texelFetch( iChannel2, ivec2(KEY_A,0), 0 ).x > 0.5;\n        bool spaceDown = texelFetch( iChannel2, ivec2(KEY_SPACE,0), 0 ).x > 0.5;\n        bool shiftDown = texelFetch( iChannel2, ivec2(KEY_SHIFT,0), 0 ).x > 0.5;\n        bool wDown = texelFetch( iChannel2, ivec2(KEY_W,0), 0 ).x > 0.5;\n        bool sDown = texelFetch( iChannel2, ivec2(KEY_S,0), 0 ).x > 0.5;\n        \n        if(wDown){\n            prevColor.xyz += forward*sensitivity;\n        }\n        if(sDown){\n            prevColor.xyz -= forward*sensitivity;\n        }\n        if(dDown){\n            prevColor.xyz += right*sensitivity;\n        }\n        if(aDown){\n            prevColor.xyz -= right*sensitivity;\n        }\n        if(spaceDown){\n            prevColor.xyz += up*sensitivity;\n        }\n        if(shiftDown){\n            prevColor.xyz -= up*sensitivity;\n        }\n        if(false || iTime < 0.1){\n            //prevColor.xyz = vec3(-1.1, -7.99, -5.1); // 70.\n            //prevColor.xyz = vec3(-1.1, -7. - float(getCubeSize())*0., -5.1); // 61.\n            //prevColor.xyz = vec3(-1.1, -5., -5.1); // 40.\n            // g: y = -x * 2 / 21 - 25 / 21\n            prevColor.xyz = vec3(-1.1, -2./21.*float(getCubeSize()) - 25./21., -5.1); // Adaptable.\n        }\n    }\n    \n    // Check for screen resolution change.\n    if(ivec2(fragCoord) == ivec2(SCREEN_RESOLUTION,0)){\n        prevColor.xy = iResolution.xy;\n    }else if(ivec2(fragCoord) == ivec2(DO_BUFFER_UPDATE,0)){\n        bool qIsDown = texelFetch( iChannel2, ivec2(KEY_Q, 0), 0 ).x > 0.5;\n        bool eIsDown = texelFetch( iChannel2, ivec2(KEY_E, 0), 0 ).x > 0.5;\n        if(\n            texelFetch( iChannel0, ivec2(SCREEN_RESOLUTION, 0), 0 ).xy != iResolution.xy || qIsDown || eIsDown\n        ){\n        \tprevColor.x = 1.;\n        }else{\n        \tprevColor.x = 0.;\n        }\n    }\n    \n    // Change seed.\n    if(ivec2(fragCoord) == ivec2(CHANGE_SEED,0)){\n\t    bool qIsDown = texelFetch(iChannel2, ivec2(KEY_Q,0), 0).x > 0.5;\n    \tbool eIsDown = texelFetch(iChannel2, ivec2(KEY_E,0), 0).x > 0.5;\n        if(qIsDown){\n        \tprevColor.r += 0.1;\n        }\n        if(eIsDown){\n        \tprevColor.r -= 0.1;\n        }\n    }\n    \n    //\n    fragColor = prevColor;\n}\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// This buffer is only changed on screen resolution change. When that happens, the mountain heightmap texture is refreshed once.\n\nGET_CUBE_SIZE\n\nfloat getDensity(vec3 pos, int seed, int size){\n    return layeredPerlinNoise(/*vec3 pos=*/pos*float(size), /*int numLayers=*/3, /*int seed=*/seed, /*int tileSize=*/size);\n}\nfloat getDensityCave(in vec3 pos){\n    float densityA = getDensity(pos, 0, 1);\n    float densityB = getDensity(pos, 1, 1);\n    float densityC = getDensity(pos, 2, 1);\n    \n    float density;\n    if(densityA > densityC){\n    \tdensity = max(densityA, densityB) - min(densityC, densityB);\n    } else {\n    \tdensity = max(densityC, densityB) - min(densityA, densityB);\n    }\n    \n    return density;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 prevColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    if(texelFetch( iChannel0, ivec2(DO_BUFFER_UPDATE,0), 0 ).x > 0.5){\n        \n        // Only run once every time the screen resolution or seed is changed.\n        ivec2 iFragCoord = ivec2(fragCoord);\n        int flatCoord = iFragCoord.x + iFragCoord.y * int(iResolution.x);\n        int cubeSize = getCubeSize();\n        ivec3 cubeCoords = ivec3(\n        \tflatCoord % cubeSize,\n            (flatCoord / cubeSize) % cubeSize,\n            flatCoord / cubeSize / cubeSize\n        );\n        vec3 fCubeCoords = vec3(cubeCoords) / float(cubeSize);\n        vec2 e = vec2(0, 1./float(cubeSize));\n        vec3 positions[8] = vec3[](\n        \tfCubeCoords + e.xxx, fCubeCoords + e.yxx, fCubeCoords + e.xyx, fCubeCoords + e.yyx,\n            fCubeCoords + e.xxy, fCubeCoords + e.yxy, fCubeCoords + e.xyy, fCubeCoords + e.yyy\n        );\n        float noise[8];\n        for(int i=0; i<8; i++){\n            noise[i] = getDensityCave(positions[i]);\n        }\n        prevColor = vec4(\n        \tpack(noise[0]+0.5, noise[1]+0.5),\n        \tpack(noise[2]+0.5, noise[3]+0.5),\n        \tpack(noise[4]+0.5, noise[5]+0.5),\n        \tpack(noise[6]+0.5, noise[7]+0.5)\n        );\n        //prevColor = vec4(\n        //\tnoise[0],\n        //\tnoise[1],\n        //\tnoise[2],\n        //\tnoise[3]\n        //);\n        \n    }\n    \n    fragColor = prevColor;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// This buffer is only changed on screen resolution change. When that happens, the mountain heightmap texture is refreshed once.\n\nGET_CUBE_SIZE\n\nfloat getDensity(vec3 pos, int seed, int size){\n    return layeredPerlinNoise(/*vec3 pos=*/pos*float(size), /*int numLayers=*/3, /*int seed=*/seed, /*int tileSize=*/size);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 prevColor = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    if(texelFetch( iChannel0, ivec2(DO_BUFFER_UPDATE,0), 0 ).x > 0.5){\n        \n        // Only run once every time the screen resolution or seed is changed.\n        ivec2 iFragCoord = ivec2(fragCoord);\n        int flatCoord = iFragCoord.x + iFragCoord.y * int(iResolution.x);\n        int cubeSize = getCubeSize();\n        ivec3 cubeCoords = ivec3(\n        \tflatCoord % cubeSize,\n            (flatCoord / cubeSize) % cubeSize,\n            flatCoord / cubeSize / cubeSize\n        );\n        vec3 fCubeCoords = vec3(cubeCoords) / float(cubeSize);\n        vec2 e = vec2(0, 1./float(cubeSize));\n        vec3 positions[8] = vec3[](\n        \tfCubeCoords + e.xxx, fCubeCoords + e.yxx, fCubeCoords + e.xyx, fCubeCoords + e.yyx,\n            fCubeCoords + e.xxy, fCubeCoords + e.yxy, fCubeCoords + e.xyy, fCubeCoords + e.yyy\n        );\n        float noise[8];\n        for(int i=0; i<8; i++){\n            noise[i] = getDensity(positions[i], 1, 10);\n        }\n        prevColor = vec4(\n        \tpack(noise[0]+0.5, noise[1]+0.5),\n        \tpack(noise[2]+0.5, noise[3]+0.5),\n        \tpack(noise[4]+0.5, noise[5]+0.5),\n        \tpack(noise[6]+0.5, noise[7]+0.5)\n        );\n    }\n    \n    fragColor = prevColor;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}