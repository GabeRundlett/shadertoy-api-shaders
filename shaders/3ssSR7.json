{
    "Shader": {
        "info": {
            "date": "1550882106",
            "description": "The pointiest spike in the world.",
            "flags": 0,
            "hasliked": 0,
            "id": "3ssSR7",
            "likes": 3,
            "name": "Approximate spike distance",
            "published": 3,
            "tags": [
                "sdf",
                "spiked",
                "peak",
                "pointy"
            ],
            "usePreview": 0,
            "username": "dracusa",
            "viewed": 532
        },
        "renderpass": [
            {
                "code": "/*\n\nApproximate distance for the implicit surface y = w*h/(abs(x)+w)\n    w is width, recommended range: 0.05 to 0.15\n    h is height, recommended range: 0 to 1.5\nCan easily be turned into a 3D surface by extruding or lathing.\n\nUpdated in 2022 - the old version is commented out.\n\n*/\n\nfloat sdSpike2D(vec2 p, float w, float h)\n{\n    vec2 corner = vec2(0.18*w+0.3*h, w+0.25*h);\n    float dv = p.y - w*h/(abs(p.x)+w);\n    float dh = abs(p.x) + w - h*w/p.y;\n    float low = min(w, h-p.y);\n    if (low>0. && dv>0.) {\n        dv = min(dv, dh);\n        vec2 cd = corner - abs(p);\n        dv /= 1.+low/(.6+dot(cd,cd)*h*3.);\n    }\n    dv = min(dv, length(p - vec2(0., min(h, p.y))));\n    return dv;\n}\n\n\n/*\n// 2019 version - warning: overshoots in some places\nfloat sdSpike2D(vec2 p, float h)\n{\n    float d = p.y - (h*0.1)/(abs(p.x)+0.1);\n    d = min(d, length(p - vec2(0., min(h, p.y))));\n    float d2 = abs(p.x) - ((h*0.1)-0.1*p.y)/p.y;\n    if (p.y<h && d>0.0)\n        d = min(d, d2);\n    return d;\n}\n*/\n\n// visualization: smooth fract (from a comment by Shane)\nfloat sFract(float x, float s) {\n    float is = 1./s-.99;\n    x = fract(x);\n    return min(x, x*(1.-x)*is)+s*.5;\n}\n\n// visualization: color gradient\nvec3 distanceGradient(float d, float aa) {\n    vec3 ret = vec3(sFract(abs(d*6.), aa));\n    ret.x = 1. - smoothstep(-.5*aa, .5*aa, d);\n    ret *= exp(-1. * abs(d));\n    return ret;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2  p  = (2.*fragCoord-iResolution.xy)/iResolution.y + vec2(0., .75);\n    vec2  m  = (2.*iMouse.xy-iResolution.xy)/iResolution.y + vec2(0., .75);\n    \n    // spike params (see sdSpike comments)\n    float w = .1;\n    float h = sin(iTime)*.8+.8;\n\n    // distance with antialiasing\n    float d = sdSpike2D(p, w, h);\n    float d2 = sdSpike2D(p+1./iResolution.xy, w, h);\n    \n    // coloring\n    float aa = abs(d-d2)*20.;\n    vec3 col = distanceGradient(d, aa);\n    \n    // mouse interaction\n    if( iMouse.z>.001 )\n    {\n        d = sdSpike2D(m, w, h); \n        col = mix(col, vec3(1.,1.,0.), 1.0-smoothstep(0., .005, abs(length(p-m)-abs(d))-.0025));\n        col = mix(col, vec3(1.,1.,0.), 1.0-smoothstep(0., .005, length(p-m)-.015));\n    }\n   \n    fragColor = vec4(col,1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}