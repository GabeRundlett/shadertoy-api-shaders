{
    "Shader": {
        "info": {
            "date": "1611514731",
            "description": "color experiment with noise functions and time.",
            "flags": 0,
            "hasliked": 0,
            "id": "WlGyRt",
            "likes": 1,
            "name": "pretend it's a club",
            "published": 3,
            "tags": [
                "fractal",
                "noise",
                "simple",
                "fbm",
                "perlin",
                "gradient",
                "template",
                "function",
                "value",
                "cellular"
            ],
            "usePreview": 0,
            "username": "YitingLiu",
            "viewed": 309
        },
        "renderpass": [
            {
                "code": "// noise functions from youtube https://www.youtube.com/watch?v=ybbJz6C9YYA\n// git code https://github.com/Gonkee/Gonkees-Shaders/blob/master/noise%20textures.shader\n\n#define PI 3.14159265358979323846\n\nfloat rand(vec2 coord){\n    coord = mod(coord,10000.);\n    return fract(sin(dot(coord, vec2(12.9898,78.233)))*43758.5453);\n}\n\nfloat random (in float x) {\n    return fract(sin(x)*1e4);\n}\n\n\nvec2 rand2(vec2 coord){\n    coord = mod(coord,10000.);\n    return fract(sin( vec2( dot(coord,vec2(127.1,311.7)), dot(coord,vec2(269.5,183.3)) ) ) * 43758.5453);\n}\n\nfloat circle (in vec2 _st, in float _radius, in float _size){\n    vec2 dist = _st-vec2(0.5);\n    return smoothstep(_radius-_radius*_size,_radius+_radius*_size,dot(dist,dist)*4.0) ;       \n}\n\nfloat value_noise(vec2 coord){\n    vec2 i = floor(coord);\n    vec2 f = fract(coord);\n    \n    float tl = rand(i);\n    float tr = rand(i + vec2(1.,0.));\n    float bl = rand(i + vec2(0.,1.));\n    float br = rand(i + vec2(1.,1.));\n    \n    //linear distance will cause sharp transition \n    //use smoothstep or cubic function\n    \n    vec2 cubic = f*f*(3.-2.*f);\n    \n    float topmix = mix(tl,tr,cubic.x);\n    float botmix = mix(bl,br,cubic.x);\n    float wholemix = mix(topmix,botmix,cubic.y);\n    \n    return wholemix;\n\n}\n\nfloat perlin_noise(vec2 coord){\n    vec2 i = floor(coord);\n    vec2 f = fract(coord);\n    \n    float tl = rand(i) * 6.283;\n    float tr = rand(i + vec2(1.,0.))* 6.283;\n    float bl = rand(i + vec2(0.,1.))* 6.283;\n    float br = rand(i + vec2(1.,1.))* 6.283;\n    \n    vec2 tlvec = vec2(-sin(tl),cos(tl));\n    vec2 trvec = vec2(-sin(tr),cos(tr));\n    vec2 blvec = vec2(-sin(bl),cos(bl));\n    vec2 brvec = vec2(-sin(br),cos(br));\n    \n    float tldot = dot (tlvec,f);\n    float trdot = dot(trvec,f - vec2(1.,0.));\n    float bldot = dot(blvec, f- vec2(0.,1.));\n    float brdot = dot(brvec, f - vec2(1.,1.));\n    \n    // or delete the +0.5 after the wholemix - this shows different patterns \n    //tldot = abs(tldot);\n    ////trdot = abs(trdot);\n    //bldot = abs(bldot);\n    //brdot = abs(brdot);\n    \n    vec2 cubic = f*f*(3.-2.*f);\n    \n    float topmix = mix(tldot,trdot,cubic.x);\n    float botmix = mix(bldot,brdot,cubic.x);\n    float wholemix = mix(topmix,botmix,cubic.y);//maintain the brightness \n    \n    return wholemix+0.5;\n    \n}\n\nfloat cellular_noise(vec2 coord){\n   vec2 i = floor(coord);\n    vec2 f = fract(coord);\n    \n    float min_dist=9999.;\n   for(float x = -1.0; x <= 1.0; x++) {\n\t\tfor(float y = -1.0; y <= 1.0; y++) {\n        \n        vec2 node = rand2(i+vec2(x,y))+vec2(x,y);\n        float dist = sqrt((f-node).x*(f-node).x+(f-node).y*(f-node).y);\n        min_dist = min(min_dist,dist);\n       }\n    }\n    return min_dist;\n    \n}\n\n// can use it to combine with other noise functions \nfloat fbm(vec2 coord, int OCTAVES){\n    //for loop size \n    //int OCTAVES =4;\n    \n    float normalize_factor =0.;\n    float value =0.;\n    float scale = 0.5; \n    \n    for (int i =0; i< OCTAVES; i++){\n    value += cellular_noise(coord)*scale;\n    normalize_factor +=scale; \n    coord *=2.;\n    scale *= 0.5;\n    }\n    return value/normalize_factor; \n\n\n}\n   \nvec2 rotate2D (vec2 _st, float _angle) {\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += smoothstep(0.0,1.0,abs(sin(iTime)));\n    return _st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x);\n    vec2 coord = uv*10.*abs(tan(iTime))*rotate2D(uv,cos(iTime)*PI*5.);\n    vec3 color = vec3(0.);\n     \n    float noise;\n    //noise = rand(coord);\n    noise = value_noise(coord);\n   // noise = perlin_noise(coord);\n    noise = cellular_noise(coord);\n   //noise = fbm(coord,int(abs(tan(iTime))*2.));\n   \n   \n\nuv-=random(abs(sin(iTime)));\n    color= vec3(rotate2D(uv,cos(iTime)*PI*10.),0.8);\n  \n    color/= vec3(rotate2D(coord,clamp(0., PI/2.,tan(iTime/1e5)*PI)),noise);\n    color-=noise+random(smoothstep(0.1,1.,abs(cos(iTime))));\n    color*=vec3(random(abs(tan(iTime/1e5))),atan(coord.y,coord.x),noise/coord.y);\n  \n     uv+=random(abs(sin(iTime)));\n\n   \n\n    fragColor = vec4(color*uv.x,1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}