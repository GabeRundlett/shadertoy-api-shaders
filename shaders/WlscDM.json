{
    "Shader": {
        "info": {
            "date": "1592229918",
            "description": "Simple blobby cloud",
            "flags": 0,
            "hasliked": 0,
            "id": "WlscDM",
            "likes": 2,
            "name": "Simple Blobby Cloud 1",
            "published": 3,
            "tags": [
                "noise",
                "cloud",
                "perlin"
            ],
            "usePreview": 0,
            "username": "Leria",
            "viewed": 409
        },
        "renderpass": [
            {
                "code": "#define RADIUS 10.\n\n#define PI 3.14\n\n\n\n//iq noise\nfloat hash( float n )\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\t\n\tf = f*f*(3.0-2.0*f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\treturn mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t\t   mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n/////////////////////\n\nfloat fbm( vec3 p ) { // in [0,1]\n    float f;\n    f  = 0.5000*noise( p ); p = p*2.;\n    f += 0.2500*noise( p ); p = p*2.;\n    f += 0.1250*noise( p ); p = p*2.;\n    f += 0.0625*noise( p );\n    return f;\n}\n\n\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n\n#define transp current_transparency\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n \treturn length((pXp0)) - radius;   \n}\n\nvec3 cam = vec3(0., 0., 30.);\nfloat uniform_step = .1;\n\nvoid draw(vec3 dir, vec3 center, vec3 normal, float radius, inout vec3 c)\n{\n    float antialiasing = 1.;\n    //antialiasing = fract(1e4*sin(1e4*dot(dir, vec3(1., 7.1, 13.3)))); //Comment to see it without antialiasing/jittering\n    vec3 p = cam+dir*antialiasing;\n    int s = 0;\n        \n    float t = 1.;\n    float dist_acc = 0.;\n    \n    float perturbation = fbm(p*3.5);\n  \tfloat dens = perturbation;\n    vec3 rgb_t = vec3(transp(uniform_step, .15, dens), transp(uniform_step, .15, dens), transp(uniform_step, .15, dens));\n    \n\n    vec3 t_acc = vec3(1.);\t// accumulated transparency\n    \n    for(s; s < 120; s++)\n    {                       \n        float k_step = uniform_step;\n        \n        float dist_dist = dot(p-cam, p-cam);\n        float dist_center = length(center-cam);\n        \n        //if too far, then big step        \n        if(sqrt(dist_dist)-(dist_center-(radius+perturbation*10.)) < 0.)\n        {\n        \tk_step = dist_center-(radius);\n        }\n\n        //if in the shape, draw\n        if( sdf_sphere(p-center, RADIUS+perturbation*10.) <= 0.)\n        {            \n           \t//blending\n        \tc += t_acc*vec3(1.)*(1.-rgb_t);\n            dens = fbm(p);\n            //rgb_t = vec3(transp(uniform_step, .2, dens), transp(uniform_step, .2, dens), transp(uniform_step, .2, dens));\n\t\t\tt_acc *= rgb_t;  \n        }   \n                \n        //if it will never be in the shape anymore, return;\n        if(length(p-cam) >(dist_center+radius+perturbation*10.))\n        {\n         \tbreak;\n        }\n        \n        p += dir*k_step;       \n    }\n}\n\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    \n    vec3 color = vec3(.5, .5, .7);\n    vec2 m = (2.*PI * iMouse.xy/iResolution.xy - PI)/100.;\n    \n    vec3 ray_dir = vec3(uv, -1.);\n    vec3 C = cam, R = normalize(ray_dir);\n    C.xz *= rot2(m.x); C.yz *= rot2(m.y);\n    R.xz *= rot2(m.x); R.yz *= rot2(m.y);\n    cam = C;\n    draw(normalize(R), vec3(0., 0., 0.), vec3(0., 1., 0.), RADIUS, color);\n    \n    fragColor = vec4(color, 1.);\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}