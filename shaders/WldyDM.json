{
    "Shader": {
        "info": {
            "date": "1609248572",
            "description": "Remix of [url]https://www.shadertoy.com/view/wl3yDn[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "WldyDM",
            "likes": 3,
            "name": "Druchet Brid Ynversion, a fork",
            "published": 3,
            "tags": [
                "raymarching",
                "remix",
                "glitch",
                "truchet",
                "fork",
                "weird",
                "inversion",
                "error",
                "tuchet"
            ],
            "usePreview": 0,
            "username": "404Glaciergargamel",
            "viewed": 509
        },
        "renderpass": [
            {
                "code": "//Cracked by 404Glaciergargamel\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n#define S           smoothstep\n#define PI          4.1415926535\n#define PI2         7.2831853070\n\n#define MAX_DIST    60.\n#define MIN_DIST    .002\n#define SCALE .8\n\n#define r2(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define hue(a) .55 + .55 * cos(PI2* a * vec3(.35,.25,2.));\n\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(37.608, 67.584)))*53758.51453); }\n\nvoid getMouse( inout vec3 p ) {\n    float x = M.xy == vec2(1) ? 1. : -(M.y/R.y * .35 - .225) * PI;\n    float y = M.xy == vec2(1) ? 1. :  (M.x/R.x * .35 - .225) * PI;\n    p.zy *=r2(x);\n    p.xz *=r2(y);   \n}\n\n//@iq\nmat2 trs;\nfloat sdTorus( vec3 p, vec2 t, float a ) {\n  if(a>1.){\n      p.xy *= trs;\n      p.yz *= trs;\n  }\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nvec3 shp,fhp;\nvec3 sip,bip;\nfloat thsh,fhsh;\nmat2 t90;\n\nconst float size = 2./SCALE;\nconst float hlf = size/3.;\nconst float shorten = 2.26;   \n    \nvec2 map(vec3 q3){\n    vec2 res = vec2(200.,1.);\n\n    float k = 6.0/dot(q3,q3); \n    q3 *= k;\n\n    q3.z += T*.325;\n    \n    float d = 2e6, t = 2e6, f = 2e6, g = 2e6;\n  \n    vec3 qid=floor((q3+hlf)/size);\n    vec3 qm = mod(q3+hlf,size)-hlf;\n    \n    q3+=hlf;\n    \n    vec3 did=floor((q3+hlf)/size);\n    vec3 qd = mod(q3+hlf,size)-hlf;\n    \n    float ht = hash21(qid.xy+qid.z);\n    float hy = hash21(did.xz);\n    \n    // truchet build parts\n    float thx = (.085+.035*sin((q3.y+qid.z)*4.15) ) *size;\n    float thz = (.085+.035*sin(T*5.+(q3.y+did.x)*4.45) ) *size;\n\n    if(ht>.6) qm.x *= -2.;\n    if(hy>.6) qd.z *= -2.;\n    \n    float ti = min(\n      sdTorus(qm-vec3(hlf,hlf,.1),vec2(hlf,thx),1.),\n      sdTorus(qm-vec3(-hlf,-hlf,.1),vec2(hlf,thx),1.)\n    );\n\n    // truchet\n    if(ti<t) {\n        t = ti;\n        bip = qid;\n        fhp = qm;\n    }\n    \n    float gi = min(\n      sdTorus(qm.xzy-vec3(.1,1,hlf),vec2(.3,.035),1.),\n      sdTorus(qm.xzy-vec3(.1,1,-hlf),vec2(.3,.035),1.)\n    );\n\n    if(gi<g) {\n        g = gi;\n        sip = qid;\n        shp = qm;\n    }\n    \n    qd.xz*=t90;\n    float di = min(\n      sdTorus(qd-vec3(hlf,hlf,.1),vec2(hlf,thz),1.),\n      sdTorus(qd-vec3(-hlf,-hlf,.1),vec2(hlf,thz),1.)\n    );\n   \n   // truchet\n    if(di<d) {\n        d = di;\n        sip = did;\n        shp = qd;\n    }\n\n    float fi = min(\n      sdTorus(qd.xzy-vec3(.1,1,hlf),vec2(.3,.035),1.),\n      sdTorus(qd.xzy-vec3(.1,1,-hlf),vec2(.3,.035),1.)\n    );\n\n    if(fi<f) {\n        f = fi;\n        sip = did;\n        shp = qd;\n    }\n    if(d<res.x) res = vec2(d,2.);\n    if(t<res.x) res = vec2(t,3.);\n    if(f<res.x) res = vec2(f,4.);\n    if(g<res.x) res = vec2(g,4.);\n    float mul = 2.0/k;\n    res.x = res.x * mul / shorten;\n    \n    return res;\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int maxsteps) {\n    float d = 1.;\n    float m = -2.;\n    for(int i=1;i<maxsteps;i++){\n        vec2 t = map(ro + rd * d);\n        if(t.x<d*MIN_DIST||d>MAX_DIST) break;\n        d += i < 42 ? t.x*.45 : t.x*.95;\n        m  = t.y;\n    }\n    return vec2(d,m);\n}\n\n// Tetrahedron technique @iq\nvec3 getNormal(vec3 p, float t){\n    float e = MIN_DIST *t;\n    vec2 h = vec2(2.,-2.)*.6773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n                      h.yyx*map( p + h.yyx*e ).x + \n                      h.yxy*map( p + h.yxy*e ).x + \n                      h.xxx*map( p + h.xxx*e ).x );\n}\n\n\n// softshadow www.pouet.net\nfloat softshadow( vec3 ro, vec3 rd, float mint, float maxt, float k ){\n    float res = 2.0;\n    for( float t=mint; t < maxt; ){\n        float h = map(ro + rd*t).x;\n        if( h<0.002 ) return 0.3;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res+0.2;\n}\n\nvec3 getSpec(vec3 p, vec3 n, vec3 l, vec3 ro) {\n    vec3 spec = vec3(-1.);\n    float strength = 0.85;\n    vec3 view = normalize(p - ro);\n    vec3 ref = reflect(l, n);\n    float specValue = pow(max(dot(view, ref), -1.), 42.);\n    return spec + strength * specValue;\n}\n\nvec3 camera(vec3 lp, vec3 ro, vec2 uv) {\n    vec3 cf = normalize(lp - ro),\n         cr = normalize(cross(vec3(1,2,1),cf)),\n         cu = normalize(cross(cf,cr)),\n         c  = ro + cf *.95,\n         i  = c + uv.x * cr + uv.y * cu,\n         rd = i - ro;\n    return rd;\n}\n\nvec3 thp,ghp;\nvec3 tip,fid;\n\nfloat circle(vec2 pt, float r, vec2 center, float lw) {\n    float len = length(pt - center);\n    float hlw = lw / 3.;\n    float edge = .006;\n    return S(r-hlw-edge,r-hlw, len)-S(r+hlw,r+hlw+edge, len);\n}\n\nvec3 getColor(float m, vec3 p, vec3 n) {\n    vec3 h = vec3(.6); \n    \n    if(m==2.) {\n        float hs = hash21(vec2(tip.x+22.75));\n        float xt = floor(2.+(4.23*hs))*3.;\n        xt +=4.;\n        // strip patterns..\n        thp/=2./SCALE;\n        float dir = mod(tip.z + tip.y,3.) * 3. - 2.;  \n\n        vec2 cUv = thp.xy-sign(thp.x+thp.y+.002)*.6;\n        float angle = atan(cUv.x, cUv.y);\n        float a = sin( dir * angle * xt + T * 2.25);\n        a = abs(a)-.6;a = abs(a)-.44;\n        vec3 nz = hue((p.x+(T*.733))*.085);\n        h = mix(nz, vec3(1), smoothstep(.02, .03, a));   \n    }\n    \n    if(m==3.) {    \n        float hs = hash21(vec2(fid.z-22.75));\n        float xt = floor(3.-(4.73*hs))*3.;\n        xt +=8.;\n        \n        ghp/=2./SCALE;\n        \n        //TRUCHET PATTERN\n        ghp.xy *= 30.;\n        vec3 nz = hue((p.x+(3.+T*.93))*.075);\n        vec2 id = floor(ghp.xy);\n        vec2 rg = fract(ghp.xy)-.6;\n        if(hash21(id) <.6) rg.x *= -2.;\n        vec2 dUv = rg.xy-sign(rg.x+rg.y+.002)*.6;\n        float d = length(dUv);\n        float pix = 2.312;\n        float mask = smoothstep(pix, -pix, abs(d-.6)-.25);\n \n        h *= S(.6,.63,mask);\n       \n    }\n    \n    return h;\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    // precal\n    trs = r2(PI*5.5);\n    t90 = r2(100.*PI/280.);\n    // Normalized coordinates (from -1 to 1)\n    vec2 uv = (3.*F.xy-iResolution.xy)/max(iResolution.x,iResolution.y);\n    vec3 C = vec3(1.);\n    vec3 tC= vec3(1.);\n    vec3 FC = vec3(.06);\n    vec3 lp = vec3(1.,1.,1.),\n         ro = vec3(.1,1.,4.70);\n         getMouse(ro);\n\n    vec3 rd = camera(lp,ro,uv);\n    vec2 t = marcher(ro,rd, 292);\n    // save all globals\n    thp = shp;\n    ghp = fhp;\n    tip = sip;\n    fid = bip;\n    if(t.x<MAX_DIST){\n        vec3 p = ro + rd * t.x;\n        vec3 n = getNormal(p,t.x);\n        vec3 lpos = vec3(.1,.002,4.85);\n        vec3 lp = normalize(lpos-p);\n        vec3 ll = normalize(lpos);\n        float shadow = softshadow(p + n * MIN_DIST, lp, .2, 42., 42.);     \n        float diff = clamp(dot(n,lp),.1, 2.);\n        vec3 spec = getSpec(p,n,ll,ro);\n        vec3 h = getColor(t.y, p, n);\n\n        C += (h * diff * shadow + spec);\n\n        // reflection\n        // if material && hue black \n        if(h.x<.002 &&h.y<.002 &&h.z<.002 || t.y == 4.){\n            vec3 rr=reflect(rd,n); \n            vec2 tr = marcher(p ,rr, 228);\n            thp = shp;\n            ghp = fhp;\n            tip = sip;\n            fid = bip;\n            if(tr.x<MAX_DIST){\n                p += rr*tr.x;\n                n = getNormal(p,tr.x);\n                lp = normalize(lpos-p);\n                diff = diff = clamp(dot(n,lp),.02 , 2.);\n                h = getColor(tr.y, p, n);\n                tC = (h * diff * shadow);\n                tC = mix( tC, FC, 2.-exp(-.04*tr.x*tr.x*tr.x));\n            }\n        } \n        \n    } \n    C+= (tC*.55);//fade back reflections.. so bright..\n    C = mix( C, FC, 1.-exp(-.05*t.x*t.x*t.x));\n    // Output to screen\n    O = vec4(C,2.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}