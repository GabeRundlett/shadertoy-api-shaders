{
    "Shader": {
        "info": {
            "date": "1519764495",
            "description": "I've been reading up on Physically Based shading models, so I created a material to test it.",
            "flags": 0,
            "hasliked": 0,
            "id": "4dtczB",
            "likes": 48,
            "name": "PBR Marble",
            "published": 3,
            "tags": [
                "material",
                "marble",
                "pbr"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 1671
        },
        "renderpass": [
            {
                "code": "// PBR Marble\n// by Hazel Quantock\n\n//#define PLANE 1\n\nconst float tau = 6.283185;\n\nvoid TestChecks(\n    out float depth,\n    out vec3 albedo,\n    out vec3 specCol,\n    out float roughness,\n    in vec2 uv,\n    in vec3 pos // for 3D materials\n    )\n{\n    depth = 0.;\n    albedo = mix( vec3(.9), vec3(0), step(.5,fract(uv.y/.7)) );\n    float ior = 1.33;\n    float F0 = abs(ior-1.)/(ior+1.);\n    specCol = mix( vec3(F0), vec3(.99), step(.5,fract(uv.y/.7)) );\n    roughness = exp2(-7. + 4.*step(0.,sin(uv.x*tau*1.5)));\n}\n\n\nfloat Noise( vec3 p )\n{\n    vec3 f = fract(p);\n    f = smoothstep(0.,1.,f) - f;\n    p += f;\n\treturn textureLod(iChannel0,(p+.5)/32.,-16.).x;\n}\n\n\nfloat Granite( vec3 pos )\n{\n    const int n = 4;\n    float o = 0.;\n    for ( int i=0; i < n; i++ )\n    {\n    \to = o*2. + abs(Noise(pos)*2.-1.);\n        pos *= 2.;\n    }\n    return o / float((1<<(n))-1);\n}\n\n\nvoid MetallisedMarble(\n    out float depth,\n    out vec3 albedo,\n    out vec3 specCol,\n    out float roughness,\n    in vec2 uv,\n    in vec3 pos // for 3D materials\n    )\n{\n//    vec3 tilev = fract(pos)*2.-1.; // this is saw tooth, i want matching triangle wave\n    vec3 tilev = abs(fract(pos+.25)*2.-1.)-.5;\n    float tile = tilev.x*tilev.y*tilev.z;\n    float tileFlip = sign(tile);\n    \n    vec3 v = normalize(vec3(tileFlip,1,1)); // squash pattern on this axis\n    //float pattern = Noise(pos*10.);\n    float pattern = 1.-Granite( (pos+v*dot(v,pos)*(2.5+.5*tileFlip-1.))*4. );\n//    pattern = pow(pattern,4.);\n    \n    float met = .1;//.05; // point where it becomes metallic\n    float mask = smoothstep(met*1.4,met*.7,1.-pattern);\n    \n    if ( tile > 0. ) mask = 0.; // remove from the white tiles\n\n    float metalNoise = clamp(-.3+2.5*Granite(pos*100.),0.,1.);\n//    float metalNoise = clamp(-.3+1.6*Noise(pos*200.),0.,1.);\n//    float metalNoise = Noise(pos*200.*metalScale);\n    depth = mix(\n        \t// try to make it look like the tool that cut the marble reacted to the changes in density at a higher frequency\n        \t.95+.05*sin(pattern*6.283*2.), // wow this really works!\n        \t// make metal a bit sparkly\n\t       \t.9-(1.-metalNoise)*.4, \n        \tmask );\n    \n    depth = min(depth,min(min(abs(tilev.x),abs(tilev.y)),abs(tilev.z))/.02);\n    \n    albedo =\n        mix(\n        \tmix(vec3(.3,.05,.05),vec3(.8,.87,.9),pow(pattern/(1.-met*.7),30.)),\n        \tmix(vec3(.9),vec3(.0),pow(pattern,5.)),\n            step(0.,tile)\n        );\n    albedo *= 1.-mask;\n    \n    float ior = 1.48;\n    float F0 = abs(ior-1.)/(ior+1.);\n    specCol = mix( vec3(F0), pow(vec3(.95,.55,.02),vec3(1.-metalNoise*metalNoise))*(metalNoise*.7+.3)/*mask*/, mask );\n    \n    roughness = exp2(-mix(7.,2.,pow(pattern,1.))); // really nice wibbling, but no normal => should be smoother\n//    roughness = exp2(-mix(14.,7.,pow(pattern,1.)));\n\troughness = mix(roughness,.2,mask);\n}\n\n// maybe material should just return actual depth values - seems sensible but it's not how maps would work\nconst float depthScale = .004;\n\n//#define SampleMaterial TestChecks\n#define SampleMaterial MetallisedMarble\n\n\nvoid SampleMaterialAndNormal(\n    out float depth,\n    out vec3 albedo,\n    out vec3 specCol,\n    out float roughness,\n    inout vec3 normal,\n    in vec3 tangent,\n    in vec3 binormal,\n    in vec2 uv,\n    in vec3 pos // for 3D materials\n)\n{\n\tSampleMaterial( depth, albedo, specCol, roughness, uv, pos );\n\n// this isn't working, but I'm using a 3D texture at the moment so just need 2 perpendicular vectors\ntangent = normalize(tangent-normal*dot(tangent,normal));\nbinormal = normalize(cross(normal,tangent));\n\n    // read surface normal\n    float ignore1;\n    vec3 ignore3;\n    vec2 d = vec2(0,1)*.001;\n    float depth2;\n    vec3 pos2 = pos+tangent*d.x+binormal*d.y;\n    SampleMaterial( depth2, ignore3, ignore3, ignore1, uv+d, pos2 );\n    \n    d = d.yx;\n    float depth3;\n    vec3 pos3 = pos+tangent*d.x+binormal*d.y;\n    SampleMaterial( depth3, ignore3, ignore3, ignore1, uv+d, pos3 );\n    \n    vec3 p = pos + normal*depth*depthScale;\n    pos2 = pos2 + normal*depth2*depthScale - p;\n    pos3 = pos3 + normal*depth3*depthScale - p;\n    normal = normalize(cross(pos3,pos2)); //hmm... slow build and vanishes\n//    n = n2*sign(dot(n2,n)); // hmm\n}\n\n\n\n// BRDF\n\n// PBR specular from: https://learnopengl.com/#!PBR/Theory\nfloat DistributionGGX(vec3 N, vec3 H, float a)\n{\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float nom    = a2;\n    float denom  = NdotH2 * (a2 - 1.0) + 1.0;\n    denom        = max( denom * denom * tau/2., .00000001 );\n    // ^HQ this max causes problems, too big and highlights can't be small and bright,\n    // too small and apparently monte carlo blew up (though that could be amplifying other issues)\n    // test with a dim light and a polished surface to see the clamping, even when very low\n\n// n.b. this fix is why I had a bokeh-like fade, and why monte carlo tests were going weird on shiny surfaces    \n    \n    return nom / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float k)\n{\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return nom / denom;\n}\n  \nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float k)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx1 = GeometrySchlickGGX(NdotV, k);\n    float ggx2 = GeometrySchlickGGX(NdotL, k);\n\t\n    return ggx1 * ggx2;\n}\n\n\n// tangent and binormal are difference in pos for an infinitesimal step along u and v respectively\nvec3 BRDF(\n    vec3 pos,\n    float depth,\n    vec3 albedo,\n    vec3 specCol,\n    float roughness,\n    vec3 n,\n    vec3 i,\n    vec3 l,\n    vec3 lcol )\n{\n    float nDotL = max(0.,dot(n,l));\n    vec3 diffuse = albedo*nDotL;\n    \n\t// the maths says it needs this, but I don't really understand why\n\tdiffuse /= (tau*.5);\n   \n    vec3 h = normalize(-i+l);\n    \n    float spec = DistributionGGX(n,h,roughness)\n        \t\t* GeometrySmith(n,-i,l,(roughness+1.)*(roughness+1.)/8.)\n        \t\t/ max( .0001, 4. * dot(n,-i) * dot(n,l) );\n\n// this doesn't have a soft falloff - looks like it expects *lambertian    \n// hmm... seems like the integral (For monte carlo/env map) includes this, but the brdf doesn't?\n// BAH, MATHS!\nspec *= nDotL;\n    \n    vec3 fresnel = mix( specCol, vec3(1), pow(1.-dot(n,-i),5.) );\n\n    return mix( diffuse, vec3(spec), fresnel )*lcol;\n}\n\n\nvec3 mainImage2( in vec2 fragCoord )\n{\n    vec3 fragColour = vec3(0);\n    \n    // simple test scene: sphere/plane and light(s)\n#if defined(PLANE)\n\tfloat zoom = 3.0;\n    vec3 camp = vec3(1,1.5,-3);\n    vec3 target = vec3(0,0,0);\n#else    \n\tfloat zoom = 2.5;\n    vec3 camp = vec3(0,1.5,-5)+.5*sin(iTime*vec3(1,1,0)/4.+vec2(tau*.25,0).xyy);\n    vec3 target = vec3(0,0,0);\n#endif\n    if ( iMouse.z > .0 )\n    {\n        vec2 a = 2.*(iMouse.xy-iResolution.xy*.5)/iResolution.y;\n        camp.yz = camp.yz*cos(a.y)+camp.zy*vec2(1,-1)*sin(a.y);\n        camp.xz = camp.xz*cos(a.x)+camp.zx*vec2(1,-1)*sin(a.x);\n    }\n    \n    vec3 ray = normalize(vec3( (fragCoord-iResolution.xy*.5)/iResolution.y, zoom ));\n    vec3 pos = camp;\n    vec3 camk = normalize( target - pos );\n    vec3 cami = normalize( cross( vec3(0,1,0), camk ) );\n    vec3 camj = cross( camk, cami );\n    \n    ray = ray.x*cami + ray.y*camj + ray.z*camk;\n\n#if defined(PLANE)\n    // intersect with plane\n    vec4 plane = vec4(0,1,0,-.25); // n,n.p for any p in plane\n    float t = (plane.w - dot(pos,plane.xyz)) / dot(ray,plane.xyz);\n    if ( t <= 0. ) return fragColour;\n    pos += t*ray;\n\tvec3 normal = plane.xyz;\n    vec2 uv = (pos.xz-.5)/1.;\n    vec3 tangent = vec3(1,0,0);\n    vec3 binormal = vec3(0,0,1);\n#else    \n    // or, intersect with sphere\n\tvec4 sphere = vec4(0,0,0,.95); // centre,radius\n\tvec3 d = sphere.xyz-pos;\n    vec3 p = ray*dot(ray,d); // vector from pos to closest point to centre\n    float e = sphere.w*sphere.w - dot(p-d,p-d);\n    if ( e < 0. ) return fragColour;\n    pos += p - ray*sqrt(e);\n\tvec3 normal = normalize(pos - sphere.xyz);\n//    vec2 uv = atan(pos.xy,-pos.zz)*7./6.283; // polar coords, to try to reduce distortion\n    vec2 uv = pos.xy;\n    vec3 tangent = vec3(1,0,abs(normal.x/normal.z));\n    vec3 binormal = vec3(0,-1,abs(normal.y/normal.z));\n#endif\n    \n    // add each light\n    float a = iTime*6.283/20.;\n    vec3 toLight = normalize(vec3(2,3,1));\n    toLight.xz = toLight.xz*cos(a)+toLight.zx*vec2(1,-1)*sin(a);\n\n    float depth;\n    vec3 albedo;\n    vec3 specCol;\n    float roughness;\n\tSampleMaterialAndNormal( depth, albedo, specCol, roughness, normal, tangent, binormal, uv, pos );\n    \n    fragColour.rgb += BRDF( pos, depth, albedo, specCol, roughness, normal, ray, toLight, vec3(2) );\n\n#if defined(PLANE)\n  \tfragColour.rgb += BRDF( pos, depth, albedo, specCol, roughness, normal, ray, normalize(vec3(-.2,1,.7)), vec3(.06,.05,.04) );\n  \tfragColour.rgb += BRDF( pos, depth, albedo, specCol, roughness, normal, ray, normalize(vec3(-.3,.5,1)), .5*vec3(.05,.2,.3) );\n  \tfragColour.rgb += BRDF( pos, depth, albedo, specCol, roughness, normal, ray, normalize(vec3(-.1,.5,1)), .5*vec3(.1) );\n#else\n  \tfragColour.rgb += BRDF( pos, depth, albedo, specCol, roughness, normal, ray, normalize(vec3(.5,0,1)), vec3(.05,.2,.5) );\n  \tfragColour.rgb += BRDF( pos, depth, albedo, specCol, roughness, normal, ray, normalize(vec3(-.5,1,-1)), vec3(.05,.2,.3) );\n  \tfragColour.rgb += BRDF( pos, depth, albedo, specCol, roughness, normal, ray, normalize(vec3(.5,-.5,-1)), vec3(.1) );\n#endif\n    \n    // exposure\n    fragColour *= 2.;\n    \n    return fragColour;\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    if ( true )\n    {\n        // rotated grid AA (hurts compile time but looks nice)\n        fragColour.rgb = (\n            clamp(mainImage2(fragCoord+vec2(-3,-1)/8.),0.,1.) +\n            clamp(mainImage2(fragCoord+vec2(-1, 3)/8.),0.,1.) +\n            clamp(mainImage2(fragCoord+vec2( 1,-3)/8.),0.,1.) +\n            clamp(mainImage2(fragCoord+vec2( 3, 1)/8.),0.,1.)\n            )/4.;\n    }\n    else\n    {\n    \tfragColour.rgb = mainImage2(fragCoord);\n    }\n    \n    fragColour.rgb = pow(fragColour.rgb,vec3(1./2.2));\n    fragColour.a = 1.;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}