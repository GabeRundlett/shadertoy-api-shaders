{
    "Shader": {
        "info": {
            "date": "1617207177",
            "description": "Distancefield raytracing on a 3D manifold given as the graph of a function f(x,y,z). You can also implement your own! This is done with automatic differentiation. Mouse and WASD to move! More info at the top of the shader!",
            "flags": 48,
            "hasliked": 0,
            "id": "fdBGDz",
            "likes": 13,
            "name": "Geodesic raytracer",
            "published": 3,
            "tags": [
                "riemann",
                "metric",
                "geodesic",
                "automaticdifferentiation",
                "manifold"
            ],
            "usePreview": 0,
            "username": "sibaku",
            "viewed": 588
        },
        "renderpass": [
            {
                "code": "//********************************************************************\n//\n// INSTRUCTIONS:\n//\n// This shader implements basic distancefield raytracing of a regular grid on\n// a 3D manifold given as the graph of a function f(x,y,z).\n//\n// Click and drag the mouse to look around. WASD for movement. You are moving\n// through distorted space, so you might not move in a straight line, but\n// instead move along the shortest paths in curved space.\n// Press \"R\" to reset the view.\n//\n// WARNING: The space-bending and movement might be a bit nauseating. I tried to\n// not make stuff move too fast, but wanted to give a short warning anyways.\n\n// DISPLAY OPTIONS:\n// Below you can find a few defines to control the look of the grid, background\n// and general tracing\n//\n// FUNCTIONAL OPTIONS\n// The actual function is defined in the common shader part under \"Metric\n// functions\".  A few functions are predefined, but you can implement your own\n// in \"HessNum3 fCustom(in HessNum3 x, in HessNum3 y, in HessNum3 z, float\n// globalTime)\". Just comment in the one you want to see or comment all of them\n// out to use the custom function. Additional information can be found there as\n// well.\n//\n// Note: As calculating the metric from the function requires 1st and 2nd order\n// derivatives and it would be cumbersome to calculate and implement them for\n// each function, I use automatic differentiation, which is why you need to use\n// the special types and operations defined in the automatic differentiation\n// header below to implement your own f.\n//\n//\n//********************************************************************\n\n// Maximum number of trace steps\n// Higher step number will let you look farther, especially with higher\n// deformations\n#define MAX_STEPS 100\n// The maximum length traversed per step. Lower values produce higher quality\n// paths through the curved space\n#define STEP_LENGTH 0.4\n\n// Grid parameters\n#define GRID_SIZE 5.0\n#define GRID_THICKNESS 0.2\n\n// Linear fog parameters\n#define FOG_MAX_DIST 50.0\n#define FOG_MIN_DIST 10.0\n#define FOG_COLOR vec3(0.1)\n\n// Surface epsilon\n#define EPS 0.005\n\n//********************************************************************\n//\n// Distance helpers and tracing\n//\n//********************************************************************\n#define INF 3.402823466e+38\n\nfloat sdf(in vec3 p);\n\n// Tracing function\nbool trace(inout vec3 p, in vec3 dir, out float t, out int steps) {\n\n  steps = 0;\n  t = 0.0;\n\n  for (int n = 0; n < MAX_STEPS && t < FOG_MAX_DIST; n++) {\n\n    float d = sdf(p);\n\n    if (d < EPS) {\n      return true;\n    }\n\n    // make step length dependent on distance field to not miss geometry, but\n    // also use EPS as a min step\n    float s = max(EPS, min(d, STEP_LENGTH));\n\n    // \"acceleration\" of a particle traveling along the geodesic\n    vec3 vp = compute_update(p, dir, iTime);\n\n    // euler integration\n    dir += vp * s;\n    // position euler step\n    p += dir * s;\n\n    // maybe not fully correct, but try to preserve arc length by normalizing\n    // dir\n    dir = normalize(dir);\n\n    // length traveled, used for fog\n    t += s;\n\n    steps++;\n  }\n\n  return false;\n}\n\nfloat sdfBox2d(vec2 p, vec2 b);\nfloat sdfGrid(vec3 p, vec3 cellSize, vec3 gridHalfLength);\nvec3 normal(in vec3 p);\n\n//********************************************************************\n//\n// Image formation\n//\n//********************************************************************\n\nvec3 shade(in vec3 P, in vec3 N, in vec3 color, in vec3 LPos);\n\nfloat simpleColor(float coord, float gridSize, float repetition);\n\nvec4 loadValue(in ivec2 re) { return texelFetch(iChannel0, re, 0); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n  vec2 uv = fragCoord.xy / iResolution.xy;\n\n  float aspect = iResolution.x / iResolution.y;\n\n  vec3 rayDir;\n  vec3 p;\n\n  {\n    vec2 thetaPhi = loadValue(D_thetaPhi).xy;\n    float theta = thetaPhi.x;\n    float phi = thetaPhi.y;\n\n    vec3 eye = loadValue(D_pos).xyz;\n    // vec3 eye = vec3(0.0);\n    vec3 center =\n        eye + vec3(sin(theta) * sin(phi), cos(theta), sin(theta) * cos(phi));\n    // inverse projection and view matrices\n    mat4 PInv = perspectiveInv(radians(90.), aspect, 0.1, 100.);\n    mat4 VInv = lookAtInv(eye, center, vec3(0., 1., 0.));\n\n    rayDir = createRay(uv, PInv, VInv);\n    p = eye;\n  }\n\n  float t = 0.0;\n  int steps = 100;\n\n  vec3 col = vec3(0.0);\n\n  if (trace(p, rayDir, t, steps)) {\n    vec3 N = normal(p);\n\n    col =\n        vec3(simpleColor(p.x, GRID_SIZE, 3.0), simpleColor(p.y, GRID_SIZE, 7.0),\n             simpleColor(p.z, GRID_SIZE, 11.0));\n\n    vec3 LPos = vec3(1.0, 2.0, 0.0);\n    col = shade(p, N, col, LPos);\n\n  } else {\n    t = INF;\n  }\n\n  // simple linear fog\n  float fogFactor = (FOG_MAX_DIST - t) / (FOG_MAX_DIST - FOG_MIN_DIST);\n  fogFactor = clamp(fogFactor, 0.0, 1.0);\n  col = mix(FOG_COLOR, col, fogFactor);\n\n  fragColor = vec4(col, 1.0);\n}\n\n//***************\n\nfloat sdfBox2d(vec2 p, vec2 b) {\n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdfGrid(vec3 p, vec3 cellSize, vec3 gridHalfLength) {\n  vec3 pg = floor(p / cellSize) * cellSize;\n\n  vec3 center = pg + cellSize * 0.5;\n\n  float d = sdfBox2d(p.xz - center.xz, gridHalfLength.xz);\n  d = min(d, sdfBox2d(p.xy - center.xy, gridHalfLength.xy));\n  d = min(d, sdfBox2d(p.yz - center.yz, gridHalfLength.yz));\n  return d;\n}\n\nfloat sdf(in vec3 p) {\n  float d = sdfGrid(p, vec3(GRID_SIZE), vec3(GRID_THICKNESS));\n  return d;\n}\n\nvec3 normal(in vec3 p) {\n  return normalize(\n      vec3(sdf(p + vec3(EPS, 0., 0.)) - sdf(p - vec3(EPS, 0., 0.)),\n           sdf(p + vec3(0., EPS, 0.)) - sdf(p - vec3(0., EPS, 0.)),\n           sdf(p + vec3(0., 0., EPS)) - sdf(p - vec3(0., 0., EPS))));\n}\n\n//********************************************************************\n//\n// Shading and main\n//\n//********************************************************************\nvec3 shade(in vec3 P, in vec3 N, in vec3 color, in vec3 LPos) {\n  vec3 L = normalize(LPos - P);\n  // simple two sided diffuse shading\n  return color * clamp(abs(dot(L, N)), 0.0, 1.0);\n}\n\nfloat simpleColor(float coord, float gridSize, float repetition) {\n\n  float cr = (gridSize * 0.5 - coord) / gridSize;\n\n  float v = pow(sin(PI * cr / 2.0), 2.0);\n\n  return v;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Data load/store from https://www.shadertoy.com/view/Ms3XWN\n\nvoid storeValue(in ivec2 re, in vec4 va, inout vec4 fragColor,\n                in ivec2 fragCoord) {\n  fragColor = (re.x == fragCoord.x && re.y == fragCoord.y) ? va : fragColor;\n}\nvec4 loadValue(in ivec2 re) { return texelFetch(iChannel0, re, 0); }\n\nbool isKeyPressed(int key) {\n  return texelFetch(iChannel1, ivec2(key, 1), 0).x == 1.0;\n}\n\nbool isKeyDown(int key) {\n  return texelFetch(iChannel1, ivec2(key, 0), 0).x == 1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n  ivec2 ifragCoord = ivec2(fragCoord - 0.5);\n\n  // skip processing outside of data\n  if (ifragCoord.x > 6)\n    discard;\n\n  float deg2Rad = PI / 180.0;\n\n  // reset with R\n  if (iFrame == 0 || isKeyPressed(82)) {\n    storeValue(D_thetaPhi, vec4(90.0 * deg2Rad, 0.0, 0.0, 0.0), fragColor,\n               ifragCoord);\n    storeValue(D_lastMouse, vec4(-1.0), fragColor, ifragCoord);\n    storeValue(D_pos, vec4(0.0), fragColor, ifragCoord);\n    return;\n  }\n\n  vec4 thetaPhi = loadValue(D_thetaPhi);\n  vec4 lastMouse = loadValue(D_lastMouse);\n\n  // click and drag camera movement\n  if (iMouse.z > 0.0 && lastMouse.z > 0.) {\n    vec2 dm = (iMouse.xy - lastMouse.xy) / iResolution.xy;\n    thetaPhi.y -= dm.x * 2.0 * PI;\n    thetaPhi.x -= dm.y * PI;\n    thetaPhi.x = clamp(thetaPhi.x, 5.0 * deg2Rad, PI - 5.0 * deg2Rad);\n  }\n  lastMouse = iMouse;\n\n  vec4 pos = loadValue(D_pos);\n\n  {\n    float theta = thetaPhi.x;\n    float phi = thetaPhi.y;\n\n    vec3 dir = vec3(sin(theta) * sin(phi), cos(theta), sin(theta) * cos(phi));\n    mat4 VInv = lookAtInv(pos.xyz, pos.xyz + dir, vec3(0., 1., 0.));\n    vec3 right = (VInv * vec4(1.0, 0.0, 0.0, 0.0)).xyz;\n\n    vec3 move = vec3(0.0);\n\n    if (isKeyDown(87)) // W\n    {\n      move += dir;\n    }\n    if (isKeyDown(83)) // A\n    {\n      move -= dir;\n    }\n    if (isKeyDown(65)) // S\n    {\n      move -= right;\n    }\n    if (isKeyDown(68)) // D\n    {\n      move += right;\n    }\n\n    if (dot(move, move) > 0.0) {\n      move = normalize(move);\n      const int numSteps = 5;\n      const float speed = 2.0;\n      float stepLength = speed * iTimeDelta / float(numSteps);\n\n      // movement through the distorted space should be done in the same way as\n      // with the view rays\n      for (int i = 0; i < numSteps; i++) {\n        vec3 vp = compute_update(pos.xyz, move, iTime);\n        // euler integration\n        move += vp * stepLength;\n        // position euler step\n        pos.xyz += move * stepLength;\n        // should be very small step lengths so we skip normalization\n      }\n    }\n  }\n\n  storeValue(D_thetaPhi, thetaPhi, fragColor, ifragCoord);\n  storeValue(D_lastMouse, lastMouse, fragColor, ifragCoord);\n  storeValue(D_pos, pos, fragColor, ifragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n//********************************************************************\n//\n// Begin of automatic differentiation header\n// Full code with additional functions (gradients, jacobians, ...) can be found\n// at: https://github.com/sibaku/glsl-autodiff\n//\n//********************************************************************\n#ifndef HESSNUM_3_H_\n#define HESSNUM_3_H_\n\n// This file contains methods to compute the gradient and hessian \n// of a scalar valued 3 dimensional function using automatic forward differentiation\n\n//--------------------------------\n// Types\n//--------------------------------\n\n// Data type to hold information about a scalar valued 3 dimensional function\n// These should be created by the constH3 (for constants) and varH3 (for variables) helpers\nstruct HNum3\n{\n    // The current value\n    float val;\n    // The current gradient\n    vec3 g;\n    // The current hessian\n    mat3 h;\n};\n\n//--------------------------------\n// Prototypes\n//--------------------------------\n\n/**\n* Creates a constant HNum3\n* @param val The current value of the constant\n*/\nHNum3 constH3(in float val);\n/**\n* Creates a HNum3 corresponding to the variable with the given index\n* @param val The current value of the variable\n* @param index The variable's index\n*/\nHNum3 varH3(in float val, in int index);\n/**\n* Creates a HNum3 corresponding to the variable x (index = 0)\n* @param val The current value of the variable\n*/\nHNum3 varH3x(in float val);\n/**\n* Creates a HNum3 corresponding to the variable y (index = 1)\n* @param val The current value of the variable\n*/\nHNum3 varH3y(in float val);\n/**\n* Creates a HNum3 corresponding to the variable z (index = 2)\n* @param val The current value of the variable\n*/\nHNum3 varH3z(in float val);\nHNum3 add(in HNum3 a, in HNum3 b);\nHNum3 add(in HNum3 a, in float b);\nHNum3 add(in float a, in HNum3 b);\nHNum3 sub(in HNum3 a, in HNum3 b);\nHNum3 sub(in HNum3 a, in float b);\nHNum3 sub(in float a, in HNum3 b);\nHNum3 mult(in HNum3 a, in HNum3 b);\nHNum3 mult(in HNum3 a, in float b);\nHNum3 mult(in float a, in HNum3 b);\nHNum3 neg(in HNum3 a);\nHNum3 div(in HNum3 a, in HNum3 b);\nHNum3 div(in HNum3 a, in float b);\nHNum3 div(in float a, in HNum3 b);\nHNum3 inv(in HNum3 a);\nHNum3 a_pow(in HNum3 a, in HNum3 b);\nHNum3 a_pow(in HNum3 a, in float b);\nHNum3 a_pow(in float a, in HNum3 b);\nHNum3 a_min(in HNum3 a, in HNum3 b);\nHNum3 a_max(in HNum3 a, in HNum3 b);\nHNum3 a_exp2(in HNum3 a);\nHNum3 a_inversesqrt(in HNum3 a);\nHNum3 a_atan(in HNum3 a);\nHNum3 a_sqrt(in HNum3 a);\nHNum3 a_sinh(in HNum3 a);\nHNum3 a_ceil(in HNum3 a);\nHNum3 a_tan(in HNum3 a);\nHNum3 a_asinh(in HNum3 a);\nHNum3 a_asin(in HNum3 a);\nHNum3 a_acosh(in HNum3 a);\nHNum3 a_abs(in HNum3 a);\nHNum3 a_exp(in HNum3 a);\nHNum3 a_cosh(in HNum3 a);\nHNum3 a_floor(in HNum3 a);\nHNum3 a_log(in HNum3 a);\nHNum3 a_atanh(in HNum3 a);\nHNum3 a_log2(in HNum3 a);\nHNum3 a_acos(in HNum3 a);\nHNum3 a_tanh(in HNum3 a);\nHNum3 a_cos(in HNum3 a);\nHNum3 a_sin(in HNum3 a);\nHNum3 a_atan2(in HNum3 y, in HNum3 x);\nHNum3 a_atan2(in HNum3 y, in float x);\nHNum3 a_atan2(in float y, in HNum3 x);\nHNum3 a_mix(in HNum3 a, in HNum3 b, in HNum3 t);\nHNum3 a_mix(in HNum3 a, in HNum3 b, in float t);\nHNum3 a_mix(in HNum3 a, in float b, in HNum3 t);\nHNum3 a_mix(in HNum3 a, in float b, in float t);\nHNum3 a_mix(in float a, in HNum3 b, in HNum3 t);\nHNum3 a_mix(in float a, in HNum3 b, in float t);\nHNum3 a_mix(in float a, in float b, in HNum3 t);\n\n//--------------------------------\n// Macros\n//--------------------------------\n\n#define HESSIAN3(f,x, y, z,result)  {     result = f(varH3x(x), varH3y(y), varH3z(z)); }\n\n//--------------------------------\n// Utilities prototypes\n//--------------------------------\n\nmat3 a_outerProduct(in vec3 a, in vec3 b);\n\n//--------------------------------\n// Implementation\n//--------------------------------\n\nHNum3 constH3(in float val)\n{\n    return HNum3(val, vec3(0.0), mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3(in float val, in int index)\n{   \n    vec3 g = vec3(0.0);\n    g[index] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3x(in float val)\n{   \n    vec3 g = vec3(0.0);\n    g[0] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3y(in float val)\n{   \n    vec3 g = vec3(0.0);\n    g[1] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3z(in float val)\n{   \n    vec3 g = vec3(0.0);\n    g[2] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//--------------------------------\nHNum3 add(in HNum3 a, in HNum3 b)\n{\n    return HNum3(a.val + b.val , a.g + b.g, a.h + b.h);\n}\n//--------------------------------\nHNum3 add(in HNum3 a, in float b)\n{\n    return HNum3(a.val + b , a.g, a.h);\n}\n//--------------------------------\nHNum3 add(in float a, in HNum3 b)\n{\n    return HNum3(a + b.val , b.g, b.h);\n}\n//--------------------------------\nHNum3 sub(in HNum3 a, in HNum3 b)\n{\n    return HNum3(a.val - b.val , a.g - b.g, a.h - b.h);\n}\n//--------------------------------\nHNum3 sub(in HNum3 a, in float b)\n{\n    return HNum3(a.val - b , a.g, a.h);\n}\n//--------------------------------\nHNum3 sub(in float a, in HNum3 b)\n{\n    return HNum3(a - b.val , - b.g, - b.h);\n}\n//--------------------------------\nHNum3 mult(in HNum3 a, in HNum3 b)\n{\n    return HNum3(a.val * b.val, \n        a.val*b.g + b.val*a.g, \n        a.val*b.h + b.val*a.h + a_outerProduct(b.g,a.g) + a_outerProduct(a.g,b.g)\n    );\n}\n//--------------------------------\nHNum3 mult(in HNum3 a, in float b)\n{\n    return HNum3(a.val * b, b*a.g, b*a.h);\n}\n//--------------------------------\nHNum3 mult(in float a, in HNum3 b)\n{\n    return HNum3(a * b.val, a*b.g, a*b.h);\n}\n//--------------------------------\nHNum3 neg(in HNum3 a)\n{\n    return mult(-1.0,a);\n}\n//--------------------------------\nHNum3 div(in HNum3 a, in HNum3 b)\n{\n    float b1 = b.val;\n    float b2 = b1*b1;\n    float b3 = b2*b1;\n\n    return HNum3(a.val / b.val , \n        (b.val*a.g - a.val*b.g)/b2, \n        2.0*a.val/b3*a_outerProduct(b.g,b.g) \n        - a.val/b2*b.h\n        + a.h/b1 \n        - a_outerProduct(b.g/b2, a.g)\n        - a_outerProduct(a.g/b2, b.g)\n    );\n}\n//--------------------------------\nHNum3 div(in HNum3 a, in float b)\n{\n    return HNum3(a.val / b, a.g/b, a.h/b);\n}\n//--------------------------------\nHNum3 div(in float a, in HNum3 b)\n{\n    float b1 = b.val;\n    float b2 = b1*b1;\n    float b3 = b2*b1;\n\n    return HNum3(a / b.val, \n        -a*b.g/b2, \n        2.0*a/b3*a_outerProduct(b.g,b.g) - a/b2*b.h\n    );\n}\n//--------------------------------\nHNum3 inv(in HNum3 a)\n{\n    return div(1.0, a);\n}\n//--------------------------------\nHNum3 a_pow(in HNum3 a, in HNum3 b)\n{\n    return a_exp(mult(b,a_log(a)));\n}\n//--------------------------------\nHNum3 a_pow(in HNum3 a, in float b)\n{\n    // constant exponent -> make special case\n    float v = pow(a.val, b); // value f(a(x))\n    float da = b*pow(a.val,b-1.0); // first derivative f'(a(x))\n    float dda = b*(b-1.0)*pow(a.val,b-2.0); // second derivative f''(a(x))\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_pow(in float a, in HNum3 b)\n{\n    return a_exp(mult(b,log(a)));\n}\n//--------------------------------\nHNum3 a_min(in HNum3 a, in HNum3 b)\n{\n    if(a.val < b.val)\n    {\n        return a;\n    }\n    return b;\n}\n//--------------------------------\nHNum3 a_max(in HNum3 a, in HNum3 b)\n{\n    if(a.val > b.val)\n    {\n        return a;\n    }\n    return b;\n}\n//--------------------------------\nHNum3 a_exp2(in HNum3 a)\n{\n    float v = exp2(a.val); // value f(a(x))\n    float da = log(2.0)*exp2(a.val); // first derivative f'(a(x))\n    float dda = log(2.0)*log(2.0)*exp2(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_inversesqrt(in HNum3 a)\n{\n    float v = inversesqrt(a.val); // value f(a(x))\n    float da = -0.5/pow(sqrt(a.val),3.0); // first derivative f'(a(x))\n    float dda = 0.75/pow(sqrt(a.val),5.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_atan(in HNum3 a)\n{\n    float v = atan(a.val); // value f(a(x))\n    float da = 1.0/(1.0 + a.val * a.val); // first derivative f'(a(x))\n    float dda = -2.0*a.val/pow(1.0 + a.val * a.val, 2.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_sqrt(in HNum3 a)\n{\n    float v = sqrt(a.val); // value f(a(x))\n    float da = 0.5/sqrt(a.val); // first derivative f'(a(x))\n    float dda = -0.25/pow(sqrt(a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_sinh(in HNum3 a)\n{\n    float v = sinh(a.val); // value f(a(x))\n    float da = cosh(a.val); // first derivative f'(a(x))\n    float dda = sinh(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_ceil(in HNum3 a)\n{\n    float v = ceil(a.val); // value f(a(x))\n    float da = 0.0; // first derivative f'(a(x))\n    float dda = 0.0; // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_tan(in HNum3 a)\n{\n    float v = tan(a.val); // value f(a(x))\n    float da = 1.0 + pow(tan(a.val),2.0); // first derivative f'(a(x))\n    float dda = 2.0*tan(a.val)*(1.0 + pow(tan(a.val),2.0)); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_asinh(in HNum3 a)\n{\n    float v = asinh(a.val); // value f(a(x))\n    float da = 1.0/sqrt(1.0 + a.val * a.val); // first derivative f'(a(x))\n    float dda = -a.val/pow(sqrt(1.0 + a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_asin(in HNum3 a)\n{\n    float v = asin(a.val); // value f(a(x))\n    float da = 1.0/sqrt(1.0 - a.val * a.val); // first derivative f'(a(x))\n    float dda = a.val/pow(sqrt(1.0 - a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_acosh(in HNum3 a)\n{\n    float v = acosh(a.val); // value f(a(x))\n    float da = 1.0/sqrt(-1.0 + a.val * a.val); // first derivative f'(a(x))\n    float dda = -a.val/pow(sqrt(-1.0 + a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_abs(in HNum3 a)\n{\n    float v = abs(a.val); // value f(a(x))\n    float da = a.val < 0.0 ? -1.0 : 1.0; // first derivative f'(a(x))\n    float dda = 0.0; // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_exp(in HNum3 a)\n{\n    float v = exp(a.val); // value f(a(x))\n    float da = exp(a.val); // first derivative f'(a(x))\n    float dda = exp(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_cosh(in HNum3 a)\n{\n    float v = cosh(a.val); // value f(a(x))\n    float da = sinh(a.val); // first derivative f'(a(x))\n    float dda = cosh(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_floor(in HNum3 a)\n{\n    float v = floor(a.val); // value f(a(x))\n    float da = 0.0; // first derivative f'(a(x))\n    float dda = 0.0; // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_log(in HNum3 a)\n{\n    float v = log(a.val); // value f(a(x))\n    float da = 1.0/a.val; // first derivative f'(a(x))\n    float dda = -1.0/(a.val * a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_atanh(in HNum3 a)\n{\n    float v = atanh(a.val); // value f(a(x))\n    float da = 1.0/(1.0 - a.val * a.val); // first derivative f'(a(x))\n    float dda = 2.0*a.val/pow(1.0 - a.val * a.val,2.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_log2(in HNum3 a)\n{\n    float v = log2(a.val); // value f(a(x))\n    float da = 1.0/(a.val * log(2.0)); // first derivative f'(a(x))\n    float dda = -1.0/(a.val * a.val * log(2.0)); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_acos(in HNum3 a)\n{\n    float v = acos(a.val); // value f(a(x))\n    float da = -1.0/sqrt(1.0 - a.val * a.val); // first derivative f'(a(x))\n    float dda = -a.val/pow(sqrt(1.0 - a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_tanh(in HNum3 a)\n{\n    float v = tanh(a.val); // value f(a(x))\n    float da = 1.0 - pow(tanh(a.val),2.0); // first derivative f'(a(x))\n    float dda = -2.0*tanh(a.val)*(1.0 - pow(tanh(a.val),2.0)); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_cos(in HNum3 a)\n{\n    float v = cos(a.val); // value f(a(x))\n    float da = -sin(a.val); // first derivative f'(a(x))\n    float dda = -cos(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_sin(in HNum3 a)\n{\n    float v = sin(a.val); // value f(a(x))\n    float da = cos(a.val); // first derivative f'(a(x))\n    float dda = -sin(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_atan2(in HNum3 y, in HNum3 x)\n{\n    const float pi = 3.14159265; \n    // from https://en.wikipedia.org/wiki/Atan2\n    if(x.val > 0.0)\n    {\n        HNum3 n = a_sqrt(add(mult(x,x),mult(y,y)));\n        HNum3 inner = div(y, add(n,x));\n        \n        return mult(2.0,a_atan(inner));\n        \n    }else if(x.val <= 0.0 && abs(y.val) > 1E-6)\n    {\n        HNum3 n = a_sqrt(add(mult(x,x),mult(y,y)));\n        HNum3 inner = div(sub(n,x),y);\n         return mult(2.0,a_atan(inner));\n    }else if(x.val < 0.0 && abs(y.val) <= 1E-6)\n    {\n        return constH3(pi);\n    }\n    // return 0 for undefined\n    return constH3(0.0); \n}\n//--------------------------------\nHNum3 a_atan2(in HNum3 y, in float x)\n{\n    return a_atan2(y,constH3(x));\n}\n//--------------------------------\nHNum3 a_atan2(in float y, in HNum3 x)\n{\n    return a_atan2(constH3(y),x);\n}\n//--------------------------------\nHNum3 a_mix(in HNum3 a, in HNum3 b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n//--------------------------------\nHNum3 a_mix(in HNum3 a, in HNum3 b, in float t)\n{\n    return add(mult(a, 1.0 - t), mult(b, t));\n}\n\n//--------------------------------\nHNum3 a_mix(in HNum3 a, in float b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n//--------------------------------\nHNum3 a_mix(in HNum3 a, in float b, in float t)\n{\n    return add(mult(a, 1.0 - t), b*t);\n}\n\n//--------------------------------\nHNum3 a_mix(in float a, in HNum3 b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n//--------------------------------\nHNum3 a_mix(in float a, in HNum3 b, in float t)\n{\n    return add(a * (1.0 - t), mult(b, t));\n}\n\n//--------------------------------\nHNum3 a_mix(in float a, in float b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n\n//--------------------------------\n// Implementation prototypes\n//--------------------------------\n\nmat3 a_outerProduct(in vec3 a, in vec3 b)\n{\n    return mat3(a * b[0], a * b[1], a * b[2]);\n}\n\n\n#endif // HESSNUM_3_H_\n//********************************************************************\n//\n// End automatic differentiation header\n//\n//********************************************************************\n\n//********************************************************************\n//\n// Metric functions\n//\n//********************************************************************\n#define PI 3.14159265359\n\n// Predefined functions!\n// Just comment in the one you want to see! (comment out the other ones)\n// If none is defined, the default identity operation is used (f(x,y,z) = 0).\n// You can comment out all predefined ones and implement your own in fCustom\n\n#define EXPONENTIAL\n// #define SADDLE\n//  #define WAVES\n// #define PARABOLA\n// #define IDENTITY\n\n// Implement your custom height function here and comment out all the defines\n// above! You can use all the mathematical operations defined in the automatic\n// differentiation header above\nHNum3 fCustom(in HNum3 x, in HNum3 y, in HNum3 z,\n                 float globalTime) {\n  return constH3(0.0);\n}\n\nHNum3 fExponential(in HNum3 x, in HNum3 y, in HNum3 z,\n                      float globalTime);\nHNum3 fSaddle(in HNum3 x, in HNum3 y, in HNum3 z, float globalTime);\nHNum3 fWaves(in HNum3 x, in HNum3 y, in HNum3 z, float globalTime);\nHNum3 fParabola(in HNum3 x, in HNum3 y, in HNum3 z,\n                   float globalTime);\nHNum3 fIdentity(in HNum3 x, in HNum3 y, in HNum3 z,\n                   float globalTime);\n\n// Height function used for the metric. More information in compute_update\nHNum3 f(in HNum3 x, in HNum3 y, in HNum3 z, float globalTime) {\n\n#if defined EXPONENTIAL\n  return fExponential(x, y, z, globalTime);\n#elif defined SADDLE\n  return fSaddle(x, y, z, globalTime);\n#elif defined WAVES\n  return fWaves(x, y, z, globalTime);\n#elif defined PARABOLA\n  return fParabola(x, y, z, globalTime);\n#elif defined IDENTITY\n  return fIdentity(x, y, z, globalTime);\n#else\n  return fCustom(x, y, z, globalTime);\n#endif\n}\n\nHNum3 hessF(vec3 p, float globalTime) {\n  // compute hessian with addition time parameter\n\n  vec3 uGrad = vec3(1., 0., 0.);\n  HNum3 uHessian = HNum3(p.x, uGrad, mat3(0.));\n  vec3 vGrad = vec3(0., 1., 0.);\n  HNum3 vHessian = HNum3(p.y, vGrad, mat3(0.));\n  vec3 wGrad = vec3(0., 0., 1.);\n  HNum3 wHessian = HNum3(p.z, wGrad, mat3(0.));\n  return f(uHessian, vHessian, wHessian, globalTime);\n}\nvec3 compute_update(vec3 p, vec3 v, float globalTime) {\n\n  // explicit form of the christoffel symbols for the metric given by graph of\n  // the function f(x_1,x_1,x_3) df/dx_i = f_i d^2f/(dx_j dx_j) = f_{i,j}\n  // gamma_{i,j}^k = f_k*f_{i,j}/(1 + |grad(f)|^2)\n\n  // This is the update given by the differential geodesic equation used for\n  // numerical integration in local coordinates (x_i) for a curve c_i(t) = x_i\n  // d^2 c_k/dt^2 = gamma_{i,j}^k * d c_i/dt * d c_j/dt\n\n  // The local position's velocity is given by the ray's current direction\n\n  // compute first and second order derivatives\n  HNum3 r = hessF(p, globalTime);\n\n  vec3 vp = vec3(0.0);\n\n  for (int k = 0; k < 3; k++) {\n    for (int i = 0; i < 3; i++) {\n      for (int j = 0; j < 3; j++) {\n        vp[k] += r.g[k] * r.h[j][i] * v[i] * v[j];\n      }\n    }\n  }\n\n  return -vp / (1.0 + dot(r.g, r.g));\n}\n\n//********************************************************************\n//\n// Data\n//\n//********************************************************************\n\nconst ivec2 D_lastMouse = ivec2(0, 0);\nconst ivec2 D_thetaPhi = ivec2(2, 0);\nconst ivec2 D_pos = ivec2(4, 0);\n\n//********************************************************************\n//\n// Camera functions\n//\n//********************************************************************\n// This assumes the pixel position px to be in [0,1],\n// which can be done by (x+0.5)/w or (y+0.5)/h (or h-y +0.5 for screens\n// with top left origin) to sample pixel centers\nvec3 createRay(vec2 px, mat4 PInv, mat4 VInv);\n\nmat4 translate(vec3 t);\nmat4 translateInv(vec3 t);\n\nmat4 scale(vec3 s);\nmat4 scaleInv(vec3 s);\n\nmat4 rightToLeft();\nmat4 rightToLeftInv();\n\nmat4 ortho(float l, float r, float b, float t, float n, float f);\nmat4 orthoInv(float l, float r, float b, float t, float n, float f);\n\nmat4 projection(float n, float f);\nmat4 projectionInv(float n, float f);\n\nmat4 perspective(float fov, float aspect, float n, float f);\nmat4 perspectiveInv(float fov, float aspect, float n, float f);\n\nmat4 lookAt(vec3 eye, vec3 center, vec3 up);\nmat4 lookAtInv(vec3 eye, vec3 center, vec3 up);\n\n//********************************************************************\n//\n// Implementation\n//\n//********************************************************************\nHNum3 fExponential(in HNum3 x, in HNum3 y, in HNum3 z,\n                      float globalTime) {\n  HNum3 rx = sub(x, 0.0);\n  HNum3 ry = sub(y, 1.0);\n  HNum3 rz = sub(z, 2.0);\n\n  HNum3 x2 = mult(rx, rx);\n  HNum3 y2 = mult(ry, ry);\n  HNum3 z2 = mult(rz, rz);\n\n  HNum3 sum = neg(add(x2, add(y2, z2)));\n\n  HNum3 f1 = a_exp(mult(sum, 1.0 / (abs(sin(globalTime / 3.0)) + 0.1)));\n\n  rx = sub(x, -6.0);\n  ry = sub(y, -0.25);\n  rz = sub(z, 3.5);\n\n  x2 = mult(rx, rx);\n  y2 = mult(ry, ry);\n  z2 = mult(rz, rz);\n\n  sum = neg(add(x2, add(y2, z2)));\n  sum = mult(sum, 0.1);\n  HNum3 f2 = mult(a_exp(sum), abs(sin(globalTime / 5.0)) * 5.0);\n  return add(f1, f2);\n}\nHNum3 fSaddle(in HNum3 x, in HNum3 y, in HNum3 z,\n                 float globalTime) {\n  return mult(0.25 * pow(sin(globalTime / 2.0), 2.0),\n              sub(add(mult(x, x), mult(z, z)), mult(y, y)));\n}\nHNum3 fWaves(in HNum3 x, in HNum3 y, in HNum3 z, float globalTime) {\n  float frequency = 2.0 * PI / (10.0 + 3.0 * sin(0.1 * globalTime));\n  return a_cos(add(mult(x, frequency), mult(z, frequency)));\n}\nHNum3 fParabola(in HNum3 x, in HNum3 y, in HNum3 z,\n                   float globalTime) {\n  HNum3 rel = sub(x, 0.0);\n  HNum3 sum = mult(rel, rel);\n\n  rel = sub(y, 0.0);\n  sum = add(sum, mult(rel, rel));\n\n  rel = sub(z, -10.0);\n  sum = add(sum, mult(rel, rel));\n  return mult(sum, 0.1);\n}\nHNum3 fIdentity(in HNum3 x, in HNum3 y, in HNum3 z,\n                   float globalTime) {\n  return constH3(0.0);\n}\n\n\n//********************************************************************\nvec3 createRay(vec2 px, mat4 PInv, mat4 VInv) {\n\n  // convert pixel to NDS\n  // [0,1] -> [-1,1]\n  vec2 pxNDS = px * 2. - 1.;\n\n  // choose an arbitrary point in the viewing volume\n  // z = -1 equals a point on the near plane, i.e. the screen\n  vec3 pointNDS = vec3(pxNDS, -1.);\n\n  // as this is in homogenous space, add the last homogenous coordinate\n  vec4 pointNDSH = vec4(pointNDS, 1.0);\n  // transform by inverse projection to get the point in view space\n  vec4 dirEye = PInv * pointNDSH;\n\n  // since the camera is at the origin in view space by definition,\n  // the current point is already the correct direction (dir(0,P) = P - 0 = P\n  // as a direction, an infinite point, the homogenous component becomes 0\n  // the scaling done by the w-division is not of interest, as the direction\n  // in xyz will stay the same and we can just normalize it later\n  dirEye.w = 0.;\n\n  // compute world ray direction by multiplying the inverse view matrix\n  vec3 dirWorld = (VInv * dirEye).xyz;\n\n  // now normalize direction\n  return normalize(dirWorld);\n}\n\n// matrix operations\nmat4 translate(vec3 t) {\n  return mat4(vec4(1., 0., 0., 0.), vec4(0., 1., 0., 0.), vec4(0., 0., 1., 0.),\n              vec4(t, 1.));\n}\nmat4 translateInv(vec3 t) { return translate(-t); }\n\nmat4 scale(vec3 s) {\n  return mat4(vec4(s.x, 0., 0., 0.), vec4(0., s.y, 0., 0.),\n              vec4(0., 0., s.z, 0.), vec4(0., 0., 0., 1.));\n}\nmat4 scaleInv(vec3 s) { return scale(1. / s); }\n\nmat4 rightToLeft() {\n  // 1 0 0  0\n  // 0 1 0  0\n  // 0 0 -1 0\n  // 0 0 0  1\n  return scale(vec3(1., 1., -1.));\n}\n\nmat4 rightToLeftInv() {\n  // same matrix\n  return rightToLeft();\n}\n\nmat4 ortho(float l, float r, float b, float t, float n, float f) {\n\n  // translation and scale\n  return scale(vec3(2. / (r - l), 2. / (t - b), 2. / (f - n))) *\n         translate(vec3(-(l + r) / 2., -(t + b) / 2., -(f + n) / 2.));\n}\n\nmat4 orthoInv(float l, float r, float b, float t, float n, float f) {\n  return translateInv(vec3(-(l + r) / 2., -(t + b) / 2., -(f + n) / 2.)) *\n         scaleInv(vec3(2. / (r - l), 2. / (t - b), 2. / (f - n)));\n}\n\nmat4 projection(float n, float f) {\n  // n 0 0 0\t0\n  // 0 n 0 0\t0\n  // 0 0 n+f\t-fn\n  // 0 0 1\t0\n  return mat4(vec4(n, 0., 0., 0.), vec4(0., n, 0., 0.), vec4(0., 0., n + f, 1.),\n              vec4(0., 0., -f * n, 0.));\n}\n\nmat4 projectionInv(float n, float f) {\n  // 1/n \t0 \t0 \t\t0\n  // 0 \t1/n\t0 \t\t0\n  // 0\t0\t0 \t\t1\n  // 0\t0\t-1/fn\t(f+n)/fn\n\n  return mat4(vec4(1. / n, 0., 0., 0.), vec4(0., 1. / n, 0., 0.),\n              vec4(0., 0., 0., -1. / (f * n)),\n              vec4(0., 0., 1., (f + n) / (f * n)));\n}\n\nmat4 perspective(float fov, float aspect, float n, float f) {\n  float l = tan(fov / 2.) * n;\n  float b = l / aspect;\n\n  return ortho(-l, l, -b, b, n, f) * projection(n, f) * rightToLeft();\n}\n\nmat4 perspectiveInv(float fov, float aspect, float n, float f) {\n  float l = tan(fov / 2.) * n;\n  float b = l / aspect;\n\n  return rightToLeftInv() * projectionInv(n, f) * orthoInv(-l, l, -b, b, n, f);\n}\n\nmat4 lookAt(vec3 eye, vec3 center, vec3 up) {\n\n  vec3 z = normalize(eye - center);\n  vec3 x = normalize(cross(up, z));\n  vec3 y = cross(z, x);\n\n  mat4 v = mat4(vec4(x.x, y.x, z.x, 0.), vec4(x.y, y.y, z.y, 0.),\n                vec4(x.z, y.z, z.z, 0.), vec4(0., 0., 0., 1.));\n\n  return v * translate(-eye);\n}\n\nmat4 lookAtInv(vec3 eye, vec3 center, vec3 up) {\n  vec3 z = normalize(eye - center);\n  vec3 x = normalize(cross(up, z));\n  vec3 y = cross(z, x);\n\n  return translateInv(-eye) *\n         mat4(vec4(x, 0.), vec4(y, 0.), vec4(z, 0.), vec4(0., 0., 0., 1.));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}