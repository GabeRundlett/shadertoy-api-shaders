{
    "Shader": {
        "info": {
            "date": "1666751493",
            "description": "Rounded rectangle with variable radius edges and borders drawn using an SDF. ",
            "flags": 0,
            "hasliked": 0,
            "id": "cdsGzs",
            "likes": 0,
            "name": "Rounded Rectangle with border2",
            "published": 3,
            "tags": [
                "sdf",
                "rectangle",
                "rounded"
            ],
            "usePreview": 0,
            "username": "i509VCB",
            "viewed": 297
        },
        "renderpass": [
            {
                "code": "// The size of the shape as a ratio.\n//\n// One value must always be 1.0. The other value may be greater than 1.0 to create a rectangle.\nconst vec2 size = vec2(1.0, 1.0);\n\n// The radius in a fraction.\n//\n// A value of 0.0 indicates that a quad should be drawn.\n// A value of 1.0 indicates that the radius of the curves should occupy the entire width or height (whichever is shorter).\n// Values between 0.0 and 1.0 will result in a quad with curved edges, with a radius of 1.0 for all edges creating a circle.\n//\n// r.x = top-right radius\n// r.y = bottom-right radius\n// r.z = top-left radius\n// r.w = bottom-left radius\nconst vec4 radius = vec4(0.0, 0.15, 1.0, 0.05);\n\n// The thickness of the shape.\n//\n// A thickness of 1.0 means the shape will be solid.\n// A thickness of 0.0 means the shape will be invisible.\n//\n// Note: With smaller values for radius, the inner border might be a right angle.\nconst float thickness = 0.06;\n\n// The fade applied to edges of the shape.\n//\n// This value is used to smooth the edges of the shape and remove jagged edges.\n//\n// A fade of 0.0 will not smooth the shape.\n// High fade values will cause the shape to become invisible.\nconst float fade = 0.006;\n\nfloat _distance(vec2 position, vec2 size, vec4 radii) {\n    vec2 edges = position.x > 0.0 ? radii.xy : radii.zw;\n    float radius = position.y > 0.0 ? edges.x : edges.y;\n\n    // A quad will be symmetrical along the x and y axis and therefore the absolute value can be taken for symmetry.\n    //\n    // The size is subtracted from the position to effectively center q around some edge of the quad.\n    // The radius however is added to move the edge of the quad further to the middle.\n    vec2 q = abs(position) - size + radius;\n    return min(max(q.x,q.y),0.0)\n        // The essence of an SDF is finding the distance to some mathematically defined shape. To do this we measure the distance\n        // from position q to (0.0, 0.0).\n        + length(max(q, 0.0))\n        // In order to prevent the distance from scaling with the radius, subtract the radius to keep the quad at a fixed size.\n        - radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // 0 -> 1 local space, adjusted for aspect ratio\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n\n    // Subtract half the fade to ensure the rectangle is not clipped.\n    vec2 size = size - (fade / 2.0);\n\n    // Calculate distance and fill circle with white\n    float distance = _distance(uv, size, radius);\n    float smoothed_alpha = 1.0 - smoothstep(0.0, fade, distance);\n    float border_alpha = 1.0 - smoothstep(thickness - fade, thickness, abs(distance));\n\n    vec4 bg_color = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 rect_color = vec4(0.85, 0.35, 0.2, 1.0);\n\n    // Set output color\n    fragColor = mix(bg_color, mix(bg_color, rect_color, border_alpha), smoothed_alpha);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}