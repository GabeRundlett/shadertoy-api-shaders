{
    "Shader": {
        "info": {
            "date": "1607739529",
            "description": "Limit set of rank 4 hyperbolic Coxeter groups, drawn both on the boundary sphere and the stereo-projected plane.",
            "flags": 0,
            "hasliked": 0,
            "id": "WdGBz3",
            "likes": 71,
            "name": "Boyd-Maxwell 2D circle packing",
            "published": 3,
            "tags": [
                "coxeter",
                "tiling",
                "hyperbolic",
                "circlepacking",
                "limitset"
            ],
            "usePreview": 0,
            "username": "neozhaoliang",
            "viewed": 2804
        },
        "renderpass": [
            {
                "code": "/*\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nBoyd-Maxwell circle packings of hyperbolic Coxeter groups: rank 4/level 2 case\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFor more information check the github repo:\n\n    https://github.com/neozhaoliang/Hyperbolic-Honeycombs\n\nRequired input:\n\nThe Coxeter diagram of a rank 4 Coxeter group G = <A, B, C, D>, with dihedral angles\nm_{s,t} in the order (AB, AC, AD, BC, BD, CD).\n\nNote:\n\n1. CD must be finite\n2. The triangle group <B, C, D> must be hyperbolic\n\nIf you see only a sphere and a small disk under it, try comment out `#define useMouseInvert` below.\n*/\n\n\n#define useMouseInvert\n\n#define shiny        5.\n\n\n//#define config      initLevel2Graph(float[6](4., 2., 7., 4., 2., 5.))\n//#define config      initLevel2Graph(float[6](3., 2., 2., 3., 2., 7.))\n//#define config      initLevel2Graph(float[6](3., 3., 2., 3., 2., 7.))\n//#define config      initLevel2Graph(float[6](4., 4., 4., 4., 4., 4.))\n//#define config      initLevel2Graph(float[6](2., 2., 7., inf, 3., 3.))\n//#define config      initLevel2Graph(float[6](3., 3., 2., 7., 2., 3.))\n#define config      initLevel2Graph(float[6](5., 2., 3., 4., 3., 3.))\n\n\nvec2 map(vec3 p) {\n    float d1 = sdSphere(p);\n    float d2 = sdPlane(p);\n    float id = (d1 < d2) ? 0.: 1.;\n    return vec2(min(d1, d2), id);\n}\n\n// standard scene normal\nvec3 getNormal(vec3 p) {\n    const vec2 e = vec2(0.0001, 0.);\n    return normalize(\n        vec3(\n            map(p + e.xyy).x - map(p  - e.xyy).x,\n            map(p + e.yxy).x - map(p  - e.yxy).x,\n            map(p + e.yyx).x - map(p  - e.yyx).x\n            )\n        );\n}\n\n// get the signed distance to an object and object id\nvec2 raymarch(in vec3 ro, in vec3 rd)\n{\n    float t = MIN_TRACE_DIST;\n    vec2 h;\n    for(int i=0; i<MAX_TRACE_STEPS; i++)\n    {\n        h = map(ro + t * rd);\n        if (h.x < PRECISION * (t*0.125+1.))\n            return vec2(t, h.y);\n\n        if (t > MAX_TRACE_DIST)\n            break;\n\n        t += h.x;\n    }\n    return vec2(-1.0);\n}\n\nfloat calcOcclusion(vec3 p, vec3 n) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n        float h = 0.01 + 0.15 * float(i) / 4.0;\n        float d = map(p + h * n).x;\n        occ += (h - d) * sca;\n        sca *= 0.85;\n    }\n    return clamp(1.0 - occ, 0.2, 1.0);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k) {\n    float res = 1.0;\n    float t = tmin;\n    for (int i = 0; i < 20; i++) {\n        float h = map(ro + rd * t).x;\n        res = min(res, k * h / t);\n        t += clamp(h, 0.001, 0.1);\n        if (h < 0.0001 || t > tmax)\n            break;\n    }\n    return clamp(res, 0., 1.0);\n}\n\nvec3 getColor(vec3 ro, vec3 rd, vec3 pos, vec3 nor, vec3 lp, vec3 basecol) {\n    vec3 col = vec3(0.0);\n    vec3 ld = lp - pos;\n    float lDist = max(length(ld), .001);\n    ld /= lDist;\n    float ao = calcOcclusion(pos, nor);\n    float sh = softShadow(pos+0.001*nor, ld, 0.01, lDist, 8.);\n    float diff = clamp(dot(nor, ld), 0., 1.);\n    float atten = shiny / (1. + lDist * lDist * .001);\n    float spec = pow(max( dot( reflect(-ld, nor), -rd ), 0.0 ), 6.);\n    float fres = clamp(1.0 + dot(rd, nor), 0.0, 1.0);\n    col += basecol * diff;\n    col += basecol * vec3(.8, 1., 0.3) * spec * 4.;\n    col += basecol * vec3(1.2, 1., .8) * fres * fres * 2.;\n    col *= ao * atten * sh;\n    col += basecol * clamp(0.8 + 0.2 * nor.z, 0., 1.);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 scenecol = vec3(0.);\n\n// initialize the mirrors\n  \n    config;\n    \n    vec3 camera = vec3(4, 1.5, 4);\n    vec3 lp =  vec3(.5, .5, 4.); //light position\n    camera.xy = rot2d(camera.xy, iTime*0.3);\n    vec3 lookat  = vec3(0.);\n    vec3 up = vec3(0, 0, 1);\n    vec3 forward = normalize(lookat - camera);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    \n    float lw = 8. / iResolution.y;\n\n// antialiasing loop\n\n    for(int ii=0; ii<AA; ii++) {\n        for(int jj=0; jj<AA; jj++) {\n            vec2 o = vec2(float(ii), float(jj)) / float(AA);\n            vec2 uv = (2. * fragCoord + o - iResolution.xy) / iResolution.y;\n            vec3 rd = normalize(uv.x * right + uv.y * up + 1.5 * forward);\n            vec2 res = raymarch(camera, rd);\n            float t = res.x;\n            float id = res.y;\n            vec3 pos = camera + t * rd;\n\n            float ed;\n            vec3 col;\n            vec2 p0;\n            vec3 nor;\n\n            // the sphere is hit\n            if (id == 0.) {\n                nor = pos;\n                p0 = sphereToPlane(pos);\n            }\n            \n            // the plane is hit\n            else if (id == 1.) {\n                nor = vec3(0, 0, 1);\n                p0 = pos.xy;\n            }\n#ifdef useMouseInvert      \n            vec2 mouse = (iMouse.xy-2.*iResolution.xy)/iResolution.y;\n            if (iMouse.z == 0.)\n                mouse = vec2(1.5, 1.5);\n            mouse = rot2d(mouse, iTime*0.1);\n            float k = 1./L2(mouse);\n            vec2 invCtr = k * mouse;\n            float tt = (k - 1.) / L2(p0 -invCtr);\n            p0 = tt*p0 + (1. - tt)*invCtr;\n#endif\n            vec3 basecol = getcolor(p0, ed);\n            col = getColor(camera, rd, pos, nor, lp, basecol);\n            float dist = distanceToMirrors(p0) ;\n            col = mix(col, vec3(0.), 1.0 - exp(-0.01*t*t));\n            scenecol += col;\n        }\n    }\n    scenecol /= (float(AA) * float(AA));\n\n    fragColor = vec4(sqrt(max(scenecol, 0.0)), 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define inf                 1.0     // Vinberg convention for edge labels\n#define MAX_REFLECTIONS     500\n#define AA                  2\n#define PI                  3.141592653\n#define L2(x)               dot(x, x)\n#define L2XY(x, y)          L2(x - y)\n#define Hyperbolic          -1.0\n#define Euclidean           0.\n#define Spherical           1.\n#define MAX_TRACE_STEPS     500\n#define MIN_TRACE_DIST      0.001\n#define MAX_TRACE_DIST      100.0\n#define PRECISION           0.0001\n#define EdgeSize1           0.0035 \n#define EdgeSize2           0.01\n#define ColorScale          0.8\n\n// Move a vertex of Euclidean type (if there is any) to infinity,\n// so the pattern tiles the entire plane\n#define moveVertexToInf\n\n// 4x4 Cartan matrix for the Coxeter group\nmat4 cartan;\n\n// geometry type of each vertex in the Coxeter diagram\n// -1 for hyerbolic, 0 for Euclidean, 1 for spherial\nvec4 vertexType = vec4(1);\n\n// coordinates of a Euclidean vertex\nvec2 euclideanVertex;\n\n// if we are outside of the unit circle\n// if a point lies outside of unit circle, the distance\n// estimation becomes inaccurate. We use EdgeSize2 to control the edge size for this case.\nbool outside = false;\n\n// if there is an Euclidean vertex, i.e. if remove this vertex, the remain diagram is affine\nbool hasEuclideanVertex;\n\n// compute cos(PI / x), for x = inf this is just inf\nfloat dihedral(float x) {\n    return x == inf ? inf : cos(PI / x);\n}\n\n// complex multiplication\nvec2 cmul(vec2 p, vec2 q) { return vec2(p.x*q.x-p.y*q.y, p.x*q.y+p.y*q.x); }\n\n\n// complex division\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2(z.x * w.x + z.y * w.y, -z.x * w.y + z.y * w.x) / dot(w, w);\n}\n\n// compute the vertex type of each vertex.\n// for each vertex in the Coxeter diagram, its vertex type is determined by the triangle group G formed by\n// the remaining three vertices. This vertex is of hyperbolic/spherical/euclidean iff G is\n// hyperbolic/spherical/euclidean, respectively.\n// This can be checked from the determinant of the leading minors of the Cartan matrix.\nvoid checkCartan(mat4 M) {\n    const float e = 0.001;\n    float det;\n    det = determinant(mat3(M[1].yzw, M[2].yzw, M[3].yzw));\n    vertexType.x = step(-e, det) + step(e, det) - 1.;\n        \n    det = determinant(mat3(M[0].xzw, M[2].xzw, M[3].xzw));\n    vertexType.y = step(-e, det) + step(e, det) - 1.;\n    \n    det = determinant(mat3(M[0].xyw, M[1].xyw, M[3].xyw));\n    vertexType.z = step(-e, det) + step(e, det) - 1.;\n    \n    det = determinant(mat3(M[0].xyz, M[1].xyz, M[2].xyz));\n    vertexType.w = step(-e, det) + step(e, det) - 1.;\n}\n\n\n// For spheres cen is the center, r is the radius\n// For planes cen is the normal vector, r is the offset from the origin along the normal. \n// if invert is true then the inside/outside of the sphere is exchanged.\nstruct Ball {\n    vec2 cen;\n    float r;\n    bool isplane;\n    bool invert;\n};\n\n\n// coclusters are mirror balls, they corresponde to root vectors (space-like)\nBall[4] coclusters;\n// clusters are real balls, they corresponde to space-like weight vectors\nBall[4] clusters;\n\n\n// create a default ball (unit circle)\nBall defaultBall() {\n    return Ball(vec2(0), 1., false, false);\n}\n\n\nBall from_plane(vec2 normal, float offset) {\n    return Ball(normal, offset, true, false);\n}\n\nBall from_sphere(vec2 cen, float r) {\n    return Ball(cen, r, false, false);\n}\n\nvoid invertBall(inout Ball B) {\n    B.invert = !B.invert;\n}\n\n\n// try to reflect a point p to the positive half space bounded by a ball\n// if we are already in the positive half space, do nothing and return true,\n// else reflect about the ball and return false\n// if B is a sphere we try to reflect p into the interior of B\nbool try_reflect(inout vec2 p, Ball B, inout int count) {\n    vec2 cen = B.cen;\n    float r = B.r;\n    if (B.isplane) {\n        float k = dot(vec3(p, 1), vec3(cen, r));\n        if (k >= 0.)\n            return true;\n        p -= 2. * k  * cen;\n        count += 1;\n        return false;\n    }\n    else {\n        vec2 q = p - cen;\n        float d2 = dot(q, q);\n        float k = (r * r) / d2;\n        if (k < 1.0)\n            return true;\n        p = k * q + cen;\n        count += 1;\n        return false;\n    }\n}\n\n\nvec2 getIntersection(Ball B1, Ball B2, Ball B3) {\n    vec2 dir = vec2(-B3.cen.y, B3.cen.x);\n    float r1 = B1.r, r2 = B2.r;\n    float k = (L2(B1.cen) - L2(B2.cen) - (r1*r1 - r2*r2)) / (2. * dot(B1.cen - B2.cen, dir));\n    return k*dir;\n}\n\nBall solveBall(Ball B1, Ball B2, Ball B3) {\n    vec2 dir = vec2(-B3.cen.y, B3.cen.x);\n    float r1 = B1.r, r2 = B2.r;\n    float k = (L2(B1.cen) - L2(B2.cen) - (r1*r1 - r2*r2)) / (2. * dot(B1.cen - B2.cen, dir));\n    vec2 cen = k * dir; \n    float r = sqrt(L2XY(cen, B1.cen) - r1*r1);\n    return from_sphere(cen, r);\n}\n\n\nfloat sdistanceToBall(vec2 p, Ball B) {\n    if (B.isplane) {\n        float k = dot(vec3(p, 1), vec3(B.cen, B.r));\n        return k;\n    }\n    else {\n        float k = length(p - B.cen) - B.r;\n        return B.invert ? -k : k;\n    }\n}\n\n\nvoid initLevel2Graph(in float[6] diagram) {\n    Ball B0, B1, B2, B3;\n    float c01 = dihedral(diagram[0]);\n    float c02 = dihedral(diagram[1]);\n    float c03 = dihedral(diagram[2]);\n    float c12 = dihedral(diagram[3]);\n    float c13 = dihedral(diagram[4]);\n    float c23 = dihedral(diagram[5]);\n    \n    cartan = mat4(1, -c01, -c02, -c03,\n                  -c01, 1, -c12, -c13,\n                  -c02, -c12, 1, -c23,\n                  -c03, -c13, -c23, 1);\n    checkCartan(cartan);\n    \n    float s23 = sqrt(1. - c23*c23);\n    \n    // The two virtual balls B2, B3 (reflection mirrors) are lines through the origin\n    B2 = from_plane(vec2(1, 0), 0.);\n    B3 = from_plane(vec2(-c23, s23), 0.);\n    \n    // The mirror ball B1(x, y, r) satisfy\n    // Angle with B2: dot((x, y), (1, 0)) / r = c12\n    // Angle with B3: dot((x, y), (-c23, s23)) / r = c13\n    // Orthogonal to the real ball (unit ball) C0: x^2 + y^2 = r^2 + 1\n    float k1 = c12;\n    float k2 = (c13 + c23*c12) / s23;\n    float r = 1. / sqrt(k1*k1 + k2*k2 - 1.);\n    \n    B1 = from_sphere(vec2(k1*r, k2*r), r);\n    \n    // The mirror ball B0(x, y, r) satisfy\n    // Angle with B2: dot((x, y), (1, 0)) / r = c02\n    // Angle with B3: dot((x, y), (-c23, s23)) / r = c03\n    // Angle with B1:\n    //\n    //        r^2 + r1^2 - |(x,y) - (x1,y1)|^2\n    //        --------------------------------  = -c01\n    //                   2 * r * r1\n    k1 = c02;\n    k2 = (c03 + c23*c02) / s23;\n    \n    float a = k1*k1 + k2*k2 - 1.;\n    float b = dot(vec3(k1, k2, c01), vec3(B1.cen, B1.r));\n    float c = L2(B1.cen) - B1.r*B1.r;\n    \n    r = b / a - sqrt(b*b - a*c) / a;\n    B0 = from_sphere(vec2(k1*r, k2*r), r);\n\n    \n    coclusters = Ball[4] (B0, B1, B2, B3);\n    \n    for (int k = 0; k < 4; k++) {\n        clusters[k] = defaultBall();\n    }\n   \n    invertBall(clusters[0]);\n    \n    if (vertexType.y == Hyperbolic) {\n        float r = sqrt(L2(B0.cen) - B0.r*B0.r);\n        clusters[1] = from_sphere(vec2(0), r);\n    }\n    if (vertexType.z == Hyperbolic) {\n        clusters[2] = solveBall(B0, B1, B3);\n    }\n    if (vertexType.w == Hyperbolic) {\n        clusters[3] = solveBall(B0, B1, B2);\n    }\n    \n    if (vertexType.y == Euclidean) {\n        hasEuclideanVertex = true;\n        euclideanVertex = vec2(0);\n        return;\n    }\n        \n    if (vertexType.z == Euclidean) {\n        hasEuclideanVertex = true;\n        euclideanVertex = getIntersection(B0, B1, B3);\n        return;\n    }\n    \n    if (vertexType.w == Euclidean) {\n        hasEuclideanVertex = true;\n        euclideanVertex = getIntersection(B0, B1, B2);\n        return;\n    }\n}\n\nvec2 applyMobius(vec2 p) {\n    if (hasEuclideanVertex) {\n        vec2 A = euclideanVertex;\n        vec2 B = vec2(0, 0);\n        vec2 C = vec2(1, 0);\n        vec2 D = vec2(4, 0);\n        p = cdiv(cmul(p, A) + B, cmul(C, p) + D);\n    }\n    return p;\n}\n\n\nfloat distanceToMirrors(vec2 p) {\n    float d = abs(sdistanceToBall(p, coclusters[0]));\n    \n    if (length(p) > 1.) {\n        p /= L2(p);\n        outside = true;\n    }\n    \n    for (int k = 1; k < 4; k++) {\n         d = min(d, abs(sdistanceToBall(p, coclusters[k])));\n    }\n    return d;\n}\n\n\nvoid fold(inout vec2 p, inout int count, inout int index) {\n#ifdef moveVertexToInf\n    p = applyMobius(p);\n#endif\n    for (int i = 0; i < MAX_REFLECTIONS; i++) {\n        bool cond = true;\n        for (int k = 0; k < 4; k++) {\n            cond = try_reflect(p, coclusters[k], count) && cond;\n        }\n        if (cond)\n            break;\n    }\n    for (int k = 0; k < 4; k++) {\n        if (vertexType[k] == Hyperbolic && sdistanceToBall(p, clusters[k]) < -0.0001) {\n            index = k;\n            break;\n        }\n    }\n}\n\n// signed distance to unit ball and plane z=-1\nfloat sdSphere(vec3 p) { return length(p) - 1.0; }\nfloat sdPlane(vec3 p) { return p.z + 1.0; }\n\n// project points on the unit ball to plabe z=-1\nvec2 sphereToPlane(vec3 p) {\n    return 2. * p.xy / (1. - p.z);\n}\n\n// 2d rotation\nvec2 rot2d(vec2 p, float a) { return p * cos(a) + vec2(-p.y, p.x) * sin(a); }\n\n// you can implement your color functions here\nvec3 colormap(int index, float t) {\n    float c = float(index) + 1.;\n    return .5 + .45*cos(2.*PI  * pow(t, 0.3) * ColorScale * c + vec3(0, 1, 2));\n}\n\nvec3 getcolor(inout vec2 p, out float ed) {\n    int index = -1;\n    int count = 0;\n    fold(p, count, index);\n    float dist = distanceToMirrors(p);\n    float t = clamp(float(count + 1) / float(MAX_REFLECTIONS), 0., 1.);\n    vec3 col = colormap(index, t);\n    float es = outside ? EdgeSize2 : EdgeSize1;\n    float aa = fwidth(dist) / 2.;\n    col = mix(col, vec3(0), 1. - smoothstep(es-aa, es+aa, dist));\n    return col;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}