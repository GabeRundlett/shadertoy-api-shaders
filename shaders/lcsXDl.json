{
    "Shader": {
        "info": {
            "date": "1705923017",
            "description": "WORK IN PROGRESS\nHeavily modulated, geometrically warped fractal square tiling of the plane.\nModulations are (very) slow, as this is meant for use as a wallpaper / backdrop (e.g. using the Shader wallpaper plugin for KDE plasma).",
            "flags": 0,
            "hasliked": 0,
            "id": "lcsXDl",
            "likes": 5,
            "name": "Slow, Morphing Fractal Wallpaper",
            "published": 3,
            "tags": [
                "fractal",
                "wallpaper"
            ],
            "usePreview": 0,
            "username": "pxsort",
            "viewed": 208
        },
        "renderpass": [
            {
                "code": "/* \nHeavily modulated, geometrically warped fractal square tiling of the plane.\nModulations are designed to progress (very) slowly, as this is meant for use as a wallpaper / backdrop \n  (e.g. using the Shader wallpaper plugin for KDE plasma).\nHowever, for this Shadertoy demo, the global speed parameter has been set to 100x to give viewers an idea \n  of how the image progresses.\nIf you would like to speed up the warping, set the *Rate parameters to something higher (e.g. 1 or 0.1).\n\nBased off of this shader by Ingio Quilez:\nhttps://www.shadertoy.com/view/Ml2GWy\n*/\n\n/*************\n * CONSTANTS *\n *************/\n#define PI 3.141592653589793238\n#define EPSILON 1.0E-50\n\n\n/**************\n * PARAMETERS *\n **************/ \n\n// Time: Speed up or slow down the animation, and control how quicky different aspects of \n//       the animation change.\n\n// Global speed: use a value around 1.0 for a pleasant, subtly morphing desktop background.\nconst float SPEED = 100.0;\n\n// How quickly the colours \"blink\" in the animation.\n//  - Must be positive. Smaller values slow down the blink rate.\nconst float BLINKINESS = 1.0;\n\n// Debug parameter: offset iTime to inspect the animation at a given point in time.\nconst float TIME_OFFSET = 0.0;\n\n\n// Multi-monitor: split the animation over a grid multiple monitors. \n//   - assumes that the monitors are the same size, and resolution\n\n// Part 1: Specify the number of rows and columns in your grid of monitors.\nconst int MONITOR_GRID_ROWS = 1;\nconst int MONITOR_GRID_COLUMNS = 1;\n\n// Part 2: Identify the location of each monitor in the grid.\n//   Row 0 is at the bottom, and column 0 is the leftmost column.\nconst int MONITOR_ROW = 0;\nconst int MONITOR_COLUMN = 0;\n\n\n// Affine Transform: translate, scale, and rotate the animation.\n\n// Horizontally shifts the center of the animation by TRANSLATE_X monitor widths.\n//   - negative shifts left, positive shifts right\nconst float TRANSLATE_X = 0.0;\n\n// Vertically shifts the center of the animation by TRANSLATE_Y monitor heights.\n//   - negative shifts down, positive shifts up\nconst float TRANSLATE_Y = 0.0;\n\n// Horizontally scale the animation.\n//   - negative scale mirrors the animation in the X axis\nconst float SCALE_X = 1.0;\n\n// Horizontally scale the animation.\n//   - negative scale mirrors the animation in the X axis\nconst float SCALE_Y = 1.0;\n\n// Rotation (in radians)\nconst float ROTATION = 0.0 * PI;\n\n\n// Colour: tweak the resulting colours of the output\n\n// Apply a global shift to the hue of the image pixels.\nconst float HUE_SHIFT = 0.0;\n\n// Constrain pixel hues to a given range.\nconst vec2 HUE_CONSTRAIN = vec2(0.0, 1.0);\n\n// Apply a global shift to the saturation of the image pixels.\nconst float SAT_SHIFT = 0.0;\n\n// Constrain image saturation to a given range.\nconst vec2 SAT_CONSTRAIN = vec2(0.0, 1.0);\n\n// Apply a global shift to the value of the image pixels.\nconst float VAL_SHIFT = 0.0;\n\n// Constrain pixel hues to a given range.\nconst vec2 VAL_CONSTRAIN = vec2(0.0, 1.0);\n\n\n\n/******************\n * COLOUR HELPERS *\n ******************/\n\n// Copied from: https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n\n// RGB to HSV: components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// HSV to RGB: components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n/************************\n * MODULATOR PRIMITIVES *\n ************************ \n   - function definitions of various LFOs to be combined for defining periodic functions \n     to modulate animation parameters\n */\n \n// Helper function (calculate the fraction of a full cycle that t corresponds to)\nfloat cycleFrac(float t, float hz, float phaseShift) {\n  phaseShift = clamp(phaseShift, -0.5, 0.5);\n  \n  float period = 1.0 / hz;\n  return fract(t / period + phaseShift);\n}\n\n// Pulse-width modulation LFO\n// - t: time\n// - hz: LFO frequency (in Hertz)\n// - skew: fraction of time that the pulse is high (must be between 0.0 and 1.0; 0.5 -> square wave)\n// - phaseShift: shift the phase of the LFO (must be between -0.5 and 0.5)\nfloat lfoPulse(float t, float hz, float skew, float phaseShift) {\n  skew = clamp(skew, 0.0, 1.0);\n  float cFrac = cycleFrac(t, hz, phaseShift);\n\n  return 1.0 - step(skew, cFrac);\n}\n\n\n// Smoothed pulse-width modulation LFO\n// - t: time\n// - hz: LFO frequency (in Hertz)\n// - skew: fraction of time that the pulse is high (must be between 0.0 and 1.0; 0.5 -> square wave)\n// - phaseShift: shift the phase of the LFO (must be between -0.5 and 0.5)\nfloat lfoSmoothPulse(float t, float hz, float skew, float phaseShift) {\n  skew = clamp(skew, 0.0, 1.0);\n  float cFrac = cycleFrac(t, hz, phaseShift);\n\n  return 1.0 - smoothstep(skew - 1.0, skew, cFrac);\n}\n\n\n// Triangle wave LFO\n// - t: time\n// - hz: LFO frequency (in Hertz)\n// - skew: fraction of time that the wave is ascending (must be between 0.0 and 1.0; 0.0 or 1.0 -> saw-tooth)\n// - phaseShift: shift the phase of the LFO (must be between -1.0 and 1.0)\nfloat lfoTriangle(float t, float hz, float skew, float phaseShift) {\n  skew = clamp(skew, EPSILON, 1.0 - EPSILON);\n  float cFrac = cycleFrac(t, hz, phaseShift);\n  float desc = step(skew, cFrac);\n  \n  return ((1.0 - desc) * cFrac / skew) + (desc * (1.0 - cFrac / (1.0 - skew)));\n}\n\n\n// Sine wave LFO\n// - t: time\n// - hz: LFO frequency (in Hertz)\n// - skew: fraction of time that the wave is ascending (must be between 0.0 and 1.0)\n// - phaseShift: shift the phase of the LFO (must be between -1.0 and 1.0)\nfloat lfoSine(float t, float hz, float skew, float phaseShift) {\n  skew = clamp(skew, EPSILON, 1.0 - EPSILON);\n  float cFrac = cycleFrac(t, hz, phaseShift);\n  float desc = step(skew, cFrac);\n\n  return ((1.0 - desc) * sin(PI * cFrac / skew)) + (desc * sin(PI + PI * (1.0 - cFrac / (1.0 - skew))));\n}\n\n\n/**************\n * MODULATORS *\n **************/\n \n// 1: Colour\n\n// How quickly the colours shift in the animation.\n//   - value is relative to other *_RATE parameters\nconst float COLOUR_RATE = 1.0;\n\n\n// 2: Warp\n\n// How quickly the polar grid warping occurs in the animation.\n//   - value is relative to other *_RATE parameters\nconst float WARP_RATE = 1.0;\n\n\n\nvec2 getWarp(float t) {\n  float xWarp = sin(sin(t) + 0.33 * sin(3.0 * t + 0.25) + 0.2 * sin(5.0 * t - 0.25));\n  float yWarp = sin(0.01 * (sin(0.3 * t) + 0.5 * sin(t - 0.25) + 6.0 * sin(13.0 * t)));\n  \n  return 2.0 * normalize(vec2(xWarp, yWarp));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float cScale = 5.0;\n    \n    float colorRate = 0.01;\n    float coreWarpRate = 0.051;\n    float warpRate = 0.07;\n    float blinkRate = 0.0075;\n    \n    float warpMix = 0.0025;\n    float warpMixModulationRate = 0.001;\n    float coreDisplacement = 1.0;\n    float coreWarpMix= 0.5;\n    \n    float tCore = iTime * coreWarpRate;\n    mat2 rotCore;\n    rotCore[0] = vec2(cos(tCore), -sin(tCore));\n    rotCore[1] = vec2(sin(tCore), cos(tCore));\n    \n    vec2 core = (0.5 *  iResolution.xy);\n    vec2 coreOffset = rotCore * vec2(coreDisplacement * core.y, 0);\n    core += (1.0 - coreWarpMix) * coreOffset + (getWarp(tCore) * core.y * coreWarpMix);\n    \n    vec2 fcTrans = fragCoord.xy - core;\n    \n    float tWarp = warpRate * iTime;\n    mat2 rotT;\n    rotT[0] = vec2(cos(tWarp), -sin(tWarp));\n    rotT[1] = vec2(sin(tWarp), cos(tWarp));\n    \n    float r = length(fragCoord.xy - 0.5 * iResolution.xy);\n    \n    vec2 c1 = rotT * vec2(0, cScale);\n    float phi1 = atan(fcTrans.y - c1.y * iResolution.x, fcTrans.x - c1.x * iResolution.x);\n    mat2 rotPhi1;\n    rotPhi1[0] = vec2(cos(phi1), -sin(phi1));\n    rotPhi1[1] = vec2(sin(phi1), cos(phi1));\n    \n    vec2 c2 = rotT * vec2(0, -cScale);\n    float phi2 = atan(fcTrans.y - c2.y * iResolution.x, fcTrans.x - c2.x * iResolution.x);\n    mat2 rotPhi2;\n    rotPhi2[0] = vec2(cos(phi2), -sin(phi2));\n    rotPhi2[1] = vec2(sin(phi2), cos(phi2));\n        \n    vec2 c3 = rotT * vec2(cScale, 0);\n    float phi3 = atan(fcTrans.y - c3.y * iResolution.x, fcTrans.x - c3.x * iResolution.x);\n    mat2 rotPhi3;\n    rotPhi3[0] = vec2(cos(phi3), -sin(phi3));\n    rotPhi3[1] = vec2(sin(phi3), cos(phi3));\n        \n    vec2 c4 = rotT * vec2(-cScale, 0);\n    float phi4 = atan(fcTrans.y - c4.y * iResolution.x, fcTrans.x - c4.x * iResolution.x);\n    mat2 rotPhi4;\n    rotPhi4[0] = vec2(cos(phi4), -sin(phi4));\n    rotPhi4[1] = vec2(sin(phi4), cos(phi4));\n    \n    float tMix = warpMixModulationRate * iTime;\n    vec2 basePos = 256.0*fragCoord.xy/iResolution.x;\n    vec2 pos =  1.0 * basePos \n      + warpMix * sin(tMix) * (rotPhi1 * basePos * r) \n      + warpMix * cos(tMix) * (rotPhi2 * basePos * r)\n      + warpMix * sin(tMix) * (rotPhi3 * basePos * r)\n      + warpMix * cos(tMix) * (rotPhi4 * basePos * r);\n\n    float tColor = iTime * colorRate;\n    vec2 cWarp = getWarp(tColor);\n    vec2 fWarp = getWarp(3.0 * tColor);\n\n    vec3 col = vec3(0.0);\n    for( int i=0; i<6; i++ ) \n    {\n        vec2 a = floor(pos);\n        vec2 b = fract(pos);\n        \n        vec4 w = fract((sin(a.x*7.0+31.0*a.y + blinkRate*iTime)+vec4(0.10 + (0.01 * cWarp.y),0.192,0.185 + (0.005 * cWarp.x),0.205 + (0.005 * sin(1.1 * tColor))))*13.545317); // randoms\n                \n        col += w.xyz *                                   // color\n               2.0*smoothstep(0.45,0.55,w.w) *           // intensity\n               sqrt( 12.0*b.x*b.y*(1.0-b.x)*(1.0-b.y) ); // pattern\n        \n        pos /= 2.0 + (0.2 * fWarp.x); // lacunarity\n        col /= 2.0 + (0.2 * fWarp.y); // attenuate high frequencies\n    }\n    \n    col = pow( col, vec3(0.7,0.8,0.5) );    // contrast and color shape\n    \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}