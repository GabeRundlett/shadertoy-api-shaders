{
    "Shader": {
        "info": {
            "date": "1623900187",
            "description": "Y'know those pinboard sculpture thingies:\n\nhttps://www.boredpanda.com/be-a-pin-up-by-lulu-guinness/?utm_source=google&utm_medium=organic&utm_campaign=organic",
            "flags": 32,
            "hasliked": 0,
            "id": "7lBGWD",
            "likes": 3,
            "name": "The shimmer",
            "published": 3,
            "tags": [
                "dots",
                "mograph",
                "chromab",
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "xenn",
            "viewed": 354
        },
        "renderpass": [
            {
                "code": "// Fork of Jeyko, 2021-06-17 https://www.shadertoy.com/user/jeyko\n// \"maybe mention that this forked from my shader?\n// It just keeps the website sorted.\"\n\n// Jeyko has heaps of intrigueing and fascinating code vignettes, you should check them all out!\n// 2021-06-09 02:00:41\n\n// and it has been further forked with the following and possibly one each per buffer channel.\n// Though, each buffer also may change in the future too. So, No promises. No threats.\n\n// ahem \n// also created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat getVal(vec2 uv)\n{\n    return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )/delta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 n = vec3(getGrad(uv,01.0/iResolution.y),500.+(10.0*cos(iTime/3.)));\n    //n *= n;\n    n=normalize(n);\n    fragColor=vec4(n,1);\n    vec3 light = normalize(vec3(1,1,2));\n    float diff=clamp(dot(n,light),0.5,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,88.0)*1.25;\n    //spec=0.0;\n\t// Convert the uv's to polar coordinates to scale up  \n    vec2 polarUv = (uv * 2.0 - 1.0);\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    // Scale up the length of the vector by a noise function feeded by the angle and length of the vector\n    float ll = length(polarUv)*0.4915+(0.01*sin(iTime));\n    \n    vec3 base = texture(iChannel0, uv).rgb;\n    \n    // Convert the scaled coordinates back to cartesian\n    vec2 offs = vec2(cos(angle)*ll + 0.5, sin(angle)*ll + 0.5);\n    vec3 overlay = texture(iChannel1,offs).rgb;\n    \n     vec4 col = vec4(base + overlay*(0.478975+(0.1*cos(iTime/4.3))), 1.0);\n    \n//    fragColor = col;\n    \n    fragColor = texture(iChannel0,uv)*vec4(diff)+vec4(spec)+vec4(col);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": " \n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\n\n\nfloat cyclicNoise(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.9;\n    const float lacunarity = 1.5;\n    const int octaves = 6;\n    \n    const float warp = 0.2;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .2;\n    \n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\nfloat cyclicNoiseMarb(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.6;\n    const float lacunarity = 1.75;\n    const int octaves = 9;\n    \n    const float warp = 0.7;    \n    float warpTrk = 2. ;\n    const float warpTrkGain = 1.09;\n    \n    vec3 seed = vec3(-5,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\nfloat cyclicNoiseMarbB(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.6;\n    const float lacunarity = 1.75;\n    const int octaves = 5;\n    \n    const float warp = .9;\n    float warpTrk = 1. ;\n    const float warpTrkGain = 1.09;\n    \n    vec3 seed = vec3(-5,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// :)\n// in the vibe of https://twitter.com/beesandbombs\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define dmin(a,b) a.x < b.x ? a : b\n#define preplim(g,c,l) g-c*clamp(round((g)/c),-l,l)\n#define xor(a,b,c) min(max(a,-b), max(-a,b + c))\n\n\n\nfloat pixSz;\n\n// Hex code from BigWings! He has a tutorial on them.\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c, p.x);\n    return c;\n}\n\nvec4 HexCoords(vec2 uv, out vec2 gv) {\n\tvec2 r = vec2(1, 01.-(0.502*(cos(iTime/4.))));\n    vec2 h = r*.5;\n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;\n    gv = dot(a, a) < dot(b,b) ? a : b;\n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = uv-gv;\n    return vec4(x, y, id.x,id.y);\n}\n\n\nfloat sdBox(vec2 p, vec2 s){\n    p = abs(p) - s; return max(p.x, p.y);\n}\nvoid getTile( vec2 p, out float d, inout vec3 col, vec2 gv, vec4 hc){\n    vec2 op = p;\n    for(float i = 0.; i < 3.; i++){\n        float t = iTime - i*.05;\n        p = op;\n        \n        float m =   + 0.3*sin( hc.z*1. + sin(hc.w + t)*0.4)*sin(t) + .4*( length(hc.zw) + sin(length(hc.w)*0.));\n        p *= rot(0. \n            + m - length(hc.zw)*0.9\n            + t*3.);\n\n        p.y += 0.5;\n        p.x -= sin(hc.w)*.5*(sin(m*1.14));\n        d = length(p) - sin(m*2. + t)*0.04 - 0.05;\n\n        col[int(i)] = mix( col[int(i)], 1., smoothstep(pixSz*2.,0.,d));\n    \n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 ouv = uv;\n    \n    uv *= 32.;\n    \n    //uv.y += iTime*0.5;\n    \n    pixSz = fwidth(uv.x);\n    \n    vec2 gv;\n    vec4 hc = HexCoords(uv, gv);\n    /*\n    float d = map(gv);\n    col += smoothstep(pixSz,0.,abs(d));\n    */\n    for(float i = 0.; i < 7.; i++){\n        vec2 offs = vec2(0);\n        \n        float ioffs = 0.;\n        if(i < 3. ){\n            float offsIdx = tau*(i + ioffs)/6.;\n            offs = vec2(sin(offsIdx),cos(offsIdx))*0.5;\n        } else if( i == 3.) {\n        \n        } else if( i == 4. || i == 5.){\n            float offsIdx = tau*(i + ioffs - 1. + float(i == 5.)  )/6.;\n            offs = vec2(sin(offsIdx),cos(offsIdx))*0.5;\n        \n        } else if( i == 6.){\n            float offsIdx = tau*(i + ioffs - 2.)/6.;\n            offs = vec2(sin(offsIdx),cos(offsIdx))*0.5;\n        }\n        \n        vec4 hc = HexCoords(uv + offs, gv);\n        \n        float d; \n        getTile(gv - offs, d, col, uv - offs, hc);\n        \n        \n        \n    }\n    \n    \n    \n    col = max(col,0.);\n    col = mix(col,col*col*0.0,pow(smoothstep(0.,1.,dot(ouv,ouv)),1.0));\n\n    col *= vec3(1.,1.,1.);\n    \n   // if( mod(iTime/10.,1.) > 0.66)\n        col = 1. - col;\n  //  if(iMouse.z > 0.5)\n        col = 1. - col;\n    col = pow(col,vec3(.5));\n    \n    \n    fragColor.xyz += col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Fork of \"spilled\" by flockaroo. https://shadertoy.com/view/MsGSRd\n// 2020-05-07 11:42:26\n\n// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\nfloat getVal(vec2 uv)\n{\n    return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )/delta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 n = vec3(getGrad(uv,01.0/iResolution.y),500.+(10.0*cos(iTime/3.)));\n    //n *= n;\n    n=normalize(n);\n    fragColor=vec4(n,1);\n    vec3 light = normalize(vec3(1,1,2));\n    float diff=clamp(dot(n,light),0.5,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,88.0)*1.25;\n    //spec=0.0;\n\t// Convert the uv's to polar coordinates to scale up  \n    vec2 polarUv = (uv * 2.0 - 1.0);\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    // Scale up the length of the vector by a noise function feeded by the angle and length of the vector\n    float ll = length(polarUv)*0.4915+(0.01*sin(iTime));\n    \n    vec3 base = texture(iChannel0, uv).rgb;\n    \n    // Convert the scaled coordinates back to cartesian\n    vec2 offs = vec2(cos(angle)*ll + 0.5, sin(angle)*ll + 0.5);\n    vec3 overlay = texture(iChannel1,offs).rgb;\n    \n     vec4 col = vec4(base + overlay*(0.478975+(0.1*cos(iTime/4.3))), 1.0);\n    \n//    fragColor = col;\n    \n    fragColor = texture(iChannel0,uv)*vec4(diff)+vec4(spec)+vec4(col);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define PI 3.1415926536\n\nvec2 rotate(vec2 src, float angle) {\n    float sn = sin(angle);\n    float cs = cos(angle);\n    return vec2(src.x * cs - src.y * sn, src.x * sn + src.y * cs);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,4,4));\n\n    float radius = 0.0065;\n    float angle = iTime * 4.0 + (uv.x * 80.0 + uv.y * 80.0) * 0.015;\n    float angle2 = iTime * 4.0 + (uv.x * 80.0 + uv.y * 80.0) * 0.015;\n    float angle3 = iTime * 4.0 + (uv.x * 80.0 + uv.y * 80.0) * 0.015;\n    \n    vec2 vector = vec2(0, radius);\n    \n    vec4 red = texture(iChannel0, uv + rotate(vector/* + sin(iTime * 7.0) * 0.0025*/, angle));\n    vec4 green = texture(iChannel0, uv + rotate(vector/* + sin(iTime * 9.0) * 0.0025*/, angle2 + 2.0 * PI / 3.0));\n    vec4 blue = texture(iChannel0, uv + rotate(vector/* + sin(iTime * 11.0) * 0.0025*/, angle3 + 2.0 * PI / 3.0 * 2.0));\n    fragColor = vec4(red.r, green.g, blue.b, 1.0);\n\n    // Output to screen\n    // fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Fork of \"spilled\" by flockaroo. https://shadertoy.com/view/MsGSRd\n// 2020-05-07 11:42:26\n\n// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\nfloat getVal(vec2 uv)\n{\n    return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )/delta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 n = vec3(getGrad(uv,01.0/iResolution.y),500.+(100.0*cos(iTime/4.)));\n    //n *= n;\n    n=normalize(n);\n    fragColor=vec4(n,1);\n    vec3 light = normalize(vec3(1,1,2));\n    float diff=clamp(dot(n,light),0.5,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,88.0)*1.25;\n    //spec=0.0;\n\t// Convert the uv's to polar coordinates to scale up  \n    vec2 polarUv = (uv * 2.0 - 1.0);\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    // Scale up the length of the vector by a noise function feeded by the angle and length of the vector\n    float ll = length(polarUv)*0.4915+(0.01*sin(iTime));\n    \n    vec3 base = texture(iChannel2, uv).rgb;\n    \n    // Convert the scaled coordinates back to cartesian\n    vec2 offs = vec2(cos(angle)*ll + 0.5, sin(angle)*ll + 0.5);\n    vec3 overlay = texture(iChannel1,offs).rgb;\n    \n     vec4 col = vec4(base + overlay*(0.0+(1.0*cos(iTime/3.))), 1.0);\n    \n//    fragColor = col;\n    \n    fragColor = (texture(iChannel0,uv)-texture(iChannel2,uv))*(vec4(diff)+vec4(col))+vec4(spec)+vec4(col);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}