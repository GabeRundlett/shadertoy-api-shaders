{
    "Shader": {
        "info": {
            "date": "1712255255",
            "description": "Fully deterministic large-caliber fireworks. Use the mouse to scrub backward/forward through time.",
            "flags": 0,
            "hasliked": 0,
            "id": "4fdGDl",
            "likes": 11,
            "name": "Deterministic Fireworks",
            "published": 3,
            "tags": [
                "procedural",
                "sphere",
                "glow",
                "deterministic",
                "fireworks"
            ],
            "usePreview": 0,
            "username": "milkfat",
            "viewed": 266
        },
        "renderpass": [
            {
                "code": "/*\n\nCode written 2021-08-25\n\nPublished 2024-04-04\n\n*/\n\n\n#define PI 3.14159\n//#define TRAILS\n#define NUM_SHELLS 3\n#define TIME iTime\n\nvec2 rotate(vec2 p, float a) {return vec2 (cos(a)*p.x - sin(a)*p.y, sin(a)*p.x + cos(a)*p.y);}\nfloat moda(float r) {return (mod(1.0+r/PI,2.0)-1.0)*PI;}\n\n//float hash(float n) {return fract(n*fract(n*.133929));}\nfloat hash(float p) {\n   // p=isnan(p)?0.0:p;\n    p=fract(p*.917331);\n    uint b = uint(p*123456.7);\n\tb += 0x9e3779b9u;\n\tb ^= b >> 15;\n\tb *= 0x85ebca6bu;\n\tb ^= b >> 13;\n\tb *= 0xc2b2ae3du;\n\tb ^= b >> 16;\n\treturn fract(abs(float(b)/1000000.0));\n}\n\nfloat vf(vec3 p) {return fract(p.x)*fract(p.y)*fract(p.z);}\n\nfloat dist(vec3 p, inout vec3 col, float seed, inout vec3 col2, float time)\n{\n    seed=hash(seed);\n    vec3 mx = vec3(iResolution.xy*(4000.0/iResolution.y),4000);\n    float md = 3.0+seed;\n    float mdx = md;\n    float tmd = mod(time,md);\n    float tid = time/md;\n    float stp = tmd/md;\n    stp=stp*(mdx/(3.0+seed));\n    \n    float rand = hash(seed+1.12*floor(tid));\n    float rand2 = hash(seed+.9713*floor(tid));\n    \n    vec3 loc = vec3(rand*mx.x*.9-mx.x*.45,rand2*mx.y*.5-mx.y*.125,4000); //burst location\n    \n    //rising shell effect\n    float pre_rand = hash(seed+1.12*floor(tid+1.0));\n    float pre_rand2 = hash(seed+.9713*floor(tid+1.0));\n    vec3 pre_loc = vec3(pre_rand*mx.x*.9-mx.x*.45,pre_rand2*mx.y*.5-mx.y*.125,4000); //next burst location\n    pre_loc.y-=(1.0-stp)*(1.0-stp)*(pre_loc.y+mx.y*.5);\n    pre_loc.x-=(pre_loc.x<0.0)?(pre_loc.x+mx.x*.25)*(1.0-stp):(pre_loc.x-mx.x*.25)*(1.0-stp);\n    float d_shell = distance(p,pre_loc)-10.0;\n    \n    \n    p.y+=(stp*stp)*200.0; //gravity\n    \n    float val=stp;\n    val=val*val*val*val*val;\n    val=1.0-val;\n    val*=1.0-pow(1.0-stp,3.0);\n\n    \n    col = vec3(float(rand>.5),float(rand2>.5),float(rand<.5||rand2<.5)); //random color\n    //col = max(col,vec3(.1));\n    \n    p-=loc;\n    float lp = length(p);\n    \n    \n    \n    \n    /*\n    \n    //droop\n    float llp=lp/1000.0;\n    llp=pow(llp,llp*5.0+1.0);\n    llp*=1000.0;\n    p.y+=llp/3.0;\n    */\n    \n    float sz = (500.0+rand2*1000.0); //overall size\n    \n    //atmospheric effect\n    float burst_stp = clamp(1.0-stp*30.0,0.0,1.0);\n    float post_burst_stp = clamp(stp*8.0-1.0/30.0,0.0,1.0);\n    col=col*post_burst_stp*post_burst_stp+vec3(burst_stp*burst_stp*burst_stp);\n    float amt = clamp(((6000.0+sz)-lp)/(6000.0+sz),0.0,1.0);\n    col2+=clamp(val*col*pow(amt,5.0),0.0,1.0)*(hash(vf(p)*stp)*.5+.5)*.02; //atmosphere glow\n    col2+=pow(clamp(burst_stp*burst_stp*pow(amt,8.0),0.0,1.0),1.0)*.15*(1.0+rand2*rand2*3.0); //bright flash\n    \n    //break early\n    if(lp>sz+200.0&&d_shell>0.0){col=vec3(0);return min(d_shell,lp*.3);}\n    \n    //random rotation\n    p.yz=rotate(p.yz,rand*PI*2.0);\n    //p.xy=rotate(p.xy,iTime);\n    p.xz=rotate(p.xz,rand*PI*3.1);\n    \n    //procedurally find the closest star\n    float ang1 = atan(p.y,p.x);\n    vec3 tp = p;\n    tp.xy = rotate(tp.xy, -ang1);\n    float ang2 = atan(tp.z,tp.x);\n    \n    float dense = (11.0+rand2*11.0)/PI; //star density\n\n    ang2 = round(ang2*(dense))/(dense);\n    float h = abs(ang2/PI);\n    h = abs(.5-h);\n    h*=2.0;\n    \n    ang1 = round(ang1*(h*dense))/(h*dense);\n    ang1 = moda(ang1);\n    ang2 = moda(ang2);\n    float h1 = hash(ang1);\n    float h2 = hash(ang2);\n    float h3 = hash(ang1*ang2);\n    ang1+=h2*h3*(.1)-.05; //slightly random star position\n    ang2+=h1*h3*(.1)-.05;\n    \n    p.xy = rotate(p.xy,-ang1);\n    p.xz = rotate(p.xz,-ang2);\n    \n    \n    //variegated colors\n    if(hash(rand2)>.7)\n    col = vec3(h1,h2,h3);\n    \n    //overall size of the firework based on time\n    sz+=h3*40.0*(burst_stp>0.0?10.0:1.0)-20.0; //slightly random star velocity\n    float m = tmd;\n    m/=mdx;\n    m*=.7;\n    m=1.0-m;\n    m=pow(m,m*5.0+1.0); //deceleration\n    m=1.0-m;\n    m=clamp(m,0.0,1.0);\n    m=m*sz;\n    \n    //calculate distance to star\n    float d1 = distance(p,vec3(1.0+m,0,0));\n    #ifdef TRAILS\n    float d2 = length(vec3(max(p.x-m,0.0),p.yz)); //trails\n    float d=(d1<.0)?d1:d2;\n    #else\n    float d = d1;\n    #endif\n    \n    //add some randomness to each star's life/brightness\n    float m2 = tmd;\n    m2/=md;\n    m2+=h3*h3*.3;\n    m2=m2*m2*m2*m2*m2;\n    m2=1.0-m2;\n\n    //add some star glow\n    float cm = 9.0-d;\n    cm/=9.0;\n    cm=clamp(cm,0.0,1.0);\n    cm=pow(cm,2.0);\n    \n    //add some atmospheric glow\n    float cm2 = 100.0-d;\n    cm2/=100.0;\n    cm2=clamp(cm2,0.0,1.0);\n    cm2=pow(cm2,5.0);\n    //col=(abs(ang2)<.1||abs(ang2)>.9)?col:col=vec3(0); //bow tie\n    \n    \n    \n    #ifdef TRAILS\n    if(d1>5.0)\n    {\n        float t = clamp(clamp(p.x/m,0.0,1.0)*2.0-1.0,0.0,1.0)*.08;\n        float v = (col.x+col.y+col.z)/3.0;\n        col=vec3(v*1.2,v*1.1,v);\n        col*=t;\n    }\n    #endif\n    \n    col2 += clamp(cm2*col*m2*1.0,0.0,1.0); //star glow\n    \n    //final star brightness\n    col *= cm*m2*.3; //star light\n    col=max(col,vec3(0));\n    \n    d = min(d_shell,d);\n    if(d==d_shell)col=vec3(pow(clamp(1.0-(d_shell*.1+1.0),0.0,1.0),2.0))*vec3(.04,.02,.02);\n    return d;\n    \n    \n    //float asdf = hash(hash(ang1)*ang2)*2.0-1.0;\n    //return (lp-(500.0-asdf*50.0));\n\n}\n\n\nvoid mainImage( out vec4 F, in vec2 C )\n{\n    C-=iResolution.xy*.5;\n    vec3 p = vec3(C,0.0);\n    vec3 ps = normalize(vec3(C*(4000.0/iResolution.y),4000.0)-p);\n    vec3 col=vec3(0);\n    vec3 col2=vec3(0);\n    float mowss = (iMouse.z>0.0)?(iMouse.x*30.0)/iResolution.x-15.0:0.0;\n    for (int i = 0; i < 200; i++)\n    {\n        float min_d = 10000.0;\n        vec3 c2=vec3(0);\n        for (int j; j<NUM_SHELLS; j++)\n        {\n            vec3 c;\n            float d = max(dist(p, c, hash(float(j)), c2,TIME+mowss),1.0);\n            min_d=min(min_d,d);\n            col+=c;\n        }\n        if(p.z>7500.0)break;\n        col2+=(c2)*min_d*.004;\n        p+=ps*max(min_d,1.0)*.9;\n    }\n    col+=col2*.02;\n    F=vec4(col,0);\n    F*=8.0;\n    F=pow(F,vec4(1./2.2));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}