{
    "Shader": {
        "info": {
            "date": "1608857124",
            "description": "potato",
            "flags": 0,
            "hasliked": 0,
            "id": "tttyWn",
            "likes": 42,
            "name": "Day 372",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 1,
            "username": "jeyko",
            "viewed": 866
        },
        "renderpass": [
            {
                "code": " \nvec2 dmin(vec2 a, float b, float cmp){return a.x < b ? a : vec2(b,cmp);}\n\n// PBR atmospheric scattering, learned from Sebastian Lague https://www.youtube.com/watch?v=DxfEbulyFcY\n// ACES from knarkowitz\n// cheap noise from nimitz\n// voronoi, smoothmin from iq\n// noise from dave hoskins\n \n\nfloat sdSnowflakes(vec3 _p, float md, float s){\n  vec4 p = vec4(_p,1.);\n  \n  p.yw *= rot(0.4);\n  p = abs(p);\n  p.xz *= rot(0.4);\n  p = abs(p);\n  \n  p.xy *= rot(2.4); \n  p = abs(p) - 1.4;\n  \n  p.yz *= rot(.7);\n  p = abs(p);\n  p = pmod(p,md);\n  \n  return length(p) - s ;\n}\n\nfloat fe;\nfloat fbmSnow(vec3 p){\n\n    vec3 op = p;\n    float n = 0.;\n    p *= 0.25;\n    fa = valueNoise(p,1.); \n    \n    \n    p *= 8.;\n    \n    p.y = 1.;\n    \n    float fb = valueNoise(p*2.,1.);\n    \n    \n    float fc = valueNoise(p*4.,1.);\n    \n    float fd = valueNoise(p*8.1,1.);\n  \n    fe = valueNoise(p*20.1,1.);\n  \n\n    n += fa + (fb*0.51 + fc*0.255 + fd*.125 + fe*0.07)*0.02 ; /*fa*/;// + valueNoise(op*5.8,1.)*0.0;\n    \n    n *= 1.2;\n    \n    return n;\n}\n\nfloat sdSnow(vec3 p){\n    float d = 10e5;\n    \n    d = p.y;\n    \n    d -= fbmSnow(p); \n    \n    return d;\n}\n\nfloat getWalk(vec3 p){\n    return valueNoise(vec3(1,1,p.z*0.1),1.)*24.;\n}\n\n\nvec3 getLampP(vec3 p, bool getLightP, bool getLightRelative){\n    vec3 op = p;\n    p.y -= lampH * 0.5;\n\n    p.x -= 1.5;\n    \n    float md = 8.;\n    float id = floor(p.z/md)*md;\n    p.z = pmod(p.z,md);\n    \n    float walk = getWalk(vec3(1,1,id + 0.5*md));\n    p.x += walk;\n    \n    if(getLightRelative){\n        p = vec3(0,0.,id + md*0.5);\n        p.x -= walk;\n        p.x += 1.5;\n        p.x -= lampW;\n        p.y += lampH * 0.5;\n    } else if( getLightP ){\n    \n        p.y -= lampH - 0.4;\n    \n        p.x += lampW*0.55;\n    }\n        \n    return p;\n\n}\n\nfloat noiseLamp;\nvec2 sdLamp(vec3 p){\n\n    p = getLampP(p,false,false);\n    \n    float lampR = 0.02;\n    \n    float d = sdVerticalCapsule( p, lampH, lampR );\n    \n    p.y -= lampH;\n    \n    d = min(d, sdRoundCone( p, lampR, 0.01, 0.1));\n    \n    d -= smoothstep(0.3,0.,abs(p.y + 0.1)*8.)*abs(sin(p.y*48.))*0.04;\n    \n    \n    d -= smoothstep(1.,0.,abs(p.y + 0.32)*8.)*pow(abs(sin(p.y*8.)),5.)*0.04;\n    \n    d -= pow(smoothstep(3.1,2.,abs(p.y + 1.32)*5.),0.01)*pow(abs(sin(p.y*4.)),.3)*0.03;\n    \n    d -= pow(smoothstep(3.1,2.,abs(p.y + 1.32)*15.),0.01)*pow(abs(sin(p.y*24.)),.3)*0.03;\n    \n    \n    \n    d = opSmoothUnion( d, sdRoundCone( p + vec3(0.,lampH*1.,0), lampR, 0.07, 0.4), 0.01 );\n    \n    d = opSmoothUnion( d, sdRoundCone( p + vec3(0.,lampH*1.5,0), lampR*11.2, lampR*2.5, 0.8) - 0.01, 0.3 );\n    \n    \n    p.y += 0.3;\n    p.xy *= rot(-0.5*pi);\n    \n    vec3 op = p;\n    p.x += smoothstep(1.,0.,(p.y- 0.1)*1.)*0.2;\n    \n    p.y += lampW*0.2;\n    float vert =sdVerticalCapsule( p, lampW*1., lampR ); \n    \n    vert -= smoothstep(1.,0.,abs(p.y + 0.02)*18.)*abs(sin(p.y*78.))*0.04;\n    \n    \n    \n    \n    p = op;\n    p.y += lampW*0.2;\n\n    //vert -= smoothstep(1.,0.,abs(p.y - lampW)*4.)*pow(abs(sin(p.y*42.)),0.2)*0.04;\n    //vert -= smoothstep(0.3,0.,abs(p.y - lampW)*4. - 1.)*0.015;\n    \n    d = opSmoothUnion( d, vert, 0.02 );\n\n    p.xy *= rot(0.5*pi);\n    \n    p.x += lampW*0.85;\n    p.y += 0.4;\n    \n    float cup = abs(sdRoundCone( p + vec3(0,0.05,0) , 0.2, 0., 0.2)) - 0.01;\n\n    cup += sin(length(p.xz)*55.)*smoothstep(1.,0.,length(p.xz))*0.02;\n    cup = opSmoothSubtraction( -cup, -p.y, 0.05 );\n    \n    cup = opSmoothUnion(cup,  sdRoundCone( p - vec3(0,0.14,0), 0.04, 0.005, 0.3 ), 0.07);\n    \n    d = opSmoothUnion( d, cup, 0.01 );\n    \n    //d = min(d, );\n    \n    vec2 od = vec2(d,2.);\n    \n    float bulb = length(p) - 0.1;\n    \n    od = dmin(od,bulb,4.);\n    \n    if(!volumetricMarching)\n        glow += exp(-bulb*6.)*smoothstep(0.2,0.,p.y + 0.15)*smoothstep(1.,0.,bulb*1.5);\n    \n    \n    if(mapShadows){\n        od = max(od,-(length(p) - 1.5));\n    }\n         \n    od.x -= (fa = pow(valueNoise(p*120.,1.),3.))*0.001;//valueNoise(p*20.,1.);\n    \n    return od;\n}\n\nvec3 fluv;\n\nfloat getFloor(){\n    vec3 uv = fluv;\n    vec3 buv = uv;\n    vec2 md = vec2(0.5,0.25);\n    \n    vec2 id = floor(uv.xz/md);\n    uv.x += md.x*0.5*id.y;\n    uv.xz = pmod(uv.xz,md);\n    \n    buv.z = pmod(buv.z,4.);\n    \n    \n    \n    uv.xz = abs(uv.xz);\n    \n    float d = 0.;\n    \n    d += smoothstep(0.,0.05, max( (uv.x - md.x*0.45)/md.x/2., uv.z - md.y*0.4));\n    \n    \n    d = mix(d,-1.+smoothstep(0.02,0.0,length(buv.xz) - 0.11),1.-smoothstep(0.0,0.02,length(buv.xz) - 0.2));\n    \n    \n    \n    d -= fa*0.125;\n    return d;\n}    \nfloat sdSideRail(vec3 p){\n    \n    p.x = abs(p.x) - 0.9;\n    p.y -= 0.6;\n    float d = length(p.xy) - 0.02;\n    \n    vec3 pb = p;\n    \n    p.z = pmod(p.z,1.);\n    \n    pb.z = pmod(pb.z - 2.5,4.);\n    \n    d = min(\n            d,\n        max(\n            length(p.zx) - 0.02,\n            p.y - 0.01\n            )\n        );\n    \n    float topHat = sdRoundCone( pb, 0.01, 0.04, 0.1 );\n    \n    d = min(d, topHat);\n    \n    \n    \n    d -= fa*0.001;\n    return d;\n}\n\n\nfloat dsnow;\nvec2 map(vec3 p){\n    vec2 d = vec2(10e5);\n    \n\n    \n    float snow = sdSnow(p);\n    vec2 lamp = sdLamp(p);\n    \n    float walk = getWalk(p);\n    \n\n        \n    \n    float ground = -abs(p.x + walk) + 0.9;\n    //ground = min( ground, p.y + snow + 0.2);\n    ground = opSmoothUnion(ground,p.y + snow + 0.2 + pow(valueNoise(p,1.),1.)*1.5,1. );\n    \n    \n    float fl = p.y + 0.1;\n    \n    fluv = p;\n    fluv.x += walk;\n    fl += getFloor()*0.015;\n    \n    d = dmin(d,fl,5.);\n    \n    \n    snow = opSmoothSubtraction(-snow,ground,0.4);\n    \n    \n    \n    vec3 flakeWindDir = -normalize(vec3(-4,-2.6,-1.6));\n    vec3 pFlakes = p + iTime*flakeWindDir;\n    float n = valueNoise(pFlakes*1.,1.);\n    float flakeWind = n*0.5;\n    \n    pFlakes.y += n*0.6;\n    \n    snowFlakes = sdSnowflakes(pFlakes + flakeWindDir*flakeWind*7. , 1., 0.017);\n\n    snowFlakes = min(snowFlakes, sdSnowflakes(pFlakes + 1.2 + flakeWindDir*iTime*.7 + flakeWind , 1., 0.014));\n    \n    snowFlakes = min(snowFlakes, sdSnowflakes(pFlakes + 0.6 + flakeWindDir*iTime*2. + flakeWind , 0.75, 0.014));\n    \n    snowFlakes = min(snowFlakes, sdSnowflakes(pFlakes + 4.6 + flakeWindDir*iTime*2.5 + flakeWind , 0.75, 0.014));\n    \n\n    \n    //snow = opSmoothUnion(snow,,0.41);\n    \n    \n    \n\n    float sideRail = sdSideRail(vec3(p.x + walk,p.y,p.z));\n    \n    snow = opSmoothSubtraction( -snow, -lamp.x, 0.2);\n    \n    d = dmin(d,lamp.x,lamp.y);\n    \n    \n    d = dmin(d,sideRail,lamp.y);\n    \n\n    if(!volumetricMarching && !mapShadows)\n        dsnow = snow;\n    \n    snow = opSmoothUnion(snow,sideRail,0.1);\n\n    \n    \n    d = dmin(d,snow,1.);\n    \n    //float drocks = sdRocks(p, 14.4, 3.8);\n    //drocks = opSmoothSubtraction( -drocks, -(-length(p) + planetSz + 4.5), 1.2 );\n    \n    //d = dmin(d, drocks,3.);\n    \n    \n    d.x *= 0.75;\n    return d;\n}\nfloat mapVolumetricFog(vec3 p){\n    float dens = 0.;\n    \n    vec3 op = p;\n    p += vec3(iTime*3.,-4.3*iTime,0);\n    \n    dens = valueNoise(p*0.4,1.);\n    \n    dens *= smoothstep(1.,0.,op.y*.1);\n    \n    \n    //dens = pow(max(dens,0.),0.4);\n    \n    return dens*0.1 + 0.007;\n}\nfloat mapVolumetricLight(vec3 p){\n    \n    vec3 lp = getLampP(p,true,false);\n    lp.xy *= rot(pi);\n    \n    return sdRoundCone( lp, 0., 12., 14.9 );\n    return sdSolidAngle(lp, vec2(.25,0.5), 15.9);\n}\n\nvec3 getNormal(vec3 p){\n      vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.001).x;\n    }\n    return normalize(n);\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\nfloat softshadowa( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h*smoothstep(0.1,0.,maxt - t );\n    }\n    return res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0);\n    \n    \n    vec3 sunPos = vec3(1,0.1 + sin(iTime)*0.02,1.)*200.;\n    vec3 sunDir = normalize(sunPos);\n    \n    ro.y += 2.;\n    ro.z += iTime;\n    ro.x -= getWalk(ro);\n    \n    vec3 lookAt = vec3(0,0,ro.z + 9.);\n    \n    lookAt.x -= getWalk(lookAt);\n    lookAt.y += valueNoise(lookAt*0.25,1.);\n    \n    \n    \n    vec3 rd = getRd( ro, lookAt, uv );\n    \n    #define pump(a,b) (floor(a) + pow(fract(a),b))\n    float sphericalEnv = cos(pump(iTime*0.06,50.)*pi + pi)*0.5 + 0.5; \n    //sphericalEnv -= sphericalEnv;\n    \n    //rd = normalize(vec3(uv,1));\n    rd = mix( rd, getRdSpherical(ro,uv),sphericalEnv);\n    ro = mix( ro, ro + vec3(0,0.9,0),sphericalEnv);\n        \n    vec3 p = ro;\n    \n\n    float t = 0.;\n    bool hit = false;\n    \n    vec3 albedo = vec3(1.,0.9,0.6);\n    // Marching\n    \n    vec2 d;\n    for(int i = 0; i < marchSteps ; i++){\n        d = map(p);\n        \n        d = dmin(d,snowFlakes,3.);\n        \n        if(d.x < marchEps){\n            hit = true;\n            break;\n        } else if (t > 29.){\n            break;\n        }\n        \n        p = ro + rd*(t += d.x);\n    }\n    \n\n    //col += totalVolDens;\n    \n    \n    \n    vec3 sunCol = vec3(0.9,0.9,0.9)*0. + vec3(1,0.9,0.7);\n        \n    float depthView = opticalDepth(p, -rd, t); \n    vec3 atmosphere = vec3(0);\n    atmosphere =  vec3(0.4,0.5,0.6)*0.3;\n\n    // Volumetrics\n    volumetricMarching = true;\n    float dith = r21(fragCoord + sin(iTime*20.)*20.)*volumetricDithAmt;\n    vec3 volP = ro;\n    float totalVolDens = 0.;\n    float totalVolLightDens = 0.;\n    float volumT = 0.;\n    for(int i = 0; i < volumetricSteps ; i++){\n        float volDens = mapVolumetricFog(volP);\n        float volLight = mapVolumetricLight(volP);\n        \n        \n        if ( volumT >  t ){\n            break;\n            \n        }\n        \n        totalVolLightDens += 5.* smoothstep(0.,0.9,-volLight + 0.2) * volumetricStepSz * (volDens ) * clamp((1.-totalVolDens*1.),0.,1.);//(1. - totalVolLightDens);\n        totalVolDens += volDens * volumetricStepSz *(1. - totalVolLightDens);\n        /*if(i%1 == 0){\n            if(map(volP).x < 0.){\n                //hit = true;\n                break;\n            }    \n        }*/\n        \n        \n        if(totalVolDens > 1.){\n            break;\n        }\n        \n        volP = ro + rd*(volumT += volumetricStepSz);\n    }\n    \n    \n    // Shading\n    \n    if(hit){\n        \n        vec3 n = getNormal(p);\n        \n        vec3 lampP = getLampP(p,false,true);\n        \n        vec3 lampDir = normalize(lampP - p);\n        \n        \n        //n.xz *= rot(-0.5);\n        \n        vec3 hf = normalize(sunDir - rd);\n        float diff = max(dot(n,sunDir),0.);\n        float spec = pow(max(dot(n,hf),0.),12.);\n        float fres = pow( 1. - max(dot( n, -rd),0.001),4.);\n        \n        vec3 hfLamp = normalize(lampDir - rd);\n        float diffLamp = max(dot(n,lampDir),0.);\n        float specLamp = pow(max(dot(n,hfLamp),0.),5.)*smoothstep(1.,0.,abs(mod(p.z,8.) -4.) - 3.);;\n        \n        \n        float specFact = 0.45;\n        \n        vec3 snowAlbedo = vec3(0.9,0.9,0.95)*1.;\n        #define SSS(a) clamp(map(p + sunDir*a).x/a,0., 1.)\n        #define ao(a) clamp(map(p + n*a).x/a,0., 1.)\n        float sssfact = SSS(0.26)*SSS(1.45)*8.5;\n        \n        mapShadows = true;\n        float shad = softshadow( p , lampDir, 0.2 + r21(fragCoord + sin(iTime)*5.)*0.04, length(p - lampP)*1. + 0.8, 5. );\n        \n        snowAlbedo = mix(snowAlbedo , vec3(0.,0.04,0.2)*0.5 + snowAlbedo*0.1,smoothstep(1.,0.,sssfact));\n        \n        \n        vec3 snowColor = snowAlbedo*(diff + smoothstep(1.,0.,sssfact)*0.3 + sssfact*(1. + diff)*0.1)\n            *(sunCol*0.5 + atmosphere) \n            + spec*specFact*(sunCol + atmosphere)*0.02;\n        \n        vec3 lampColor = 1.*(snowAlbedo*lampLightCol + lampLightCol)*(diffLamp + smoothstep(1.,0.,sssfact)*0.9 + sssfact*(1. + diff)*0.1)\n            *(sunCol*0.5 + atmosphere)\n            + lampLightCol*specLamp*specFact*10.;\n        \n        float lampRange = smoothstep(3.,0.,length(p - lampP) - 1.);\n        snowColor += lampColor * lampRange *0.4*shad;\n        //snowColor += specLamp*specFact*(lampLightCol)*20.;\n        //snowColor += specLamp*specFact*(lampLightCol)*smoothstep(1.,0.,length(p - lampP) - 1.1);\n\n        \n        float aofact = ao(0.2)*ao(1.)*1.5 + 0.2; \n        if (d.y == 1.){\n            // snow\n            col += snowColor*aofact;\n        } else if (d.y == 3.){\n            // snoflakes\n            col += (snowAlbedo*0.4 + (lampRange) *lampColor )*ao(3.);\n        } else if (d.y == 2.){\n            // lamppost\n            vec3 lampPostColor = .1*(1.- fa)*(diffLamp)\n                *(sunCol*0.25 + atmosphere)\n                + lampLightCol*specLamp*specFact*1.;            \n            \n            lampPostColor = lampPostColor*(shad + atmosphere*(1.-fa)*.15);\n            lampPostColor += fres*specFact*atmosphere*1.45;\n            lampPostColor = mix(lampPostColor*aofact,snowColor*aofact,smoothstep(0.4,0.0,dsnow + 0.05));\n            col += lampPostColor;\n                //+ spec*specFact*(sunCol + atmosphere)*.45;\n                //+ spec*.45*atmosphere;\n        } else if (d.y == 4.){\n            col += lampColor;\n        } else if (d.y == 5.){\n            // floor\n             \n            vec3 flCol = .23*vec3(1,0.6,0.4)*(1.- fa)*(diffLamp)\n                *(sunCol*0.25 + atmosphere) \n                + lampLightCol*pow(specLamp,4.)*specFact*.61;\n        \n            \n            //flCol += fl*shad + atmosphere*(1.-fa)*.15*0.;\n            flCol = mix(flCol*aofact,snowColor*aofact,smoothstep(0.2,0.0,dsnow - 0.02));\n            col += flCol ;\n            //col += fres*specFact*atmosphere*1.45;\n        }\n        \n    }\n    \n    // Atmosphere\n    \n    //col=mix(col,atmosphere,smoothstep(0.,1.,(p.z - iTime - 23.)*0.6));\n    \n    col += lampLightCol*144.*glow/float(marchSteps)*smoothstep( 1., 0., t*0.08 - 1.7 + totalVolDens*0.02 );\n    vec3 fogC = atmosphere;\n    fogC = mix(fogC, vec3(0.3,0.3,0.35), clamp(totalVolDens,0.,1.));\n    fogC = mix(fogC, (lampLightCol + fogC)*0.5, clamp(totalVolLightDens,0.,1.));\n    \n    if(hit){\n       atmosphere *= 1.-pow(exp(-(t)*0.05 ),2.);\n    }\n    \n    col = col * exp(-depthView*0.01) + atmosphere; \n    \n    col = mix(col, fogC,totalVolDens);\n    \n    \n    /*\n    // sun \n    \n    vec2 sunUV = mix( uv, uv+2000., sphericalEnv);\n    \n    vec3 sun = vec3(0);\n    vec3 sunDirNormalized = normalize(sunPos - ro);\n    //sunDirNormalized = mix( sunDirNormalized, getRdSpherical(ro, sunUV), sphericalEnv);\n    sunDirNormalized = mix( sunDirNormalized, getRdSpherical(ro, sunDirNormalized.xy), sphericalEnv);\n    \n    \n    if (!hit){\n        sun += .5* smoothstep(1.,0.,length(sunUV - sunDirNormalized.xy) + .44)*vec3(1,0.6,0.4);\n        sun += .5* smoothstep(0.5,0.,length(sunUV - sunDirNormalized.xy) + .24)*vec3(2,0.9,0.4);\n        sun += smoothstep(0.08,0.,length(sunUV - sunDirNormalized.xy) - .03)*vec3(1,0.8,0.9);\n    }\n    float sunCloudBlend = smoothstep( 0. ,1. , 1. - cloudDensTotal*0.8 );\n    col += sun*sunCloudBlend;\n    \n    //sphericalEnv\n    float sunRaysBlend = smoothstep(0.,1.,  \n        mix(\n            (sunDirNormalized.y +  0.24 - smoothstep(0.,0.4,abs(sunDirNormalized.y) - 0.4 ) )*4.,\n            ( 2.4 - length(sunUV - sunDirNormalized.xy) )*19.*0. + 0.,\n            sphericalEnv\n            ))\n            ;\n    col += sunRaysBlend*sunCloudBlend*getSun(uv, sunUV, sunDirNormalized.xy, sunCol*0.2 + vec3(1,0.6,0.4)*0.8);\n    */\n    \n    col *= vec3(0.95,0.98,1.04);\n    \n    col = mix(col,smoothstep(0.,1.,col*1.3),0.7);\n    col = mix(col,smoothstep(0.,1.,col*1.5),0.2);\n    col = mix(acesFilm(col), col, 1.);\n    col *= 1. - dot(uv,uv*0.4)*2.1;\n    \n    col = pow(col,vec3(0.454545));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nfloat fa;\nfloat snowFlakes;\n\nbool mapShadows = false;\n\nbool volumetricMarching = false;\nvec3 glow = vec3(0.);\n\n\n#define iTime (iTime + 8.)\n#define marchSteps 140\n#define marchEps  0.004\n\n#define planetSz 34.\n#define atmoSz 10.\n\n#define volumetricDist 30.\n#define volumetricSteps 200\n#define volumetricDithAmt 0.01\n#define volumetricStepSz ( \\\n    max(volumetricDist/float(volumetricSteps), \\\n    0.4*volumT/volumetricDist - 0.1)*(0.5 + dith) \\\n    )\n\n\n\n#define itersAtmo 5.\n#define itersOptic 5.\nconst float redLightLen = 600.;\nconst float greenLightLen = 530.;\nconst float blueLightLen = 440.;\n\nconst float transStrength = 0.2;\n\nfloat densFalloff = 10.;\n\n\n\n#define lampLightCol vec3(1,0.6,0.5)\n#define lampH 2.\n#define lampW 0.8 \n\n\n\n\n\n#define pi acos(-1.)\n\n#define tau (2.*pi)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p - 0.*a,a) - 0.5*a\n\n#define iMouse (iMouse.y < 10. ? iResolution.xy/2. : iMouse.xy)\n\n#define TT iTime\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra );\n\n\nfloat atmosphericDensity( vec3 p){\n    float fact = (p.y - planetSz )/atmoSz;\n    fact = max(fact, 0.001);\n    return exp(-fact*densFalloff)*pow((1. - fact),0.04);//*pow(smoothstep(0.95,0.84,fact),1.);\n}\n\nfloat opticalDepth(vec3 p, vec3 rd, float len){\n    float stSz = len / (itersOptic-1.);\n    float depth = 0.;\n    for(float opticIdx = 0.; opticIdx < itersOptic; opticIdx++ ){\n        depth += atmosphericDensity(p) * stSz;\n        p += rd*stSz;\n     }\n    return depth;\n}\n\n\nvec3 scatteringCoefficients = transStrength*vec3(\n    pow(400./redLightLen,4.),\n    pow(400./greenLightLen,4.),\n    pow(400./blueLightLen,4.)\n);\nvec3 getAtmosphere(vec3 ro, vec3 rd, float t, bool hit,out float opticalDepthView, vec3 sunPos){\n    vec3 accumAtmo = vec3(0);\n    float atmoMarchLen = 0.;\n    \n    vec3 offs = vec3(0,planetSz ,0);\n    vec3 p = ro;\n    sunPos += offs;\n    \n    p += offs*1.;\n    \n    \n    if(hit){\n        atmoMarchLen = t*0.9;\n    } else {\n        atmoMarchLen = sphIntersect( p, rd, vec3(0), planetSz + atmoSz ).y;\n    }\n    float stepSz = atmoMarchLen/(itersAtmo - 1.);\n    \n\n    for(float atmoIdx = 0.; atmoIdx < itersAtmo ; atmoIdx++ ){\n        vec3 dirToSun = normalize(sunPos - p);\n        float lenSunDirToEndOfAtmosphere = sphIntersect( p, dirToSun, vec3(0), planetSz + atmoSz ).y;\n        float lenViewDirToEndOfAtmosphere = sphIntersect( p, -rd, vec3(0), planetSz + atmoSz ).y;\n        \n        float opticalDepthSun = opticalDepth(p, dirToSun, lenSunDirToEndOfAtmosphere);\n        opticalDepthView = opticalDepth(p, -rd, stepSz*atmoIdx);\n        \n        float localDens = atmosphericDensity(p);\n        \n\n        vec3 transmittance = exp(-(opticalDepthSun + opticalDepthView) * scatteringCoefficients);        \n        accumAtmo += transmittance * localDens * scatteringCoefficients * stepSz;\n        \n        p += rd * stepSz;\n    }\n    \n    return accumAtmo;\n}\n\n\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n    \n    uv *= 0.7;\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir,right));\n    return normalize(dir + right*uv.x + up*uv.y);\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdSolidAngle(vec3 p, vec2 c, float ra)\n{\n  // c is the sin/cos of the angle\n  vec2 q = vec2( length(p.xz), p.y );\n  float l = length(q) - ra;\n  float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n  return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n\n\nfloat hash13(vec3 p3){\n    p3 = fract((p3)*0.1031);\n    p3 += dot(p3, p3.yzx  + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat r21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat valueNoise(vec3 p, float pw){\n    \n\tvec3 s = vec3(1., 25, 75);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    if(pw == 1.){\n        p = p*p*(3. - 2.*p); \n    } else {\n    \tp = p*p*(p*(p * 6. - 15.) + 10.);\n    }\n    \n    //p = smoothstep(0.,1.,p);\n    // Smoother version of the above. Weirdly, the extra calculations can sometimes\n    // create a surface that's easier to hone in on, and can actually speed things up.\n    // Having said that, I'm sticking with the simpler version above.\n\t//p = p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nvec3 getRdSpherical(vec3 ro,vec2 uv){\n    \n    // polar coords\n    uv = vec2(atan(uv.y,uv.x),length(uv));\n    uv += 0.5;\n    uv.y *= tau/2.;\n    \n    // parametrized sphere\n    vec3 offs = vec3(cos(uv.y)*cos(uv.x),sin(uv.y),cos(uv.y)*sin(uv.x));\n    \n    // insert camera rotations here\n    offs.yz *= rot(-(1.)*pi);\n    \n    vec3 lookAt = ro + offs;\n    \n    return normalize(lookAt - ro);\n}\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    //return -b+h;\n    //return max(max(-b-h,0.),max(-b+h,0.));\n    return vec2( -b-h, -b+h );\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}