{
    "Shader": {
        "info": {
            "date": "1548426417",
            "description": "My home work on computer graphics",
            "flags": 0,
            "hasliked": 0,
            "id": "WdX3Dn",
            "likes": 2,
            "name": "Triangle party",
            "published": 3,
            "tags": [
                "triangle",
                "rotate"
            ],
            "usePreview": 0,
            "username": "levgogol",
            "viewed": 435
        },
        "renderpass": [
            {
                "code": "vec2 rot2(vec2 point, float alpha, vec2 center){\n    vec2 temp;\n    temp.x = center.x + (point.x - center.x) * cos(alpha) - (point.y - center.y) * sin(alpha);\n\ttemp.y = center.y + (point.y - center.y) * cos(alpha) + (point.x - center.x) * sin(alpha);\n    return temp;\n}\n\n\nfloat PseudoScalarProduct(vec2 a, vec2 b) {\n    return a.x * b.y - b.x * a.y;\n}\n\nvec3 P(vec3 r){\n    mat3 A = mat3(vec3(sin(iTime), 0., 0.),\n                  vec3(0., cos(iTime), 0.),\n                  vec3(0., 0., .0));\n    vec3 B = A * r;\n\treturn B;\n}\n\nfloat triangle (vec2 A, vec2 B, vec2 C, vec2 uv) {\n    float p1 = PseudoScalarProduct(vec2(B.x - A.x, B.y - A.y), vec2(uv.x - A.x, uv.y - A.y));\n    float p2 = PseudoScalarProduct(vec2(C.x - B.x, C.y - B.y), vec2(uv.x - B.x, uv.y - B.y));\n    float p3 = PseudoScalarProduct(vec2(A.x - C.x, A.y - C.y), vec2(uv.x - C.x, uv.y - C.y));\n    \n    return step(3., abs(sign(p1) + sign(p2) + sign(p3)));\n    //if ((p1 >= 0. && p2 >= 0. && p3 >= 0.) || (p1 <= 0. && p2 <= 0. && p3 <= 0.)) return 1.;\n    //else return 0.;\n}\n\nfloat leftTriangle (vec2 uv) {\n    vec2 A = vec2(-0.2, 0.2);\n\tvec2 B = vec2(-0.8, 0.2);\n    vec2 C = vec2(-0.5, 0.8);\n    \n    vec2 center = vec2((A.x + B.x +C.x)/3., (A.y + B.y + C.y)/3.);\n    \n    float alpha = iTime;\n    \n    A = rot2(A, alpha, center);\n    B = rot2(B, alpha, center);\n    C = rot2(C, alpha, center);\n    \n  \n    return triangle (A, B, C, uv);\n}\n\nfloat rightTriangle (vec2 uv) {\n    vec2 A = vec2(0.2, 0.2);\n\tvec2 B = vec2(0.8, 0.2);\n    vec2 C = vec2(0.5, 0.8);\n    \n    vec2 center = vec2((A.x + B.x +C.x)/3., (A.y + B.y + C.y)/3.);\n    \n    float alpha = sin(iTime) * 3. + iTime * 4.;\n    \n    A = rot2(A, alpha, center);\n    B = rot2(B, alpha, center);\n    C = rot2(C, alpha, center);\n    \n    return triangle (A, B, C, uv);\n}\n\nfloat centralTriangle(vec2 uv) {\n    vec3 A = vec3(-0.2, -0.2, 1);\n\tvec3 B = vec3(0.2, -0.2, 1);\n    vec3 C = vec3(0, 0.2, 1);\n    \n    A = P(A);\n    B = P(B);\n    C = P(C);\n    \n    return triangle (A.xy, B.xy, C.xy, uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2. -1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    //vec3 col = vec3(0.8);\n    vec3 col = vec3(uv.x * uv.y, uv.y * -uv.x, uv.y);\n\n\n    col += (vec3(1., 0., 0.) - col) * leftTriangle (uv);\n    col += (vec3(uv.x, uv.y, uv.x * uv.y) - col) * rightTriangle(uv);\n    col += (cos(iTime+uv.xyy+vec3(0,2,4)) - col) * centralTriangle(uv);\n\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}