{
    "Shader": {
        "info": {
            "date": "1726720765",
            "description": "click mouse and move\noriginals  https://www.shadertoy.com/view/MXfcDS https://www.shadertoy.com/view/MdXSzS",
            "flags": 0,
            "hasliked": 0,
            "id": "l3fyWf",
            "likes": 1,
            "name": "zoom universe",
            "published": 3,
            "tags": [
                "zoom",
                "universe"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 64
        },
        "renderpass": [
            {
                "code": "\n// buffer A is Kaleidoscope \n#define MOUSECONTROLS_ZOOM                   1  \n#define MOUSECONTROLS_ROTATE                 1\n// buffer D is distortion buffer\n#define MOUSECONTROLS_DISTORTION_FREQUENCY   1\n#define MOUSECONTROLS_DISTORTION_SPEED       1\n// buffer B is edge detection\n#define MOUSE_X_CONTROLS_HOW_BLACK_EDGES_ARE    1\n\nfloat waveSpeed     = 0.1;                      \n float waveFrequency = 8.0;                  \n\nvec2 distortPosition( vec2 uv ) {                        \n    float timeOffset = iTime * waveSpeed;\n    vec2 frequencyOffset = waveFrequency * (uv + timeOffset);\n    \n    vec2 distortion = cos( vec2(                        \n       cos(frequencyOffset.x - frequencyOffset.y) * cos(frequencyOffset.y + frequencyOffset.x),                       \n       sin(frequencyOffset.x + frequencyOffset.y) * sin(frequencyOffset.y - frequencyOffset.x) ) );                   \n    return distortion;                                  \n}                                            \n\n// OR THIS overrides MOUSE_X_CONTROLS_HOW_BLACK_EDGES_ARE\n#define DETECTED_EDGES_BLACK   0precision highp float;\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nconst float pi = acos(-1.0);\nconst float pi2 = pi*2.0;\n\nvec2 pmod(vec2 p, float r) {\n    float a = atan(p.x, p.y) + pi/r;\n    float n = pi2 / r;\n    a = floor(a/n)*n;\n    return p*rot(-a);\n}\n\nfloat box( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat ifsBox(vec3 p) {\n    for (int i=0; i<5; i++) {\n        p = abs(p) - 1.0;\n        p.xy *= rot(iTime*0.3);\n        p.xz *= rot(iTime*0.1);\n    }\n    p.xz *= rot(iTime);\n    return box(p, vec3(0.4,0.8,0.3));\n}\n\nfloat map(vec3 p, vec3 cPos) {\n    vec3 p1 = p;\n    p1.x = mod(p1.x-5., 10.) - 5.;\n    p1.y = mod(p1.y-5., 10.) - 5.;\n    p1.z = mod(p1.z, 16.)-8.;\n    p1.xy = pmod(p1.xy, 5.0);\n    return ifsBox(p1);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec3 rgb = clamp( abs(mod(c.x *7.0 + vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\n// simple mouse rotate and zoom for shader\n#define pi 3.14159265359 \n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvec2 mouseRotZoom(vec2 uv) {\n    // allow mouse zoom and rotate    \n    vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(1.0,0.1) : iMouse.xy/iResolution.xy;\n#if MOUSECONTROLS_ROTATE\n    uv.xy *= r2d(-(mouse.x)*pi*2.);\n#endif\n#if MOUSECONTROLS_ZOOM\n    uv *= (1./(10.0*mouse.y));\n#endif\n    return uv;\n}\n\nconst ivec2 FS_ADDR = ivec2(0.0);\n\nconst vec4 fs_stt = vec4(1.0);\n\nuint seed = 0u;\n\nvoid setSeed(uint s) {\n    seed = s;\n}\n\nuint hash(uint s) {\n    s ^= 2747636419u;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    return s;\n}\n\nuint randI() {\n    seed = hash(seed);\n    return seed;\n}\n\nfloat rand() {\n    uint rn = randI();\n    rn %= 1000000000u;\n    float rs = float(rn);\n    rs /= 1000000000.0;\n    return rs;\n}\n#define NUM_LAYERS 6.\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n\n}\n\nfloat Star(vec2 uv, float flare) {\n    float d = length(uv);\n    \n    float m = 0.06/d; // the middle cirle of the star\n    \n    float rays = max(0.,1.-abs(uv.x * uv.y*888.));\n    m += rays * flare;\n    uv *= Rot(3.1415/4.);\n    rays = max(0.,1.-abs(uv.x * uv.y*888.));\n    m += rays * .3 * flare;\n    \n    m *= smoothstep(.8, .1, d);\n    return m;\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34, 456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x * p.y);\n}\n\nvec3 StarLayer(vec2 uv) {\n    vec3 col = vec3(0);\n    \n    vec2 gv = fract(uv)-0.5; // fractional component\n    vec2 id = floor(uv); // integer component\n    \n    for(int y=-1; y<=1; y++) {\n        for(int x=-1; x<=1; x++) {\n            vec2 offs = vec2(x,y); //add contribution of all negighboring stars\n            \n            float n = Hash21(id+offs); //random btw 0 and 1 for each grid \n            float size = fract(n*456.78)*1.2;\n            float flare = smoothstep(.3, .9, size);//for ray only\n            flare *= abs(sin(iTime*2.)); \n            float star = Star(gv-offs-vec2(n,fract(n*68.))+.5, flare);\n            vec3 tint1 = vec3(0.6+size*0.35,.9,.9);\n            vec3 tint2 = vec3(0.7+size*0.25,.75,.75);\n            vec3 color = mix(tint1, tint2,abs(cos(iTime))+n);\n            color *= fract(n*1234.5);\n            \n            star *= sin(iTime*3.+n*6.2821)*.5+.5;\n            col += star*size*color;\n        }\n    }\n    return col;\n}\n\n//#define setNSeed() setSeed(uint(iResolution.x*fragCoord.y+fragCoord.x ))\n#define setNSeed() setSeed(uint(1000.+float(iFrame)/1.-75.*length(fragCoord) ))\n\n//+iResolution.x*fragCoord.y+fragCoord.x \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - .5;\n\tfloat t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .27)) * 2.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n    uv*=ma;\n uv = mouseRotZoom(uv);\n  vec3 col2=vec3(0.);\nvec2 uv2 =fragCoord;\n\n    vec2 fragCoord2=uv2;\n\n    float n=3.;\n    uv2.x = n*(uv2.x-0.5*iResolution.x)/iResolution.y;\n    uv2.y = n*(uv2.y-0.5*iResolution.y)/iResolution.y;\n    fragCoord=uv2;\n   fragCoord = mouseRotZoom(  fragCoord);\n    setNSeed();\n    \n    float k=pow(10.,(1.5-0.5*cos(float(iFrame)/4800.)));\n\n    float t2=float(iFrame)/(1.*180.);\n    float h=4.;\n  ;\n    for(float i=1.;i<=k;i+=1.){\n        float r1=rand();\n        float r2=rand();\n\n        float r3=rand();\n        float r4=rand();\n        vec2 p=vec2(floor(h*(0.25*cos(5.*t2)+pow(r2,0.5)*cos(2.*3.1415*r1)))/h,floor(h*(0.25*sin(5.*t)+pow(r2,0.5)*sin(2.*3.1415*r1)))/h);\n        col2 += (0.5 + 0.5*cos(iTime/1.+p.xyx+vec3(0,2,4)))*0.2/k*vec3(pow(length(uv-(p+vec2(r3/h,r4/h))),-2.)); \n     \n        \n    \n}\n    \n  vec2 uv3 = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 M = (iMouse.xy - iResolution.xy*.5)/iResolution.y;\n    \n    //uv *= .5;\n    // uv.x -= 0.2 * iTime;\n    float t3 = iTime*.05;\n    \n    // uv += M;\n    uv3 *= Rot(t3);\n    vec3 col3 = vec3(0);\n    \n    for(float i=0.; i<1.; i+=1./NUM_LAYERS) {\n        float depth = fract(i+t);\n        float scale = mix(20.,.5,depth);\n        float fade = depth*smoothstep(1.,.9,depth);\n        col3 += StarLayer(uv*scale+i*456.45-M)*fade;\n        \n    }\n    \n\tfloat v1, v2, v3;\n\tv1 = v2 = v3 = 0.0;\n\t\n\tfloat s = 0.0;\n\tfor (int i = 0; i < 90; i++)\n\t{\n\t\tvec3 p = s * vec3(uv, 0.0);\n\t\t\n\t\tp += vec3(.22, .3, s - 1.5 - sin(iTime * .13) * .1)*col2;\n\t\tfor (int i = 0; i < 8; i++)\tp = abs(p) / dot(p,p) - 0.659;\n\t\tv1 += dot(p,p) * .0015 * (1.8 + sin(length(uv.xy * 13.0) + .5  - iTime * .2));\n\t\tv2 += dot(p,p) * .0013 * (1.5 + sin(length(uv.xy * 14.5) + 1.2 - iTime * .3));\n\t\tv3 += length(p.xy*10.) * .0003;\n\t\ts  += .035;\n\t}\n\t\n\tfloat len = length(uv);\n\tv1 *= smoothstep(.1, .0, len);\n\tv2 *= smoothstep(1.0, .0, len);\n\tv3 *= smoothstep(.5, .0, len);\n\t\n\tvec3 col = vec3( v3 * (1.5 + sin(iTime * .2) * .4),\n\t\t\t\t\t(v1 + v3) * .3,\n\t\t\t\t\t v2) + smoothstep(0.2, .0, len) * .85 + smoothstep(.0, .6, v3) * .3;\n\n\tfragColor=vec4(min(pow(abs(col)+col3, vec3(1.2))+col3, 1.0), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}