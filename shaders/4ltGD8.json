{
    "Shader": {
        "info": {
            "date": "1708400582",
            "description": "Bomberman\nInitially wrote this about ~8 years ago but never finished it. Spent some time recently cleaning it up and figured I'd make it public despite some remaining issues. \nControls:\nPlayer0: Arrows+Space\nPlayer1: WASD+Q\nPlayer2: IJKL+U\nPlayer3: GVBN+F",
            "flags": 112,
            "hasliked": 0,
            "id": "4ltGD8",
            "likes": 6,
            "name": "Bomberman",
            "published": 3,
            "tags": [
                "game",
                "sdf",
                "sprite",
                "multipass",
                "bomberman"
            ],
            "usePreview": 1,
            "username": "AxleMike",
            "viewed": 178
        },
        "renderpass": [
            {
                "code": "// Post\n// See Buffer C for additional visual settings\n\n// References:\n// [SH16C] Contra by knarkowicz    - https://www.shadertoy.com/view/XltGDr\n// CRT Effect by Jasper \t\t   - https://www.shadertoy.com/view/4sf3Dr\n// FixingPixelArt by TimothyLottes - https://www.shadertoy.com/view/XsjSzR\n\n//////////////////////////////////////////////////\n// Post Settings\n#define POST_EFFECTS  \t1\n#define CRT_CURVATURE \t1\n#define SCANLINES\t\t1\n\n//////////////////////////////////////////////////\n// Debugging Settings\n#define DISPLAY_SPRITE_SHEET 0\n\n//////////////////////////////////////////////////\n// Helpers\nvec2 CRTCurvature(in vec2 uv, in float strength)\n{\n    uv = uv * 2.0 - 1.0;\n    vec2 offset = (strength * abs(uv.yx)) * vec2(0.3334, 0.5);\n    uv = uv + uv * offset * offset;\n    return Saturate(uv * 0.5 + 0.5);\n}\n\nfloat Scanline(in float position)\n{\n    return sin((position * iResolution.y * 2.0)) * 0.1;\n}\n\n//////////////////////////////////////////////////\n// Implementation \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n#if POST_EFFECTS    \n\n#if CRT_CURVATURE    \n    vec2 gameUV = CRTCurvature(uv, 0.425);\n#else\n    vec2 gameUV = uv;\n#endif       \n    vec4 gameColor = texture(iChannel0, gameUV);\n   \n    float vignette = (gameUV.x * gameUV.y * (1.0 - gameUV.x) * (1.0 - gameUV.y));\n    vignette = Saturate(pow(16.0 * vignette, 0.3));\n\n    const float k_brightness = 1.5;  \n    vec3 finalColor = (gameColor.rgb * vignette * k_brightness);\n#if SCANLINES\n    finalColor = finalColor - Scanline(gameUV.y);\n#endif // SCANLINES\n\n#else    \n    vec4 gameColor = texture(iChannel0, uv);\n#endif // POST_EFFECTS    \n        \n#if DISPLAY_SPRITE_SHEET    \n    const int k_spriteIndex = 0;\n    vec4 spriteSheetColor = texture(iChannel1, (uv * 16.0 + vec2(float(k_spriteIndex) * 16.0, 0.0)) / iChannelResolution[1].xy);\n    finalColor = spriteSheetColor.rgb;\n#endif\n\n    fragColor = vec4(finalColor, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "musicstream",
                        "id": 36121,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/junechikuma/june-chikuma-nes-bomberman"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Game state and gameplay\n\n//////////////////////////////////////////////////\n// Constants\nconst float BOMB_FUSE_TIME = 3.0; // 3 seconds\nconst float BOMB_EXPLOSION_TIME = 1.0;\nconst uint MAX_BOMB_LEVEL = 4U;\nconst uint MAX_FLAME_LEVEL = 19U;\nconst uint MAX_SKATE_LEVEL = 7U;\n\n// Facing Direction\nconst float DIRECTION_UP \t= 0.0;\nconst float DIRECTION_DOWN \t= 1.0;\nconst float DIRECTION_RIGHT = 2.0;\nconst float DIRECTION_LEFT \t= 3.0;\n\nvec4 LoadValueBufferA(in vec2 re)\n{\n    return texture(iChannel0, (0.5 + re) / iChannelResolution[0].xy, -100.0);\n}\n\n// Same as LoadValueBufferA but with bound checking\nvec4 LoadTileValueBufferA(in vec2 re)\n{\n    if ((re.x >= txPlayField.x) && (re.y >= txPlayField.y) && (re.x <= txPlayField.z) && (re.y <= txPlayField.w - 1.0))\n    {\n    \treturn LoadValueBufferA(re);\n    }\n    return vec4(0.0);\n}\n\nvec4 LoadValueBufferB(in vec2 re)\n{\n    return texture(iChannel1, (0.5 + re) / iChannelResolution[1].xy, -100.0);\n}\n\n////////////////////////////////////////////////////////\n// Random\nfloat GetRandomValue(in float seed, in int startValue, in int range)\n{\n    vec3 value = texture(iChannel3, seed * (iTime + 1.0) * vec2(12.9898, 78.233 + iTime)).rgb;\n    return floor(mod((value.x + value.y * 7.13 + value.z * 131.0), float(range)) + float(startValue));    \n}\n\nfloat GetRandomStartingBlock(in vec2 tileIndex)\n{\n\treturn clamp(GetRandomValue(tileIndex.x + tileIndex.y * float(CELLS_WIDE), -5, 6), float(BREAKABLE_BLOCK), float(FREE_SPACE));   \n}\n\nfloat GetRandomPowerup(in vec2 tileIndex)\n{\n\treturn clamp(GetRandomValue(tileIndex.x + tileIndex.y * float(CELLS_WIDE), FREE_SPACE, FLAME_POWER_UP + 2), float(FREE_SPACE), float(FLAME_POWER_UP));   \n}\n\n////////////////////////////////////////////////////////\n// Tiles\nvec4 GetTileInfo(in vec2 tileIndex)\n{\n\treturn LoadValueBufferA(txPlayField.xy + tileIndex);\n}\n\nbool IsFreeTile(in int tileType)\n{\n    return ((tileType >= FREE_SPACE) && (tileType < BOMB));\n}\n\nvec4 ResetTile(vec2 tileIndex)\n{\n    float tileType = float(UNBREAKABLE_BLOCK); // Initially set all blocks as unbreakble\n\n    // Set random free blocks, breakable ect\n    if (((mod(tileIndex.x, 2.0) != 0.0) && (mod(tileIndex.y, 2.0) != 0.0)) == false)\n    {\n        tileType = GetRandomStartingBlock(tileIndex);\n    }\n\n    // Clear out space near the corners\n    if (length((tileIndex - vec2(7.0, 6.0))) > 8.25)\n    {\n        tileType = float(FREE_SPACE);\n    }\n    return vec4(tileType, 0.0, 0.0, 0.0f);\n}\n\n////////////////////////////////////////////////////////\n// Bomberman\nstruct BombSlots\n{\n    vec2    mBombTile0;\n    vec2    mBombTile1;\n    vec2    mBombTile2;\n    vec2    mBombTile3;\n};\n\nstruct Bomberman\n{\n\tvec2 \t\tmPosition;\n    float   \tmDirection;\n    float \t\tmAnimation;\n    \n    BombSlots \tmBombSlots;\n    \n    // Could pack these together\n    uint \t\tmBombLevel;  \n    uint \t\tmFlameLevel;\n    uint \t\tmSkateLevel;   \t\n    \n    uint \t\tmCurrentBombFreeSlot;\n    uint\t   \tmCurrentBombCount;\n};\n    \nBomberman gBomberman0;\nBomberman gBomberman1;\nBomberman gBomberman2;\nBomberman gBomberman3;\n     \n#define ResetBombSlots BombSlots(vec2(-1.0), vec2(-1.0), vec2(-1.0), vec2(-1.0))\n#define CreateDefaultBomberman(position, direction) Bomberman(position, direction, 0., ResetBombSlots, 1U, 2U, 1U, 0U, 0U)    \n\nvec2 ConvertPackedFloatToVec2(in float x)\n{\n    return vec2(mod(x, 100.0), floor(x * 0.01));\n}\n\nfloat ConvertVec2ToPackedFloat(in vec2 v)\n{\n    return (v.x + v.y * 100.0);\n}\n\nBomberman LoadBomberman(in vec2 re)\n{\n    vec4 bombermanInfo0 = LoadValueBufferA(re);\n    vec4 bombermanInfo1 = LoadValueBufferA(re + vec2(1.0, 0.0));\n    vec4 bombermanInfo2 = LoadValueBufferA(re + vec2(2.0, 0.0));\n    \n    vec2 bomb0Location = ConvertPackedFloatToVec2(bombermanInfo1.w); \n    vec2 bomb1Location = ConvertPackedFloatToVec2(bombermanInfo2.x); \n    vec2 bomb2Location = ConvertPackedFloatToVec2(bombermanInfo2.y); \n    vec2 bomb3Location = ConvertPackedFloatToVec2(bombermanInfo2.z); \n    \n    uint currentBombCount = 4U;\n    uint currentBombFreeSlot = 0U;\n    \n    bool bombTile0 = (bomb0Location.x != -1.0) && (int(LoadValueBufferA(txPlayField.xy + bomb0Location).x) == BOMB);\n    bool bombTile1 = (bomb1Location.x != -1.0) && (int(LoadValueBufferA(txPlayField.xy + bomb1Location).x) == BOMB);\n    bool bombTile2 = (bomb2Location.x != -1.0) && (int(LoadValueBufferA(txPlayField.xy + bomb2Location).x) == BOMB);\n    bool bombTile3 = (bomb3Location.x != -1.0) && (int(LoadValueBufferA(txPlayField.xy + bomb3Location).x) == BOMB);\n\n    if (bombTile3 == false)\n    {\n        currentBombFreeSlot = 3U;\n        bomb3Location = vec2(-1.0);\n        currentBombCount -= 1U;\n    }\n    \n    if (bombTile2 == false)\n    {\n        currentBombFreeSlot = 2U;\n        bomb2Location = vec2(-1.0);\n        currentBombCount -= 1U;\n    }\n\n    if (bombTile1 == false)\n    {\n        currentBombFreeSlot = 1U;\n        bomb1Location = vec2(-1.0);\n        currentBombCount -= 1U;\n    }\n\n    if (bombTile0 == false)\n    {\n        currentBombFreeSlot = 0U;\n        bomb0Location = vec2(-1.0);\n        currentBombCount -= 1U;\n    }\n    \n    return Bomberman(bombermanInfo0.xy, // position \n                     bombermanInfo0.z, // direction \n                     bombermanInfo0.w, // animation\n                     // bomb locations\n       \t\t\t     BombSlots(bomb0Location, bomb1Location, bomb2Location, bomb3Location),\n                     uint(bombermanInfo1.x), // bomb level\n                     uint(bombermanInfo1.y), // flame level \n                     uint(bombermanInfo1.z), // skate level\n                     // extra bomb info\n                     currentBombFreeSlot, currentBombCount);\n}\n\nvoid StoreBomberman(in vec2 re, in Bomberman b, inout vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 bombermanInfo0 = vec4(b.mPosition, b.mDirection, b.mAnimation);  \n    vec4 bombermanInfo1 = vec4(b.mBombLevel, b.mFlameLevel, b.mSkateLevel, ConvertVec2ToPackedFloat(b.mBombSlots.mBombTile0));\n    vec4 bombermanInfo2 = vec4(ConvertVec2ToPackedFloat(b.mBombSlots.mBombTile1), ConvertVec2ToPackedFloat(b.mBombSlots.mBombTile2),\n                               ConvertVec2ToPackedFloat(b.mBombSlots.mBombTile3), 0.0);\n\n    StoreValue(re, bombermanInfo0, fragColor, fragCoord);\n    StoreValue(re + vec2(1.0, 0.0), bombermanInfo1, fragColor, fragCoord);\n    StoreValue(re + vec2(2.0, 0.0), bombermanInfo2, fragColor, fragCoord);\n}\n\n////////////////////////////////////////////////////////\n// Inputs\nstruct BombermanInput\n{\n    float mHorizontalMovement;\n\tfloat mVerticalMovement;\n    bool  mPlaceBomb;\n    float mLastBombTime;\n};\n\nBombermanInput gBomberman0Inputs;\nBombermanInput gBomberman1Inputs;\nBombermanInput gBomberman2Inputs;\nBombermanInput gBomberman3Inputs;\n\n////////////////////////////////////////////////////////\n// Gameplay\nbool CheckIfValidMove(in vec2 position, in vec2 movementDirection)\n{\n    vec2 normalizedMovementDirection = normalize(movementDirection);\n    vec4 currentTile = GetTileInfo(position);\n    vec2 targetPosition = position + movementDirection;\n    \n    vec2 targetTile = (position + normalizedMovementDirection);\n    \n    if ((targetPosition.x >= -0.25) && (targetPosition.x < float(CELLS_WIDE) - 0.5) \n\t\t&& (targetPosition.y >= -0.25) && (targetPosition.y < float(CELLS_TALL) - 0.5)) \n    {\n    \treturn (IsFreeTile(int(GetTileInfo(targetTile).x)) || IsFreeTile(int(GetTileInfo(targetPosition).x)));\n    }\n    return false;    \n}\n\nvoid HandleMovementInput(inout vec2 position, out float direction, inout float animation, in uint skateLevel, in BombermanInput inputs)\n{\n    const float k_defaultBombermanSpeed = 2.4;\n    const float k_speedIncreaseRate = 0.5;\n    \n    float bombermanSpeed = (k_defaultBombermanSpeed + (float(skateLevel) * k_speedIncreaseRate)) * iTimeDelta;\n\n    float xMovement = bombermanSpeed * inputs.mHorizontalMovement;\n    if ((xMovement != 0.0) && CheckIfValidMove(position, vec2(xMovement, 0.0)))\n    {\n        position.x += xMovement;\n        direction = (xMovement > 0.0) ? DIRECTION_RIGHT : DIRECTION_LEFT;\n    } \n\n    float yMovement = bombermanSpeed * inputs.mVerticalMovement;\n    if ((yMovement != 0.0) && CheckIfValidMove(position, vec2(0.0, yMovement)))\n    {\n    \tposition.y += yMovement;\n        direction = (yMovement > 0.0) ? DIRECTION_UP : DIRECTION_DOWN;\n    }\n    \n    const float k_walkAnimationLength = 40.0;\n    animation = ((xMovement + yMovement) != 0.0) ? (mod(animation + 1.0, k_walkAnimationLength)) : (animation += -sign(animation));\n}\n\nvoid UpdateBombSlot(inout BombSlots bombSlots, in vec2 tileIndex, in uint freeSlot)\n{\n    if (freeSlot == 0U)\n    {\n        bombSlots.mBombTile0 = tileIndex;\n    }\n    else if (freeSlot == 1U)\n    {\n        bombSlots.mBombTile1 = tileIndex;\n    }\n    else if (freeSlot == 2U)\n    {\n        bombSlots.mBombTile2 = tileIndex;\n    }\n    else if (freeSlot == 3U)\n    {\n        bombSlots.mBombTile3 = tileIndex;\n    }\n}\n\nvoid UpdateBombermanTile(inout vec4 tileInfo, in uint flameLevel, in bool placeBomb, in bool canPlaceBomb)\n{\n    int tileType = int(tileInfo.x);\n    if (canPlaceBomb && (tileType == FREE_SPACE) && placeBomb)\n    {\n        tileInfo.x = float(BOMB);\n        tileInfo.y = BOMB_FUSE_TIME;\n        tileInfo.z = float(EXPLOSION_DIRECTION_ALL);\n        \n        float floatFlameLevel = float(flameLevel);\n        tileInfo.w = floatFlameLevel;\n    }\n    else if ((tileType == BOMB_POWER_UP) || (tileType == FLAME_POWER_UP) || (tileType == SKATE_POWER_UP))\n    {\n        tileInfo.x = float(FREE_SPACE);\n        tileInfo.z = 0.0;\n    }   \n}\n\nvoid UpdateBomberman(inout Bomberman bomberman, inout vec4 tileInfo, in BombermanInput inputs)\n{         \n    vec2 bombermanTileIndex = GetTileIndex(ConvertTileCoordsToScreenUV(bomberman.mPosition.xy));\n    vec4 bombermanTileInfo = LoadValueBufferA(txPlayField.xy + bombermanTileIndex);\n\tint tileType = int(bombermanTileInfo.x);   \n    \n    bomberman.mBombLevel = min(bomberman.mBombLevel + ((tileType == BOMB_POWER_UP) ? 1U : 0U), MAX_BOMB_LEVEL);\n    bomberman.mFlameLevel = min(bomberman.mFlameLevel + ((tileType == FLAME_POWER_UP) ? 1U : 0U), MAX_FLAME_LEVEL);\n    bomberman.mSkateLevel = min(bomberman.mSkateLevel + ((tileType == SKATE_POWER_UP) ? 1U : 0U), MAX_SKATE_LEVEL);\n    bomberman.mPosition = (tileType == EXPLOSION) ? vec2(-100.0) : bomberman.mPosition;\n    \n    if ((tileType == FREE_SPACE) && (bomberman.mCurrentBombCount < bomberman.mBombLevel) && inputs.mPlaceBomb)\n    {\n        UpdateBombSlot(bomberman.mBombSlots, bombermanTileIndex, bomberman.mCurrentBombFreeSlot);\n    }   \n    HandleMovementInput(bomberman.mPosition, bomberman.mDirection, bomberman.mAnimation, bomberman.mSkateLevel, inputs);\n}\n\nBombermanInput LoadInputs(in vec2 re)\n{\n    vec4 inputs = LoadValueBufferB(re).xyzw;    \n    return BombermanInput(inputs.x, inputs.y, (inputs.z > 0.0), inputs.w);\n}\n\n//////////////////////////////////////////////////\n// Implementation \nvoid UpdateTile(inout vec4 tileInfo, in vec4 comparisionTile, in uint explosionDirection, in bool isBomb, in bool isBreakableBlock)\n{\n    if ((int(comparisionTile.x) == EXPLOSION) \n        && (comparisionTile.w > 0.0)\n        && ((uint(comparisionTile.z) == EXPLOSION_DIRECTION_ALL) \n        || (uint(comparisionTile.z) == explosionDirection)))\n    {\n        tileInfo.w = isBomb ? tileInfo.w : (isBreakableBlock ? 0.0 : comparisionTile.w - 1.0);\n        tileInfo.x = isBreakableBlock ? float(COLLAPSING_BLOCK) : float(EXPLOSION);\n        tileInfo.y = isBomb ? BOMB_EXPLOSION_TIME : ((int(tileInfo.x) == EXPLOSION) ? max(tileInfo.y, comparisionTile.y) : (comparisionTile.y - iTimeDelta));              \n        tileInfo.z = isBomb ? float(EXPLOSION_DIRECTION_ALL) : float(explosionDirection);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Don't compute gameplay outside of the data area\n    if ((fragCoord.x > float(CELLS_WIDE)) || (fragCoord.y > float(CELLS_TALL + 1U))) discard;\n    \n    vec4 gameInfo = LoadValueBufferA(txGameInfo);\n    float timeInMode = iTime - gameInfo.z;\n    \n    float previousGameMode = gameInfo.x;\n    \n    gBomberman0 = LoadBomberman(txBomberman0Info);\n    gBomberman1 = LoadBomberman(txBomberman1Info);\n    gBomberman2 = LoadBomberman(txBomberman2Info);\n    gBomberman3 = LoadBomberman(txBomberman3Info);\n     \n    vec4 tileInfo = LoadValueBufferA(fragCoord.xy - 0.5);\n    vec2 tileIndex = floor(vec2(fragCoord.x, fragCoord.y - 1.0));\n           \n    if (gameInfo.x == MODE_MATCH_RESET)\n    { \n        tileInfo = ResetTile(tileIndex);\n        \n        gBomberman0 = CreateDefaultBomberman(vec2(0.0), DIRECTION_UP);\n        gBomberman1 = CreateDefaultBomberman(vec2(float(CELLS_WIDE - 1U), float(CELLS_TALL - 1U)), DIRECTION_DOWN);\n        gBomberman2 = CreateDefaultBomberman(vec2(0.0, float(CELLS_TALL - 1U)), DIRECTION_DOWN);\n        gBomberman3 = CreateDefaultBomberman(vec2(float(CELLS_WIDE - 1U), 0.0), DIRECTION_UP);\n                \n        gameInfo.x = MODE_GAMEPLAY;\n    }\n    else if (gameInfo.x == MODE_GAMEPLAY)\n    {              \n        uint aliveCount = 0U;\n                \n        if (IsBombermanAlive(gBomberman0.mPosition.x))\n        {\n            aliveCount += 1U;           \n            bool isBombermanTile = (floor(gBomberman0.mPosition + vec2(0.5)) == tileIndex);\n            \n            gBomberman0Inputs = LoadInputs(txBomberman0Command);\n            if (isBombermanTile)\n            {\n                UpdateBombermanTile(tileInfo, gBomberman0.mFlameLevel, gBomberman0Inputs.mPlaceBomb, (gBomberman0.mCurrentBombCount < gBomberman0.mBombLevel));\n            }\n            UpdateBomberman(gBomberman0, tileInfo, gBomberman0Inputs);\n        }\n         \n        if (IsBombermanAlive(gBomberman1.mPosition.x))\n        {\n            aliveCount += 1U;   \n            bool isBombermanTile = (floor(gBomberman1.mPosition + vec2(0.5)) == tileIndex);\n            \n            gBomberman1Inputs = LoadInputs(txBomberman1Command);\n            if (isBombermanTile)\n            {\n                UpdateBombermanTile(tileInfo, gBomberman1.mFlameLevel, gBomberman1Inputs.mPlaceBomb, (gBomberman1.mCurrentBombCount < gBomberman1.mBombLevel));\n            }\n            UpdateBomberman(gBomberman1, tileInfo, gBomberman1Inputs);\n        }\n        \n        if (IsBombermanAlive(gBomberman2.mPosition.x))\n        {\n            aliveCount += 1U;   \n            bool isBombermanTile = (floor(gBomberman2.mPosition + vec2(0.5)) == tileIndex);\n            \n            gBomberman2Inputs = LoadInputs(txBomberman2Command);\n            if (isBombermanTile)\n            {\n                UpdateBombermanTile(tileInfo, gBomberman2.mFlameLevel, gBomberman2Inputs.mPlaceBomb, (gBomberman2.mCurrentBombCount < gBomberman2.mBombLevel));\n            }\n            UpdateBomberman(gBomberman2, tileInfo, gBomberman2Inputs);\n        }\n        \n        if (IsBombermanAlive(gBomberman3.mPosition.x))\n        {\n            aliveCount += 1U;    \n            bool isBombermanTile = (floor(gBomberman3.mPosition + vec2(0.5)) == tileIndex);\n            \n            gBomberman3Inputs = LoadInputs(txBomberman3Command);\n            if (isBombermanTile)\n            {\n                UpdateBombermanTile(tileInfo, gBomberman3.mFlameLevel, gBomberman3Inputs.mPlaceBomb, (gBomberman3.mCurrentBombCount < gBomberman3.mBombLevel));\n            }\n            UpdateBomberman(gBomberman3, tileInfo, gBomberman3Inputs);\n        }\n        \n        // End the match if only one player remains\n        gameInfo.x = (aliveCount <= 1U) ? MODE_MATCH_OVER : gameInfo.x;\n        \n        int currentTileType = int(tileInfo.x);\n        \n        if (currentTileType != UNBREAKABLE_BLOCK)\n        {\n            // Update Tiles\n            vec4 leftTileInfo  = LoadTileValueBufferA(fragCoord.xy - 0.5 + vec2(-1.0, 0.0));\n            vec4 rightTileInfo = LoadTileValueBufferA(fragCoord.xy - 0.5 + vec2(1.0, 0.0));\n            vec4 upTileInfo    = LoadTileValueBufferA(fragCoord.xy - 0.5 + vec2(0.0, -1.0));\n            vec4 downTileInfo  = LoadTileValueBufferA(fragCoord.xy - 0.5 + vec2(0.0, 1.0));     \n            \n            bool isBreakableBlock = (currentTileType == BREAKABLE_BLOCK);\n            bool isExplosion = (currentTileType == EXPLOSION) || (currentTileType == COLLAPSING_BLOCK);\n            bool isCollapsingBlock = (currentTileType == COLLAPSING_BLOCK);\n            bool isBomb = (currentTileType == BOMB);\n\n            float previousExplosionType = 0.0;\n            if (isExplosion || isCollapsingBlock)\n        \t{\n                if (tileInfo.y <= 0.0)\n                {\n                \ttileInfo.x = (currentTileType == COLLAPSING_BLOCK) ? GetRandomPowerup(tileIndex) : float(FREE_SPACE);\n                    tileInfo.z = 0.0;\n                }\n                previousExplosionType = tileInfo.z;\n                tileInfo.w = 0.0;\n        \t}\n            \n\t\t\tif (isCollapsingBlock == false)\n            {\n                UpdateTile(tileInfo, leftTileInfo, EXPLOSION_DIRECTION_RIGHT, isBomb, isBreakableBlock);\n                UpdateTile(tileInfo, rightTileInfo, EXPLOSION_DIRECTION_LEFT, isBomb, isBreakableBlock);\n                UpdateTile(tileInfo, upTileInfo, EXPLOSION_DIRECTION_DOWN, isBomb, isBreakableBlock);\n                UpdateTile(tileInfo, downTileInfo, EXPLOSION_DIRECTION_UP, isBomb, isBreakableBlock);\n            }\n\n            // Update bomb, flame and collapsing block timers\n            if ((isExplosion || isCollapsingBlock || isBomb) && (tileInfo.y > 0.0))\n            {\n                tileInfo.y -= iTimeDelta;\n                if (isBomb && (tileInfo.y <= 0.0))\n                {\n                    tileInfo.x = float(EXPLOSION);\n                    tileInfo.y = BOMB_EXPLOSION_TIME;\n                }\n            }\n        }    \n    }\n    else if (gameInfo.x == MODE_MATCH_OVER)\n    {\n        gameInfo.x = (timeInMode > 3.0) ? MODE_AWARD : gameInfo.x;\n    }\n    else if (gameInfo.x == MODE_AWARD)\n    {\n        gameInfo.x = (timeInMode > 10.0) ? MODE_MATCH_RESET : gameInfo.x;\n    }\n    gameInfo.z = (previousGameMode != gameInfo.x) ? iTime : gameInfo.z;\n    \n    // Store game state\n    fragColor = vec4(0.0);\n \n    StoreValue(txGameInfo, gameInfo, fragColor, fragCoord);\n    StoreValue(txPlayField, tileInfo, fragColor, fragCoord);\n     \n    StoreBomberman(txBomberman0Info, gBomberman0, fragColor, fragCoord);\n    StoreBomberman(txBomberman1Info, gBomberman1, fragColor, fragCoord);\n    StoreBomberman(txBomberman2Info, gBomberman2, fragColor, fragCoord);\n    StoreBomberman(txBomberman3Info, gBomberman3, fragColor, fragCoord);\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Keyboard Input\nvec4 LoadValueBufferB(in vec2 re)\n{\n    return texture(iChannel0, (0.5 + re) / iChannelResolution[0].xy, -100.0);\n}\n\nvec4 LoadValueBufferA(in vec2 re)\n{\n    return texture(iChannel1, (0.5 + re) / iChannelResolution[1].xy, -100.0);\n}\n\n////////////////////////////////////////////////////////\n// Controls\nstruct ControlSet\n{\n    float mLeftKey;\n\tfloat mUpKey;\n    float mRightKey;\n    float mDownKey;\n    float mBombKey;\n};\n\n#define CalculateKeyCode(x) ((float(x) + 0.5) / 256.0)\n\n// Player 0\nconst float KEY_LEFT  = CalculateKeyCode(37);\nconst float KEY_UP    = CalculateKeyCode(38);\nconst float KEY_RIGHT = CalculateKeyCode(39);\nconst float KEY_DOWN  = CalculateKeyCode(40);\nconst float KEY_SPACE = CalculateKeyCode(32);\nControlSet gControlSet0 = ControlSet(KEY_LEFT, KEY_UP, KEY_RIGHT, KEY_DOWN, KEY_SPACE);\n\n// Player 1\nconst float KEY_A     = CalculateKeyCode(65);\nconst float KEY_W     = CalculateKeyCode(87);\nconst float KEY_D     = CalculateKeyCode(68);\nconst float KEY_S     = CalculateKeyCode(83);\nconst float KEY_Q     = CalculateKeyCode(81);\nControlSet gControlSet1 = ControlSet(KEY_A, KEY_W, KEY_D, KEY_S, KEY_Q);\n\n// Player 2\nconst float KEY_J     = CalculateKeyCode(74);\nconst float KEY_I     = CalculateKeyCode(73);\nconst float KEY_K     = CalculateKeyCode(76);\nconst float KEY_L     = CalculateKeyCode(75);\nconst float KEY_U     = CalculateKeyCode(85);\nControlSet gControlSet2 = ControlSet(KEY_J, KEY_I, KEY_K, KEY_L, KEY_U);\n\n// Player 3\nconst float KEY_V     = CalculateKeyCode(86);\nconst float KEY_G     = CalculateKeyCode(71);\nconst float KEY_N     = CalculateKeyCode(78);\nconst float KEY_B     = CalculateKeyCode(66);\nconst float KEY_F     = CalculateKeyCode(70);\nControlSet gControlSet3 = ControlSet(KEY_V, KEY_G, KEY_N, KEY_B, KEY_F);\n    \nbool CheckKey(in float key)\n{\n\treturn texture(iChannel2, vec2(key, 0.25)).x > 0.5;   \n}\n\nvec4 CheckKeyboardInput(in ControlSet controlSet, in float lastBombTime)\n{\n    vec4 results = vec4(0.0, 0.0, 0.0, (abs(iTime - lastBombTime) > 0.25) ? 0.0 : lastBombTime);\n    \n    results.x -= CheckKey(controlSet.mLeftKey) ? 1.0 : 0.0;\n    results.x += CheckKey(controlSet.mRightKey) ? 1.0 : 0.0;\n    results.y -= CheckKey(controlSet.mDownKey) ? 1.0 : 0.0;\n    results.y += CheckKey(controlSet.mUpKey) ? 1.0 : 0.0;\n       \n    // Last bomb time is used to determine the bomb key was released before another bomb can be placed\n    if (CheckKey(controlSet.mBombKey)) \n    { \n        if (lastBombTime == 0.0)\n        {\n            results.z += 1.0; \n            results.w = iTime;\n        }\n    }\n    return results;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    fragColor = vec4(0.0);\n    \n    float playerToUpdate = mod(float(iFrame), 4.0);\n    \n    vec4 gameInfo = LoadValueBufferA(txGameInfo);\n    \n    float bomberman0TimeSinceBomb = LoadValueBufferB(txBomberman0Command).w;\n    float bomberman1TimeSinceBomb = LoadValueBufferB(txBomberman1Command).w;\n    float bomberman2TimeSinceBomb = LoadValueBufferB(txBomberman2Command).w;\n    float bomberman3TimeSinceBomb = LoadValueBufferB(txBomberman3Command).w;       \n\n    vec4 bomberman0Inputs = CheckKeyboardInput(gControlSet0, bomberman0TimeSinceBomb);\n    vec4 bomberman1Inputs = CheckKeyboardInput(gControlSet1, bomberman1TimeSinceBomb);\n    vec4 bomberman2Inputs = CheckKeyboardInput(gControlSet2, bomberman2TimeSinceBomb);\n    vec4 bomberman3Inputs = CheckKeyboardInput(gControlSet3, bomberman3TimeSinceBomb);\n\n    StoreValue(txBomberman0Command, bomberman0Inputs, fragColor, fragCoord);\n    StoreValue(txBomberman1Command, bomberman1Inputs, fragColor, fragCoord);\n    StoreValue(txBomberman2Command, bomberman2Inputs, fragColor, fragCoord);\n    StoreValue(txBomberman3Command, bomberman3Inputs, fragColor, fragCoord);\t\t  \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Game Display Buffer\n\n//////////////////////////////////////////////////\n// Debugging Settings\n#define     SHOW_ALBEDO             \t0\n#define     SHOW_NORMALS            \t0\n#define     SHOW_LIGHTING               0\n\n//////////////////////////////////////////////////\n// Settings\n#define ULTRA_QUALITY       4\n#define HIGH_QUALITY\t    3\t\t\n#define MEDIUM_QUALITY\t\t2\n#define LOW_QUALITY\t\t    1\n\n#define QUALITY_MODE \t\tULTRA_QUALITY\n\n//////////////////////////////////////////////////\n// Advanced Settings\n#define     NUMBER_OF_STEPS         30\n\n#if (QUALITY_MODE >= ULTRA_QUALITY) \n#define \tGRASS_NOISE\t\t\t\t1\n#else\n#define \tGRASS_NOISE\t\t\t\t0\n#endif\n\n//////////////////////////////////////////////////\n// Common Globals\nvec3 gCloseIntersection;\n\n//////////////////////////////////////////////////\n// Constants\nconst float     MAX_DISTANCE    = 30.0; // VR needs 20\nconst float     EPSILON         = 0.001;\nconst float     PI              = 3.14159265359;\n\n// Scene\nconst int EDGE_BLOCK\t\t\t= 20;\nconst int GROUND\t\t\t\t= 30;\n\n// Bomberman Material Indexes\nconst int BOMBERMAN_WHITE\t\t= 100;\nconst int BOMBERMAN_BLACK\t\t= 101;\nconst int BOMBERMAN_RED\t\t\t= 102;\nconst int BOMBERMAN_BLUE\t\t= 103;\nconst int BOMBERMAN_PINK\t\t= 104;\nconst int BOMBERMAN_SKIN\t\t= 105;\nconst int BOMBERMAN_GOLD\t\t= 106;\n\nstruct BombermanColorSet\n{\n    int \tmPrimaryColor;\n    int \tmSecondaryColor;\n    int \tmBodyColor;\n};\nconst BombermanColorSet gColorSet0 = BombermanColorSet(BOMBERMAN_WHITE, BOMBERMAN_PINK, BOMBERMAN_BLUE);\nconst BombermanColorSet gColorSet1 = BombermanColorSet(BOMBERMAN_BLACK, BOMBERMAN_PINK, BOMBERMAN_BLACK);\nconst BombermanColorSet gColorSet2 = BombermanColorSet(BOMBERMAN_RED, BOMBERMAN_PINK, BOMBERMAN_RED);\nconst BombermanColorSet gColorSet3 = BombermanColorSet(BOMBERMAN_BLUE, BOMBERMAN_PINK, BOMBERMAN_BLUE);\n            \n// Loading code is from IQ's shader: https://www.shadertoy.com/view/MddGzf\nvec4 LoadValueBufferA(in vec2 re)\n{\n    return texture(iChannel0, (0.5 + re) / iChannelResolution[0].xy, -100.0);\n}\n\nstruct Bomberman\n{\n\tvec2 \tmPosition;\n    float   mDirection;\n    float   mAnimation;\n};\n    \nBomberman LoadBomberman(in vec2 re)\n{\n    vec4 bombermanInfo = LoadValueBufferA(re);  \n    return Bomberman(bombermanInfo.xy, bombermanInfo.z, bombermanInfo.w);\n}\n\n//////////////////////////////////////////////////////\n// Intersection Helpers\nstruct IntersectionData\n{\n    vec2\t\tmStartingTileIndex;\n    vec2\t\tmEndingTileIndex;\n    float       mT;\n    int\t\t    mMaterialIndex;\n};  \n\n#define CreateIntersectionData(x, y)    \tIntersectionData(vec2(-1.0), vec2(-1.0), x, y)\n#define InvalidIntersectionData    \t\t\tIntersectionData(vec2(-1.0), vec2(-1.0), MAX_DISTANCE, -1)\n    \nIntersectionData GetClosestIntersection(in IntersectionData a, in IntersectionData b)\n{\n    if (a.mT < b.mT)\n    {\n        return a;\n    }\n    return b;\n}\n\nstruct Ray\n{\n    vec3    mPosition;\n    vec3    mDirection;\n}; \n\nstruct AABB\n{\n\tvec3 mMin;\n    vec3 mMax;\n};\n           \n//////////////////////////////////////////////////////\n// Basic Distance Field Tests\n// https://iquilezles.org/articles/distfunctions\nfloat sdfBox(in vec3 p, in vec3 boxSize)\n{\n\tvec3 d = abs(p) - boxSize;\n  \treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdfCylinder(in vec3 p, in vec3 cylinderDimensions)\n{\n\treturn length(p.xz - cylinderDimensions.xy) - cylinderDimensions.z;\n}\n\nfloat sdfSphere(in vec3 p, in float radius)\n{\n    return length(p) - radius;\n}\n\nfloat sdfCapsule(in vec3 p, in vec3 pointA, in vec3 pointB, in float radius)\n{\n    vec3 lineBA = pointB - pointA;\n    vec3 linePA = p - pointA;\n    float rate = min(max(dot(lineBA, linePA), 0.0) / dot(lineBA, lineBA), 1.0);\n    return length(p - (pointA + rate * lineBA)) - radius; \n}\n\nfloat udfRoundedBox(in vec3 p, in vec3 boxSize, in float radius)\n{\n\treturn length(max(abs(p) - boxSize, 0.0)) - radius;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin(in float a, in float b, in float k)\n{\n    float h = Saturate(0.5 + 0.5 * (b - a) / k);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat opBlend(in float a, in float b)\n{\n    return smin(a, b, 0.005);\n}\n\n//////////////////////////////////////////////////////\n// Noise\nfloat Hash(in vec2 p)\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat Noise(in vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\t\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(Hash(i), Hash(i + vec2(1.0, 0.0)), u.x), mix(Hash(i + vec2(0.0, 1.0)), Hash(i + vec2(1.0)), u.x), u.y);   \n}\n\nfloat FractalBrownianMotion(in vec2 p)\n{\n   float f \n     = Noise(p) * 16.0\n   \t + Noise(p * 2.0) * 8.0\n     + Noise(p * 4.0) * 4.0\n     + Noise(p * 8.0) * 2.0\n     + Noise(p * 16.0);\n    \n    return f / (1.0 + 2.0 + 4.0 + 8.0 + 16.0 + 32.0);\n}\n\nbool AABBIntersection(in Ray ray, in AABB aabb, out float tMin, out float tMax)\n{\n    for(int i = 0; i < 3; i++)\n    {\n        float inverseDirection = 1.0 / ray.mDirection[i];\n        float t0 = (aabb.mMin[i] - ray.mPosition[i]) * inverseDirection;\n        float t1 = (aabb.mMax[i] - ray.mPosition[i]) * inverseDirection;\n        \n        if (inverseDirection < 0.0)\n        {\n            float temp = t0;\n            t0 = t1;\n            t1 = temp;\n        }\n        \n        tMin = max(t0, tMin);\n        tMax = min(t1, tMax);\n        \n        if (tMax <= tMin)\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Scene\nconst vec3 k_playFieldHalfSize = vec3(0.75, 0.035, 0.5);\nconst vec3 k_playFieldOffset = vec3(0.0, 0.1, 0.0);\nconst AABB k_playField = AABB(-k_playFieldHalfSize + k_playFieldOffset, k_playFieldHalfSize + k_playFieldOffset);\nconst vec3 k_playFieldSize = abs(k_playField.mMax - k_playField.mMin);\n\n// Ground\nconst vec3 k_groundHalfSize = vec3(0.5 * k_playFieldSize.x, 0.25 * k_playFieldSize.y, 0.5 * k_playFieldSize.z);\nconst vec3 k_groundCenter = k_playField.mMin + k_groundHalfSize;\n\n// Blocks\nconst vec3 k_tileSize = vec3(k_playFieldSize.x / (float(CELLS_WIDE) + 2.0), k_playFieldSize.y * 0.375, k_playFieldSize.z / (float(CELLS_TALL) + 2.0));\nconst vec3 k_tileHalfSize = k_tileSize * 0.5;\nconst vec3 k_edgeBlockHalfSize = vec3(k_tileHalfSize.x, k_playFieldSize.y, k_tileHalfSize.z);\n\n// Power Ups\nconst vec3 k_powerUpSize = vec3(k_tileHalfSize.z * 0.65, k_tileHalfSize.y * 0.5, k_tileHalfSize.z * 0.65);\n\nvec3 GetTileCenter(in vec2 tileIndex)\n{\n    vec2 offsetTileIndex = floor(tileIndex + vec2(1.0));\n \n    return vec3(k_playField.mMin.x + k_tileHalfSize.x + offsetTileIndex.x * k_tileSize.x,\n\t\t\t\tk_groundCenter.y + k_groundHalfSize.y + k_tileHalfSize.y,\n    \t\t\tk_playField.mMin.z + k_tileHalfSize.z + offsetTileIndex.y * k_tileSize.z);\n}\n\nvec3 GetBombermanPosition(in vec2 position)\n{    \n    vec2 bomberman2DPosition = k_playField.mMin.xz + k_tileHalfSize.xz + (position.xy + 1.0) * k_tileSize.xz;\n    return vec3(bomberman2DPosition.x, (k_groundCenter.y + k_groundHalfSize.y) + k_tileHalfSize.y, bomberman2DPosition.y);\n}\n\nvec3 GetBombermanForward(in float direction)\n{\n    const vec3[] k_bombermanForward = vec3[](vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, -1.0), vec3(1.0, 0.0, 0.0), vec3(-1.0, 0.0, 0.0)); \n    return k_bombermanForward[uint(direction)];\n}\n\nvec3 GetBombermanRight(in float direction)\n{\n    const vec3[] k_bombermanRight = vec3[](vec3(1.0, 0.0, 0.0), vec3(-1.0, 0.0, 0.0), vec3(0.0, 0.0, -1.0), vec3(0.0, 0.0, 1.0)); \n    return k_bombermanRight[uint(direction)];\n}\n\nIntersectionData CheckBomberman(in Bomberman bomberman, in vec3 position, in vec2 tileIndex, in BombermanColorSet colorSet)\n{\n    IntersectionData primaryIntersection = InvalidIntersectionData;\n    vec2 bombermanTileIndex = GetTileIndex(ConvertTileCoordsToScreenUV(bomberman.mPosition.xy)); \n    vec2 tileDistance = abs(tileIndex - bombermanTileIndex);\n    \n    if ((tileDistance.x <= 1.0) && (tileDistance.y <= 1.0))\n    {\n    \tvec3 bombermanPosition = GetBombermanPosition(bomberman.mPosition) + vec3(k_tileHalfSize.x * 0.125, 0.0, k_tileHalfSize.z * 0.25); \n        vec3 bombermanForward = GetBombermanForward(bomberman.mDirection);\n        vec3 bombermanRight = GetBombermanRight(bomberman.mDirection);\n\n        vec3 offsetPosition = bombermanPosition - position;\n\n#if QUALITY_MODE >= MEDIUM_QUALITY   \n        float headT = sdfSphere(offsetPosition + vec3(0.0, 0.05, 0.0), k_tileHalfSize.z * 0.65);\n        primaryIntersection.mT = headT;\n        primaryIntersection.mMaterialIndex = colorSet.mPrimaryColor;\n\n        // Body\n        IntersectionData bodyIntersection;\n        bodyIntersection.mT = min(primaryIntersection.mT, sdfCapsule(position, bombermanPosition + vec3(0.0, 0.04, 0.0), bombermanPosition + vec3(0.0, 0.03, 0.0), k_tileHalfSize.z * 0.45));\n        bodyIntersection.mMaterialIndex = colorSet.mBodyColor;\n\t\tprimaryIntersection = GetClosestIntersection(bodyIntersection, primaryIntersection);\n        \n        IntersectionData pinkIntersection;\n        pinkIntersection.mMaterialIndex = colorSet.mSecondaryColor;  \n        pinkIntersection.mT = sdfSphere((offsetPosition - (bombermanForward * 0.012) + vec3(0.0, 0.07, 0.0)), k_tileHalfSize.z * 0.3);    \n\n        // Hands\n        vec3 handHeightOffset = vec3(0.0, 0.015, 0.0);\n        float handRotation = bomberman.mAnimation / 20.0 * PI;\n        vec3 handForwardOffset = sin(handRotation) * bombermanForward * 0.01;\n        \n        pinkIntersection.mT = min(pinkIntersection.mT, sdfSphere((offsetPosition - (bombermanRight * 0.02) + handHeightOffset + handForwardOffset), k_tileHalfSize.z * 0.25));\n        pinkIntersection.mT = min(pinkIntersection.mT, sdfSphere((offsetPosition - (bombermanRight * -0.02) + handHeightOffset - handForwardOffset), k_tileHalfSize.z * 0.25));     \n        primaryIntersection = GetClosestIntersection(pinkIntersection, primaryIntersection);\n\n        // Face\n        IntersectionData skinIntersection;\n        vec3 bombermanSkinBoxSize = vec3(k_tileHalfSize.x * 0.3, k_tileHalfSize.y * 0.3, k_tileHalfSize.x * 0.3) * (vec3(1.0) - (0.70 * abs(bombermanForward)));\n        skinIntersection.mT = udfRoundedBox(offsetPosition + vec3(0.0, 0.05, 0.0) + (bombermanForward * 0.0125), bombermanSkinBoxSize, 0.001);\n\n        skinIntersection.mT = opBlend(skinIntersection.mT, headT);\n        skinIntersection.mMaterialIndex = BOMBERMAN_SKIN;  \n        primaryIntersection = GetClosestIntersection(skinIntersection, primaryIntersection);\n\n        // Eyes\n        const float k_eyeRadius = 0.006;\n        const float k_eyeForward = 0.015;\n        const float k_eyeSpacing = 0.0075;\n\n        IntersectionData eyeIntersection;\n        eyeIntersection.mMaterialIndex = BOMBERMAN_BLACK;\n        vec3 eyeTop = bombermanPosition + vec3(0.0, 0.052, 0.0) + (bombermanForward * k_eyeForward);\n        vec3 eyeBottom = bombermanPosition + vec3(0.0, 0.0485, 0.0) + (bombermanForward * k_eyeForward);\n\n        eyeIntersection.mT = sdfCapsule(position, eyeBottom + (bombermanRight * k_eyeSpacing), eyeTop + (bombermanRight * k_eyeSpacing), k_eyeRadius);\n        eyeIntersection.mT = min(eyeIntersection.mT, sdfCapsule(position, eyeBottom + (bombermanRight * -k_eyeSpacing), eyeTop + (bombermanRight * -k_eyeSpacing), k_eyeRadius));\n        primaryIntersection = GetClosestIntersection(eyeIntersection, primaryIntersection);\n\n#elif QUALITY_MODE >= LOW_QUALITY      \n        primaryIntersection.mT = sdfSphere(bombermanPosition - position, gTileHalfSize.z);\n        primaryIntersection.mMaterialIndex = colorSet.mPrimaryColor;\n\n        IntersectionData pinkIntersection;\n        pinkIntersection.mT = sdfSphere((bombermanPosition - (bombermanForward * 0.02) + vec3(0.0, 0.03, 0.0)) - position, gTileHalfSize.z * 0.3);\n        pinkIntersection.mMaterialIndex = colorSet.mSeconadryColor;  \n\n        primaryIntersection = GetClosestIntersection(pinkIntersection, primaryIntersection);\n#endif // QUALITY_MODE >= LOW_QUALITY \n    }\n    return primaryIntersection;\n}\n\nIntersectionData CheckBombermen(in vec3 position, in vec2 tileIndex)\n{ \n\tBomberman bomberman0 = LoadBomberman(txBomberman0Info);\n    Bomberman bomberman1 = LoadBomberman(txBomberman1Info);\n    Bomberman bomberman2 = LoadBomberman(txBomberman2Info);\n    Bomberman bomberman3 = LoadBomberman(txBomberman3Info);\n     \n    IntersectionData bombermanIntersection = GetClosestIntersection(\n           GetClosestIntersection(CheckBomberman(bomberman0, position, tileIndex, gColorSet0), CheckBomberman(bomberman1, position, tileIndex, gColorSet1)),                                                                 \n           GetClosestIntersection(CheckBomberman(bomberman2, position, tileIndex, gColorSet2), CheckBomberman(bomberman3, position, tileIndex, gColorSet3)));\n\n    bombermanIntersection.mStartingTileIndex = tileIndex;\n    bombermanIntersection.mEndingTileIndex = tileIndex;  \n    \n    return bombermanIntersection;\n}\n\nIntersectionData CheckTileIntersection(in vec3 position, in vec2 tileIndex)\n{\n    IntersectionData tileIntersection = InvalidIntersectionData;\n    \n    vec3 tileCenter = GetTileCenter(tileIndex);\n            \n    if ((tileIndex.x >= 0.0) && (tileIndex.y >= 0.0) && (tileIndex.x < float(CELLS_WIDE)) && (tileIndex.y < float(CELLS_TALL)))\n    {\n        vec4 tileInfo = LoadValueBufferA(txPlayField.xy + tileIndex);   \n\t\tint tileType = int(tileInfo.x);\n        \n        if ((tileType == BREAKABLE_BLOCK) || (tileType == UNBREAKABLE_BLOCK) || (tileType == COLLAPSING_BLOCK))\n        {\n            tileIntersection.mT = sdfBox(tileCenter - position, k_tileHalfSize);\n            tileIntersection.mMaterialIndex = int(tileInfo.x);\n        }\n        else if (tileType == EXPLOSION)\n        {\n            tileIntersection.mMaterialIndex = EXPLOSION;\n\n            const vec3 k_horizontalExplosionOffset = vec3(k_tileHalfSize.x, 0.0, 0.0);\n            const vec3 k_verticalExplosionOffset = vec3(0.0, 0.0, k_tileHalfSize.z);\n            float explosionRadius = k_tileHalfSize.z * 0.9 * Saturate(tileInfo.y * 10.0);\n\n            vec3 explosionCenter = vec3(tileCenter.x, k_playField.mMin.y + k_tileHalfSize.z * 0.9, tileCenter.z);\n\n            uint explosionFlags = uint(tileInfo.z);\n            if ((explosionFlags & EXPLOSION_DIRECTION_LEFT) != 0U)\n            {\n                tileIntersection.mT = min(tileIntersection.mT, sdfCapsule(position, explosionCenter, explosionCenter + k_horizontalExplosionOffset * 2.0, explosionRadius));\n            }\n            \n            if ((explosionFlags & EXPLOSION_DIRECTION_RIGHT) != 0U)\n            {\n                tileIntersection.mT = min(tileIntersection.mT, sdfCapsule(position, explosionCenter - k_horizontalExplosionOffset * 2.0, explosionCenter, explosionRadius));\n            }\n            \n            if ((explosionFlags & EXPLOSION_DIRECTION_UP) != 0U)\n            {\n                tileIntersection.mT = min(tileIntersection.mT, sdfCapsule(position, explosionCenter, explosionCenter + k_verticalExplosionOffset * 2.0, explosionRadius));\n            }\n            \n            if ((explosionFlags & EXPLOSION_DIRECTION_DOWN) != 0U)\n            {\n                tileIntersection.mT = min(tileIntersection.mT, sdfCapsule(position, explosionCenter - k_verticalExplosionOffset * 2.0, explosionCenter, explosionRadius));\n            }\n        }\n        else if (tileType == BOMB)\n        {\n            float radiusMix = (sin(tileInfo.y * 10.0) + 1.0) * 0.5;\n            float bombRadius = mix(k_tileHalfSize.z * 0.9, k_tileHalfSize.z * 1.05, radiusMix);\n            \n            tileIntersection.mT = sdfSphere(tileCenter - position, bombRadius);\n            tileIntersection.mMaterialIndex = BOMBERMAN_BLACK;        \n        }\n        else if ((tileType == BOMB_POWER_UP) || (tileType == FLAME_POWER_UP) || (tileType == SKATE_POWER_UP))\n        {\n            tileIntersection.mT = sdfBox(tileCenter - position, k_powerUpSize);\n            tileIntersection.mMaterialIndex = tileType;\n        }         \n    }\n    else\n    {\n        bool xEdge = (tileIndex.x == -1.0) || (tileIndex.x == float(CELLS_WIDE));\n        bool yEdge = (tileIndex.y == -1.0) || (tileIndex.y == float(CELLS_TALL));\n            \n        if (xEdge || yEdge)\n        {\n            tileIntersection.mT = sdfBox(tileCenter - position, k_edgeBlockHalfSize);\n        \ttileIntersection.mMaterialIndex = EDGE_BLOCK;\n        }\n    }   \n    return tileIntersection;\n}\n\nIntersectionData CheckSceneForIntersection(in vec3 position, in vec2 startingTileIndex, in vec2 endingTileIndex)\n{\n#if GRASS_NOISE\n    vec3 grassOffset = vec3(0.0, Noise((position.xz + vec2(2.0)) * iResolution.y * 0.5) * 0.0075, 0.0);\n    IntersectionData sceneIntersection = CreateIntersectionData(sdfBox(k_groundCenter - position, k_groundHalfSize + grassOffset), GROUND);\n#else\n    IntersectionData sceneIntersection = CreateIntersectionData(sdfBox(k_groundCenter - position, k_groundHalfSize), GROUND);\n#endif // GRASS_NOISE\n       \n    IntersectionData bombermanIntersection = CheckBombermen(position, startingTileIndex);\n    sceneIntersection = GetClosestIntersection(sceneIntersection, bombermanIntersection);      \n\n    // Starting tile collision\n    IntersectionData tileIntersection = CheckTileIntersection(position, startingTileIndex);\n    sceneIntersection = GetClosestIntersection(sceneIntersection, tileIntersection);\n    \n    bool checkX = (abs(endingTileIndex.x - startingTileIndex.x) > 0.01);\n\tbool checkY = (abs(endingTileIndex.y - startingTileIndex.y) > 0.01);           \n    \n    if (checkX)\n    {\n        tileIntersection = CheckTileIntersection(position, vec2(endingTileIndex.x, startingTileIndex.y));\n        sceneIntersection = GetClosestIntersection(sceneIntersection, tileIntersection);\n    }\n    \n    if (checkY)\n    {\n        tileIntersection = CheckTileIntersection(position, vec2(startingTileIndex.x, endingTileIndex.y));\n        sceneIntersection = GetClosestIntersection(sceneIntersection, tileIntersection);\n    }\n    \n    if (checkX && checkY)\n    {\n        tileIntersection = CheckTileIntersection(position, endingTileIndex.xy);\n        sceneIntersection = GetClosestIntersection(sceneIntersection, tileIntersection);\n    }\n    \n    // Adjacent tiles, doing some duplicate work here :(\n    const int k_adjacentTilesToCheck = 1;\n     \n    for (int x = -k_adjacentTilesToCheck; x <= k_adjacentTilesToCheck; ++x)\n    {\n        for (int y = -k_adjacentTilesToCheck; y <= k_adjacentTilesToCheck; ++y)\n        {                     \n            vec2 currentTileIndex = (startingTileIndex + vec2(x, y));    \n            if (currentTileIndex != startingTileIndex)\n            {\n\t\t\t\ttileIntersection = CheckTileIntersection(position, currentTileIndex);\n            \tsceneIntersection = GetClosestIntersection(sceneIntersection, tileIntersection);\n            }\n    \t}\n    }\n    \n    return sceneIntersection;\n}\n\nvec2 CalculateTileUV(in vec2 point)\n{\n    return (point - k_playField.mMin.xz) / k_playFieldSize.xz;\n}\n\nvec2 CalculateTileIndex(in vec3 intersectionPoint)\n{\n    vec2 tileUV = CalculateTileUV(intersectionPoint.xz);    \n    return GetTileIndex(tileUV);\n}\n\nIntersectionData CheckSceneForIntersection(in Ray ray)\n{\n    IntersectionData sceneIntersection = InvalidIntersectionData;\n    vec2 closeTileIndex = vec2(-1.0);  \n    vec2 farTileIndex = vec2(-1.0);\n    \n    float tMin = -100.0;\n    float tMax = 100.0;\n    \n    if (AABBIntersection(ray, k_playField, tMin, tMax))\n    { \n        gCloseIntersection = ray.mPosition + (tMin * ray.mDirection);\n        vec2 closeTileUV = CalculateTileUV(gCloseIntersection.xz); \n        closeTileIndex = GetTileIndex(closeTileUV);\n        \n        vec3 farIntersection = ray.mPosition + (tMax * ray.mDirection);\n        vec2 farTileUV = CalculateTileUV(farIntersection.xz); \n        farTileIndex = GetTileIndex(farTileUV);\n             \n        sceneIntersection = CheckSceneForIntersection(ray.mPosition, closeTileIndex, farTileIndex);\n    }\n    sceneIntersection.mStartingTileIndex = closeTileIndex;\n    sceneIntersection.mEndingTileIndex = farTileIndex;\n    \n    return sceneIntersection;\n}\n\nIntersectionData Intersect(in Ray initialRay)\n{    \n    IntersectionData sceneIntersection = InvalidIntersectionData;\n    \n    float t = 0.0;   \n\n    for (int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        // Break out if our step size is too small or we've gone out of range\n        if(sceneIntersection.mT < EPSILON || t > MAX_DISTANCE) break;\n        \n        Ray currentRay = Ray(initialRay.mPosition + initialRay.mDirection * t, initialRay.mDirection);    \n        sceneIntersection = CheckSceneForIntersection(currentRay);    \n        t += sceneIntersection.mT; // Step forward\n    }    \n    sceneIntersection.mT = t;\n    \n    return sceneIntersection;\n}\n\n//////////////////////////////////////////////////////\n// Lighting Helpers\nvec3 GetNormal(in vec3 position, in vec2 startingTileIndex, in vec2 endingTileIndex, in float d0T) \n{\n    IntersectionData d0 = CheckSceneForIntersection(position, startingTileIndex, endingTileIndex);\n    IntersectionData dX = CheckSceneForIntersection(position - vec3(EPSILON, 0.0, 0.0), startingTileIndex, endingTileIndex);\n    IntersectionData dY = CheckSceneForIntersection(position - vec3(0.0, EPSILON, 0.0), startingTileIndex, endingTileIndex);\n    IntersectionData dZ = CheckSceneForIntersection(position - vec3(0.0, 0.0, EPSILON), startingTileIndex, endingTileIndex);\n    return normalize(vec3(dX.mT - d0.mT, dY.mT - d0.mT, dZ.mT - d0.mT));\n}\n\nmat3 Create3x3RotationMatrix(in vec3 axis, in float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,          oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c,          oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c);\n}\n\nvec2 Hash2D(in vec2 p)\n{\n    return fract(sin(p * mat2(12.98, 78.23, 127.99, 311.33)) * 43758.54);\n}\n\nvec3 WorleyNoise(in vec2 uv)\n{\n    vec2 i = floor(uv);\n    vec2 n = fract(uv);\n    vec3 minD = vec3(9.0);\n    \n    for (float y = -1.0; y <= 1.0; ++y) \n    {\n        for(float x = -1.0; x <= 1.0; ++x) \n        {\n            vec2 point = sin(32.0 * Hash2D(i + vec2(x, y))) * 0.5 + 0.5;\n            float d = length(vec2(x, y) + point - n);\n            \n            minD = (d < minD.x) ? vec3(d, minD.xy) \n               \t : (d < minD.y) ? vec3(minD.x, d, minD.y) \n               \t : (d < minD.z) ? vec3(minD.xy, d) \n                 : minD;\n        }\n    }\n    return minD;\n}\n\nvec2 GetPowerUpUVs(in vec3 point, in vec3 normal, in int powerUp)\n{\n\tvec2 tileIndex = CalculateTileIndex(point); \n    vec3 tileCenter = GetTileCenter(tileIndex);\n    normal = abs(normal);\n    \n    vec2 sampleUV = vec2(0.0);\n    if (normal.y > 0.5)\n    {\n    \tsampleUV = (((point.xz - tileCenter.xz) / k_powerUpSize.xz) + vec2(1.0)) * 0.5;\n    }\n    else if (normal.x > 0.5)\n    {\n    \tsampleUV = (((point.yz - tileCenter.yz) / k_powerUpSize.yz) + vec2(1.0)) * 0.5;\n    }\n    else if (normal.z > 0.5)\n    {\n    \tsampleUV = (((point.xy - tileCenter.xy) / k_powerUpSize.xy) + vec2(1.0)) * 0.5;\n    }\n    sampleUV = sampleUV * (vec2(16.0) / iChannelResolution[1].xy) + (float(powerUp) * vec2(16.0, 0.0) / iChannelResolution[1].xy);\n   \n    return sampleUV;\n}\n\nvec3 GetDiffuseColor(in vec3 intersectionPoint, in vec3 normal, in int materialIndex)\n{\n    const vec3 bombermanColors[] = vec3[](vec3(1.0), vec3(0.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), vec3(0.93, 0.51, 0.65), vec3(0.96, 0.9, 0.76));\n\n    vec3 diffuse = vec3(0.0);\n\t\t\n    if (materialIndex == BREAKABLE_BLOCK)\n    {\n#if QUALITY_MODE >= MEDIUM_QUALITY\n        vec2 tileIndex = CalculateTileIndex(intersectionPoint);   \n        vec3 noise = WorleyNoise((intersectionPoint.xz + tileIndex * 17.3) * 30.0);\n        float tint = (noise.z - noise.x);\n        \n        diffuse = mix(vec3(0.35, 0.25, 0.15), vec3(0.7, 0.5, 0.3), tint);\n#else\n        diffuse = vec3(0.8, 0.6, 0.4);        \n#endif \n    }\n    else if (materialIndex == UNBREAKABLE_BLOCK)\n    {\n        diffuse = vec3(0.20);\n #if QUALITY_MODE >= MEDIUM_QUALITY       \n    \tvec2 tileUV = CalculateTileUV(intersectionPoint.xz);   \n        vec2 t = fract(tileUV * vec2(float(CELLS_WIDE) + 2.0, float(CELLS_TALL) + 2.0) - vec2(0.25));   \n        \n        if((t.x < 0.5) || (t.y < 0.5))\n        {\n            diffuse = vec3(0.35);\n        }\n#endif \n    }\n    else if (materialIndex == COLLAPSING_BLOCK)\n    {\n#if QUALITY_MODE >= MEDIUM_QUALITY\n        vec2 tileIndex = CalculateTileIndex(intersectionPoint);   \n        vec3 noise = WorleyNoise((intersectionPoint.xz + tileIndex * 17.3) * 30.0);\n        float tint = (noise.z - noise.x);\n        \n        diffuse = mix(vec3(0.35, 0.25, 0.15), vec3(1.0, 0.25, 0.0), tint);\n#else\n        diffuse = vec3(1.0, 0.25, 0.0);        \n#endif \n    }\n    else if (materialIndex == EXPLOSION)\n    {\n        float flameTint = Saturate(dot(normal, vec3(0.0, -1.0, 0.0)));\n        float flameTintSquared = flameTint * flameTint;\n        diffuse = mix(vec3(1.0, 0.25, 0.0), vec3(1.0, 0.6, 0.2), flameTintSquared * flameTintSquared);\n    }\n    else if (materialIndex == EDGE_BLOCK)\n    {\n        diffuse = vec3(0.5);\n    }\n    else if (materialIndex == GROUND)\n    {\n        diffuse = vec3(0.0, 0.5, 0.0); \n        \n#if QUALITY_MODE >= MEDIUM_QUALITY\n        vec2 tileIndex = CalculateTileIndex(intersectionPoint);\n        if (mod(tileIndex.x + tileIndex.y, 2.0) < 1.0)\n        {\n            diffuse = vec3(0.0, 0.425, 0.0);\n        }\n#endif\n    }\n    else if ((materialIndex >= BOMB_POWER_UP) && (materialIndex <= FLAME_POWER_UP))\n    {\n\t\tdiffuse = texture(iChannel1, GetPowerUpUVs(intersectionPoint, normal, materialIndex - BOMB_POWER_UP)).rgb;      \n#if QUALITY_MODE >= MEDIUM_QUALITY\n\t\tdiffuse = (diffuse.r >= 0.95) ? mix(diffuse, vec3(1.0, 1.0, 0.0), mod(iTime * 15.0, 2.0)) : diffuse;       \n#endif\n    }\n    else if ((materialIndex >= BOMBERMAN_WHITE) && (materialIndex <= BOMBERMAN_SKIN))\n    {\n        diffuse = bombermanColors[materialIndex - BOMBERMAN_WHITE];\n    }  \n    return diffuse;\n}\n\nfloat ApplyDirectionalLight(in vec3 point, in vec3 normal, in vec3 lightDirection, in vec2 startingTileIndex, in vec2 endingTileIndex, in float t)\n{\n    float nDotL = Saturate(dot(normal, lightDirection)); \n    // Eventually apply shadows here\n    return nDotL;\n}\n\nfloat CalculateLighting(in vec3 point, in vec3 normal, in vec2 startingTileIndex, in vec2 endingTileIndex, in float t)\n{\n    const vec3 lightDirection = normalize(vec3(0.5, -1.0, 0.5));\n    float lighting = ApplyDirectionalLight(point, normal, lightDirection, startingTileIndex, endingTileIndex, t);\n    \n    // Wrap lighting\n    const float k_wrapAmount = 0.5;\n    lighting = (lighting + k_wrapAmount) / (1.0 + k_wrapAmount);\n    \n    const float k_ambientLight = 0.3;\n    lighting = min(lighting + k_ambientLight, 1.0);\n\n    return lighting;\n}\n\nvec3 ThreeDimensionalDisplay(in vec3 cameraPosition, in vec3 cameraDirection)\n{\n    vec3 finalColor = vec3(0.0);\n  \n    Ray cameraRay = Ray(cameraPosition, cameraDirection);\n    \n    IntersectionData intersection = Intersect(cameraRay);        \n    if(intersection.mT < MAX_DISTANCE)\n    {   \n        vec3 intersectionPoint = (cameraRay.mPosition + cameraRay.mDirection * intersection.mT);\n        vec3 normal = GetNormal(intersectionPoint, intersection.mStartingTileIndex, intersection.mEndingTileIndex, intersection.mT); \n       \tvec3 diffuse = GetDiffuseColor(intersectionPoint, normal, intersection.mMaterialIndex);\n        \n        float lighting = CalculateLighting(intersectionPoint, normal, intersection.mStartingTileIndex, intersection.mEndingTileIndex, intersection.mT);\n#if SHOW_ALBEDO       \n    \tfinalColor = diffuse;  \n#elif SHOW_NORMALS\n        finalColor = normal * 0.5 + vec3(0.5);\n#elif SHOW_LIGHTING\n        finalColor = vec3(lighting);\n#else\n        finalColor = (diffuse * lighting);\n#endif // SHOW_NORMALS        \n    }\n    else\n    {\n#if QUALITY_MODE == ULTRA_QUALITY\n\t\tfinalColor = vec3(0.6, 0.6, 1.0) * (1.0 - FractalBrownianMotion(cameraDirection.xz));\n#else\n        finalColor = vec3(0.6, 0.6, 1.0);\n#endif\n    }  \n\treturn finalColor;\n}\n\n//////////////////////////////////////////////////\n// Font\n\nfloat DrawCharacter(inout vec2 p, in int c)\n{\n    float fC = float(c);\n    float color = 0.0;\n\tif (p.x >= 0.0 && p.x <= 1.0 && p.y >= 0.0 && p.y <= 1.0)\n    {\n        color = step(texture(iChannel2, p / 16.0 + fract(floor(vec2(fC, 15.99 - fC / 16.0)) / 16.0)).a, 0.5);\n    }\n    p.x -= 0.5;\n    return color;\n}\n\n#define DrawWhite(c, x) c += DrawCharacter(x, 87); c += DrawCharacter(x, 104); c += DrawCharacter(x, 105); c += DrawCharacter(x, 116); c += DrawCharacter(x, 101)\n#define DrawBlack(c, x) c += DrawCharacter(x, 66); c += DrawCharacter(x, 108); c += DrawCharacter(x, 97); c += DrawCharacter(x, 99); c += DrawCharacter(x, 107)\n#define DrawRed(c, x) c += DrawCharacter(x, 82); c += DrawCharacter(x, 101); c += DrawCharacter(x, 100);\n#define DrawBlue(c, x) c += DrawCharacter(x, 66); c += DrawCharacter(x, 108); c += DrawCharacter(x, 117); c += DrawCharacter(x, 101);\n#define DrawBomber(c, x) c += DrawCharacter(x, 66); c += DrawCharacter(x, 111); c += DrawCharacter(x, 109); c += DrawCharacter(x, 98); c += DrawCharacter(x, 101); c += DrawCharacter(x, 114)\n#define DrawWins(c, x) c += DrawCharacter(x, 87); c += DrawCharacter(x, 105); c += DrawCharacter(x, 110); c += DrawCharacter(x, 115)\n#define DrawDraw(c, x) c += DrawCharacter(x, 68); c += DrawCharacter(x, 114); c += DrawCharacter(x, 97); c += DrawCharacter(x, 119)\n\n//////////////////////////////////////////////////\n// Implementation \n\nvec3 DisplayScene(in vec3 cameraPosition, in vec3 cameraDirection, in vec2 uv, in vec2 textUVs)\n{\n    vec3 sceneColor = vec3(0.0);\n    \n    vec4 gameInfo = LoadValueBufferA(txGameInfo);\n    \n    if ((gameInfo.x == MODE_GAMEPLAY) || (gameInfo.x == MODE_MATCH_OVER) || (gameInfo.x == MODE_AWARD))\n    {  \n    \tsceneColor = ThreeDimensionalDisplay(cameraPosition, cameraDirection);\n        \n        float characterMask = 0.0;\n\n        if (gameInfo.x == MODE_AWARD) // Win Screen\n        {\n            Bomberman bomberman0 = LoadBomberman(txBomberman0Info);\n            Bomberman bomberman1 = LoadBomberman(txBomberman1Info);\n            Bomberman bomberman2 = LoadBomberman(txBomberman2Info);\n            Bomberman bomberman3 = LoadBomberman(txBomberman3Info);\n        \n            const float k_textScale = 8.0;\n            const float k_spaceAmount = 0.5f;\n            \n            textUVs = textUVs * k_textScale + vec2(0.0, -3.25);\n            vec3 textColor = vec3(1.0);\n        \n            bool shouldBrighten = true;\n        \n            // Tint the screen the color of the winner\n            if (IsBombermanAlive(bomberman0.mPosition.x))\n            {   \n                textUVs.x -= 2.8;\n            \n                textColor = vec3(1.0, 1.0, 1.0);\n                DrawWhite(characterMask, textUVs);\n                textUVs.x -= k_spaceAmount;\n                DrawBomber(characterMask, textUVs);\n                textUVs.x -= k_spaceAmount;\n                DrawWins(characterMask, textUVs);\n                \n                shouldBrighten = false;\n            }\n            else if (IsBombermanAlive(bomberman1.mPosition.x))\n            {\n                textUVs.x -= 3.0;\n            \n                textColor = vec3(0.0, 0.0, 0.0);\n                DrawBlack(characterMask, textUVs);\n                textUVs.x -= k_spaceAmount;\n                DrawBomber(characterMask, textUVs);\n                textUVs.x -= k_spaceAmount;\n                DrawWins(characterMask, textUVs);\n            }\n            else if (IsBombermanAlive(bomberman2.mPosition.x))\n            {\n                textUVs.x -= 3.1;\n            \n                textColor = vec3(1.0, 0.0, 0.0);\n                DrawRed(characterMask, textUVs);\n                textUVs.x -= k_spaceAmount;\n                DrawBomber(characterMask, textUVs);\n                textUVs.x -= k_spaceAmount;\n                DrawWins(characterMask, textUVs);\n            }\n            else if (IsBombermanAlive(bomberman3.mPosition.x))\n            {\n                textUVs.x -= 3.0;\n            \n                textColor = vec3(0.0, 0.0, 1.0);\n                DrawBlue(characterMask, textUVs);\n                textUVs.x -= k_spaceAmount;\n                DrawBomber(characterMask, textUVs);\n                textUVs.x -= k_spaceAmount;\n                DrawWins(characterMask, textUVs);\n            }\n            else\n            {\n                textUVs.x -= 5.8;            \n                DrawDraw(characterMask, textUVs);\n                shouldBrighten = false;\n            }\n            \n            // Darken or brighten the screen for easier text reading\n            sceneColor = shouldBrighten ? mix(sceneColor, vec3(1.0), 0.7) : (sceneColor * 0.7);\n            sceneColor = mix(sceneColor, textColor, characterMask);\n        }    \n    }\n    return sceneColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n    vec2 adjustedUVs = vec2((uv.x * 2.0 - 1.0) * (iResolution.x / iResolution.y), uv.y * 2.0 - 1.0) * 0.75; \n    \n    float xRotationValue = (iMouse.z > 0.0) ? (iMouse.y / iResolution.y - 0.5) * (PI * 0.5) : 0.0;\n    mat3 xRotationMatrix = Create3x3RotationMatrix(vec3(1.0, 0.0, 0.0), xRotationValue);\n    float zRotationValue = (iMouse.z > 0.0) ? (iMouse.x / iResolution.x - 0.5) * (PI * 0.5) : 0.0; // Multiply by 0.1 to slow down the rotation \n    mat3 zRotationMatrix = Create3x3RotationMatrix(vec3(0.0, 0.0, -1.0), zRotationValue);\n           \n    const float k_distanceFromOrigin = 0.75;\n    vec3 cameraPosition = vec3(k_distanceFromOrigin * sin(zRotationValue) * cos(xRotationValue), k_distanceFromOrigin * cos(zRotationValue) * cos(xRotationValue), k_distanceFromOrigin * sin(xRotationValue));\n    vec3 cameraDirection = normalize(zRotationMatrix * xRotationMatrix * vec3(adjustedUVs.x, -1.0, adjustedUVs.y));\n   \n    // We use yy to account for the aspect ratio  \n    vec2 textUVs = (fragCoord.xy / iResolution.yy);\n   \n    vec3 finalColor = DisplayScene(cameraPosition, cameraDirection, uv, textUVs);\n    \n    fragColor = vec4(finalColor, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Sprite Sheet\n// References: [SH16C] Contra by knarkowicz - https://www.shadertoy.com/view/XltGDr\n\n#define RGB(r, g, b) vec3(float(r), float(g), float(b)) / 255.0\n\n// Each powerup sprite is 16x16\n\nconst vec2 k_powerUpSize = vec2(16.0);\nconst vec4 k_bombPowerUp = vec4(0.0, 0.0, k_powerUpSize.xy);\nconst vec4 k_skatePowerUp = vec4(k_powerUpSize.x, 0.0, 2.0 * k_powerUpSize.x, k_powerUpSize.y);\nconst vec4 k_flamePowerUp = vec4(2.0 * k_powerUpSize.x, 0.0, 3.0 * k_powerUpSize.x, k_powerUpSize.y);\n\nbool IsWithinDimensions(in vec2 fragCoord, in vec4 area)\n{\n    if ((fragCoord.x >= area.x) && (fragCoord.y >= area.y) && (fragCoord.x < area.z) && (fragCoord.y < area.w))\n    {\n        return true;\n    }\n    return false;\n}\n\nvec3 DisplayBombPowerUp(in vec2 fragCoord)\n{\n    float x = floor(fragCoord.x - k_bombPowerUp.x);\n    float y = floor(fragCoord.y - k_bombPowerUp.y);\n    \n    vec3 spriteColor = RGB(255, 25, 25);\n\n   \tconst vec3 k_backGreen = RGB(51, 148, 82);\n\tconst vec3 k_bombBlack = RGB(33, 38, 30);\n    const vec3 k_edgeRed = RGB(255, 25, 25);\n    \n    spriteColor = (y == 14.0) ? ((x >= 5.0 && x <= 10.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    spriteColor = (y == 13.0) ? ((x >= 3.0 && x <= 11.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : (x == 13.0 ? RGB(209, 60, 30) : (x == 12.0 ? RGB(255, 255, 255) : k_backGreen)))) : spriteColor; \n    spriteColor = (y == 12.0) ? ((x >= 2.0 && x <= 13.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : RGB(51, 148, 82))) : spriteColor; \n    spriteColor = (y == 11.0) ? ((x >= 2.0 && x <= 13.0) ? (x == 5.0 || x == 6.0 ? RGB(255, 255, 255) : k_bombBlack) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor;     \n    spriteColor = (y == 10.0) ? ((x >= 2.0 && x <= 13.0) ? (x == 5.0 || x == 6.0 ? RGB(255, 255, 255) : k_bombBlack) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor;     \n\tspriteColor = (y == 9.0) ? ((x >= 1.0 && x <= 14.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 8.0) ? ((x >= 1.0 && x <= 14.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 7.0) ? ((x >= 1.0 && x <= 14.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 6.0) ? ((x >= 1.0 && x <= 14.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 5.0) ? ((x >= 1.0 && x <= 14.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 4.0) ? ((x >= 2.0 && x <= 13.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 3.0) ? ((x >= 2.0 && x <= 13.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    spriteColor = (y == 2.0) ? ((x >= 3.0 && x <= 12.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    spriteColor = (y == 1.0) ? ((x >= 5.0 && x <= 10.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\n    return spriteColor;\n}\n\nvec3 DisplayFlamePowerUp(in vec2 fragCoord)\n{\n    float x = floor(fragCoord.x - k_flamePowerUp.x);\n    float y = floor(fragCoord.y - k_flamePowerUp.y);\n    \n    vec3 spriteColor = RGB(255, 25, 25);\n    \n    const vec3 k_backGreen = RGB(51, 148, 82);\n    const vec3 k_black = RGB(0, 0, 0);\n    const vec3 k_edgeRed = RGB(255, 25, 25);\n    const vec3 k_flameYellow = RGB(255, 180, 0);\n    \n    spriteColor = (y == 14.0) ? ((x >= 5.0 && x <= 13.0) ? ((x == 5.0 || x == 9.0 || x == 12.0 || x == 13.0) ? RGB(127, 26, 4) : RGB(51, 148, 82))  : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    spriteColor = (y == 13.0) ? ((x >= 3.0 && x <= 14.0) ? ((x == 3.0 || x == 4.0 || x == 6.0 || x == 8.0 || x == 9.0 || x == 11.0 || x == 13.0 || x == 14.0) ? RGB(127, 26, 4) : (x == 5.0 || x == 12.0 ? RGB(255, 202, 0) : k_backGreen)) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    spriteColor = (y == 12.0) ? ((x >= 2.0 && x <= 14.0) ? ((x == 14.0 || x == 10.0 || x == 7.0 || x == 2.0) ? RGB(127, 26, 4) : RGB(255, 202, 0))  : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    spriteColor = (y == 11.0) ? ((x >= 2.0 && x <= 14.0) ? ((x == 2.0 || x == 14.0) ? RGB(127, 26, 4) : k_flameYellow) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor;     \n    spriteColor = (y == 10.0) ? ((x >= 1.0 && x <= 14.0) ? ((x == 1.0 || x == 14.0) ? RGB(127, 26, 4) : k_flameYellow) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 9.0) ? ((x >= 1.0 && x <= 14.0) ? ((x == 1.0 || x == 14.0) ? RGB(127, 26, 4) : (x == 5.0  || x == 9.0 ? k_black : k_flameYellow)) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 8.0) ? ((x >= 1.0 && x <= 14.0) ? ((x == 1.0 || x == 14.0) ? RGB(127, 26, 4) : (x == 5.0  || x == 9.0 ? k_black : k_flameYellow)) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 7.0) ? ((x >= 1.0 && x <= 14.0) ? ((x == 1.0 || x == 14.0) ? RGB(127, 26, 4) : (x == 5.0  || x == 9.0 ? k_black : k_flameYellow)) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 6.0) ? ((x >= 1.0 && x <= 14.0) ? ((x == 1.0 || x == 14.0) ? RGB(127, 26, 4) : k_flameYellow) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 5.0) ? ((x >= 1.0 && x <= 14.0) ? ((x == 1.0 || x == 14.0) ? RGB(127, 26, 4) : (x >= 5.0 && x <= 9.0 ? RGB(155, 20, 20) : k_flameYellow)) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 4.0) ? ((x >= 2.0 && x <= 13.0) ? ((x == 2.0 || x == 13.0) ? RGB(127, 26, 4) : (x >= 5.0 && x <= 9.0 ? RGB(155, 20, 20) : k_flameYellow)) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 3.0) ? ((x >= 2.0 && x <= 13.0) ? ((x == 2.0 || x == 13.0) ? RGB(127, 26, 4) : (x >= 6.0 && x <= 8.0 ? RGB(155, 20, 20) : k_flameYellow)) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    spriteColor = (y == 2.0) ? ((x >= 3.0 && x <= 12.0) ? ((x == 3.0 || x == 12.0) ? RGB(127, 26, 4) : k_flameYellow) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    spriteColor = (y == 1.0) ? ((x >= 4.0 && x <= 11.0) ? RGB(127, 26, 4) : ((x == 0.0 || x == 15.0) ? k_edgeRed : RGB(51, 148, 82))) : spriteColor; \n    \n    return spriteColor;\n}\n\nvec3 DisplaySkatePowerUp(in vec2 fragCoord)\n{\n    float x = floor(fragCoord.x - k_skatePowerUp.x);\n    float y = floor(fragCoord.y - k_skatePowerUp.y);\n    \n    vec3 spriteColor = RGB(255, 25, 25);\n    \n    const vec3 k_backGreen = RGB(51, 148, 82);\n    const vec3 k_black = RGB(0, 0, 0);\n    const vec3 k_edgeRed = RGB(255, 25, 25);\n    const vec3 k_skateBlue = RGB(5, 119, 252);\n    const vec3 k_skateOrange = RGB(219, 113, 5);\n    \n    spriteColor = (y == 14.0) ? ((x >= 6.0 && x <= 13.0) ? ((x >= 6.0 && x <= 13.0) ? k_black : k_skateBlue) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor;\n    spriteColor = (y == 13.0) ? ((x >= 6.0 && x <= 13.0) ? ((x == 6.0 || x == 13.0) ? k_black : k_skateBlue) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    spriteColor = (y == 12.0) ? ((x >= 6.0 && x <= 13.0) ? ((x == 6.0 || x == 13.0) ? k_black : ((x < 9.0) ? k_skateOrange : k_skateBlue)) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    spriteColor = (y == 11.0) ? ((x >= 6.0 && x <= 13.0) ? ((x == 6.0 || x == 13.0) ? k_black : k_skateBlue) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor;     \n    spriteColor = (y == 10.0) ? ((x >= 5.0 && x <= 13.0) ? ((x == 5.0 || x == 13.0) ? k_black : ((x < 9.0) ? k_skateOrange : k_skateBlue)) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor;\n\tspriteColor = (y == 9.0) ? ((x >= 3.0 && x <= 13.0) ? (((x >= 3.0 && x <= 5.0) || x == 13.0) ? k_black : k_skateBlue) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor;\n\tspriteColor = (y == 8.0) ? ((x >= 2.0 && x <= 14.0) ? ((x == 2.0 || x == 14.0) ? k_black : k_skateBlue) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor;\n\tspriteColor = (y == 7.0) ? ((x >= 1.0 && x <= 14.0) ? ((x == 1.0 || x == 14.0) ? k_black : k_skateBlue) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 6.0) ? ((x >= 1.0 && x <= 14.0) ? ((x == 1.0 || x == 4.0 || x == 5.0 || x == 10.0 || x == 11.0 || x == 14.0) ? k_black : k_skateBlue) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 5.0) ? ((x >= 1.0 && x <= 14.0) ? ((x == 1.0 || x == 3.0 || x == 6.0 || x == 9.0 || x == 12.0 || x == 14.0) ? k_black : ((x == 4.0 || x == 5.0 || x == 10.0 || x == 11.0) ? k_skateOrange : k_skateBlue)) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 4.0) ? ((x == 2.0 || x == 7.0 || x == 8.0 || x == 13.0 || x == 4.0 ||x == 5.0 || x == 10.0 || x == 11.0) ? k_black : ((x == 0.0 || x == 15.0) ? k_edgeRed : ((x >= 3.0 && x <= 6.0 || x >= 9.0 && x <= 12.0) ? k_skateOrange : k_backGreen))) : spriteColor; \n\tspriteColor = (y == 3.0) ? ((x == 2.0 || x == 7.0 || x == 8.0 || x == 13.0 || x == 4.0 ||x == 5.0 || x == 10.0 || x == 11.0) ? k_black : ((x == 0.0 || x == 15.0) ? k_edgeRed : ((x >= 3.0 && x <= 6.0 || x >= 9.0 && x <= 12.0) ? k_skateOrange : k_backGreen))) : spriteColor; \n    spriteColor = (y == 2.0) ? ((x == 3.0 || x == 6.0 || x == 9.0 || x == 12.0) ? k_black : ((x == 0.0 || x == 15.0) ? k_edgeRed : ((x == 4.0 || x == 5.0 || x == 10.0 || x == 11.0) ? k_skateOrange : k_backGreen))) : spriteColor; \n    spriteColor = (y == 1.0) ? ((x == 4.0 || x == 5.0 || x == 10.0 || x == 11.0) ? k_black : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    \n    return spriteColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 finalColor = vec3(0.0);\n    \n    // Early out if not within bounds\n    if ((fragCoord.x > (k_powerUpSize.x * 4.0)) || (fragCoord.y > k_powerUpSize.y)) \n    {\n        discard;\n    }\n    \n    if (iFrame == 0)\n    {\n        finalColor = vec3(0.0, 0.0, 0.0);     \n        finalColor += IsWithinDimensions(fragCoord, k_bombPowerUp) ? DisplayBombPowerUp(fragCoord) : vec3(0);\n        finalColor += IsWithinDimensions(fragCoord, k_skatePowerUp) ? DisplaySkatePowerUp(fragCoord) : vec3(0);\n        finalColor += IsWithinDimensions(fragCoord, k_flamePowerUp) ? DisplayFlamePowerUp(fragCoord) : vec3(0);            \n    }\n    else\n    {\n        finalColor = texture(iChannel0, uv).rgb;\n    }\t\n    fragColor = vec4(finalColor, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Tile info\n// x = tile type, y = tile timer, z = tile explosion direction, w = explosion steps remaining\nconst int UNBREAKABLE_BLOCK = -2;\nconst int BREAKABLE_BLOCK \t= -1;\nconst int FREE_SPACE\t\t=  0;\nconst int BOMB_POWER_UP\t\t=  1;\nconst int SKATE_POWER_UP\t=  2;\nconst int FLAME_POWER_UP\t=  3;\nconst int EXPLOSION\t\t\t=  4;\nconst int COLLAPSING_BLOCK \t= -3;\nconst int BOMB\t\t\t\t=  20;\n\n// Stage is 15 by 13\nconst uint CELLS_WIDE = 15U;\nconst uint CELLS_TALL = 13U;\n\n// Explosion Directions\nconst uint EXPLOSION_DIRECTION_LEFT  = 1U;\nconst uint EXPLOSION_DIRECTION_UP    = 2U;\nconst uint EXPLOSION_DIRECTION_RIGHT = 4U;\nconst uint EXPLOSION_DIRECTION_DOWN  = 8U;\nconst uint EXPLOSION_DIRECTION_ALL   = 15U;\n\n// Storage register/texel addresses\nconst vec2 txGameInfo = vec2(0.0, 0.0); // x = game mode\nconst vec4 txBombermanInfo = vec4(1.0, 0.0, 8.0, 1.0);\nconst vec2 txBomberman0Info = vec2(1.0, 0.0);\nconst vec2 txBomberman1Info = vec2(5.0, 0.0);\nconst vec2 txBomberman2Info = vec2(9.0, 0.0);\nconst vec2 txBomberman3Info = vec2(13.0, 0.0);\n\n// x = horizontal movement, y = vertical movement, z = bomb key, w = time since last bomb key press\nconst vec2 txBomberman0Command = vec2(1.0, 0.0); \nconst vec2 txBomberman1Command = vec2(2.0, 0.0); \nconst vec2 txBomberman2Command = vec2(3.0, 0.0); \nconst vec2 txBomberman3Command = vec2(4.0, 0.0); \n\nconst vec4 txPlayField = vec4(0.0, 1.0, float(CELLS_WIDE), 1.0 + float(CELLS_TALL));\n\n//////////////////////////////////////////////////\n// Game Modes \nconst float MODE_MATCH_RESET = 0.0;\nconst float MODE_GAMEPLAY = 1.0;\nconst float MODE_MATCH_OVER = 2.0;\nconst float MODE_AWARD = 3.0;\n\n////////////////////////////////////////////////////////\n// Helpers\nfloat Saturate(in float f)\n{\n    return clamp(f, 0.0, 1.0);\n}\n\nvec2 Saturate(in vec2 v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nvec3 Saturate(in vec3 v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\n// IsInside/Saving/Loading code is from IQ's shader: https://www.shadertoy.com/view/MddGzf\nfloat IsInside(in vec2 p, in vec2 c) \n{ \n    vec2 d = abs(p - 0.5 - c) - 0.5; \n    return -max(d.x, d.y); \n}\n\nfloat IsInside(in vec2 p, in vec4 c) \n{ \n    vec2 d = abs(p - 0.5 - c.xy - c.zw * 0.5) - 0.5 * c.zw - 0.5; \n    return -max(d.x, d.y); \n}\n\nvoid StoreValue(in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = (IsInside(fragCoord, re) > 0.0) ? va : fragColor;\n}\n\nvoid StoreValue(in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = (IsInside(fragCoord, re) > 0.0) ? va : fragColor;\n}\n\nvec2 GetTileIndex(in vec2 uv)\n{\n    return floor(vec2(uv.x, uv.y) * vec2(float(CELLS_WIDE) + 2.0, float(CELLS_TALL) + 2.0)) - 1.0;\n}\n\nvec2 ConvertTileCoordsToScreenUV(in vec2 tileCoords)\n{\n    return (tileCoords + vec2(1.5)) / vec2(float(CELLS_WIDE) + 2.0, float(CELLS_TALL) + 2.0);\n}\n\nbool IsBombermanAlive(in float xPosition)\n{\n    return (xPosition >= -10.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}