{
    "Shader": {
        "info": {
            "date": "1605367661",
            "description": "This started with me trying to work out how to make a cloud, and then developed from there.\nThe sea and plane are deliberately voxel-y, partly to keep the frame rate up and partly coz I just like it.\nNo airplanes were harmed in the making of this shader.",
            "flags": 0,
            "hasliked": 0,
            "id": "tsVcWt",
            "likes": 99,
            "name": "Storm in a teacup",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "water",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "dean_the_coder",
            "viewed": 16882
        },
        "renderpass": [
            {
                "code": "// Processed by 'GLSL Shader Shrinker' (Shrunk by 501 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\n// Storm in a teacup\n//\n// This started with me trying to work out how to make a cloud,\n// and then kinda developed from there...\n// The sea and plane are deliberately voxel-y, partly\n// to keep the frame rate up and partly coz I just like it. :)\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat time, flash, glow;\n\nstruct MarchData {\n\tfloat d;\n\tvec3 mat; // RGB\n\tbool isCloud;\n};\n\n// Thanks Shane - https://www.shadertoy.com/view/lstGRB\nfloat noise(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip;\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat noise(float n) {\n\tfloat flr = floor(n);\n\tvec2 rndRange = fract(sin(vec2(flr, flr + 1.) * 12.9898) * 43758.545);\n\treturn mix(rndRange.x, rndRange.y, fract(n));\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nMarchData minResult(MarchData a, MarchData b) {\n\tif (a.d < b.d) return a;\n\treturn b;\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n\tvec2 d = abs(vec2(length(p.xy), p.z)) - vec2(h, r);\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nMarchData sdSea(vec3 p, const float bowlInner) {\n\tMarchData result;\n\tresult.isCloud = false;\n\tmat2 r = rot(23.23);\n\tvec2 af = vec2(1);\n\tfloat t = time * .4,\n\t      wave = noise(p.x);\n\tfor (int i = 0; i < 8; i++) {\n\t\twave += (1. - abs(sin((p.x + t) * af.y))) * af.x;\n\t\tp.xz *= r;\n\t\taf *= vec2(.5, 1.64);\n\t}\n\n\tresult.d = max(p.y + 1. - wave * .3, bowlInner);\n\tresult.mat = vec3(.03, .09, .12) * wave;\n\treturn result;\n}\n\nMarchData sdCup(vec3 p) {\n\tMarchData result;\n\tresult.mat = vec3(1);\n\tresult.isCloud = false;\n\tfloat bowlInner = length(p) + p.y * .1 - 2.;\n\tresult.d = smin(max(abs(bowlInner) - .06, p.y), max(max(abs(length(p.xy - vec2(2, p.x * p.x * .1 - 1.1)) - .5) - .06, abs(p.z) - .06), -bowlInner), .1);\n\treturn minResult(result, sdSea(p, bowlInner));\n}\n\nfloat sdSaucer(vec3 p) {\n\tfloat l = length(p.xz);\n\tp.y += 1.9 - l * (.1 + .02 * smoothstep(0., .1, l - 2.05));\n\treturn sdCappedCylinder(p.xzy, 2.6, .01) - .02;\n}\n\nvec3 getRayDir(vec3 ro, vec2 uv) {\n\tvec3 forward = normalize(-ro),\n\t     right = normalize(cross(vec3(0, 1, 0), forward));\n\treturn normalize(forward + right * uv.x + cross(forward, right) * uv.y);\n}\n\nfloat sdCloud(vec3 p) {\n\tp.y -= 1.3;\n\tfloat d = min(length(p + vec3(.4, 0, 0)), length(p - vec3(.4, 0, 0)));\n\tif (d < 2.0) d -= abs(smoothstep(0., 1., (noise(p * 4.) + noise(p * 9.292 - vec3(0, time, 0)) * .4) * .3) - .4) + .55;\n    return d;\n}\n\nMarchData sdPlane(vec3 p) {\n\tMarchData result;\n\tresult.mat = vec3(.29, .33, .13);\n\tresult.isCloud = false;\n\n\t// Scale, position, rotate.\n\tp *= 1.5;\n\tp.xz *= rot(time * .6);\n\tp.xy -= vec2(1.5, .4);\n\tp.xy *= rot(sin(time * 3.) * .1);\n\n\t// Fuselage.\n\tvec3 ppp,\n\t     pp = p + vec3(0, 0, .15);\n\tresult.d = sdBox(pp, vec2(.04 + pp.z * .05, .3).xxy);\n    \n    if (result.d > 2.0) return result;\n\n\t// Prop.\n\tppp = pp;\n\tppp.z -= .33;\n\tppp.xy *= rot(time * 8.);\n\tfloat d = sdBox(ppp, vec3(.09, .01 * sin(length(p.xy) * 34.), .005));\n\n\t// Tail.\n\tpp.yz += vec2(-.05, .26);\n\tresult.d = min(min(result.d, sdBox(pp, vec3(.01, .06 * cos(pp.z * 25.6), .03))), sdBox(pp + vec3(0, .05, 0), vec3(.15 * cos(pp.z * 12.), .01, .03)));\n\n\t// Wings\n\tp.y = abs(p.y) - .08;\n\tresult.d = min(result.d, sdBox(p, vec3(.3, .01, .1)));\n\tif (d < result.d) {\n\t\tresult.d = d;\n\t\tresult.mat = vec3(.05);\n\t}\n\n\tresult.d = (result.d - .005) * .4;\n\treturn result;\n}\n\n// Map the scene using SDF functions.\nbool hideCloud;\nMarchData map(vec3 p) {\n\tMarchData result = sdCup(p);\n\tresult.d = min(result.d, sdSaucer(p));\n\tresult = minResult(result, sdPlane(p));\n\tfloat d,\n\t      gnd = length(p.y + 1.7);\n\tif (flash > 0.) {\n\t\td = max(length(p.xz * rot(fract(time) * 3.141) + vec2(noise(p.y * 6.5) * .08) - vec2(.5, 0)), p.y - .7);\n\t\tglow += .001 / (.01 + 2. * d * d);\n\t\tif (d < result.d) result.d = d;\n\t}\n\n\tif (gnd < result.d) {\n\t\tresult.d = gnd;\n\t\tresult.mat = vec3(.2);\n\t}\n\n\tif (!hideCloud) {\n\t\td = sdCloud(p);\n\t\tif (d < result.d) {\n\t\t\tresult.d = d * .7;\n\t\t\tresult.isCloud = true;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nvec3 calcNormal(vec3 p, float t) {\n\tvec2 e = vec2(.5773, -.5773) * t * 1e-4;\n\treturn normalize(e.xyy * map(p + e.xyy).d + e.yyx * map(p + e.yyx).d + e.yxy * map(p + e.yxy).d + e.xxx * map(p + e.xxx).d);\n}\n\nvec3 cloudNormal(vec3 p) {\n\tconst vec2 e = vec2(.5773, -.5773);\n\treturn normalize(e.xyy * sdCloud(p + e.xyy) + e.yyx * sdCloud(p + e.yyx) + e.yxy * sdCloud(p + e.yxy) + e.xxx * sdCloud(p + e.xxx));\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos) {\n\t// Thanks iq.\n\tvec3 rd = normalize(lightPos - p);\n\tfloat res = 1.,\n\t      t = .1;\n\tfor (float i = 0.; i < 32.; i++) {\n\t\tfloat h = map(p + rd * t).d;\n\t\tres = min(res, 10. * h / t);\n\t\tt += h;\n\t\tif (res < .001 || t > 3.) break;\n\t}\n\n\treturn clamp(res, 0., 1.);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) { return map(p + h * n).d / h; }\n\nfloat cloudAo(vec3 p, vec3 n, float h) { return sdCloud(p + h * n) / h; }\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tcol *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn col;\n}\n\nvec3 applyLighting(vec3 p, vec3 rd, float d, MarchData data) {\n\tvec3 sunDir = normalize(vec3(6, 10, -4) - p),\n\t     n = calcNormal(p, d);\n\treturn data.mat * (max(0., dot(sunDir, n)) * mix(.4, 1., calcShadow(p, vec3(6, 10, -4))) + max(0., dot(sunDir * vec3(-1, 0, -1), n)) * .3) * dot(vec3(ao(p, n, .2), ao(p, n, .5), ao(p, n, 2.)), vec3(.2, .3, .5)) * vec3(2, 1.6, 1.4) * exp(-length(p) * .14);\n}\n\nvec3 cloudLighting(vec3 p, float den) {\n\tvec3 n = cloudNormal(p),\n\t     col = vec3(2, 1.6, 1.4) * (1. + flash);\n\treturn min(.75, den) * max(.1, dot(normalize(vec3(6, 10, -4) - p), n)) * cloudAo(p, n, 1.) * col;\n}\n\nvec3 getSceneColor(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tMarchData h;\n\tfloat d = .01,\n\t      den = 0.,\n\t      maxCloudD = 0.;\n\thideCloud = false;\n\tvec3 p, cloudP;\n\tfor (float steps = 0.; steps < 120.; steps++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\t\tif (h.d < .0015) {\n\t\t\tif (!h.isCloud) break;\n\t\t\thideCloud = true;\n\t\t\tcloudP = p;\n\t\t\tmaxCloudD = 20. - sdCloud(p + rd * 20.);\n\t\t}\n\n\t\tif (d > 55.) break; // Distance limit reached - Stop.\n\t\td += h.d; // No hit, so keep marching.\n\t}\n\n\tif (hideCloud) {\n\t\tfor (float i = 0.; i < 20.; i++)\n\t\t\tden += clamp(-sdCloud(cloudP + rd * maxCloudD * i / 20.) * .2, 0., 1.);\n\t}\n\n\thideCloud = false;\n\treturn applyLighting(p, rd, d, h) + cloudLighting(cloudP, den) + glow + flash * .05;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\ttime = mod(iTime, 120.);\n\tflash = step(.55, pow(noise(time * 8.), 5.));\n    \n\tvec3 col = vec3(0),\n\t     ro = vec3(0, 2, -5);\n\tro.xz *= rot(-.6);\n    \n\tvec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\tcol += getSceneColor(ro, getRayDir(ro, uv));\n\n\t// Output to screen.\n\tfragColor = vec4(vignette(pow(col, vec3(.4545)), fragCoord), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}