{
    "Shader": {
        "info": {
            "date": "1641790365",
            "description": "Path-Traced Black Hole v2: Electric Boogaloo\n\nStill more to be done, idk it's all just one big experiment... I've been doing more with C/C++ lately, I need to get back to doing more shaders.",
            "flags": 32,
            "hasliked": 0,
            "id": "flcXW4",
            "likes": 38,
            "name": "Path-Traced Black Hole v2",
            "published": 3,
            "tags": [
                "pathtrace",
                "pathtracing",
                "pathtracer",
                "blackhole",
                "tracing",
                "traced",
                "tracer",
                "optics",
                "trace",
                "path",
                "hole",
                "optic",
                "black",
                "bh",
                "pathtraced"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 3641
        },
        "renderpass": [
            {
                "code": "// ####### Path-Traced Black Hole v2 #######\n// Made by Jacob Bingham (Zi7ar21) on January 9th, 2022\n// Merry (Late) Christmas! :)\n\n// Last Updated on January 22nd, 2022 at 02:46 Mountain Standard Time\n\n// If you found this anywhere except Shadertoy, you can find the original and possibly updated version at:\n// https://www.shadertoy.com/view/flcXW4\n\n// Version 1: https://www.shadertoy.com/view/7tS3DW\n\n/*\n## Features\n\n- Gravitational Distortion\n- Monte-Carlo Bloom\n- Volumetric Path-Tracing\n*/\n\n/*\n# Zi7ar21's Epic License\n\nThis applies to...\n\n- Code I wrote\n  - You must respect the individual licenses of any snippets in the source that aren't mine\n\nYou are free to...\n\n- Use this code however you want (as long as it complies with this license)\n  - e.g. personal and commercial projects\n  - Especially open-source projects\n\nAs long as...\n\n- You use it ethically\n  - e.g. no using it for NFT's, which are unsustainable and stupid\n- You keep comments in the source that credit and link to snippets of code that aren't mine\n  - e.g. Comments such as \"PCG Random: https://www.pcg-random.org/\"\n  - Of course, you must also respect whatever licenses they use\n\nRemember, we are programmers, not lawyers! :)\n*/\n\n// Check out some of my friends!\n// Dumb_Psycho\n// https://www.shadertoy.com/user/Dumb_Psycho\n// loicvdb\n// https://www.shadertoy.com/user/loicvdb\n// michael0884\n// https://www.shadertoy.com/user/michael0884\n// peabrainiac\n// https://www.shadertoy.com/user/peabrainiac\n// skythedragon\n// https://www.shadertoy.com/user/skythedragon\n\n// We have a Discord Server focused on STEM and Memes, DM me (@Zi7ar21#2168) if you're interested.\n\n// Render Preview\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get the Image Export Buffer\n    vec3 color = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n\n    // HDR Tonemapping\n    color = tonemap(color);\n\n    // Output the Image Preview\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ##### Preprocessor #####\n\n/*\n#if __VERSION__ < 300\n#error This shader requires GLSL 300 ES to run!\n#endif\n*/\n\n/*\n#pragma debug(off)\n#pragma optimize(on)\n*/\n\n/*\n#pragma debug(on)\n#pragma optimize(off)\n*/\n\n// ##### Parameters #####\n\n// Camera Field of View\n#define CAMERA_FOV 1.0\n\n// Tonemap Exposure\n#define EXPOSURE 1.0\n\n// Enable sRGB gamma thingy\n#define sRGB_transfer\n\n// Enable Monte-Carlo Bloom\n#define BLOOM\n\n// Radius of the Black Hole\n#define blackhole_radius 0.6\n\n// Timestep (smaller = slower)\n#define delta_t 0.05\n\n// Maximum number of times a light path can bounce before getting yeeted\n#define MAX_BOUNCES 4u\n\n// Use Gradient Noise instead of Value Noise (slower, should look nicer)\n//#define USE_GRADIENT_NOISE\n\n//\n#define MAX_DIST 4.0\n\n// Maximum steps a light path can take before getting yeeted\n#define MAX_STEPS 16384u\n\n// Camera Sensor Size (for DoF, unused by default, uncomment it in Buffer A)\n//#define sensorSize 0.035\n\n// ##### Constants #####\n\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\nconst float pi     = 3.141592653589793; // Pi\nconst float two_pi = 6.283185307179586; // 2 * Pi\nconst float inv_pi = 0.318309886183790; // 1 / Pi\n\n// ##### Maths #####\n\n// Rotate a 2-Component Vector\nvec2 rotate(vec2 vector, float theta)\n{\n    float s = sin(theta), c = cos(theta);\n    return vec2(vector.x * c - vector.y * s, vector.x * s + vector.y * c);\n}\n\n// Dot Product\n// for optimizations involving comparing length, for example:\n// min(length(vector0), length(vector1))\n// This can be simplified and save using an extra sqrt() by changing it to:\n// sqrt(min(dotp(vector0), dotp(vector1)))\n\nfloat dot_p(vec2 vector) { return dot(vector, vector); }\nfloat dot_p(vec3 vector) { return dot(vector, vector); }\nfloat dot_p(vec4 vector) { return dot(vector, vector); }\n\n// ##### Color Management #####\n\n// Sh*tty HDR Tonemap(tm)\nvec3 tonemap(vec3 color)\n{\n    color = smoothstep( 0.0, 1.0, 1.0 - exp(-color * EXPOSURE) );\n\n    #ifdef sRGB_transfer\n    // sRGB Color Component Transfer: https://www.color.org/chardata/rgb/sRGB.pdf\n    color  = vec3(\n    color.r > 0.0031308 ? (pow(color.r, 1.0 / 2.4) * 1.055) - 0.055 : color.r * 12.92,\n    color.g > 0.0031308 ? (pow(color.g, 1.0 / 2.4) * 1.055) - 0.055 : color.g * 12.92,\n    color.b > 0.0031308 ? (pow(color.b, 1.0 / 2.4) * 1.055) - 0.055 : color.b * 12.92);\n    #endif\n\n    return clamp(color, 0.0, 1.0);\n}\n\n/*\n// https://www.color.org/chardata/rgb/sRGB.pdf\nconst mat3 XYZ2sRGB = mat3(\n 3.2406255, -1.5372080, -0.4986286,\n-0.9689307,  1.8757561,  0.0415175,\n 0.0557101, -0.2040211,  1.0569959);\n*/\n/*\n// https://www.shadertoy.com/view/4s3cRr\nconst mat3 XYZ2sRGB = mat3(\n 3.2404542, -1.5371385, -0.4985314,\n-0.9692660,  1.8760108,  0.0415560,\n 0.0556434, -0.2040259,  1.0572252);\n*/\n/*\n// https://www.shadertoy.com/view/tsKczy\nconst mat3 XYZ2sRGB = mat3(\n 3.2409699419, -1.5373831776, -0.4986107603,\n-0.9692436363,  1.8759675015,  0.0415550574,\n 0.0556300797, -0.2039769589,  1.0569715142);\n*/\n\n// Every XYZ to sRGB matrix I find is slightly different, so here is my own:\nconst mat3 XYZ2sRGB = mat3(\n 3.240, -1.537, -0.499,\n-0.969,  1.876,  0.042,\n 0.056, -0.204,  1.057);\n\n// Convert XYZ to sRGB\nvec3 xyz2rgb(vec3 color_xyz)\n{\n    // I can't remember the order of GLSL matrix multiplication,\n    // so this function exists instead of doing it every time\n    return color_xyz * XYZ2sRGB;\n}\n\n// Convert sRGB to XYZ\nvec3 rgb2xyz(vec3 color_rgb)\n{\n    return color_rgb * transpose(XYZ2sRGB);\n}\n\n// idk what to cite, here are some shaders that all use this\n// https://www.shadertoy.com/view/tsKczy\n// https://www.shadertoy.com/view/MslSDl\n// https://www.shadertoy.com/view/MttyzB\nvec3 blackbodyXYZ(float t)\n{\n    // https://en.wikipedia.org/wiki/Planckian_locus\n    float u = (0.860117757 + 1.54118254E-4 * t + 1.28641212E-7 * t * t) / (1.0 + 8.42420235E-4 * t + 7.08145163E-7 * t * t);\n    float v = (0.317398726 + 4.22806245E-5 * t + 4.20481691E-8 * t * t) / (1.0 - 2.89741816E-5 * t + 1.61456053E-7 * t * t);\n\n    // https://en.wikipedia.org/wiki/CIE_1960_color_space\n    // https://en.wikipedia.org/wiki/XYZ_color_space\n\n    // Hippitty Hoppity through magic convert the planckian locus to some weird Color space linked to XYZ\n    vec2 xyy = vec2(3.0 * u, 2.0 * v) / (2.0 * u - 8.0 * v + 4.0);\n\n    // And then convert from the shart color space to XYZ\n    return vec3(xyy.x / xyy.y, 1.0, (1.0 - xyy.x - xyy.y) / xyy.y);\n}\n\n// ##### Random Number Generator #####\n\n// Triple32 Hash: https://nullprogram.com/blog/2018/07/31/\nuint triple32(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xED5AD4BBu;\n    x ^= x >> 11u;\n    x *= 0xAC4C1B51u;\n    x ^= x >> 15u;\n    x *= 0x31848BABu;\n    x ^= x >> 14u;\n    return x;\n}\n\n// Random Number Generator Seed\nuint ns;\n\n// Uniform Random Value Between 0.0 and 1.0\nfloat rand()\n{\n    // Update RNG\n    ns = triple32(ns);\n\n    return float(ns) / float(0xFFFFFFFFu);\n}\n\n// 2-Component Uniform Random Vector\nvec2 rand2()\n{\n    vec2 vector;\n    vector.x = rand();\n    vector.y = rand();\n    return vector;\n}\n\n// 3-Component Uniform Random Vector\nvec3 rand3()\n{\n    vec3 vector;\n    vector.x = rand();\n    vector.y = rand();\n    vector.z = rand();\n    return vector;\n}\n\n// 4-Component Uniform Random Vector\nvec4 rand4()\n{\n    vec4 vector;\n    vector.x = rand();\n    vector.y = rand();\n    vector.z = rand();\n    vector.w = rand();\n    return vector;\n}\n\n// Uniformly distributied random point on a unit circle\nvec2 udir2()\n{\n    float z = rand();\n    float r = two_pi * z;\n    float s = sin(r), c = cos(r);\n    return vec2(s, c);\n}\n\n// Uniformly distributed random point on the surface of a unit sphere\nvec3 udir3()\n{\n    vec2 z = rand2();\n    vec2 r = vec2( two_pi * z.x, acos(2.0 * z.y - 1.0) );\n    vec2 s = sin(r), c = cos(r);\n    return vec3(c.x * s.y, s.x * s.y, c.y);\n}\n\n// See michael0884's usage of PCG Random\n// https://www.shadertoy.com/view/wltcRS\n// https://www.shadertoy.com/view/WttyWX\n\n// 2D Gaussian Distribution\nvec2 nrand2(vec2 mean, float sigma)\n{\n    vec2 z = rand2();\n    return mean + sigma * sqrt( -2.0 * log(z.x   ) ) * vec2(cos(two_pi * z.y), sin(two_pi * z.y) );\n}\n\n// 3D Gaussian Distribution\nvec3 nrand3(vec3 mean, float sigma)\n{\n    vec4 z = rand4();\n    return mean + sigma * sqrt( -2.0 * log(z.xxy ) ) * vec3(cos(two_pi * z.z), sin(two_pi * z.z), cos(two_pi * z.w) );\n}\n\n// 4D Gaussian Distribution\nvec4 nrand4(vec4 mean, float sigma)\n{\n    vec4 z = rand4();\n    return mean + sigma * sqrt( -2.0 * log(z.xxyy) ) * vec4(cos(two_pi * z.z), sin(two_pi * z.z), cos(two_pi * z.w), sin(two_pi * z.w) );\n}\n\n// ##### Misc #####\n\n// Blackman-Harris Pixel Filter\nvec2 pixel_filter(vec2 pixel_coord)\n{\n    // Gaussian Pixel Filter\n    //return nrand2(pixel_coord, 0.5);\n\n    // https://www.desmos.com/calculator/fcdor4uxyt\n    float r = pow(2.0 * acos(1.0 - rand()) / pi, 0.78539821704);\n    return pixel_coord + rand() * udir2();\n\n    // https://en.wikipedia.org/wiki/Window_function#Blackman–Harris_window\n    // w[n] = a0-a1*cos(2*pi*n/N)+a2*cos(4*pi*n/N)-a3*cos(6*pi*n/N)\n    // a0 = 0.35875; a1 = 0.48829; a2 = 0.14128; a3 = 0.01168\n    float n = 0.5 * rand() + 0.5;\n    float w = 0.35875 - 0.48829 * cos(2.0 * pi * n) + 0.14128 * cos(4.0 * pi * n) - 0.01168 * cos(6.0 * pi * n);\n    return pixel_coord + (udir2() * 2.0 * w);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ##### Rendering #####\n\n// https://www.shadertoy.com/view/4djSRW\nvec4 hash44(vec4 p4)\n{\n    p4  = fract( p4 * vec4(0.1031, 0.1030, 0.0973, 0.1099) );\n    p4 += dot(p4, p4.wzxy + 33.33);\n    return fract( (p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nfloat noise(vec3 p, int octave)\n{\n    #ifdef USE_GRADIENT_NOISE\n    // Inigo Quilez Gradient Noise\n    // https://www.shadertoy.com/view/Xsl3Dl\n\n    vec3 f = fract(p);\n    vec3 i = floor(p);\n\n    vec3 s = smoothstep(0.0, 1.0, f);\n\n    vec3 h0 = hash44( vec4(i + vec3(0, 0, 0), octave) ).xyz;\n    vec3 h1 = hash44( vec4(i + vec3(1, 0, 0), octave) ).xyz;\n    vec3 h2 = hash44( vec4(i + vec3(0, 1, 0), octave) ).xyz;\n    vec3 h3 = hash44( vec4(i + vec3(1, 1, 0), octave) ).xyz;\n    vec3 h4 = hash44( vec4(i + vec3(0, 0, 1), octave) ).xyz;\n    vec3 h5 = hash44( vec4(i + vec3(1, 0, 1), octave) ).xyz;\n    vec3 h6 = hash44( vec4(i + vec3(0, 1, 1), octave) ).xyz;\n    vec3 h7 = hash44( vec4(i + vec3(1, 1, 1), octave) ).xyz;\n\n    float v0 = dot( h0, f - vec3(0, 0, 0) );\n    float v1 = dot( h1, f - vec3(1, 0, 0) );\n    float v2 = dot( h2, f - vec3(0, 1, 0) );\n    float v3 = dot( h3, f - vec3(1, 1, 0) );\n    float v4 = dot( h4, f - vec3(0, 0, 1) );\n    float v5 = dot( h5, f - vec3(1, 0, 1) );\n    float v6 = dot( h6, f - vec3(0, 1, 1) );\n    float v7 = dot( h7, f - vec3(1, 1, 1) );\n\n    return smoothstep(-0.5, 0.5, mix(\n    mix(mix(v0, v1, s.x), mix(v2, v3, s.x), s.y),\n    mix(mix(v4, v5, s.x), mix(v6, v7, s.x), f.y),\n    s.z)\n    );\n    #else\n    \n    vec3 f = fract(p);\n    vec3 i = floor(p);\n\n    vec3 s = smoothstep(0.0, 1.0, f);\n\n    float t0 = hash44( vec4(i + vec3(0, 0, 0), octave) ).x;\n    float t1 = hash44( vec4(i + vec3(1, 0, 0), octave) ).x;\n    float t2 = hash44( vec4(i + vec3(0, 1, 0), octave) ).x;\n    float t3 = hash44( vec4(i + vec3(1, 1, 0), octave) ).x;\n    float t4 = hash44( vec4(i + vec3(0, 0, 1), octave) ).x;\n    float t5 = hash44( vec4(i + vec3(1, 0, 1), octave) ).x;\n    float t6 = hash44( vec4(i + vec3(0, 1, 1), octave) ).x;\n    float t7 = hash44( vec4(i + vec3(1, 1, 1), octave) ).x;\n\n    return mix(\n    mix(mix(t0, t1, s.x), mix(t2, t3, s.x), s.y),\n    mix(mix(t4, t5, s.x), mix(t6, t7, s.x), f.y),\n    s.z);\n    #endif\n}\n\n// Fractal Brownian Motion\nfloat fbm(vec3 p, int iter)\n{\n    float value = 0.0;\n    float accum = 0.0;\n    float atten = 0.5;\n    float scale = 1.0;\n\n    for(int i = 0; i < iter; i++)\n    {\n        value += atten * noise(scale * p, iter);\n        accum += atten;\n        atten *= 0.5;\n        scale *= 2.5;\n    }\n\n    return accum != 0.0 ? value / accum : value;\n}\n\n// Basically copied and pasted from michael0884\n// https://rantonels.github.io/starless/\nvec3 gravitational_field(vec3 p)\n{\n    /*\n    vec3 r = p / blackhole_radius;\n    float R = length(r);\n    return -4.0 * 1.5 * r / pow(R, 5.0);\n    */\n\n    vec3 r = p / blackhole_radius;\n    float R = length(r);\n    return -6.0 * r / (R * R * R * R * R); // get rid of that nasty pow() calculation\n}\n\n// crappy redshift/blueshift approximation\nvec3 shift_color(vec3 color, float t) // color (rgb), wavelength (nm) \n{\n    /*\n    float k0 = smoothstep(0.0, 1.0,  t);\n    float k1 = smoothstep(0.0, 1.0, -t);\n \n    if(t > 0.0)\n    {\n        color = vec3(\n        mix(color.r, 0.0    , k0),\n        mix(color.g, color.r, k0),\n        mix(color.b, color.g, k0)\n        );\n    }\n    else\n    {\n        color = vec3(\n        mix(color.r, color.g, k1),\n        mix(color.g, color.b, k1),\n        mix(color.b, 0.0    , k1)\n        );\n    }\n\n    return color;\n    */\n\n    // convert rgb to xyz\n    color = rgb2xyz(color);\n\n    // shift approx\n    //color = ;\n\n    // convert xyz to rgb\n    color = xyz2rgb(color);\n\n    return color;\n}\n\nfloat sample_volume(in vec3 p, out vec3 c, out vec3 e)\n{\n    c = vec3(0.3, 0.2, 0.1);\n    e = vec3(0);\n\n    //if(dot_p(p.xz) > 8.0 || abs(p.y)  > 0.33)\n    if(dot_p(p.xz) > 8.0 || p.y * p.y > 0.3 * 0.3) // I think this might be slightly faster, doesn't matter\n    {\n        return 0.0;\n    }\n\n    float n0 = fbm(20.0 * vec3(rotate( p.xz, (8.0 * p.y) + ( 4.0 * length(p.xz) ) ), p.y).xzy, 8);\n\n    float d_falloff = length(vec3(0.12, 7.50, 0.12) * p);\n    float e_falloff = length(vec3(0.20, 8.00, 0.20) * p);\n\n    float t = rand();\n    e = xyz2rgb( blackbodyXYZ( (4000.0 * t * t) + 2000.0 ) );\n    e = clamp(e / max(max(max(e.r, e.g), e.b), 0.01), 0.0, 1.0);\n\n    //e *= 128.0 * max(n0 - e_falloff, 0.0) / (pow(dot_p(0.5 * p), 1.5) + 0.05);\n    e *= 128.0 * max(n0 - e_falloff, 0.0) / (dot_p(0.5 * p) + 0.05);\n\n    return 128.0 * max(n0 - d_falloff, 0.0);\n}\n\nvec3 sky_radiance(vec3 dir)\n{\n    return vec3(0);\n}\n\nvec3 radiance(vec3 ro, vec3 rd)\n{\n    vec3 att = vec3(1); // Light Attenuation\n    vec3 r   = vec3(0); // Emission\n\n    vec3 p = ro + (rand() * delta_t * rd);\n    vec3 v = rd;\n\n    uint bounces = 0u;\n\n    for(uint i = 0u; i < MAX_STEPS; i++)\n    {\n        if(bounces > MAX_BOUNCES) // light path bounced too many times, discard the sample\n        {\n            break;\n        }\n\n        if(dot_p(p) < blackhole_radius * blackhole_radius) // light fell into the black hole\n        {\n            return r;\n        }\n\n        if(dot_p(p) > 3.6 * 3.6) // light escaped the scene\n        {\n            r += att * sky_radiance( normalize(v) );\n            return r;\n        }\n\n        vec3 volume_color   ;\n        vec3 volume_emission;\n\n        float d = sample_volume(p, volume_color, volume_emission);\n\n        r += att * volume_emission * delta_t; // add emission\n\n        if(d > 0.0)\n        {\n            float absorbance = exp(-1.0 * delta_t * d);\n\n            if( absorbance < rand() ) // check if light decides to bounce\n            {\n                v = length(v) * reflect( normalize(v), udir3() );\n\n                att *= volume_color;\n\n                bounces++;\n            }\n        }\n\n        vec3 g = gravitational_field(p); // calculate gravitational influence on the light\n\n        v += g * delta_t; // update velocity\n        p += v * delta_t; // update position\n    }\n\n    //return vec3(0) ; // accumulate vec3(0)\n    return vec3(-1); // discards sample\n}\n\n/*\n// https://www.shadertoy.com/view/XtGBDW\n#define level 5u\n#define width (1u << level)\n#define area (width * width)\n\nuint hilbert_index(uvec2 p)\n{\n    uint index = 0u;\n\n    for(uint cur_level = width / 2u; cur_level > 0u; cur_level /= 2u)\n    {\n        uvec2 region = uvec2( greaterThan( ( p & uvec2(cur_level) ), uvec2(0u) ) );\n\n        index += cur_level * cur_level * ( (3u * region.x) ^ region.y );\n\n        if(region.y == 0u)\n        {\n            if(region.x == 1u)\n            {\n                p = uvec2(width - 1u) - p;\n            }\n\n            p.xy = p.yx;\n        }\n    }\n\n    return index;\n}\n\nvoid INIT_RNG()\n{\n    //ns = uint(iFrame) + 1u;\n    //ns = uint(iFrame) + uint(gl_FragCoord.x + gl_FragCoord.y * iResolution.x) + 1u;\n    ns = area * uint(iFrame) + hilbert_index( uvec2(gl_FragCoord.xy) ) + 1u;\n}\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Accumulation Buffer\n    fragColor = iFrame != 0 ? texelFetch(iChannel0, ivec2(fragCoord), 0) : vec4(0.0);\n\n    // Initialize the Random Number Generator\n    ns = uint(iFrame) * uint(iResolution.x * iResolution.y) + uint(fragCoord.x + fragCoord.y * iResolution.x);\n    //INIT_RNG();\n\n    // Screen UV Coordinates\n    vec2 uv = 2.0 * (pixel_filter(fragCoord) - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    // Bloom\n    #ifdef BLOOM\n    float r = rand();\n    if(r < 0.10)\n    {\n        uv = nrand2(uv, rand() * 0.015);\n    }\n    if(r > 0.90)\n    {\n        uv = nrand2(uv, rand() * 0.200);\n    }\n    #endif\n\n    mat3 rotmat = mat3(\n     0.8, -0.2, -0.0,\n     0.2,  0.8, -0.0,\n    -0.0, -0.0,  1.0);\n\n    // Normalize the Rotation Matrix\n    rotmat[0] = normalize(rotmat[0]);\n    rotmat[1] = normalize(rotmat[1]);\n    rotmat[2] = normalize(rotmat[2]);\n\n    /*\n    mat3 cam2world;\n\t{\n\t\tvec3 d = normalize(Target-Eye);\n\t\tvec3 r = normalize(cross(d, Up));\n\t\tvec3 u = cross(r, d);\n\t\tcam2world = mat3(r, u, d);\n\t}\n    */\n\n    vec3 ro = vec3(0.0, 0.2, 3.5);\n    vec3 rd = normalize(vec3(CAMERA_FOV * uv, -1.0) * rotmat);\n\n    // Render the Sample\n    vec3 color = radiance(ro, rd);\n\n    // Accumulate the Sample (reject if Inf or NaN)\n    fragColor += any( lessThan(color, vec3(0) ) ) || any( isinf(color) ) || any( isnan(color) ) ? vec4(0) : vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ##### Image Export #####\n// Shadertoy can export renders in the OpenEXR format!\n// Just press the little image icon buttom on the bottom right-hand side of the editor.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get the Progressive Rendering Buffer\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    // Compute and Output the Final Color\n    fragColor = vec4(texel.a != 0.0 ? texel.rgb / texel.a : texel.rgb, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}