{
    "Shader": {
        "info": {
            "date": "1684747755",
            "description": "My partial implementation of Disney's BSDF: it lacks SSS and anisotropy.",
            "flags": 32,
            "hasliked": 0,
            "id": "DdVSWV",
            "likes": 3,
            "name": "Disney BSDF - implementation",
            "published": 3,
            "tags": [
                "pathtracer",
                "disney",
                "bsdf"
            ],
            "usePreview": 0,
            "username": "PlathC",
            "viewed": 192
        },
        "renderpass": [
            {
                "code": "vec3 ACESFilm( vec3 x )\n{\n\tfloat a = 2.51f;\n\tfloat b = 0.03f;\n\tfloat c = 2.43f;\n\tfloat d = 0.59f;\n\tfloat e = 0.14f;\n\treturn clamp( ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e ), vec3( 0.f ), vec3( 1.f ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x == 0. && fragCoord.y == 0.)\n        return;\n        \n    vec4 data = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n    vec3 col = data.xyz;\n    if( data.w > 0.)\n        col /= data.w;\n    \n    fragColor = vec4(pow(col, vec3(1./2.2)), 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float SampleNb = 2.;\nconst int   BounceNb = 8;\n\nuvec4 seed;\n\nstruct DiskLight {\n    float height;\n    float radius;\n    vec3  strength;\n    uint  lightId;\n};\n\nDiskLight getLight(uint id) \n{\n   const DiskLight light = DiskLight(5., 2., 10. * vec3(1.000,1.000,1.000), 0u);\n   return light;\n}\n\nLightSample sampleLight(vec3 p) \n{\n    vec2 uv;\n    \n    float lightPdf;\n    DiskLight light = getLight(0u);\n    vec3  lightPos  = sampleDisk(light.height, light.radius, prng(seed).xy);\n    vec3  wi        = normalize(lightPos - p);\n    float pdf       = length2(lightPos - p) / max(1e-4, abs(dot(vec3(0., -1., 0.), -wi)) * getDiskArea(light.radius));\n                        \n    return LightSample(wi, light.strength, pdf);\n}\n\n//-- BSDF implementation\n// For all these functions, ro and rd are transformed s.t. n = (0., 0., 1.)\n\n//- Diffuse\nvec3 evalDisneyDiffuse(HitInfo hit, vec3 wo, vec3 wi)\n{\n    float alpha = max(1e-4, hit.material.roughness * hit.material.roughness);\n    \n    vec3  h   = normalize(wo + wi);\n    float wih = clamp(dot(wi, h), 0., 1.);\n    float won = clamp(abs(wo.z), 1e-4, 1.);\n    float win = clamp(abs(wi.z), 1e-4, 1.);\n    \n    float fd90 = 0.5 + 2. * alpha * wih * wih;\n    float f1   = 1. + (fd90 - 1.) * pow(1. - win, 5.);\n    float f2   = 1. + (fd90 - 1.) * pow(1. - won, 5.);\n    return hit.material.baseColor * OneOverPi * (1. - hit.material.metallic) * f1 * f2;\n}\n\nvec3 sampleDisneyDiffuse(HitInfo hit, vec3 wo, const vec2 u) \n{\n    vec3 wi = sampleCosine(u);\n    if (wo.z < 0.)\n        wi.z *= -1.;\n    return wi;\n}\n\nfloat getPDFDisneyDiffuse(HitInfo hit, vec3 wo, vec3 wi) \n{\n    return wo.z * wi.z > 0. ? abs(wi.z) * OneOverPi : 0.;\n}\n\n//- Specular\nfloat evalSpecularReflection(HitInfo hit, vec3 wo, vec3 wi) \n{\n    float roughness = max(1e-4, hit.material.roughness);\n    float alpha     = max(1e-4, roughness * roughness);\n    float alpha2    = max(1e-4, alpha * alpha);  \n\n    vec3  h   = normalize(wo + wi);\n    float hn  = clamp(abs(h.z),  1e-4, 1.);\n    float won = clamp(abs(wo.z), 1e-4, 1.);\n    float win = clamp(abs(wi.z), 1e-4, 1.);\n\n    float g = getSmithG2GGX(won, win, alpha2);\n    float d = getDGGX(hn, alpha2);\n\n    return g * d;\n}\n\nfloat getPDFSpecularReflection(HitInfo hit, vec3 wo, vec3 wi) \n{\n    float roughness = max(1e-4, hit.material.roughness);\n    float alpha     = max(1e-4, roughness * roughness);\n    float alpha2    = max(1e-4, alpha * alpha);  \n    \n\tvec3  h   = normalize(wo + wi);\n    float hn  = clamp(abs(h.z),   1e-4, 1.);\n    float won = clamp(abs(wo.z),  1e-4, 1.);\n    float win = clamp(abs(wi.z),  1e-4, 1.);\n    float wih = clamp(dot(wi, h), 1e-4, 1.);\n\n    float g1 = getSmithG1GGX(wih, alpha2);\n    float d  = getDGGX(hn, alpha2);\n    \n    // Pdf of the VNDF times the Jacobian of the reflection operator\n    return d * g1 * wih / max(1e-4, 4. * win * wih);\n}\n\nfloat getClearCoatRoughness(HitInfo hit) \n{\n    return 0.6 * (1. - hit.material.clearcoatGloss);\n}\n\nfloat evalClearCoat(HitInfo hit, vec3 wo, vec3 wi) \n{\n    float roughness = max(1e-4, getClearCoatRoughness(hit));\n    float alpha     = max(1e-4, roughness * roughness);\n    float alpha2    = max(1e-4, alpha * alpha);  \n\n    vec3  h   = normalize(wo + wi);\n    float hn  = clamp(abs(h.z),  1e-4, 1.);\n    float won = clamp(abs(wo.z), 1e-4, 1.);\n    float win = clamp(abs(wi.z), 1e-4, 1.);\n\n    float g = getSmithG2GGX(won, win, alpha2);\n    float d = getDGGX(hn, alpha2);\n\n    return hit.material.clearcoat * 0.25 * g * d;\n}\n\nfloat getPDFClearCoat(HitInfo hit, vec3 wo, vec3 wi) \n{\n    float roughness = max(1e-4, getClearCoatRoughness(hit));\n    float alpha     = max(1e-4, roughness * roughness);\n    float alpha2    = max(1e-4, alpha * alpha);  \n    \n\tvec3  h   = normalize(wo + wi);\n    float hn  = clamp(abs(h.z),   1e-4, 1.);\n    float won = clamp(abs(wo.z),  1e-4, 1.);\n    float win = clamp(abs(wi.z),  1e-4, 1.);\n    float wih = clamp(dot(wi, h), 1e-4, 1.);\n\n    float g1 = getSmithG1GGX(wih, alpha2);\n    float d  = getDGGX(hn, alpha2);\n    \n    // Pdf of the VNDF times the Jacobian of the reflection operator\n    return hit.material.clearcoat * 0.25 * d * g1 * wih / max(1e-4, 4. * win * wih);\n}\n\nfloat evalSpecularTransmission(HitInfo hit, vec3 wo, vec3 wi) \n{\n    float roughness = max(1e-4, hit.material.roughness);\n    float alpha     = max(1e-4, roughness * roughness);\n    float alpha2    = max(1e-4, alpha * alpha);  \n\n    float inside   = sign(wo.z);\n    bool  isInside = inside < 0.; \n\n    const float AirIOR = 1.f;\n    float etaI = isInside ? AirIOR : hit.material.ior;\n    float etaT = isInside ? hit.material.ior : AirIOR;\n\n    vec3  h   = normalize(-(etaI * wi + etaT * wo));\n    float hn  = clamp(abs(h.z),        1e-4, 1.);\n    float won = clamp(abs(wo.z),       1e-4, 1.);\n    float woh = clamp(abs(dot(wo, h)), 1e-4, 1.);\n    float win = clamp(abs(wi.z),       1e-4, 1.);\n    float wih = clamp(abs(dot(wi, h)), 1e-4, 1.);\n\n    float g2 = getSmithG1GGX(wih, alpha2) * getSmithG1GGX(woh, alpha2);\n    float d  = getDGGX(hn, alpha2);\n    float w  = wih * woh / max(1e-4, win * won);\n    float s  = etaI * wih + etaT * woh;\n    \n    return w * etaT*etaT * g2 * d / max(1e-4, s*s);\n}\n\nfloat getPDFSpecularTransmission(HitInfo hit, vec3 wo, vec3 wi) \n{\n    float roughness = max(1e-4, hit.material.roughness);\n    float alpha     = max(1e-4, roughness * roughness);\n    float alpha2    = max(1e-4, alpha * alpha);  \n    \n    float inside   = sign(wo.z);\n    bool  isInside = inside < 0.; \n\n    const float AirIOR = 1.f;\n    float etaI = isInside ? AirIOR : hit.material.ior;\n    float etaT = isInside ? hit.material.ior : AirIOR;\n\n    vec3  h   = normalize(-(etaI * wi + etaT * wo));\n    float hn  = clamp(abs(h.z),        1e-4, 1.);\n    float won = clamp(abs(wo.z),       1e-4, 1.);\n    float woh = clamp(abs(dot(wo, h)), 1e-4, 1.);\n    float win = clamp(abs(wi.z),       1e-4, 1.);\n    float wih = clamp(abs(dot(wi, h)), 1e-4, 1.);\n\n    float g1 = getSmithG1GGX(wih, alpha2);\n    float d  = getDGGX(hn, alpha2);\n    \n    float s                    = etaI * wih + etaT * woh;\n    float transmissionJacobian = etaT*etaT * woh / max(1e-4, s*s);\n    float vndf                 = g1 * wih * d    / win;\n    \n    return transmissionJacobian * vndf;\n}\n\n// Linear interpolation between Fresnel metallic and dielectric based on \n// material.metallic. \n// Found: https://schuttejoe.github.io/post/disneybsdf/\nvec3 getDisneyFresnel(HitInfo hit, vec3 wo, vec3 wi, vec3 h)\n{\n    float luminance = getLuminance(hit.material.baseColor);\n    vec3 tint       = luminance > 0. ? hit.material.baseColor * (1. / luminance) : vec3(1.);\n    \n    vec3 baseR0 = vec3(iorToReflectance(hit.material.ior));\n    vec3 r0     = mix(baseR0, tint, hit.material.specularTint);\n    r0          = mix(r0, hit.material.baseColor, hit.material.metallic);\n\n    float wih = clamp(abs(dot(wi, h)), 1e-4, 1.);\n    float woh = clamp(abs(dot(wo, h)), 1e-4, 1.);\n    \n    vec3 dielectricF = schlickFresnel(baseR0, woh);\n    vec3 metallicF   = schlickFresnel(r0, wih);\n    \n    return mix(dielectricF, metallicF, hit.material.metallic);\n}\n\nvec3 evalBSDF(HitInfo hit, vec3 wo, vec3 wi) \n{\n    float win       = clamp(abs(wi.z),       1e-4, 1.);\n    float won       = clamp(abs(wo.z),       1e-4, 1.);\n    bool  entering  = wi.z > 0.;\n    bool  doReflect = wi.z * wo.z > 0.f;\n    \n    vec3 weight = vec3(1.);\n    if (!entering && hit.material.specularTransmission > 0.f)\n        weight *= exp(log(hit.material.transmittance) * abs(hit.t) / hit.material.atDistance);\n\n    const float AirIOR = 1.f;\n    float etaI = entering ? hit.material.ior : AirIOR;\n    float etaT = entering ? AirIOR : hit.material.ior;\n\n    if( doReflect )\n    {\n        vec3 h = normalize(wi + wo);\n        vec3 f = getDisneyFresnel(hit, wi, wo, h);\n\n        float roughness = max(1e-4, hit.material.roughness);\n        float alpha     = max(1e-4, roughness * roughness);\n        float alpha2    = max(1e-4, alpha * alpha);\n\n        float nh  = clamp(abs(h.z),        1e-4, 1.);\n        float lh  = clamp(abs(dot(wi, h)), 1e-4, 1.);\n\n        float diffuseWeight = 1. - hit.material.specularTransmission;\n        vec3  diffuse       = diffuseWeight * evalDisneyDiffuse(hit, wo, wi);\n        float specular      = evalSpecularReflection(hit, wo, wi);\n        \n        float woh = clamp(abs(dot(wo, h)), 1e-4, 1.);\n        float ccf = schlickFresnel(vec3(iorToReflectance(1.5)), woh).x;\n\n        return weight * ((1. - f) * diffuse + f * specular + ccf * evalClearCoat(hit, wo, wi));\n    }\n    else \n    {\n        vec3 h = normalize(-(etaI * wi + etaT * wo));\n        vec3 f = getDisneyFresnel(hit, wi, wo, h);\n\n        float transmissionWeight   = hit.material.specularTransmission;\n        float specularTransmission = transmissionWeight * evalSpecularTransmission(hit, wo, wi);\n        return weight * (sqrt(hit.material.baseColor) * (1. - f) * specularTransmission);\n    }\n}\n\nvec3 sampleBSDF(HitInfo hit, vec3 wo, out vec3 weight, out float pdf)\n{\n    float roughness = max(1e-4, hit.material.roughness);\n    float alpha     = max(1e-4, roughness * roughness);\n    float alpha2    = max(1e-4, alpha * alpha);\n    \n    float inside   = sign(wo.z);\n    bool  isInside = inside < 0.; \n\n    pdf    = 1.;\n    weight = vec3(1.);\n    if (isInside && hit.material.specularTransmission > 0.f)\n       weight *= exp(log(hit.material.transmittance) * abs(hit.t) / hit.material.atDistance);\n\n    vec4 u = prng(seed);\n    vec3 h = hit.normal;\n    \n    vec2 alea = prng(seed).xy;\n    if(hit.material.clearcoat > 0.) {\n        float ccRoughness = getClearCoatRoughness(hit);\n        float ccAlpha     = max(1e-4, ccRoughness * ccRoughness);\n        float ccAlpha2    = max(1e-4, ccAlpha * ccAlpha);\n\n        vec3 ccH = h;\n        if(ccRoughness > .0)\n            ccH = SampleVndf_GGX(u.xy, wo, vec2(ccAlpha));\n        \n        float woh = clamp(abs(dot(wo, ccH)), 1e-4, 1.);\n        float ccf = schlickFresnel(vec3(iorToReflectance(1.5)), woh).x;\n        if(alea.y < ccf) {\n            vec3  wi = reflect(-wo,ccH);\n\n            float hn  = clamp(abs(ccH.z),        1e-4, 1.);\n            float woh = clamp(abs(dot(wo, ccH)), 1e-4, 1.);\n            float wih = clamp(abs(dot(wi, ccH)), 1e-4, 1.);\n\n            float g1 = getSmithG1GGX(woh, ccAlpha2);\n            float g2 = getSmithG1GGX(wih, ccAlpha2) * g1;\n            weight  *= hit.material.clearcoat * g2 / max(1e-4, g1);\n            pdf     *= 1.;\n            return wi;\n        }\n    }\n    \n    if (roughness > 0.)\n        h = SampleVndf_GGX(u.xy, wo, vec2(alpha));\n\n    vec3 f = getDisneyFresnel(hit, wo, wo, h);\n\n    float specularWeight = length(f); \n    bool  fullSpecular   = roughness == 0. && hit.material.metallic == 1.;\n    float type           = fullSpecular ? 0. : prng(seed).x;\n    \n#define GROUND_TRUTH\n\n    if (type < specularWeight)\n    {\n        vec3  wi = reflect(-wo, h);\n\n#ifdef GROUND_TRUTH\n        float hn  = clamp(abs(h.z),        1e-4, 1.);\n        float woh = clamp(abs(dot(wo, h)), 1e-4, 1.);\n        float wih = clamp(abs(dot(wi, h)), 1e-4, 1.);\n\n        float g1 = getSmithG1GGX(woh, alpha2);\n        float g2 = getSmithG1GGX(wih, alpha2) * g1;\n        weight  *= sqrt(hit.material.baseColor) * g2 / max(1e-4, g1);\n        pdf     *= 1.;\n#else\n        weight *= f * evalSpecularReflection(hit, wo, wi) ;\n        pdf    *= getPDFSpecularReflection(hit, wo, wi);\n        pdf    *= fullSpecular ? 1. : specularWeight;\n#endif\n        return wi;\n    }\n   \n    float transmissionType           = type - specularWeight;\n    float specularTransmissionWeight = (1. - specularWeight) * hit.material.specularTransmission;\n    if(transmissionType < specularTransmissionWeight) \n    {\n        const float AirIOR = 1.f;\n        float etaI = isInside ? hit.material.ior : AirIOR;\n        float etaT = isInside ? AirIOR : hit.material.ior;\n        vec3 wi    = refract(-wo, h, etaI / etaT);\n\n        // surface absorption: we multiply the refraction result by the square root of the surface color,\n        // which, after both the entering and exiting scattering events are accounted for, produces the\n        // expected albedo.\n\n#ifdef GROUND_TRUTH\n        float woh = clamp(abs(dot(wo, h)), 1e-4, 1.);\n        float wih = clamp(abs(dot(wi, h)), 1e-4, 1.);\n\n        float g1 = getSmithG1GGX(wih, alpha2);\n        float g2 = getSmithG1GGX(woh, alpha2) * g1;\n        weight *= sqrt(hit.material.baseColor) * g2 / max(1e-4, g1 * abs(wo.z));\n        pdf = 1.;\n#else\n        weight *= sqrt(hit.material.baseColor) * hit.material.specularTransmission * evalSpecularTransmission(hit, wo, wi);\n        pdf    *= hit.material.specularTransmission * getPDFSpecularTransmission(hit, wo, wi);\n#endif\n#undef GROUND_TRUTH\n        return wi;\n    }\n    \n    vec3 wi = sampleDisneyDiffuse(hit, wo, prng(seed).xy);\n\n    weight = (1. - hit.material.specularTransmission) * (1. - f) * evalDisneyDiffuse(hit, wo, wi); \n    pdf    = (1. - hit.material.specularTransmission) * getPDFDisneyDiffuse(hit, wo, wi);\n\n    return wi;\n}\n\nfloat getPDFBSDF(HitInfo hit, vec3 wo, vec3 wi) \n{\n    float specular     = getPDFSpecularReflection(hit, wo, wi);\n    float transmission = hit.material.specularTransmission  * getPDFSpecularTransmission(hit, wo, wi);\n    float diffuse      = getPDFDisneyDiffuse(hit, wo, wi);\n    float clearcoat    = getPDFClearCoat(hit, wo, wi);\n\n    return (specular + transmission + diffuse + clearcoat) / 4.;\n}\n\n//-- Geometry acquisition\nHitInfo trace(vec3 ro, vec3 rd) \n{\n    HitInfo hit = defaultHitInfo();\n\n    const uint HashOffset = 15u;\n    const float NbSpheres = 7.;\n    const float r = .7;\n    for(float i = 0.; i < NbSpheres; i++)\n    {\n        for(float j = 0.; j < NbSpheres; j++) \n        {\n            vec3 c = vec3(i + .5 - NbSpheres/2., 0., j  + .5 - NbSpheres/2.) * r * 2.;\n            vec2 tt = iSphere(ro, rd, c, r);\n\n            float t = (tt.x < tt.y && tt.x >= 0.) ? tt.x : tt.y;\n            if(t > 0. && (t < hit.t || hit.t < 0.))\n            {\n                hit.t      = t;\n                hit.normal = ((ro + rd * t) - c) / r;\n                \n                uint hashOffset = HashOffset + uint(i * NbSpheres + j);\n                float hash = hash11(hashOffset);\n                \n                hit.material              = defaultMaterial();\n                hit.material.baseColor    = hash31(hashOffset);\n                hit.material.metallic     = step(.7, hash) * hash11(hashOffset - 2u);\n                hit.material.specularTint = hit.material.metallic * hash11(hashOffset - 4u);\n                hit.material.roughness    = hash11(hashOffset - 1u) * .5;\n                hit.material.ior          = 1.01 + 1.5 * hash;\n                \n                hit.material.specularTransmission = (1. - hit.material.metallic) * hash11(hashOffset - 2u);\n                hit.material.transmittance        = hash31(hashOffset - 4u);\n                hit.material.atDistance           = hash11(hashOffset - 5u) * 1.;\n                \n                hit.material.clearcoat      = hash11(hashOffset - 7u);\n                hit.material.clearcoatGloss = hash11(hashOffset - 8u);\n            }\n        }\n    }\n    \n    vec3 boxNormal;\n    vec2 tt = iBox(ro + vec3(0., r, 0.), rd, vec3(NbSpheres, 0.1, NbSpheres) * (r + .1), boxNormal);\n    float t = tt.x < tt.y && tt.x >= 0. ? tt.x : tt.y;\n    if(t > 0. && (t < hit.t || hit.t < 0.)) {\n        hit.t = t, hit.normal = boxNormal;\n        hit.material = defaultMaterial();\n        hit.material.baseColor = vec3(1.);\n        hit.material.roughness = .3;\n        hit.material.metallic  = .0;\n    }\n    \n    return hit;\n}\n\nvoid getCamera(vec2 fragCoord, vec2 jitter, out vec3 ro, out vec3 rd) {\n    vec2 uv = (fragCoord+(jitter * 2. - 1.)+.5-iResolution.xy*0.5)/iResolution.y;\n    uv.y = -uv.y;\n    \n    vec2 mouse = texelFetch(iChannel0, ivec2(0), 0).zw;\n    \n    ro           = vec3(max(1e-4, mouse.y) * 4e-2, 4., 0.);\n    vec3 forward = normalize( /* target */ - ro);\n    vec3 right   = normalize(cross(forward, vec3(0., 1., 0.)));\n    vec3 up      = normalize(cross(forward, right)); \n    \n    mat3 ruf = mat3(right, up, forward);\n    float a  = tan(Pi * .35);\n    rd       = ruf * normalize(vec3(uv, a));\n    \n    float xStep = mouse.x / iResolution.x;\n    vec4 q = quaternion(xStep * 2. * Pi, vec3(0., 1., 0.));\n    ro = multiply(q, ro), rd = multiply(q, rd);    \n}\n\nvec4 getBlueNoise(vec2 fragCoord, int frame) \n{\n    // Reference: https://www.shadertoy.com/view/tlySzR\n    ivec2 p = ivec2(fragCoord);\n    p = (p+frame*ivec2(113,127)) & 1023;\n    return texelFetch(iChannel2, p, 0);\n}\n\nvec3 render(vec2 fragCoord, int frame)\n{\n\tseed       = uvec4( fragCoord.x, fragCoord.y, frame, 0 );\n    vec2 noise = getBlueNoise(fragCoord, frame).xy;\n    \n    vec3 ro, rd;\n    getCamera(fragCoord, noise, ro, rd);\n    \n    // Light integration\n    vec3 throughput = vec3(1.);\n    vec3 finalColor = vec3(0.);\n    for(int b = 0; b < BounceNb; b++) \n    {\n        HitInfo hit = trace(ro, rd);\n        \n        if(hit.t < 0.) \n        {\n            finalColor += throughput * texture(iChannel1, rd).rgb;\n            break;\n        }\n        \n        vec3 position  = ro + rd * hit.t;\n        vec3 n         = hit.normal;\n        float inside   = sign(dot(n, -rd));\n        bool  isInside = inside < 0.; \n\n        vec3 pposition = offsetRay(position, hit.normal * inside);\n        vec4 transform = toLocalZ(hit.normal);\n        hit.normal     = vec3(0., 0., 1.);\n        vec3 woLocal   = normalize(multiply(transform, -rd));\n        vec3 direct    = vec3( 0. );\n\n        // Direct lighting\n        // Light sampling\n        {\n            LightSample lightSample = sampleLight(pposition);\n            \n            vec3  wiLocal  = normalize( multiply(transform, lightSample.wi) );\n            float cosTheta = wiLocal.z;\n            if( lightSample.pdf > 0. && cosTheta > 0. ) \n            {\n                if( trace(pposition, lightSample.wi).t < 0. ) \n                {\n                    vec3 brdf = evalBSDF(hit, woLocal, wiLocal) * cosTheta;\n                    \n                    float scatteringPdf = getPDFBSDF( hit, woLocal, wiLocal ); \n                    float weight\t\t= powerHeuristic( 1, lightSample.pdf, 1, scatteringPdf );\n\n                    direct += brdf * lightSample.intensity * weight / max(1e-4, lightSample.pdf);\n                }\n            }            \n        }\n        \n        // Sampling BRDF\n        {\n            float scatteringPdf = 0.;\n            vec3  brdf          = vec3(0.);\n            vec3  wiLocal       = sampleBSDF( hit, woLocal, brdf, scatteringPdf );\n            float cosTheta      = wiLocal.z;\n            if( scatteringPdf > 0. && cosTheta > 0. ) \n            {\n                vec3 wi = normalize(multiply(conjugate(transform), wiLocal));\n\n                if(trace(pposition, wi).t < 0.)\n                {\n                    DiskLight light = getLight(0u);\n                    float tt        = iDisk(pposition, wi, vec3(0., light.height, 0.), vec3(0., -1., 0.), light.radius);\n                    if(tt > 0.)\n                    {\n                        vec3  lightPos = pposition + wi * tt;\n                        float lightPdf = length2(lightPos - pposition) / max(1e-4, abs(dot(vec3(0., -1., 0.), -wi)) * getDiskArea(light.radius));\n\n                        float weight = powerHeuristic(1, scatteringPdf, 1, lightPdf);\n\n                        direct += brdf * cosTheta * light.strength * weight / max(1e-4, scatteringPdf);\n                    }\n                }\n            }\n        }\n        finalColor += throughput * direct;\n\n        float scatteringPdf = 0.;\n        vec3  weight        = vec3(0.);\n        vec3  wiLocal       = sampleBSDF(hit, woLocal, weight, scatteringPdf);\n                \n        float cosTheta = abs(woLocal.z);\n        throughput    *= weight * cosTheta / max(1e-4, scatteringPdf);\n\n        if(any(isinf(throughput)) || any(isnan(throughput)) )\n            return vec3(1., 0., 0.);\n    \n        float luminance = getLuminance(throughput);\n        if(luminance == 0.)\n            return vec3(0.);\n\n        // Russian Roulette\n        // Crash course in BRDF implementation\n        float rr = min(luminance, .95f);\n        // https://computergraphics.stackexchange.com/a/2325\n        // float rr = max(throughput.x, max(throughput.y, throughput.z));\n        if (getBlueNoise(fragCoord, frame * int(SampleNb) + b).x > rr)\n            break;\n            \n        throughput *= 1. / rr;\n\n        rd = normalize(multiply(conjugate(transform), wiLocal));\n        ro = offsetRay(position, n * sign(dot(n, rd)));\n    }\n\n    return finalColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 v = ivec2(fragCoord);\n    \n    vec4 lastData       = texelFetch(iChannel0, ivec2(0), 0);\n    vec2 lastResolution = lastData.xy;\n    vec2 lastMouse      = lastData.zw;\n    vec4 data = texture( iChannel0, fragCoord/iResolution.xy );\n    if( iFrame==0 ) data = vec4(0.0);\n\n    vec3 col = vec3(0.);\n    for (float i = 0.; i < SampleNb; i++) \n        col += render(fragCoord, int(data.w + i));\n    col /= SampleNb;\n        \n    if( length(lastResolution - iResolution.xy) > 0. || length(lastMouse - iMouse.xy) > 0. ) \n         data = vec4(col, 0.);\n     data = vec4(col, 1.) + (data.w > 0. ? data : vec4(0.));\n    \n    fragColor = data;\n    if(fragCoord.x < 1. && fragCoord.y < 1.)\n    {\n        fragColor.xy = iResolution.xy;\n        fragColor.zw = iMouse.xy;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float Pi        = 3.1415;\nconst float OneOverPi = 1. / Pi;\n\n//-- Math\nfloat length2(vec3 v) {return dot(v,v);}\n\nvec4 quaternion(float angle, vec3 axis)\n{\n    float halfAngle = angle / 2.;\n    return vec4(axis.x * sin(halfAngle), axis.y * sin(halfAngle), axis.z * sin(halfAngle), cos(halfAngle));\n}\n\n// Based on GLM implementation\nvec3 multiply(vec4 quat, vec3 p)\n{\n    vec3 quatVector = quat.xyz;\n    vec3 uv         = cross(quatVector, p);\n    vec3 uuv        = cross(quatVector, uv);\n\n    return p + ((uv * quat.w) + uuv) * 2.;\n}\n\nvec4 conjugate(vec4 quat) { return vec4(-quat.x, -quat.y, -quat.z, quat.w); }\n\n// Both n and ref must be normalized\nvec4 toLocal(vec3 n, vec3 ref)\n{\n    if (dot(n, ref) < -1.f + 1e-4f)\n        return vec4(1.f, 0.f, 0.f, 0.f);\n\n    float angle = 1.f + dot(n, ref); // sqrt(length2(n) * length2(ref)) + dot( input, up );\n    vec3  axis  = cross(n, ref);\n    return normalize(vec4(axis, angle));\n}\n\nvec4 toLocalZ(vec3 n) { return toLocal(n, vec3(0., 0., 1.)); }\n\nfloat getDiskArea(float radius) \n{\n    return Pi * radius * radius;\n}\n\nfloat iorToReflectance(float ior)\n{\n    return ((ior - 1.) * (ior - 1.)) / ((ior + 1.) * (ior + 1.));\n}\n\n// Ref: https://en.wikipedia.org/wiki/Relative_luminance\nfloat getLuminance(vec3 rgb)\n{\n    return rgb.x * 0.2126f + rgb.y * 0.7152f + rgb.z * 0.0722f;\n}\n\n//-- Sampling \n\n// Sampling Transformations Zoo\n// Peter Shirley, Samuli Laine, David Hart, Matt Pharr, Petrik Clarberg,\n// Eric Haines, Matthias Raab, and David Cline\n// NVIDIA\nvec3 sampleCosine(vec2 u)\n{\n    // 16.6.1 COSINE-WEIGHTED HEMISPHERE ORIENTED TO THE Z-AXIS\n    float a = sqrt(u.x);\n    float b = 2. * Pi * u.y;\n\n    return vec3(a * cos(b), a * sin(b), sqrt(1.0f - u.x));\n}\n\n// Stratified Sampling of 2-Manifolds, Jim Arvo\n// SIGGRAPH Course Notes 2001\n// Found: https://twitter.com/keenanisalive/status/1529490555893428226?s=20&t=mxRju6YioMmlMOJ1fDVBpw\nvec2 sampleCircle(vec2 u)\n{\n    float  r     = u.x;\n    float  theta = u.y * 2. * Pi;\n    return sqrt(r) * vec2(cos(theta), sin(theta));\n}\n\nvec3 sampleDisk(float height, float radius, vec2 u) \n{\n    vec2 pd   = sampleCircle(u);\n    return vec3(pd.x * radius, height, pd.y * radius);\n}\n\n// https://pbr-book.org/3ed-2018/Monte_Carlo_Integration/Importance_Sampling\nfloat powerHeuristic(int nf, float fPdf, int ng, float gPdf)\n{\n    float f = float(nf) * fPdf, g = float(ng) * gPdf;\n    return (f * f) / (f * f + g * g);\n}\n\n//-- Hashes\n\n// https://www.shadertoy.com/view/Xt3cDn\n// Modified from: iq's \"Integer Hash - III\" (https://www.shadertoy.com/view/4tXyWN)\nuint baseHash(uvec3 p)\n{\n    p = 1103515245U*((p.xyz >> 1U)^(p.yzx));\n    uint h32 = 1103515245U*((p.x^p.z)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\nuint baseHash(uint p)\n{\n    p = 1103515245U*((p >> 1U)^(p));\n    uint h32 = 1103515245U*((p)^(p>>3U));\n    return h32^(h32 >> 16);\n}\nvec3 hash31(uint x)\n{\n    uint n = baseHash(x);\n    uvec3 rz = uvec3(n, n*16807U, n*48271U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec3((rz >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\nfloat hash11(uint x)\n{\n    uint n = baseHash(x);\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\n// Reference: https://www.shadertoy.com/view/XlGcRh\n// Hash Functions for GPU Rendering. Mark Jarzynski, & Marc Olano (2020).\n// Journal of Computer Graphics Techniques (JCGT), 9(3), 20–38.\nuvec4 pcg4d(uvec4 v)\n{\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * v.w;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v.w += v.y * v.z;\n\n    v ^= v >> 16u;\n\n    v.x += v.y * v.w;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v.w += v.y * v.z;\n\n    return v;\n}\n\nvec4 prng(inout uvec4 p)\n{\n    p.w++;\n    return vec4(pcg4d(p)) * (1.0/float(0xffffffffu));\n}\n\n//-- Ray\nstruct Material\n{\n    vec3  baseColor;\n    float roughness;\n    float metallic;\n    float ior;\n    float specularTransmission;\n    float specularTint;\n    vec3  transmittance;\n    float atDistance;\n    float clearcoat;\n    float clearcoatGloss;\n\n    // TODO list\n    float anisotropic;\n};\n\nMaterial defaultMaterial() {\n    Material material;\n    material.baseColor            = vec3(1., 0., 1.);\n    material.metallic             = 1.;\n    material.ior                  = 1.52;\n    material.roughness            = 0.;\n    material.specularTransmission = 0.;\n    material.transmittance        = vec3(1.);\n    material.atDistance           = 1.;\n    material.specularTint         = 1.;\n    material.clearcoatGloss       = 0.;\n    material.clearcoat            = 0.;\n    \n\n    return material;\n}\n\nstruct HitInfo\n{\n    float    t;\n    vec3     normal;\n    Material material;\n};\n\nHitInfo defaultHitInfo() {\n    return HitInfo(-1., vec3(0.), defaultMaterial());\n}\n\nstruct LightSample {\n    vec3  wi;\n    vec3 intensity;\n    float pdf;\n};\n\n// A Fast and Robust Method for Avoiding Self-Intersection, Carsten Wächter and Nikolaus Binder, NVIDIA\n// Reference: https://github.com/Apress/ray-tracing-gems/blob/master/Ch_06_A_Fast_and_Robust_Method_for_Avoiding_Self-Intersection/offset_ray.cu\nvec3 offsetRay(vec3 p, vec3 n)\n{\n    const float origin      = 1.0f / 32.0f;\n    const float float_scale = 1.0f / 65536.0f;\n    const float int_scale   = 256.0f;\n\n    ivec3 of_i = ivec3(int_scale * n.x, int_scale * n.y, int_scale * n.z);\n\n    vec3 p_i = vec3(intBitsToFloat(floatBitsToInt(p.x) + ((p.x < 0.) ? -of_i.x : of_i.x)),\n                    intBitsToFloat(floatBitsToInt(p.y) + ((p.y < 0.) ? -of_i.y : of_i.y)),\n                    intBitsToFloat(floatBitsToInt(p.z) + ((p.z < 0.) ? -of_i.z : of_i.z)));\n\n    return vec3(abs(p.x) < origin ? p.x + float_scale * n.x : p_i.x,\n                abs(p.y) < origin ? p.y + float_scale * n.y : p_i.y,\n                abs(p.z) < origin ? p.z + float_scale * n.z : p_i.z);\n}\n\n// https://iquilezles.org/articles/intersectors/\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec3 c, float r )\n{\n    float d = length( c - ro );\n\tfloat a = 0.f;\n\tif ( d > r )\n\t\ta = d - r;\n\tro += rd * a;\n\n\tvec3 po = ro - c;\n\tfloat proj = dot(rd, po);\n\n\tfloat delta = proj * proj - (dot(po, po) - r * r);\n\tif ( delta < 0.f )\n        return vec2(-1.);\n    \n    float sqrd = sqrt( delta );\n    return vec2(-proj - sqrd, -proj + sqrd) + a;\n}\nfloat iDisk(in vec3 ro, in vec3 rd, vec3 c, vec3 n, float r ) {\n    vec3  o = ro - c;\n    float t = -dot(n,o)/dot(rd,n);\n    vec3  q = o + rd*t;\n    return (dot(q,q)<r*r) ? t : -1.0;\n}\nvec2 iBox( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = (tN>0.0) ? step(vec3(tN),t1) : // ro ouside the box\n                           step(t2,vec3(tF));  // ro inside the box\n    outNormal *= -sign(rd);\n    return vec2( tN, tF );\n}\n\n// Materials\n\nvec3 schlickFresnel(vec3 f0, float cosThetaD) \n{\n    return f0 + (1. - f0) * pow(1. - cosThetaD, 5.);\n}\n\n// Found: https://github.com/boksajak/brdf/blob/master/brdf.h#L710\nfloat getSmithG1GGX(float sn2, float alpha2) {\n\treturn 2. / (sqrt(((alpha2 * (1. - sn2)) + sn2) / sn2) + 1.);\n}\n\n// Moving Frostbite to Physically Based Rendering by Lagarde & de Rousiers\n// Found: https://github.com/boksajak/brdf/blob/master/brdf.h#L653\n// Includes specular BRDF denominator\nfloat getSmithG2GGX(float won, float win, float alpha2) \n{\n    float ggxv = win * sqrt(won * won * (1. - alpha2) + alpha2);\n    float ggxl = won * sqrt(win * win * (1. - alpha2) + alpha2);\n    \n    return 0.5 / (ggxv + ggxl);\n}\n\n// Found: https://github.com/boksajak/brdf/blob/master/brdf.h#L710\nfloat getDGGX(float hn, float alpha2) \n{\n    float b = ((alpha2 - 1.) * hn * hn + 1.);\n\treturn alpha2 / max(1e-4, Pi * b * b);\n}\n\n// Eric Heitz, A Simpler and Exact Sampling Routine for the GGX Distribution of Visible Normals, \n// Technical report 2017\nvec3 sampleGGXVNDF(vec3 V_, float alpha_x, float alpha_y, float U1, float U2)\n{\n    // stretch view\n    vec3 V = normalize(vec3(alpha_x * V_.x, alpha_y * V_.y, V_.z));\n    \n    // orthonormal basis\n    vec3 T1 = (V.z < 0.9999) ? normalize(cross(V, vec3(0,0,1))) : vec3(1,0,0);\n    vec3 T2 = cross(T1, V);\n    \n    // sample point with polar coordinates (r, phi)\n    float a = 1.0 / (1.0 + V.z);\n    float r = sqrt(U1);\n    float phi = (U2<a) ? U2/a * Pi : Pi + (U2-a)/(1.0-a) * Pi;\n    float P1 = r*cos(phi);\n    float P2 = r*sin(phi)*((U2<a) ? 1.0 : V.z);\n    \n    // compute normal\n    vec3 N = P1*T1 + P2*T2 + sqrt(max(0.0, 1.0 - P1*P1 - P2*P2))*V;\n    \n    // unstretch\n    N = normalize(vec3(alpha_x*N.x, alpha_y*N.y, max(0.0, N.z)));\n    return N;\n}\n\n// Sampling Visible GGX Normals with Spherical Caps, Dupuy & Benyoub\n// https://arxiv.org/pdf/2306.05044.pdf\n// Sampling the visible hemisphere as half vectors (our method)\nvec3 SampleVndf_Hemisphere(vec2 u, vec3 wi)\n{\n    // sample a spherical cap in (-wi.z, 1]\n    float phi = 2.0f * Pi * u.x;\n    float z = (1.0f - u.y) * (1.0f + wi.z) - wi.z;\n    float sinTheta = sqrt(clamp(1.0f - z * z, 0.0f, 1.0f));\n    float x = sinTheta * cos(phi);\n    float y = sinTheta * sin(phi);\n    vec3 c = vec3(x, y, z);\n    // compute halfway direction;\n    vec3 h = c + wi;\n    // return without normalization (as this is done later)\n    return h;\n}\n\n#if 0\nvec3 SampleVndf_GGX(vec2 u, vec3 wi, vec2 alpha)\n{\n    // warp to the hemisphere configuration\n    vec3 wiStd = normalize(vec3(wi.xy * alpha, wi.z));\n    // sample the hemisphere (see implementation 2 or 3)\n    vec3 wmStd = SampleVndf_Hemisphere(u, wiStd);\n    // warp back to the ellipsoid configuration\n    vec3 wm = normalize(vec3(wmStd.xy * alpha, wi.z));\n    // return final normal\n    return wm;\n}\n#else \nvec3 SampleVndf_GGX(vec2 u, vec3 wi, vec2 alpha){\n    return sampleGGXVNDF(wi, alpha.x, alpha.y, u.x, u.y);\n}\n#endif ",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}