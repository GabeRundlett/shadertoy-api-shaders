{
    "Shader": {
        "info": {
            "date": "1507105426",
            "description": "A simple function of x approaching 1 asymptotically. Many ways to do this, but I've found this one really intuitive to control.\nThe function will reach 0.5 at x = pivot and 0.9 at x = 9 * pivot. These mnemonics give an easy reference to how it behaves.",
            "flags": 0,
            "hasliked": 0,
            "id": "XtSyRz",
            "likes": 4,
            "name": "Controllable asymptotic ramp",
            "published": 3,
            "tags": [
                "graph",
                "function",
                "asymptotic"
            ],
            "usePreview": 0,
            "username": "grinist",
            "viewed": 611
        },
        "renderpass": [
            {
                "code": "// I've often found use for this kind of behavior. Mapping the [0,1] range with easing functions\n// has the problem that they will reach one and stay there. Logarithmic or root functions are expensive\n// and can be tricky to control or figure out in your head.\n// I've found this one really simple: using a 1/x curve. It doesn't very well reflect\n// natural conditions (like fog, light or sound attenuation etc.), but in most cases you can't\n// really tell.\n// To control it you give a half-way pivot value at which the function evaluates to 0.5.\n// Reference values:\n// 0.5 at x = pivot\n// 0.9 at x = pivot * 9\n// 0.99 at x = pivot * 99\n// 0.1 at x = pivot / 9\n\n// A simple function of x approaching 1 asymptotically.\n// Returns 0.5 at x = pivot\nfloat asymptoticRamp(float x, float pivot)\n{\n    pivot = max(0.001, pivot); \t// optional if you know your pivot\n    x = max(0.0, x);\t\t\t// optional if you know your x\n\treturn 1.0 - (pivot / (x + pivot));\n}\n\n\n// ----- The rest is just for demo\n\nvec2 xy;\t\t// current graph coords\nvec2 dxy; \t\t// pixel size in graph units\nvec4 fColor;\t// current fragment color\n\nvoid mixColor(vec4 color, float alpha)\n{\n    fColor = vec4(mix(fColor.rgb, color.rgb, alpha * color.a), 1.0);\n}\n\nvoid drawGrid(float stepSize, vec4 gridCol)\n{\n\tfloat mul = 1.0 / stepSize;\n\tvec2 g = abs(vec2(-0.5) + fract((xy + vec2(stepSize) * 0.5) * mul)); // g passes 0 at stepSize intervals\n\tg = vec2(1.0) - smoothstep(vec2(0.0), dxy * mul * 1.5, g);\n    mixColor(gridCol, max(g.x, g.y));\n}\n\nvoid drawCurve(float value, vec4 curveCol)\n{\n\t// Using y distance to curve, modifying distance threshold with approximated slope\n    // Derivative breaks with drastic changes of value and discontinuities, but so be it\n    float yDist = abs(value - xy.y);\n    float dValue = abs(dFdx(value));\n\tfloat c = 1.0 - smoothstep(0.0, (dxy.y + dValue) * 2.0, yDist);\n\tmixColor(curveCol, c);\n}\n\nvoid drawGradientRect(vec2 pos, vec2 size, float t, vec4 startCol, vec4 endCol)\n{\n\tvec4 gradientCol = mix(startCol, endCol, t);\n\tvec2 inside = step(pos, xy) * step(xy, pos + size);\n\tmixColor(gradientCol, inside.x * inside.y);\n}\n\nvoid drawCircle(vec2 pos, float radius, vec4 circleCol)\n{\n    float r = length(pos - xy);\n    float aar = length(dxy) * 0.707;\n    float c = 1.0 - smoothstep(radius - aar, radius + aar, r);\n    mixColor(circleCol, c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    float auto = 1.005 + sin(iTime) * 0.995;\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n    \n    // graph setup\n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec2 graphSize = vec2(aspect * 1.4, 1.4);\n\tvec2 graphPos = 0.5 - graphSize * vec2(0.3, 0.5);\n\n\txy = graphPos + uv * graphSize;\t// graph coords\n\tdxy = graphSize / iResolution.xy;\t// pixel size in graph units\n\n    // pivot value\n    float p = iMouse.z <= 0.0 ? auto : (graphPos.x + mouse.x * graphSize.x);\n    p = max(0.01, p);\n    \n    // background\n\tfColor = mix(vec4(1.0, 1.0, 1.0, 1.0), vec4(0.7, 0.7, 0.7, 1.0), pow(length(0.5 - uv) * 1.414, 3.5));\n    \n\t// grid\n    drawGrid(0.1, vec4(0.0, 0.0, 0.0, 0.2));\n\tdrawGrid(0.5, vec4(0.0, 0.0, 0.0, 0.3));\n\tdrawGrid(1.0, vec4(0.0, 0.0, 0.0, 0.4));\n\n    // curve\n    float value = asymptoticRamp(xy.x, p);\n    vec4 curveCol = vec4(0.91, 0.13, 0.23, 1.0);\n\n    drawCurve(value, curveCol);\n    drawGradientRect(vec2(graphPos.x, -0.2), vec2(graphSize.x, 0.1), value, vec4(0.0, 0.0, 0.0, 1.0), curveCol);\n\n    // pivot and reference points\n    drawCircle(vec2(p, asymptoticRamp(p, p)), 0.0125, curveCol);\n    drawCircle(vec2(p * 9.0, asymptoticRamp(p * 9.0, p)), 0.0125, vec4(curveCol.rgb, 0.5));\n    drawCircle(vec2(p / 9.0, asymptoticRamp(p / 9.0, p)), 0.0125, vec4(curveCol.rgb, 0.25));\n\n\tfragColor = fColor;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}