{
    "Shader": {
        "info": {
            "date": "1588924976",
            "description": "Draw a net of lines tangent to a conic section and passing through a \"baseline\" that follows the mouse (end  points to baseline shown). The lines nearest the pixel point are calculated completely looplessly.",
            "flags": 0,
            "hasliked": 0,
            "id": "WdsBzS",
            "likes": 9,
            "name": "Loopless Conic Envelope",
            "published": 3,
            "tags": [
                "envelope",
                "conic",
                "projective",
                "loopless"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 420
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Loopless Conic Envelopes\n// Matthew Arcus, mla, 2020\n//\n// A demo of drawing envelopes of conic curves looplessly\n//\n////////////////////////////////////////////////////////////////////////////////\n\n\nconst float PI = 3.1415927;\nint AA = 2;\n\n// With homogeneous coordinates, (x,y,z) corresponds to the Euclidean\n// point (x/z,y/z), so (kx,ky,kz) represents the same point for any\n// k. z can be regarded as a \"scaling\" parameter, so (x,y,0)\n// represents a point infinitely far away (like a vanishing point in a\n// perspective drawing it can be regarded as a pure direction), in\n// fact, a point on the \"line at infinity\", equation z = 0.\n//\n// Lines also are represented as l = vec3(a,b,c) with point p being on line l\n// just when dot(l,p) = 0, again, multiples of (a,b,c) represent the\n// same line, so (a,b,c) represents the Euclidean line ax+by+c = 0.\n//\n// If l1 and l2 are lines, join(l1,l2) is their intersection, and if p1,p2 are\n// points, then join(p1,p2) is the line between them. join is just\n// cross product:\n\nvec3 join(vec3 p, vec3 q) {\n  return cross(p,q);\n}\n\n// Actually drawing a point or a line or a conic involves Euclidean notions of\n// scale and distance, so we need to convert to Euclidean points (or do something\n// equivalent), so to draw a point, we need the distance between the pixel point\n// and the point being drawn (we can look on this as mapping both points to the\n// z=1 plane and measuring distances there):\n\nfloat point(vec3 p, vec3 q) {\n  return distance(p.xy/p.z,q.xy/q.z);\n}\n\n// We can short circuit the calculations a little:\n// If p = (x,y,z) and l = (a,b,c) then (x/z,y/z) is the Euclidean point\n// and if |(a,b)| = 1, then the distance to the line is ax+by+c:\nfloat line(vec3 p, vec3 l) {\n  return abs(dot(p,l)/(p.z*length(l.xy)));\n}\n\n// For a line given by two points, just join the points into a line:\nfloat line(vec3 p, vec3 q, vec3 r) {\n  return line(p,join(q,r));\n}\n\n// A conic curve is represented by a 3x3 symmetric matrix A and p is on the\n// conic just when dot(p,A*p) = dot(p*A,p) = 0. Lines tangent to the conic then\n// satisfy dot(l,inverse(A)*l) = dot(l*inverse(A),l) = 0 (points and lines\n// are dual).\n//\n// For simple conics where the matrix is diagonal, we can just use a\n// a vector to represent the conic, the code is much the same:\n//\n// To turn the conic equation into a distance function, we need to\n// divide by the magnitude of the gradient, and the gradient at p is\n// just 2.0*A*p (analogous to dx^2/dx = 2x):\nfloat conic(vec3 p, mat3 A) {\n  float s = dot(p,A*p);\n  vec3 ds = 2.0*A*p; // Gradient\n  return abs(s/(p.z*length(ds.xy))); // Normalize for Euclidean distance\n}\n\n// Note, this is solving at^2 + 2bt + c = 0, so the discriminant is\n// b^2 - ac, not b^2 - 4ac.\nbool quadratic(float a, float b, float c, out float t1, out float t2) {\n  // Assumes we have checked for a == 0 or c == 0\n  float disc = b*b-a*c;\n  if (disc < 0.0) return false;\n  if (b >= 0.0) {\n    // Try to avoid rounding error.\n    t1 = -b-sqrt(disc);\n    t2 = c/t1; t1 /= a;\n  } else {\n    t2 = -b+sqrt(disc);\n    t1 = c/t2; t2 /= a;\n  }\n  return true;\n}\n\n// Find the intersections of the line through p0,p1 with the conic\n// defined by A by solving a quadratic equation.\n// (or dually, find the tangent lines to A through join of lines p0,p1).\nbool intersection(vec3 p0, vec3 p1, mat3 A, out vec3 q0, out vec3 q1) {\n  // Any line through p0, p1 is expressible as p0+t*p1,\n  // so solve (p0 + t*p1)A((p0 + t*p1) = 0 =>\n  // p0*A*p0 + 2*t*p0*A*p1 + t^2*p1*A*p1 = 0\n  // We have a quadratic equation:\n  float a = dot(p1,A*p1), b = dot(p0,A*p1), c = dot(p0,A*p0);\n  // a==0 or c==0 indicate p1 or p0 are actually on conic\n  if (a == 0.0) { q0 = q1 = p1; return true; }\n  if (c == 0.0) { q0 = q1 = p0; return true; }\n  float t1,t2;\n  if (!quadratic(a,b,c,t1,t2)) return false;\n  q0 = p0 + t1*p1;\n  q1 = p0 + t2*p1;\n  return true;\n  \n}\n\n// Find the tangents to a conic from the point z, since this involves\n// solving a quadratic equation, there may be no (real) solution, so\n// return a boolean to indicate success or otherwise.\nbool tangents(vec3 z, mat3 A, out vec3 tan1, out vec3 tan2) {\n  // Construct two lines through the point - assuming that z is not at\n  // infinity, l1 and l2 will be distinct.\n  vec3 l1 = join(z,vec3(1,0,0));\n  vec3 l2 = join(z,vec3(0,1,0));\n  return intersection(l1,l2,A,tan1,tan2);\n}\n\n// crossratio(infinity,p,q,r) = pr/pq\n// Assumes p,q,r are collinear.\n// -1 if p is midpoint of q and r\n// r = p + k(q-p) or r = (1-k)p + kq where k = ratio(p,q,r)\nfloat ratio(vec3 p, vec3 q, vec3 r) {\n  p /= p.z; q /= q.z; r /= r.z;\n  return dot(r-p,q-p)/dot(q-p,q-p);\n}\n\nvec3 getcolor(vec3 z, vec3 pointer) {\n  // This is just a plain unit circle, which seems very dull,\n  mat3 A = mat3(1,0,0,\n                0,1,0,\n                0,0,-1);\n  // until we rotate it in projective space, when it transitions\n  // to ellipse, parabola, hyperbola, then back to parabola,\n  // ellipse and circle.\n  float t = iTime;\n  mat3 rot = mat3(cos(t),0,sin(t),\n                  0,1,0,\n                  -sin(t),0,cos(t));\n  A = A*rot;\n\n  // We use the inverse of the conic matrix to find lines.\n  mat3 Ainv = inverse(A);\n\n  float dconic = conic(z,A); // The distance to the conic\n\n  // Draw the grid of tangent lines to the conic, with lines\n  // passing through a baseline:\n  vec3 base0 = vec3(-1,0,1);\n  vec3 base1 = pointer;\n  vec3 baseline = join(base0,base1);\n  vec3 tan1, tan2; // Put tangent solutions here\n  float ldist = dconic; // This will be minimum distance to a line,\n  float pdist = 1e8; // and the minimum distance to a point\n  pdist = min(pdist,point(z,2.0*base0-base1)); // Opposite baseline end\n  if (tangents(z,Ainv,tan1,tan2)) {\n    // Find where the tangents hit the baseline\n    vec3 z1 = join(tan1,baseline); \n    vec3 z2 = join(tan2,baseline);\n    float k1 = ratio(base0,base1,z1);\n    float k2 = ratio(base0,base1,z2); \n    float N = 16.0;\n    float t = 0.0;//0.1*iTime;\n    k1 = round(N*(k1+t))/N-t;\n    k2 = round(N*(k2+t))/N-t;\n    // If the rounded baseline point is in the right range (and the\n    // tangent from there is defined) then draw it. Since there will\n    // be two tangents from the baseline point, we need to make sure\n    // we use the right one - if baseline point and the pixel point\n    // are on the same side of the conic, then use the same quadratic\n    // root for both, otherwise use different roots. We find which\n    // side the points are with the ratio function.\n    //\n    // If line l is a tangent to the conic A, then the intersection\n    // point of the tangent is Ainv*l (and the tangent line at point\n    // p is A*p). A is symmetric, so A*p = p*A and Ainv*l = l*Ainv.\n    vec3 tan11,tan12;\n    if (abs(k1) <= 1.0 && tangents(base0+k1*(base1-base0),Ainv,tan11,tan12)) {\n      vec3 t1 = Ainv*tan1; // The point of tan1 on the conic\n      if (ratio(t1,z1,z) > 0.0) ldist = min(ldist,line(z,tan11));\n      else ldist = min(ldist,line(z,tan12));\n    }\n    vec3 tan21,tan22;\n    if (abs(k2) <= 1.0 && tangents(base0+k2*(base1-base0),Ainv,tan21,tan22)) {\n      vec3 t2 = Ainv*tan2; // The point of tan2 on the conic\n      if (ratio(t2,z2,z) > 0.0) ldist = min(ldist,line(z,tan22));\n      else ldist = min(ldist,line(z,tan21));\n    }\n  }\n  ldist = min(ldist,line(z,baseline));\n  pdist = min(pdist,point(z,pointer));\n  vec3 col = vec3(0.75+0.25*cos(20.0*dconic),1,1);\n  col *= smoothstep(0.01,max(fwidth(z.x),0.02),ldist);\n  col *= smoothstep(0.08,0.1,pdist);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec3 col = vec3(0);\n  float scale = 5.0;\n  vec2 pointer;\n  if (iMouse.x > 0.0) pointer = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  else pointer = cos(0.5*iTime-vec2(0,0.4*PI));\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 z = (2.0*(fragCoord+vec2(i,j)/float(AA))-iResolution.xy)/iResolution.y;\n      col += getcolor(vec3(scale*z,1),vec3(scale*pointer,1));\n    }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}