{
    "Shader": {
        "info": {
            "date": "1581525942",
            "description": "Felt like doing some character that I know. Thought Aang would be a\ngood fit. No hair... And the arrow would be fun to figure out.",
            "flags": 0,
            "hasliked": 0,
            "id": "wtcXRs",
            "likes": 13,
            "name": "AangHead",
            "published": 3,
            "tags": [
                "characteraang"
            ],
            "usePreview": 0,
            "username": "samhattangady",
            "viewed": 434
        },
        "renderpass": [
            {
                "code": "/*\nFelt like doing some character that I know. Thought Aang would be a\ngood fit. No hair... And the arrow would be fun to figure out.\n*/\nfloat PI = 3.14159;\nvec3 rotate3D(vec3 point, vec3 rotation) {\n    vec3 r = rotation;\n\tmat3 rz = mat3(cos(r.z), -sin(r.z), 0,\n                   sin(r.z),  cos(r.z), 0,\n                   0,         0,        1);\n    mat3 ry = mat3( cos(r.y), 0, sin(r.y),\n                    0       , 1, 0       ,\n                   -sin(r.y), 0, cos(r.y));\n    mat3 rx = mat3(1, 0       , 0        ,\n                   0, cos(r.x), -sin(r.x),\n                   0, sin(r.x),  cos(r.x));\n    return rx * ry * rz * point;\n}\nfloat sdfSphere(vec3 position, vec3 center, float radius) {\n    return distance(position, center) - radius;\n}\nfloat sdfEllipsoid(vec3 position, vec3 center, vec3 radii) {\n    position -= center;\n    float k0 = length(position/radii);\n    float k1 = length(position/(radii*radii));\n    return k0*(k0-1.0)/k1;\n}\nfloat sdfEllipsoidRotated(vec3 position, vec3 center, vec3 radii, vec3 rotation) {\n\tposition -= center;\n    position = rotate3D(position, rotation);\n    float k0 = length(position/radii);\n    float k1 = length(position/(radii*radii));\n    return k0*(k0-1.0)/k1;\n}\nfloat sdfPlane( vec3 position, vec4 n ) {\n    return dot(position, normalize(n.xyz)) + n.w;\n}\nfloat sdfRoundBoxRotated(vec3 position, vec3 center, vec3 box, vec3 rotation, float radius) {\n    position -= center;\n    position = rotate3D(position, rotation);\n    vec3 q = abs(position) - box;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - radius;\n}\nfloat dot2(vec2 v) {\n\treturn dot(v, v);\n}\nvec3 bendSpaceZ (vec3 position, float degree) {\n    //position = rotate3D(position, vec3(0.0, PI/2.0, 0.0));\n    float k = degree;\n    float c = cos(k*position.y);\n    float s = sin(k*position.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec2  q = m*position.xy;\n    return vec3(q, position.z);\n}\nvec4 sdfJoint3DSphere(vec3 position, vec3 start, vec3 rotation, float len, float angle, float thickness) {\n    vec3 p = position;\n    float l = len;\n    float a = angle;\n    float w = thickness;\n    p -= start;\n    p = rotate3D(p, rotation);\n\n    if( abs(a)<0.001 ) {\n        return vec4( length(p-vec3(0,clamp(p.y,0.0,l),0))-w, p );\n    }\n\n    vec2  sc = vec2(sin(a),cos(a));\n    float ra = 0.5*l/a;\n    p.x -= ra;\n    vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n    float u = abs(ra)-length(q);\n    float d2 = (q.y<0.0) ? dot2( q+vec2(ra,0.0) ) : u*u;\n    float s = sign(a);\n    return vec4( sqrt(d2+p.z*p.z)-w,\n               (p.y>0.0) ? s*u : s*sign(-p.x)*(q.x+ra),\n               (p.y>0.0) ? atan(s*p.y,-s*p.x)*ra : (s*p.x<0.0)?p.y:l-p.y,\n               p.z );\n}\nfloat smin(float d1, float d2, float k) {\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\nfloat smax(float d1, float d2, float k) {\n    float h = max(k-abs(d1-d2),0.0);\n    return max(d1, d2) + h*h*0.25/k;\n}\n\nvec2 aangHead(vec3 position) {\n\tvec3 symPosX = vec3(abs(position.x), position.yz);\n    float material = 1.0;\n    float d, d1, d2;\n\n    // Basic head sphere\n    d = sdfEllipsoid(position, vec3(0.0), vec3(0.4, 0.5, 0.5));\n    // basic jaw\n    d1 = sdfRoundBoxRotated(position, vec3(0.0, -0.3, -0.1), vec3(0.08, 0.2, 0.20),\n                            vec3(0.0), 0.2);\n    d2 = sdfRoundBoxRotated(position, vec3(0.0, -0.90, 0.1), vec3(0.5, 0.8, 0.3),\n                            vec3(PI/2.5, 0.0, 0.0), 0.0);\n    d1 = smax(d1, -d2, 0.3);\n    d2 = sdfRoundBoxRotated(symPosX, vec3(0.30, -0.56, -0.40), vec3(0.38, 0.45, 0.08),\n                            vec3(-0.6, -1.3, -0.2), 0.0);\n    //d1 = smin(d1, d2, 0.1);\n    d1 = smax(d1, -d2, 0.15);\n    d2 = sdfRoundBoxRotated(symPosX, vec3(0.35, -0.56, -0.50), vec3(0.58, 0.53, 0.18),\n                            vec3(-0.0, -1.1, -0.0), 0.0);\n    //d1 = smin(d1, d2, 0.1);\n    d1 = smax(d1, -d2, 0.1);\n    d = smin(d, d1, 0.1);\n    // sculpt head\n    d1 = sdfRoundBoxRotated(symPosX, vec3(0.51, 0.0, 0.0), vec3(0.07, 1.0, 1.0),\n                            vec3(0.0, 0.0, -0.1), 0.01);\n    d = smax(d, -d1, 0.1);\n    // ears\n    d1 = sdfEllipsoidRotated(symPosX, vec3(0.38, -0.15, 0.1), vec3(0.12, 0.15, 0.03),\n                             vec3(-0.3, -PI/9.9,- 0.3));\n    d2 = sdfSphere(symPosX, vec3(0.43, -0.15, 0.1), 0.001);\n    d1 = smax(d1, -d2, 0.1);\n    d = smin(d, d1, 0.01);\n\n    // eye sockets\n    d1 = sdfRoundBoxRotated(position, vec3(0.0, -0.04, -0.57), vec3(0.2, 0.1, 0.1),\n                            vec3(PI/4.0, 0.0, -0.0), 0.01);\n    d = smax(d, -d1, 0.2);\n    // nose\n    d1 = sdfRoundBoxRotated(position, vec3(0.0, -0.12, -0.45), vec3(0.005, 0.12, 0.05),\n                            vec3(0.7, 0.0, 0.0), 0.02);\n    d = smin(d, d1, 0.1);\n    d1 = sdfRoundBoxRotated(position, vec3(0.0, -0.22, -0.53), vec3(0.05, 0.005, 0.05),\n                            vec3(0.0, PI/4.0, 0.0), 0.0);\n    d = smin(d, d1, 0.1);\n    // mouth\n    d1 = sdfEllipsoid(vec3(symPosX.x, symPosX.y-4.9*pow(symPosX.x, 2.3), symPosX.z),\n                      vec3(0.0, -0.42, -0.5), vec3(0.15, 0.07, 0.6));\n    d = smax(d, -d1, 0.01);\n    d1 = sdfSphere(position, vec3(0.0, -0.42, -0.35), 0.13);\n    if (d1 < d) {\n        material = 6.0;\n    }\n    d = smin(d, d1, 0.01);\n    d1 = sdfJoint3DSphere(position, vec3(0.08, -0.36, -0.45),\n                          vec3(PI/2.0, -PI/1.4, 0.0),\n                          0.2, PI/4.0, 0.01).x;\n    if (d1 < d) {\n        material = 2.0;\n    }\n    d = smin(d, d1, 0.01);\n    d1 = sdfJoint3DSphere(position, vec3(0.08, -0.47, -0.45),\n                          vec3(PI/2.0, -PI/1.4, 0.0),\n                          0.2, PI/4.0, 0.01).x;\n    if (d1 < d) {\n        material = 2.0;\n    }\n    d = smin(d, d1, 0.01);\n    // cheeks\n    d1 = sdfSphere(symPosX, vec3(0.2, -0.22, -0.35), 0.05);\n    d = smin(d, d1, 0.2);\n    // eyes\n    d1 = sdfSphere(symPosX, vec3(0.15, -0.07, -0.35), 0.11);\n    if (d1 < d) {\n        material = 2.0;\n    }\n    d = smin(d, d1, 0.01);\n    d1 = sdfSphere(symPosX, vec3(0.15, -0.07, -0.41), 0.06);\n    if (d1 < d) {\n        material = 3.0;\n    }\n    d = smin(d, d1, 0.01);\n    d1 = sdfSphere(symPosX, vec3(0.15, -0.07, -0.445), 0.03);\n    if (d1 < d) {\n        material = 4.0;\n    }\n    d = smin(d, d1, 0.01);\n    // eye brows\n    d1 = sdfJoint3DSphere(symPosX, vec3(0.1, 0.13+0.01*sign(position.x), -0.455),\n                          vec3(0.0, -0.9, -PI/3.2),\n                          0.2, 0.9, 0.01).x;\n    if (d1 < d) {\n        material = 5.0;\n    }\n    d = smin(d, d1, 0.01);\n\n    return vec2(d, material);\n}\n\nint calculateArrow(vec3 position) {\n    // To calculate the arrow, we take the origin as 0. If facing back (z=1)\n    // is 0, we trace a circle on the yz plane, and calculate the angle made\n    // we use that to calculate the stem of the arrow, and the position of the\n    // pointyhead.\n    if (abs(position.x) > 0.20) {\n        return 0;\n    }\n    float angle = atan(position.y, position.z);\n    float maxAngle = PI-0.2;\n    float arrowAngle = PI/6.0;\n    if (-PI/2.0 < angle && angle < maxAngle) {\n        // pointy head\n        if (angle > maxAngle-arrowAngle) {\n            float rem = (angle-(maxAngle-arrowAngle)) / arrowAngle;\n            rem = -1.0 * (rem-1.0);\n            if (abs(position.x) < 0.20*rem) {\n                return 1;\n            }\n        } else if (abs(position.x) < 0.11) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvec4 distanceField(vec3 position) {\n\tvec2 d = aangHead(position);\n    return vec4(d, 0.0, 0.0);\n}\n\nvec3 calcNormal(vec3 p) {\n    // We calculate the normal by finding the gradient of the field at the\n    // point that we are interested in. We can find the gradient by getting\n    // the difference in field at that point and a point slighttly away from it.\n    const float h = 0.0001;\n    return normalize( vec3(\n        \t\t\t       -distanceField(p).x+ distanceField(p+vec3(h,0.0,0.0)).x,\n                           -distanceField(p).x+ distanceField(p+vec3(0.0,h,0.0)).x,\n                           -distanceField(p).x+ distanceField(p+vec3(0.0,0.0,h)).x\n    \t\t\t\t ));\n}\n\nvec4 raymarch(vec3 direction, vec3 start) {\n    // We need to cast out a ray in the given direction, and see which is\n    // the closest object that we hit. We then move forward by that distance,\n    // and continue the same process. We terminate when we hit an object\n    // (distance is very small) or at some predefined distance.\n    float far = 15.0;\n    vec3 pos = start;\n    float d = 0.0;\n    vec4 obj = vec4(0.0, 0.0, 0.0, 0.0);\n    for (int i=0; i<100; i++) {\n    \tobj = distanceField(pos);\n        float dist = obj.x;\n        pos += dist*direction;\n        d += dist;\n        if (dist < 0.01) {\n        \tbreak;\n        }\n        if (d > far) {\n        \tbreak;\n        }\n    }\n    return vec4(d, obj.yzw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalise and set center to origin.\n    vec2 p = fragCoord/iResolution.xy;\n    p -= 0.5;\n    p.y *= iResolution.y/iResolution.x;\n\n    float mouseX = ((iMouse.x/iResolution.x)-0.5) * 2.0 * 3.14159/2.0;\n    mouseX = -0.3;\n    mouseX = 0.4*sin(iTime/3.6);\n    vec3 cameraPosition = vec3(0.0, 0.0, -3.0);\n    vec3 planePosition = vec3(p, 1.0) + cameraPosition;\n\n    mat2 camRotate = mat2(cos(mouseX), -sin(mouseX), sin(mouseX), cos(mouseX));\n    cameraPosition.xz = camRotate * cameraPosition.xz;\n    planePosition.xz = camRotate * planePosition.xz;\n\n    float yRotate = 0.1;\n    yRotate = 0.2*sin(iTime/4.2);\n    camRotate = mat2(cos(yRotate), -sin(yRotate), sin(yRotate), cos(yRotate));\n    cameraPosition.yz = camRotate * cameraPosition.yz;\n    planePosition.yz = camRotate * planePosition.yz;\n\n    vec3 lookingDirection = (planePosition - cameraPosition);\n\n    // This was fun to sort out, but is it the best way?\n    float lightTime = iTime/3.0;\n    float multiplier = -1.0 + (step(-0.0, sin(lightTime*3.14159)) *2.0);\n    float parabola = (4.0 * fract(lightTime) * (1.0-fract(lightTime)));\n    float lightX = multiplier*parabola *-1.2;\n    vec3 lightPoint = normalize(vec3(lightX, 1.0, -1.0));\n    vec3 lightFacing = lightPoint - vec3(0.0);\n    // lightFacing = vec3(1.0, 1.0, -0.3) - vec3(0.0);\n\n    // raymarch to check for colissions.\n    vec4 obj = raymarch(lookingDirection, planePosition);\n    float dist = obj.x;\n    vec3 color = vec3(0.01);\n    if (dist < 15.0) {\n        vec3 normal = calcNormal(planePosition+ dist*lookingDirection);\n        int arrow = calculateArrow(planePosition+ dist*lookingDirection);\n        float light = dot(lightFacing, normal);\n        light = max(light, 0.0);\n        if (obj.y < 1.5) {\n            // skin\n        \tcolor = vec3(0.505, 0.205, 0.105);\n            color += 0.3* smoothstep(0.1, 1.0, light);\n            if (arrow==1) {\n        \t    color = vec3(0.21, 0.21, 0.31);\n                color += 0.1* smoothstep(0.1, 1.0, light);\n            }\n        } else if (obj.y < 2.5) {\n            //eyes\n        \tcolor = vec3(0.75, 0.75, 0.85);\n            color += 0.1 * smoothstep(0.5, 1.0, light);\n        } else if (obj.y < 3.5) {\n        \tcolor = vec3(0.21, 0.21, 0.31);\n            color += 0.7 * smoothstep(0.4, 1.0, pow(light, 5.0));\n        } else if (obj.y < 4.5) {\n        \tcolor = vec3(0.01);\n            color += 0.5 * smoothstep(0.4, 1.0, pow(light, 5.0));\n        } else if (obj.y < 5.5) {\n            // eyebrows\n        \tcolor = vec3(0.05, 0.02, 0.01);\n            color += 0.05 * smoothstep(0.4, 1.0, pow(light, 5.0));\n        } else if (obj.y < 6.5) {\n            // mouth\n        \tcolor = vec3(0.15, 0.02, 0.01);\n            color += 0.1 * smoothstep(0.4, 1.0, pow(light, 5.0));\n        }\n    }\n    // gamma correction\n    color = pow( color, vec3(1.0/2.2) );\n    fragColor = vec4(color,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}