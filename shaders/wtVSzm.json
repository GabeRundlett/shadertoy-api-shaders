{
    "Shader": {
        "info": {
            "date": "1582468013",
            "description": "IMO the asteroid is the good guy in Armageddon.",
            "flags": 0,
            "hasliked": 0,
            "id": "wtVSzm",
            "likes": 20,
            "name": "Imminent Doom (SS8)",
            "published": 3,
            "tags": [
                "sdf",
                "shadersundays"
            ],
            "usePreview": 0,
            "username": "angelo12",
            "viewed": 783
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 200\n#define MAX_DIST 20.0\n#define MIN_DIST 0.001\n#define AA 2\n\n/*\n\tShader Sundays! (8/52) \n\t\"Imminent Doom\"\n\t\n\tThis week I picked up an old shader I never published on shadertoy and polished it a bit.\n\tReally like how the soft shadow spreads slowly over the surface giving it a very spooky\n\tfeel. The noisy surface kinda works nicely for the moon/asteroid surface I was going for\n\tbut there are definitely some things that could be improved.\n\t\n\t- The end transition is too harsh.\n\t- The ambient blue light doesn't quite work.\t\n\t- The stars lack variance. (Rotating stars coulda worked?)\n\t- The sphere lacks some details & contrast.\n\t- Distinct lack of Aerosmith soundtrack\n*/\n\nfloat\nhash(vec2 n){\n    return fract(sin(dot(n,vec2(12.9898, 4.1414)))*43758.5453);\n}\n\nfloat _doom = 0.0;\n\nfloat\nSmoothNoise(vec2 uv){\n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n\n    lv = lv*lv*(3.0 - 2.0*lv);\n    float bl = hash(id);\n    float br = hash(id + vec2(1.0, 0.0));\n    float b = mix(bl, br, lv.x);\n\n    float tl = hash(id + vec2(0.0, 1.0));\n    float tr = hash(id + vec2(1.0, 1.0));\n    float t = mix(tl, tr, lv.x);\n\n    return mix(b, t, lv.y);\n}\n\nfloat\nValueNoise(vec2 uv, int octaves){\n    float amplitude = 1.0;\n    float frequency = 1.0;\n    float noise = 0.0;\n    float totalAmp = 0.0;\n\n    for(int i = 0; i < octaves; ++i){\n        noise += SmoothNoise(uv * frequency) * amplitude;\n        totalAmp += amplitude;\n        amplitude /= 2.0;\n        frequency *= 2.0;\n    }\n\n    return noise / totalAmp ;\n}\n\nfloat\nsdTerrain(vec3 pos){\n    return pos.y - ValueNoise(pos.xz, 8);\n}\n\nvec2\nMap(vec3 pos){\n    vec2 res = vec2(1e10, -1.0);\n\n    res = uop(res, vec2(sdTerrain(pos), 1.0));\n    res = uop(res, vec2(sdSphere(pos - vec3(0.0, 5.0, 0.0), 3.5 * (1.0 - _doom) + 0.7), 0.0));\n\n    return res;\n}\n\nvec2\nRayMarch(vec3 ro, vec3 rd){\n    vec2 res = vec2(-1.0, -1.0);\n    float t = 0.0;\n\n    for(int i = 0; i < MAX_STEPS && t < MAX_DIST; ++i){\n        vec2 hit = Map(ro + t*rd);\n\n        if(hit.x < MIN_DIST){\n            res = vec2(t, hit.y);\n            break;\n        }\n\n        t += hit.x;\n    }\n\n\n    return res;\n}\n\nvec3 \nCalcNormals(vec3 p){\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(Map(p + e.xyy).x - Map(p - e.xyy).x,\n                          Map(p + e.yxy).x - Map(p - e.yxy).x,\n                          Map(p + e.yyx).x - Map(p - e.yyx).x\n    ));\n}\n\nfloat\nCalcSoftShadows(vec3 ro, vec3 rd){\n    float k = 4.0;\n    float n = 1.0;\n    for(float t = 0.02; t < MAX_DIST;){\n        float h = Map(ro + t*rd).x;\n        \n        if(h < MIN_DIST){\n            return 0.0;\n        }\n        n = min(n, h*k/t);\n        t += h;\n    }\n\n    return n;\n}\n\nvec3\nRender(vec3 ro, vec3 rd, vec2 uv){\n    vec2 res = RayMarch(ro, rd);\n    float t = res.x;\n    float id = res.y;\n\n    //Sky\n    vec3 col = vec3(0.0);\n    col += vec3(1.0) * pow(hash(uv * vec2(13.0, 2.2)), 703.58);\n    col *= 100.0* (_doom*_doom*_doom);\n\n    if(id >= 0.0){\n        //Geometry\n        vec3 P = ro + t*rd;\n        vec3 N = CalcNormals(P);\n\n        //Material\n        float fresnel = 0.0;\n        vec3 planetCol = vec3(0.1, 0.3, 0.7);\n        if (id == 0.0){\n            col = planetCol;\n            fresnel = 0.04 + (1.0 - 0.04)*pow(1.0 - dot(N,-rd), 5.0);\n        }\n        else{\n            col = vec3(1.0)*N.y;\n            fresnel = 0.0;\n        }\n\n        //Lighting\n        vec3 L = normalize(vec3(0.0, _doom, 1.2));\n        vec3 lin = vec3(0.0);\n        float dif = clamp(dot(N, L), 0.0, 1.0);\n\n        //Shadowing\n        dif *= CalcSoftShadows(P, L);\n\n        //Shading\n        lin += 1.0 * dif * vec3(1.1, 0.9, 0.78);\n        lin += (0.8 - _doom*_doom)* 20.0 * fresnel * vec3(1.0)* 0.01;\n        lin += (0.8 - _doom)* 0.01 * planetCol;\n        col *= lin *(pow(_doom, 0.7));\n    }\n\n    return saturate(col);\n}\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragPos){\n    float time  = mod(iTime, 45.45);\n    _doom = (sin(time/ 16.0 - 1.4 *M_PI) + 1.0)/ 2.0 ;\n    vec3 tot = vec3(0.0);\n    //Camera setup\n    float near = 1.0;\n    float roll = 0.0;\n    vec3 ro = vec3(0.0, 2.0, -20.0);\n    vec3 tar = vec3(0.0);\n    mat3 cam = SetCamera(ro, tar, roll);\n#if AA > 1\n    for(int i = 0; i < AA; ++i)\n    for(int j = 0; j < AA; ++j){\n        vec2 offset = vec2(float(i), float(j))/ float(AA) - 0.5;\n        vec2 uv = ((fragPos+offset) - 0.5*iResolution.xy)/ iResolution.y;\n#else\n        vec2 uv = ((fragPos) - 0.5*iResolution.xy)/ iResolution.y;\n#endif\n\n        vec3 rd = cam * normalize(vec3(uv, near));\n\n        vec3 col = Render(ro, rd, uv);\n\n        col = pow(col, vec3(INV_GAMMA));\n\n        tot += col;\n    #if AA > 1\n    }\n    tot /= float(AA * AA);\n    #endif\n    \n    fragColor = vec4(tot, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define INV_GAMMA  0.454545\n#define M_PI acos(-1.0)\n#define M_TAU M_PI*2.0\n\n//Comment this out if running this file on shadertoy\n#define SHADERTOY \n\n//------------------------------------------------------------------------------------\n//----------------------------------SDF Shaping functions-----------------------------\nfloat\nsdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat \nsdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------SDF Joining functions-----------------------------\n#define UOP(dist, ID) res = uop(res, vec2(dist, ID))\nvec2\nuop(vec2 a, vec2 b)\n{\n    return (a.x < b.x) ? a : b;\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Rotation functions--------------------------------\nvec2 \nrotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Noise functions-----------------------------------\nfloat\nhash(float seed)\n{\n    uvec2 p = floatBitsToUint(vec2(seed+=.1,seed+=.1));\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    uint n = h32^(h32 >> 16);\n    return float(n)/float(0xffffffffU);\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Camera functions------------------------------\nmat3\nSetCamera(vec3 ro, vec3 ta, float roll)\n{\n    vec3 f, temp, r, u;\n    f = normalize(ta - ro);\n    temp = normalize(vec3(sin(roll), cos(roll), 0.0));\n    r = normalize(cross(temp, f));\n    u = normalize(cross(f, r));\n\n    return mat3(r, u, f);\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Path Trace functions------------------------------\nvec3\nCosineWeightedRay(vec3 N, float seed)\n{\n    float u = hash(seed + 70.93);\n    float v = hash(seed + 21.43);\n\n    float a = M_TAU*v;\n    u = 2.0*u - 1.0;\n\n    return(normalize(N + vec3(sqrt(1.0 - u*u)*vec2(cos(a), sin(a)), u)));\n}\n\n//--------------------------------------------------------------------------------------\n//----------------------------------Post processing functions----------------------------\n#define GAMMA(col) col = pow(col, vec3(INV_GAMMA))\n\n\n//---------------------------------------------------------------------------------------- \n//----------------------------------Basic functions---------------------------------------\n#ifdef SHADERTOY\n#define saturate(vol) clamp(col, 0.0, 1.0)\n#endif\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}