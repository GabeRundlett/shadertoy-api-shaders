{
    "Shader": {
        "info": {
            "date": "1614812357",
            "description": "some silly clock design I came up with.\nAlso has code to invert colors with a animation when its AP or PM.",
            "flags": 0,
            "hasliked": 0,
            "id": "wtKBz3",
            "likes": 5,
            "name": "Hand on Hand Clock",
            "published": 3,
            "tags": [
                "clock",
                "weird",
                "art"
            ],
            "usePreview": 0,
            "username": "foxic",
            "viewed": 314
        },
        "renderpass": [
            {
                "code": "\n#define PI 3.14159*2.\nfloat sdCircle( vec2 p, float r ){\n    return length(p) - r;\n}\nfloat sdCircleLine( vec2 p, float r1, float r2 ){\n    return abs(length(p) - r1) - r2;\n}\n\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba)-0.00525;\n}\n\nvec2 dir_to_vec( float angle )\n{\n    return vec2(sin( angle ),cos( angle ));\n}\n\n\nfloat tick_curve( float time )\n{\n    return floor(time)+clamp( fract(time)*5., 0., 1. );\n}\nfloat tick_bounce_curve( float time,float mult )\n{\n    return cos( clamp( fract(time), 0., 1. )*3.14159*2. )*mult;\n}\n\nfloat clock( in vec2 p, float time )\n{\n    float mils  = fract(time);\n\tfloat secs  = mod( tick_curve(time),        60.0 );\n\tfloat mins  = mod( tick_curve(time/60.0),   60.0 )+tick_bounce_curve(secs,0.1);\n\tfloat hors  = mod( tick_curve(time/3600.0), 12.0 )+tick_bounce_curve(mins,0.05)-tick_bounce_curve(secs,0.01);\n    \n    \n    vec2  center = (-tick_bounce_curve(hors,0.125)+0.125)*dir_to_vec((hors*PI)/12.);\n    vec2  offset = center;\n    vec2  h1 = offset;\n    float d  = 1.;\n    \n    // Clock hands\n    d = min( udSegment( p, offset, offset+=dir_to_vec((hors*PI)/12.)*.9 ), d );\n    d = min( sdCircle(p-offset, 0.0125), d );\n    \n    \n    // PIN\n    d = max( -sdCircle(p-center*0.2, 0.1), d ); // cut hole\n    \n    d = min( sdCircleLine(p-center*0.2, 0.1, 0.005), d );\n    d = min( sdCircle(p-center, 0.05), d );\n    \n    // Clock hands contined\n    d = min( udSegment( p, offset, offset+=dir_to_vec((mins*PI)/60.)*.5 ), d );\n    d = min( sdCircle(p-offset, 0.0125), d );\n    d = min( udSegment( p, offset, offset+=dir_to_vec((secs*PI)/60.)*.2 ), d );\n    d = min( sdCircle(p-offset, 0.025), d );\n    d = min( udSegment( p, offset, offset+=dir_to_vec((secs*PI)/60.)*.1 ), d );\n    \n    return d;\n}\n\n\nfloat background( in vec2 p, float time ){\n\n\tfloat day_blend  = max( fract(time/43200.0)*6.28318 , 0.);\n    bool is_bright   = mod( floor(time/43200.0), 2. ) == 1.;\n    \n    float d = 1.;\n    float CircleSize_inner  = mix( 0., 7., day_blend);\n    float CircleSize_outter = mix( 0., 8., day_blend);\n    float WaveSize          = 100.;\n    \n    d = sdCircle(p, CircleSize_inner);\n    d = min( cos(WaveSize*sdCircle(p, CircleSize_inner))*0.01, d );\n    d = max( sdCircle(p, CircleSize_outter), d );\n    \n    if (is_bright) { // likely better way to do this\n        return d;\n    } else {\n        return -d;\n    }\n}\n\nfloat flipblend( float bg, float fg ){\n    return min( max( bg, fg ), 1.-min( bg, fg ) );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n    p *= 1.4;\n    \n    float time  = iDate.w;\n    float fg  =   smoothstep( 0.0,  2.*px, clock( p,               time ) );\n    fg = min( fg, smoothstep( -0.5,  .1,   clock( p+vec2(0.,.03125), time )*2.9 )); // add shadow\n    \n    float bg  = smoothstep( 0.0,2.*px, background( p,time ) );\n    \n    float b = flipblend( bg, fg ); // if background is higher than forgrount invert forground\n    \n    p = fragCoord.xy / iResolution.xy;\n    p *=  1.0 - p.yx;\n    float vig = p.x*p.y * 10.0; // multiply with sth for intensity\n    vig = pow(vig, 0.5)+0.125; // change pow for modifying the extend of the  vignette\n    \n    b = b+(1.-clamp(vig,0.,1.));\n    vec3 col = mix( vec3(0.941,0.9647,0.941), vec3(0.13,0.137,0.137), clamp(b,0.,1.)); // add color\n\n\tfragColor = vec4( col*(vig+0.125), 1.0);\n}\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}