{
    "Shader": {
        "info": {
            "date": "1521709610",
            "description": "Use the mouse; switch forward/backward views when mouse in lower-right view",
            "flags": 0,
            "hasliked": 0,
            "id": "4dGcDh",
            "likes": 7,
            "name": "Asteroid Field",
            "published": 3,
            "tags": [
                "space",
                "flight",
                "asteroid"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 892
        },
        "renderpass": [
            {
                "code": "// \"Asteroid Field\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat Minv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nvec3 Hashv3v3 (vec3 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm1 (float p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nmat3 flMat, flyerMat;\nvec4 ast;\nvec3 flPos, flyerPos, qHit, ltDir, cId, hsh;\nfloat tCur, dstFar, spd, szFacFl;\nint idObj;\nconst vec3 bGrid = vec3 (1.);\nconst float pi = 3.14159;\n\nvec3 trkAx = vec3 (0.7, 0.8, 1.2), trkAy = vec3 (1., 1.1, 0.9),\n   trkFx = vec3 (0.43, 0.33, 0.23), trkFy = vec3 (0.41, 0.31, 0.12);\n\nvec3 TrackPath (float t)\n{\n  return vec3 (dot (trkAx, cos (trkFx * t)), dot (trkAy, cos (trkFy * t)), t);\n}\n\nvec3 TrackVel (float t)\n{\n  return vec3 (- dot (trkFx * trkAx, sin (trkFx * t)),\n     - dot (trkFy * trkAy, sin (trkFy * t)), 1.);\n}\n\nvec3 TrackAcc (float t)\n{\n  return vec3 (- dot (trkFx * trkFx * trkAx, cos (trkFx * t)),\n     - dot (trkFy * trkFy * trkAy, cos (trkFy * t)), 0.);\n}\n\nvoid AstState ()\n{\n  float s, r, a;\n  hsh = Hashv3v3 (cId);\n  s = fract (64. * length (hsh));\n  s *= s;\n  r = 0.5 * bGrid.x * (0.8 + 0.2 * hsh.x * (1. - s) * abs (sin (3. * pi * hsh.y * (1. - s))));\n  a = hsh.z * tCur + hsh.x;\n  ast = vec4 ((r - 1.1 * (0.15 - 0.07 * s)) * vec3 (cos (a), sin (a), 0.), 0.15 - 0.07 * s);\n}\n\nfloat AstDf (vec3 p)\n{\n  vec2 s;\n  s = abs (cId.xy - floor (TrackPath (bGrid.z * cId.z).xy / bGrid.xy));\n  return (hsh.x > 0.7 && max (s.x, s.y) > 0.) ?\n     length (p - bGrid * (cId + 0.5) - ast.xyz) - ast.w : dstFar;\n}\n\nvec3 AstCell (vec3 p)\n{\n  cId.xy = floor (p.xy / bGrid.xy);\n  p.z += 0.1 * spd * tCur * Hashfv2 (cId.xy) * step (10., length (cId.xy));\n  cId.z = floor (p.z / bGrid.z);\n  return p;\n}\n\nfloat AstRay (vec3 ro, vec3 rd)\n{\n  vec3 cIdP, p, s;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  cIdP = vec3 (-999.);\n  dHit = eps;\n  for (int j = 0; j < 100; j ++) {\n    p = ro + rd * dHit;\n    p = AstCell (p);\n    if (length (cId - cIdP) > 0.) {\n      AstState ();\n      cIdP = cId;\n    }\n    d = AstDf (p);\n    s = (bGrid * (cId + step (0., rd)) - p) / rd;\n    d = min (d, abs (Minv3 (s)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 AstNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  p = AstCell (p);\n  AstState ();\n  v = vec4 (AstDf (p + e.xxx), AstDf (p + e.xyy), AstDf (p + e.yxy), AstDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat FlyerEngDf (vec3 p)\n{\n  vec3 q;\n  float d;\n  p = flyerMat * (p - flyerPos);\n  p = p / szFacFl;\n  q = p - vec3 (0., 0.3, -0.6);\n  q.xz = abs (q.xz) - vec2 (1.6, 1.3);\n  q.xy = Rot2D (q.xy, -32. * tCur);\n  d = max (PrCylDf (q, 0.4, 0.4), 0.05 - min (abs (q.x), abs (q.y)));\n  return szFacFl * d;\n}\n\nfloat FlyerEngRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 50; j ++) {\n    d = FlyerEngDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0002 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nfloat FlyerDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, h;\n  dMin = dstFar / szFacFl;\n  p = flyerMat * (p - flyerPos);\n  p = p / szFacFl;\n  q = p;\n  h = 0.5 - 0.05 * (q.z + 0.3) * (q.z + 0.3);\n  q.y -= h;\n  d = PrRoundBoxDf (q, vec3 (0.9 - 0.06 * (q.z + 0.5) * (q.z + 0.5), h, 2.7), 0.15);\n  q = p + vec3 (0., -0.3, 0.6);\n  qq = q;  qq.xz = abs (qq.xz) - vec2 (1.6, 1.3);\n  d = min (min (min (d, PrCylAnDf (qq, 0.44, 0.04 - 0.03 * (qq.z / 0.48) * (qq.z / 0.48), 0.48)),\n     PrCylDf (qq, 0.15 - 0.12 * (qq.z / 0.45) * (qq.z / 0.45), 0.45)),\n     PrRoundBoxDf (qq, vec3 (0.4, 0.01, 0.1), 0.01));\n  q = p;  q.y -= 0.3;\n  qq = q;  qq.z = abs (qq.z + 0.6) - 1.3;\n  d = SmoothMin (d, PrRoundBoxDf (qq, vec3 (1.15, 0.03 - 0.05 * abs (qq.z), 0.3), 0.01), 0.05);\n  DMINQ (1);\n  q = p;  q.yz -= vec2 (0.52, 0.5);\n  d = PrCapsDf (q, 0.6, 1.);\n  DMINQ (2);\n  return 0.7 * szFacFl * dMin;\n}\n\nfloat FlyerRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = FlyerDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0002 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 FlyerNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (FlyerDf (p + e.xxx), FlyerDf (p + e.xyy), FlyerDf (p + e.yxy), FlyerDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec4 FlyerCol ()\n{\n  vec4 col;\n  float ax;\n  col = vec4 (0.9, 0.9, 0.95, 0.3);\n  ax = abs (qHit.x);\n  if (idObj == 1) {\n    if (qHit.z > 2. && length (vec2 (ax - 0.15, qHit.y + 0.3)) < 0.08) {\n      if (length (vec2 (ax - 0.15, qHit.y + 0.3)) < 0.06) col = vec4 (1., 1., 0.8, -2.);\n      else col = vec4 (0.5, 0.5, 0.7, 0.3);\n    } else if (qHit.z < -2. && length (vec2 (abs (ax - 0.3) - 0.15, qHit.y + 0.1)) < 0.1) {\n      if (length (vec2 (abs (ax - 0.3) - 0.15, qHit.y + 0.1)) < 0.08) col = vec4 (1., 0., 0., -2.);\n      else col = vec4 (0.5, 0.5, 0.7, 0.3);\n    } else if (abs (abs (qHit.z + 0.15) - 1.3) < 0.1 && length (vec2 (ax - 1.6, qHit.y)) < 0.2) {\n      col = vec4 (1., 0., 0., 0.3);\n    } else if (ax < 0.02 || qHit.z < -2.8 && mod (8. * qHit.x + 0.1, 1.) < 0.2 ||\n       qHit.z > 2.8 && mod (12. * qHit.y + 0.1, 1.) < 0.2 ||\n       abs (qHit.z + 1.3) < 0.9 && ax < 0.8 && mod (6. * qHit.x + 0.1, 1.) < 0.15 ||\n       abs (qHit.z + 0.7) < 0.5 && abs (qHit.y - 0.2) < 0.3 && mod (12. * qHit.y + 0.1, 1.) < 0.15) {\n      col = vec4 (0.6, 0.6, 0.6, 0.3);\n    } else if (abs (abs (qHit.z + 0.15) - 1.3) < 0.1 && ax > 1.12) {\n      col = vec4 (0.6, 0.6, 0.6, 0.3);\n    } else if (length (vec2 (abs (qHit.z + 0.6) - 1.3, ax - 1.6)) < 0.1 && abs (qHit.y) > 0.44) {\n       col = mix (0.8 * col, vec4 (0., 1., 0., -2.), step (0.5, mod (0.5 * tCur, 1.)));\n    }\n  } else if (idObj == 2) {\n    if (min (ax, abs (qHit.z - 1.)) > 0.03) col = vec4 (0.1, 0.1, 0.2, -1.);\n  }\n  return col;\n}\n\nvec3 HvnCol (vec3 rd)\n{\n  vec3 col;\n  float b;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  col = 0.3 * mix (vec3 (0.8, 0.8, 0.7), vec3 (0.6, 0.6, 0.5), 0.5 * (1. - rd.y)) *\n     (0.4 + 0.15 * (rd.y + 1.) * (rd.y + 1.));\n  rd.xz = Rot2D (rd.xz, 0.01 * tCur);\n  rd = floor (2000. * rd);\n  rd = 0.00015 * rd + 0.1 * Noisefv3 (0.0005 * rd.yzx);\n  for (int j = 0; j < 19; j ++) rd = abs (rd) / dot (rd, rd) - 0.9;\n  col += 0.3 * vec3 (1., 1., 0.9) * min (1., 0.5e-3 * pow (min (6., length (rd)), 5.));\n  return col;\n}\n\nvec3 AstCol (vec3 ro, vec3 rd, float dstAst)\n{\n  vec3 vn, p, col;\n  ro += dstAst * rd;\n  vn = AstNf (ro);\n  p = ro;\n  p = AstCell (p);\n  AstState ();\n  p -= ast.xyz + bGrid * (cId + 0.5) + 0.3 * (hsh - 0.5);\n  vn = VaryNf (32. * (0.5 + 0.5 * hsh.x) * p, vn, 10. * (0.5 + 0.5 * hsh.y));\n  col = HsvToRgb (vec3 (0.13 + 0.03 * hsh.x, 0.3 + 0.3 * hsh.y,\n     min (0.5 + 0.2 * hsh.z + 0.5 * Fbm3 (32. * p), 1.)));\n  col = col * (0.1 + 0.9 * max (dot (vn, ltDir), 0.)) +\n     0.2 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  return mix (col, HvnCol (rd), smoothstep (0.5, 1., min (dstAst / dstFar, 1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstAst, dstFlyer, dstEng, refFac;\n  dstEng = FlyerEngRay (ro, rd);\n  dstFlyer = FlyerRay (ro, rd);\n  if (dstFlyer < dstEng) dstEng = dstFar;\n  dstAst = AstRay (ro, rd);\n  if (dstFlyer < min (dstAst, dstFar)) {\n    ro += rd * dstFlyer;\n    vn = FlyerNf (ro);\n    col4 = FlyerCol ();\n    col = col4.rgb;\n    refFac = 0.;\n    if (col4.a >= 0.) {\n      col = col * (0.2 + 0.1 * max (dot (vn, - ltDir), 0.) + 0.7 * max (dot (vn, ltDir), 0.)) +\n         col4.a *  pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n      refFac = 0.5;\n    } else if (col4.a == -1.) refFac = 0.9;\n    if (refFac > 0.) {\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n      dstAst = AstRay (ro, rd);\n      col = mix (col, AstCol (ro, rd, dstAst), refFac);\n    }\n  } else col = AstCol (ro, rd, dstAst);\n  if (dstEng < min (dstAst, dstFar)) col = mix (col, vec3 (1., 0.5, 0.1), 0.7);\n  return pow (clamp (col, 0., 1.), vec3 (0.9));\n}\n\nvoid FlyerPM (float s, float rl, float vu)\n{\n  vec3 vel, ort, ca, sa;\n  float el, az;\n  flPos = TrackPath (s);\n  vel = normalize (TrackVel (s));\n  el = - asin (vel.y);\n  az = atan (vel.z, vel.x) - 0.5 * pi;\n  rl = clamp (rl - 3. * TrackAcc (s).x, -0.4 * pi, 0.4 * pi);\n  ort = (vu >= 0.) ? vec3 (el, az, rl) : vec3 (- el, az + pi, - rl);\n  ca = cos (ort);\n  sa = sin (ort);\n  flMat = mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n          mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col, ori, ca, sa;\n  vec2 canvas, uv, mMid, ut, mSize;\n  float el, az, asp, vuDir;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  mSize = (1./6.) * vec2 (asp, 1.);\n  mMid = vec2 (1. / mSize.y, 1. / mSize.y - 1.) * mSize * vec2 (1. - 1./6., -1.);\n  ut = abs (uv - mMid) - mSize;\n  vuDir = 1.;\n  if (max (ut.x, ut.y) < 0.) {\n    uv = (uv - mMid) / mSize.y;\n    vuDir = -1.;\n  }\n  szFacFl = 0.005;\n  spd = 1.5;\n  tCur = mod (tCur, 10800.) + 30.;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    if (mPtr.x < 0.5 - 1./6. || mPtr.y > -0.5 + 1./6.) {\n      az = 2. * pi * mPtr.x;\n      el = 0.6 * pi * mPtr.y;\n    } else vuDir *= -1.;\n  }\n  ori = vec3 (el, az, 0.02 * pi * (Fbm1 (tCur) - 0.5));\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n          mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.);\n  FlyerPM (spd * tCur + ((vuDir > 0.) ? 0.5 + 0.45 * sin (0.2 * tCur) :\n     - (0.25 + 0.2 * sin (0.2 * tCur))), 0.03 * pi * (Fbm1 (1.3 * tCur) - 0.5), 0.);\n  flyerPos = flPos;\n  flyerMat = flMat;\n  FlyerPM (spd * tCur, 0., vuDir);\n  ro = flPos;\n  rd = normalize (vec3 (uv, 2.7));\n  rd = rd * flMat;\n  rd = vuMat * rd;\n  ltDir = normalize (vec3 (1., 1., ((vuDir >= 0.) ? -1. : 1.)));\n  ltDir.xy = Rot2D (ltDir.xy, -0.07 * pi * tCur);\n  dstFar = 40.;\n  col = ShowScene (ro, rd);\n  if (max (ut.x, ut.y) < 0. && min (abs (ut.x), abs (ut.y)) * canvas.y < 2.)\n     col = vec3 (0.1, 0.1, 0.8);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec3 Hashv3v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec3 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}