{
    "Shader": {
        "info": {
            "date": "1584817249",
            "description": "I played XIII last Friday and wanted to remake the iconic look. Based off of my deferred rendering sketch. took a few hours. Kinda nailed it, I know :'",
            "flags": 32,
            "hasliked": 0,
            "id": "WslyW4",
            "likes": 16,
            "name": "XIII — sat.sketch #8",
            "published": 3,
            "tags": [
                "celshading",
                "outline",
                "toon",
                "comic",
                "frame",
                "comicbook",
                "deferred",
                "gbuffer",
                "xiii"
            ],
            "usePreview": 0,
            "username": "szczm_",
            "viewed": 716
        },
        "renderpass": [
            {
                "code": "/*************************************************************************************\n\n XIII — saturday sketch #8\n  — Matthias Scherba (@szczm_)\n\n\n So I played XIII last Friday and wanted to remake the iconic look.\n Based off of my deferred rendering sketch. took a few hours.\n Kinda nailed it, I know :'\n\n Not much more to add here, everything is nicely commented.\n if you have any questions hit me up on Twitter or ask in comments (:\n\n https://twitter.com/szczm_\n\n*************************************************************************************/\n\n// Image tab: Final render and frame\n\n\n#define LIT_BUFFER (iChannel0)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    time = iTime;\n    \n    vec2 coord = fragCoord / iResolution.xy;\n\n    \n    fragColor = texture(LIT_BUFFER, coord);\n    \n    \n    vec4 region = getRegion();\n    \n    // If not the active region,\n    if (!(coord.x > region.x && coord.x < region.z && coord.y > region.y && coord.y < region.w))\n    {\n        // tint ice blue.\n        fragColor = mix(fragColor, vec4(0.6, 0.9, 1.0, 1.0), 0.4);\n    }\n    \n    // Draw frames\n    for (int i = 0; i < 5; i++)\n    {\n        vec4 region = getRegion(i);\n        \n        if (coord.x > region.x && coord.x < region.z && coord.y > region.y && coord.y < region.w)\n        {\n            vec2 ep = vec2(1.0, iResolution.x / iResolution.y);\n            vec4 epp = ep.xyxy * vec4(1.0, 1.0, -1.0, -1.0);\n            \n            vec4 frame = region + epp * 0.03;\n            \n            // One\n            if (coord.x < frame.x || coord.x > frame.z || coord.y < frame.y || coord.y > frame.w)\n            {\n                fragColor = vec4(0.0);\n            }\n            \n            frame -= epp * 0.005;\n            \n            // Two\n            if (coord.x < frame.x || coord.x > frame.z || coord.y < frame.y || coord.y > frame.w)\n            {\n                fragColor = vec4(1.0);\n            }\n            \n            frame -= epp * 0.01;\n            \n            // Three.\n            if (coord.x < frame.x || coord.x > frame.z || coord.y < frame.y || coord.y > frame.w)\n            {\n                fragColor = vec4(0.0);\n            }\n            \n            return;\n        }\n    }    \n}\n\n#undef LIT_BUFFER",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "precision highp float;\n\n\n// Constants\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\n\nconst int MAX_STEPS = 200;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 30.0;\nconst float EPSILON = 1e-4;\n\nconst float MIN_DIST_SHADOW = 0.0;\nconst float MAX_DIST_SHADOW = 5.5;\n\nconst vec3 CAMERA_TARGET = vec3(0.0, -0.8, 0.0);\nconst float CAMERA_FOV = 60.0;\n\nconst vec3 LIGHT_CAMERA_TARGET = vec3(0.0, -0.5, 0.0);\nconst float LIGHT_CAMERA_SIZE = 2.3;\n\nconst float MAX_ROUGHNESS = 60.0;\n\n\n// Need to set time in buffers - iTime is undefined in the Common tab\nfloat time;\n\n\n// Distance functions\n\nfloat torusSDF(vec3 p, vec2 t)\n{\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nfloat sphereSDF(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat planeSDF(vec3 p, vec3 n)\n{\n    return length(p) * dot(normalize(p), n);\n}\n\nfloat capsuleSDF(vec3 p, float h, float r)\n{\n\tp.y -= clamp(p.y, 0.0, h);\n\treturn length(p) - r;\n}\n\n\n// Gotta fix those for my drivers\n#define TAU 6.28318530718\nfloat sinf(float arg) { return sin(mod(arg, TAU)); }\nfloat cosf(float arg) { return cos(mod(arg, TAU)); }\n\n\n// Rotations\n\nvec3 rotX(vec3 p, float angle) {\n    return mat3(\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, cosf(angle), -sinf(angle)),\n        vec3(1.0, sinf(angle), cosf(angle))\n    ) * p;\n}\n      \nvec3 rotY(vec3 p, float angle) {\n    return mat3(\n        vec3(cosf(angle), 0.0, sinf(angle)),\n        vec3(0.0, 1.0, 0.0),\n        vec3(-sinf(angle), 0.0, cosf(angle))\n    ) * p;\n}\n      \nvec3 rotZ(vec3 p, float angle) {\n    return mat3(\n        vec3(cosf(angle), -sinf(angle), 0.0),\n        vec3(sinf(angle), cosf(angle), 0.0),\n        vec3(1.0, 0.0, 1.0)\n    ) * p;\n}\n\n\n// Structs\n\nstruct Material\n{\n    vec3 albedo;\n    float id;\n};\n\nstruct Hit\n{\n    float dist;\n    int id;\n};\n    \n\n// Tracing stuff\n    \nHit minHit(Hit a, Hit b)\n{\n    if (a.dist < b.dist)\n        return a;\n    \n    return b;\n}\n\nHit sceneSDF(vec3 p)\n{\n    p -= vec3(-0.3, -0.2, 0.2);\n    Hit scene = Hit(planeSDF(p + vec3(1.5), vec3(0.0, 1.0, 0.0)), 1);\n    \n    scene = minHit(scene, Hit(sphereSDF(p - vec3(-0.5, 0.2, 0.0), 0.7), 2));\n    scene = minHit(scene, Hit(torusSDF(p - vec3(0.5, -0.4, 1.1), vec2(0.45, 0.3)), 3));\n    scene = minHit(scene, Hit(capsuleSDF(p - vec3(1.1, -0.2, -0.7), 0.7, 0.5), 4));\n    \n    return scene;\n}\n\nHit shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    Hit finalHit = Hit(start, -1);\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        Hit hit = sceneSDF(eye + finalHit.dist * marchingDirection);\n        \n        finalHit.dist += hit.dist;\n        finalHit.id = hit.id;\n        \n        if (hit.dist < EPSILON) {\n\t\t\tbreak;\n        }\n        \n        if (finalHit.dist >= end) {\n            finalHit = Hit(end, -1);\n            break;\n        }\n    }\n    \n    return finalHit;\n}\n\nvec3 getEye()\n{\n    return rotY(vec3(2.5, 2.5, 2.0), -time * TAU * 0.05);\n}\n\n\n\nvec4 getRegion(int i)\n{\n    const vec4[5] regions = vec4[]\n    (\n        vec4(0.0, 0.0, 0.2, 1.0),\n        vec4(0.2, 0.0, 0.4, 0.2),\n        vec4(0.4, 0.0, 1.0, 0.2),\n        vec4(0.8, 0.2, 1.0, 1.0),\n        vec4(0.2, 0.2, 0.8, 1.0)\n    );\n    \n    return regions[i];\n}\n\nvec4 getRegion()\n{\n    int i = int(mod(time + 4.0, 5.0));\n    \n    return getRegion(i);\n}\n\n\n// Math stuff\n\n// vec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\nvec3 rayDirection(vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(CAMERA_FOV) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\n// Light stuff\n\nconst float a = 0.95;\n\nfloat h()\n{\n    return clamp(0.0, 1.0, (mod(time - a * 0.5, 1.0) - (1.0 - a)) / a);\n}\n\nfloat g(float x)\n{\n    return floor(mod(x, 4.0)) * 0.2;\n}\n\nvec3 lightPosition()\n{\n    vec3 dir = vec3(0.0, 2.0, 0.0);\n    \n    dir = rotX(dir, -0.15 * TAU);\n    \n    float t = -0.4 + mix(g(time - a * 0.5), g(time + a * 0.5), smoothstep(0.0, 1.0, h()));\n    \n    dir = rotY(dir, t * TAU);\n    \n    return dir;\n}\n\n// This is a directional light - the direction is the same for each world position\nvec3 lightDirection()\n{\n    return -normalize(lightPosition());\n}\n\nvec3 lightColor()\n{\n    return vec3(1.0, 1.0, 0.9);\n}\n\nmat4 lightToWorldMatrix()\n{\n    return viewMatrix(lightPosition(), LIGHT_CAMERA_TARGET, UP);\n}\n\nvec3 worldPointToLightPoint(vec3 worldPoint, out float lightDist)\n{\n    vec3 lightDir = lightDirection();\n    vec3 lightPos = lightPosition();\n    \n    // Plane SDF allows easy distance calculation to ortographic plane.\n    // -lightPos = lightDir * length(lightPos)\n    lightDist = planeSDF(worldPoint, -lightPos);\n\n    mat4 worldToLight = inverse(lightToWorldMatrix());\n    \n    // Quick maths\n    vec3 lightPoint = worldPoint + lightDist * lightDir;\n\tlightPoint = (worldToLight * vec4(lightPoint, 0.0)).xyz;\n    lightPoint = (lightPoint + LIGHT_CAMERA_SIZE) / (2.0 * LIGHT_CAMERA_SIZE);\n    \n    return lightPoint;\n}\n\n\n// Packing/encoding stuff\n\nfloat map(in float val, in float startIn, in float endIn, in float startOut, in float endOut)\n{\n    float norm = (val - startIn) / (endIn - startIn);\n    return norm * (endOut - startOut) + startOut;\n}\n\nvec3 quantize(vec3 value, float steps)\n{\n    return floor(value * steps) / steps;\n}\n\nfloat packVec3(vec3 vec, float steps)\n{\n    vec3 quantized = quantize(vec, steps);\n    \n    float x = quantized.x * steps * steps;\n    float y = quantized.y * steps;\n    float z = quantized.z;\n    \n    return (x + y + z) / (steps * steps);\n}\n\nvec3 unpackVec3(float packed, float steps)\n{\n    vec3 vec = vec3(0.0);\n    \n    vec.x = fract(packed);\n    vec.y = fract(packed * steps);\n    vec.z = fract(packed * steps * steps);\n    \n    return vec;\n}\n\nvoid packGbuffer(out vec4 packed, in float depth, in vec3 normal, in Material material)\n{\n    packed = vec4(0.0);\n    \n    // values equal to 1.0 are clipped, so have to lower them a bit\n    packed.r = packVec3(normal * 0.49 + 0.49, 256.0);\n    packed.g = packVec3(material.albedo * 0.999, 256.0);\n    packed.b = packVec3(vec3(float(material.id) / 5.0), 5.0);\n    packed.a = map(depth, MIN_DIST, MAX_DIST, 0.0, 1.0);\n}\n\nvoid unpackGbuffer(in vec4 packed, out float depth, out vec3 normal, out Material material)\n{\n    vec3 matParams = unpackVec3(packed.b, 100.0);\n    \n    depth = map(packed.a, 0.0, 1.0, MIN_DIST, MAX_DIST);\n    normal = 2.0 * unpackVec3(packed.r, 256.0) - 1.0;\n\n    material.id = matParams.r * 5.0;\n    \n    material.albedo = unpackVec3(packed.g, 256.0);\n}\n\nvoid packShadow(out vec4 packed, in float depth)\n{\n    packed = vec4(map(depth, MIN_DIST_SHADOW, MAX_DIST_SHADOW, 0.0, 1.0));\n}\n\nvoid unpackShadow(in vec4 packed, out float depth)\n{\n    depth = map(packed.r, 0.0, 1.0, MIN_DIST_SHADOW, MAX_DIST_SHADOW);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Buffer A: Render the G buffer.\n\n// This tab has knowledge of materials, no other tab does.\n\n\nMaterial materials[4] = Material[]\n(\n    //            albedo          id\n    Material(vec3(0.6),           0.0), // floor\n    Material(vec3(0.9, 0.3, 0.0), 1.0), // sphere\n    Material(vec3(0.5, 1.0, 0.0), 2.0), // torus\n    Material(vec3(0.5, 0.2, 1.0), 3.0)  // capsule\n);\n\nvec3 normal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).dist - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).dist,\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).dist - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).dist,\n        sceneSDF(vec3(p.x, p.y, p.z + EPSILON)).dist - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).dist\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    time = iTime;\n    \n\tvec3 viewDir = rayDirection(iResolution.xy, fragCoord);\n    \n    vec3 eye = getEye();\n    mat4 viewToWorld = viewMatrix(eye, CAMERA_TARGET, UP);\n    vec3 worldDir = (viewToWorld * viewDir.xyzz).xyz;\n    \n    Hit hit = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n\n    Material material;\n        \n    if (hit.id > 0)\n    {    \n        vec3 normal = normal(eye + hit.dist * worldDir);\n        Material material = materials[hit.id - 1];\n        \n\t\tpackGbuffer(fragColor, hit.dist, normal, material);\n    }\n\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Buffer B: Render the shadow buffer.\n\n// This is an ortographic camera oriented around the center.\n// Parameters chosen for best quality.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    \n    vec2 coord = (-1.0 + 2.0 * fragCoord / iResolution.xy) * LIGHT_CAMERA_SIZE;\n    \n    vec3 eye = lightPosition();\n    vec3 viewDir = vec3(0.0, 0.0, -1.0);\n    \n    mat4 lightToWorld = lightToWorldMatrix();\n    \n    // Identical direction, changed position, it's an ortographical projection 🎶 (bad raps I know)\n    eye += (lightToWorld * vec4(coord.x, coord.y, 0.0, 0.0)).xyz;\n    \n    vec3 worldDir = (lightToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    Hit hit = shortestDistanceToSurface(eye, worldDir, MIN_DIST_SHADOW, MAX_DIST_SHADOW);\n\n    packShadow(fragColor, hit.dist);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Buffer C: Render the scene.\n\n// This tab knows how to light the scene, no other tab does.\n\n\n#define G_BUFFER (iChannel0)\n#define SHADOW_BUFFER (iChannel1)\n#define THIS_BUFFER (iChannel2)\n\n\nvec3 lighting(in vec3 position, in vec3 normal, in vec3 viewDir, in Material material, in float shadow)\n{\n    vec3 lightDir = lightDirection();\n    vec3 lightCol = lightColor();\n    \n    // Diffuse\n    float ndotl = dot(normal, -lightDir);\n    float diffuseStep = step(0.01, ndotl); // toon shading\n    \n    // Final terms\n    float ambient = 0.05;\n    float diffuse = diffuseStep * shadow;\n    \n    return (ambient * material.albedo + mix(material.albedo, lightCol, diffuse * 0.5)) * lightCol;\n}\n\nfloat shadow(in vec3 position)\n{\n    float lightDist;\n\tvec3 lightPoint = worldPointToLightPoint(position, lightDist);\n    \n    float shadowDist;\n    unpackShadow(texture(SHADOW_BUFFER, lightPoint.xy), shadowDist);\n    \n    // Compare real distance to light with distance captured by the light \"camera\".\n    // If they differ, this means that something is on the way.\n    // This means one thing.\n    // Shadow.\n    // (Mapping.)\n    float shadow = shadowDist - lightDist;\n    shadow = step(0.0, shadow);\n\n    if (clamp(lightPoint.x, 0.0, 1.0) != lightPoint.x\n     || clamp(lightPoint.y, 0.0, 1.0) != lightPoint.y\n     || shadowDist >= MAX_DIST_SHADOW - 1.0)\n        shadow = 1.0;\n    \n    return shadow;\n}\n\nfloat outline(in vec2 coord, in float id)\n{\n    float depth;\n    vec3 normal;\n    Material material;\n\n    \n\tfloat shouldOutline = 0.0;\n    \n    // Check circular neighbourhood\n    for (float i = 0.0; i < TAU; i += TAU / 10.0)\n    {\n        vec2 offset = vec2(cos(i), sin(i) * iResolution.x / iResolution.y) * 0.002;\n\t    unpackGbuffer(texture(G_BUFFER, coord + offset), depth, normal, material);\n        \n        if (id != material.id)\n        {\n            shouldOutline = 1.0;\n        }\n    }\n    \n    return shouldOutline;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    time = iTime;\n    \n    vec2 coord = fragCoord / iResolution.xy;\n    \n    vec4 region = getRegion();\n    \n    // If not the current region and not the first frame,\n    if (!(coord.x > region.x && coord.x < region.z && coord.y > region.y && coord.y < region.w) && iFrame > 0)\n    {\n        // Return previous frame's texel\n        fragColor = texture(THIS_BUFFER, coord);\n    }\n    else\n    {\n        vec3 viewDir = rayDirection(iResolution.xy, fragCoord);\n\n        vec3 eye = getEye();\n        mat4 viewToWorld = viewMatrix(eye, CAMERA_TARGET, UP);\n        vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n\n        float depth;\n        vec3 normal;\n        Material material;\n\n        unpackGbuffer(texture(G_BUFFER, coord), depth, normal, material);\n\n\n        vec3 position = eye + depth * worldDir;\n\n        float shadow = shadow(position);\n\n        fragColor.rgb = lighting(position, normal, worldDir, material, shadow);\n\t\tfragColor.a = 1.0;\n\n        fragColor.rgb = mix(fragColor.rgb, vec3(0.0), outline(coord, material.id));\n    }\n}\n\n#undef G_BUFFER\n#undef SHADOW_BUFFER\n#undef THIS_BUFFER",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}