{
    "Shader": {
        "info": {
            "date": "1553344662",
            "description": "click: show domains. mouse:V  S: strips\nTexture advection by moving uv coordinates inside blended square tiles.\nOppositely to [url]https://shadertoy.com/view/ll2BDw[/url],  preserves the pattern but the flow looks tily",
            "flags": 48,
            "hasliked": 0,
            "id": "3dSSWz",
            "likes": 22,
            "name": "Advecting random velocity - 3",
            "published": 3,
            "tags": [
                "texture",
                "fluid",
                "flow",
                "advection",
                "pseudoparticles"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 1550
        },
        "renderpass": [
            {
                "code": "// Fork of  https://shadertoy.com/view/WsSXDR\n// see lava variant here: https://www.shadertoy.com/view/WdjSWz\n\n// velocity field from Ultraviolet's https://shadertoy.com/view/ll2BDw\n\n// mouse.x = amout of flow simulation ( 0: \"fix flow\" )\n// mouse.y = velocity amplitude\n// S: show strips vs noise\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n\tO = texelFetch(iChannel0, ivec2(U), 0);\n  //O = pow(O, vec4(1./2.2)); // to SRGB\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// --- analytical velocity field from https://shadertoy.com/view/ll2BDw\n\n#define SPEED_EV\tmax(0., 1.6*iMouse.x/iResolution.x - .1)\n#define SPEED_AM\t(0.5+iMouse.y/iResolution.y)\n\n// from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec3 hash(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0*fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n// from https://www.shadertoy.com/view/Xsl3Dl\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n\n\n\nvec2 speed(vec2 uv)\n{\n    float ratio = iResolution.y/iResolution.x;\n    uv = uv*10.*vec2(1., ratio);\n#if 1 // random velocity field\n    return SPEED_AM*vec2(noise(vec3(uv, iTime*SPEED_EV)), noise(vec3(uv + vec2(12.10135, 1354.2435), iTime*SPEED_EV)));\n\n#else // test: uniform rotation\n    uv -= 5.*vec2(1., ratio); return .3*SPEED_AM*vec2(-uv.y,uv.x);\n#endif    \n}\n\n\nvoid mainImage( out vec4 O, vec2 C )\n{\n\tO.xy = speed(C/iResolution.xy);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// --- texture coords advection \n\n\nvoid mainImage( out vec4 O, in vec2 C )\n{\n\tvec2 R = iResolution.xy,\n        uv = C / R;\n    \n    O.xy = iFrame==0 || texture(iChannel0,.5/R).zw != R\n        ? 17.73*uv    \n        : texture(iChannel0,uv).xy - texture(iChannel1,uv).xy/R;\n\n    O.zw = R;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// --- reconstruct advected texture \n\n#define r iResolution.xy\n#define keypress(c) ( texelFetch(iChannel2, ivec2(c,2),0).x > .5 )\n\nvec2 speed(vec2 uv)\n{\n    return texture(iChannel3, uv).xy;\n}\n\n#define tex(p) (2.* texture(iChannel1, p).x - 1.) \n\nfloat noiseTexture(vec2 p, float t)\n{\n    p = .5*p + t;\n    float val = tex(p);\n    //return val;\n    \n    if keypress(32)\n    {\n        val *= .5;\n        val += tex(p*2.) *.25;\n        val += tex(p*4.) *.125;\n        val += tex(p*8.) *.0625;\n    }\n    \n    return val;\n}\n\n\nvoid mainImage( out vec4 O, in vec2 C )\n{\n#define CASE 2\n#define T 16.  // tiles size\n    \n#if CASE==0    // naive way: per pixel\n    \n\tvec2 uv = texture(iChannel0, C / r).xy;       \n    O = vec4( .5 + .5* noiseTexture(uv, 0.) );\n    \n#elif CASE==1  // per  tiles\n\n    vec2 I = round(C/T)*T, F = C-I,\n\t    uv = texelFetch(iChannel0, ivec2(I), 0).xy\n             + F/r;\n    O = vec4( .5 + .5* noiseTexture(uv, 0.) );\n\n#else        // per overlapping tiles\n\n    O -= O;\n    bool demo = iMouse.z>0.;\n    vec2 I = floor(C/T)*T;\n    float v,w,s=0.;\n    \n    for (int k=0; k<4; k++) {\n        vec2 J = I + T*vec2(k%2,k/2),\n             F = C-J, W = fract(F/T),\n\t        uv = texelFetch(iChannel0, ivec2(J), 0).xy\n                + F/r;\n        uv *= r/r.y;\n        w = ( k%2==1 ? W.x: 1.-W.x ) * ( k/2==1 ? W.y: 1.-W.y );\n        s += w*w;\n        v = keypress(64.+19.)      // strips markers\n           ? sin(r.y/1.5* dot( uv, normalize(texelFetch(iChannel3, ivec2(J), 0).xy)))\n         //? sin(r.y/1.5* dot( vec2(-uv.y,uv.x), normalize(texelFetch(iChannel3, ivec2(J), 0).xy)))\n           : noiseTexture(uv, 0.); // noise markers\n\n        if (demo) O[(k+int(C.x/T)+int(C.y/T)*2)%4] += w*(.5+.5*v);\n        else      O += w*v;\n    }\n    if (demo) O += O.a ;\n    else O = .5 + .5* O/sqrt(s);\n#endif\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}