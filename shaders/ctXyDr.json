{
    "Shader": {
        "info": {
            "date": "1690573724",
            "description": "Credit to IQ for anti aliased Curve plot , hsv ( edited)\nCredit Branchless Blend Modes https://www.shadertoy.com/view/Md3GzX",
            "flags": 0,
            "hasliked": 0,
            "id": "ctXyDr",
            "likes": 3,
            "name": "Curve Visualization Blend Modes",
            "published": 3,
            "tags": [
                "curvelines2dplotblendmodesphotoshopchris"
            ],
            "usePreview": 0,
            "username": "Chrisy",
            "viewed": 180
        },
        "renderpass": [
            {
                "code": "#define ctiles  4.0 \n#define cgrid 2.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    float dx = 1.0/iResolution.y;\n\n     col = vec3(0.0);\n\n    \n    vec2 tileduv = mod(uv*ctiles,vec2(1.0));\n    int idxy = int(uv.y*ctiles)*int(ctiles);\n    int idxx = int(uv.x*ctiles);\n    int idx = idxx+idxy;\n    \n    vec3 ix = vec3(tileduv.x);vec3 iy = vec3(tileduv.y-.2)*1.25;\n    col = vec3( 0.2 + 0.02*mod(floor(ix*cgrid)+floor(iy*cgrid),2.0) );\n    if(tileduv.y<0.2){\n        col = plotA(ix,iTime,idx);\n    }else{\n    \n        vec3 y = plotA( ix,iTime,idx);\n        vec3 dy = plotA(ix-dx,iTime,idx) - y;\n        vec3 di = iy-y;\n        col = mix( col, vec3(1), smoothstep(1., 0., abs(di)/fwidth(di) ) );\n    }\n    //col.x = float(idx==0?1:0);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define DEG2RAD 0.03926990816987241548078304229099\n\n\n\nvec3 multiply(in vec3 src, in vec3 dst)\n{\n\treturn src * dst;\n}\n\nvec3 screen(in vec3 src, in vec3 dst)\n{\n    return src + dst - src * dst;\n}\n\nvec3 exclusion(in vec3 src, in vec3 dst)\n{\n    return dst + src - (2.0*dst*src);;\n}\n\nvec3 overlay(in vec3 src, in vec3 dst)\n{\n    return mix(2.0 * src * dst, 1.0 - 2.0 * (1.0 - src) * (1.0-dst), step(0.5, dst));\n}\n\nvec3 hardlight(in vec3 src, in vec3 dst)\n{\n    return mix(2.0 * src * dst,  1.0 - 2.0 * (1.0 - src) * (1.0-dst), step(0.5, src));\n}\n\nvec3 softlight(in vec3 src, in vec3 dst)\n{\n    return mix(dst - (1.0 - 2.0 * src) * dst * (1.0 - dst), \n               mix(dst + ( 2.0 * src - 1.0 ) * (sqrt(dst) - dst),\n                   dst + (2.0 * src - 1.0) * dst * ((16.0 * dst - 12.0) * dst + 3.0),\n                   step(0.5, src) * (1.0 - step(0.25, dst))),\n               step(0.5, src));\n}\n\nvec3 colorDodge(in vec3 src, in vec3 dst)\n{\n    return step(0.0, dst) * mix(min(vec3(1.0), dst/ (1.0 - src)), vec3(1.0), step(1.0, src)); \n}\n\nvec3 colorBurn(in vec3 src, in vec3 dst)\n{\n    return mix(step(0.0, src) * (1.0 - min(vec3(1.0), (1.0 - dst) / src)),\n        vec3(1.0), step(1.0, dst));\n}\n\nvec3 linearDodge(in vec3 src, in vec3 dst)\n{\n    return clamp(src.xyz + dst.xyz, 0.0, 1.0);\n}\n\nvec3 linearBurn(in vec3 src, in vec3 dst)\n{\n    return clamp(src.xyz + dst.xyz - 1.0, 0.0, 1.0);\n}\n\nvec3 vividLight(in vec3 src, in vec3 dst)\n{\n    return mix(max(vec3(0.0), 1.0 - min(vec3(1.0), (1.0 - dst) / (2.0 * src))),\n               min(vec3(1.0), dst / (2.0 * (1.0 - src))),\n               step(0.5, src));\n}\n\nvec3 linearLight(in vec3 src, in vec3 dst)\n{\n    return clamp(2.0 * src + dst - 1.0, 0.0, 1.0);;\n}\n\nvec3 pinLight(in vec3 src, in vec3 dst)\n{\n    return mix(mix(2.0 * src, dst, step(0.5 * dst, src)),\n        max(vec3(0.0), 2.0 * src - 1.0), \n        step(dst, (2.0 * src - 1.0))\n    );\n}\n\nvec3 hardMix(in vec3 src, in vec3 dst)\n{\n    return step(1.0, src + dst);\n}\n\nvec3 subtract(in vec3 src, in vec3 dst)\n{\n    return dst - src;\n}\n\nvec3 divide(in vec3 src, in vec3 dst)\n{\n    return dst / src;\n}\n\nvec3 addition(vec3 src, vec3 dst)\n{\n    return src + dst;\n}\n\nvec3 difference(in vec3 src, in vec3 dst )\n{\n    return abs(dst - src);   \n}\n\nvec3 darken(in vec3 src, in vec3 dst)\n{\n    return min(src, dst);\n}\n\nvec3 lighten(in vec3 src, in vec3 dst)\n{\n    return max(src, dst);\n}\n\nvec3 invert(in vec3 src, in vec3 dst)\n{\n    return 1.0 - dst;\n}\n\nvec3 invertRGB(in vec3 src, in vec3 dst)\n{\n    return src * (1.0 - dst);\n}\n\nvec3 source(in vec3 src, in vec3 dst)\n{\n\treturn src;\n}\n\nvec3 dest(in vec3 src, in vec3 dst)\n{\n\treturn dst;\n}\n\n// Branchless RGB2HSL implementation from : https://www.shadertoy.com/view/MsKGRW\nvec3 rgb2hsl( in vec3 c )\n{\n    const float epsilon = 0.00000001;\n    float cmin = min( c.r, min( c.g, c.b ) );\n    float cmax = max( c.r, max( c.g, c.b ) );\n\tfloat cd   = cmax - cmin;\n    vec3 hsl = vec3(0.0);\n    hsl.z = (cmax + cmin) / 2.0;\n    hsl.y = mix(cd / (cmax + cmin + epsilon), cd / (epsilon + 2.0 - (cmax + cmin)), step(0.5, hsl.z));\n\n    vec3 a = vec3(1.0 - step(epsilon, abs(cmax - c)));\n    a = mix(vec3(a.x, 0.0, a.z), a, step(0.5, 2.0 - a.x - a.y));\n    a = mix(vec3(a.x, a.y, 0.0), a, step(0.5, 2.0 - a.x - a.z));\n    a = mix(vec3(a.x, a.y, 0.0), a, step(0.5, 2.0 - a.y - a.z));\n    \n    hsl.x = dot( vec3(0.0, 2.0, 4.0) + ((c.gbr - c.brg) / (epsilon + cd)), a );\n    hsl.x = (hsl.x + (1.0 - step(0.0, hsl.x) ) * 6.0 ) / 6.0;\n    return hsl;\n}\n\n// HSL2RGB thanks to IQ : https://www.shadertoy.com/view/lsS3Wc\nvec3 hsl2rgb(in vec3 c)\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 hue(in vec3 src, in vec3 dst)\n{\n    vec3 dstHSL = rgb2hsl(dst);\n    vec3 srcHSL = rgb2hsl(src);\n    return hsl2rgb(vec3(srcHSL.r, dstHSL.gb));\n}\n\nvec3 saturation(in vec3 src, in vec3 dst)\n{\n    vec3 dstHSL = rgb2hsl(dst);\n    vec3 srcHSL = rgb2hsl(src);\n    return hsl2rgb(vec3(dstHSL.r, srcHSL.g, dstHSL.b));\n}\n\nvec3 color(in vec3 src, in vec3 dst)\n{\n    vec3 dstHSL = rgb2hsl(dst);\n    vec3 srcHSL = rgb2hsl(src);\n    return hsl2rgb(vec3(srcHSL.rg, dstHSL.b));\n}\n\nvec3 luminosity(in vec3 src, in vec3 dst)\n{\n    vec3 dstHSL = rgb2hsl(dst);\n    vec3 srcHSL = rgb2hsl(src);\n    return hsl2rgb(vec3(dstHSL.rg, srcHSL.b));\n}\nvec3 blend(in vec3 src, in vec3 dst, in int mode)\n{\n    //if (mode == )  return source(src, dst);\n    //if (mode == )  return dest(src, dst);\n    if (mode == 0)  return screen(src, dst);\n    if (mode == 1)  return multiply(src, dst);\n    if (mode == 2)  return overlay(src, dst);\n    if (mode == 3)  return hardlight(src, dst);\n    if (mode == 4)  return softlight(src, dst);\n    if (mode == 5)  return colorDodge(src, dst);\n    if (mode == 6)  return colorBurn(src, dst);\n    if (mode == 7)  return linearDodge(src, dst);\n    if (mode == 8)  return linearBurn(src, dst);\n    if (mode == 9)  return vividLight(src, dst);\n    if (mode == 10) return linearLight(src, dst);\n    if (mode == 11) return pinLight(src, dst);\n    if (mode == 12) return hardMix(src, dst);\n    if (mode == 13) return subtract(src, dst);\n    if (mode == 14) return divide(src, dst);\n    if (mode == 15) return addition(src, dst);\n    if (mode == 16) return difference(src, dst);\n    if (mode == 17) return darken(src, dst);\n    if (mode == 18) return lighten(src, dst);\n    if (mode == 19) return invert(src, dst);\n    if (mode == 20) return invertRGB(src, dst);\n    if (mode == 21) return hue(src, dst);\n    if (mode == 22) return saturation(src, dst);\n    if (mode == 23) return color(src, dst);\n    if (mode == 24) return luminosity(src, dst);\n    if (mode == 25) return exclusion(src, dst);\n    return vec3(0.0,0.0,0.0);\n}\n\n\nvec3 hsv2rgb( in vec3 c )\n{\n    //c*= vec3(0.01666666666,0.01,0.01); // mapping to photoshop\n    c*= vec3(6.0,1.0,1.0); // mapping to 0..1\n    vec3 rgb = clamp( abs(mod(c.x+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    c*= vec3(0.01666666666,0.01,0.01); // mapping to photoshop\n    //c*= vec3(6.0,1.0,1.0); // mapping to 0..1\n    vec3 rgb = clamp( abs(mod(c.x+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\nvec3 p22( vec3 c )\n{\n    return pow(c,vec3(2.2));\n}\nvec3 p045( vec3 c )\n{\n    return pow(c,vec3(0.454545));\n}\nvec3 plotA ( vec3 c,float time,int idx)\n{\n\nfloat t = 0.5 + 0.5*cos(time*0.075); \n\n//c = p22(c);\n//c*=hsv2rgb(vec3(0.,1.,1.0));\n//c = p045(c);\n//c=1.0-hsv2rgb(vec3(180.,0.5,1.0));\nc= blend(c,hsv2rgb(vec3(180.,0.0,0.75)),idx);\n\nreturn c;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}