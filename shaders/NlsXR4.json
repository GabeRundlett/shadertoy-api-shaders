{
    "Shader": {
        "info": {
            "date": "1625257891",
            "description": "Another scene based on 'The Shining'.",
            "flags": 0,
            "hasliked": 0,
            "id": "NlsXR4",
            "likes": 30,
            "name": "Room 237 (The Shining)",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "horror",
                "shining",
                "movie",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "dean_the_coder",
            "viewed": 6363
        },
        "renderpass": [
            {
                "code": "// 'Room 237 (The Shining)' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/NlsXR4 (YouTube: https://youtu.be/w_RCsMP70-I)\n//\n// Processed by 'GLSL Shader Shrinker' (Shrunk by 1,704 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// Another scene based on 'The Shining'.\n// Weird, as I don't actually like the movie too much!\n// It's in Ready Player One though, and that's great...\n//\n// Tricks to get the performance:\n// - The curtain is actually a flat plane, textured\n//   when the material color is added.\n// - The 'person' doesn't have an SDF - Just a subtle\n//   color added to the curtain material.\n// - The SDF for some objects (E.g. the toilet) is not\n//   calculated if the march point is 'too far away'.\n// - Use of abs() to mirror SDF content.\n//   (E.g. shelves, wall lights, sinks, ...)\n// - Keep the material (lights(...)) code outside of the\n//   marching 'for' loop to reduce compilation times.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// Blackle and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define Z0\tmin(iTime, 0.)\n#define sat(x)\tclamp(x, 0., 1.)\n\nfloat g = 0.,\n      furn = 1.;\n\n#define AA // Comment out this line to speed things up!\n\nstruct Hit {\n\tfloat d;\n\tint id;\n\tvec3 uv;\n};\n\n\n// Thnx Dave_Hoskins - https://www.shadertoy.com/view/4djSRW\nfloat hash31(vec3 p3) {\n\tp3 = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 3.3456);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash21(vec2 p) { return hash31(p.xyx); }\n\nvec4 hash44(vec4 p) { p = fract(p * .1031); p *= p + 3.3456; return fract(p * (p + p)); }\n\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(hash44(h), hash44(h + s.x), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat n21(vec2 p) { return n31(vec3(p, 1)); }\n\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\n#define minH(a)\tif (a.d < h.d) h = a\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdBox2D(vec2 p, vec2 b) {\n\treturn length(max(abs(p) - b, 0.));\n}\n\nfloat sdCyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nvec3 rayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nHit map(vec3 p) {\n\tfloat bath, bulb, lid, bowl, curt,\n\t      d = abs(p.z) - .4;\n\td = min(max(min(min(min(max(d, -(sdBox2D(p.xy, vec2(1.6, 6)) - 1.8)), min(2. - p.z, max(sdBox2D(p.yz - vec2(0, 2.4), vec2(1.78)), 3.5 - abs(p.x)))), sdBox2D(p.yz, vec2(.2, 1.6))), 4.1 - abs(p.x)), -(sdBox2D(p.zy + vec2(5.5, 0), vec2(.7, 5.2)) - 1.8)), 6.5 - abs(p.x));\n\tfloat bathRimCut = smoothstep(1., .5, abs(p.x) - 1.) * .25 + p.y - 1.7;\n\tbath = max(abs(sdBox(p - vec3(0, 2, 1.2), vec3(3.5, 2, .7))), p.y - 1.8);\n\tfurn = min(max(bath, bathRimCut), length(vec2(bath, bathRimCut)) - .08);\n\td = min(d, furn);\n\tvec3 c,\n\t     q = p;\n\tq.x = abs(q.x);\n\tq += vec3(-5.2, -4.6, 2.71);\n\td = max(d, -sdBox(q, vec3(.8, 1.8, .3)));\n\tq.y = abs(q.y + .45) - .5;\n\tfloat chrome = sdBox(q, vec3(.8, .04, .3));\n\tchrome = min(chrome, max(abs(q.z), 4.5 - abs(p.x)));\n\tbulb = length(q.xz - vec2(1.15, -2.2)) - .12;\n\tq.y = p.y - 5.;\n\tchrome = min(chrome, max(bulb, abs(abs(q.y) - .76) - .15));\n\tbulb = max(bulb, abs(q.y) - .6);\n\tq = p - vec3(-5.4, 1.3, -4);\n\tq.x *= .7;\n\tlid = sdCyl(q, vec2(.7, .02)) - .03;\n\tif (lid < 2.) {\n\t\tfurn = min(min(furn, max(sdCyl(q + vec3(0, .12, 0), vec2(.53, .1)) - .18, .03 - lid)), lid);\n\t\tfurn = min(furn, max(length(q.xz) - .4 + sin(q.y * 4. - .4) * .1, q.y));\n\t\tfurn = smin(furn, max(length(q.yz + vec2(.8, 0)) - .2, q.x), .2);\n\t}\n\n\tq = p - vec3(5.5, 2.2, -5.2);\n\tq.z = abs(q.z) - 1.2;\n\tbowl = sdBox(q, vec3(.4, .2, .4));\n\tif (bowl < 1.) {\n\t\tfurn = min(furn, min(sdBox(q, vec3(.8, .15, .8)) - .1, max(bowl - .2, q.y)));\n\t\tfurn = max(furn, .18 - bowl);\n\t}\n\n\td = min(d, furn);\n\tchrome = min(min(chrome, sdBox(q - vec3(1.95, 2, 0), vec3(1, 1.4, .6))), smin(sdCyl(q.xzy + vec3(.8, 0, .7), vec2(.04, .6)), max(length(abs(q.xz + vec2(.2, 0)) - .6) - .04, q.y), .08));\n\td = min(min(d, abs(p.y)), abs(p.y - 8.7));\n\tc = p;\n\tc.x += sin(iTime) * .1 * -(cos((c.y + 3.) * .6) - 1.) * smoothstep(-3.5, 2., c.x);\n\tcurt = max(max(abs(c.z), c.x), 1. - c.y - sin(c.x * 8.) * .06);\n\tq = p - vec3(0, 8.2, -2);\n\tbulb = min(bulb, length(q) - .5);\n\tg += .01 / (.2 + bulb * bulb);\n\tfloat bulbHolder = length(q.xz) - 1.;\n\td = min(d, min(max(bulbHolder, .4 - q.y), max(bulbHolder + .3, .3 - q.y)));\n\tHit h = Hit(d, 1, p);\n\tminH(Hit(chrome, 0, p));\n\tminH(Hit(bulb, 2, p));\n\tminH(Hit(curt, 3, c));\n\treturn h;\n}\n\nvec3 N(vec3 p) {\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * .01).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 ld) {\n\tfloat i, h,\n\t      s = 1.,\n\t      t = .1;\n\tfor (i = Z0; i < 30.; i++) {\n\t\th = map(t * ld + p).d;\n\t\ts = min(s, 15. * h / t);\n\t\tt += h;\n\t\tif (s < .001 || t > 50.) break;\n\t}\n\n\treturn sat(s);\n}\n\nfloat ao(vec3 p, vec3 n, float h) { return map(h * n + p).d / h; }\n\nvec3 vig(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nvec3 lights(vec3 p, vec3 rd, Hit h) {\n\tif (h.id == 2) return vec3(1.6);\n\tif (h.id == 0) return vec3(.01);\n\tvec3 c,\n\t     ld = normalize(vec3(0, 6.5, -5) - p),\n\t     n = N(p);\n\tfloat w, lig,\n\t      ss = 0.,\n\t      gg = g,\n\t      spe = 2.;\n\tvec2 pp;\n\tif (h.id == 1) {\n\t\tif (abs(n.y - 1.) < .01 && p.y < .3) {\n\t\t\tc = vec3(.5, .5, .4) - n21(p.xz * 20.) * .1;\n\t\t\tc -= .2 * smoothstep(.6, 0., furn);\n\t\t\tpp = p.xz;\n\t\t\tpp.y += 5.;\n\t\t\tc = mix(c, vec3(.5, .25, .25), step(abs(min(sdBox2D(pp, vec2(1)), sdBox2D(pp, vec2(2, .2))) - 1.), .15));\n\t\t}\n\t\telse if (p.y < .35 && furn > .01) c = vec3(.05);\n\t\telse if (p.y > 8.6 || p.y > 3. && (abs(p.z + .4) < .1 || abs(abs(p.x) - 4.1) < .01)) c = mix(vec3(.35, .38, .36), vec3(.4, .3, .1), step(p.y, 3.5));\n\t\telse c = vec3(.16, .35, .17) + step(furn, .0015) * .15;\n\t}\n\telse if (h.id == 3) {\n\t\tpp = h.uv.xy;\n\t\tw = sin(pp.x * 8.) * .8 + sin(pp.x * 20.) * sin(pp.y * .4);\n\t\tc = vec3(.5, .76 + w * .07, .5) + step(length(mod(pp - vec2(0, w * .02), .2) - .1), .03) * .15;\n\t\tn.x += w / 4.;\n\t\tn = normalize(n);\n\t\tspe = .04;\n\t\tpp = p.xy;\n\t\tpp.x += sin(iTime * .3 + pp.y) * .08;\n\t\tc = mix(c, -smoothstep(1., 0., min(length(pp * vec2(2, 1) - vec2(-2.8, 3)), length(pp - vec2(-1.3, 2.2)))) * vec3(.6, 1.8, 1.8), .1);\n\t}\n\telse {\n\t\tss = 1.8;\n\t\tc = vec3(.13, .09, .09);\n\t\tc *= .5 + .5 * smoothstep(-.1 - sin(h.uv.y * 3.5) * .1, 0., h.uv.x);\n\t}\n\n\tfloat ao = mix(ao(p, n, .1), ao(p, n, .8), .5),\n\t      l1 = sat(.3 + .7 * dot(ld, n)) * (.7 + .3 * shadow(p, ld)) * (.6 + .4 * ao),\n\t      l2 = sat(n.y * -.3) + pow(sat(dot(rd, reflect(ld, n))), 2.) * spe,\n\t      fre = smoothstep(.7, 1., 1. + dot(rd, n)) * .5;\n\tlig = l1 + l2 * ao + ss;\n\tg = gg;\n\treturn mix(lig * c * vec3(1.8, 1.6, 1.5), vec3(.01), fre);\n}\n\nvec4 march(inout vec3 p, vec3 rd, float s) {\n\tg = 0.;\n\tHit h;\n\tfor (float i = Z0; i < s; i++) {\n\t\th = map(p);\n\t\tif (abs(h.d) < .0015) break;\n\t\tp += h.d * rd;\n\t}\n\n\treturn vec4(g + lights(p, rd, h), h.id);\n}\n\nvec3 scene(vec3 p, vec3 rd) {\n\tvec4 l,\n\t     col = vec4(0);\n\tfloat a = 1.;\n\tfor (int i = 0; i < 3; i++) {\n\t\tl = march(p, rd, 64.);\n\t\tcol += l * a;\n\t\tif (l.w > 0.) break;\n\t\ta *= .9;\n        vec3 n = N(p);\n\t\trd = reflect(rd, n);\n\t\tp += n * .01;\n\t}\n\n\treturn col.rgb;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tfloat t = mod(iTime, 25.),\n\t      f = smoothstep(0., 14.5, t);\n\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n\tvec3 lookAt = mix(vec3(-1. + f, 4, 0), vec3(8, 5, -3), sat(1.2 * pow(sin(sat(f * 1.2 - .2) * 3.141), 4.))),\n\t     ro = vec3(.1, 4, -14. + f * 7.),\n         col = scene(ro, rayDir(ro, lookAt, uv));\n#ifdef AA\n\tif (fwidth(col.r) > .1) {\n\t\tfor (float dx = Z0; dx <= 1.; dx++) {\n\t\t\tfor (float dy = Z0; dy <= 1.; dy++)\n\t\t\t\tcol += scene(ro, rayDir(ro, lookAt, uv + (vec2(dx, dy) - .5) / iResolution.xy));\n\t\t}\n\n\t\tcol /= 5.;\n\t}\n\n#endif\n\tcol.g -= hash21(fc) * .04;\n\tfragColor = vec4(vig(pow(max(vec3(0), col), vec3(.45)) * sat(t), fc), 0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}