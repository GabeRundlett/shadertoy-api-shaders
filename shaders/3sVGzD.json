{
    "Shader": {
        "info": {
            "date": "1569841194",
            "description": "A spinning thing",
            "flags": 0,
            "hasliked": 0,
            "id": "3sVGzD",
            "likes": 1,
            "name": "A Spinning Thing",
            "published": 3,
            "tags": [
                "raymarching",
                "boolean"
            ],
            "usePreview": 0,
            "username": "atsn",
            "viewed": 331
        },
        "renderpass": [
            {
                "code": "mat4 scale(vec3 p){\n\treturn mat4(\n        1./p.x, 0.,  0.,  0.,\n        0.,  1./p.y, 0.,  0.,\n        0.,  0.,  1./p.z, 0.,\n        0.,  0.,  0.,  1.\n    );\n}\nmat4 translate(vec3 p){\n\treturn mat4(\n        1., 0., 0., p.x,\n        0., 1., 0., p.y,\n        0., 0., 1., p.z,\n        0., 0., 0., 1.\n    );\n}\nmat4 rotate(vec3 u,float rad){\n    u = normalize(u);\n\tfloat c = cos(rad);\n    float s = sin(rad);\n    float ic = 1.-c;\n    float is = 1.-s;\n    return mat4(\n        u.x*u.x*ic+c,     u.x*u.y*ic-u.z*s, u.x*u.z*ic+u.y*s, 0.,\n        u.y*u.x*ic+u.z*s, u.y*u.y*ic+c,     u.y*u.z*ic-u.x*s, 0.,\n        u.z*u.x*ic-u.y*s, u.z*u.y*ic+u.x*s, u.z*u.z*ic+c,     0.,\n        0.,               0.,               0.,               1.\n    );\n}\n\nfloat cube(vec4 p){\n\treturn max(abs(p.x),max(abs(p.y),abs(p.z)))-.5;\n}\nfloat sphere(vec4 p){\n\treturn length(p.xyz)-.5;\n}\n\nvoid add(inout float dist,float shape){\n    dist = min(dist,shape);\n}\nvoid remove(inout float dist,float shape){\n    dist = max(dist,-shape);\n}\nfloat world(vec4 p){\n    float dist = 100.;\n    add(dist,cube(p*\n        translate(vec3(0.,0.,-1.3))*\n\t\trotate(vec3(1.,1.,0.),iTime)\n    ));\n    remove(dist,sphere(p*\n        translate(vec3(0.,-0.4,-1.))*\n\t\tscale(vec3(1.,1.7,1.))\n    ));\n    \n    return dist;\n}\n\n#define STEP 0.01\nvec4 normal(vec4 p){\n\treturn vec4(\n        normalize(vec3(\n            world(vec4(p.x+STEP,p.y,p.z,1.)),\n        \tworld(vec4(p.x,p.y+STEP,p.z,1.)),\n        \tworld(vec4(p.x,p.y,p.z+STEP,1.))\n\t\t)),\n        0.\n    );\n}\nvec3 rayCast(vec4 p, vec4 dir, float maxSteps, float minDist, float maxDist){\n    float dist = 0.;\n    vec3 col = vec3(1.);\n    while(maxSteps-->0.){\n        dist = world(p);\n        \n        col += 0.001*dist;\n        \n        p += dir*dist;\n        //col = vec3(dist);\n        //return;\n        if(dist<minDist){\n        \tcol *= vec3(0.8,0.8,0.8);\n            vec4 n = normal(p);\n            float glance = dot(dir.xyz,n.xyz);\n            vec4 dif = dir-n;\n            dir = normalize(dir-dif*2.);\n            p += dir - dif*2.;\n            //col = dif.xyz;\n            //return;\n        }\n        if(dist>maxDist){\n            break;\n        }\n    }\n    //col *= dot(vec3(0.,1.,0.),dir.xyz)*vec3(1.,0.,0.);\n    col *= vec3(pow(-dir.y+dir.z,2.)*.2+.2,0.1,0.1);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 col = rayCast(\n        vec4(uv.x,uv.y,0.,1.),\n        normalize(vec4(uv.x,uv.y,1.,0.)),\n        100.,0.0001,100.\n    );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}