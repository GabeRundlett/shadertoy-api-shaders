{
    "Shader": {
        "info": {
            "date": "1548602882",
            "description": "bot, use arrow keys to move and mouse to look around\n",
            "flags": 48,
            "hasliked": 0,
            "id": "WsjGWR",
            "likes": 9,
            "name": "cleaner bot (interactive)",
            "published": 3,
            "tags": [
                "raymarching",
                "keyboard",
                "bot"
            ],
            "usePreview": 0,
            "username": "movAX13h",
            "viewed": 508
        },
        "renderpass": [
            {
                "code": "// BOT, shadertoy by movAX13h, 2016\n\n#define SHADOW\n//#define REFLECTION\n\n// --\n#define resolution iResolution\n#define mouse iMouse\n\n#define pi2 6.2831853071795\n#define pih 1.5707963267949\n\n\nfloat rand(float x)\n{\n    return fract(sin(x) * 4358.5453123);\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5357);\n}\n\nfloat rand(vec3 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5357 * co.z);\n}\n\nfloat noise(float x)\n{\n    return texture(iChannel1, vec2(x*0.08, 0.3+0.01*iTime)).r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) \n{\t\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox(vec3 p, vec3 b, float r)\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdSegment(vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n\treturn length(p)-r;\n}\n\nfloat sdCylinder(vec3 p, float r)\n{\n\treturn length(p.xz)-r;\n}\n\nfloat sdCappedCylinderZ( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCylinderY(vec3 p, vec2 h)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nvec2 rotate(vec2 p, float a, vec2 offset)\n{\n    p += offset;\n\tvec2 r;\n\tr.x = p.x*cos(a) - p.y*sin(a);\n\tr.y = p.x*sin(a) + p.y*cos(a);\n    r -= offset;\n\treturn r;\n}\n\nvec2 rotate(vec2 p, float a)\n{\n\tvec2 r;\n\tr.x = p.x*cos(a) - p.y*sin(a);\n\tr.y = p.x*sin(a) + p.y*cos(a);\n\treturn r;\n}\n\nfloat opS(float d1, float d2)\n{\n    return max(-d1,d2);\n}\n\nfloat opI(float d1, float d2)\n{\n    return max(d1,d2);\n}\n\n// polynomial smooth min (k = 0.1); by iq\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat time;\nvec3 sunPos = vec3(10.0, 15.0, 25.0);\nvec3 sun;\nfloat focus = 4.0;\nfloat far = 45.0;\nvec4 botInfo;\n\nstruct Hit\n{\n\tfloat d;\n\tvec3 color;\n\tfloat ref;\n\tfloat spec;\n};\n\n    \nHit scene(vec3 q)\n{\n\tHit h = Hit(1.0e6, vec3(0.1), 0.0, 0.0);\n\n    // floor\n    h.d = sdBox(q-vec3(0.2, -0.19, 0.0), vec3(14.0, 0.1, 14.0));\n    \n    float panel = sdBox(q-vec3(0.2, -0.18+0.005*texture(iChannel1, q.xz).r, 0.0), vec3(10.0, 0.1, 10.0));\n    \n    if (panel < h.d)\n    {\n        h.d = panel;\n\t    h.color = vec3(q.y + 0.3-0.2*max(smoothstep(0.9, 0.91, sin(8.0*q.x)), smoothstep(0.9, 0.91, sin(8.0*q.z))));\n    }\n    \n    // bot\n    q -= botInfo.xyz;\n    q.xz = rotate(q.xz, botInfo.a);\n    \n    // body\n    float bodyCyl = smin(sdCylinder(q, 0.5), sdCappedCylinderY(q-vec3(0.0, 0.09,-0.5), vec2(0.13, 0.07)), 0.23);\n    float bodySphere = sdSphere(q-vec3(0.0, -1.08, 0.0), 1.4);\n    float body = opI(bodyCyl,bodySphere);\n    float antenna = sdCappedCylinderY(q-vec3(-0.12, 0.11, -0.45), vec2(0.01, 1.0));\n    float ring = sdCappedCylinderY(q-vec3(0.0, 0.0, 0.0), vec2(0.51, 0.02));    \n    float lense = opS(sdCappedCylinderZ(q-vec3(0.0, 0.11, 0.4), vec2(0.07, 0.2)),\n                      sdCappedCylinderZ(q-vec3(0.0, 0.11, 0.4), vec2(0.08, 0.14)));\n    vec3 glassPos = q-vec3(0.0, 0.11, 0.38);\n\tfloat glass = sdCappedCylinderZ(glassPos, vec2(0.07, 0.14));\n    float led = sdCappedCylinderZ(q-vec3(0.1, 0.16, 0.36), vec2(0.01, 0.14));\n    vec3 qSym = vec3(abs(q.x), q.y, q.z);\n    float stripe = sdBox(qSym-vec3(0.03, 0.3, 0.0), vec3(0.01, 0.03, 0.28));\n \tvec3 qRot = vec3(qSym.x-0.523, rotate(qSym.yz-vec2(0.1, 0.0), 0.7854));\n    float knob = min(sdBox(qRot, vec3(0.005, 0.04, 0.04)), sdBox(qRot-vec3(-0.05, 0.0, 0.0), vec3(0.04, 0.03, 0.03)));\n    \n    // slice (cut-out)\n    float bot = min(h.d, opS(sdBox(q, vec3(1.0, 0.019, 1.0)), body));\n    \n    if (bot < h.d)\n    {\n        h.d = bot;\n\t    h.color = vec3(0.7, 0.7, 0.7);\n        h.spec = 0.6;\n        h.ref = 0.2;\n    }\n    \n    // black ring\n    if (ring < h.d)\n    {\n        h.color = mix(h.color, vec3(0.0), smoothstep(0.0, 0.008, abs(h.d-ring)));\n        h.d = ring;\n        h.spec = 0.2;\n        h.ref = 0.0;\n    }\n    \n    if (lense < h.d)\n    {\n        h.d = lense;\n        h.color = vec3(0.0);\n        h.spec = 0.6;\n        h.ref = 0.0;\n    }\n    \n    if (antenna < h.d)\n    {\n        h.color = vec3(0.0);\n        h.d = antenna;\n        h.spec = 0.8;\n        h.ref = 0.0;\n    }\n    \n    if (stripe < h.d)\n    {\n        h.color = mix(h.color, vec3(0.0), smoothstep(0.0, 0.01, abs(h.d-stripe)));\n    }\n    \n    if (knob < h.d)\n    {\n        h.color = vec3(0.0);\n        h.d = knob;\n        h.spec = 0.2;\n        h.ref = 0.0;\n    }\n    \n    if (glass < h.d)\n    {\n        float a = length(glassPos.xy)/0.07;\n        float b = a*a * (0.4+0.3*sin(18.0*a));\n        h.color = vec3(b-0.1, b-0.1, b+0.04);\n        h.spec = 1.0;\n        h.ref = 0.4;\n        h.d = glass;\n    }\n    \n    if (led < h.d)\n    {\n        h.color = vec3(mod(floor(6.0*iTime),2.0)*step(0.496, q.z), 0.0, 0.0);\n        h.d = led;\n        h.spec = 0.5;\n    }\n    \n\treturn h;\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat c = scene(p).d;\n\tvec2 h = vec2(0.01, 0.0);\n\treturn normalize(vec3(scene(p + h.xyy).d - c, \n\t\t\t\t\t\t  scene(p + h.yxy).d - c, \n\t\t                  scene(p + h.yyx).d - c));\n}\n\n\nvec3 colorize(const vec3 col, const float spec, const vec3 n, const vec3 dir, const in vec3 lightPos)\n{\n\tfloat diffuse = 0.2*max(0.0, dot(n, lightPos));\n\tvec3 ref = normalize(reflect(dir, n));\n\tfloat specular = spec*pow(max(0.0, dot(ref, lightPos)), 3.5);\n\treturn (col + diffuse * vec3(0.9) +\tspecular * vec3(1.0));\n}\n\nvec3 tex3D(vec3 dir)\n{\n    vec3 col = texture(iChannel0, dir).bgr;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\ttime = iTime + 7.0;\n\tsun = normalize(sunPos);\n    \n    vec2 pos = (fragCoord.xy*2.0 - resolution.xy) / resolution.y;\n\t\n\tfloat d = 10.0;\n\tfloat t = 0.6*sin(time*0.3)+1.4;\n\n    botInfo = texture(iChannel2, vec2(0.0));\n    \n\tvec3 cp = botInfo.xyz + vec3(0.0, 5.0, 8.0);\n    \n    if (mouse.z > 0.5)\n\t{\n\t\tvec2 mrel = 3.0*(mouse.xy/resolution.xy-0.5);\n\t\td = 10.0;\n        focus = 9.0 + 4.0*mrel.y;\n\t\tcp = vec3(d*cos(-mrel.x*pih), 6.0*mouse.y/resolution.y, d*sin(-mrel.x*pih));\n\t}\n\t\n    vec3 ct = botInfo.xyz + vec3(0.0, 0.0, -1.0);\n   \tvec3 cd = normalize(ct-cp);\n    vec3 cu  = vec3(0.0, 1.0, 0.0);\n    vec3 cs = cross(cd, cu);\n    vec3 dir = normalize(cs*pos.x + cu*pos.y + cd*focus);\t\n\t\n    Hit h;\n\tvec3 col = vec3(0.16);\n\tvec3 ray = cp;\n\tfloat dist = 0.0;\n\t\n\t// raymarch scene\n    for(int i=0; i < 60; i++) \n\t{\n        h = scene(ray);\n\t\t\n\t\tif(h.d < 0.001) break;\n\t\t\n\t\tdist += h.d;\n\t\tray += dir * h.d * 0.8;\n\n        if(dist > far) \n\t\t{ \n\t\t\tdist = far; \n\t\t\tbreak; \n\t\t}\n    }\n\n\tfloat m = (1.0 - dist/far);\n\tvec3 n = normal(ray);\n\tcol = colorize(h.color, h.spec, n, dir, sun)*m;\n\n\tif (dist < far)\n\t{\t\n\t\t// MIRROR (from obj to reflected normal direction)\n\t\t#ifdef REFLECTION\n\t\tHit h2;\n\t\tdir = reflect(dir, n);\n\t\tvec3 neb = tex3D(dir);\n\t\t\n\t\tvec3 ray2 = ray + dir*0.008;\n\n\t\tdist = 0.0;\n\t\t\n\t\tfor(int i=0; i < 25; i++) \n\t\t{\n\t\t\th2 = scene(ray2 + dir*dist);\n\t\t\tdist += h2.d;\n\t\t\tif (h2.d < 0.001) break;\n\t\t}\n\n\t\tif (dist > far) col += h.ref*neb;\n\t\telse col += h.ref*colorize(h2.color, h2.spec, normal(ray2+dir*dist), dir, sun)*(1.0 - dist/far);\n\t\t#endif\t\n\t\t\n\t\t// HARD SHADOW (from hit to sun)\n\t\t#ifdef SHADOW\n\t\tvec3 ray1 = ray;\n\t\tdir = normalize(sunPos - ray1);\n\t\tray1 += n*0.006;\n\t\t\n\t\tfloat sunDist = length(sunPos-ray1);\n\t\tdist = 0.0;\n\t\t\n\t\tfor(int i=0; i < 25; i++) \n\t\t{\n\t\t\th = scene(ray1 + dir*dist);\n\t\t\tdist += h.d;\n\t\t\tif (abs(h.d) < 0.001) break;\n\t\t}\n\n\t\tcol -= 0.2*smoothstep(0.5, -0.3, min(dist, sunDist)/max(0.0001,sunDist));\n\t\t#endif\n\t}\n\telse col = tex3D(dir);\n    \n\tcol = clamp(col, vec3(0.0), vec3(1.0));\n\tcol = pow(col, vec3(2.5, 2.5, 2.2)) * 2.3;\n\tcol = pow(col, vec3(1.0 / 2.2)); // gamma\t\n\t\n\tfragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nconst float MOVE_SPEED = 4.0;\nconst float ROT_SPEED = 4.0;\n\nbool isKeyPressed(float key)\n{\n\treturn texture(iChannel3, vec2(key, 0.5/3.0) ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 col = vec4(0.0);\n    \n    if (fragCoord.x < 1.0 && fragCoord.y < 1.0) \n    {\n        col = texture(iChannel0, uv);\n        vec2 fwd = MOVE_SPEED * iTimeDelta * vec2(sin(col.a), cos(col.a));\n        \n        if (isKeyPressed(KEY_LEFT)) col.a += ROT_SPEED * iTimeDelta;\n        if (isKeyPressed(KEY_RIGHT)) col.a -= ROT_SPEED * iTimeDelta;\n        \n        if (isKeyPressed(KEY_UP)) col.xz += fwd;\n        if (isKeyPressed(KEY_DOWN)) col.xz -= fwd;\n        \n        col.xz = min(col.xz, 9.3);\n        col.xz = max(col.xz, -9.3);\n    }\n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}