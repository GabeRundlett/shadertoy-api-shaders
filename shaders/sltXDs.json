{
    "Shader": {
        "info": {
            "date": "1640032338",
            "description": "hmm",
            "flags": 32,
            "hasliked": 0,
            "id": "sltXDs",
            "likes": 23,
            "name": "Iso Hitomezashi Stitch [Day 732]",
            "published": 3,
            "tags": [
                "shane",
                "mdtmjvm",
                "stitch",
                "isogrid"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 423
        },
        "renderpass": [
            {
                "code": "// https://www.youtube.com/watch?v=JbfhzlMk2eY&ab_channel=Numberphile\n// ^ Hitomezashi Stitch Patterns - Numberphile ^\n\n// Inspired by Shane's awesome style\n// But the code is unreadable and not a good way to go about it :D\n\n// But the basic concept of the isogrid construction is (and this method is pretty good):\n// repeating space on each of the three \"axes\" of the triangle. \n// An axis is defined by a direction, so your uv in one axis would be mod(dot(uv,axis),1.).\n// dot(uv,axis) being line/plane SDF\n\n// Then a bunch of hacks to render the lines of neighboring triagnles.\n// I tried to colour them but failed miserably.\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p,a) - 0.5*a\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    //fragCoord += 250.*noise(vec3(uv*2.5,5.))/iResolution.xy;\n    col = texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    col = vec3(1)*pow(col,vec3(0.85,0.96,1.1));\n    \n    float no = noise(vec3(uv*2.,35.));\n    //col = mix(col,vec3(0),smoothstep(0.,0.5,max(noise(vec3(uv*2.2 + 0.1,35.)) - 0.5,0.))*0.4);\n    \n    //col = mix(col,vec3(1),smoothstep(0.,4.,max(no - 0.5,0.))*.4);\n    \n    col *= 1. - pow(dot(uv,uv*0.6),2.)*2.;\n    \n    //col += min(no - 0.5,0.)*0.02;\n    \n    float n1d = texelFetch(iChannel2,ivec2(mod(fragCoord + vec2(float(iFrame)*0.4,0.),256.)),0).x*0.5;\n    vec3 n  = texelFetch(iChannel2,ivec2(mod(fragCoord + n1d*200. ,256.)),0).xyz*0.6;\n    \n    \n    //C = smoothstep(0.,1.,C);z\n    \n    //col.xyz = pow(max(col.xyz,0.), vec3(0.55) + n*0.1);\n    \n    col.xyz += smoothstep(1.,0.,length(col))*n*0.05;\n    \n    col.xyz -= smoothstep(0.,1.,length(col))*n*0.01;\n    \n    //col = col/(col*0.5 + 0.7);\n    \n    \n    col = pow(clamp(col,0.01,1.),vec3(0.4545));\n\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define third 1./3.\n\n#define pmod(p,a) mod(p,a) - 0.5*a\n\n#define pmodTri(p,a) (mod(p,a) - third*a)\n\n#define dmin(da,db) (da.x) < (db.x) ? (da) : (db)\n\n#define dminm(da,db,bm) (da.x) < (db) ? (da) : vec2(db,bm)\n\n#define draw(col,newCol, d) col = mix(col,newCol,smoothstep(pxSz,0.,d))\n\n// Dave Hoskins's hash without sine.\nfloat r21(float a, float b)\n{\n    vec2 p = vec2(a,b);\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\n// Mirror point across axis.\nvec2 refl(vec2 p, vec2 axis){\n    float d = dot(p,axis);\n    if (d < 0.)\n        return p;\n    else\n        return p - axis*2.*d;\n}\n\n// Probability on each axis of even or odd distribution.\nvec3 probabilities;\n\n\nbvec3 getShouldDraw(vec3 idline, vec3 id){\n    idline = floor(idline);\n    id = floor(id);\n    bvec3 shouldDraw = bvec3(\n        r21(idline.x,10.) < probabilities.x,\n        r21(idline.y,20.) < probabilities.y,\n        r21(idline.z,30.) < probabilities.z\n    );\n    \n    if(mod(id.z,2.) == 0.)\n        shouldDraw.y = !shouldDraw.y;\n    if(mod(id.y,2.) == 0.)\n        shouldDraw.z = !shouldDraw.z;\n    if(mod(id.y,2.) == 0.)\n        shouldDraw.x = !shouldDraw.x;\n    return shouldDraw;\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uvn = U/R.xy;\n    \n    vec2 uv = (U - 0.5*R)/R.y;\n    \n    probabilities = vec3(\n        iMouse.x/iResolution.x, iMouse.y/iResolution.y, 0.5\n    );\n    \n    {\n        // value noise\n        float t = 1.;\n        float env = fract(iTime/t);\n        env = pow(env,7.);\n        float fl = floor(iTime/t);\n        float vn = mix(hash11(fl),hash11(fl+1.),env);\n        probabilities.z = vn;\n\n    }\n    \n    uv *= 15. - sin(iTime)*0.4;\n    \n    uv.x += iTime*1.45;\n    \n    uv += noise(vec3(uv*0.1,0.))*0.01;\n    uv += noise(vec3(uv*rot(0.25*pi)*0.6 + 4.,0.))*0.01;\n    float pxSz = fwidth(uv.y)*1.1;\n    \n    vec3 col = vec3(0);\n\n    float md = 1.;\n    \n    vec2 axisA = vec2(0,1);\n    vec2 axisB = vec2(0,1)*rot(pi*2./3.);\n    vec2 axisC = vec2(0,1)*rot(-pi*2./3.);\n    \n    vec3 uvtri = vec3(dot(uv,axisA),dot(uv,axisB),dot(uv,axisC));\n    \n    vec3 id = floor(uvtri/md);\n    \n    vec2 uvlocal = uv - (axisA*id.x + axisB*id.y + axisC*id.z)*third*2.;\n    \n    vec3 idlineuv = (uvtri + (third)*0.5)/md;\n    vec3 idline = floor(idlineuv);\n    \n    //float pattcnt = 17.;\n    \n    vec3 flips = step(1.0,mod(uvtri,2.0))*2.0-1.0;\n    float flip = flips.x * flips.y * flips.z;\n\n    bool flipped = false;\n    if(mod(id.x + id.y + id.z,2.) == 0.){\n        //uvtri = -pmodTri(uvtri,-md);\n        flipped = true;\n    } else{\n        //uvtri = pmodTri(uvtri,md);\n    }\n    \n\n    //col += vec3(0.8,0.4,0.7) + 0.5*sin(vec3(1,2.5,1.6) + id*vec3(0.5,0.1,0.1)*0.7 + id.x + id.y + id.z);\n    col = vec3(1);    \n    \n    \n     \n     {   \n        float linew = 0.024;\n        float d = 10e5;\n\n        \n        bvec3 shouldDraw = getShouldDraw(idline, id);\n        \n        \n        bvec3 skip = bvec3(true);\n        \n        \n        \n        vec3 lineCol = vec3(0);\n        \n        // draw lines\n        \n        float dx = abs(dot(uvlocal,axisA) + third * flip) - linew;\n        float dy = abs(dot(uvlocal,axisB) + third * flip) - linew;\n        float dz = abs(dot(uvlocal,axisC) + third * flip) - linew;\n        \n        if(skip.x && shouldDraw.x){\n            d = dx;\n        }\n        \n        if(skip.y && shouldDraw.y){\n            d = min(dy,d);\n        }\n        \n        if(skip.z && shouldDraw.z){\n            d = min(dz,d);\n        }\n        \n        float oldd = d;\n        float dd = min(dx,min(dy,dz));\n        float ddb = dd;\n        \n        d = pmod(d + 0.4,0.2);\n        d = abs(d);\n        \n        ddb = pmod(ddb + 0.4,0.2);\n        ddb = abs(ddb);\n        \n        draw(col,(sin(vec3(10.4,5.2,5.5) + sin(id.x*2. + sin(id.y)*6. + iTime*10.))*0.2 + 0.6)*0.7, d - 0.001);\n        \n        \n        if(oldd > 1.)\n            draw(col,(sin(vec3(0.4,1.2,9.5) + sin(uvtri.x*2. + sin(uvtri.y)*6. + iTime*10.))*0. + 0.7)*1., ddb - 0.02);\n        \n        \n        \n        col=mix(col,col*col*col*0.4, smoothstep(0.4,0.,oldd)*0.1);\n        \n        draw(col,lineCol*0., oldd);\n        \n    }\n    {\n        float dotw = 0.1 + sin(idline.y + iTime + sin(idline.z))*0.05;\n        // dots center\n        float d = length(uvlocal) - dotw*0.1;\n        draw(col,vec3(0),d);\n        \n        // dots edges\n        vec2 p = refl(uvlocal,axisA);\n        //p = uvlocal;\n        //p = refl(p,axisB);\n        p = refl(uvlocal,axisC);\n        \n        d = length(p - axisA*third*2.) - dotw;\n        //draw(col,vec3(0),d);\n        d = min(d,length(p - axisB*third*2.) - dotw);\n        //draw(col,vec3(0),d);\n        d = min(d,length(p + axisC*third*2.) - dotw);\n        \n        draw(col,vec3(0),d);\n        \n        \n    }\n    \n    col = mix(col,col*col*col*0.5,smoothstep(0.445,0.3,texture(iChannel1,uv*0.0025).x)*0.5);\n    \n    col = mix(col,vec3(0),clamp(noise(vec3(uv*3.,0.)),0.,1.)*0.1);\n    //col = exp(-col*4.);\n    C = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define R iResolution.xy\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat noise(vec3 p_){\n    float n = 0.;\n    float amp = 1.;\n    vec4 p = vec4(p_,11.);\n    p.xw *= rot(1.4);\n    p.x *= 57.;\n    for(float i = 0.; i < 5.; i++){\n        p.yz *= rot(.5);\n        p.xz *= rot(2.5 + i);\n        p.wy *= rot(2.5-i);\n        p += cos(p*1./amp + vec4(3,2,1,1.) )*amp*.3;\n        n += dot(sin(p),cos(p))*amp;\n    \n        amp *= 0.7;\n        p *= 1.5;\n    }\n    \n    //n = sin(n*1.);\n    n = abs(n);\n    return n;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}