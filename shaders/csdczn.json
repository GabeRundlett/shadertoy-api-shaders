{
    "Shader": {
        "info": {
            "date": "1694866347",
            "description": "The Joukowsky transform acting on a circle. Mouse sets circle parameters.",
            "flags": 16,
            "hasliked": 0,
            "id": "csdczn",
            "likes": 28,
            "name": "Joukowsky Transform",
            "published": 3,
            "tags": [
                "complex",
                "transform",
                "joukowsky"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 395
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Joukowsky Transform, mla, 2023\n//\n// A circle under the Joukowsky transform. This is double branched so both\n// branches are shown, in different colours.\n//\n// Mouse sets circle location\n// c: show/hide untransformed circle\n// g: show/hide grid axes\n// x: toggle transform\n// z: zoom out\n//\n////////////////////////////////////////////////////////////////////////////////\n\nvec3 dogrid(vec3 color, vec2 w, float px, vec3 c) {\n  vec2 uv = rotate(w,0.25*iTime);\n  float ldist = length(uv);\n  ldist *= 10.0;\n  ldist -= round(ldist);\n  ldist /= 10.0;\n  ldist = abs(ldist);\n  float t = atan(uv.y,uv.x);\n  t /= PI;\n  t *= 20.0;\n  t = round(t);\n  t /= 20.0;\n  t *= PI;\n  ldist = min(ldist,line(uv,vec2(0),vec2(cos(t),sin(t))));\n  color = mix(c,color,0.75+0.25*smoothstep(0.002,0.004+px,abs(ldist)));\n  return color;\n}\n\nfloat R = 1.2;\n\nvec3 docircle(vec3 color, vec2 w, float px, vec3 c) {\n  float ldist = length(w)-R;\n  color = mix(c,color,smoothstep(0.0,px,abs(ldist)-0.01));\n  return color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  float scale = 1.5;//exp(iTime);\n  if (key(CHAR_Z)) scale *= 2.0;\n  vec2 z = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  vec2 ci = vec2(0,1);\n  z *= scale;\n  vec2 t = cpow(cmul(z,z)-vec2(4,0),0.5);\n  vec2 w1 = z, w2 = z;\n  if (!key(CHAR_X)) {\n    w1 = 0.5*(z-t); // Inverse Joukowsky\n    w2 = 0.5*(z+t); // The other branch\n  }\n  vec2 mousepos = 0.4*vec2(cos(0.5*iTime),sin(0.49*iTime)); // Circle location\n  if (iMouse.x > 0.0) mousepos = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  w1 -= mousepos; w2 -= mousepos;\n  vec3 color = vec3(0);\n  if (!key(CHAR_G)) {\n    float mdist = min(abs(z.x),abs(z.y));\n    color = mix(vec3(1),color,0.75+0.25*smoothstep(0.01,0.02,mdist));\n    float pdist = distance(abs(z),vec2(round(abs(z.x)),0));\n    color = mix(vec3(1),color,0.5+0.5*smoothstep(0.04,0.05,pdist));\n  }\n  if (!key(CHAR_C)) color = docircle(color,z-mousepos,fwidth(z.x),vec3(0.4));\n  float px1 = fwidth(w1.x);\n  float px2 = fwidth(w2.x);\n  color = dogrid(color,w1,px1,vec3(0,1,0));\n  color = dogrid(color,w2,px2,vec3(0,1,1));\n  color = docircle(color,w1,px1,vec3(1,1,0));\n  color = docircle(color,w2,px2,vec3(1,0,0));\n  color = pow(color, vec3(0.4545));\n  if (alert) color.g = 1.0;\n  fragColor = vec4(color,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float PI =  3.141592654;\nconst float TWOPI =  2.0*PI;\n\n// Debugging aids\nbool alert = false;\nvoid assert(bool test) {\n  if (!test) alert = true;\n}\n//#define assert(x)\n\nvec2 rotate(float t) {\n  return normalize(vec2(cos(t),sin(t)));\n}\n\nvec2 rotate(vec2 p, float t) {\n  vec2 r = rotate(t);\n  r = normalize(r);\n  return p * r.x + vec2(p.y, -p.x) * r.y;\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\nfloat line(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  return length(p-b*h);\n}\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_M = 77;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_X = 88;\nconst int CHAR_Z = 90;\n\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n\nvec2 cmul(vec2 z, vec2 w) {\n  return vec2 (z.x*w.x-z.y*w.y, z.x*w.y+z.y*w.x);\n}\n\nvec2 cinv(vec2 z) {\n  float t = dot(z,z);\n  return vec2(z.x,-z.y)/t;\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n  return cmul(z,cinv(w));\n}\n\nvec2 clog(vec2 z) {\n  float r2 = dot(z,z);\n  return vec2(0.5*log(r2),atan(z.y,z.x));\n}\n\nvec2 clog(float x) {\n  return clog(vec2(x,0));\n}\n\nvec2 cexp(vec2 z) {\n  // If cos and sin were perfect we wouldn't need normalize\n  return exp(z.x)*normalize(vec2(cos(z.y),sin(z.y)));\n}\n\nvec2 cexp(float k, vec2 z) {\n  // return k^z\n  return cexp(cmul(clog(k),z));\n}\n\nvec2 catan(vec2 z) {\n  vec2 iz = vec2(-z.y,z.x);\n  vec2 t = clog(cdiv(vec2(1,0)-iz,vec2(1,0)+iz));\n  return 0.5*vec2(-t.y,t.x);\n}\n\nvec2 catanh(vec2 z) {\n  return 0.5*clog(cdiv(vec2(1,0)+z,vec2(1,0)-z));\n}\n\nvec2 cpow(vec2 z, vec2 w) {\n  return cexp(cmul(clog(z),w));\n}\n\nvec2 cpow(vec2 z, float x) {\n  return cexp(x*clog(z));//+vec2(0,-TWOPI));\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}