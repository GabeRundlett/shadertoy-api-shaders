{
    "Shader": {
        "info": {
            "date": "1718074998",
            "description": "Homework for 0510029 コンピュータグラフィクス論\n48-246640\nI've combined a couple of homework assignments and commented out different things in the main function.",
            "flags": 0,
            "hasliked": 0,
            "id": "4XKGRt",
            "likes": 0,
            "name": "コンピュータグラフィクス論-LiRuoyu",
            "published": 3,
            "tags": [
                "homework"
            ],
            "usePreview": 0,
            "username": "RinPV2",
            "viewed": 75
        },
        "renderpass": [
            {
                "code": "struct Ray\n{\n    vec3 org;\n    vec3 dir;\n};\n\nstruct Hit\n{\n    float distanceToHitpoint;\n    vec3 normal;\n    vec3 color;   // add color\n    int material; // add material\n};\n\nstruct DistanceState\n{\n    float distance;\n    vec3 color;\n    int material; // add material\n};\n\nconst float PI = 3.14159265358979323846;\n\nfloat rand(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453); }\nfloat randCnt = 0.0;\nfloat random()\n{\n    vec2 seed = vec2(randCnt, PI);\n    randCnt += 1.0;\n    return rand(seed);\n}\n\nfloat FilmWidth() { return iResolution.x / 100.0; }\nfloat FilmHeight() { return iResolution.y / 100.0; }\nfloat FilmDistance() { return 8.0; }\n\nfloat radius = 5.0;\n\nvec3 CameraFrom()\n{\n    if (iMouse.z > 0.0)\n    {\n        vec2 deltaMouse = iMouse.xy - iMouse.zw;\n        float rotationAngle = deltaMouse.x * 0.05;\n        return vec3(radius * cos(rotationAngle), 2.0,\n                    radius * sin(rotationAngle));\n    }\n    return vec3(radius * cos(iTime * 0.3), 2.0, radius * sin(iTime * 0.3));\n}\nvec3 CameraTo() { return vec3(0.2, 0.7, 0.2); }\nvec3 CameraUp() { return vec3(0.0, 1.0, 0.0); }\n\nfloat LargeFloat() { return 1e+6; }\nconst int MAX_STEPS = 500;\nconst float EPSILON = 0.001;\nconst float MAX_DISTANCE = 1000.0;\n\nconst int Diffuse = 0;\nconst int Mirror = 1;\n\nfloat distanceToSphere(vec3 p, vec3 center, float radius)\n{\n    return length(p - center) - radius;\n}\n\nfloat distanceToPlane(vec3 p, vec3 n, float h) { return dot(p, n) + h; }\n\nfloat distanceToTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat distanceToCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ba = b - a;\n    vec3 pa = p - a;\n    float baba = dot(ba, ba);\n    float paba = dot(pa, ba);\n    float x = length(pa * baba - ba * paba) - r * baba;\n    float y = abs(paba - baba * 0.5) - baba * 0.5;\n    float x2 = x * x;\n    float y2 = y * y * baba;\n    float d = (max(x, y) < 0.0)\n                  ? -min(x2, y2)\n                  : (((x > 0.0) ? x2 : 0.0) + ((y > 0.0) ? y2 : 0.0));\n    return sign(d) * sqrt(abs(d)) / baba;\n}\n\nfloat distanceToEllipsoid(vec3 p, vec3 center, vec3 r)\n{\n    vec3 q = (p - center) / r;\n    return length(q) * (length(q) - 1.0) / length(q / r);\n}\n\nDistanceState HitState(vec3 p)\n{\n    vec3 colors[5] =\n        vec3[](vec3(1.0, 0.5, 0.5), vec3(1.0, 1.0, 1.0), vec3(0.2, 1.0, 1.0),\n               vec3(0.3, 1.0, 0.0), vec3(0.5, 0.1, 0.7));\n    float distances[5] = float[](\n        distanceToSphere(p, vec3(0.5, 2.1, -0.8), 1.0),\n        distanceToPlane(p, vec3(0.0, 1.0, 0.0), 2.0),\n        distanceToTorus(p, vec2(1.0, 0.3)),\n        distanceToCylinder(p, vec3(-0.2, -1.5, -0.6), vec3(0.2, 1.5, 0.6), 0.3),\n        distanceToEllipsoid(p, vec3(-2.0, 0.5, 1.2), vec3(0.6, 1.2, 0.3)));\n    int materials[5] = int[](0, 1, 0, 1, 0);\n\n    float minDistance = distances[0];\n    vec3 color = colors[0];\n    int material = 0;\n    for (int i = 1; i < 5; ++i)\n    {\n        if (distances[i] < minDistance)\n        {\n            minDistance = distances[i];\n            color = colors[i];\n            material = i;\n        }\n    }\n    return DistanceState(minDistance, color, material);\n}\n\nvec3 calculateNormal(vec3 p)\n{\n    const vec3 eps = vec3(EPSILON, 0.0, 0.0);\n    float dist = HitState(p).distance;\n    vec3 normal = normalize(vec3(\n        HitState(p + eps.xyy).distance - dist,\n        HitState(p + eps.yxy).distance - dist,\n        HitState(p + eps.yyx).distance - dist));\n    return normal;\n}\n\nbool sphereTracing(Ray ray, out Hit hit)\n{\n    float t = 0.0;\n    for (int i = 0; i < MAX_STEPS; ++i)\n    {\n        vec3 p = ray.org + t * ray.dir;\n        DistanceState dc = HitState(p);\n        if (dc.distance < EPSILON)\n        {\n            hit.distanceToHitpoint = t;\n            hit.normal = calculateNormal(p);\n            hit.color = dc.color;\n            hit.material = dc.material;\n            return true;\n        }\n        if (t > MAX_DISTANCE)\n            break;\n        t += dc.distance;\n    }\n    return false;\n}\n\n// 正規直交基底を計算する関数の例\nvoid createOrthoNormalBasis(vec3 from, vec3 to, vec3 up, out vec3 u, out vec3 v,\n                            out vec3 w, out vec3 e)\n{\n    w = normalize(from - to);\n    u = normalize(cross(up, w));\n    v = cross(w, u);\n    e = from;\n}\n\nvec3 convertToCameraCoordinateSystem(vec2 pixelCoordinate)\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    float filmWidth = FilmWidth();\n    float filmHeight = FilmHeight();\n    float filmDistance = FilmDistance();\n\n    vec2 ndc = (pixelCoordinate - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 positionOnSensor =\n        vec2(ndc.x * filmWidth, ndc.y * filmHeight * aspectRatio);\n    vec3 cameraCoordinate =\n        vec3(positionOnSensor.x, positionOnSensor.y, -filmDistance);\n\n    return cameraCoordinate;\n}\n\nRay generateCameraRay(vec2 pixelCoordinate)\n{\n    vec3 cameraCoordinate = convertToCameraCoordinateSystem(pixelCoordinate);\n    vec3 u, v, w, e;\n    createOrthoNormalBasis(CameraFrom(), CameraTo(), CameraUp(), u, v, w, e);\n    vec3 worldCoordinate = e + cameraCoordinate.x * u + cameraCoordinate.y * v -\n                           FilmDistance() * w;\n\n    Ray ray;\n    ray.org = CameraFrom();\n    ray.dir = normalize(worldCoordinate - ray.org);\n\n    return ray;\n}\n\nvec3 lightDir = vec3(0.9, 0.9, 0.6);\n\n// ----------------------------------------------\n// Shadowing\nbool isInShadow(vec3 point, vec3 lightDir)\n{\n    Ray shadowRay;\n    shadowRay.org = point + lightDir * EPSILON * 40.0;\n    shadowRay.dir = normalize(lightDir);\n\n    Hit shadowHit;\n    return sphereTracing(shadowRay, shadowHit);\n}\n\nvec3 computeIrradiance(Ray ray, Hit hit)\n{\n    vec3 normal = hit.normal;\n    vec3 point = ray.org + hit.distanceToHitpoint * ray.dir;\n    vec3 lightDirection = normalize(lightDir);\n\n    bool shadowed = isInShadow(point, lightDirection);\n\n    if (shadowed)\n    {\n        return hit.color * 0.3;\n    }\n    else\n    {\n        return hit.color;\n    }\n}\n\n// Shading\nconst vec3 lightColor = vec3(1.0, 1.0, 1.0);\nconst float lightPower = 3.2;\nconst vec3 ambientColor = vec3(0.2, 0.2, 0.2);\nconst vec3 diffuseColor = vec3(0.4, 0.4, 0.4);\nconst vec3 specColor = vec3(1.0, 1.0, 1.0);\nconst float shininess = 120.0;\nconst float screenGamma = 2.2;\nconst vec3 mirrorReflectance = vec3(0.8);\n// HalfLambert\nvec3 halfLambertShade(Ray ray, Hit hit)\n{\n    float diffuse = max(dot(hit.normal, lightDir), 0.0);\n\n    float halfLambert = diffuse * 0.5 + 0.5;\n\n    vec3 finalColor = hit.color * halfLambert + ambientColor;\n\n    return finalColor;\n}\n\n// Brdf\n// Unknown error: ERROR: Recursive function call in the following call chain:mainImage) -> brdfShade) -> brdfShade)\nRay computeReflectionRay(Ray ray, Hit hit)\n{\n    Ray reflectRay;\n    reflectRay.org = ray.org + ray.dir * hit.distanceToHitpoint;\n    reflectRay.dir = normalize(reflect(ray.dir, hit.normal));\n    return reflectRay;\n}\n\nvec3 brdfShade(Ray ray, Hit hit)\n{\n    if (hit.material == Diffuse)\n    {\n        return halfLambertShade(ray, hit);\n    }\n    else if (hit.material == Mirror)\n    {\n        Ray reflectRay = computeReflectionRay(ray, hit);\n        Hit hit2;\n        if (sphereTracing(reflectRay, hit2))\n        {\n            //vec3 reflectColor = brdfShade(reflectRay, hit2);\n            //return reflectColor * mirrorReflectance;\n        }\n    }\n    return vec3(0.0);\n}\n\n// Blinn-Phong\nvec3 blinnPhongShade(Ray ray, Hit hit)\n{\n    vec3 normal = hit.normal;\n    float distance = length(lightDir);\n    distance = distance * distance;\n    lightDir = normalize(lightDir);\n\n    vec3 irradianceColor = computeIrradiance(ray, hit);\n\n    float lambertian = max(dot(lightDir, normal), 0.0);\n    float specular = 0.0;\n\n    if (lambertian > 0.0)\n    {\n        vec3 viewDir = normalize(-ray.dir);\n\n        vec3 halfDir = normalize(lightDir + viewDir);\n        float specAngle = max(dot(halfDir, normal), 0.0);\n        specular = pow(specAngle, shininess);\n    }\n    vec3 colorLinear =\n        ambientColor * irradianceColor +\n        diffuseColor * irradianceColor * lambertian * lightColor * lightPower / distance +\n        specColor * specular * lightColor * lightPower / distance;\n    // apply gamma correction (assume ambientColor, diffuseColor and specColor\n    // have been linearized, i.e. have no gamma correction in them)\n    vec3 colorGammaCorrected = pow(colorLinear, vec3(1.0 / screenGamma));\n    // use the gamma corrected color in the fragment\n    return colorGammaCorrected;\n}\n\n// Ambient Occlusion\n// Importance sampling\nvec3 sampleHemisphere(vec3 normal, out float pdf)\n{\n    float x = random();\n    float y = random();\n    float phi = 2.0 * PI * y;\n\n    // uniformly sample hemisphere (z-up)\n    float z = sqrt(x);\n    float r = sqrt(1.0 - z * z);\n    vec3 dir_loc = vec3( // direction in normal coordinate\n        r * cos(phi),\n        r * sin(phi),\n        z);\n\n    pdf = z / PI; // Cosine-weighted PDF\n\n    vec3 u, v, w;\n    w = normalize(normal);\n    u = normalize(cross(abs(w.x) > 0.0 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0), w));\n    v = cross(w, u);\n\n    vec3 dir_out = normalize(mat3(u, v, w) * dir_loc);\n    return dir_out;\n}\n\nfloat calAmbientOcclusion(vec3 pos, vec3 normal)\n{\n    const int num_sample_ao = 32;\n    float sum = 0.0;\n    for (int i_sample = 0; i_sample < num_sample_ao; ++i_sample)\n    {\n        float pdf;\n        vec3 sample_dir = sampleHemisphere(normal, pdf);\n        vec3 sample_pos = pos + normal * EPSILON;\n\n        Ray sampleRay;\n        sampleRay.org = sample_pos;\n        sampleRay.dir = sample_dir;\n\n        Hit sampleHit;\n        if (!sphereTracing(sampleRay, sampleHit))\n        {\n            sum += dot(sample_dir, normal) / pdf / PI;\n        }\n    }\n    return sum / float(num_sample_ao);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    Ray ray = generateCameraRay(fragCoord);\n\n    Hit hit;\n    if (sphereTracing(ray, hit))\n    {\n        // vec3 shadedColor = halfLambertShade(ray, hit);\n        \n        // Recursive functions are not allowed to compile, so mirror reflection is commented out.\n        // vec3 shadedColor = brdfShade(ray, hit);\n        \n        vec3 shadedColor = blinnPhongShade(ray, hit);\n        fragColor = vec4(shadedColor, 0.0);\n        \n        // AO works, still some bugs and the page will get stuck. Need to del some SDF :)\n        // float ao = calAmbientOcclusion(ray.org + ray.dir * hit.distanceToHitpoint, hit.normal);\n        // fragColor = vec4(mix(shadedColor, shadedColor*ao, 0.3), 0.0);\n\n        // debug\n        // vec3 normal = hit.normal * 0.5 + 0.5;\n        // fragColor = vec4(normal, 1.0);\n        // fragColor = vec4(mix(normal,vec3(ao),0.5), 0.0);\n    }\n    else\n    {\n        fragColor = vec4(0.0);\n    }\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}