{
    "Shader": {
        "info": {
            "date": "1587590218",
            "description": "Interesting pattern that stems from just adding a bunch of point lights that are each orbit a little faster",
            "flags": 0,
            "hasliked": 0,
            "id": "tdffzn",
            "likes": 21,
            "name": "Swirly fire thing",
            "published": 3,
            "tags": [
                "raytracedfire"
            ],
            "usePreview": 0,
            "username": "suyoku",
            "viewed": 769
        },
        "renderpass": [
            {
                "code": "// Created by Christopher Wallis\n#define PI 3.14\n#define SCENE_MAX_T 900.0\n\n#define CHECKER_FLOOR_MATERIAL_ID 0\n#define LAMP_MATERIAL_ID 1\n#define NUM_MATERIALS 2\n\n#define NUM_LIGHTS 20\n\n#define INVALID_MATERIAL_ID int(-1)\n#define LARGE_NUMBER 1e20\n#define EPSILON 0.0001\n\nstruct CameraDescription\n{\n    vec3 Position;\n    vec3 LookAt;    \n\n    float LensHeight;\n    float FocalDistance;\n};\n    \nstruct OrbLightDescription\n{\n    vec3 Position;\n    float Radius;\n    vec3 LightColor;\n};\n    \nCameraDescription Camera = CameraDescription(\n    vec3(0, 20, -250),\n    vec3(0, 5, 0),\n    2.0,\n    7.0\n);\n\nOrbLightDescription GetLight(int lightIndex)\n{\n    float theta = iTime * 0.2 * (float(lightIndex) + 1.0f);\n    float radius = 10.0f + float(lightIndex) * 2.5;\n    \n    OrbLightDescription orbLight;\n    orbLight.Position = vec3(radius * cos(theta), 3.0 + sin(theta * 2.0) * 2.5, radius * sin(theta));\n    orbLight.LightColor = vec3(20.0, 10.0, 0.4);\n    orbLight.Radius = 1.0f;\n\n    return orbLight;\n}\n\n#define MATERIAL_IS_LIGHT_SOURCE 0x1\n\nstruct Material\n{\n    vec3 albedo;\n    vec3 emissive;\n    int flags;\n};\n    \nMaterial NormalMaterial(vec3 albedo, int flags)\n{\n    return Material(albedo, vec3(0), flags);\n}\n\nbool IsLightSource(in Material m)\n{\n    return (m.flags & MATERIAL_IS_LIGHT_SOURCE) != 0;\n}\n\nMaterial GetMaterial(int materialID, vec3 position)\n{\n    Material materials[NUM_MATERIALS];\n\tmaterials[CHECKER_FLOOR_MATERIAL_ID] = NormalMaterial(vec3(0.6, 0.6, 0.7), 0);\n\tmaterials[LAMP_MATERIAL_ID] = NormalMaterial(GetLight(0).LightColor, MATERIAL_IS_LIGHT_SOURCE);\n    \n    Material mat;\n    if(materialID < int(NUM_MATERIALS))\n    {\n        mat = materials[materialID];\n    }\n    else\n    {\n        // Should never get hit\n   \t\treturn materials[0];\n    }\n    \n    if(materialID == CHECKER_FLOOR_MATERIAL_ID)\n    {\n        vec2 uv = position.xz / 13.0;\n        uv = vec2(uv.x < 0.0 ? abs(uv.x) + 1.0 : uv.x, uv.y < 0.0 ? abs(uv.y) + 1.0 : uv.y);\n        if((int(uv.x) % 2 == 0 && int(uv.y) % 2 == 0) || (int(uv.x) % 2 == 1 && int(uv.y) % 2 == 1))\n        {\n            mat.albedo = vec3(1, 1, 1) * 0.7;\n        }\n    }\n\n    return mat;    \n}\n\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-plane-and-ray-disk-intersection\nfloat PlaneIntersection(vec3 rayOrigin, vec3 rayDirection, vec3 planeOrigin, vec3 planeNormal, out vec3 normal) \n{ \n    float t = -1.0f;\n    normal = planeNormal;\n    float denom = dot(-planeNormal, rayDirection); \n    if (denom > EPSILON) { \n        vec3 rayToPlane = planeOrigin - rayOrigin; \n        return dot(rayToPlane, -planeNormal) / denom; \n    } \n \n    return t; \n} \n    \nfloat SphereIntersection(\n    in vec3 rayOrigin, \n    in vec3 rayDirection, \n    in vec3 sphereCenter, \n    in float sphereRadius, \n    out vec3 normal)\n{\n      vec3 eMinusC = rayOrigin - sphereCenter;\n      float dDotD = dot(rayDirection, rayDirection);\n\n      float discriminant = dot(rayDirection, (eMinusC)) * dot(rayDirection, (eMinusC))\n         - dDotD * (dot(eMinusC, eMinusC) - sphereRadius * sphereRadius);\n\n      // If the ray doesn't intersect\n      if (discriminant < 0.0) \n         return -1.0;\n\n      float firstIntersect = (dot(-rayDirection, eMinusC) - sqrt(discriminant))\n             / dDotD;\n      \n      float t = firstIntersect;\n    \n      // If the ray is inside the sphere\n      if (firstIntersect < EPSILON) {\n         t = (dot(-rayDirection, eMinusC) + sqrt(discriminant))\n             / dDotD;\n      }\n    \n      normal = normalize(rayOrigin + rayDirection * t - sphereCenter);\n      return t;\n}\n\n\nvoid UpdateIfIntersected(\n    inout float t,\n    in float intersectionT, \n    in vec3 intersectionNormal,\n    in int intersectionMaterialID,\n    out vec3 normal,\n    out int materialID\n\t)\n{    \n    if(intersectionT > EPSILON && intersectionT < t)\n    {\n\t\tnormal = intersectionNormal;\n        materialID = intersectionMaterialID;\n        t = intersectionT;\n    }\n}\n\nfloat IntersectOpaqueScene(in vec3 rayOrigin, in vec3 rayDirection, out int materialID, out vec3 normal)\n{\n    float intersectionT = LARGE_NUMBER;\n    vec3 intersectionNormal = vec3(0, 0, 0);\n\n    float t = LARGE_NUMBER;\n    normal = vec3(0, 0, 0);\n    materialID = INVALID_MATERIAL_ID;\n\n    for(int lightIndex = 0; lightIndex < NUM_LIGHTS; lightIndex++)\n    {\n        UpdateIfIntersected(\n            t,\n            SphereIntersection(rayOrigin, rayDirection, GetLight(lightIndex).Position, GetLight(lightIndex).Radius, intersectionNormal),\n            intersectionNormal,\n            LAMP_MATERIAL_ID,\n            normal,\n            materialID);\n    }\n\n    \n    UpdateIfIntersected(\n        t,\n        PlaneIntersection(rayOrigin, rayDirection, vec3(0, 0, 0), vec3(0, 1, 0), intersectionNormal),\n        intersectionNormal,\n        CHECKER_FLOOR_MATERIAL_ID,\n        normal,\n        materialID);\n\n    \n    return t;\n}\n\nvec3 Diffuse(in vec3 normal, in vec3 lightVec, in vec3 diffuse)\n{\n    float nDotL = dot(normal, lightVec);\n    return clamp(nDotL * diffuse, 0.0, 1.0);\n}\n\nvoid CalculateLighting(vec3 position, vec3 normal, vec3 reflectionDirection, Material material, bool shootShadowRays, inout vec3 color)\n{\n    for(int lightIndex = 0; lightIndex < NUM_LIGHTS; lightIndex++)\n    {\n        vec3 lightDirection = (GetLight(lightIndex).Position - position);\n        float lightDistance = length(lightDirection);\n        lightDirection /= lightDistance;\n\n        // Manually tuned light falloff for what looked best\n        vec3 lightColor = GetLight(lightIndex).LightColor / pow(lightDistance, 1.5); \n\n        color += 0.25 * lightColor * pow(max(dot(reflectionDirection, lightDirection), 0.0), 4.0);\n        color += lightColor * Diffuse(normal, lightDirection, material.albedo);\n    \n    }\n    color += material.emissive;\n}\n\nvoid Render( in vec3 rayOrigin, in vec3 rayDirection, out vec3 color)\n{\n    float depth = SCENE_MAX_T;\n    color = vec3(0.0f);\n    \n    vec3 normal;\n    float t;\n    int materialID = INVALID_MATERIAL_ID;\n    \n    t = IntersectOpaqueScene(rayOrigin, rayDirection, materialID, normal);\n    \n    if( materialID != INVALID_MATERIAL_ID )\n    {\n        depth = t;\n        vec3 position = rayOrigin + t*rayDirection;\n        Material material = GetMaterial(materialID, position);\n\t\tif(IsLightSource(material))\n        {\n            color = min(material.albedo, vec3(1.0));\n            return;\n        }       \n        \n        vec3 reflectionDirection = reflect( rayDirection, normal);\n        CalculateLighting(position, normal, reflectionDirection, material, true, color);\n    }\n}\n\nmat3 GetViewMatrix(float xRotationFactor)\n{ \n   float xRotation = ((1.0 - xRotationFactor) - 0.5) * PI * 0.4 + PI * 0.25;\n   return mat3( cos(xRotation), 0.0, sin(xRotation),\n                0.0,           1.0, 0.0,    \n                -sin(xRotation),0.0, cos(xRotation));\n}\n\nfloat GetCameraPositionYOffset()\n{\n    return 250.0 * (iMouse.y / iResolution.y);\n}\n\nfloat GetRotationFactor()\n{\n    if(iMouse.x <= 0.0)\n    {\n        // Default value when shader is initially loaded up\n        return 0.65f;\n    }\n    \n    return iMouse.x / iResolution.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float aspectRatio = iResolution.x /  iResolution.y; \n    float lensWidth = Camera.LensHeight * aspectRatio;\n    \n    vec3 CameraPosition = Camera.Position + GetCameraPositionYOffset();\n    \n    vec3 NonNormalizedCameraView = Camera.LookAt - CameraPosition;\n    float ViewLength = length(NonNormalizedCameraView);\n    vec3 CameraView = NonNormalizedCameraView / ViewLength;\n\n    vec3 lensPoint = CameraPosition;\n    \n    // Pivot the camera around the look at point\n    {\n        float rotationFactor = GetRotationFactor();\n        mat3 viewMatrix = GetViewMatrix(rotationFactor);\n        CameraView = CameraView * viewMatrix;\n        lensPoint = Camera.LookAt - CameraView * ViewLength;\n    }\n    \n    // Technically this could be calculated offline but I like \n    // being able to iterate quickly\n    vec3 CameraRight = cross(CameraView, vec3(0, 1, 0));    \n    vec3 CameraUp = cross(CameraRight, CameraView);\n\n    vec3 focalPoint = lensPoint - Camera.FocalDistance * CameraView;\n    lensPoint += CameraRight * (uv.x * 2.0 - 1.0) * lensWidth / 2.0;\n    lensPoint += CameraUp * (uv.y * 2.0 - 1.0) * Camera.LensHeight / 2.0;\n    \n    vec3 rayOrigin = focalPoint;\n    vec3 rayDirection = normalize(lensPoint - focalPoint);\n    \n    vec3 color;\n    Render(rayOrigin, rayDirection, color);\n    fragColor=vec4( clamp(color, 0.0, 1.0), 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}