{
    "Shader": {
        "info": {
            "date": "1649004475",
            "description": "Cyclides raytraced using analytic solution to quartic.\n\nMouse rotates. <up>/<down> to zoom.\n\nClick & drag red blob in crosshairs to change cyclide parameters.\n\n'z' hides controls\n't' texturing\n'r' controls autorotation",
            "flags": 48,
            "hasliked": 0,
            "id": "7dSBWz",
            "likes": 28,
            "name": "Cyclides",
            "published": 3,
            "tags": [
                "quartic",
                "universe",
                "descartes",
                "cyclide"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 478
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Cyclides, Matthew Arcus, 2022.\n//\n// A Dupin cyclide is essentially an inverted torus and like a torus\n// has an implicit quartic equation. By moving the projection point\n// to be orthogonal to the projection direction, the cubic term in the\n// quartic disappears and we can directly use Descartes method for\n// solving a depressed quartic. As usual this requires solving an\n// auxiliary cubic and we do this with Kahan's semi iterative method -\n// this has the great advantage that we avoid use of potentially\n// inaccurate trigonometry functions.\n// \n// Mouse rotates. <up>/<down> to zoom.\n//\n// Click & drag red blob in crosshairs to change cyclide parameters.\n//\n// 'z' hides controls\n// 't' texturing\n// 'r' controls autorotation\n// 'h' 'horn' cycle (parameter d = c = a²-b²)\n// 's' 'spindle' cyclide (parameter d = 1.0).\n// 'b' show where biquadratic solver is used\n//\n////////////////////////////////////////////////////////////////////////////////\n\nfloat sgn(float x) {\n  return x < 0.0? -1.0: 1.0; // Return 1 for x == 0\n}\n\nint quadratic(float A, float B, float C, out vec2 res) {\n  float x1,x2;\n  float b = -0.5*B;\n  float q = b*b - A*C;\n  if (q < 0.0) return 0;\n  float r = b + sgn(b)*sqrt(q);\n  x1 = C/r;\n  x2 = r/A;\n  res = vec2(x1,x2);\n  return 2;\n}\n\n// The Kahan algorithm, for explanation see:\n// https://people.eecs.berkeley.edu/~wkahan/Math128/Cubic.pdf\n\nvoid eval(float X, float B, float C, float D,\n          out float Q, out float DQ, out float B1,out float C2) {\n  float q0 = X;\n  B1 = q0+B;\n  C2 = B1*X+C;\n  DQ = (q0+B1)*X + C2;\n  Q = C2*X + D;\n}\n\nfloat qcubic(float B, float C, float D) {\n  float X,b1,c2;\n  X = -B/3.0;\n  float t,r,s,q,dq,x0;\n  eval(X,B,C,D,q,dq,b1,c2);\n  t = q; r = pow(abs(t),1.0/3.0); s = sgn(t);\n  t = -dq; if (t > 0.0) r = 1.324718*max(r,sqrt(t));\n  x0 = X - s*r;\n  if (x0 != X) {\n    X = x0;\n    for (int i = 0; i < 4; i++) {\n      eval(X,B,C,D,q,dq,b1,c2);\n      if (dq == 0.0) break;\n      X -= q/dq;\n    }\n    if (X*X > abs(D/X)) {\n      c2 = -D/X; b1 = (c2 - C)/X;\n    }\n  }\n  vec2 res;\n  if (quadratic(1.0,b1,c2,res) == 0) return X;\n  X = max(X,res[0]);\n  X = max(X,res[1]);\n  return X;\n}\n\nint biquadratic(float p, float r, out vec4 res) {\n  if (key(CHAR_B)) assert(false);\n  // Solve x^4 + px^2 + r = 0 (ie. a quadratic equation in x^2)\n  vec2 t;\n  if (quadratic(1.0,p,r,t) == 0) return 0;\n  int n = 0;\n  for (int i = 0; i < 2; i++) {\n    if (t[i] >= 0.0) {\n      float x = sqrt(t[i]);\n      res[n++] = -x;\n      res[n++] = x;\n    }\n  }\n  return n;\n}\n\n// Descartes solver for depressed quartics\n// ie. x⁴ + px² + qx + r = 0\nint dquartic(float p, float q, float r, out vec4 res) {\n  if (abs(q) < 0.001) return biquadratic(p,r,res);\n  float A = 2.0*p;\n  float B = p*p-4.0*r;\n  float C = -q*q;\n  float U = qcubic(A,B,C);\n  assert(U >= 0.0);\n  float u = sqrt(U);\n  float s = -u;\n  float t = 0.5*(p+U+q/u);\n  float v = 0.5*(p+U-q/u);\n  int n1 = quadratic(1.0,s,t,res.xy);\n  int n2 = quadratic(1.0,u,v,res.zw);\n  if (n1 == 0) res.xy = res.zw;\n  return n1+n2;\n}\n\nint cyclide(vec4 params, vec3 q, vec3 r, out vec4 roots) {\n  // Cartesian equation for p = (x,y,z), a,b,c,d params:\n  // (p.p+b²-d²)² = 4((ax-cd)²+b²y²)\n  // Solve for p = q+tr, with r.r = 1.0, q.r = 0.0\n  float a = params.x, b = params.y, c = params.z, d = params.w;\n  float K = (b+d)*(b-d); float L = c*d;\n  // t0 = (q+tr).(q+tr) + K = q.q + K + t^2\n  // t0*t0 = (q.q + K + t^2)(q.q + K + t^2) = (q.q + K)^2 + 2t^2(q.q + K) + t^4\n  // (a(q.x+tr.x)-L)² = ((aq.x-L)+tr.x)² = t²(r.x)²+2tr.x(aq.x-L)+(aq.x-L)²\n  float qq = dot(q,q)+K; // Roll K into qq\n  float arx = a*r.x, aqx = a*q.x-L; // Roll L into aqx\n  float bry = b*r.y, bqy = b*q.y;\n  float C = 2.0*qq - 4.0*arx*arx - 4.0*bry*bry;\n  float D = -8.0*(aqx*arx + bqy*bry);\n  float E = qq*qq - 4.0*aqx*aqx - 4.0*bqy*bqy;\n  return dquartic(C,D,E,roots);\n}\n\nvec3 cyclidegrad(vec4 params, vec3 p) {\n  float a = params.x, b = params.y, c = params.z, d = params.w;\n  float x = p.x, y = p.y;\n  float K = (b+d)*(b-d), L = c*d;\n  float t = dot(p,p) + K;\n  float u = a*x-L, v = b*y;\n  return 2.0*(2.0*t*p - 4.0*vec3(u*a,v*b,0));\n}\n\n// Lighting\nvec3 light = vec3(1,1,-1);\nfloat ambient = 0.4;\nfloat diffuse = 0.6;\nfloat specular = 0.8;\nfloat specularpow = 10.0;\nvec3 specularcolor = vec3(1);\n\nvec3 applylighting(vec3 baseColor, vec3 p, vec3 n, vec3 r) {\n  vec3 c = baseColor*ambient;\n  c += baseColor*diffuse*(max(0.0,dot(light,n)));\n  float s = pow(max(0.0,dot(reflect(light,n),r)),specularpow);\n  c += specular*s*specularcolor;\n  return c;\n}\n\nvec3 compute(vec3 color, vec3 q, vec3 r, float tmin) {\n  vec4 res;\n  // a = b: torus\n  // b = 0: tangent spheres\n  float a = 1.0; float b = 0.5;\n  float d = 2.0*sin(iTime);\n  vec2 sel0 = getselection(0);\n  b = min(1.0,abs(1.1*sel0.y));\n  float c = sqrt(a*a-b*b);\n  d = key(CHAR_H) ? c : key (CHAR_S) ? 1.0 : sel0.x;\n  vec4 params = vec4(a,b,c,d);\n  int n = cyclide(params,q,r,res);\n  // Sort results in decreasing order\n  if (n > 1) {\n    if (res.x < res.y) res.xy = res.yx;\n  }\n  if (n > 2) {\n    if (res.y < res.z) res.yz = res.zy;\n    if (res.x < res.y) res.xy = res.yx;\n  }\n  if (n > 3) {\n    if (res.z < res.w) res.zw = res.wz;\n    if (res.y < res.z) res.yz = res.zy;\n    if (res.x < res.y) res.xy = res.yx;\n  }\n  // Process from furthest\n  for (int i = 0; i < n; i++) {\n    float t = res[i];\n    //if (t > tmax) continue; // Not needed here, surface is bounded\n    if (t < tmin) break;\n    vec3 p = q+t*r;\n    float phi = atan(p.y,p.x);\n    float theta = atan(p.z,sqrt(p.x*p.x+p.y*p.y));\n    vec2 uv = 4.0*vec2(phi,theta)/PI;\n    vec3 n = cyclidegrad(params,p);\n    if (dot(r,n) > 0.0) n = -n; // Face forwards\n    n = normalize(n);\n    vec3 basecolor = pow(abs(n),vec3(1.0));\n    if (!key(CHAR_T)) basecolor *= texture(iChannel0,uv).xyz;\n    if (min(abs(p.x),min(abs(p.y),abs(p.z))) < 0.01) basecolor *= vec3(0.5);\n    vec3 c = applylighting(basecolor,p,n,r);\n    color = mix(c,color,0.5);\n  }\n  return color;\n}\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\n\nvec3 transform(in vec3 p) {\n  vec2 s = defaultselection();\n  {\n    float theta = s.y*PI;\n    float phi = s.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (!key(CHAR_R)) {\n    p.yz = rotate(p.yz, 0.1*iTime);\n    p.zx = rotate(p.zx, 0.222*iTime);\n  }\n  return p;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 uv = map(fragCoord);\n  float camera = 4.0;\n  camera *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  vec3 p = vec3(0,0,-camera);\n  vec3 r = vec3(uv,2);\n\n  light = transform(light);\n  light = normalize(light);\n  p = transform(p);\n  r = transform(r);\n  r = normalize(r);\n  float t = -dot(p,r);\n  vec3 color = vec3(0);\n  if (!key(CHAR_Z)) {\n    float px = fwidth(uv.x);\n    vec2 d = abs(uv-getselection(0));\n    color = mix(vec3(1),color,0.95+0.05*smoothstep(-px,px,min(d.x,d.y)-0.005));\n    color = mix(vec3(1,0,0),color,0.6+0.4*smoothstep(-px,px,length(d)-0.02));\n  }\n  vec3 c = compute(color,p+t*r,r,-t);\n  c = pow(c,vec3(0.4545));\n  if (alert) c.r = 1.0;\n  fragColor = vec4(c,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage(out vec4 t, vec2 uv) {\n  //setscale();\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n  } else if (j == 3) {\n      // Cell 0 holds currently selected item, 0 = no selection\n    if (i == 0) {\n      if (t.x == 0.0 && iMouse.z > 0.0) {\n        vec2 mouse = map(iMouse.xy);\n        // No selection, but mouse now down\n        t.x = -1.0;\n        for (int i = nselections; i >= 1; i--) {\n          // Select topmost item (assume drawn 1..N)\n          vec2 p = texelFetch(iChannel2,ivec2(i,3),0).xy; // Get current state\n          if (distance(mouse,p) < scale*0.05) {\n            t.x = float(i);\n            break;\n          }\n        }\n      } else if (t.x != 0.0 && iMouse.z <= 0.0) {\n        // Clear selection if mouse up.\n        t.x = 0.0;\n      }\n      if (t.x <= 0.0 && iMouse.z > 0.0) t.zw = map(iMouse.xy);\n    } else if (iFrame == 0) {\n      t.xy = initselection(i-1); // Current coordinates\n    } else {\n      vec4 t0 = texelFetch(iChannel2,ivec2(0,3),0); // Get current state\n      if (int(t0.x) == i && iMouse.z > 0.0) {\n        // If currently selected, copy mouse position\n        t.xy = map(iMouse.xy);\n      }\n    }\n  }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define map(p) ((2.0*(p) - iResolution.xy)/iResolution.y)\nint nselections = 1;\nfloat scale = 1.0;\nvec2 initselection(int i) {\n  return vec2(0.5);\n}\n#define getselection(i) (texelFetch(iChannel2,ivec2((i)+1,3),0).xy)\n#define defaultselection() (texelFetch(iChannel2,ivec2(0,3),0).zw)\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )\nconst int KEY_ALT = 18;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\nbool alert = false;\n\nvoid assert(bool t) {\n  if (!t) alert = true;\n}\n\nconst float PI =  3.141592654;\nconst float TWOPI = 2.0*PI;",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}