{
    "Shader": {
        "info": {
            "date": "1597140024",
            "description": "Mix of [url=https://www.shadertoy.com/view/Wl2cDt]Basic 2 pass AA[/url] and [url=https://www.shadertoy.com/view/ltGyWz]Voxel Pac-Man[/url].\n\nUse the mouse to rotate when in 3D.",
            "flags": 32,
            "hasliked": 0,
            "id": "wtXBRj",
            "likes": 17,
            "name": "AA Voxel Pac-Man",
            "published": 3,
            "tags": [
                "voxel",
                "pacman",
                "aa"
            ],
            "usePreview": 0,
            "username": "Nrx",
            "viewed": 419
        },
        "renderpass": [
            {
                "code": "void mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Render the scene normally\n\tfragColor = Render (fragCoord, iResolution.xy, iTime, iMouse.xy);\n\n\t// Mix with the scene shifted by half a pixel\n\t// Notes:\n\t// - Linear filtering has to be used to fetch the color\n\t// - A value of 0.8 for the mix returns the actual average of the 5 sampling points,\n\t//   while 0.5 acts more like a Gaussian filter\n\tfragColor = mix (fragColor, texture (iChannel0, (fragCoord + 0.5) / iResolution.xy), 0.5);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Render the scene shifted by half a pixel\n\tfragColor = Render (fragCoord - 0.5, iResolution.xy, iTime, iMouse.xy);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Giant Voxel Pac-Man (from https://www.shadertoy.com/view/ltGyWz)\n\n// Parameters\n#define VOXEL_RESOLUTION\t1.0\n#define CAMERA_FOCAL_LENGTH\t8.0\n#define DELTA\t\t\t\t0.01\n#define RAY_LENGTH_MAX\t\t500.0\n#define RAY_STEP_MAX\t\t100.0\n#define AMBIENT\t\t\t\t0.2\n#define SPECULAR_POWER\t\t2.0\n#define SPECULAR_INTENSITY\t0.3\n#define SHADOW_LENGTH\t\t150.0\n#define SHADOW_POWER\t\t3.0\n#define FADE_POWER\t\t\t0.7\n#define BACKGROUND\t\t\t0.7\n#define GLOW\t\t\t\t0.4\n#define GAMMA\t\t\t\t0.8\n\n//#define GROUND\n\n// Math constants\n#define PI\t\t3.14159265359\n#define SQRT3\t1.73205080757\n\n// Global variables\nfloat time;\nfloat glowCounter;\n\n// PRNG (from https://www.shadertoy.com/view/4djSRW)\nfloat rand (in vec3 seed) {\n\tseed = fract (seed * vec3 (5.3983, 5.4427, 6.9371));\n\tseed += dot (seed.yzx, seed.xyz + vec3 (21.5351, 14.3137, 15.3219));\n\treturn fract (seed.x * seed.y * seed.z * 95.4337);\n}\n\n// Distance to the voxel\nfloat distVoxel (in vec3 p) {\n\n\t// Update the glow counter\n\t++glowCounter;\n\n\t// Rounded box\n\tconst float voxelRadius = 0.25;\n\treturn length (max (abs (p) - 0.5 + voxelRadius, 0.0)) - voxelRadius;\n}\n\n// Distance to the scene and color of the closest point\nvec2 distScene (in vec3 p, out vec3 P) {\n\n\t// Update the glow counter\n\t++glowCounter;\n\n\t// Scaling\n\tp *= VOXEL_RESOLUTION;\n\n\t// Velocity, period of the waves, spacing of the gums\n\tfloat v = VOXEL_RESOLUTION * floor (time * 100.0 / VOXEL_RESOLUTION);\n\tconst float k1 = 0.05;\n\tconst float k2 = 60.0;\n\n\t// Giant Pac-Man\n\tfloat body = length (p);\n\tfloat eyes = 6.0 - length (vec3 (abs (p.x) - 12.5, p.y - 19.5, p.z - 20.0));\n\tfloat mouthAngle = PI * (0.075 + 0.065 * cos (2.0 * v * PI / k2));\n\tfloat mouthTop = dot (p, vec3 (0.0, -cos (mouthAngle), sin (mouthAngle))) - 2.0;\n\tmouthAngle *= 2.5;\n\tfloat mouthBottom = dot (p, vec3 (0.0, cos (mouthAngle), sin (mouthAngle)));\n\tfloat pacMan = max (max (body - 32.0, eyes), min (mouthTop, mouthBottom));\n\tvec2 d = vec2 (pacMan, pacMan > 29.0 - body ? 0.13 : 1.0);\n\tP = p;\n\n\t// Gums\n\tvec3 q = vec3 (p.xy, mod (p.z + v, k2) - k2 * 0.5);\n\tfloat gum = max (length (q) - 6.0, -p.z);\n\tif (gum < d.x) {\n\t\td = vec2 (gum, 0.35);\n\t\tP = q;\n\t}\n\n\t// Ground\n\t#ifdef GROUND\n\tq = vec3 (p.xy, p.z + v);\n\tfloat ground = (q.y + 50.0 + 14.0 * cos (q.x * k1) * cos (q.z * k1)) * 0.7;\n\tif (ground < d.x) {\n\t\td = vec2 (ground, 0.55);\n\t\tP = q;\n\t}\n\t#endif\n\n\t// Ghost\n\tv = VOXEL_RESOLUTION * floor ((110.0 + 40.0 * cos (time * 3.0)) / VOXEL_RESOLUTION);\n\tq = vec3 (p.xy, p.z + v);\n\tbody = length (vec3 (q.x, max (q.y - 4.0, 0.0), q.z));\n\teyes = 8.0 - length (vec3 (abs (q.x) - 12.0, q.y - 10.0, q.z - 22.0));\n\tfloat bottom = (q.y + 28.0 + 4.0 * cos (p.x * 0.4) * cos (p.z * 0.4)) * 0.7;\n\tfloat ghost = max (max (body - 28.0, eyes), -bottom);\n\tif (ghost < d.x) {\n\t\td = vec2 (ghost, ghost > 25.0 - body ? 0.76 : 1.0);\n\t\tP = q;\n\t}\n\n\t// Scaling\n\td.x /= VOXEL_RESOLUTION;\n\treturn d;\n}\n\n// Distance to the (voxelized?) scene\nvec4 dist (inout vec3 p, in vec3 ray, in float voxelized, in float rayLengthMax) {\n\tvec3 P = p;\n\tvec2 d = vec2 (1e10, 0.0);\n\tfloat rayLength = 0.0;\n\tfloat rayLengthInVoxel = 0.0;\n\tfloat rayLengthCheckVoxel = 0.0;\n\tvec3 raySign = sign (ray);\n\tvec3 rayDeltaVoxel = raySign / ray;\n\tfor (float rayStep = 0.0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\tif (rayLength < rayLengthInVoxel) {\n\t\t\td.x = distVoxel (fract (p + 0.5) - 0.5);\n\t\t\tif (d.x < DELTA) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (rayLength < rayLengthCheckVoxel) {\n\t\t\tvec3 rayDelta = (0.5 - raySign * (fract (p + 0.5) - 0.5)) * rayDeltaVoxel;\n\t\t\tfloat dNext = min (rayDelta.x, min (rayDelta.y, rayDelta.z));\n\t\t\td = distScene (floor (p + 0.5), P);\n\t\t\tif (d.x < 0.0) {\n\t\t\t\trayDelta = rayDeltaVoxel - rayDelta;\n\t\t\t\td.x = max (rayLengthInVoxel - rayLength, DELTA - min (rayDelta.x, min (rayDelta.y, rayDelta.z)));\n\t\t\t\trayLengthInVoxel = rayLength + dNext;\n\t\t\t} else {\n\t\t\t\td.x = DELTA + dNext;\n\t\t\t}\n\t\t} else {\n\t\t\td = distScene (p, P);\n\t\t\tif (voxelized > 0.5) {\n\t\t\t\tif (d.x < SQRT3 * 0.5) {\n\t\t\t\t\trayLengthCheckVoxel = rayLength + abs (d.x) + SQRT3 * 0.5;\n\t\t\t\t\td.x = max (rayLengthInVoxel - rayLength + DELTA, d.x - SQRT3 * 0.5);\n\t\t\t\t}\n\t\t\t} else if (d.x < DELTA) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trayLength += d.x;\n\t\tif (rayLength > rayLengthMax) {\n\t\t\tbreak;\n\t\t}\n\t\tp += d.x * ray;\n\t}\n\treturn vec4 (d, rayLength, rand (P));\n}\n\n// Normal at a given point\nvec3 normal (in vec3 p, in float voxelized) {\n\tvec2 h = vec2 (DELTA, -DELTA);\n\tvec3 n;\n\tif (voxelized > 0.5) {\n\t\tp = fract (p + 0.5) - 0.5;\n\t\tn = h.xxx * distVoxel (p + h.xxx) +\n\t\t\th.xyy * distVoxel (p + h.xyy) +\n\t\t\th.yxy * distVoxel (p + h.yxy) +\n\t\t\th.yyx * distVoxel (p + h.yyx);\n\t} else {\n\t\tn = h.xxx * distScene (p + h.xxx, n).x +\n\t\t\th.xyy * distScene (p + h.xyy, n).x +\n\t\t\th.yxy * distScene (p + h.yxy, n).x +\n\t\t\th.yyx * distScene (p + h.yyx, n).x;\n\t}\n\treturn normalize (n);\n}\n\n// HSV to RGB\nvec3 hsv2rgb (in vec3 hsv) {\n\treturn hsv.z * (1.0 + 0.5 * hsv.y * (cos (2.0 * PI * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n}\n\n// Main function\nvec4 Render (in vec2 fragCoord, in vec2 iResolution, in float iTime, in vec2 iMouse) {\n\n\t// Make the time global\n\ttime = iTime;\n\n\t// Get the fragment\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution) / iResolution.y;\n\n\t// Define the rendering mode\n\tfloat modeTiming = iTime * 0.234;\n\tfloat modeAngle = PI * cos (iTime * 0.2);\n\tmodeAngle = dot (frag - vec2 (cos (iTime * 2.0), 0.0), vec2 (cos (modeAngle), sin (modeAngle)));\n\tfloat modeVoxel = step (0.5, fract (modeTiming / (4.0 * PI)));\n\tmodeTiming = cos (modeTiming);\n\tfloat mode3D = smoothstep (0.8, 0.5, modeTiming);\n\tfloat modeSwitch = smoothstep (0.995, 1.0, modeTiming) + smoothstep (0.02, 0.0, abs (modeAngle)) * modeVoxel;\n\tmodeVoxel = 1.0 + (step (0.0, modeAngle) - 1.0) * modeVoxel;\n\n\t// Define the ray corresponding to this fragment\n\tvec3 ray = normalize (vec3 (frag, mix (12.0, CAMERA_FOCAL_LENGTH, mode3D)));\n\n\t// Compute the orientation of the camera\n\tfloat yawAngle = PI * (1.2 + 0.2 * cos (iTime * 0.5));\n\tfloat pitchAngle = PI * (0.1 * cos (iTime * 0.3) - 0.05);\n\n\tyawAngle += 4.0 * PI * iMouse.x / iResolution.x;\n\tpitchAngle += PI * 0.3 * (1.0 - iMouse.y / iResolution.y);\n\n\tyawAngle = mix (PI * 1.5, yawAngle, mode3D);\n\tpitchAngle *= mode3D;\n\n\tfloat cosYaw = cos (yawAngle);\n\tfloat sinYaw = sin (yawAngle);\n\tfloat cosPitch = cos (pitchAngle);\n\tfloat sinPitch = sin (pitchAngle);\n\n\tmat3 cameraOrientation;\n\tcameraOrientation [0] = vec3 (cosYaw, 0.0, -sinYaw);\n\tcameraOrientation [1] = vec3 (sinYaw * sinPitch, cosPitch, cosYaw * sinPitch);\n\tcameraOrientation [2] = vec3 (sinYaw * cosPitch, -sinPitch, cosYaw * cosPitch);\n\n\tray = cameraOrientation * ray;\n\n\t// Compute the origin of the ray\n\tfloat cameraDist = mix (400.0, 200.0 + 80.0 * cos (iTime * 0.8), mode3D);\n\tvec3 origin = (vec3 (0.0, 0.0, 80.0 * sin (iTime * 0.2) - 20.0) - cameraOrientation [2] * cameraDist) / VOXEL_RESOLUTION;\n\n\t// Compute the distance to the scene\n\tglowCounter = 0.0;\n\tvec4 d = dist (origin, ray, modeVoxel, RAY_LENGTH_MAX / VOXEL_RESOLUTION);\n\n\t// Set the background color\n\tvec3 finalColor = hsv2rgb (vec3 (0.53 - 0.1 * ray.y + 0.1 * modeVoxel, 1.0, mode3D * BACKGROUND));\n\tvec3 glowColor = GLOW * vec3 (1.0, 0.3, 0.0) * glowCounter / RAY_STEP_MAX;\n\tif (d.x < DELTA) {\n\n\t\t// Set the object color\n\t\tvec3 color = d.y != 1.0 ? hsv2rgb (vec3 (d.y + 0.1 * d.w * modeVoxel, 0.5 + 0.5 * modeVoxel, 1.0)) : vec3 (0.0);\n\n\t\t// Lighting\n\t\tvec3 l = normalize (mix (vec3 (1.0, 0.0, 0.0), vec3 (1.25 + cos (iTime * 0.2), 1.0, 1.0), mode3D));\n\t\tif (modeVoxel > 0.5) {\n\t\t\tvec3 n = normal (floor (origin + 0.5), 0.0);\n\t\t\tfloat diffuse = max (0.0, dot (n, l));\n\t\t\tfloat specular = pow (max (0.0, dot (reflect (ray, n), l)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\tcolor = (AMBIENT + diffuse) * color + specular;\n\t\t}\n\t\tvec3 n = normal (origin, modeVoxel);\n\t\tfloat diffuse = dot (n, l);\n\t\tfloat specular;\n\t\tif (diffuse < 0.0) {\n\t\t\tdiffuse = 0.0;\n\t\t\tspecular = 0.0;\n\t\t} else {\n\t\t\tspecular = pow (max (0.0, dot (reflect (ray, n), l)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\torigin += n * DELTA * 2.0;\n\t\t\tvec4 shadow = dist (origin, l, modeVoxel, SHADOW_LENGTH / VOXEL_RESOLUTION);\n\t\t\tif (shadow.x < DELTA) {\n\t\t\t\tshadow.z = pow (min (1.0, shadow.z * VOXEL_RESOLUTION / SHADOW_LENGTH), SHADOW_POWER);\n\t\t\t\tdiffuse *= shadow.z;\n\t\t\t\tspecular *= shadow.z;\n\t\t\t}\n\t\t}\n\t\tcolor = (AMBIENT + diffuse) * color + specular;\n\n\t\t// Fading\n\t\tfloat fade = pow (max (0.0, 1.0 - d.z * VOXEL_RESOLUTION / RAY_LENGTH_MAX), FADE_POWER);\n\t\tfinalColor = mix (finalColor, color, fade);\n\t}\n\n\t// Set the fragment color\n\tfinalColor = mix (pow (finalColor, vec3 (GAMMA)) + glowColor, vec3 (1.0), modeSwitch);\n\treturn vec4 (finalColor, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}