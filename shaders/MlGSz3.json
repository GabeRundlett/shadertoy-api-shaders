{
    "Shader": {
        "info": {
            "date": "1485217525",
            "description": "Fork of iq's [url=https://www.shadertoy.com/view/4lGSDw]Fourier - interpolation[/url] that compares Fourier (green) with Catmull-Rom Spline (black) interpolation. Fourier produces more round shape but is over 3 times slower than CatmullRom on my videocard",
            "flags": 0,
            "hasliked": 0,
            "id": "MlGSz3",
            "likes": 51,
            "name": "Fourier vs Spline interpolation ",
            "published": 3,
            "tags": [
                "2d",
                "spline",
                "fourier",
                "catmullrom"
            ],
            "usePreview": 1,
            "username": "revers",
            "viewed": 3521
        },
        "renderpass": [
            {
                "code": "// revers: This is fork of iq's \"Fourier - interpolation\" [ https://www.shadertoy.com/view/4lGSDw ].\n//         It compares Fourier (green line) with Catmull-Rom (black line) interpolation. \n//         Fourier version produces more round shape, but is slower (over 3 times on my video card)\n//         than Catmull-Rom.\n//\n//         Comment out SHOW_CATMULL_ROM / SHOW_FOURIER to see a single curve.\n\n\n// Created by inigo quilez - iq/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A set of 38 points gets interpolated by computing the DFT (Discrete Fourier Transform)\n// and then its inverse, and evaluating the it at more than 38 points. This results in\n// an interpolation sort of made of cosine/sine waves. Would be nice to do a regular\n// Hermite spline interpolation as well to compare.\n//\n// More info: https://iquilezles.org/articles/fourier\n//\n// Original drawing (kind of), here:\n// https://mir-s3-cdn-cf.behance.net/project_modules/disp/831a237863325.560b2e6f92480.png\n\n\n\n//--------------------------------------------------------------------------------------\n// Additions by revers:\n\n#define SHOW_CATMULL_ROM\n#define SHOW_FOURIER\n\n/**\n * Tension. Default Catmul-Rom matrix\n * has tension equal to 0.5.\n *\n * Values below 0.5 will cause sharp edges,\n * values above 0.5 will produce more curly lines.\n */\n#define T 0.7\n\n/**\n * Catmull-Rom Matrix\n */\nconst mat4 CRM = mat4(-T,        2.0 - T,  T - 2.0,         T,\n                       2.0 * T,  T - 3.0,  3.0 - 2.0 * T,  -T,\n                      -T,        0.0,      T,               0.0,\n                       0.0,      1.0,      0.0,             0.0);\n/**\n * Catmull-Rom Spline Interpolation\n */\nvec2 interpolate(vec2 G1, vec2 G2, vec2 G3, vec2 G4, float t) {\n    vec2 A = G1 * CRM[0][0] + G2 * CRM[0][1] + G3 * CRM[0][2] + G4 * CRM[0][3];\n    vec2 B = G1 * CRM[1][0] + G2 * CRM[1][1] + G3 * CRM[1][2] + G4 * CRM[1][3];\n    vec2 C = G1 * CRM[2][0] + G2 * CRM[2][1] + G3 * CRM[2][2] + G4 * CRM[2][3];\n    vec2 D = G1 * CRM[3][0] + G2 * CRM[3][1] + G3 * CRM[3][2] + G4 * CRM[3][3];\n\n    return t * (t * (t * A + B) + C) + D;\n}\n//=======================================================================================\n\nfloat sdSegmentSq(vec2 p, vec2 a, vec2 b) {\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\tvec2 d = pa - ba * h;\n\treturn dot(d, d);\n}\n\nfloat sdPointSq(vec2 p, vec2 a) {\n\tvec2 d = p - a;\n\treturn dot(d, d);\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n\treturn vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tfloat e = 1.0 / iResolution.x;\n\tvec2 uv = fragCoord / iResolution.x;\n    \n    vec3 col = vec3(1.0);\n\n    const int NUM = 41;\n    \n    vec2 path[NUM];\n    \n    //------------------------------------------------------\n    // path\n    //------------------------------------------------------\n    {\n        path[ 0] = vec2( 0.098, 0.062 );\n        path[ 1] = vec2( 0.098, 0.062 );\n        path[ 2] = vec2( 0.352, 0.073 );\n        path[ 3] = vec2( 0.422, 0.136 );\n        path[ 4] = vec2( 0.371, 0.085 );\n        path[ 5] = vec2( 0.449, 0.140 );\n        path[ 6] = vec2( 0.352, 0.187 );\n        path[ 7] = vec2( 0.379, 0.202 );\n        path[ 8] = vec2( 0.398, 0.202 );\n        path[ 9] = vec2( 0.266, 0.198 );\n        path[10] = vec2( 0.318, 0.345 );\n        path[11] = vec2( 0.402, 0.359 );\n        path[12] = vec2( 0.361, 0.425 );\n        path[13] = vec2( 0.371, 0.521 );\n        path[14] = vec2( 0.410, 0.491 );\n        path[15] = vec2( 0.410, 0.357 );\n        path[16] = vec2( 0.502, 0.482 );\n        path[17] = vec2( 0.529, 0.435 );\n        path[18] = vec2( 0.426, 0.343 );\n        path[19] = vec2( 0.449, 0.343 );\n        path[20] = vec2( 0.504, 0.335 );\n        path[21] = vec2( 0.664, 0.355 );\n        path[22] = vec2( 0.748, 0.208 );\n        path[23] = vec2( 0.738, 0.277 );\n        path[24] = vec2( 0.787, 0.308 );\n        path[25] = vec2( 0.748, 0.183 );\n        path[26] = vec2( 0.623, 0.081 );\n        path[27] = vec2( 0.557, 0.099 );\n        path[28] = vec2( 0.648, 0.116 );\n        path[29] = vec2( 0.598, 0.116 );\n        path[30] = vec2( 0.566, 0.195 );\n        path[31] = vec2( 0.584, 0.228 );\n        path[32] = vec2( 0.508, 0.083 );\n        path[33] = vec2( 0.457, 0.140 );\n        path[34] = vec2( 0.508, 0.130 );\n        path[35] = vec2( 0.625, 0.071 );\n        path[36] = vec2( 0.818, 0.093 );\n        path[37] = vec2( 0.951, 0.066 );\n        path[38] = vec2( 0.547, 0.081 );\n        path[39] = vec2( 0.098, 0.062 );\n        path[40] = vec2( 0.098, 0.062 );\n    }\n\n\t//------------------------------------------------------\n\t// draw path\n\t//------------------------------------------------------\n\t{\n\t\tvec2 d = vec2(1000.0);\n\t\tfor (int i = 0; i < (NUM - 1); i++) {\n\t\t\tvec2 a = path[i + 0];\n\t\t\tvec2 b = path[i + 1];\n\t\t\td = min(d, vec2(sdSegmentSq(uv, a, b), sdPointSq(uv, a)));\n\t\t}\n\t\td.x = sqrt(d.x);\n\t\td.y = sqrt(min(d.y, sdPointSq(uv, path[NUM - 1])));\n\t\tcol = mix(col, vec3(0.9, 0.2, 0.0), 1.0 - smoothstep(5.0 * e, 6.0 * e, d.y));\n\t}\n\n#ifdef SHOW_CATMULL_ROM\n\t//------------------------------------------------------\n\t// Catmull-Rom interpolation\n\t// (added by revers)\n\t//------------------------------------------------------\n\t{\n\t\tfloat d = 1e5;\n\t\tfloat ani = min(mod((12.0 + iTime) / 10.1, 1.3), 1.0) * float(NUM);\n\n\t\tvec2 p = path[0];\n\n\t\tfor (int i = 0; i < NUM - 3; i++) {\n\t\t\tfloat fi = float(i);\n\n\t\t\tif (fi > ani) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvec2 A = path[i + 0];\n\t\t\tvec2 B = path[i + 1];\n\t\t\tvec2 C = path[i + 2];\n\t\t\tvec2 D = path[i + 3];\n\n\t\t\tfor (float t = 0.0; t <= 1.01; t += 0.1) {\n\t\t\t\tvec2 q = interpolate(A, B, C, D, t);\n\n\t\t\t\td = min(d, sdSegmentSq(uv, p, q));\n\t\t\t\tp = q;\n\n\t\t\t\tif (fi + t > ani) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\td = sqrt(d);\n\n\t\tcol = mix(col, vec3(0.1, 0.1, 0.2), 1.0 - smoothstep(0.0 * e, 2.0 * e, d));\n\t\tcol *= 0.75 + 0.25 * smoothstep(0.0, 0.13, sqrt(d));\n\t}\n#endif\n\n#ifdef SHOW_FOURIER\n    vec2 p = uv;\n    //------------------------------------------------------\n   // compute fourier transform of the path\n   //------------------------------------------------------\n\tvec2 fcsX[20];\n\tvec2 fcsY[20];\n\tfor (int k = 0; k < 20; k++) {\n\t\tvec2 fcx = vec2(0.0);\n\t\tvec2 fcy = vec2(0.0);\n\t\tfor (int i = 1; i < NUM - 2; i++) {\n\t\t\tfloat an = -6.283185 * float(k) * float(i - 1) / float(NUM - 3);\n\t\t\tvec2 ex = vec2(cos(an), sin(an));\n\t\t\tfcx += path[i].x * ex;\n\t\t\tfcy += path[i].y * ex;\n\t\t}\n\t\tfcsX[k] = fcx;\n\t\tfcsY[k] = fcy;\n\t}\n    //------------------------------------------------------\n    // inverse transform with 6x evaluation points\n    //------------------------------------------------------\n\t{\n\t\tfloat ani = min(mod((12.0 + iTime) / 10.1, 1.3), 1.0);\n\t\tfloat d = 1000.0;\n\t\tvec2 oq;\n\n\t\tfor (int i = 0; i < 256; i++) {\n\t\t\tfloat h = ani * float(i) / 256.0;\n\t\t\tvec2 q = vec2(0.0);\n\n\t\t\tfor (int k = 0; k < 20; k++) {\n\t\t\t\tfloat w = (k == 0 || k == 19) ? 1.0 : 2.0;\n\n\t\t\t\tfloat an = -6.283185 * float(k) * h;\n\t\t\t\tvec2 ex = vec2(cos(an), sin(an));\n\t\t\t\tq.x += w * dot(fcsX[k], ex) / float(NUM - 3);\n\t\t\t\tq.y += w * dot(fcsY[k], ex) / float(NUM - 3);\n\t\t\t}\n\t\t\tif (i != 0)\n\t\t\t\td = min(d, sdSegmentSq(p, q, oq));\n\t\t\toq = q;\n\t\t}\n\t\td = sqrt(d);\n\t\tcol = mix(col, vec3(0.1, 0.8, 0.2), 1.0 - smoothstep(0.0 * e, 2.0 * e, d));\n\t\tcol *= 0.75 + 0.25 * smoothstep(0.0, 0.13, sqrt(d));\n\t}\n#endif\n    //------------------------------------------------------\n\n\tcol *= 1.0 - 0.3 * length(fragCoord / iResolution.xy - 0.5);\n\tfragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}