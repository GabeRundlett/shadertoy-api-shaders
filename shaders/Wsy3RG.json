{
    "Shader": {
        "info": {
            "date": "1570393072",
            "description": "first shader w/ materials.\nknown issues:\n  * no AA\n  * very limited reflection\n  * shading model not so great\n  * scintillating edges\n  * hard shadows\n",
            "flags": 0,
            "hasliked": 0,
            "id": "Wsy3RG",
            "likes": 7,
            "name": "materials 1",
            "published": 3,
            "tags": [
                "materials",
                "grimoire"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 407
        },
        "renderpass": [
            {
                "code": "/*\nfirst shader w/ materials.\nknown issues:\n  * no AA\n  * very limited reflection\n  * shading model not so great\n  * scintillating edges\n*/\n\n// common stuff\nconst vec3  fv3_1   = vec3(1.0, 1.0, 1.0);\nconst vec3  fv3_0   = vec3(0.0, 0.0, 0.0);\nconst vec3  fv3_x   = vec3(1.0, 0.0, 0.0);\nconst vec3  fv3_y   = vec3(0.0, 1.0, 0.0);\nconst vec3  fv3_z   = vec3(0.0, 0.0, 1.0);\nconst vec2  fv2_1   = vec2(1.0, 1.0);\nconst vec2  fv2_0   = vec2(0.0, 0.0);\nconst vec2  fv2_x   = vec2(1.0, 0.0);\nconst vec2  fv2_y   = vec2(0.0, 1.0);\nconst float PI      = 3.14159265359;\nconst float TAU     = PI * 2.0;\nconst float MAX_FLOAT = intBitsToFloat(0x7f7fffff);\n\n\n// less common\nconst float rmMaxSteps = 350.0;\nconst float rmMaxDist  = 150.0;\nconst float rmEpsilon  =   0.01;\nconst float grEpsilon  =   0.001;\nconst float nrmBackoff =   grEpsilon * 1.0;\n\nconst float shadowFac  = 0.2;           // 1.0 for no shadows, 0.0 for black.\nconst vec3  clr_fog   = vec3(0.0, 0.03, 0.05);\n\n#define SHOW_PIXEL_COST 0\n\nfloat gT = 0.0;\n\n#define mat_no_hit -1\n#define mat_0       0\n#define mat_1       1\n#define mat_2       2\n#define mat_3       3\n#define mat_4       4\n\n#define clr_cyn vec3(0.5, 0.8, 0.8)\n#define clr_er1 vec3(1e3, 0e0, 0e0)\n#define clr_er2 vec3(1e3, 0e0, 1e3)\n#define clr_er3 vec3(0e0, 0e0, 1e3)\n#define clr_grn vec3(0.1, 0.9, 0.3)\n#define clr_mag vec3(0.7, 0.0, 0.1)\n#define clr_pnk vec3(1.0, 0.5, 0.7)\n#define clr_red vec3(0.4, 0.2, 0.2)\n#define clr_wht vec3(0.8, 0.8, 0.8)\n#define clr_yel vec3(1.0, 1.0, 0.0)\n\nstruct SurfaceHit {\n    int  material;\n    vec3 position;\n};\n\n// from IQ's https://www.shadertoy.com/view/XlcSz2\nfloat checkers2D(vec2 p)\n{\n    vec2 ddx = dFdx(p); \n    vec2 ddy = dFdy(p); \n\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 albedo(in SurfaceHit sh) {\n    if (false) {\n        // noop\n    }\n    else if (sh.material == mat_no_hit) {\n        return clr_fog;\n    }\n    else if (sh.material == mat_0) {\n        return clr_pnk * (0.7 + 0.3 * checkers2D(vec2(sh.position.y - gT * 3.0, 0.1) * 1.0));\n    }\n    else if (sh.material == mat_1) {\n        return clr_grn * (0.7 + 0.3 * checkers2D(vec2(sh.position.y - gT * 3.0, 0.1) * 1.0));\n    }\n    else if (sh.material == mat_2) {\n        float ch = checkers2D(sh.position.xz * 0.1);\n        float w = 1.0/(2.0 + dot(sh.position.xz, sh.position.xz));\n        vec3 c1 = mix(clr_yel, clr_wht, smoothstep(0.5 - w, 0.5 + w, 2.0 * abs(-0.5 + fract(-gT * (ch - 0.5) * 2.0 + 16.0 * (atan(sh.position.x, sh.position.z) / TAU)))));\n        vec3 c2 = mix(clr_red, clr_cyn, ch);\n        return mix(c1, c2, clamp(length(sh.position.xz) / (rmMaxDist * 0.5) + 0.2, 0.0, 1.0));\n    }\n    else if (sh.material == mat_3) {\n        return clr_mag * (0.7 + 0.3 * checkers2D(vec2(sh.position.y + gT * 3.0, 0.1) * 1.0));\n    }\n    else if (sh.material == mat_4) {\n        return clr_wht;\n    }\n    else {\n        return clr_er1;\n    }\n}\n\n\n// based on https://www.shadertoy.com/view/Wtf3Df\nvec3 getRayDirection(in vec3 ro, in vec3 lookAt, in vec2 uv, float zoom) {\n  vec3 ol       = normalize(lookAt - ro);\n  vec3 screenRt = cross(ol      , fv3_y); // world Up\n  vec3 screenUp = cross(screenRt, ol   );\n  vec3 rd       = normalize(uv.x * screenRt + uv.y * screenUp + ol * zoom);\n  return rd;\n}\n\nfloat sdfSphere(in vec3 p, float radius) {\n  return length(p) - radius;\n}\n\nfloat sdfCylinderX(in vec3 p, float radius) {\n  return length(p.yz) - radius;\n}\n\nfloat sdfFloor(in vec3 p, float height) {\n  float lxz = length(p.xz);\n  float floorRipple = sin(sqrt(lxz) * 2.0 + mod(gT, 25.0) * -25.0) * 0.4;\n  floorRipple *= 7.0 * smoothstep(0.0, 20.0, lxz) / (1.0 + lxz * 0.05);\n  return p.y - height + floorRipple;\n}\n\n// todo: how to get the material without all this ternaries ?\n//       we only care about material during shading, not when marching or getting normal.\n//       idea: two SDF fn's, only one of which has the material logic.\n//             this could be made even uglier by using #def's.\n//             #def SDF_FULL(all the things) {\\...\\...\\}\n//             #def INCLUDE_MATERIAL false\n//             #def SDF_NO_MAT(p) SDF_FULL\n//             #def INCLUDE_MATERIAL true\n//             etc. ugh.\nfloat sdf(in vec3 p, out int material) {\n  const float sphRad = 5.0;\n\n  float d = MAX_FLOAT;\n  float D;\n  int   m = mat_no_hit;\n\n  D = sdfSphere(p,  sphRad);\n  d = min(d, D);\n  m = d == D ? mat_0 : m;\n\n  const float offset = 1.1;\n  vec3 pax = vec3(abs(p.x) -offset * sphRad, p.y, p.z);\n  D = sdfSphere(pax,  sphRad);\n  d = max(d, -D);\n  m = d == -D ? mat_1 : m;\n\n  pax.x += sphRad * 0.65;\n  pax.x *= -1.0;\n  D = pax.x;\n  d = max(d, -D);\n\n  D = sdfCylinderX(p, sphRad * 0.5);\n  d = max(d, -D);\n  m = d == -D ? mat_3 : m;\n\n  D = sdfSphere(p,  sphRad * 0.2  );\n  d = min(d, D);\n  m = d == D ? mat_4 : m;\n\n  // lower the floor slightly to avoid some shadow tearing.\n  D = sdfFloor (vec3(p.xz, p.y + 0.2).xzy, -sphRad);\n  d = min(d, D);\n  m = d == D ? mat_2 : m;\n\n  material = m;\n\n  return d;\n}\n\n// from http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions\nvec3 estimateNormal(vec3 p) {\n  const float e = grEpsilon;\n  int unused;\n  return normalize(vec3(\n    sdf(vec3(p.x + e, p.y    , p.z    ), unused) - sdf(vec3(p.x - e, p.y    , p.z    ), unused),\n    sdf(vec3(p.x    , p.y + e, p.z    ), unused) - sdf(vec3(p.x    , p.y - e, p.z    ), unused),\n    sdf(vec3(p.x    , p.y    , p.z + e), unused) - sdf(vec3(p.x    , p.y    , p.z - e), unused)\n  ));\n}\n\n\nSurfaceHit march(in vec3 p, in vec3 rd, out float numSteps) {\n  SurfaceHit sh; // = SurfaceHit(mat_no_hit, vec3(0.0));\n\n  float distTotal = 0.0;\n  for (numSteps = 0.0; (numSteps < rmMaxSteps) && (distTotal <= rmMaxDist); ++numSteps) {\n    int mat;\n    float d = sdf(p, mat);\n    if (d < rmEpsilon) {\n      sh.material = mat;          \n      sh.position = p;\n      return sh;\n    }\n    p += rd * d;\n    distTotal += d;\n  }\n  sh.material = mat_no_hit;\n  sh.position = p;\n  return sh;\n}\n\nfloat AO(in vec3 p, in vec3 n) {\n    int _;\n    float ret = min(1.0, (sdf(p + n * 0.6, _) * 2.0 + 2.0) / 3.0);\n    return ret;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    RGBA.a   = 1.0;\n\n    float smallWay = min(iResolution.x, iResolution.y);\n    vec2  uv = (XY * 2.0 - fv2_1 * iResolution.xy)/smallWay;\n    gT  = iTime * TAU * 0.01;\n    vec3  ro = vec3( vec2(cos(gT), sin(gT)) * 30.0, mix(0.0, 20.0, sin(gT * 0.21) * 0.5 + 0.5)).xzy;\n    vec3  la = vec3( 0.0, 0.0, 0.0);\n    float zoom = 4.0;\n    vec3  rd = getRayDirection(ro, la, uv, zoom);\n\n    vec3  rgb = clr_fog;\n\n    vec3  ld = normalize(vec3(sin(gT * -3.0), 2.0 * (sin(gT * 5.0) * 0.4 + 0.6), cos(gT * -3.0)));\n\n    float numSteps;\n    SurfaceHit sh = march(ro, rd, numSteps);\n    rgb = albedo(sh);\n\n    vec3 nrm = estimateNormal(sh.position - rd * nrmBackoff);\n\n    float numSubSteps;\n\n    if (sh.material == mat_2) {\n      SurfaceHit shrf = march(sh.position + nrm * 0.01, reflect(rd, nrm), numSubSteps);\n      rgb = mix(rgb, albedo(shrf), 0.2);\n      numSteps += numSubSteps;\n    }\n    if (sh.material == mat_4) {\n      SurfaceHit shrf = march(sh.position + nrm * 0.01, reflect(rd, nrm), numSubSteps);\n      rgb = mix(rgb, albedo(shrf), 0.2);\n      numSteps += numSubSteps;\n    }\n\n    if (sh.material != mat_no_hit) {\n      // shading\n      float shadeFac = max(shadowFac, dot(ld, nrm));\n\n      // shadow\n      SurfaceHit shsh = march(sh.position + nrm * 0.01, ld, numSubSteps);\n      numSteps += numSubSteps;\n      if (shsh.material != mat_no_hit) {\n          shadeFac = shadowFac;\n      }\n\n      rgb *= shadeFac;\n      \n      rgb *= AO(sh.position, nrm);\n    }\n\n    // fog\n    float dist = length(ro - sh.position);\n    rgb = mix(rgb, clr_fog, clamp(dist/rmMaxDist - 0.1, 0.0, 1.0));\n\n    // gamma\n    // rgb = pow(rgb, vec3(0.4545));\n    rgb = pow(rgb, vec3(0.6));\n  \n    #if SHOW_PIXEL_COST\n    rgb.r += numSteps / rmMaxSteps;\n    #endif\n\n    RGBA.rgb = rgb;\n}\n\n\n// grimoire bindings\n#ifdef GRIMOIRE\nout vec4 fragColor; void main() { mainImage(fragColor, gl_FragCoord.xy); }\n#endif\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}