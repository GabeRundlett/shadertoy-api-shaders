{
    "Shader": {
        "info": {
            "date": "1466656206",
            "description": "Zooming into the Mandelbrot Set using the escape time algorithm as a fragment shader.\nNote the math breaks down around 20 seconds which is at a zoom factor of 2^20.\nI have some baked in Offsets on the Complex Plane that are zoomed into.",
            "flags": 0,
            "hasliked": 0,
            "id": "MsyXDV",
            "likes": 3,
            "name": "Mandelbrot-Zoom",
            "published": 3,
            "tags": [
                "2d",
                "fractal",
                "mandelbrot"
            ],
            "usePreview": 0,
            "username": "SparkX120",
            "viewed": 1133
        },
        "renderpass": [
            {
                "code": "/**\n * Adapted from my Mandelbrot-JS Project\n * http://sparkx120.github.io/mandelbrot.html\n * https://github.com/Sparkx120/mandelbrot-js\n * \n * By: James Wake (SparkX120)\n * Copyright (c) 2016 James Wake\n * \n * MIT\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\n * software and associated documentation files (the \"Software\"), to deal in the Software\n * without restriction, including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons\n * to whom the Software is furnished to do so, subject to the following conditions:\n *  \n * The above copyright notice and this permission notice shall be included in all copies or\n * substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    const float iterations = 512.;\n    const float maxZoom    = 20.;\n    \n    vec2  R      = iResolution.xy;                              // Resolution Variable\n    float scale  = 0.5*exp2(mod(iTime, maxZoom));         // Set Scale to 2^time and Loop at MaxZoom\n    vec2  scalar = vec2(3.5,3.5*R.y/R.x)/scale;                 // Always fit width\n    vec2  aspect = vec2(1.4,2.0);                               // Old Coord Compatibility\n    \n    vec2     offset  = vec2(0);                                 // Hacky solution for multiple coordinates\n    float    modTime = mod(iTime/maxZoom, 3.0);\n    offset = modTime < 1. ? vec2(21.30899,-5.33795) :\n             modTime < 2. ? vec2(5.39307,-41.7374)  :\n                            vec2(48.895,0)          ;\n    \n    vec2 T  = fragCoord-R*offset*scale/100.;                    // Mandelbrot Space Transform\n    vec2 z0 = scalar/R*T - scalar/aspect;                       // Scaling and Aspect Correction\n    vec2 z  = vec2(0);\n    \n    float iteration = iterations;\n    \n    for (float i=0.0; i < iterations; i++) {                    // Escape Time Computation\n        //z = vec2(z.x*z.x-z.y*z.y, 2.0*z.x*z.y) + z0;\n        z = mat2(z,-z.y,z.x)*z + z0;\n        if(dot(z, z) > 4.){ iteration = i; break; }\n    }\n    \n    // Custom Color Shader based on log functions\n    float intensity = iteration == iterations ? 0.0 : iteration/iterations;\n    float redGreen  = intensity*((-1./4.)*log((-1.0/11.112347)*intensity+0.09)-0.25);\n    float blue      = (intensity*(1.-2.4*log(intensity+0.0000000001)));\n\tfragColor       = vec4(redGreen,redGreen, blue, 1);\n}\n\n/* Old Shader\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    const float iterations = 512.0;                             // Iterations to compute over\n    const float maxZoom    = 20.0;                              // Max Zoom Time\n    float scale  = 0.5*pow(2.0, mod(iTime, maxZoom));     // Set Scale to 2^time and Loop at MaxZoomTime\n    \n\tfloat width  = iResolution[0];                              // Width Height\n\tfloat height = iResolution[1];                              //\n      \n    float widthScalar  = 3.5/scale;                             // Always fit width\n    float heightScalar = 3.5*height/width/scale;                // scale height\n        \n    float Px = fragCoord.x;                                     // Set Pixel Position\n    float Py = fragCoord.y;                                     //\n    \n    vec2 offset   = vec2(0.0, 0.0);                             // Hacky solution for multiple coordinates\n    float modTime = mod(iTime/maxZoom, 3.0);\n    if(modTime >= 0.0 && modTime < 1.0){\n      offset = vec2(21.30899, -5.33795);                        // Coordinate 1\n    }\n    if(modTime >= 1.0 && modTime < 2.0){\n      offset = vec2(5.39307,-41.7374);                          // Coordinate 2\n    }\n    if(modTime >= 2.0 && modTime < 3.0){\n      offset = vec2(48.895,0.0);                                // Coordinate 3\n    }\n    \n    float xDelta = iResolution.x/100.0*offset.x;                // Mandelbrot space offset\n    float yDelta = iResolution.y/100.0*offset.y;                //\n    \n    float Tx = Px-xDelta*scale;                                 // X-Y Translation\n    float Ty = Py-yDelta*scale;\n    float x0 = widthScalar/width*Tx - widthScalar/1.4;          // Scaling and Aspect Correction\n    float y0 = heightScalar/height*Ty - heightScalar/2.0;       //\n    float x  = 0.0;\n\tfloat y  = 0.0;\n    \n    float iteration = iterations;\n    int end = 0;\n    \n    for (float i=0.0; i < iterations; i++) {                    // Escape Time Computation\n        float xtemp = x*x-y*y+x0;\n        y = 2.0*x*y+y0;\n        x = xtemp;\n        if(x*x+y*y > 4.0){\n            iteration = i;\n            break;\n        }\n    }\n    \n    float intensity = iteration == iterations ? 0.0 : iteration/iterations;\n    \n    // Custom Color Shader based on log functions\n    float redGreen = intensity*((-1.0/4.0)*log((-1.0/11.112347)*intensity+0.09)-0.25);\n    float blue = (intensity*(1.0-2.4*log(intensity+0.0000000001)));\n    \n\tfragColor = vec4(redGreen,redGreen, blue, 1.0);\n}*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}