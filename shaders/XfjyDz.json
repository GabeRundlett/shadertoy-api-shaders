{
    "Shader": {
        "info": {
            "date": "1722178663",
            "description": "Optical illusion, dots at the edge of you vision look like they are filled with black. But when you focus on them they are completely white.\n\nNothing out of the ordinary.",
            "flags": 0,
            "hasliked": 0,
            "id": "XfjyDz",
            "likes": 2,
            "name": "Very normal dot grid illusion",
            "published": 3,
            "tags": [
                "simple",
                "illusion",
                "funny",
                "trainning"
            ],
            "usePreview": 0,
            "username": "SSAlp",
            "viewed": 94
        },
        "renderpass": [
            {
                "code": "// Center coordinates and normalize them with respect to the y axis \nvec2 normCenter(vec2 coord)\n{\n    // Center the coordinates\n    vec2 centered = coord - (iResolution.xy / 2.0);\n    // Normalized pixel coordinates (from 0 to 1) with respect to the y axis\n    vec2 normalized = centered / iResolution.y;\n    return normalized;\n}\n\n// basic pseudo-random function. Takes a seed (any float) and gives back a pseudo-random float between 0 and 1.\n// Not uniform.\n// https://thebookofshaders.com/10/\nfloat random(float seed)\n{\n    return fract(sin(seed * 78.233) * 43758.5453123);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 white = vec3(1, 1, 1);\n    // What percent of white do you want your gray to be (0 = black, 1 = white)\n    float grayFactor = 0.4;\n    // distance between grid lines\n    float gridSpacing = 0.2;\n    // width of grid lines\n    float gridWidth = 0.025;\n    // vector of grid shift (can also be seen as the position of one grid intersection relative to the center of\n    // the screen)\n    vec2 gridShift = vec2(0.0, 0.0);\n    // the radius of the dots at the intersections should be the ditance between the intersection and the corner\n    // created by the intersecting grid lines. Such that the dot \"fills\" the intersection and touches the corner\n    // of the black squares.\n    float dotRad = length(vec2(gridWidth, gridWidth)/2.0);\n    // the radius of the small dot\n    float bDotRad = dotRad * 0.7;\n    // frequency of apparition of a new random black dot (Hz)\n    float bDotFreq = 0.5;\n    // time during which the random black dot is visible. Currently we can't display more than one black dot at a\n    // time, thus the actual duration will be max(bDotDuration, 1/bDotFreq).\n    float bDotDuration = 0.02;\n    \n    vec2 uv = normCenter(fragCoord.xy);\n    \n    // distance (on x and y) to the next grid lines WHEN GOING TOWARD (0,0). This distance is relative to lines\n    // spacing. example : if relDistToNext = (0.7, 0.1) then there is 70% of the way left between the last\n    // vertical grid line and the next and 10% of the way left from the last horizontal grid line to the next.\n    vec2 relDistToNext = fract((uv + gridShift) / gridSpacing);\n    // distance (on x and y) to the closest grid lines. Relative to lines spacing.\n    vec2 relDistToGrid = min(relDistToNext, 1.0 - relDistToNext);\n    // distance (on x and y) to the closest grid lines.\n    vec2 distToGrid = relDistToGrid * gridSpacing;\n    \n    // Euclidian distance to the closest intersection\n    float distToDot = length(distToGrid);\n    \n    // Change random seed according to our determined frequency\n    float seed = floor(iTime * bDotFreq);\n    // Choose ramdom point on screen\n    vec2 randCoord = vec2(iResolution.x * random(seed), iResolution.y * random(seed + 1.0));\n    // random point with normalized coordinates\n    vec2 uvBDot = normCenter(randCoord);\n    // closest intersection to our random coordinate.\n    vec2 bDotIntersection = round((uvBDot + gridShift) / gridSpacing) * gridSpacing;\n    \n    // we determine wether or not the black dot should be diplayed based on its duration.\n    float timeSinceBDotApparition = fract(iTime * bDotFreq) / bDotFreq;\n    bool isBDotVisible = timeSinceBDotApparition <= bDotDuration;\n    \n    float isOnGrid = float((distToGrid.x <= gridWidth / 2.0) || (distToGrid.y <= gridWidth / 2.0));\n    float isOnDot = float(distToDot <= dotRad);\n    float isNotOnBDot = float(distance(uv, bDotIntersection) > bDotRad || !isBDotVisible);\n    \n    // grid lines are colored in gray and the dots at the intersections are colored in white. The random black\n    // dot is colorer in black.\n    vec3 col = (white * (isOnGrid * grayFactor) + white * (isOnDot * (1.0 - grayFactor))) * isNotOnBDot;\n\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}