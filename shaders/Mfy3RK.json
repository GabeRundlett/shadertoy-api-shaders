{
    "Shader": {
        "info": {
            "date": "1712963069",
            "description": "A set of function intended for drawing decimal and hexadecimal numbers as 7-segment display, that can de used for debugging or just displaying numbers.",
            "flags": 0,
            "hasliked": 0,
            "id": "Mfy3RK",
            "likes": 3,
            "name": "7-Segment display functions",
            "published": 3,
            "tags": [
                "font",
                "7segment",
                "debug",
                "digits",
                "util"
            ],
            "usePreview": 0,
            "username": "GetItemFromBlock",
            "viewed": 138
        },
        "renderpass": [
            {
                "code": "// GetItemFromBlock - 2024-04-13\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Update - 2024-04-14\n// Remade segment function and added other characters (point, colon and minus) based on\n// @FabriceNeyret2's and @spalmer's comments - Thanks for the feedback and suggestions :)\n\n#define pnt_radius 0.009\n#define seg_length 0.02\n#define seg_width 0.008\n#define seg_offset 0.031\n#define txt_offset 0.095\n\n// constants for segments, one byte is one number\n// 0 is lowest byte of first number and f is highest byte of fourth's number\n// 0123456789AbCdEF\nconst int numbers[] = int[](\n    0x7c790c5f,\n    0x4c77762e,\n    0x376f7e7f,\n    0x63733d53\n);\n\n// constants for segments and points offsets\nconst vec2 deltas[] = vec2[](\n    vec2( seg_offset, seg_offset),\n    vec2( seg_offset,-seg_offset),\n    vec2(-seg_offset, seg_offset),\n    vec2(-seg_offset,-seg_offset),\n    vec2(         0.,seg_offset*2.),\n    vec2(         0.,        0.),\n    vec2(         0.,-seg_offset*2.),\n    // minus\n    vec2(         0.,        0.),\n    // dot\n    vec2(         0., seg_offset*2.),\n    // colon\n    vec2(         0., seg_offset),\n    vec2(         0.,-seg_offset)\n);\n\n// \"string\" for storing text used by draw_text function\n// one character is 4 bits\n#define text_length 16\n#define text_length2 text_length >> 3\nconst uint text[] = uint[text_length2](\n    0x76543210u,\n    0xfedcba98u\n);\n\nfloat vseg(vec2 uv)\n{\n    vec2 p = abs(uv) - vec2(seg_width, seg_length);\n    return max(p.x, p.y+p.x);\n}\n\nfloat hseg(vec2 uv)\n{\n    vec2 p = abs(uv) - vec2(seg_length, seg_width);\n    return max(p.x+p.y, p.y);\n}\n\nfloat pnt(vec2 uv)\n{\n    vec2 p = abs(uv);\n    return length(p)-pnt_radius;\n}\n\nfloat colon(vec2 uv, vec2 pos)\n{\n    return smoothstep(1.5/iResolution.y, 0., min(pnt(uv+deltas[9] - pos), pnt(uv+deltas[10] - pos)));\n}\n\nfloat point(vec2 uv, vec2 pos)\n{\n    return smoothstep(1.5/iResolution.y, 0., pnt(uv+deltas[8] - pos));\n}\n\nfloat minus(vec2 uv, vec2 pos)\n{\n    return smoothstep(1.5/iResolution.y, 0., hseg(uv+deltas[7] - pos));\n}\n\nfloat number(int n, vec2 uv, vec2 pos)\n{\n    // Just a random big number, nothing to see here ;)\n    float r = 299792458.;\n    int submask = n & 0x3;\n    int mask = numbers[n>>2];\n    mask = mask >> (submask<<3);\n    for (int i = 0; i < 7; i++)\n    {\n        if ((mask & 1) != 0)\n        {\n            if (i > 3)\n            {\n                r = min(r, hseg(uv+deltas[i] - pos));\n            }\n            else\n            {\n                r = min(r, vseg(uv+deltas[i] - pos));\n            }\n        }\n        mask = mask >> 1;\n    }\n    return smoothstep(1.5/iResolution.y, 0., r);\n}\n\nfloat draw_text(vec2 uv, vec2 pos)\n{\n    float r = 0.;\n    for (int n = 0; n < text_length; n++)\n    {\n        int submask = n & 0xf;\n        uint mask = text[n>>3];\n        mask = mask >> (submask<<2);\n        mask = mask & 0xfu;\n        r = max(r, number(int(mask), uv, pos));\n        pos.x += txt_offset;\n    }\n    return r;\n}\n\nfloat draw_int(int value, vec2 uv, vec2 pos)\n{\n    if (value == 0)\n    {\n        return number(0, uv, pos);\n    }\n    float r = 0.;\n    bool neg = false;\n    if (value < 0)\n    {\n        value = -value;\n        neg = true;\n    }\n    for (int n = 0; n < 9 && value != 0; n--)\n    {\n        int tmp = value / 10;\n        int d = value - tmp * 10;\n        value = tmp;\n        r = max(r, number(d, uv, pos));\n        pos.x -= txt_offset;\n    }\n    if (neg) r = max(r, minus(uv, pos));\n    return r;\n}\n\nfloat draw_test(vec2 uv, vec2 pos)\n{\n    float r = 0.;\n    r = max(r, number(8,uv, pos));\n    pos.x -= txt_offset;\n    r = max(r, number(8,uv, pos));\n    pos.x -= txt_offset;\n    r = max(r, minus(uv, pos));\n    pos.x -= txt_offset;\n    r = max(r, number(8,uv, pos));\n    pos.x -= txt_offset;\n    r = max(r, point(uv, pos));\n    pos.x -= txt_offset;\n    r = max(r, number(8,uv, pos));\n    pos.x -= txt_offset;\n    r = max(r, colon(uv, pos));\n    pos.x -= txt_offset;\n    r = max(r, number(8,uv, pos));\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy;\n    uv.x -= (iResolution.x - iResolution.y) / (2.*iResolution.y);\n    uv -= 0.5;\n\n    vec3 col = vec3(0.);\n    col = mix(col, vec3(1.), draw_test(uv, vec2(0.6,0.4)));\n    col = mix(col, vec3(1.), draw_text(uv, vec2(-0.7,0.)));\n    col = mix(col, vec3(1.), draw_int(int(iFrameRate*1000.), uv, vec2(0.6,-0.2)));\n    col = mix(col, vec3(1.), draw_int(int(iTime*1000.), uv, vec2(0.6,-0.4)));\n    col = mix(col, vec3(1.), draw_int(-7320508, uv, vec2(0.6,0.2)));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}