{
    "Shader": {
        "info": {
            "date": "1492731527",
            "description": "Slowly porting over my Intro to Graphics project objective by objective. This section hopefully demonstrates the \"soft shadows\" objective.\n\nA brief rundown of my project can be found at: http://mattrobertson.ca/raytracer.html",
            "flags": 0,
            "hasliked": 0,
            "id": "XsByzW",
            "likes": 3,
            "name": "Ray Traced Soft Shadows",
            "published": 3,
            "tags": [
                "raytracer",
                "shadow",
                "raytrace",
                "softshadows",
                "distributed"
            ],
            "usePreview": 0,
            "username": "twitchingace",
            "viewed": 623
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159\nconst int numSoft = 32;\nvec3 eye = vec3(0.0, 0.0, 800.);\nconst float amb = 0.1;\n\nconst int numL = 3;\nconst int numSpheres = 4;\n\nstruct Light{\n    vec3 pos;\n    vec3 col;\n};\nLight l[numL];\n    \nstruct Material{\n\tvec3 kd;\n    vec3 ks;\n    float reflectance;\n    float transparency;\n    float indR;\n    float phongN;\n    \n};\n   \nstruct Sphere{\n\tvec3 pos;\n    Material mat;\n    float radius;\n};\nSphere spheres[numSpheres];\n    \nstruct Ray{\n\tvec3 ro;\n    vec3 rd;\n    float indR;\n};\n    \nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat intersectSphere(Ray ray, Sphere s){\n    vec3 d = ray.ro - s.pos;\n    float A = dot(ray.rd, ray.rd);\n    float B = 2. * dot(ray.rd, d);\n    float C = dot(d, d) - s.radius * s.radius;\n        \n    float D = B*B - 4.*A*C;\n    if (D < 0.0) return -1.0;\n    \n    float t = -B - sqrt(D);\n\tif (t / (2.0 * A) < 0.) { // Closest intersection behind the ray\n  \t\tt += 2.*sqrt(D); // t = -B + sqrt(D)\n\t}\n\tif (t / (2.0 * A) < 0.) {\n  \t\treturn -1.0;\n\t}\n \treturn t / (2.0 * A);   \n}\n\n// Returns true if there's an object that intersects with the ray. Used for shadowing.\nbool castShadow(Ray ray){\n    for (int i = 0; i  < numSpheres; i++){\n    \tfloat t = intersectSphere(ray, spheres[i]);\n\t    if (t >= 0.1){\n    \t\treturn true;\n    \t}\n    }\n    return false;\n}\n\n// Ray that hits the surface, how far along it does, the surface normal, and the hit material\nvec3 phongLight(Ray ray, vec3 sP, vec3 norm, Material mat){\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < numL; i++){\n        vec3 col2 = vec3(0.0);\n        for (int j = 0; j < numSoft; j++){\n            vec3 lpos = l[i].pos;\n            lpos.x += 75. * rand(vec2(j,3.2));\n            lpos.y += 75. * rand(vec2(j,1.4));\n            lpos.z += 75. * rand(vec2(j,7.3));\n            \n            vec3 sDir = lpos - sP;\n            sDir /= length(sDir);\n            Ray sRay;\n            sRay.rd = sDir;\n            sRay.ro = sP;\n\n            if (castShadow(sRay)){\n                continue;   \n            }\n\n            // Add in diffuse bit\n            float diffCoeff = max(0.0, dot(norm, sDir));\n            col2.x += mat.kd.x * l[i].col.x * diffCoeff;\n            col2.y += mat.kd.y * l[i].col.y * diffCoeff;\n            col2.z += mat.kd.z * l[i].col.z * diffCoeff;\n\n            // Add in specular bit\n            vec3 refDir = reflect(sDir, norm);\n            float specDot = max(0.0, dot(ray.rd, refDir));\n            float specCoeff = pow(specDot, mat.phongN);\n\n            col2.x += mat.ks.x * l[0].col.x * specCoeff;\n            col2.y += mat.ks.y * l[0].col.y * specCoeff;\n            col2.z += mat.ks.z * l[0].col.z * specCoeff;\n        }\n        col += col2 / float(numSoft);\n    }\n    col /= float(numL);\n    return col + amb * mat.kd;\n}\n\nvec3 castRay(Ray ray){\n    Material hitM = Material(vec3(0.0), vec3(0.0), 0.0, 0.0, 0.0, 0.0);\n    vec3 hitNorm = vec3(0.0);\n    float tMin = 999999.0;\n    \n    // Let's go through each object in the scene, check which is the closest\n    for (int i = 0; i  < numSpheres; i++){\n    \tfloat t = intersectSphere(ray, spheres[i]);\n\t    if (t >= 0.1 && t <= tMin){\n    \t\thitM = spheres[i].mat;\n        \thitNorm = ray.ro + t * ray.rd - spheres[i].pos;\n\t        hitNorm /= length(hitNorm);\n    \t    tMin = t;\n    \t}\n    }\n    \n    // Do Phong reflection model\n    if (tMin < 9999.0){\n    \treturn phongLight (ray, ray.ro + tMin *ray.rd, hitNorm, hitM);        \n    }\n    return vec3(0.0);\n}\n\nvoid initScene(){\n    // Define lights\n    l[0] = Light(vec3(-600.0, 200., 00.0), vec3(0.9));\n    l[1] = Light(vec3(0.0, 400., 400.0), vec3(0.9));\n    l[2] = Light(vec3(600.0, 200., 00.0), vec3(0.9));\n    \n    // Define materials\n    Material m1 = Material(vec3(0.6, 0.6, 0.6), vec3(0.4), 0.5, 0.0, 1.0, 14.);\n    Material m2 = Material(vec3(0.3, 0.6, 0.4), vec3(0.4), 0.0, 0.5, 1.52, 14.);\n    \n    //Define shapes\n    spheres[0] = Sphere(vec3(-200.0, 100.0, 100.0), m1, 150.);\n    spheres[1] = Sphere(vec3(000.0, 0.0, -300.0), m2, 150.);\n    spheres[2] = Sphere(vec3(0.0, -750.0, 00.0), m2, 600.);\n    spheres[3] = Sphere(vec3(00.0, 0.0, -2500.0), m1, 1500.);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    initScene();\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy - vec2(0.5);\n    vec2 size = iResolution.xy;\n    \n    spheres[0].pos = vec3(0.0 + cos(iTime) * 300., 100.0, -300. + sin(iTime) * 400.);\n    \n    vec3 col = vec3(0.0);\n    Ray ray = Ray(vec3(0.0), vec3(0.0), 1.0);\n    ray.ro = eye;\n    ray.rd = vec3(uv, -1.0);\n    ray.rd /= length(ray.rd);       \n               \n    col += castRay(ray);\n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}