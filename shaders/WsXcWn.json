{
    "Shader": {
        "info": {
            "date": "1588652330",
            "description": "- The layout comes from tracing a polyhedron's geodesics; pillars are at its vertices\n- Tall pillars: pos curvature (270° around); arch pillars: neg curvature (450° around)\n- The \"laser\" and camera path follow one closed geodesic\n- Inputs: Mouse, S, D, F",
            "flags": 48,
            "hasliked": 0,
            "id": "WsXcWn",
            "likes": 113,
            "name": "Non-Euclidean world",
            "published": 3,
            "tags": [
                "portal",
                "laser",
                "ssao",
                "curvature",
                "noneuclidean",
                "geodesic"
            ],
            "usePreview": 1,
            "username": "tmst",
            "viewed": 2077
        },
        "renderpass": [
            {
                "code": "#define DEPTH(texCoord) textureLod(iChannel0, texCoord, 0.0).a\n\nvoid outlineCheck(in vec2 uv, in float weight, in float aBase, inout float n) {\n    n += weight * (1.0 - isInInterval(aBase-0.004, aBase+0.004, DEPTH(uv)));\n}\n\nfloat outline(in vec2 uv, in float aBase) {\n    vec2 uvPixel = 1.0/iResolution.xy;\n    float n = 0.0;\n\n    outlineCheck(uv + vec2( 1.0, 0.0)*uvPixel, 0.125, aBase, n);\n    outlineCheck(uv + vec2( 0.0, 1.0)*uvPixel, 0.125, aBase, n);\n    outlineCheck(uv + vec2( 0.0,-1.0)*uvPixel, 0.125, aBase, n);\n    outlineCheck(uv + vec2(-1.0, 0.0)*uvPixel, 0.125, aBase, n);\n\n    outlineCheck(uv + vec2( 1.0, 1.0)*uvPixel, 0.125, aBase, n);\n    outlineCheck(uv + vec2( 1.0,-1.0)*uvPixel, 0.125, aBase, n);\n    outlineCheck(uv + vec2(-1.0, 1.0)*uvPixel, 0.125, aBase, n);\n    outlineCheck(uv + vec2(-1.0,-1.0)*uvPixel, 0.125, aBase, n);\n\n    return n;\n}\n\nvec2 ssao(vec2 fragCoord) {\n    vec2 texCoord = fragCoord / iResolution.xy;\n    vec2 texColorSize = iResolution.xy;\n\n    float d = DEPTH(texCoord);\n    float scaleBase = 0.25/d;\n\n    vec2 offset[16];\n    float rand = hash12(fragCoord);\n    vec2 invRes = 1.0 / iResolution.xy;\n    \n    mat2 m = mat2(INV_SQRT2, INV_SQRT2, -INV_SQRT2, INV_SQRT2);\n\n    float dSample = 2.0*scaleBase;\n    float ra = rand*PI_OVER_2;\n    vec2 r = vec2(cos(ra), sin(ra));\n    offset[ 0] = dSample*vec2( r.x, r.y)*invRes;\n    offset[ 1] = dSample*vec2(-r.y, r.x)*invRes;\n    offset[ 2] = dSample*vec2(-r.x,-r.y)*invRes;\n    offset[ 3] = dSample*vec2( r.y,-r.x)*invRes;\n\n    dSample = 4.0*scaleBase;\n    r = m*r;\n    offset[ 4] = dSample*vec2( r.x, r.y)*invRes;\n    offset[ 5] = dSample*vec2(-r.y, r.x)*invRes;\n    offset[ 6] = dSample*vec2(-r.x,-r.y)*invRes;\n    offset[ 7] = dSample*vec2( r.y,-r.x)*invRes;\n\n    dSample = 6.0*scaleBase;\n    r = m*r;\n    offset[ 8] = dSample*vec2( r.x, r.y)*invRes;\n    offset[ 9] = dSample*vec2(-r.y, r.x)*invRes;\n    offset[10] = dSample*vec2(-r.x,-r.y)*invRes;\n    offset[11] = dSample*vec2( r.y,-r.x)*invRes;\n\n    dSample = 8.0*scaleBase;\n    r = m*r;\n    offset[12] = dSample*vec2( r.x, r.y)*invRes;\n    offset[13] = dSample*vec2(-r.y, r.x)*invRes;\n    offset[14] = dSample*vec2(-r.x,-r.y)*invRes;\n    offset[15] = dSample*vec2( r.y,-r.x)*invRes;\n\n    float deeperCount = 0.0;\n    float nearerCount = 0.0;\n    for(int i=0; i<16; ++i){\n        vec2 texSamplePos = texCoord + offset[i];\n        float dsamp = DEPTH(texSamplePos);\n\n        deeperCount += step(d, dsamp);\n        nearerCount += step(dsamp, d);\n    }\n\n    float shadowIntensity = clamp(1.0 - deeperCount/8.0, 0.0, 1.0);\n    float highlightIntensity = clamp(1.0 - nearerCount/8.0, 0.0, 1.0);\n\n    return vec2(shadowIntensity, highlightIntensity);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 dataBase = textureLod(iChannel0, uv, 0.0);\n    vec3 rgb = unpackColor(dataBase.st);\n    float glow = dataBase.b;\n    float depth = dataBase.a;\n    \n    vec2 datassao = ssao(fragCoord);\n    float outlineAmount = outline(uv, depth);\n    \n    vec4 overlay = vec4(0.0);\n    overlay = blendOnto((0.15*datassao.t)*vec4(vec3(1.0), 1.0), overlay);\n    overlay = blendOnto((0.75*datassao.s)*vec4(vec3(0.0), 1.0), overlay);\n    overlay = blendOnto((0.4*outlineAmount) * vec4(vec3(0.0), 1.0), overlay);\n    overlay *= 1.0 - glow;\n\n    bool showOverlay = texelFetch(iChannel1, ivec2(KEY_S,0), 0).x > 0.5;\n    if (showOverlay) {\n        rgb = vec3(0.4);\n    }\n    vec3 finalRGB = blendOnto(overlay, rgb).rgb;\n\n    float dCorner = length(uv - vec2(0.5)) * SQRT2;\n    float vignetteFactor = 1.0 - mix(0.0, 0.4, smoothstep(0.3, 0.9, dCorner));\n    fragColor = vec4(vignetteFactor*finalRGB, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ======================\n// Lighting, colors, sky\n// ======================\n\n#define PILLAR_COLOR vec3(0.5, 0.1, 0.0)\n#define TERRAIN_COLOR vec3(1.0, 0.5, 0.2)\n#define LIGHT_COLOR vec3(1.0, 0.7, 0.5)\n#define GLOW_COLOR vec3(0.2, 0.5, 1.0)\n\n// cf. iq https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos(TWOPI*(c*t+d));\n}\nvec3 colormapPhi(float t) {\n    return pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n}\n\nvec3 colormapTerrainGrass(float h) {\n    return mix(vec3(0.3, 0.2, 0.1), vec3(0.3, 0.6, 0.2), h);\n}\n\nvec3 colormapTerrainStone(float h) {\n    return mix(vec3(0.4), vec3(0.7,0.6,0.5), h);\n}\n\nvec4 glowPremulFromDsq(float dsq) {\n    float glow = 1.0 / (1.0 + 500.0*dsq);\n    vec3 glowColor = mix( GLOW_COLOR, vec3(1.0), smoothstep(0.0, 1.0, glow) );\n    return glow*vec4(glowColor, 1.0);\n}\n\nvec4 skyboxLocal(vec2 phiTheta) {\n    vec2 phiThetaT = vec2(phiTheta.s + 0.05*iTime, phiTheta.t);\n    float a = textureLod(iChannel0, phiThetaT*vec2(1.0,3.0), 0.0).r;\n    a = 0.75*a*a;\n    return a*vec4(vec3(1.0), 1.0);\n}\n\nvec3 skyboxGlobal(vec3 nvDir) {\n    float t = abs(nvDir.y);\n    return colormapPhi(t*(1.0-0.5*t));\n}\n\n#define MAT_SKY 0\n#define MAT_PILLAR 1\n#define MAT_TERRAIN 2\n#define MAT_WATER 3\n\nvoid computeLighting(\n    in int matId,\n    in vec3 lightColor,\n    in vec3 texColor,\n    in vec3 nvNormal,\n    in vec3 nvFragToLight,\n    in vec3 nvFragToCam,\n    out vec3 litColor\n) {\n    float ambientCoefficient = 0.0;\n    float diffuseCoefficient = 0.0;\n    float specularCoefficient = 0.0;\n    float specularExponent = 1.0;\n    switch(matId) {\n        case MAT_PILLAR: {\n            ambientCoefficient = 0.0;\n            diffuseCoefficient = 0.9;\n            specularCoefficient = 0.9;\n            specularExponent = 20.0;\n            break;\n        }\n        case MAT_TERRAIN: {\n            ambientCoefficient = 0.0;\n            diffuseCoefficient = 0.9;\n            specularCoefficient = 0.15;\n            specularExponent = 10.0;\n            break;\n        }\n        case MAT_WATER: {\n            ambientCoefficient = 0.3;\n            diffuseCoefficient = 0.5;\n            specularCoefficient = 0.6;\n            specularExponent = 50.0;\n            break;\n        }\n    }\n\n    float valDiffuse = max(0.0, dot(nvNormal, nvFragToLight));\n    valDiffuse *= diffuseCoefficient;\n\n    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);\n    float valSpecular = pow(max(0.0, dot(nvNormal, blinnH)), specularExponent);\n    valSpecular *= specularCoefficient;\n\n    litColor = clamp((ambientCoefficient+valDiffuse)*texColor*lightColor + valSpecular*lightColor, 0.0, 1.0);\n}\n\n// ======================\n// Geometry and textures\n// ======================\n\n#define EPS 1e-4\n#define T_MAX 25.0\n\n#define SDF_STEPS 50\n#define SDF_EPS 5e-3\n#define SDF_N_EPS 0.015\n\n#define TERRAIN_POM_DEPTH 0.15\n#define TERRAIN_POM_STEPS 16\n#define TERRAIN_N_EPS 0.01\n\n// NOTE: Changing these 3 will break the \"laser\" path\n#define HALF_WIDTH 0.5\n#define HALF_INNER_DIAM 1.0\n#define HALF_OUTER_DIAM 2.4\n\n#define HALF_DEPTH 1.0\n#define PILLAR_RADIUS 0.05\n#define ARCH_B_VERT_OFFSET (0.25*HALF_DEPTH)\n#define LASER_Y (-HALF_DEPTH + 1.5*ARCH_B_VERT_OFFSET)\n\n#define ID_NOTHING 0\n#define ID_PORTAL_LOOP 1\n#define ID_PORTAL_SIDE 2\n#define ID_PORTAL_INNER 3\n#define ID_PORTAL_OUTER 4\n#define ID_PILLAR 5\n#define ID_PLANAR 6\n\n// Helper for hitting multiple materials\nvoid updateHit(inout float tMin, inout int idMin, in float t, in int id) {\n    if (t < tMin) {\n        tMin = t;\n        idMin = id;\n    }\n}\n\n// ----------------------------\n// Miscellaneous useful macros\n// ----------------------------\n\n#define _SDF_NORMAL(sdfFn, p) \\\n    normalize(vec3( \\\n        sdfFn( p+vec3(SDF_N_EPS,0.0,0.0) ) - sdfFn( p-vec3(SDF_N_EPS,0.0,0.0) ), \\\n        sdfFn( p+vec3(0.0,SDF_N_EPS,0.0) ) - sdfFn( p-vec3(0.0,SDF_N_EPS,0.0) ), \\\n        sdfFn( p+vec3(0.0,0.0,SDF_N_EPS) ) - sdfFn( p-vec3(0.0,0.0,SDF_N_EPS) )  \\\n    ))\n\n#define _SDF_HIT(sdfFn, p, pDist, shadowAmount) \\\n\tfloat tPillar = 0.0; \\\n    float didHitPillar = 0.0; \\\n    vec3 pSdf = p; \\\n    for (int i=0; i<SDF_STEPS; i++) { \\\n        float d = sdfFn(pSdf); \\\n        float curShadowAmount = clamp(1.0 - abs(d)/( 0.015 + 0.04*(pDist+tPillar) ), 0.0, 1.0); \\\n        shadowAmount = max(shadowAmount, curShadowAmount); \\\n        if (abs(d) < SDF_EPS || tPillar > t) { \\\n            didHitPillar = 1.0; \\\n            break; \\\n        } \\\n        tPillar += d; \\\n        pSdf += d * nv; \\\n    } \\\n    if (didHitPillar > 0.5) { \\\n        updateHit(t, id, tPillar, ID_PILLAR); \\\n    }\n\n#define _DSQ_POINT_FACE(iFace, p) \\\n\t(iFace == 0 ? dsq0Point(p) : \\\n     iFace == 1 ? dsq1Point(p) : \\\n     iFace == 2 ? dsq2Point(p) : \\\n                  dsq3Point(p) )\n\n#define _DSQ_NORMAL(iFace, p) \\\n\t(iFace == 0 ? _SDF_NORMAL(dsq0Point, p) : \\\n     iFace == 1 ? _SDF_NORMAL(dsq1Point, p) : \\\n     iFace == 2 ? _SDF_NORMAL(dsq2Point, p) : \\\n                  _SDF_NORMAL(dsq3Point, p) )\n\n#define _UV_FACE(iFace, p) \\\n\t(iFace == 0 ? uvFace0(p) : \\\n     iFace == 1 ? uvFace1(p) : \\\n     iFace == 2 ? uvFace2(p) : \\\n                  uvFace3(p) )\n\n#define _DPHI_FACE(iFace, p) \\\n\t(iFace == 0 ? vec2(1.0, 0.0) : \\\n     iFace == 1 ? ( abs(p.x) > abs(p.z) ? vec2(-sign(p.x), 0.0) : vec2(0.0, -sign(p.z)) ) : \\\n     iFace == 2 ? vec2(1.0, 0.0) : \\\n                  ( abs(p.x) > abs(p.z) ? vec2( sign(p.x), 0.0) : vec2(0.0,  sign(p.z)) ) )\n\n// --------------------------------\n// Repeated geometry and bump maps\n// --------------------------------\n\nfloat floorH(int face, vec2 xz) {\n    switch(face) {\n        case 1:\n        case 3: {\n            // Terrain\n            return textureLod(iChannel0, xz*0.15, 0.0).g;\n        }\n        case 0:\n        case 2: {\n            // Water: Ensure match over \"loop portals\"\n            float loopdist = face == 0 ? (4.0*HALF_OUTER_DIAM) : (8.0*HALF_INNER_DIAM);\n            vec2 xzSlow = (xz + vec2(0.0, iTime*0.66)) / loopdist;\n            vec2 xzFast = (xz + vec2(0.0, iTime*1.00)) / loopdist + vec2(0.4, 0.0);\n\n            float hFast = textureLod(iChannel0, xzFast, 0.0).g;\n            float h = textureLod(iChannel0, xzSlow + 0.05*vec2(0.0, hFast), 0.0).g;\n\n            float ts = smoothstep(0.0, 0.8, abs(xz.x)/HALF_WIDTH);\n            return mix(h, hFast, mix(0.5, 0.2, ts));\n        }\n    }\n    return 1.0;\n}\n\n// Coords: y is up, z is depth; arch opening ranges x = [0,halfLen] -> [center,pillar]\nfloat sdPillar(float height, float halfLen, float zCenter, vec3 p) {\n    float baseHeight = PILLAR_RADIUS*0.8;\n    float baseRadius = PILLAR_RADIUS*1.25;\n\n    float dBase = sdBox(\n        vec3(halfLen, -HALF_DEPTH+baseHeight*0.5 - 10.0, zCenter),\n        vec3(baseRadius, baseHeight*0.5 + 10.0, baseRadius),\n        p\n    );\n    float dTop = sdBox(\n        vec3(halfLen, -HALF_DEPTH+height-baseHeight*0.5, zCenter),\n        vec3(baseRadius, baseHeight*0.5, baseRadius),\n        p\n    );\n    float dCol = distance( p.xz, vec2(halfLen, zCenter) ) - PILLAR_RADIUS;\n    return min(dCol, min(dBase, dTop));\n}\n\nfloat sdArchA(float halfLen, float zCenter, vec3 p) {\n    float baseHeight = PILLAR_RADIUS*0.0;\n    float baseRadius = PILLAR_RADIUS*0.8;\n\n    float pillarBaseY = baseHeight;\n    float dVert = sdPillar(2.0*HALF_DEPTH-pillarBaseY, halfLen, zCenter, vec3(p.x, p.y-pillarBaseY, p.z));\n\n    float dArchBase = sdBox(\n        vec3(0.0, -HALF_DEPTH+baseHeight*0.5 - 10.0, zCenter),\n        vec3(halfLen, baseHeight*0.5 + 10.0, baseRadius),\n        p\n    );\n\n    return min(dVert, dArchBase);\n}\n\nfloat sdArchB(float halfLen, float zCenter, vec3 p) {\n    float topHeight = PILLAR_RADIUS*0.8;\n    float baseHeight = ARCH_B_VERT_OFFSET;\n\n    float baseRadius = PILLAR_RADIUS*0.8;\n    float topRadius = PILLAR_RADIUS*4.25;\n\n    float archHeight = HALF_INNER_DIAM;\n    float archCenterY = HALF_DEPTH - 0.5*archHeight;\n\n    // ----------------\n    float pillarBaseY = baseHeight;\n    float dVert = sdPillar(2.0*HALF_DEPTH-archHeight-pillarBaseY, halfLen, zCenter, vec3(p.x, p.y-pillarBaseY, p.z));\n\n    float dArchBase = sdBox(\n        vec3(0.0, -HALF_DEPTH+baseHeight*0.5 - 10.0, zCenter),\n        vec3(halfLen+baseRadius, baseHeight*0.5 + 10.0, baseRadius),\n        p\n    );\n    float dArchTop = sdBox(\n        vec3(0.0, HALF_DEPTH-topHeight*0.5, zCenter),\n        vec3(halfLen+topRadius, topHeight*0.5, topRadius),\n        p\n    );\n\n    float dSoFar = min(dVert, min(dArchBase,dArchTop));\n    // ----------------\n\n    // ----------------\n    float dArchBody = sdBox(\n        vec3(0.0, archCenterY, zCenter),\n        vec3(halfLen+PILLAR_RADIUS, archHeight*0.5, PILLAR_RADIUS),\n        p\n    );\n    float rArchSubY = archHeight - topHeight*2.0;\n    float rArchSubX = halfLen - PILLAR_RADIUS;\n    float dArchSub = distance(\n        vec2(0.0, archCenterY - archHeight*0.5),\n        vec2(p.x*(rArchSubY/rArchSubX), p.y)\n    ) - rArchSubY;\n\n    float dDecor = sdSubtract(dArchSub, dArchBody);\n    // ----------------\n\n\n    return min(dSoFar, dDecor);\n}\n\n// ---------------------\n// Face 0: \"Outer ring\"\n// ---------------------\n\n// Geodesic pieces\n#define G12_P vec3(-0.5, LASER_Y,  1.5)\n#define G12_V vec3( INV_SQRT2, 0.0, -INV_SQRT2)\n#define G08_P vec3(-0.5, LASER_Y,  9.1)\n#define G08_V vec3( INV_SQRT2, 0.0, -INV_SQRT2)\n#define G06_P vec3( 0.5, LASER_Y, 11.1)\n#define G06_V vec3(-INV_SQRT2, 0.0, -INV_SQRT2)\n#define G02_P vec3( 0.5, LASER_Y, 18.7)\n#define G02_V vec3(-INV_SQRT2, 0.0, -INV_SQRT2)\n\nfloat dsq0Point(vec3 p) {\n    float dsq12 = dsqPointLine(p, G12_P, G12_V);\n    float dsq08 = dsqPointLine(p, G08_P, G08_V);\n    float dsq06 = dsqPointLine(p, G06_P, G06_V);\n    float dsq02 = dsqPointLine(p, G02_P, G02_V);\n    return min(min(dsq12, dsq08), min(dsq02, dsq06));\n}\n\nfloat dsq0Segment(vec3 p, vec3 q) {\n    float dsq12 = dsqSegmentLine(p, q, G12_P, G12_V);\n    float dsq08 = dsqSegmentLine(p, q, G08_P, G08_V);\n    float dsq06 = dsqSegmentLine(p, q, G06_P, G06_V);\n    float dsq02 = dsqSegmentLine(p, q, G02_P, G02_V);\n    return min(min(dsq12, dsq08), min(dsq02, dsq06));\n}\n\n// SDF for face\nfloat sdFace0(vec3 p) {\n    float fiz = mod(p.z, 2.0*HALF_OUTER_DIAM);\n    vec3 pArch = vec3( abs(fiz-HALF_OUTER_DIAM), p.y, abs(p.x) );\n    float dArch = sdArchA(HALF_OUTER_DIAM, HALF_WIDTH, pArch);\n\n    return dArch;\n}\n\n// Values that continue seamlessly across the geometry\nvec2 uvFace0(vec3 p) {\n    float tWidth = unmix(-HALF_WIDTH, HALF_WIDTH, p.x);\n    float phi = tWidth/4.0;\n\n    vec2 usq = paramUnitSquare(p.z / (2.0*HALF_OUTER_DIAM));\n    float theta = 0.5+0.5*atan(usq.y, usq.x)/PI;\n\n    return vec2(phi, theta);\n}\n\nvoid traverseFace0(\n    in bool navOnly,\n    inout vec3 p, inout vec3 nv, inout float tRemaining,\n    inout vec4 color, inout float glowDsq, inout float shadowAmount,\n    out bool finished, out int matHit, out vec3 nvHit, out int nextFace\n) {\n    int id = ID_NOTHING;\n    float t = tRemaining;\n\n    float tPortalS = hitIntervalFromInside(-HALF_WIDTH, HALF_WIDTH, p.x, nv.x);\n    updateHit(t, id, tPortalS, ID_PORTAL_SIDE);\n\n    float tPortalL = hitIntervalFromInside(0.0, 8.0*HALF_OUTER_DIAM, p.z, nv.z);\n    updateHit(t, id, tPortalL, ID_PORTAL_LOOP);\n\n    if (!navOnly) {\n        float tPlanar = hitIntervalFromInside(-HALF_DEPTH - TERRAIN_POM_DEPTH, HALF_DEPTH, p.y, nv.y);\n        updateHit(t, id, tPlanar, ID_PLANAR);\n\n        _SDF_HIT(sdFace0, p, T_MAX-tRemaining, shadowAmount)\n    }\n\n    vec3 pNext = p + t*nv;\n    glowDsq = min(glowDsq, dsq0Segment(p, pNext));\n    p = pNext;\n    tRemaining -= t;\n\n    finished = true;\n    nextFace = 0;\n\n    // Floor or ceiling hit\n    if (id == ID_PLANAR) {\n        if (p.y > 0.0) {\n\n            tRemaining = 0.0;\n            vec2 phiTheta = uvFace0(p);\n            color = blendOnto(color, skyboxLocal(phiTheta));\n            matHit = MAT_SKY;\n\n        } else {\n\n\t\t\tnvHit = vec3(0.0, 1.0, 0.0);\n            color = blendOnto(color, PILLAR_COLOR);\n            matHit = MAT_PILLAR;\n\n        }\n    }\n\n    // SDF geometry was hit\n    else if (id == ID_PILLAR) {\n\n        nvHit = _SDF_NORMAL(sdFace0, p);\n        color = blendOnto(color, PILLAR_COLOR);\n        matHit = MAT_PILLAR;\n\n    }\n\n    // Loop portal was hit: Determine transform\n    else if (id == ID_PORTAL_LOOP) {\n\t\tfinished = false;\n        nextFace = 0;\n\n        if (p.z-EPS < 0.0) {\n            p.z += 8.0*HALF_OUTER_DIAM;\n        } else if (p.z+EPS > 8.0*HALF_OUTER_DIAM) {\n            p.z -= 8.0*HALF_OUTER_DIAM;\n        }\n    }\n\n    // Side portal was hit: Determine transform\n    else if (id == ID_PORTAL_SIDE) {\n        finished = false;\n\n        float fi = floor(p.z / (2.0*HALF_OUTER_DIAM));\n        float fiz = mod(p.z, 2.0*HALF_OUTER_DIAM);\n\n        if (p.x-EPS < -HALF_WIDTH) {\n            nextFace = 3;\n\n            if (fi < 1.0) {\n                p.xz = vec2(HALF_OUTER_DIAM, -HALF_OUTER_DIAM + fiz);\n            } else if (fi < 2.0) {\n                p.xz = vec2(HALF_OUTER_DIAM - fiz, HALF_OUTER_DIAM);\n                nv.xz = vec2(-nv.z, nv.x);\n            } else if (fi < 3.0) {\n                p.xz = vec2(-HALF_OUTER_DIAM, HALF_OUTER_DIAM - fiz);\n                nv.xz = -nv.xz;\n            } else {\n                p.xz = vec2(-HALF_OUTER_DIAM + fiz, -HALF_OUTER_DIAM);\n                nv.xz = vec2(nv.z, -nv.x);\n            }\n        } else if (p.x+EPS > HALF_WIDTH) {\n            nextFace = 1;\n\n            if (fi < 1.0) {\n                p.xz = vec2(HALF_OUTER_DIAM, HALF_OUTER_DIAM - fiz);\n                nv.xz = -nv.xz;\n            } else if (fi < 2.0) {\n                p.xz = vec2(HALF_OUTER_DIAM - fiz, -HALF_OUTER_DIAM);\n                nv.xz = vec2(-nv.z, nv.x);\n            } else if (fi < 3.0) {\n                p.xz = vec2(-HALF_OUTER_DIAM, -HALF_OUTER_DIAM + fiz);\n            } else {\n                p.xz = vec2(-HALF_OUTER_DIAM + fiz, HALF_OUTER_DIAM);\n                nv.xz = vec2(nv.z, -nv.x);\n            }\n        }\n    }\n}\n\n// ---------------------\n// Face 2: \"Inner ring\"\n// ---------------------\n\n// Geodesic pieces\n#define G10_P vec3(-0.5, LASER_Y, 2.5)\n#define G10_V vec3( INV_SQRT2, 0.0, -INV_SQRT2)\n#define G04_P vec3( 0.5, LASER_Y, 6.5)\n#define G04_V vec3(-INV_SQRT2, 0.0, -INV_SQRT2)\n\nfloat dsq2Point(vec3 p) {\n    float dsq10 = dsqPointLine(p, G10_P, G10_V);\n    float dsq04 = dsqPointLine(p, G04_P, G04_V);\n    return min(dsq10, dsq04);\n}\n\nfloat dsq2Segment(vec3 p, vec3 q) {\n    float dsq10 = dsqSegmentLine(p, q, G10_P, G10_V);\n    float dsq04 = dsqSegmentLine(p, q, G04_P, G04_V);\n    return min(dsq10, dsq04);\n}\n\n// SDF for face\nfloat sdFace2(vec3 p) {\n    float fiz = mod(p.z, 2.0*HALF_INNER_DIAM);\n    vec3 pArch = vec3( abs(fiz-HALF_INNER_DIAM), p.y, abs(p.x) );\n    float dArch = sdArchB(HALF_INNER_DIAM, HALF_WIDTH, pArch);\n\n    return dArch;\n}\n\n// Values that continue seamlessly across the geometry\nvec2 uvFace2(vec3 p) {\n    float tWidth = unmix(-HALF_WIDTH, HALF_WIDTH, p.x);\n    float phi = 0.5 + tWidth/4.0;\n\n    vec2 usq = paramUnitSquare(p.z / (2.0*HALF_INNER_DIAM));\n    float theta = 0.5+0.5*atan(usq.y, usq.x)/PI;\n\n    return vec2(phi, theta);\n}\n\nvoid traverseFace2(\n    in bool navOnly,\n    inout vec3 p, inout vec3 nv, inout float tRemaining,\n    inout vec4 color, inout float glowDsq, inout float shadowAmount,\n    out bool finished, out int matHit, out vec3 nvHit, out int nextFace\n) {\n    int id = ID_NOTHING;\n    float t = tRemaining;\n\n    float tPortalS = hitIntervalFromInside(-HALF_WIDTH, HALF_WIDTH, p.x, nv.x);\n    updateHit(t, id, tPortalS, ID_PORTAL_SIDE);\n\n    float tPortalL = hitIntervalFromInside(0.0, 8.0*HALF_INNER_DIAM, p.z, nv.z);\n    updateHit(t, id, tPortalL, ID_PORTAL_LOOP);\n\n    if (!navOnly) {\n        float tPlanar = hitIntervalFromInside(-HALF_DEPTH+ARCH_B_VERT_OFFSET - TERRAIN_POM_DEPTH, HALF_DEPTH, p.y, nv.y);\n        updateHit(t, id, tPlanar, ID_PLANAR);\n\n        _SDF_HIT(sdFace2, p, T_MAX-tRemaining, shadowAmount)\n    }\n\n    vec3 pNext = p + t*nv;\n    glowDsq = min(glowDsq, dsq2Segment(p, pNext));\n    p = pNext;\n    tRemaining -= t;\n\n    finished = true;\n    nextFace = 2;\n\n    // Floor or ceiling hit\n    if (id == ID_PLANAR) {\n        if (p.y > 0.0) {\n\n            tRemaining = 0.0;\n            vec2 phiTheta = uvFace2(p);\n            color = blendOnto(color, skyboxLocal(phiTheta));\n            matHit = MAT_SKY;\n\n        } else {\n\n            nvHit = vec3(0.0, 1.0, 0.0);\n            color = blendOnto(color, PILLAR_COLOR);\n            matHit = MAT_PILLAR;\n\n        }\n    }\n\n    // SDF geometry was hit\n    else if (id == ID_PILLAR) {\n\n        nvHit = _SDF_NORMAL(sdFace2, p);\n        color = blendOnto(color, PILLAR_COLOR);\n        matHit = MAT_PILLAR;\n\n    }\n\n    // Loop portal was hit: Determine transform\n    else if (id == ID_PORTAL_LOOP) {\n\t\tfinished = false;\n        nextFace = 2;\n\n        if (p.z-EPS < 0.0) {\n            p.z += 8.0*HALF_INNER_DIAM;\n        } else if (p.z+EPS > 8.0*HALF_INNER_DIAM) {\n            p.z -= 8.0*HALF_INNER_DIAM;\n        }\n    }\n\n    // Side portal was hit: Determine transform\n    else if (id == ID_PORTAL_SIDE) {\n        finished = false;\n\n        float fi = floor(p.z / (2.0*HALF_INNER_DIAM));\n        float fiz = mod(p.z, 2.0*HALF_INNER_DIAM);\n\n        if (p.x-EPS < -HALF_WIDTH) {\n            nextFace = 1;\n\n            if (fi < 1.0) {\n                p.xz = vec2(HALF_INNER_DIAM, HALF_INNER_DIAM - fiz);\n                nv.xz = -nv.xz;\n            } else if (fi < 2.0) {\n                p.xz = vec2(HALF_INNER_DIAM - fiz, -HALF_INNER_DIAM);\n                nv.xz = vec2(-nv.z, nv.x);\n            } else if (fi < 3.0) {\n                p.xz = vec2(-HALF_INNER_DIAM, -HALF_INNER_DIAM + fiz);\n            } else {\n                p.xz = vec2(-HALF_INNER_DIAM + fiz, HALF_INNER_DIAM);\n                nv.xz = vec2(nv.z, -nv.x);\n            }\n        } else if (p.x+EPS > HALF_WIDTH) {\n            nextFace = 3;\n\n            if (fi < 1.0) {\n                p.xz = vec2(HALF_INNER_DIAM, -HALF_INNER_DIAM + fiz);\n            } else if (fi < 2.0) {\n                p.xz = vec2(HALF_INNER_DIAM - fiz, HALF_INNER_DIAM);\n                nv.xz = vec2(-nv.z, nv.x);\n            } else if (fi < 3.0) {\n                p.xz = vec2(-HALF_INNER_DIAM, HALF_INNER_DIAM - fiz);\n                nv.xz = -nv.xz;\n            } else {\n                p.xz = vec2(-HALF_INNER_DIAM + fiz, -HALF_INNER_DIAM);\n                nv.xz = vec2(nv.z, -nv.x);\n            }\n        }\n    }\n}\n\n// ---------------------\n// Face 1: \"Top square\"\n// ---------------------\n\n// Geodesic pieces\n#define G01_P vec3(2.4, LASER_Y, 1.9)\n#define G01_V vec3(-INV_SQRT2, 0.0, INV_SQRT2)\n#define G05_P (vec3(-1.0, LASER_Y,  0.5) + vec3(0.25, 0.0, 0.25))\n#define G05_V vec3(-INV_SQRT2, 0.0, -INV_SQRT2)\n#define G09_P (vec3( 0.5, LASER_Y, -1.0) + vec3(0.25, 0.0, 0.25))\n#define G09_VR vec3(-INV_SQRT2, 0.0, -INV_SQRT2)\n\nfloat dsq1Point(vec3 p) {\n    float dsq01 = dsqPointLine(p, G01_P, G01_V);\n    float dsq05  = dsqPointRay(p, G05_P, G05_V);\n    float dsq09r = dsqPointRay(p, G09_P, G09_VR);\n    return min(dsq01, min(dsq05, dsq09r));\n}\n\nfloat dsq1Segment(vec3 p, vec3 q) {\n    float dsq01 = dsqSegmentLine(p, q, G01_P, G01_V);\n    float dsq05  = dsqSegmentRay(p, q, G05_P, G05_V);\n    float dsq09r = dsqSegmentRay(p, q, G09_P, G09_VR);\n    return min(dsq01, min(dsq05, dsq09r));\n}\n\n// SDF for face\nfloat sdFace1(vec3 p) {\n    vec3 pArch = vec3( min(abs(p.x),abs(p.z)), p.y, max(abs(p.x),abs(p.z)) );\n    float dO = sdArchA(HALF_OUTER_DIAM, HALF_OUTER_DIAM, pArch);\n    float dI = sdArchB(HALF_INNER_DIAM, HALF_INNER_DIAM, pArch);\n\n    return min(dI, dO);\n}\n\n// Values that continue seamlessly across the geometry\nvec2 uvFace1(vec3 p) {\n    float tWidth = unmix(HALF_OUTER_DIAM, HALF_INNER_DIAM, max(abs(p.x),abs(p.z)));\n    float phi = 0.25 + tWidth/4.0;\n\n    float theta = 0.5+0.5*atan(-p.z, p.x)/PI;\n\n    return vec2(phi, theta);\n}\n\nvoid traverseFace1(\n    in bool navOnly,\n    inout vec3 p, inout vec3 nv, inout float tRemaining,\n    inout vec4 color, inout float glowDsq, inout float shadowAmount,\n    out bool finished, out int matHit, out vec3 nvHit, out int nextFace\n) {\n    int id = ID_NOTHING;\n    float t = tRemaining;\n\n    float tPortalO = hitBox2FromInside(\n        -vec2(HALF_OUTER_DIAM), vec2(HALF_OUTER_DIAM),\n        p.xz, nv.xz\n    );\n    updateHit(t, id, tPortalO, ID_PORTAL_OUTER);\n\n    float tPortalI;\n    float didHitPortalI;\n    hitBox2FromOutside(\n        -vec2(HALF_INNER_DIAM), vec2(HALF_INNER_DIAM),\n        p.xz, nv.xz, tPortalI, didHitPortalI\n    );\n    if (didHitPortalI > 0.5) {\n        updateHit(t, id, tPortalI, ID_PORTAL_INNER);\n    }\n\n    if (!navOnly) {\n        float tPlanar = hitIntervalFromInside(-HALF_DEPTH - TERRAIN_POM_DEPTH, HALF_DEPTH, p.y, nv.y);\n        updateHit(t, id, tPlanar, ID_PLANAR);\n\n        _SDF_HIT(sdFace1, p, T_MAX-tRemaining, shadowAmount)\n    }\n\n    vec3 pNext = p + t*nv;\n    glowDsq = min(glowDsq, dsq1Segment(p, pNext));\n    p = pNext;\n    tRemaining -= t;\n\n    finished = true;\n    nextFace = 1;\n\n    // Floor or ceiling hit\n    if (id == ID_PLANAR) {\n        if (p.y > 0.0) {\n\n            tRemaining = 0.0;\n            vec2 phiTheta = uvFace1(p);\n            color = blendOnto(color, skyboxLocal(phiTheta));\n            matHit = MAT_SKY;\n\n        } else {\n\n            nvHit = vec3(0.0, 1.0, 0.0);\n            color = blendOnto(color, PILLAR_COLOR);\n            matHit = MAT_PILLAR;\n\n        }\n    }\n\n    // SDF geometry was hit\n    else if (id == ID_PILLAR) {\n\n        nvHit = _SDF_NORMAL(sdFace1, p);\n        color = blendOnto(color, PILLAR_COLOR);\n        matHit = MAT_PILLAR;\n\n    }\n\n    // Inner portal was hit: Determine transform\n    else if (id == ID_PORTAL_INNER) {\n        finished = false;\n        nextFace = 2;\n\n        if (p.x+EPS > HALF_INNER_DIAM) {\n            p.xz = vec2(-HALF_WIDTH,                        HALF_INNER_DIAM - p.z);\n            nv.xz = -nv.xz;\n        } else if (p.x-EPS < -HALF_INNER_DIAM) {\n            p.xz = vec2(-HALF_WIDTH, 4.0*HALF_INNER_DIAM + (HALF_INNER_DIAM + p.z));\n        } else if (p.z-EPS < -HALF_INNER_DIAM) {\n            p.xz = vec2(-HALF_WIDTH, 2.0*HALF_INNER_DIAM + (HALF_INNER_DIAM - p.x));\n            nv.xz = vec2(nv.z, -nv.x);\n        } else {\n            p.xz = vec2(-HALF_WIDTH, 6.0*HALF_INNER_DIAM + (HALF_INNER_DIAM + p.x));\n            nv.xz = vec2(-nv.z, nv.x);\n        }\n    }\n\n    // Outer portal was hit: Determine transform\n    else if (id == ID_PORTAL_OUTER) {\n        finished = false;\n        nextFace = 0;\n\n        if (p.x+EPS > HALF_OUTER_DIAM) {\n            p.xz = vec2(HALF_WIDTH,                        HALF_OUTER_DIAM - p.z);\n            nv.xz = -nv.xz;\n        } else if (p.x-EPS < -HALF_OUTER_DIAM) {\n            p.xz = vec2(HALF_WIDTH, 4.0*HALF_OUTER_DIAM + (HALF_OUTER_DIAM + p.z));\n        } else if (p.z-EPS < -HALF_OUTER_DIAM) {\n            p.xz = vec2(HALF_WIDTH, 2.0*HALF_OUTER_DIAM + (HALF_OUTER_DIAM - p.x));\n            nv.xz = vec2(nv.z, -nv.x);\n        } else {\n            p.xz = vec2(HALF_WIDTH, 6.0*HALF_OUTER_DIAM + (HALF_OUTER_DIAM + p.x));\n            nv.xz = vec2(-nv.z, nv.x);\n        }\n    }\n}\n\n// ------------------------\n// Face 3: \"Bottom square\"\n// ------------------------\n\n// Geodesic pieces\n#define G07_P vec3(-2.4, LASER_Y, 1.9)\n#define G07_V vec3(INV_SQRT2, 0.0, INV_SQRT2)\n#define G11_P (vec3( 1.0, LASER_Y,  0.5) + vec3(-0.25, 0.0, 0.25))\n#define G11_V vec3(INV_SQRT2, 0.0, -INV_SQRT2)\n#define G03_P (vec3(-0.5, LASER_Y, -1.0) + vec3(-0.25, 0.0, 0.25))\n#define G03_VR vec3(INV_SQRT2, 0.0, -INV_SQRT2)\n\nfloat dsq3Point(vec3 p) {\n    float dsq07 = dsqPointLine(p, G07_P, G07_V);\n    float dsq11  = dsqPointRay(p, G11_P, G11_V);\n    float dsq03r = dsqPointRay(p, G03_P, G03_VR);\n    return min(dsq07, min(dsq11, dsq03r));\n}\n\nfloat dsq3Segment(vec3 p, vec3 q) {\n    float dsq07 = dsqSegmentLine(p, q, G07_P, G07_V);\n    float dsq11  = dsqSegmentRay(p, q, G11_P, G11_V);\n    float dsq03r = dsqSegmentRay(p, q, G03_P, G03_VR);\n    return min(dsq07, min(dsq11, dsq03r));\n}\n\n// SDF for face\nfloat sdFace3(vec3 p) {\n    vec3 pArch = vec3( min(abs(p.x),abs(p.z)), p.y, max(abs(p.x),abs(p.z)) );\n    float dO = sdArchA(HALF_OUTER_DIAM, HALF_OUTER_DIAM, pArch);\n    float dI = sdArchB(HALF_INNER_DIAM, HALF_INNER_DIAM, pArch);\n\n    return min(dI, dO);\n}\n\n// Values that continue seamlessly across the geometry\nvec2 uvFace3(vec3 p) {\n    float tWidth = unmix(HALF_INNER_DIAM, HALF_OUTER_DIAM, max(abs(p.x),abs(p.z)));\n    float phi = 0.75 + tWidth/4.0;\n\n    float theta = 0.5+0.5*atan(p.z, p.x)/PI;\n\n    return vec2(phi, theta);\n}\n\nvoid traverseFace3(\n    in bool navOnly,\n    inout vec3 p, inout vec3 nv, inout float tRemaining,\n    inout vec4 color, inout float glowDsq, inout float shadowAmount,\n    out bool finished, out int matHit, out vec3 nvHit, out int nextFace\n) {\n    int id = ID_NOTHING;\n    float t = tRemaining;\n\n    float tPortalO = hitBox2FromInside(\n        -vec2(HALF_OUTER_DIAM), vec2(HALF_OUTER_DIAM),\n        p.xz, nv.xz\n    );\n    updateHit(t, id, tPortalO, ID_PORTAL_OUTER);\n\n    float tPortalI;\n    float didHitPortalI;\n    hitBox2FromOutside(\n        -vec2(HALF_INNER_DIAM), vec2(HALF_INNER_DIAM),\n        p.xz, nv.xz, tPortalI, didHitPortalI\n    );\n    if (didHitPortalI > 0.5) {\n        updateHit(t, id, tPortalI, ID_PORTAL_INNER);\n    }\n\n    if (!navOnly) {\n        float tPlanar = hitIntervalFromInside(-HALF_DEPTH - TERRAIN_POM_DEPTH, HALF_DEPTH, p.y, nv.y);\n        updateHit(t, id, tPlanar, ID_PLANAR);\n\n        _SDF_HIT(sdFace3, p, T_MAX-tRemaining, shadowAmount)\n    }\n\n    vec3 pNext = p + t*nv;\n    glowDsq = min(glowDsq, dsq3Segment(p, pNext));\n    p = pNext;\n    tRemaining -= t;\n\n    finished = true;\n    nextFace = 3;\n\n    // Floor or ceiling hit\n    if (id == ID_PLANAR) {\n        if (p.y > 0.0) {\n\n           \ttRemaining = 0.0;\n            vec2 phiTheta = uvFace3(p);\n            color = blendOnto(color, skyboxLocal(phiTheta));\n            matHit = MAT_SKY;\n\n        } else {\n\n            nvHit = vec3(0.0, 1.0, 0.0);\n            color = blendOnto(color, PILLAR_COLOR);\n            matHit = MAT_PILLAR;\n\n        }\n    }\n\n    // SDF geometry was hit\n    else if (id == ID_PILLAR) {\n\n        nvHit = _SDF_NORMAL(sdFace3, p);\n        color = blendOnto(color, PILLAR_COLOR);\n        matHit = MAT_PILLAR;\n\n    }\n\n    // Inner portal was hit: Determine transform\n    else if (id == ID_PORTAL_INNER) {\n        finished = false;\n        nextFace = 2;\n\n        if (p.x+EPS > HALF_INNER_DIAM) {\n            p.xz = vec2(HALF_WIDTH,                        HALF_INNER_DIAM + p.z);\n        } else if (p.x-EPS < -HALF_INNER_DIAM) {\n            p.xz = vec2(HALF_WIDTH, 4.0*HALF_INNER_DIAM + (HALF_INNER_DIAM - p.z));\n            nv.xz = -nv.xz;\n        } else if (p.z-EPS < -HALF_INNER_DIAM) {\n            p.xz = vec2(HALF_WIDTH, 6.0*HALF_INNER_DIAM + (HALF_INNER_DIAM + p.x));\n            nv.xz = vec2(-nv.z, nv.x);\n        } else {\n            p.xz = vec2(HALF_WIDTH, 2.0*HALF_INNER_DIAM + (HALF_INNER_DIAM - p.x));\n            nv.xz = vec2(nv.z, -nv.x);\n        }\n    }\n\n    // Outer portal was hit: Determine transform\n    else if (id == ID_PORTAL_OUTER) {\n        finished = false;\n        nextFace = 0;\n\n        if (p.x+EPS > HALF_OUTER_DIAM) {\n            p.xz = vec2(-HALF_WIDTH,                        HALF_OUTER_DIAM + p.z);\n        } else if (p.x-EPS < -HALF_OUTER_DIAM) {\n            p.xz = vec2(-HALF_WIDTH, 4.0*HALF_OUTER_DIAM + (HALF_OUTER_DIAM - p.z));\n            nv.xz = -nv.xz;\n        } else if (p.z-EPS < -HALF_OUTER_DIAM) {\n            p.xz = vec2(-HALF_WIDTH, 6.0*HALF_OUTER_DIAM + (HALF_OUTER_DIAM + p.x));\n            nv.xz = vec2(-nv.z, nv.x);\n        } else {\n            p.xz = vec2(-HALF_WIDTH, 2.0*HALF_OUTER_DIAM + (HALF_OUTER_DIAM - p.x));\n            nv.xz = vec2(nv.z, -nv.x);\n        }\n    }\n}\n\n// =============\n// Render scene\n// =============\n\n#define FIXED_UP vec3(0.0, 1.0, 0.0)\n#define TAN_HALF_FOVY 0.7002075382097097\n#define CAM_Z_NEAR 0.1\n#define CAM_Z_FAR 50.0\n\nmat4 getClipToWorld(float aspectWoverH, vec3 nvCamFw) {\n    mat4 clipToEye = mat4(\n        aspectWoverH * TAN_HALF_FOVY, 0.0, 0.0, 0.0,\n        0.0, TAN_HALF_FOVY, 0.0, 0.0,\n        0.0, 0.0,  0.0, (CAM_Z_NEAR - CAM_Z_FAR)/(2.0 * CAM_Z_NEAR * CAM_Z_FAR),\n        0.0, 0.0, -1.0, (CAM_Z_NEAR + CAM_Z_FAR)/(2.0 * CAM_Z_NEAR * CAM_Z_FAR)\n    );\n\n    vec3 nvCamRt = normalize(cross(nvCamFw, FIXED_UP));\n    vec3 nvCamUp = cross(nvCamRt, nvCamFw);\n    mat4 eyeToWorld = mat4(\n         nvCamRt, 0.0,\n         nvCamUp, 0.0,\n        -nvCamFw, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n\n    return eyeToWorld * clipToEye;\n}\n\nvoid castRay(\n    inout vec3 pRay, inout vec3 nvRay, inout int rayFace,\n    out vec4 cFinal, out float glowDsq, out float shadowAmount,\n    out float dHit, out int matHit, out vec3 nvHit\n) {\n    float tRemaining = T_MAX;\n    cFinal = vec4(0.0);\n    glowDsq = 1e5;\n    shadowAmount = 0.0;\n\n    for (int i=0; i<100; i++) {\n        bool finished;\n\n        if (rayFace == 0) {\n            traverseFace0(false, pRay, nvRay, tRemaining, cFinal, glowDsq, shadowAmount, finished, matHit, nvHit, rayFace);\n        } else if (rayFace == 1) {\n            traverseFace1(false, pRay, nvRay, tRemaining, cFinal, glowDsq, shadowAmount, finished, matHit, nvHit, rayFace);\n        } else if (rayFace == 2) {\n            traverseFace2(false, pRay, nvRay, tRemaining, cFinal, glowDsq, shadowAmount, finished, matHit, nvHit, rayFace);\n        } else {\n            traverseFace3(false, pRay, nvRay, tRemaining, cFinal, glowDsq, shadowAmount, finished, matHit, nvHit, rayFace);\n        }\n\n        if (finished) {\n            break;\n        }\n    }\n\n    dHit = T_MAX - tRemaining;\n}\n\nvoid navigate(\n    inout vec3 sphPos, inout int sphFace, inout vec3 nvSphDir,\n    in float dist\n) {\n    float tRemaining = dist;\n    vec3 pCur = sphPos;\n    vec3 nvCur = nvSphDir;\n    int face = sphFace;\n\n    for (int i=0; i<100; i++) {\n        vec4 c;\n        float ga;\n        float sa;\n        bool finished;\n        int matHit;\n        vec3 nvHit;\n\n        if (face == 0) {\n            traverseFace0(true, pCur, nvCur, tRemaining, c, ga, sa, finished, matHit, nvHit, face);\n        } else if (face == 1) {\n            traverseFace1(true, pCur, nvCur, tRemaining, c, ga, sa, finished, matHit, nvHit, face);\n        } else if (face == 2) {\n            traverseFace2(true, pCur, nvCur, tRemaining, c, ga, sa, finished, matHit, nvHit, face);\n        } else if (face == 3) {\n            traverseFace3(true, pCur, nvCur, tRemaining, c, ga, sa, finished, matHit, nvHit, face);\n        }\n\n        if (finished) {\n            break;\n        }\n    }\n\n    sphPos = pCur;\n    nvSphDir = nvCur;\n    sphFace = face;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool isMousePressed = clamp(iMouse.z, 0.0, 1.0) > 0.0;\n    bool hideGlow  = texelFetch(iChannel1, ivec2(KEY_D,0), 0).x > 0.5;\n    bool hideLight = texelFetch(iChannel1, ivec2(KEY_F,0), 0).x > 0.5;\n\n    float LOOPS = 3.0;\n    float geodesicLength = sqrt(2.0)*12.6;\n    float tLoop = isMousePressed ? (iMouse.x / iResolution.x) : mod(0.02*iTime, 1.0);\n\n    // Establish current position\n\t// -----------------------------------------\n    // NOTE: Changing the initial point will break the \"laser\" path\n    vec3 sphPos = vec3(0.5);\n    int sphFace = 0;\n    vec3 nvSphDir = normalize(vec3(1.0, 0.0, -1.0));\n\n    navigate(sphPos, sphFace, nvSphDir, tLoop*LOOPS*geodesicLength);\n    sphPos = vec3(sphPos.x, mix(0.2, 0.55, 0.5+0.5*sin(tLoop*TWOPI)), sphPos.z);\n\n    // Camera settings\n    // -----------------------------------------\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 angRtUp = vec2(-0.35 - 0.1*PI*sin(tLoop*TWOPI), PI*sin(tLoop*TWOPI));\n\n    vec3 nvCamRt = normalize(cross(nvSphDir, FIXED_UP));\n    mat3 rotRt = glRotate(nvCamRt, angRtUp.s);\n    mat3 rotUp = glRotate(vec3(0.0, 1.0, 0.0), angRtUp.t);\n    vec3 nvCamFw = rotUp*(rotRt*nvSphDir);\n\n    mat4 clipToWorld = getClipToWorld(iResolution.x/iResolution.y, nvCamFw);\n    vec4 vWorld = clipToWorld * vec4(uv*2.0 - 1.0, 1.0, 1.0);\n    vec3 nvCamDir = normalize(vWorld.xyz / vWorld.w);\n\n    // Initial geometry hit\n    // -----------------------------------------\n    vec4 cFinal;\n    float glowDsq;\n    float shadowAmount;\n    float dHit;\n    int matHit;\n    vec3 nvHit;\n    castRay(\n        sphPos, nvCamDir, sphFace,\n        cFinal, glowDsq, shadowAmount, dHit, matHit, nvHit\n    );\n\n    float fogAmount = clamp( dHit/T_MAX, 0.0, 1.0 );\n    if (hideGlow) {\n        glowDsq = 1e5;\n    }\n    vec4 glowPremul = glowPremulFromDsq(glowDsq);\n\n    // Terrain/water POM adjustment\n    // -----------------------------------------\n    float pomTop = -HALF_DEPTH;\n    if (sphFace == 2) {\n        pomTop = -HALF_DEPTH+ARCH_B_VERT_OFFSET;\n\t}\n\n    if (sphPos.y < pomTop) {\n        // Back up to surface\n        float dSurf = (pomTop - sphPos.y)/nvCamDir.y;\n        vec3 sphPosSurf = sphPos + dSurf*nvCamDir;\n        float dHitSurf = dHit + dSurf;\n\n        // Down to floor/subsurface\n        float dMax = -(TERRAIN_POM_DEPTH-EPS) / nvCamDir.y;\n        vec3 sphPosBase = sphPosSurf + dMax*nvCamDir;\n        float dHitBase = dHitSurf + dMax;\n\n        // POM loop\n        int i = 0;\n        float it = 0.0;\n        float iMidstep = 0.0;\n        float yOffsetPrev = 0.0;\n        for (; i<TERRAIN_POM_STEPS; i++) {\n            it = float(i)/float(TERRAIN_POM_STEPS);\n\n            vec3 sphPosStep = mix(sphPosSurf, sphPosBase, it);\n            float texY = mix(sphPosBase.y, sphPosSurf.y, floorH(sphFace, sphPosStep.xz));\n\n            float yOffset = sphPosStep.y - texY;\n            if (yOffset < 0.0) {\n\t\t\t\tfloat iMidstep = mix(float(i)-1.0, float(i), unmix(yOffsetPrev, yOffset, 0.0));\n\t\t\t\tit = iMidstep / float(TERRAIN_POM_STEPS);\n             \tbreak;\n            }\n            yOffsetPrev = yOffset;\n        }\n\n        float dHitStep = mix(dHitSurf, dHitBase, it);\n        if (dHitStep < dHit) {\n            sphPos = mix(sphPosSurf, sphPosBase, it);\n            dHit = mix(dHitSurf, dHitBase, it);\n\n            float hSA = floorH(sphFace, sphPos.xz + vec2(-TERRAIN_N_EPS, 0.0));\n            float hSB = floorH(sphFace, sphPos.xz + vec2( TERRAIN_N_EPS, 0.0));\n            float hTA = floorH(sphFace, sphPos.xz + vec2(0.0, -TERRAIN_N_EPS));\n            float hTB = floorH(sphFace, sphPos.xz + vec2(0.0,  TERRAIN_N_EPS));\n            vec2 gradh = vec2(hSB-hSA, hTB-hTA)*(TERRAIN_POM_DEPTH/(2.0*TERRAIN_N_EPS));\n            nvHit = normalize(vec3(-gradh.x, 1.0, -gradh.y));\n\n            if (sphFace == 0 || sphFace == 2) {\n                vec3 waterColor;\n                if (sphFace == 0) {\n                \twaterColor = mix(1.0, 0.5, it)*0.7*vec3(0.3, 0.7, 1.0);\n                } else {\n                    waterColor = mix(1.0, 0.5, it)*1.0*vec3(1.0, 0.9, 0.8);\n                }\n\n                cFinal = blendOnto(vec4(waterColor, 1.0), cFinal);\n                matHit = MAT_WATER;\n\n            } else {\n\n                vec3 terrainColor;\n                if (sphFace == 1) {\n                    terrainColor = colormapTerrainStone(1.0-it);\n                } else {\n                    terrainColor = colormapTerrainGrass(1.0-it);\n                }\n\n                cFinal = vec4(terrainColor, 1.0);\n                matHit = MAT_TERRAIN;\n\n            }\n\n        }\n    }\n\n    // Lighting and shadows\n    // -----------------------------------------\n    if (matHit != MAT_SKY) {\n        vec3 ambientColor = 0.15*cFinal.rgb;\n        \n        // Light in the direction of +phi, with shadows\n        // -----------------------------------------\n        float lSA = _UV_FACE(sphFace, sphPos + vec3(-0.05, 0.0, 0.0)).s;\n        float lSB = _UV_FACE(sphFace, sphPos + vec3( 0.05, 0.0, 0.0)).s;\n        float lTA = _UV_FACE(sphFace, sphPos + vec3(0.0, 0.0, -0.05)).s;\n        float lTB = _UV_FACE(sphFace, sphPos + vec3(0.0, 0.0,  0.05)).s;\n\n        vec2 gradlLight = normalize(vec2(lSB-lSA, lTB-lTA));\n        vec3 nvFragToLight = normalize(vec3( gradlLight.x, 0.8, gradlLight.y ));\n\n        // - grad phi has discontinuity; using smoothed version fixes hard edge for light,\n        //   but causes shadow glitch (a little shadow \"peeks through\" the smoothed part over\n        //   the discontinuity) so we use the exact non-smoothed version for shadow direction\n        // - also add a little EPS to avoid a div by zero in some intersections\n        vec2 gradlShadow = _DPHI_FACE(sphFace, sphPos) + vec2(0.0001, 0.001);\n        vec3 nvFragToLightShadow = normalize(vec3( gradlShadow.x, 0.8, gradlShadow.y ));\n        \n        vec3 nvCamDir2 = nvFragToLightShadow;\n        vec3 sphPos2 = sphPos + (5.0*SDF_EPS)*nvHit;\n\n        int sphFace2 = sphFace;\n        vec4 cFinal2;\n        float glowDsq2;\n        float shadowAmount2;\n        float dHit2;\n        int matHit2;\n        vec3 nvHit2;\n\n        castRay(\n            sphPos2, nvCamDir2, sphFace2,\n            cFinal2, glowDsq2, shadowAmount2, dHit2, matHit2, nvHit2\n        );\n\n        float hardShadowAmount = 1.0 - step(T_MAX, dHit2);\n        float totalShadow = max(shadowAmount2, hardShadowAmount);\n        \n        vec3 litColor;\n        computeLighting(\n            matHit,\n            1.25*(1.0-totalShadow)*LIGHT_COLOR, cFinal.rgb,\n            nvHit, nvFragToLight, -nvCamDir,\n            litColor\n        );\n        if (hideLight) {\n            litColor = vec3(0.0);\n        }\n        \n        // Light from the \"laser\"\n        // -----------------------------------------\n        float dsqLaser = _DSQ_POINT_FACE(sphFace, sphPos);\n        float dsqInt = 1.0 / (1.0 + 1.5*dsqLaser);\n        \n        // this is discontinuous along lines equidistant to multiple parts of the\n        // geodesic, causing hard edges in the light--not too noticeable, won't fix\n        vec3 dsqNormal = _DSQ_NORMAL(sphFace, sphPos);\n\n        vec3 litColor2;\n        computeLighting(\n            matHit,\n            1.25*dsqInt*mix(GLOW_COLOR, vec3(1.0), 0.25), cFinal.rgb,\n            nvHit, -dsqNormal, -nvCamDir,\n            litColor2\n        );\n        if (hideGlow) {\n            litColor2 = vec3(0.0);\n        }\n\n        // Final blending, with fog adjustment\n        // -----------------------------------------\n        cFinal = vec4(ambientColor + litColor + litColor2, 1.0);\n        cFinal = blendOnto(glowPremul, cFinal);\n    \tcFinal *= (1.0 - fogAmount);\n\n    } else {\n        // Since we don't get the distance to the laser, it's not possible to \n        // \"fog\" it accurately--so we just fake it when it's against the sky.\n        // (when it's against non-sky, we borrow the depth of the thing behind it)\n        cFinal = blendOnto(glowPremul*0.4, cFinal);\n    }\n\n    cFinal = blendOnto(cFinal, skyboxGlobal(nvCamDir));\n\n    fragColor = vec4(packColor(fragCoord, clamp(cFinal.rgb, 0.0, 1.0)), glowPremul.a, dHit/T_MAX);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ==========================\n// Generic Helpers/Constants\n// ==========================\n\n#define PI 3.141592653589793\n#define TWOPI 6.283185307179586\n#define PI_OVER_2 1.570796326794896\n#define PI_OVER_4 0.7853981633974483\n\n#define SQRT2 1.414213562373095\n#define INV_SQRT2 0.7071067811865476\n\n// Keyboard input description: https://www.shadertoy.com/view/lsXGzf\n#define KEY_S 83\n#define KEY_D 68\n#define KEY_F 70\n\n//---------------\n// Miscellaneous\n//---------------\n\n//cf. Dave Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Find t so that mix(a,b,t) = x\nfloat unmix(float a, float b, float x) {\n    return (x - a)/(b - a);\n}\n\n// 1 if x \\in (a,b], else 0\nfloat isInInterval(float a, float b, float x) {\n    return step(a, x) * (1.0 - step(b, x));\n}\n\n// Parameterization of unit square with t \\in [0,4]\nvec2 paramUnitSquare(float t) {\n    float tmod4 = mod(t, 4.0);\n    return vec2(\n        clamp(2.0*abs(tmod4-2.5)-2.0, -1.0, 1.0),\n        clamp(2.0-2.0*abs(tmod4-1.5), -1.0, 1.0)\n    );\n}\n\n// Rodrigues' formula: v -> (v.n)n + (v-(v.n)n)c - (vxn)s\nmat3 oProd(vec3 n) {\n    float xy = n.x*n.y, xz = n.x*n.z, yz = n.y*n.z;\n    return mat3(n.x*n.x,xy,xz,  xy,n.y*n.y,yz,  xz,yz,n.z*n.z);\n}\nmat3 glRotate(vec3 axis, float angle) {\n    float c = cos(angle), s = sin(angle);\n    vec3 n = normalize(axis);\n    return (\n        (1.-c)*oProd(n) +\n        mat3(c,s*n.z,-s*n.y,  -s*n.z,c,s*n.x,  s*n.y,-s*n.x,c)\n    );\n}\n\n//----------------------------------------\n// Color blending for premultiplied alpha\n//----------------------------------------\n\nvec4 blendOnto(vec4 cFront, vec4 cBehind) {\n    return cFront + (1.0 - cFront.a)*cBehind;\n}\n\nvec4 blendOnto(vec4 cFront, vec3 cBehind) {\n    return cFront + (1.0 - cFront.a)*vec4(cBehind, 1.0);\n}\n\n//--------------------------------------------------------------\n// Conversions vec3 rgb888 <-> vec2 rgb565 to free up a channel\n//--------------------------------------------------------------\n\n#define DITHER\n\n//24-bit color in [0,1]^3 to 16-bit color in [0,1]^2\nvec2 packColor(vec2 fragCoord, vec3 c24){\n  //get 5r6g5b values\n  float r = (c24.r == 1.0) ? 31.0 : floor(c24.r*32.0);\n  float g = (c24.g == 1.0) ? 63.0 : floor(c24.g*64.0);\n  float b = (c24.b == 1.0) ? 31.0 : floor(c24.b*32.0);\n\n  #ifdef DITHER\n      float tr = fract(c24.r*32.0);\n      float tg = fract(c24.g*64.0);\n      float tb = fract(c24.b*32.0);\n\n      float tarr[16];\n      tarr[ 0] =  1.0; tarr[ 1] =  9.0; tarr[ 2] =  3.0; tarr[ 3] = 11.0;\n      tarr[ 4] = 13.0; tarr[ 5] =  5.0; tarr[ 6] = 15.0; tarr[ 7] =  7.0;\n      tarr[ 8] =  4.0; tarr[ 9] = 12.0; tarr[10] =  2.0; tarr[11] = 10.0;\n      tarr[12] = 16.0; tarr[13] =  8.0; tarr[14] = 14.0; tarr[15] =  6.0;\n\n      int tci = int(mod(fragCoord.x, 4.0));\n      int tcj = int(mod(fragCoord.y, 4.0));\n\n      float thresh = 1.0;\n      for(int i=0; i<4; i++){\n      for(int j=0; j<4; j++){\n        if((i == tci) && (j == tcj)){ thresh = tarr[i*4+j]/17.0; }\n      }}\n\n      if(tr > thresh){ r = min(r+1.0, 31.0); }\n      if(tg > thresh){ g = min(g+1.0, 63.0); }\n      if(tb > thresh){ b = min(b+1.0, 31.0); }\n  #endif\n\n  //encode 5r6g5b -> [gggrrrrr][gggbbbbb]\n  float gmin = mod(g,8.0);\n  float gmax = floor(g/8.0);\n\n  float x = (r + 32.0*gmin)/255.0;\n  float y = (b + 32.0*gmax)/255.0;\n\n  return vec2(x,y);\n}\n\n//16-bit color in [0,1]^2 to 24-bit color in [0,1]^3\nvec3 unpackColor(vec2 c16){\n  //[gggrrrrr][gggbbbbb] -> 5r6g5b\n\n  float rpack = floor(255.0*c16.x);\n  float bpack = floor(255.0*c16.y);\n\n  float gmin = floor(rpack/32.0);\n  float gmax = floor(bpack/32.0);\n  float g = (gmin + 8.0*gmax)/63.0;\n\n  float r = mod(rpack,32.0)/31.0;\n  float b = mod(bpack,32.0)/31.0;\n\n  return vec3(r,g,b);\n}\n\n//---------------------------\n// Signed distance functions\n//---------------------------\n\nfloat sdSubtract(float d1, float d2) {\n    return max(-d1,d2);\n}\n\nfloat sdBox(vec3 boxCenter, vec3 boxRadii, vec3 p) {\n    vec3 q = boxRadii - abs(p - boxCenter);\n    return length(min(q, 0.0)) - max( min(min(q.x, q.y), q.z), 0.0 );\n}\n\n//------------------------------------------\n// Exact hits along a ray (1d and 2d boxes)\n//------------------------------------------\n\n// Find t>0 so x+t*dx is on boundary of xMin-xMax, assuming x in interval\nfloat hitIntervalFromInside(\n    float xMin, float xMax,\n    float x, float dx\n) {\n    float tMin = (xMin - x) / dx;\n    float tMax = (xMax - x) / dx;\n    return max(tMin, tMax);\n}\n\n// Find t>0 so p+t*v is on boundary of boxMin-boxMax, assuming x in box\nfloat hitBox2FromInside(\n    in vec2 boxMin, in vec2 boxMax,\n    in vec2 p, in vec2 v\n) {\n    return min(\n        hitIntervalFromInside(boxMin.x, boxMax.x, p.x, v.x),\n        hitIntervalFromInside(boxMin.y, boxMax.y, p.y, v.y)\n    );\n}\n\n// Find t>0 so p+t*v is on boundary of boxMin-boxMax, assuming x outside box\n// (Hitting from outside means there may be no such t, then didHit -> 0.0)\nvoid hitBox2FromOutside(\n    in vec2 boxMin, in vec2 boxMax,\n    in vec2 p, in vec2 v,\n    out float t, out float didHit\n) {\n    vec2 tb0 = (boxMin - p) / v;\n    vec2 tb1 = (boxMax - p) / v;\n    vec2 tmin = min(tb0, tb1);\n    vec2 tmax = max(tb0, tb1);\n\n    vec2 tRange = vec2(\n        max(tmin.x, tmin.y),\n        min(tmax.x, tmax.y)\n    );\n\n    didHit = step(tRange.s, tRange.t) * step(0.0, tRange.s);\n    t = tRange.s;\n}\n\n//-----------------------------------------------------\n// Exact squared distances (point, segment, ray, line)\n//-----------------------------------------------------\n\n// Returns t that minimizes distance(p, a + t*nv)\nfloat minPointLine(vec3 a, vec3 nv, vec3 p) {\n    return dot(p - a, nv);\n}\n\n// Returns (s,t) that minimizes distance(a + t*nv, b + t*nw)\nvec2 minLineLine(vec3 a, vec3 nv, vec3 b, vec3 nw) {\n    vec3 d = a - b;\n    float vw = dot(nv, nw);\n    float dv = dot(d, nv);\n    float dw = dot(d, nw);\n    return vec2(dv - dw*vw, -dw + dv*vw) / (vw*vw - 1.0);\n}\n\nfloat dsq(vec3 p, vec3 q) {\n    vec3 d = p - q;\n    return dot(d, d);\n}\n\nfloat dsqPointLine(vec3 a, vec3 p, vec3 nv) {\n    float tMinA = minPointLine(p, nv, a);\n    return dsq( a, p + tMinA*nv );\n}\n\nfloat dsqPointRay(vec3 a, vec3 p, vec3 nv) {\n\tfloat tMinA = max(0.0, minPointLine(p, nv, a));\n    return dsq( a, p + tMinA*nv );\n}\n\nfloat dsqSegmentLine(vec3 a, vec3 b, vec3 p, vec3 nv) {\n    float tMinA = minPointLine(p, nv, a);\n    float tMinB = minPointLine(p, nv, b);\n    float dsqMin = min(\n        dsq( a, p + tMinA*nv ),\n        dsq( b, p + tMinB*nv )\n    );\n\n    float lenSeg = length(a - b);\n    vec3 nvSeg = (a - b) / lenSeg;\n\n    vec2 minInterior = minLineLine(b, nvSeg, p, nv);\n    if (minInterior.s > 0.0 && minInterior.s < lenSeg) {\n        vec3 cpSeg = b + minInterior.s*nvSeg;\n        vec3 cpLine = p + minInterior.t*nv;\n        dsqMin = min( dsqMin, dsq(cpSeg, cpLine) );\n    }\n\n    return dsqMin;\n}\n\nfloat dsqSegmentRay(vec3 a, vec3 b, vec3 p, vec3 nv) {\n    float tMinA = max(0.0, minPointLine(p, nv, a));\n    float tMinB = max(0.0, minPointLine(p, nv, b));\n    float dsqMin = min(\n        dsq( a, p + tMinA*nv ),\n        dsq( b, p + tMinB*nv )\n    );\n\n    float lenSeg = length(a - b);\n    vec3 nvSeg = (a - b) / lenSeg;\n\n    float sMinP = clamp(minPointLine(b, nvSeg, p), 0.0, lenSeg);\n    dsqMin = min( dsqMin, dsq(p, b + sMinP*nvSeg) );\n\n    vec2 minInterior = minLineLine(b, nvSeg, p, nv);\n    if (minInterior.s > 0.0 && minInterior.s < lenSeg && minInterior.t > 0.0) {\n        vec3 cpSeg = b + minInterior.s*nvSeg;\n        vec3 cpLine = p + minInterior.t*nv;\n        dsqMin = min( dsqMin, dsq(cpSeg, cpLine) );\n    }\n\n    return dsqMin;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}