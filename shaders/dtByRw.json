{
    "Shader": {
        "info": {
            "date": "1692288308",
            "description": "Quick draft of the sets. Trying to get more precision",
            "flags": 0,
            "hasliked": 0,
            "id": "dtByRw",
            "likes": 3,
            "name": "test J/M set",
            "published": 3,
            "tags": [
                "mandelbrotset"
            ],
            "usePreview": 0,
            "username": "Elyades",
            "viewed": 145
        },
        "renderpass": [
            {
                "code": "// Fork of \"cos(1/sin(z)) J/M set\" by Elyades. https://shadertoy.com/view/Dd2BR3\n// 2023-08-09 10:44:20\n\n// Fork of \"J/M Set\" by Elyades. https://shadertoy.com/view/DdjfDh\n// 2023-07-21 15:02:44\n\nfloat PI = 3.1415926535897932;\nfloat PIONTWO = 1.57079632679;\nfloat TWOPI = 6.28318530718;\n\nfloat atan2(float y, float x)\n{\n    float result = atan(y,x);\n    if(result < 0.0){result += TWOPI;}\n    return result;\n}\n\nfloat add(float a, float b, float scalingFactor)\n{\n    a *= scalingFactor; b *= scalingFactor;\n    return((a+b)/scalingFactor);\n}\n\nvec2 add2(float a, float b)\n{\n    float s = a + b;\n    float e = s - a;\n    float t = b - e;\n    float high = s;\n    float low = a - (s - t);\n    return vec2(high,low);\n}\n\nfloat lengthsquared(vec2 uv)\n{\n    return(uv.x*uv.x + uv.y*uv.y);\n}\n\nvec2 itimes(vec2 uv)\n{\n    return( vec2(-uv.y,uv.x) );\n}\n\nvec2 oneoverz(vec2 uv)\n{\n    float squaremodulus = lengthsquared(uv);\n    return( vec2(uv.x/squaremodulus, -uv.y/squaremodulus) );\n}\n\nfloat mult(float a, float b, float scalingFactor)\n{\n    a *= scalingFactor; b *= scalingFactor;\n    return( a*b/(scalingFactor*scalingFactor));\n}\n\nvec2 add2d(vec2 a, vec2 b, float scalingFactor)\n{\n    a *= scalingFactor; b *= scalingFactor;\n    return((a+b)/scalingFactor);\n}\n\nvec2 mult2d(vec2 a, vec2 b, float scalingFactor)\n{\n    a *= scalingFactor; b *= scalingFactor;\n    return( vec2(add(a.x*b.x,-a.y*b.y,scalingFactor) , add(a.x*b.y,a.y*b.x,scalingFactor))/(scalingFactor*scalingFactor));\n}\n\nvec2 exp2d(vec2 uv)\n{\n    return( exp(uv.x)*vec2(cos(uv.y),sin(uv.y)));\n}\n\nvec2 log2d(vec2 uv)\n{\n    return(vec2(log(length(uv)),atan(uv.y,uv.x)));\n}\n\nvec2 rotate(vec2 uv,float angle)\n{\n    float co = cos(angle);float si = sin(angle);\n    uv *= mat2(co,-si,si,co);\n    return(uv);\n}\n\n\nvec2 cos2d(vec2 uv)\n{\n    return ( vec2 (exp2d(itimes(uv)) + exp2d(itimes(-uv)))*0.5);\n}\n\nvec2 sin2d(vec2 uv)\n{\n    vec2 result = (exp2d(itimes(uv)) - exp2d(itimes(-uv)))*0.5;\n    return vec2(-itimes(result));\n}\n\nvec2 tan2d(vec2 uv)\n{\n    return(sin2d(uv)/cos2d(uv));\n}\n\nvec2 power(vec2 uv, float n)\n{\n    float r = length(uv);\n    float angle = (n*(atan2(uv.y,uv.x)));\n    return( pow(r,n)*vec2(cos(angle),sin(angle)) );\n}\n\n\nvec2 iteration(vec2 uv, vec2 c)\n{    \n    vec2 result = cos2d(oneoverz(sin2d(uv))) + c;\n    return(result);\n}\n\nvec3 palette1( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.33,0.67,0.0);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 palette2( float t ) {\n    //by Inigo Quilez\n    vec2 mousePoint = iMouse.xy/iResolution.xy/4.0;\n    \n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1.5,1.0,0.0 + 4.0*mousePoint.x);\n    vec3 d = vec3(0.0,0.33, 0.67);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 thirdDegreeProcessing(vec3 color)\n{\n    float a = 8.92587;\n    float b = -13.75;\n    float c = 5.82143;\n    return vec3(a*color*color*color - b*color*color + c*color );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //Scale\n    float scale = 8.0;\n    uv += -0.5;\n    uv *= scale;\n    uv.x *= iResolution.x / iResolution.y;\n\n    //Choosing the Zoom\n    float zoomAmount = pow(10.0,-iTime/8.0);\n    //zoomAmount = exp(-max(iTime-6.0,0.0));\n    //vec2 zoomPoint = vec2(0.354,0.0);\n    vec2 mousePoint = (iMouse.xy - iResolution.xy/2.0)*8.0/ iResolution.xy;\n    vec2 zoomPoint = vec2(-0.5,0.0);\n    \n    uv = uv*zoomAmount;\n    uv += zoomPoint;\n    //uv += mousePoint;\n    //uv += vec2(-0.61021,-0.0001);\n    //uv += zoomPoint*zoomAmount;\n    \n    //Determining the interior of the set\n    \n    //Change this line to go from Mandelbrot to Julia\n    //vec2 c = 30.0*(iMouse.xy/iResolution.xy - 0.5);\n    vec2 c = uv;\n    \n    float tol = pow(10.0,-8.0);\n    float currentModulus = lengthsquared(uv);\n    vec2 previousIteration;\n    int iterationAmount;\n    int testAmount = 1000;\n    \n    vec2 dummyuv = uv;\n    \n    for (iterationAmount = 0; iterationAmount < testAmount; iterationAmount++)\n    {\n        previousIteration = dummyuv;\n        dummyuv = iteration(dummyuv,c);\n        currentModulus = lengthsquared(dummyuv);\n        \n        if(currentModulus > pow(10.0,8.0))\n        {\n            break;\n        } \n    }\n\n    //Coloring the interior of the set\n    \n    if (currentModulus < pow(10.0,8.0))\n    {\n        \n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n    //Coloring the exterior of the set\n    \n    else\n    {\n        \n        /*if(iterationAmount <= 2)\n        {\n            float intensity = 1.0 - float(iterationAmount/10);\n            fragColor = vec4(intensity*0.7,intensity*0.0,intensity*1.0,1.0);\n        }*/\n        \n        //else\n        {\n            iterationAmount /= 200;\n            int periodFast = 5;\n            int residueFast = iterationAmount%periodFast;\n            float indexFast = float(residueFast)/float(periodFast);\n            vec3 colorFast = palette2(indexFast);\n            \n            int periodMedium = 30;\n            int residueMedium = iterationAmount%periodMedium;\n            float indexMedium = float(residueMedium)/float(periodMedium);\n            vec3 colorMedium = palette2(indexMedium);\n            \n            int periodSlow = 100;\n            int residueSlow = iterationAmount%periodSlow;\n            float indexSlow = float(residueSlow)/float(periodSlow);\n            vec3 colorSlow = palette2(indexSlow);\n\n            float finalIndex = (indexSlow + indexMedium + indexFast)*0.333333333;\n            vec3 finalColor = (colorSlow + colorMedium + colorFast)*0.3333333333;\n            fragColor = vec4(finalColor,1.0);\n     }\n        \n        \n    }\n\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}