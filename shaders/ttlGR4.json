{
    "Shader": {
        "info": {
            "date": "1555783245",
            "description": "Also VR compatible! Click to rotate the camera.",
            "flags": 1,
            "hasliked": 0,
            "id": "ttlGR4",
            "likes": 127,
            "name": "Flying Centipede",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarch",
                "pbr",
                "insect"
            ],
            "usePreview": 1,
            "username": "Klems",
            "viewed": 5510
        },
        "renderpass": [
            {
                "code": "\n#define PI 3.14159265359\n#define rot(a) mat2(cos(a + PI*0.5*vec4(0,1,3,0)))\n#define Z min(iFrame, 0)\n\n// how many segments there are\n#define SEGMENTS 21\n// only display the nth segment\n//#define SEGMENT 0\n\n#define COLOR_SHELL vec4(0.015, 0.01, 0.005, 0.3)\n#define COLOR_SHELL2 vec4(0.15, 0.01, 0.001, 0.6)\n#define COLOR_ORGAN vec4(0.3, 0.1, 0.01, 0.7)\n#define COLOR_SUB vec3(0.5, 0.8, 0.9)\n\n#define VR_SCALE 0.5\n\nvec4 dummy = vec4(0);\n\n// iq's distance to a box\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\n// iq's distance to capped cylinder\nfloat sdCappedCylinder( vec3 p, vec2 h ) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// iq's smooth minimum\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// iq's box filtered grid\nfloat grid( in vec2 p ) {\n    vec2 dpdx = dFdx(p);\n    vec2 dpdy = dFdy(p);\n    const float N = 15.0;\n    p += 1.0/N*0.5;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 0.5*w;                        \n    vec2 b = p - 0.5*w;           \n    vec2 i = (floor(a)+min(fract(a)*N,1.0)-\n              floor(b)-min(fract(b)*N,1.0))/(N*w);\n    return (1.0-i.x)*(1.0-i.y);\n}\n\n// dave hoskins hash\nvec3 hash33( vec3 p3 ) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// path parametric equation\nvec3 path( float x ) {\n    x += iTime*0.7;\n    return vec3(cos(x), sin(x*2.3312)*0.3 + sin(x*1.456)*0.4, sin(x))*1.0;\n}\n\n// path derivative\nvec3 pathd( float x ) {\n    x += iTime*0.7;\n    return vec3(-sin(x), cos(x*2.3312)*0.3*2.3312+cos(x*1.456)*0.4*1.456, cos(x))*1.0;\n}\n\n// path scale\nfloat paths( float x ) {\n    return 1.0 - cos(x*2.0)*0.3;\n}\n\n// one leg\nfloat leg( vec3 p, const bool complex, out vec4 albedo, float parm, float phase, int end ) {\n    \n    float scaleP = paths(parm);\n    \n    // walk animation\n    float xro = iTime*-3.0+phase*2.0*PI + parm*12.0;\n    float sro = sin(xro);\n    float cro = cos(xro);\n    \n    float ends = 1.0;\n    if (end == 0) ends = 0.2;\n    if (end == SEGMENTS-1) ends = 0.4;\n    \n    p = p.yxz;\n    \n    p.yz *= rot(sro*0.3*ends);\n    p.yx *= rot(-0.2);\n    p.y += 0.02;\n    \n    float de = length(p)-0.03;\n    float s = 0.0;\n    float scale = 1.0;\n    float col = 0.0;\n    \n    float temp = (cro*-0.5+0.5)*0.5*ends;\n    \n    for (int i = Z ; i < 3 ; i++) {\n    \t\n        // offset the leg segment\n        p.y -= 0.04;\n        p.yx *= rot( temp + 0.1*scale );\n        p.y -= 0.04;\n        \n        // bend toward a point\n        s += smoothstep(-0.04, 0.04, p.y)*scale;\n        // find out the segment dimension\n        vec2 dim = vec2(0.039 - 0.02*(scale *= 1.1) - 0.003*s, 0.04);\n        // get distance\n        float d = sdCappedCylinder( p, dim ) - 0.002;\n        de = smin(de, d, 0.01);\n        \n        // colorize a bit\n        if ( complex ) {\n            float f = smoothstep(0.01, -0.01, d);\n            float c = sin(p.y*60.0)*-0.5+0.5;\n        \tcol += f*c;\n        }\n    }\n    \n    if ( complex ) {\n        float f = max(0.2, 0.75-col*0.7);\n        vec4 colOrg = mix(COLOR_ORGAN, COLOR_SHELL2, clamp((1.0-scaleP)*3.0+0.5, 0.0, 1.0));\n        albedo = mix(colOrg, COLOR_SHELL, f);\n    }\n    \n    return de;\n    \n}\n\n// one body part with two legs, return organic/shell as vec2\nvec2 body( vec3 p, const bool complex, out vec4 albedo, float parm, int index ) {\n    \n    float scaleP = paths(parm);\n    p /= scaleP;\n    \n    // add a base body\n    vec3 dim = vec3(0.04, 0.01, 0.05);\n    dim += cos(p.zxx*vec3(48,38,30))*vec3(0.01, 0.005, 0.02);\n   \tfloat org = sdBox(p, dim) - 0.04;\n    \n    // shell above it\n    vec3 inShell = p - vec3(0, 0.055, -0.01);\n    inShell.yz *= rot(-0.15);\n    inShell.yz -= cos(inShell.xx*vec2(20, 15))*0.02;\n    inShell.x = abs(inShell.x) - cos(inShell.z*20.0+1.0)*0.01;\n    float de = sdBox(inShell, vec3(0.08, 0, 0.09)) - 0.01;\n    \n    // legs\n    vec3 inLe = p;\n    float phase = step(p.x, 0.0)*0.5;\n    inLe.x = abs(inLe.x);\n    if (index == 0) {\n        // recycle legs into antennas\n        phase *= 0.4;\n        inLe.xz *= rot(-1.2);\n        inLe -= vec3(0.12, 0.02, 0.02);\n        inLe.xy *= rot(-0.3);\n        // add mandibles while we're here\n        vec3 inMandi = p;\n       \tinMandi.x = abs(inMandi.x) - 0.04;\n        inMandi.yz += vec2(0.03, -0.1);\n        inMandi.xy *= rot(0.3);\n        inMandi.yz *= rot(-0.3);\n        float mandi = sdBox(inMandi, vec3(0.01, 0.03, 0.04)) - 0.025;\n        de = min(de, mandi);\n    } else if (index == SEGMENTS-1) {\n        phase *= 0.2;\n        inLe.xz *= rot(1.2);\n        inLe -= vec3(0.1, 0.02, -0.01);\n        inLe.xy *= rot(-0.3);\n    } else {\n        inLe.xy += vec2(-0.07, 0.02);\n    }\n    \n    // add more stuff between the body and leg\n    vec4 leAlbedo = vec4(0);\n    float le = leg(inLe, complex, leAlbedo, parm, phase, index);\n    float bum = length(inLe)-0.03;\n    le = smin(le, bum, 0.03);\n    \n    // add bump mapping and coloring\n    if ( complex ) {\n        float tex1 = textureLod(iChannel0, inShell.xz*1.0 + float(index)*0.1424, 0.0).r;\n        float tex2 = textureLod(iChannel0, inShell.xz*1.4 + float(index)*0.1424, 0.0).r;\n        float she = smoothstep(0.0, 0.025, de+tex1*0.005);\n        de += tex1*0.03;\n        org -= tex2*0.03;\n        vec4 colOrg = mix(COLOR_ORGAN, COLOR_SHELL2, clamp((1.0-(scaleP*scaleP))*3.0-0.5, 0.0, 1.0));\n        float leAl = smoothstep(0.01, 0.0, le);\n        colOrg = mix(colOrg, leAlbedo, leAl);\n        vec4 baseColor = mix(COLOR_SHELL, colOrg, she);\n        albedo = baseColor;\n    }\n    \n    // then add the legs to the shell\n    de = smin(de, le, 0.005);\n    \n    // return organic + shell to composite later\n    return vec2(org, de) * scaleP;\n}\n\n// distance estimator\nfloat de( vec3 p, const bool complex, out vec4 albedo ) {\n    \n    #ifdef SEGMENT\n    vec2 seg = body(p, complex, albedo, 0.0, SEGMENT);\n    return smin(seg.x, seg.y, 0.01);\n    #endif\n    \n    // find the two closest points\n    vec3[2] closestParmDistIndex = vec3[2](vec3(0, 9e9, 0), vec3(0, 9e9, 0));\n    float currentParm = 0.0;\n    for (int i = Z ; i < SEGMENTS ; i++) {\n        vec3 current = path(currentParm);\n        vec3 currentD = p - current;\n        float currentDist = dot(currentD, currentD);\n        if (currentDist < closestParmDistIndex[0].y) {\n            closestParmDistIndex[1] = closestParmDistIndex[0];\n            closestParmDistIndex[0] = vec3(currentParm,currentDist,float(i));\n        } else if (currentDist < closestParmDistIndex[1].y) {\n            closestParmDistIndex[1] = vec3(currentParm,currentDist,float(i));\n        }\n        currentParm -= 0.17 / length(pathd(currentParm)) * paths(currentParm);\n    }\n    \n    float dOrg = 8.0;\n    float dShe = 8.0;\n    \n    albedo = COLOR_SHELL;\n    \n    for (int i = Z; i < 2 ; i++) {\n        float centerParm = closestParmDistIndex[i].x;\n        int centerIndex = int(closestParmDistIndex[i].z);\n        vec3 center = path(centerParm);\n        \n        // create basis\n        vec3 upZ = path(centerParm + 0.3) - center;\n        vec3 forward = normalize(path(centerParm + 0.1) - center);\n        vec3 right = normalize(cross(forward, upZ));\n        vec3 up = cross(forward, right);\n        // offset and transform\n        vec3 tp = p - center;\n        tp = tp * mat3(right, up, forward);\n\t\t\n        // get distance to the object\n        vec4 albObj = vec4(0);\n        vec2 de = body(tp, complex, albObj, centerParm, centerIndex);\n        float minDe = min(de.x, de.y);\n        \n        // composite organic/shell differently so shell/legs don't merge together\n        dOrg = smin(dOrg, de.x, 0.07);\n        dShe = min(dShe, de.y);\n        \n        if (complex) {\n            albedo = mix(albedo, albObj, smoothstep(0.01, -0.01, minDe));\n        }\n    }\n    \n    float d = smin(dShe, dOrg, 0.02);\n    \n    return d;\n}\n\n// normal function, call de() in a for loop for faster compile times.\nvec3 getNormal( vec3 p, float here ) {\n    vec3 n = vec3(0);\n    for (int i = Z ; i < 3 ; i++) {\n        vec3 s = p;\n        s[i] += 0.01;\n        n[i] = de(s, true, dummy);\n    }\n    return normalize(n.xyz-here);\n}\n\n// PBR WORKFLOW BELOW\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n    float num = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n    float num = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n    return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 computeLighting(in vec3 normal, in vec3 viewDir,\n                     in vec3 albedo, in float metallic, in float roughness,\n                     in vec3 lightDir, in vec3 radiance) {\n    \n    vec3 result = vec3(0);\n    \n    // find half way vector\n    vec3 halfwayDir = normalize(viewDir + lightDir);\n    \n    // figure out surface reflection\n    vec3 F0 = vec3(0.04);\n    F0 = mix(F0, albedo, metallic);\n    \n    // find the PBR terms\n    float NDF = DistributionGGX(normal, halfwayDir, roughness);\n    float G = GeometrySmith(normal, viewDir, lightDir, roughness);\n    vec3 F = fresnelSchlick(max(dot(halfwayDir, viewDir), 0.0), F0);\n    \n    vec3 kS = F;\n    vec3 kD = 1.0 - kS;\n    kD *= 1.0 - metallic;\n    \n    // Cook Torrance BRDF\n    vec3 numerator = NDF * G * F;\n    float denominator = 4.0 * max(dot(normal, viewDir), 0.0) * max(dot(normal, lightDir), 0.0);\n    vec3 specular = numerator / max(denominator, 0.001);  \n    \n    // add light contribution\n    float NdotL = max(dot(normal, lightDir), 0.0);\n    result += (kD * albedo / PI + specular) * radiance * NdotL;\n    \n    return result;\n}\n\n// PBR WORKFLOW ABOVE\n\n// fake subsurface scattering\nvec3 computeSSS(in vec3 normal, in vec3 viewDir, \n                in vec3 albedo, in float trans, in float index,\n                in vec3 lightDir, in vec3 radiance) {\n    float add = 1.0 - index;\n    add *= add;\n    add *= add;\n    add *= add;\n    add *= add;\n    float fr = dot(viewDir, normal)*0.5+0.5;\n    float lu = dot(viewDir, lightDir)*-0.5+0.5;\n    add *= fr*fr;\n    add *= lu;\n    return radiance*add*1.0*trans*albedo;\n}\n\n// soft shadow function\nfloat traceShadow( in vec3 from, in vec3 dir, in vec3 normal, const float sinTheta ) {\n    if (dot(dir, normal) < 0.0) return 0.0;\n    float minAlpha = 1.0;\n    float totdist = 0.0;\n    #define SHADOW_STEPS 20\n    for (int i = Z ; i < SHADOW_STEPS ; i++) {\n        vec3 p = from+dir*totdist;\n        if (dot(p, p) > 6.0) return minAlpha;\n        float dist = de(p, false, dummy);\n        float rad = dist / (totdist*sinTheta);\n        float alpha = rad * 0.5 + 0.5;\n        if (alpha <= 0.0) {\n            return 0.0;\n        } else if (alpha < minAlpha) {\n            minAlpha = alpha;\n        }\n        totdist += max(0.01, dist*0.8);\n    }\n    return minAlpha;\n}\n\n// get lighting here\nvec3 getLighting( in vec3 p, in vec3 dir, float index ) {\n    // get surface albedo and roughness\n    vec4 albedo = vec4(0);\n    float d = de(p, true, albedo);\n    // get surface normal\n    vec3 n = getNormal(p, d);\n    \n    vec3 result = vec3(0);\n    const vec3 sunDir = normalize(vec3(1, 4, 2));\n    const vec3 subDir = normalize(vec3(2, -7, 3));\n    \n    // add two lights, main one with shadows\n    float shadow = traceShadow(p+n*0.01, sunDir, n, 0.05);\n    result += computeLighting(n, dir, albedo.rgb, (1.0-albedo.a)*0.3, albedo.a, sunDir,\n                              vec3(0.9, 0.85, 0.5)*10.0)*shadow;\n    result += computeLighting(n, dir, albedo.rgb, (1.0-albedo.a)*0.3, albedo.a, subDir,\n                              COLOR_SUB*0.5);\n    // and add subsurface scattering\n    result += computeSSS(n, dir, albedo.rgb, albedo.a, index, sunDir,\n                         vec3(0.9, 0.85, 0.5)*10.0);\n    result += computeSSS(n, dir, albedo.rgb, albedo.a, index, subDir,\n                         COLOR_SUB*0.5);\n    \n    return result;\n}\n\n// get background\nvec3 getBackground( in vec3 dir ) {\n    // raytrace two plane\n    dir.y = abs(dir.y);\n    float d = 1.0 / dir.y;\n    vec2 p = (dir*d).xz;\n    // add a simple grid\n    vec3 base = mix(COLOR_SUB*0.007, vec3(0.001), grid(p));\n    // and a black fog over it\n    base = mix(base, vec3(0.0002), 1.0-exp(-d*0.4));\n    return base;\n}\n\n// return ray color for this position and direction\nvec4 getColor( in vec2 fragCoord, in vec3 from, in vec3 dir ) {\n    \n    // get random stuff\n    vec3 rnd = hash33(vec3(fragCoord, iFrame*2+0));\n    \n    // find the angular extent of this pixel\n    vec3 ddir = normalize(dir+fwidth(dir)*0.5);\n    float sinPix = length(cross(dir, ddir));\n    // add some noise to the base distance as dithering\n    float totdist = 0.2*rnd.x;\n    \n    // keep track of the closest position\n    vec3 fullPos = vec3(0);\n    float fullAlpha = 0.0;\n    int fullIndex = 0;\n    \n    #define STEPS 100\n    for (int i = Z ; i < STEPS ; i++) {\n        vec3 p = from + dir*totdist;\n        // found sky, break early\n        if (dot(p, p) > 6.0) break;\n        // find out the average alpha here\n        float dist = de(p, false, dummy);\n        float rad = dist / (totdist*sinPix);\n        float alpha = rad * -0.5 + 0.5;\n        \n        // we have a covering sample, consider it\n        if (alpha > 0.0 && alpha > fullAlpha) {\n            fullPos = p;\n            fullAlpha = alpha;\n            fullIndex = i;\n            // sample is fully opaque, break early\n            if (alpha >= 1.0) break;\n        }\n            \n        // move to next sample point\n        totdist += max(0.0004, dist*0.8);\n    }\n    \n    // if we found the surface add lighting\n    if (fullAlpha > 0.0) {\n        float index = float(fullIndex)/float(STEPS-1);\n        fullAlpha = clamp(fullAlpha, 0.0, 1.0);\n        return vec4(getLighting(fullPos, -dir, index), fullAlpha);\n    }\n    \n    return vec4(0);\n}\n\n// vr entry point\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n    \n    // get color and mix with background\n    vec4 col = getColor(fragCoord, fragRayOri/VR_SCALE, fragRayDir);\n    fragColor.rgb = mix(getBackground(fragRayDir), col.rgb, col.a);\n    // tonemapping\n    fragColor.rgb = fragColor.rgb / (fragColor.rgb + vec3(1));\n    // gamma correction\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n    // add noise\n    vec3 rnd = hash33(vec3(fragCoord, iFrame*2+1));\n    fragColor.rgb += (rnd-0.5)*0.08;\n    \n    fragColor.a = 1.0;\n}\n\n// main entry point, simulate vr input\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = fragCoord - iResolution.xy * 0.5;\n    uv /= iResolution.y;\n    \n    vec3 from = vec3(0, 0, -2.0);\n    #ifdef SEGMENT\n    from = vec3(0, 0, -0.5);\n    #endif\n    vec3 dir = normalize(vec3(uv, 1.0));\n    \n    vec2 r = vec2(iTime*0.1, 0.3);\n    \n    if (iMouse.z > 0.25) {\n        r = iMouse.xy - iResolution.xy*0.5;\n        r *= -0.01;\n    }\n    \n    dir.yz *= rot(r.y+0.1);\n    from.yz *= rot(r.y);\n    dir.xz *= rot(r.x);\n    from.xz *= rot(r.x);\n    \n    mainVR(fragColor, fragCoord, from*VR_SCALE, dir);\n    \n    // add some vignetting in non vr\n    vec2 uvv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    float vigD = dot(uvv, uvv);\n    fragColor.rgb = mix(fragColor.rgb, vec3(0), vigD*0.3);\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}