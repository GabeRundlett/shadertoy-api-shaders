{
    "Shader": {
        "info": {
            "date": "1511060009",
            "description": "lol",
            "flags": 32,
            "hasliked": 0,
            "id": "llXBRH",
            "likes": 61,
            "name": "fractal shake ",
            "published": 3,
            "tags": [
                "raymarch"
            ],
            "usePreview": 0,
            "username": "macbooktall",
            "viewed": 2214
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uuv = uv * 2.0 - 1.0;\n    \n    vec4 tex = texture(iChannel0, uv);\n    vec4 col = min(vec4(.795), pow(tex, vec4(3.75)));\n    fragColor = mix(vec4(0.), col, 1.-smoothstep(0.,1.,length(uuv)*0.7));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MAXDIST 150.\n#define GIFLENGTH 1.570795\n\nstruct Ray {\n\tvec3 ro;\n    vec3 rd;\n};\n    \nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat length6( vec3 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y + p.z, 1.0/6.0 );\n}\n\nfloat fractal(vec3 p)\n{\n    p=p.yxz;\n    p.x += 6.;\n\n    float scale = 1.25;\n   \n    const int iterations = 30;\n\n    float time = iTime;\n    float a = time;\n    \n\tfloat l = 0.;\n\tfloat len = length(p);\n    //vec2 m = iMouse.xy / iResolution.xy;\n    vec2 f = vec2(0.1,0.1);\n\tvec2 m = vec2(.525,0.6);\n\n    pR(p.yz,.5);\n    \n    pR(p.yz,m.y*3.14);\n    \n    for (int i=0; i<iterations; i++) {\n\t\tp.xy = abs(p.xy);\n\t\tp = p*scale + vec3(-3.,-1.5,-.5);\n        \n\t\tpR(p.yz,m.y*3.14 + sin(iTime*4. + len)*f.x);\n\n        pR(p.xy,m.x*3.14 + cos(iTime*4. + len)*f.y);\n\t\t\n        l=length6(p);\n\t}\n\treturn l*pow(scale, -float(iterations))-.25;\n}\n\nvec2 map(vec3 pos) {\n\n    return vec2(fractal(pos), 0.);\n}\n\nvec2 march(Ray ray) \n{\n    const int steps = 90;\n    const float prec = 0.001;\n    vec2 res = vec2(0.);\n    \n    for (int i = 0; i < steps; i++) \n    {        \n        vec2 s = map(ray.ro + ray.rd * res.x);\n        \n        if (res.x > MAXDIST || s.x < prec) \n        {\n        \tbreak;    \n        }\n        \n        res.x += s.x;\n        res.y = s.y;\n        \n    }\n   \n    return res;\n}\n\nvec3 vmarch(Ray ray, float dist, vec3 normal)\n{   \n    vec3 p = ray.ro;\n    vec2 r = vec2(0.);\n    vec3 sum = vec3(0);\n  \tvec3 c = vec3(1.+dot(ray.rd,normal));\n    for( int i=0; i<20; i++ )\n    {\n        r = map(p);\n        if (r.x > .01) break;\n        p += ray.rd*.005;\n        vec3 col = c;\n        col.rgb *= smoothstep(.0,0.1,-r.x);\n        sum += abs(col);\n    }\n    return sum;\n}\n\n\nvec3 calcNormal(vec3 pos) \n{\n\tconst vec3 eps = vec3(0.005, 0.0, 0.0);\n                          \n    return normalize(\n        vec3(map(pos + eps).x - map(pos - eps).x,\n             map(pos + eps.yxz).x - map(pos - eps.yxz).x,\n             map(pos + eps.yzx).x - map(pos - eps.yzx).x ) \n    );\n}\n\nvec3 render(Ray ray) \n{\n    vec3 col = vec3(0.);\n\tvec2 res = march(ray);\n   \n    if (res.x > MAXDIST) \n    {\n        return col;\n    }\n    \n    vec3 p = ray.ro+res.x*ray.rd;\n    vec3 normal = calcNormal(p);\n    vec3 pos = p;\n    ray.ro = pos;\n   \tcol = vec3(1.+dot(ray.rd,normal))*1.2;\n    \n    col = mix(col, vec3(0.), clamp((res.x*res.x)/80., 0., 1.));\n   \treturn col;\n}\nmat3 camera(in vec3 ro, in vec3 rd, float rot) \n{\n\tvec3 forward = normalize(rd - ro);\n    vec3 worldUp = vec3(sin(rot), cos(rot), 0.0);\n    vec3 x = normalize(cross(forward, worldUp));\n    vec3 y = normalize(cross(x, forward));\n    return mat3(x, y, forward);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 camPos = vec3(0. + sin(iTime*4.)*0.045, .5, 10.+ cos(iTime*4.)*0.055);\n    vec3 camDir = camPos + vec3(-.1, .1 + cos(iTime*4.)*0.015, -1. );\n    mat3 cam = camera(camPos, camDir, 0.);\n    \n        vec2 polarUv = (uv * 2.0 - 1.0);\n\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    vec3 rayDir = cam * normalize( vec3(uv, 1. + cos(iTime*4.)*0.05) );\n    \n    Ray ray;\n    ray.ro = camPos;\n    ray.rd = rayDir;\n    \n    vec3 col = render(ray);\n    \n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// This buffer is the feedback loop\n\nvec3 hue(vec3 color, float shift) {\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI     = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ     = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR   = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG   = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB   = vec3 (1.0, -1.107, 1.704);\n\n    // Convert to YIQ\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I      = dot (color, kRGBToI);\n    float   Q      = dot (color, kRGBToQ);\n\n    // Calculate the hue and chroma\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    // Make the user's adjustments\n    hue += shift;\n\n    // Convert back to YIQ\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    // Convert back to RGB\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n    color.r = dot (yIQ, kYIQToR);\n    color.g = dot (yIQ, kYIQToG);\n    color.b = dot (yIQ, kYIQToB);\n\n    return color;\n}\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float time = mod(iTime, 1.570795);\n    float val1 = noise(uv*2. + time)*0.0025;\n    float val2 = noise(uv*2. + time - 1.570795)*0.0025;\n    \n\t\n    // Convert the uv's to polar coordinates to scale up  \n    vec2 polarUv = (uv * 2.0 - 1.0);\n\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    // Scale up the length of the vector by a noise function feeded by the angle and length of the vector\n    float llr = length(polarUv)*0.495;\n    float llg = length(polarUv)*0.4965;\n    float llb = length(polarUv)*0.498;\n \n    vec3 base = texture(iChannel0, uv).rgb;\n\n    vec2 offsR = vec2(cos(angle)*llr + 0.5, sin(angle)*llr + 0.5);\n    vec2 offsG = vec2(cos(angle)*llg + 0.5, sin(angle)*llg + 0.5);\n    vec2 offsB = vec2(cos(angle)*llb + 0.5, sin(angle)*llb + 0.5);\n    \n    // sample the last texture with uv's slightly scaled up\n    vec3 overlayR = texture(iChannel1,offsR).rgb;\n\tvec3 overlayG = texture(iChannel1,offsG).rgb;\n\tvec3 overlayB = texture(iChannel1,offsB).rgb;\n\tvec3 overlay = vec3(overlayR.r, overlayG.g, overlayB.b);\n\n    // Additively blend the colors together\n    vec4 col = vec4(base + overlay*0.55, 1.0);\n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}