{
    "Shader": {
        "info": {
            "date": "1641235204",
            "description": "Another try at rendering a 3D parametric curve. Still not perfectly glitch free.\n(See https://www.shadertoy.com/view/NlVSDz for the previous try and header comment for details)",
            "flags": 0,
            "hasliked": 0,
            "id": "slKSRt",
            "likes": 3,
            "name": "Clelia Curve2",
            "published": 3,
            "tags": [
                "3d",
                "distance",
                "curve",
                "newton",
                "parametric"
            ],
            "usePreview": 0,
            "username": "NinjaKoala",
            "viewed": 257
        },
        "renderpass": [
            {
                "code": "/*\nFollowup to https://www.shadertoy.com/view/NlVSDz\n\nIn a first step, parameter values are found such that\nthe corresponding points on the curve have exactly the distance\ncurve_width to the ray.\n\nThis is done using Newton's method.\n\nOf these, the parameter value which corresponds to\nthe point nearest to the camera is taken.\n\nIn a second step, this parameter value is altered by another iteration\nmethod which finds the point on the curve which is nearest to the ray.\n(It finds the local minimal distance, which is why it can't get to the wrong branch of the curve.)\n\nThe idea is that the first iteration finds out which branch of the curve is hit first,\nand gets a parameter value that is only slightly off from that which we actually want,\nwhich is then found by the second iteration.\n\nI haven't thorougly compared the performance of this method to other methods\n(Raymarching with line segments or bezier segments approximation\nor directly raymarching with the used distance approximation),\nmaybe i will do this later on.\n*/\n\nconst float pi=3.1415925;\n\nconst int num_iterations=6;\nconst int num_start_params=32;\n\nconst int marching_steps=10;\nconst int num_iterations2=3;\n\nconst float curve_width_sq=.003;\nconst float eps=.0001;\n\nconst int clelia_fac1=1;\nconst int clelia_fac2=4;\n\nconst float radius=1.;\n\nconst float rotation_speed=.5;\n\n//#define SHOW_PARAMETER\n\n\nconst float clelia_fac=float(clelia_fac1)/float(clelia_fac2);\nconst float clelia_period=float(clelia_fac2)*2.*pi;\n\nfloat spectral(float x){\n        return clamp(abs(mod((x/pi+1.)*4.,8.)-4.)-2.,-.75,.75)*.5/.75+.5;\n}\n\nvec3 to_col(float x){\n\treturn vec3(spectral(x),spectral(x+pi/2.),spectral(x-pi));\n}\n\nmat2 rot(float t){\n\treturn mat2(cos(t),-sin(t),sin(t),cos(t));\n}\n\nvec3 parametric(float t){\n\t//clelia curve\n\tt*=clelia_period;\n\tvec3 p = radius*vec3(cos(t)*cos(clelia_fac*t),cos(t)*sin(clelia_fac*t),sin(t));\n    p.yz*=rot(mod(rotation_speed*iTime,2.*pi));\n\treturn p;\n}\n\nvec3 parametric_diff(float t){\n\t//clelia curve\n\tt*=clelia_period;\n\tvec3 p = clelia_period*radius*vec3(-clelia_fac*cos(t)*sin(clelia_fac*t)-sin(t)*cos(clelia_fac*t),\n\t                                   clelia_fac*cos(t)*cos(clelia_fac*t)-sin(t)*sin(clelia_fac*t),\n\t                                   cos(t));\n\n    p.yz*=rot(mod(rotation_speed*iTime,2.*pi));\n\treturn p;\n}\n\nfloat parametric_normal_iteration3d(float t, vec3 p0){\n\tvec3 p0_to_p=parametric(t)-p0;\n\tvec3 tang=parametric_diff(t);\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,p0_to_p)/l_tang;\n}\n\nfloat ray_to_curve_dis_sq(vec3 ro, vec3 rd, float t0){\n\tvec3 p0=parametric(t0);\n\tfloat s0=dot(p0-ro,rd);\n\tvec3 p1=ro+s0*rd-p0;\n\treturn dot(p1,p1);\n}\n\nfloat ray_to_curve_dis_sq_diff(vec3 ro, vec3 rd, float t0){\n\tvec3 p0=parametric(t0);\n\tvec3 p0_diff=parametric_diff(t0);\n\tfloat s0=dot(p0-ro,rd);\n\tvec3 p1=ro+s0*rd-p0;\n\treturn 2.*dot(p1,dot(p0_diff,rd)*rd-p0_diff);\n}\n\nbool parametric_curve_newton_trace(vec3 ro, vec3 rd, out vec3 p0, out vec3 nor, out float t1){\n\n\tfloat t0=0.;\n\tfloat d0=1e38;\n\tt1=1e38;\n\n\tfor(int i=0;i<num_start_params;i++){\n\t\tfloat t=t0;\n\t\tfor(int j=0;j<num_iterations;j++){\n\t\t\tt-=(ray_to_curve_dis_sq(ro,rd,t)-curve_width_sq)/ray_to_curve_dis_sq_diff(ro,rd,t);\n\t\t}\n\t\tvec3 p1=parametric(t);\n\n\t\tfloat d1=dot(p1-ro,rd);\n\n\t\tif(abs(ray_to_curve_dis_sq(ro,rd,t)-curve_width_sq)<eps && d1<d0){\n\t\t\tt1=t;\n\t\t\td0=d1;\n\t\t}\n\n\t\tt0+=1./float(num_start_params-1);\n\t}\n\n\tif(t1!=1e38){\n\t\tvec3 p1=ro+d0*rd;\n\t\tfor(int i=0;i<marching_steps;i++){\n\t\t\tfor(int j=0;j<num_iterations2;j++){\n\t\t\t\tt1=parametric_normal_iteration3d(t1,p1);\n\t\t\t}\n\n\t\t\tp0=parametric(t1);\n\t\t\td0=dot(p0-ro,rd);\n\t\t\tp1=ro+d0*rd;\n\t\t}\n\n\t\tp1-=rd*sqrt(curve_width_sq-dot(p1-p0,p1-p0));\n\t\tnor=normalize(p1-p0);\n\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0, 0, 3);\n    vec3 rd = normalize(vec3(uv, 0.) - vec3(0,0,1));\n\n\tvec3 nor, p0;\n\tfloat t0;\n\n\tbool hit = parametric_curve_newton_trace(ro,rd,p0,nor,t0);\n\n    if(hit){\n        vec3 light = vec3(0, 1, 4);\n        \n        float dif = clamp(dot(nor, normalize(light - p0)), 0., 1.);\n        dif *= 5. / dot(light - p0, light - p0);\n        \n\t\t#ifdef SHOW_PARAMETER\n        fragColor = vec4(vec3(pow(dif, 0.4545)), 1)*vec4(to_col(t0*2.*pi),1);\n\t\t#else\n        fragColor = vec4(vec3(pow(dif, 0.4545)), 1);\n\t\t#endif\n    }\n    else{\n        fragColor = vec4(0, 0, 0, 1);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}