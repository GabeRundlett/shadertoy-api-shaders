{
    "Shader": {
        "info": {
            "date": "1506324400",
            "description": "2D spot-light with a sine wave pattern, chromatic split and noise.",
            "flags": 0,
            "hasliked": 0,
            "id": "4tsyWS",
            "likes": 4,
            "name": "Alien Light",
            "published": 3,
            "tags": [
                "procedural",
                "2d",
                "noise",
                "wave"
            ],
            "usePreview": 0,
            "username": "Yetman",
            "viewed": 798
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926535897932384626433832795\n#define PI2 (2.0*PI)\n#define WAVE_FREQ 75.0\n#define COMPRESSION_FACTOR 1.0\n#define WAVE_SPEED 30.0\n#define NOISE_SCALE 5.0\n#define NOISE_SPEED 100.0\n#define NOISE_INTENSITY 0.7\n#define WAVE_FADE_FACTOR 7.0\n#define CHROMATIC_OFFSET 0.04\n#define CONE_HALF_ANGLE atan(1.0,1.0)\n#define CONE_CENTER vec2(0.0, 1.0)\n#define CONE_DIRECTION vec2(0.0, -1.0)\n#define CONE_FADE_FACTOR 2.0\n#define LIGHT_INTENSITY 1.5\n\n//all rand and noise functions from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nfloat limit_angle(float angle){\n    return PI2 * fract(angle / PI2);\n}\n\nfloat eval(vec2 delta){\n\tfloat dist = length(delta);\n    float x = WAVE_FREQ*dist;\n    x *= 1.0+(COMPRESSION_FACTOR*dist);\n    x -= WAVE_SPEED*iTime;\n    float wave = 0.5 + (0.5*sin(limit_angle(x)));\n    //1e5 added below to abuse the problem of sin function \n    //when using high floating points to make a glitch effect\n    //NOTE: this is probably not a reliable way to make an effect since it may not work on other devices\n    vec2 noise_kernel = NOISE_SCALE*delta + NOISE_SPEED*fract(iTime) + 1e5; \n    float noise_val = NOISE_INTENSITY*rand(noise(noise_kernel));\n    float fade = 1.0+WAVE_FADE_FACTOR*dist*dist;\n\treturn (wave + noise_val)/fade;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec2 center = CONE_CENTER;\n    const vec2 direction = normalize(CONE_DIRECTION);\n    const vec2 orthogonal = vec2(-direction.y, direction.x);\n\tvec2 p = (2.0*fragCoord.xy - iResolution.xy)/iResolution.yy;\n    vec2 delta = p - center;\n    vec2 offset = CHROMATIC_OFFSET*orthogonal;\n\tfloat r = eval( delta + offset );\n\tfloat gb = eval( delta - offset );\n    float ang = atan(dot(delta, orthogonal), dot(delta, direction)) / CONE_HALF_ANGLE;\n\tfloat intensity = max(0.0, 1.0/(1.0+CONE_FADE_FACTOR*ang*ang) - 1.0/(1.0 + CONE_FADE_FACTOR));\n\tfragColor = vec4(vec3(r, gb, gb) * intensity * LIGHT_INTENSITY, 1.0);\n\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}