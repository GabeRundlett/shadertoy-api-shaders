{
    "Shader": {
        "info": {
            "date": "1645360992",
            "description": "More synthwave stuff \\o/\nI've cut a lot of corners to get this one running smoothly. Feel free to play with FSAA if your GPU is a beast (4 or +) or you like pixels (1).",
            "flags": 0,
            "hasliked": 0,
            "id": "fdffz2",
            "likes": 17,
            "name": "Synthwave city",
            "published": 3,
            "tags": [
                "city",
                "car",
                "synthwave"
            ],
            "usePreview": 0,
            "username": "nyri0",
            "viewed": 797
        },
        "renderpass": [
            {
                "code": "const int FSAA = 2;\nconst float EPS = 0.01;\nconst float FOVH = 70.0;\nconst float D = 0.1;\nconst float L = 200.0;\nconst int MAX_ITER = 100;\nconst float ROAD_RADIUS = 4.;\nconst float SPEED = 2.;\n\nconst vec3 CYAN = vec3(0.4,.95,1);\nconst vec3 PINK = vec3(1,.2,.9);\nconst vec3 BLACK = vec3(0,0,0);\n\n// From https://www.shadertoy.com/view/Msf3WH\nvec2 hashv( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hashv(i+0.0)), dot(b,hashv(i+o)), dot(c,hashv(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\n// Minimum of distance wit hcolor.\nvec4 min_sdf(vec4 a, vec4 b) {\n    return a.w < b.w ? a : b;\n}\n\n// From https://www.shadertoy.com/view/WttXWX\nuint hash(uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\n//vec4 hash_vec4(uint x)\n//{\n//    uint hash_ = hash(x);\n//    return vec4(\n//        hash_ & 0xffU,\n//        (hash_ >> 8) & 0xffU,\n//        (hash_ >> 16) & 0xffU,\n//        (hash_ >> 24) & 0xffU\n//    ) / float(0xffU);\n//}\n\nvec4 sdf_building( vec3 p, vec3 col, vec3 b, bool get_color)\n{\n  vec3 q = abs(p) - b;\n  float sdf_ = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  if(get_color) {\n      vec3 bdv = smoothstep(vec3(-.6), vec3(-.4), q);\n      float bd = max(bdv.x*bdv.y, max(bdv.x*bdv.z, bdv.y*bdv.z));\n      col = mix(col, CYAN, bd);\n  }\n  return vec4(col,sdf_);\n}\nfloat sdf_box( vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Color in xyz and sdf in w.\nvec4 sdf(in vec3 pos, bool get_color) {\n    vec4 sdf_ = vec4(0,0,0,1000);\n\n    const float R_0_X = 32.;\n    const float R_0_Z = 32.;\n    const float R_0_D = 100.;\n    const int GM = 2;\n    const int GN = 2;\n    const float w = R_0_X/float(GN);\n    const float we = .325*w;\n    vec3 col;\n    if(get_color) {\n        uint col_hash = hash(uint(.6*abs(pos.x)) + (uint(1.5*abs(pos.y))<<12) + (uint(.6*abs(pos.z))<<16) + (pos.x > 0. ? 13u : 0u));\n        int col_idx = int(col_hash % 16u);\n        col = col_idx == 0 ? CYAN : (col_idx == 1 ? PINK : BLACK);\n    } else {\n        col = BLACK;\n    }\n    const float heights[4] = float[](42., 34., 34., 32.);\n    for(int i = 0; i < GM; i++) {\n        for(int j = 0; j < GN; j++) {\n            int idx = GN * i + j;\n            float height = heights[idx];\n            vec3 c = vec3(-R_0_X/2.+w*(0.5+float(j)), 0.0, -R_0_Z/2.+w*(0.5+float(i)));\n            vec3 pos0 = pos - c;\n            pos0.x += sign(pos.x) * 15.;\n            pos0.x = pos0.x-R_0_X*(clamp(round(pos0.x/R_0_X),pos.x > 0. ? 1. : -8.,pos.x > 0. ? 8. : -1.));\n            pos0.z += R_0_D;\n            pos0.z = pos0.z-R_0_Z*clamp(round(pos0.z/R_0_Z),-16.,0.);\n            sdf_ = min_sdf(sdf_, \n                sdf_building(pos0, col, vec3(we, height, we), get_color)\n            );\n        }\n    }\n    \n    //sdf_ = min_sdf(sdf_, vec4(1,1,1,length(pos-vec3(0,1,-5))-1.));\n    {\n        vec3 pos1 = pos;\n        pos1.x -= ROAD_RADIUS;\n        pos1.x = mod(pos1.x+ROAD_RADIUS, 2.*ROAD_RADIUS)-ROAD_RADIUS;\n        sdf_ = min_sdf(sdf_, vec4(CYAN, sdf_box(pos1, vec3(0.05,0.05,400.))));\n    }\n    {\n        vec3 pos2 = pos;\n        pos2.x = abs(pos2.x);\n        pos2.z -= SPEED * iTime;\n        pos2.z = mod(pos2.z+ROAD_RADIUS, 2.*ROAD_RADIUS)-ROAD_RADIUS;\n        sdf_ = min_sdf(sdf_, vec4(CYAN, sdf_box(pos2 - vec3(ROAD_RADIUS+200.,0,0), vec3(200.,.05,.05))));\n    }\n    \n    return sdf_;\n}\n\nfloat non_zero(float x) {\n    return x + (x >= 0. ? 0.0001 : -0.0001);\n}\n\n// Ray marching engine.\nvoid rayMarcher(in vec3 cameraPos, in vec3 lookDir, in vec2 screenDim, in vec2 uv,\n                inout vec3 col, in bool mirror) {\n    vec3 up = vec3(0, 1, 0);\n    vec3 lookPerH = normalize(cross(lookDir, up));\n    vec3 lookPerV = normalize(cross(-lookDir, lookPerH));\n    vec3 screenCenter = cameraPos + lookDir;\n    vec3 screenPos = screenCenter + 0.5 * screenDim.x * uv.x * lookPerH\n                     + 0.5 * screenDim.y * uv.y * lookPerV;\n    \n    vec3 rayDir = normalize(screenPos - cameraPos);\n    \n    // Simple way of doing the reflections, inaccurate if lookDir is not parallel to the ground.\n    float diffuse;\n    if(mirror) {\n        // Noise in function of where the ray intersects the reflective surface.\n        float s = -cameraPos.y / non_zero(rayDir.y);\n        vec3 surf_inter = cameraPos + s * rayDir;\n        if(s < 0.) return;\n        vec2 surf_uv = (surf_inter.xz - vec2(0, SPEED*iTime));\n        float noise_ = noise(5.*surf_uv);\n        diffuse = abs(surf_uv.x) < ROAD_RADIUS ? 0.1 : 0.2;\n    \n        float noise_coef = abs(surf_uv.x) < ROAD_RADIUS ? 0.05 : 0.2;\n        //cameraPos.y = -cameraPos.y;\n        cameraPos = surf_inter;\n        rayDir.y = -rayDir.y+noise_coef*noise_;\n    }\n    \n    float t = 0.0;\n    vec4 dist;\n    vec3 pos;\n    int iter = 0;\n    do {\n        pos = cameraPos + t * rayDir;\n        dist = sdf(pos, false);\n        t += dist.w;\n        iter++;\n    } while(t < L && iter < MAX_ITER && dist.w > EPS);\n    \n    if(pos.y < 0.) return;\n    \n    if(dist.w <= EPS && (!mirror || pos.z > -200.)) {\n        dist = sdf(pos, true);\n        float v = 1.0 - t / L;\n        col = dist.xyz;\n    } else {\n        float s = (40.-cameraPos.z) / rayDir.z;\n        vec2 sky_uv = (cameraPos + s*rayDir).xy;\n        float stars_noise = noise(sky_uv);\n        float white_intensity = smoothstep(0.6, 1.0, stars_noise);\n        col = mix(col, vec3(1,1,1), white_intensity);\n    }\n    \n    if(mirror) {\n        col = mix(col, vec3(.5,0,.7), diffuse);\n    }\n}\n\nvec4 sampleColor(in vec2 sampleCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    float screenWidth = 2.0 * D * atan(0.5 * FOVH);\n\n    vec3 cameraPos = vec3(0, 2.5, 0);\n    vec3 lookDir = vec3(0, 0., -D);\n    vec2 screenDim = vec2(screenWidth, screenWidth / aspectRatio);\n\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = 2.0 * sampleCoord / iResolution.xy - 1.0;\n    //vec2 uvf = 2.0* (sampleCoord - iResolution.xy / 2.0) / iResolution.y;\n    \n    // TODO: anti aliasing\n    vec3 col = BLACK;\n    rayMarcher(cameraPos, lookDir, screenDim, uv, col, true);\n    rayMarcher(cameraPos, lookDir, screenDim, uv, col, false);\n    \n    // Very useful visual debugging\n    //float sdf_2d = sdf(12.*vec3(uvf.x, 0., uvf.y-4.));\n    //if(sdf_2d < 0.) col = vec3(cos(60.*sdf_2d), 0, 0);\n    //else col = vec3(0, 0, cos(60.*sdf_2d));\n\n    // Output to screen\n    return vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 colSum = vec4(0);\n    for(int i = 0; i < FSAA; i++) {\n        for(int j = 0; j < FSAA; j++) {\n            colSum += sampleColor(fragCoord + vec2(float(i) / float(FSAA), float(j) / float(FSAA)));\n        }\n    }\n    fragColor = colSum / colSum.w;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}