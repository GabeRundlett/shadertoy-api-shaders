{
    "Shader": {
        "info": {
            "date": "1701567904",
            "description": "KIFS experiment part 2",
            "flags": 0,
            "hasliked": 0,
            "id": "dtdfWB",
            "likes": 7,
            "name": "Sphere-pinski",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "fractal",
                "raymarcher"
            ],
            "usePreview": 0,
            "username": "isaacchurchill",
            "viewed": 189
        },
        "renderpass": [
            {
                "code": "const int MAX_MARCHES = 300;\nconst float RAYMARCH_THRESHOLD = 0.001;\nconst float NORMAL_EPSILON = 0.001;\n\nmat2 rot_xy(float theta)\n{\n    return mat2(cos(theta), sin(theta),\n                -sin(theta), cos(theta));\n}\n\nvec3 palette(float iter)\n{\n    return 0.5 + 0.5 * sin(iter + vec3(0, 1, 2));\n}\n\nvec4 union_de(vec4 a, vec4 b)\n{\n    if (b.w < a.w) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nfloat box3d_de(vec3 p, vec3 sizes)\n{\n    vec3 temp = abs(p) - sizes;\n    return length(max(temp, 0.0)) + min(max(max(temp.x, temp.y), temp.z), 0.0);\n}\n\nfloat fractal_de(vec3 p, out float iter)\n{\n    float scale = 2.0;\n    float max_i = floor(mod(iTime + 6.0, 6.99)) + 1.0;\n    float s = 1.0;\n    float d = 1e6;\n\n    const float width = 1.0;\n    const float thickness = 0.05;\n    const float r = thickness / 2.0;\n    const float a = (width - thickness) / 2.0;\n    for (float i = 0.0; i < max_i; i++) {\n        p = abs(p);\n        if (p.x > p.y) {\n            p.xy = p.yx;\n        }\n        if (p.y < p.z) {\n            p.yz = p.zy;\n        }\n        if (p.x > p.z) {\n            p.xz = p.zx;\n        }\n        float d1 = (length(p) - 0.5) * s;\n        if (d1 < d) {\n            iter = i;\n        }\n        d = min(d, d1);\n        p -= vec3(0.0, 0.5, 0.0);\n        p *= scale;\n        s /= scale;\n    }\n    return d;\n}\n\nfloat dist_estim(vec3 p, out vec3 col)\n{\n    float iter = 0.0;\n    float scale = 0.4;\n    float fractal = fractal_de(p / scale, iter) * scale;\n    vec3 plane_col = vec3(0.5);\n    if ((mod(p.x, 1.0) > 0.5) != (mod(p.z, 1.0) > 0.5)) {\n        plane_col = vec3(1.0);\n    }\n\n    vec4 de = vec4(palette(iter), fractal);\n    de = union_de(de, vec4(plane_col, abs(p.y + 0.4)));\n\n    col = de.xyz;\n    return de.w;\n}\n\nvec3 calc_normal(vec3 p)\n{\n    const vec2 eps = vec2(0.0, NORMAL_EPSILON);\n    vec3 temp = vec3(0.0);\n    return normalize(vec3(\n        dist_estim(p + eps.yxx, temp),\n        dist_estim(p + eps.xyx, temp),\n        dist_estim(p + eps.xxy, temp)\n        ) - dist_estim(p, temp));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = vec3(0.0);\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    if (m.x < 0.01 && m.y < 0.01) {\n        m = vec2(0.3, 0.45);\n    }\n    vec2 rot = (m - 0.5) * 4.0;\n    vec3 ray_dir = normalize(vec3(uv, 2.0));\n    mat2 yz_mat = rot_xy(rot.y);\n    mat2 xz_mat = rot_xy(rot.x);\n    ray_dir.yz *= yz_mat;\n    ray_dir.xz *= xz_mat;\n    vec3 ray_endpoint = vec3(0.0, 0.0, -1.0);\n    ray_endpoint.yz *= yz_mat;\n    ray_endpoint.xz *= xz_mat;\n    \n    vec3 light_dir = normalize(vec3(0.3, 1.0, -0.5));\n    \n    for (int march = 0; march < MAX_MARCHES; march++) {\n        vec3 surface_col = vec3(0.0);\n        float dist = dist_estim(ray_endpoint, surface_col);\n        if (dist < RAYMARCH_THRESHOLD) {\n\t\t\tvec3 norm = calc_normal(ray_endpoint);\n            float intensity = max(dot(norm, light_dir), 0.0);\n            vec3 light_col = vec3(0.9);\n            vec3 ambient = vec3(0.1);\n            col = surface_col * (light_col * intensity + ambient);\n            break;\n        }\n        ray_endpoint += ray_dir * dist * 0.5;\n    }\n\n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}