{
    "Shader": {
        "info": {
            "date": "1615107210",
            "description": "I'm obsessed with shiny stuff now (had to throw in a matte material too though).",
            "flags": 0,
            "hasliked": 0,
            "id": "wlKfWK",
            "likes": 12,
            "name": "Satisfying Shininess",
            "published": 3,
            "tags": [
                "raytracing",
                "materials",
                "matte",
                "metal",
                "shiny",
                "plastic",
                "satisfying"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 170
        },
        "renderpass": [
            {
                "code": "//#define ANIMATE\n//#define METAL\n#define PLASTIC\n//#define RUBBER\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nfloat fbm(in float x) {\n    x *= 0.5;\n\n    float v = 0.0;\n    float n = 1.0;\n    float t = 0.0;\n\n    for (int i=0; i < 5; i++) {\n        v += mix(Hash11(floor(x)), Hash11(ceil(x)), smoothstep(0.0, 1.0, fract(x))) * n;\n        t += n;\n        n *= 0.5;\n        x *= 2.0;\n    }\n\n    return v / t;\n}\n\n// Cubic solver\nvec4 solveCubic(in float a, in float b, in float c, in float d) {\n    float h = 18.0 * a * b * c * d - 4.0 * b * b * b * d + b * b * c * c - 4.0 * a * c * c * c - 27.0 * a * a * d * d, minCplx = 1.0;\n\n    float d0 = b * b - 3.0 * a * c;\n    float d1 = (2.0 * b * b - 9.0 * a * c) * b + 27.0 * a * a * d;\n    float q = d1 * d1 - 4.0 * d0 * d0 * d0, j = sqrt(abs(q));\n    a *= 3.0;\n\n    vec2 C = q < 0.0 ? vec2(d1, j) : vec2(d1 + j, 0.0);\n    if (abs(C.x) < 1e-3 && abs(C.y) < 1e-3) C = q < 0.0 ? vec2(d1, -j) : vec2(d1 - j, 0.0); // Switch sign if C=0\n    C = sin(atan(C.y, C.x) / 3.0 + vec2(1.57079632679, 0.0)) * pow(0.25 * dot(C, C), 1.0 / 6.0);\n\n    vec4 roots = vec4(0.0, 0.0, 0.0, h < 0.0 ? 1 : 3);\n    vec2 e = vec2(1.0, 0.0);\n    for (int k=0; k < (h < 0.0 ? 2 : 3); k++) {\n        vec2 m = e * mat2(C.x, -C.y, C.yx); // Complex multiplication\n        e *= mat2(-0.5, -0.86602540378, 0.86602540378, -0.5); // Raise cube root of unity to next power\n        vec2 root = (vec2(-d0, d0) * m / dot(m, m) - vec2(b, 0.0) - m) / a;\n        if (h < 0.0 ? (abs(root.y) < minCplx) : true) roots[h < 0.0 ? 0 : k] = root.x, minCplx = abs(root.y);\n    }\n\n    return roots;\n}\n\n// mla's suggestion to reverse the coefficients and reciprocate the results\nvec4 solveCubic2(in float a, in float b, in float c, in float d) {\n    vec4 roots = solveCubic(d, c, b, a);\n    roots[0] = 1.0 / roots[0];\n    if (roots[3] > 1.0) roots.yz = 1.0 / roots.yz;\n    return roots;\n}\n\n// Trilinear surface intersection and normal\nvec4 IntersectTrilinearSurf(in vec3 ro, in vec3 rd, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    float x = ro.x, y = ro.y, z = ro.z;\n    float u = rd.x, v = rd.y, w = rd.z;\n\n    float ba = b - a, ca = c - a, ea = e - a;\n    float q = ba + c - d + e - f - g + h;\n    float dbac = d - ba - c, fbae = f - ba - e, gcae = g - ca - e;\n    float xy = x * y, uv = u * v;\n    float xvuy = x * v + u * y;\n\n    float coeff1 = q * uv * w;\n    float coeff2 = dbac * uv + (fbae * u + gcae * v) * w + (xvuy * w + uv * z) * q;\n    float coeff3 = ba * u + ca * v + ea * w + xvuy * dbac + (x * w + u * z) * fbae + (y * w + v * z) * gcae + (xy * w + xvuy * z) * q;\n    float coeff4 = a + ba * x + ca * y + ea * z + dbac * xy + (fbae * x + gcae * y) * z + q * xy * z;\n\n    return solveCubic2(coeff1, coeff2, coeff3, coeff4);\n}\n\nvec3 getTrilinearSurfNormal(in vec3 p, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    float x = p.x, y = p.y, z = p.z;\n\n    float ba = b - a, ca = c - a;\n    float q = ba + c - d + e - f - g + h, qx = q * x;\n    float dbac = d - ba - c, fbae = f - ba - e, gcae = g - ca - e;\n\n    float dx = ba + dbac * y + (fbae + q * y) * z;\n    float dy = ca + dbac * x + (gcae + qx) * z;\n    float dz = e - a + fbae * x + (gcae + qx) * y;\n\n    return normalize(vec3(dx, dy, dz));\n}\n\nbool intersectIsValid(in vec3 p, in float t) {\n    return t > 0.0 && length(p) < 5.0;\n}\n\nvec4 render(in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    float time = 1406.42;\n\n    #ifdef ANIMATE\n    time = iTime;\n    #endif\n\n    vec2 mouse = iMouse.z > 0.0 ? (iMouse.xy - center) / iResolution.y * 3.14 : vec2(iTime * 0.5, -0.5);\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    ro += 0.5;\n\n    vec4 fragColor = texture(iChannel0, rd);\n\n    // Isovalues\n    float a = fbm(time + 357.473);\n    float b = fbm(time + 738.484);\n    float c = fbm(time + 576.475);\n    float d = fbm(time + 857.782);\n    float e = fbm(time + 867.281);\n    float f = fbm(time + 329.385);\n    float g = fbm(time + 234.235);\n    float h = fbm(time + 813.574);\n\n    vec4 intersect = IntersectTrilinearSurf(ro, rd, a, b, c, d, e, f, g, h);\n    int numIntersects = int(intersect[3]);\n\n    // Find closest valid intersection\n    vec3 hitPos;\n    float tMin = 1000000.0;\n    bool intersecting = false;\n    for (int i=0; i < numIntersects; i++) {\n        vec3 posCandid = ro + rd * intersect[i];\n        float tCandid = intersect[i];\n        if (intersectIsValid(posCandid, tCandid) && tCandid < tMin) {\n            hitPos = posCandid;\n            tMin = tCandid;\n            intersecting = true;\n        }\n    }\n\n    if (intersecting) {\n        vec3 n = getTrilinearSurfNormal(hitPos, a, b, c, d, e, f, g, h);\n        n *= sign(dot(n, rd)); // Flip towards camera\n\n        #ifdef METAL\n        vec4 envMap = texture(iChannel0, reflect(rd, n));\n        fragColor = envMap * max(0.0, dot(rd, n));\n        #endif\n\n        #ifdef PLASTIC\n        for (int i=0; i < numIntersects; i++) {\n            vec3 pos = ro + rd * intersect[i];\n            float t = intersect[i];\n            if (intersectIsValid(pos, t)) {\n                vec4 envMap = texture(iChannel0, reflect(rd, n));\n                fragColor = mix(fragColor, envMap * max(0.0, dot(rd, n)), 0.5);\n            }\n        }\n        #endif\n\n        #ifdef RUBBER\n        fragColor = vec4(sqrt(max(0.0, dot(rd, n))));\n        #endif\n    }\n\n    return fragColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = render(fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}