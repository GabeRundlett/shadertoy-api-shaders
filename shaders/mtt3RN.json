{
    "Shader": {
        "info": {
            "date": "1682041935",
            "description": "Wanted an effect to mimic what it is like to zoom in on an LCD monitor.\nDid not find an effect like this, so I decided to make it myself. Feel free to use!",
            "flags": 0,
            "hasliked": 0,
            "id": "mtt3RN",
            "likes": 6,
            "name": "LCD Sub-pixel zoom effect",
            "published": 3,
            "tags": [
                "2d",
                "effect"
            ],
            "usePreview": 0,
            "username": "lazergenix",
            "viewed": 271
        },
        "renderpass": [
            {
                "code": "// LCD Sub-pixel zoom effect\n//\n// Note: Qaulity could be greatly improved (on small zoom values) by sampling\n//         the texture multiple times, but im too lazy to implement that\n\n/*\nMIT No Attribution License\nCopyright 2023 Lazergenix <lazergenixdev@gmail.com>\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the “Software”), to deal in the Software without restriction,\nincluding without limitation the rights to use, copy, modify, merge,\npublish, distribute, sublicense, and/or sell copies of the Software,\nand to permit persons to whom the Software is furnished to do so.\n\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n\n// Here are some constants to play around with\n#define EFFECT_DROPOUT 0.254\n#define EFFECT_RANGE   3.0\n#define ZOOM_CENTER    float2(0.5, 0.5)\n#define HORZ_SPACING   0.02 * 3.0\n#define VERT_SPACING   0.05\n\n\n// I DESPISE GLSL (this message was made by hlsl gang)\n#define float4 vec4\n#define float3 vec3\n#define float2 vec2\n#define SAMPLE0(UV) texture(iChannel0, UV)\n#define saturate(X) clamp(X, 0.0, 1.0)\n#define frac fract\n#define COLOR_BLACK float3(0.0,0.0,0.0)\n#define COLOR_WHITE float3(1.0,1.0,1.0)\n#define lerp mix\n\nfloat3 subpixel(float2 uv, float ZoomLevel) {\n    float2 center = ZOOM_CENTER;\n\n    // Scale UV based on our Zoom Level\n    uv -= center;\n    uv *= 1.0/ZoomLevel;\n    uv += center;\n\n    // Get color at the UV Coords\n    float3 color = SAMPLE0(uv).rgb;\n\n    // calculate fragCoords\n    float2 fragCoords = frac(uv * iResolution.xy);\n    \n    // calculate which subpixel we are in\n    int i = int(fragCoords.x * 3.0);\n\n    float3 output_color;\n    float value;\n\n    // calculate 0.0 - 1.0 range for every subpixel\n    float a = frac(fragCoords.x * 3.0);\n    float b = fragCoords.y;\n    \n    \n    // output black if we are in-between sub pixels\n    if( a < HORZ_SPACING || a > (1.0-HORZ_SPACING) || b < VERT_SPACING || b > (1.0-VERT_SPACING) )\n        output_color = COLOR_BLACK;\n        \n    else {\n        switch(i) {\n        \n            // Map the given color channel to a color, so that brighter colors are more desaturated and brighter\n            \n            // RED\n            case 0: { float c = color.r; output_color = float3( min(1.0, 2.0*c),     max(0.0, 2.0*c-1.0), max(0.0, 2.0*c-1.0)); break; } \n            \n            // GREEN\n            case 1: { float c = color.g; output_color = float3( max(0.0, 2.0*c-1.0), min(1.0, 2.0*c),     max(0.0, 2.0*c-1.0)); break; }\n            \n            // BLUE\n            case 2: { float c = color.b; output_color = float3( max(0.0, 2.0*c-1.0), max(0.0, 2.0*c-1.0), min(1.0, 2.0*c)    ); break; }\n            \n            default: output_color = COLOR_WHITE; break; // This case should never be reached\n        };\n    }\n    \n\n    // Only apply the subpixel effect when reached a certain zoom level\n    float effect_amount = saturate((ZoomLevel-1.0) / (EFFECT_RANGE) - EFFECT_DROPOUT);\n    \n    return lerp(color, output_color, effect_amount);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float2 tc = fragCoord.xy / iResolution.xy;\n    \n    //float zoom = exp(iMouse.x/100.0); // control zoom with mouse X\n    float zoom = exp( (sin(iTime)+1.0) * 2.4 );\n\n\tfloat3 color = subpixel(tc, zoom);\n\tfragColor = float4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 11,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}