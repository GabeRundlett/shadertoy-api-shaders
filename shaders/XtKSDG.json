{
    "Shader": {
        "info": {
            "date": "1485713231",
            "description": "retro gradient color shape grid. procedural colors and patterns. Inspired by @pattern_artbot.",
            "flags": 0,
            "hasliked": 0,
            "id": "XtKSDG",
            "likes": 15,
            "name": "Shape Wave",
            "published": 3,
            "tags": [
                "2d",
                "retro",
                "gradient",
                "shapes",
                "tiles"
            ],
            "usePreview": 1,
            "username": "airtight",
            "viewed": 753
        },
        "renderpass": [
            {
                "code": "#define SHADOWS 0 // draw drop shadows\n#define MOUSE 0   // interactive (mouse move for distortion)\n\n#define PI 3.1415926535\n#define TWO_PI 6.28318530718\n\n#define shadowStr 0.04\n#define textureStr 0.10\n#define maxHueRange 0.8\n#define flipTime 6.\n\nfloat edge = 0.01;\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//returns 1 for inside circ, 0 for outside\nfloat circle(in vec2 _st, in vec2 pos, in float _radius){   \n    \n    vec2 dist = _st - pos;    \n\treturn 1. - smoothstep(_radius, _radius + edge, dot(dist,dist)*4.0);\n}\n\n//returns 1 for inside poly, 0 for outside\nfloat polygon(in vec2 _st, in vec2 pos,  in float _radius, in int _sides){\n    \n    _st -= pos; \n\n  \t// Angle and radius from the current pixel\n  \tfloat a = atan(_st.x,_st.y) + PI;\n  \tfloat r = TWO_PI/float(_sides);\n  \n  \t// Shaping function that modulate the distance\n  \tfloat d = cos(floor(.5+a/r)*r-a)*length(_st);\n    return 1.0-smoothstep(_radius,_radius + edge,d);\n\n}   \n\nvec2 rotate2D(vec2 position, float theta)\n{\n    mat2 m = mat2( cos(theta), -sin(theta), sin(theta), cos(theta) );\n    return m * position;\n}\n\nfloat random (vec2 st) { \n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat randomRange (in vec2 seed, in float min, in float max) {\n\t\treturn min + random(seed) * (max - min);\n}\n\nvec2 distort(in vec2 uv , float amount)\n{\n    //pixel displacement\n    \n    //move displacement map    \n    vec2 uv2 = uv + vec2(iTime/10.0);\n    \n    //offset texture sample posn\n    //with noise texture rb value    \n    uv += (texture(iChannel0, uv2).rb-vec2(.5))* amount;\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n                                              \n    //square aspect ratio, centered\n    vec2 uv = vec2( fragCoord.xy - 0.5*iResolution.xy ) / min(iResolution.x,iResolution.y);\n    \n    //new rnd every flipTime\n    float beat = floor(iTime/flipTime);\n    float rndTime = random(vec2(beat) + 3243.324);\n    \n    //0 - 1 within flipTime\n    float fracT = fract(iTime/flipTime);\n    \n    //randomize grid dims every 4 beats\n    float segments = randomRange(vec2(floor(iTime/flipTime/4.)),2.,6.);\n    \n    //mousemove   \n    vec2 mouse = iMouse.xy/iResolution.xy - 0.5;\n    \n\t#if MOUSE == 1\n    \t//shift\n        uv += mouse/3.;\n        //wobbz\n        uv.y = uv.y + sin(uv.x * 6. + iTime * 3. )*mouse.y/5.;\n        //distort\n        uv = distort(uv, mouse.x/10.);\n    \n    #endif\n\n    uv = rotate2D(uv,iTime/20.1);\n        \n    //slide alternate rows + columns\n    float rowId = floor(uv.y * segments );\n    float colId = floor(uv.x * segments );\n    \n    //slide shapes to beat\n    float slide = smoothstep(0.,0.9,fracT)/segments;\n    \n    if (mod(floor(iTime/flipTime),2.) == 0.){\n         uv.x += mod(rowId,2.) == 0. ? + slide : -slide;        \n    }else{\n         uv.y += mod(colId,2.) == 0. ? + slide : -slide;  \n    }\n    \n    //get a random shape for this tile\n    float tileRnd = random(floor(uv * segments ) * rndTime * 324324.234324);\n    int sides = int(floor(tileRnd * 3.) + 3.);\n    \n    //draw shape\n    float isShape = 0.;\n    \n    //random shape sizes\n    float tileRnd2 = random(floor(uv * segments ) * rndTime  );\n    float sizeRng = 0.4;\n    float radius = 0.27;\n    radius *= 1. + ((tileRnd2 - 0.5) * sizeRng);\n    \n    //grid\n    uv = fract( uv * segments);\n    \n    if (sides == 5){\n        //some circles\n        radius *= 1.25;\n        isShape = circle(uv, vec2(0.5), radius);\n    }else{\n        //make triangles smaller, and move down a tad\n        if (sides == 3){\n        \tradius *= 0.7;\n            uv.y += 0.08;\n    \t}\n    \tisShape = polygon(uv, vec2(0.5), radius, sides);\n    }\n                         \n    //hsl colors\n    //0-1 on both axes\n    vec2 st = fragCoord.xy / iResolution.xy;\n    float hueBck;//background hue\n    float hueShp;// shape hue\n    \n    //new gradients every beat\n    \n    //bkgnd gradient\n    float hstart = random(vec2(beat, 79834));\n    float hend = hstart + random(vec2(beat, 345))* maxHueRange - maxHueRange/2.; \n    \n    hueBck = mix(hstart,hend, st.y + iTime/6.); //simpler\n    \n    //shape gradient\n    hstart = random(vec2(beat, 6045.)) + tileRnd2/6.; //random hue offset    \n    hend = hstart + random(vec2(beat, 284))* maxHueRange  - maxHueRange/2.;\n    \n    hueShp = mix(hstart,hend, st.y + iTime/6.); \n    //use opposite hue?\n    //hueShp =  fract(1.0 - hueBck);\n    \n    //mix 2 hsls in rgb\n    vec3 colBkgnd =  hsv2rgb(vec3(hueBck, 0.4,0.8 * (st.y *0.5) + 0.5 )); //bkgnd\n    vec3 colShp =  hsv2rgb(vec3(hueShp, 0.4,0.9  )); //shape\n    \n    //drop shadows\n    #if SHADOWS == 1\n        float isShadow;\n        //offset\n        uv += vec2(0., -0.03);\n\n        if (sides == 5){\n            //circle\n            edge = 0.3;\n            radius = 0.3;\n            isShadow = circle(uv, vec2(0.5), radius);\n        }else{\n\t\t\t//tri or square\n             edge = 0.1;\n            isShadow = polygon(uv, vec2(0.5), radius, sides);\n        }\n        colBkgnd *= 1.0 - isShadow * shadowStr;\n    \n    #endif\n\n    //draw shapes\n    vec3 outCol = vec3(mix(colBkgnd, colShp, isShape));  \n    \n    //add noise \n    //display independent texture res\n    //256 for actual noise res, 200 for slightly blurred\n    outCol += (texture(iChannel0, st * iResolution.xy / 200. + iTime * 0.0).r - 0.5) * textureStr;\n    \n    fragColor = vec4(outCol,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}