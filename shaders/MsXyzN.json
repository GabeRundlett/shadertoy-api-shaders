{
    "Shader": {
        "info": {
            "date": "1566769600",
            "description": "I came up with the idea for this shader back in 2017 and finally got it finished. Watch in fullscreen to see all details. ",
            "flags": 0,
            "hasliked": 0,
            "id": "MsXyzN",
            "likes": 162,
            "name": "Frozen Lake",
            "published": 3,
            "tags": [
                "water",
                "ice",
                "snow",
                "lake",
                "winter",
                "frozen",
                "cracks"
            ],
            "usePreview": 1,
            "username": "TDM",
            "viewed": 5206
        },
        "renderpass": [
            {
                "code": "/*\n * \"Frozen Lake\" by Alexander Alekseev aka TDM - 2019\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: tdmaav@gmail.com\n */\n\n//#define LOW_END\n\nconst float THRESHOLD \t= 0.001;\nconst float EPSILON \t= 5e-3;\n\nconst float HEIGHT_POWER = 5.0;\nconst float CRACKS_SCALE = 0.6;\nconst float CRACKS_THICKNESS = 0.9;\nconst float CRACKS_ALPHA = 0.8;\nconst float REFRACTION = 0.8;\nconst float BUBBLES_BRIGHTNESS = 0.4;\nconst vec3 SNOW_COLOR = vec3(0.85,0.98,1.0);\nconst vec3 FOG_COLOR = vec3(0.0,0.04,0.05);\nconst vec3 DEEP_COLOR = vec3(0.0,0.12,0.2);\nconst vec3 CRACKS_COLOR = vec3(0.3,0.95,1.0) * 1.2;\nconst vec3 CRACKS_COLOR_TOP = vec3(1.6);\nconst vec3 MOUNTAINS_COLOR = vec3(0.04,0.02,0.0);\n\n// tracing\n\nfloat mapCracks1(vec3 p) {\n    const float SCALE = 0.1;\n    p.x += sin(p.z*0.2) * 2.0;\n    p.x += triangle(p.z * 0.053) * 2.0;\n    p.z += triangle(p.x * 0.103) * 2.0;\n    return voronoi(p.xz*SCALE).x / SCALE * 0.9;\n}\n\nfloat mapCracks2(vec3 p) {\n    const float SCALE = 0.25;\n    p.x += triangle(p.z * 0.153) * 1.5;\n    p.z += triangle(p.x * 0.203) * 1.5;\n    return voronoi(p.xz*SCALE).x / SCALE * 0.9;\n}\n\nvec2 traceCracks1(vec3 ori, vec3 dir, out vec3 p) {\n    float t = 0.0;\n    float d = 0.0;\n    for(int i = 0; i < 10; i++) {\n        p = ori + dir * t;\n        d = mapCracks1(p);\n        if(d < THRESHOLD) break;\n        t += d * 0.9;\n    } \n    return vec2(d,t);\n}\nvec2 traceCracks2(vec3 ori, vec3 dir, float s, out vec3 p) {\n    float t = 0.0;\n    float d = 0.0;\n    for(int i = 0; i < 8; i++) {\n        p = ori + dir * t;\n        d = mapCracks2(p*s);\n        if(d < THRESHOLD) break;\n        t += d * 0.9;\n    } \n    return vec2(d,t);\n}\nvec2 traceCracks3(vec3 ori, vec3 dir, out vec3 p) {\n    float t = 0.0;\n    float d = 0.0;\n    for(int i = 0; i < 3; i++) {\n        p = ori + dir * t;\n        d = mapCracks1(p*0.7);\n        if(d < THRESHOLD) break;\n        t += d;\n    } \n    return vec2(d,t);\n}\nvec2 getNormalCracks1(vec3 p) {\n    float t = mapCracks1(p);\n    vec2 n;\n    n.x = mapCracks1(vec3(p.x+EPSILON,p.y,p.z)) - t;\n    n.y = mapCracks1(vec3(p.x,p.y,p.z+EPSILON)) - t;\n    return normalize(n);\n}\nvec2 getNormalCracks2(vec3 p) {\n    float t = mapCracks2(p);\n    vec2 n;\n    n.x = mapCracks2(vec3(p.x+EPSILON,p.y,p.z)) - t;\n    n.y = mapCracks2(vec3(p.x,p.y,p.z+EPSILON)) - t;\n    return normalize(n);\n}\n\n// sky\nvec3 getSkyColor(vec3 e, bool isReflection) {\n    e.y = max(e.y,0.0);\n    float yy = pow(e.y, 0.9);\n    vec3 ret;\n    ret.x = pow(1.0-yy-0.05,8.0) * 0.75;\n    ret.y = pow(1.0-yy, 4.0) * 0.75;\n    ret.z = pow(1.0-yy,2.0);\n       \n    \n    float phi = atan(e.z,e.x) / PI;\n    float h = (fbm1(phi*10.0)*0.5+0.5)*0.14-0.03;\n    float mountains = isReflection ? \n        smoothstep(h+8.0*max(h,1e-5),h-0.01,e.y) :\n    \tsmoothstep(h+0.002,h,e.y);\n    ret = mix(ret,MOUNTAINS_COLOR,\n              mountains*(pow(e.y,0.3) * 0.15 + 0.85));\n    \n    h = (fbm1(phi*14.0)*0.5+0.5)*0.1-0.01;\n    float mf = isReflection ? \n        smoothstep(h+8.0*max(h,1e-5),h-0.01,e.y) :\n    \tsmoothstep(h+0.002,h,e.y);\n    ret = mix(ret,MOUNTAINS_COLOR,\n              mf*(pow(e.y,0.5) * 0.5 + 0.5)*0.8*(1.0-mountains));\n    \n    \n    // clouds\n    vec3 p;\n    intersectionPlane(vec3(0.0,300.0,0.0),e,p);\n    ret = mix(ret,vec3(1.0), fbmClouds(p.xz)*(1.0-mountains)*(1.0-mf) * 0.7);\n    \n    return ret;\n}\n\n// snow\n\nfloat getSnowWindMask(in vec2 p, float t) {\n    float amp = 0.5;\n    float frq = 1.0;\n    float wrt = t*2.0;\n    p.x += sin(frq*p.y + wrt*0.9) * amp;\n    p.y += cos(frq*p.x*1.5 + wrt*0.8) * amp;\n    p.x += sin(frq*p.y*1.9 + wrt*0.7) * amp;\n    p.y += cos(frq*p.x*1.7 + wrt*0.6) * amp;\n    \n    float wind = fbm2(p,t*8.0);\n    wind = wind * 0.5 + 0.5;\n    return wind * wind;\n}\n\nfloat getSnowMask(in vec2 p) {\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float a = 1.0;\n    float w = 1.0;\n    float f = noise12( p );\n    for(int i = 0; i < 6; i++) {\n        p = m * p; a /= 1.5;\n        f += a * (abs(noise12( p )));\n        w += a;\n    }\n    f /= w;\n    f = smoothstep(0.55,0.65,f);\n    f = pow(f,0.25);\n    f = f * 0.9;\n    \n#ifdef WIND\n    p *= 0.02;\n    p.x *= 0.5;\n    float wind = getSnowWindMask(p,iTime * 0.25);\n    wind = max(wind, getSnowWindMask(p,iTime * 0.25 + 1.5));\n    wind *= wind;\n    wind *= 0.5;    \n    return max(f, wind);\n#else\n    return f;\n#endif\n}\n\nvec3 getObjectColor(in vec3 p, const in vec3 cam, in vec3 e) {\n    vec3 op = p;\n    vec3 dir = e;\n    const vec3 n = vec3(0.0,1.0,0.0);\n    float depth = length(p - cam);\n    float depth_f = max(depth*0.8, 1.0);\n    p *= CRACKS_SCALE;\n    \n    \n    // global thickness modulation\n    float gth = 0.6 + 0.8 * smoothstep(0.2,0.8, noise13(p*0.05));    \n    gth *= CRACKS_THICKNESS;\n    \n    // crack depth\n    vec3 cp;\n    vec3 norm = vec3(1.0,noise2(p.xz*3.)*0.2);\n    norm.yz += noise2(p.xz*10.)*0.2;\n    norm.x *= depth_f;    \n    norm = normalize(norm.yxz);\n    e.xz += norm.xz * REFRACTION;\n        \n    traceCracks1(p,e,cp);\n    vec2 cr1_normal = getNormalCracks1(cp);\n    float crack_depth = abs(cp.y - p.y);\n    crack_depth = pow(max(1.0-crack_depth*0.2/gth, 0.0),HEIGHT_POWER) * 0.6;\n    crack_depth *= 0.5 + 0.5 * noise13(cp*vec3(0.7,10.0,0.7));\n    crack_depth *= abs(cr1_normal.x) * 0.6 + 0.4;\n    \n    traceCracks2(p,e,1.0,cp);\n    vec2 cr2_normal = getNormalCracks2(cp);\n    float crack_depth_2 = abs(cp.y - p.y);\n    crack_depth_2 = pow(max(1.0 - crack_depth_2 * 0.4/gth, 0.0), HEIGHT_POWER) * 0.6;\n    crack_depth_2 *= 0.5 + 0.5 * smoothstep(0.2,0.9, noise13(cp*vec3(12.0,1.0,12.0)));\n    crack_depth_2 *= 0.5 + 0.5 * noise13(cp*vec3(1.0,20.0,1.0));\n    crack_depth_2 *= abs(cr2_normal.x) * 0.6 + 0.4;\n    \n    traceCracks2(p,e,1.5,cp);\n    float crack_depth_3 = abs(cp.y - p.y);\n    crack_depth_3 = pow(max(1.0 - crack_depth_3 * 3.0/gth , 0.0), HEIGHT_POWER) * 0.3;\n    crack_depth_3 *= 0.5 + 0.5 * smoothstep(0.3,0.9, noise13(cp*vec3(17.0,1.0,17.0)));\n      \n    vec2 c4n = noise2(p.xz*30.0) * 0.4;\n    traceCracks3(p,e+c4n.xxy,cp);\n    float crack_depth_4 = abs(cp.y - p.y + 2.0);\n    crack_depth_4 = pow(max(1.0-crack_depth_4*0.2/gth, 0.0),3.0) * 0.15;\n    crack_depth_4 *= 0.5 + 0.5 * noise13(cp*vec3(0.7,10.0,0.7));\n    \n    \n    \n    // base color\n    vec3 col = toLinear(DEEP_COLOR);\n    \n    // bubbles    \n    dir.xz += norm.xz * REFRACTION * 0.3;\n    vec3 bp;\n    intersectionPlane(cam+vec3(0.,0.5,0.),dir,bp);        \n    col += pow(noise13(bp * 14.0),20.0) * BUBBLES_BRIGHTNESS * gth;\n    intersectionPlane(cam+vec3(0.,1.,0.),dir,bp);        \n    col += pow(noise13(bp * 15.0),20.0) * BUBBLES_BRIGHTNESS * gth;\n    intersectionPlane(cam+vec3(0.,2.,0.),dir,bp);        \n    col += pow(noise13(bp * 16.0),20.0) * BUBBLES_BRIGHTNESS * gth;\n    \n    // cracks color\n    vec3 crc = toLinear(CRACKS_COLOR);\n    vec3 crct = toLinear(CRACKS_COLOR_TOP);\n    float a = 0.4 + 0.6 * smoothstep(0.2,0.8, noise13(p*0.07));\n    a *= CRACKS_ALPHA;\n    #ifndef LOW_END\n    col = mix(col, mix(crc,crct,crack_depth_4), \n              crack_depth_4 * a);\n    #endif\n    col = mix(col, mix(crc,crct,crack_depth_3), \n              crack_depth_3 * a);\n    col = mix(col, mix(crc,crct,crack_depth_2), \n              crack_depth_2 * a);\n    col = mix(col, mix(crc,crct,crack_depth), \n              crack_depth * a);\n        \n    // reflection\n    float fresnel = pow(max(1.0 - dot(-e,n),0.0),5.0) * 0.9 + 0.1;\n    vec3 rdir = reflect(e,norm);\n    vec3 reflection = getSkyColor(rdir,true);\n   \n    col = mix(col,reflection,fresnel);\n    \n    // snow surface\n    depth_f = max(depth*0.01, 1.0);\n    float snow = getSnowMask(p.xz*0.1) / depth_f;\n    col = mix(col,SNOW_COLOR,snow);\n    return col;\n}\n\n\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 iuv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    vec2 uv = iuv;\n    uv.x *= iResolution.x / iResolution.y;    \n    vec2 mouse = iMouse.xy / iResolution.xy * 4.0 - 2.0;\n        \n    // ray\n    float xst = iTime * 0.3;\n    vec3 ori = vec3(sin(xst)*10.0,5.0,-iTime*5.0);\n    \n    vec3 ang = vec3(cos(xst+1.0)*0.1,PI*0.1, cos(xst)*0.4);\n    if(iMouse.z > 0.0) ang = vec3(0.0,clamp(2.0-iMouse.y*0.01,-0.3,PI),iMouse.x*0.01);\n\tmat3 rot = fromEuler(ang);\n    \n    vec3 dir = normalize(vec3(uv.xy,-1.5)); dir.z += length(uv) * 0.05;   \n    dir = normalize(dir * rot);\n             \n    // color\n    vec3 p;\n    vec3 color = getSkyColor(dir,false);\n    if(intersectionPlane(ori,dir,p))\n        color = getObjectColor(p,ori,dir);\n    \n    // post\n    //color *= 1.3;\n    color = pow(color,vec3(0.4545));\n    \n    // vignette\n    float vgn = smoothstep(1.2,0.5,abs(iuv.y)) * smoothstep(1.2,0.5,abs(iuv.x));\n    color *= vgn * 0.3 + 0.7;\n               \n\tfragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n * \"Frozen Lake\" by Alexander Alekseev aka TDM - 2019\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: tdmaav@gmail.com\n */\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nconst float PI = 3.141592;\n\nfloat saturate(float x) { return clamp(x,0.0,1.0); }\nfloat mul(vec2 x) { return x.x*x.y; }\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\n\nbool intersectionPlane(vec3 o, vec3 d, out vec3 p) {\n    float t = o.y / d.y;\n    p = o - d * t;\n    return bool(step(t,0.0));\n}\n\nfloat hash11(float x) {\n    return fract(sin(x) * 43758.5453);\n}\nfloat hash12( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nfloat hash13(in vec3 p) {\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\nfloat noise11(in float p) {\n    float i = floor( p );\n    float f = fract( p );\t\n\tfloat u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix(hash11(i),hash11(i+1.0),u);\n}\nfloat noise12( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\nvec2 noise2( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash22( i + vec2(0.0,0.0) ), \n                     hash22( i + vec2(1.0,0.0) ), u.x),\n                mix( hash22( i + vec2(0.0,1.0) ), \n                     hash22( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat noise13(in vec3 p) {\n    vec3 i = floor( p );\n    vec3 f = fract( p );\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    float a = hash13( i + vec3(0.0,0.0,0.0) );\n\tfloat b = hash13( i + vec3(1.0,0.0,0.0) );    \n    float c = hash13( i + vec3(0.0,1.0,0.0) );\n\tfloat d = hash13( i + vec3(1.0,1.0,0.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    a = hash13( i + vec3(0.0,0.0,1.0) );\n\tb = hash13( i + vec3(1.0,0.0,1.0) );    \n    c = hash13( i + vec3(0.0,1.0,1.0) );\n\td = hash13( i + vec3(1.0,1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return abs(mix(v1,v2,u.z));\n}\n\nfloat fbm1(in float p) {\n    float m = 2.0;\n    float a = 1.0;\n    float w = 1.0;\n    float f = noise11( p );\n    for(int i = 0; i < 8; i++) {\n        p *= m; a /= 1.8;\n        f += a*noise11( p );\n        w += a;\n    }\n    return f / w;\n}\n\nfloat fbm2(in vec2 p, float t) {\n    float m = 2.0;\n    float a = 1.0;\n    float w = 1.0;\n    float f = noise12( p );\n    for(int i = 0; i < 8; i++) {\n        p *= m; a /= 1.5;\n        f += a*noise12( p+t );\n        w += a;\n    }\n    return f / w;\n}\n\nvec2 fbm22(in vec2 p) {\n    float m = 2.0;\n    float a = 1.0;\n    float w = 1.0;\n    vec2 f = noise2( p );\n    for(int i = 0; i < 8; i++) {\n        p *= m; a /= 1.2;\n        f += a*noise2(p);\n        w += a;\n    }\n    return f / w;\n}\n\nfloat fbmClouds(in vec2 p) {\n    p *= 0.001;\n    float m = 2.0;\n    float a = 1.0;\n    float w = 1.0;\n    float f = noise12( p );\n    for(int i = 0; i < 4; i++) {\n        p *= m; a /= 1.5;\n        f += a* abs(noise12( p ));\n        w += a;\n    }\n    f /= w;\n    //f = pow(max(f,0.0001),5.0);\n    f = max((f - 0.4) / (1.0 - 0.4), 1e-4);\n    f = sqrt(f);\n    return f;\n}\n\n// iq's voronoi\nvec3 voronoi( in vec2 x ) {\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash22( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash22( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mr );\n}\n\nfloat triangle(float x) {\n\treturn abs(1.0 - mod(abs(x), 2.0)) * 2.0 - 1.0;\n}\n\n// gamma correction\nconst float GAMMA = 2.2;\nconst float iGAMMA = 1.0 / GAMMA;\nfloat toLinear(float c) { return pow(c,GAMMA); }\nvec2 toLinear(vec2 c) { return pow(c,vec2(GAMMA)); }\nvec3 toLinear(vec3 c) { return pow(c,vec3(GAMMA)); }\nfloat toSRGB(float c) { return pow(c,iGAMMA); }\nvec2 toSRGB(vec2 c) { return pow(c,vec2(iGAMMA)); }\nvec3 toSRGB(vec3 c) { return pow(c,vec3(iGAMMA)); }",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}