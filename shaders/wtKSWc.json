{
    "Shader": {
        "info": {
            "date": "1584533325",
            "description": "AA4-Shaders",
            "flags": 32,
            "hasliked": 0,
            "id": "wtKSWc",
            "likes": 2,
            "name": "AA4-Shaders",
            "published": 3,
            "tags": [
                "practica"
            ],
            "usePreview": 0,
            "username": "puajklejos",
            "viewed": 279
        },
        "renderpass": [
            {
                "code": "#ifndef CFG_NO_POSTPROD\n\nconst float kToneMapA =.15;\nconst float kToneMapB =.50;\nconst float kToneMapC =.10;\nconst float kToneMapD =.20;\nconst float kToneMapE =.02;\nconst float kToneMapF =.30;\nconst float kToneMapW =2.0;\n\n//  Operador de Tonemapping \"Filmic\".\n//\tEntradas:\tx - Color en el espacio RGB HDR.\n//\tSalida:\t\tColor resultante en el espacio RGB LDR.\nvec4 tonemap(vec4 x)\n{\n   return ( (x * (kToneMapA * x + kToneMapC * kToneMapB) + kToneMapD * kToneMapE)  /\n            (x * (kToneMapA * x + kToneMapB            ) + kToneMapD * kToneMapF)) -\n            kToneMapE / kToneMapF;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv  = fragCoord.xy / iResolution.xy;\n    \n    //PIXELADO\n    uv = floor(uv * 250.0) / 250.0;  //Hemos establecido que la imagen total hayan 250 pixeles.\n    \n    //NOISE\n    float strength = 10.0;\n    float x = (uv.x + 4.0 ) * (uv.y + 4.0 ) * (iTime * 10.0);\n    vec4 grain = vec4(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01) - 0.005) * strength;\n    \n    vec2 qv  = uv * 2. - 1.;\n    vec4 col = texture(iChannel0, uv);\n\tcol = tonemap(col) / tonemap(kToneMapW + .05 * textureLod(iChannel0, vec2(.5), 9.)); // Tonemapping.\n    col = col* (1./ pow(1. + pow(sqrt(dot(qv, qv)) * .3, 3.), 150.)); // Vignetting.\n    col = pow(col, vec4(1./2.2)); // Corrección Gamma.    \n    \n\tfragColor = col + grain;\n    \n    //fragColor = col;\n}\n\n#else\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n}\n#endif//CFG_NO_POSTPROD",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//==============================================================================\n//\tFUNCIONES DE DISTANCIA\n//==============================================================================\n\n//\tPrimitivas de ejemplo.\n//\tOtras primitivas disponibles en: https://iquilezles.org/articles/distfunctions y\n//\thttp://www.pouet.net/topic.php?which=7931&page=1\nfloat sdPlaneY(vec3 p) { return p.y; }\nfloat sdSphere(vec3 p, float s) { return length(p) - s; }\nfloat sdBox   (vec3 p, vec3  b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n//\tOperadores de ejemplo.\n//\tOtros operadores disponibles en: https://iquilezles.org/articles/distfunctions y\n//\thttp://mercury.sexy/hg_sdf/\nfloat opUnion       (float d1, float d2) { return min( d1, d2); }\nfloat opIntersection(float d1, float d2) { return max( d1, d2); }\nfloat opSubstraction(float d1, float d2) { return max(-d1, d2); }\nvec3  opRepetition  (vec3 pos, vec3 frq) { return mod(pos, frq) - 0.5 * frq; } \n\n//  Smooth minimum (polynomial smin())\n//  Ver https://iquilezles.org/articles/smin para más información.\nfloat opBlend(float d1, float d2, float k) \n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\n//==============================================================================\n//\tESCENA\n//==============================================================================\n\n#define MIN(dst, src) dst = mix(src, dst, step(dst.x, src.x))\nvec2 mapScene(vec3 pos)\n{\n    float t = iTime * 2.;\n    vec2  a = vec2(kFarPlaneDist, 0), b = a;\n    \n    // Creamos una caja para contener la escena.\n    b = vec2(opSubstraction(sdBox(pos, vec3(10)), sdBox(pos, vec3(100))), 0); MIN(a, b);\n    \n\t// Calculamos la distancia a 3 esferas unidas entre ellas de forma suave, una centrada y dos orbitando alrededor.\n\tfloat p0= opBlend(sdSphere(pos, 1.), sdSphere(pos + 2. * vec3(sin(t*.11), cos(t*.24), cos(t*.33)), 1.), 0.5);\n    p0 = opBlend(p0, sdSphere(pos + 1.5 * vec3(cos(t*.21), cos(t*.23), sin(t*.45)), 1.), 0.5);\n\n    // Restamos a dichas esferas un dominio de repetición de cubos en XY e YZ.\n    float p1= sdBox(opRepetition(pos, vec3(.25,0,.25)), vec3(5, 5, .015));\n    p1 = opUnion(p1, sdBox(opRepetition(pos, vec3(.25,0,.25)), vec3(.015, 5, 5)));\n\tb  = vec2(opIntersection(p0, p1), 1); MIN(a, b);\n    \n\treturn a;\n}\n\n//==============================================================================\n//\tTRAZADO DE RAYOS\n//==============================================================================\n\n//\tcastRay() traza un rayo con origen en \"ro\" en dirección \"rd\" desde el plano cercano kNearPlaneDist \n//  hasta encontrar una superficie contra la que chocar o hasta superar la distancia del plano lejano kFarPlaneDist.\n//\tEl rayo se mueve en pasos discretos hasta un máximo de kMaxSteps (lo que sirve para determinar la precisión).\n//\tEl rayo se desplaza a lo largo de un dominio de distancia: dada una posición en mundo (la del rayo), preguntamos\n//\ta la función mapScene(), que representa la escena, cuál es la distancia al objeto más cercano. Avanzamos entonces\n//\ten la dirección del rayo dicha distancia, y volvemos a preguntar hasta que se dé alguna de las condiciones\n//\tanteriormente indicadas.\n//\tEntradas:\tro - Origen del rayo.\n//\t\t\t\trd - Dirección del rayo.\n//\tSalida:\t\tvec4(totalDistance, lastStepDistance, materialID, steps). \n#ifndef CFG_USING_ENHANCED_RAYMARCHING\nvec4 castRay(vec3 ro, vec3 rd)\n{\n    float  t   = kNearPlaneDist;\n    vec2   res = vec2(kFarPlaneDist, 0);\n    int    i   = 0;\n    for (; i < kMaxSteps; ++i)\n    {\n\t    res    = mapScene(ro + rd * t);\n        if ((res.x < kEpsilon) || (t > kFarPlaneDist))\n            break;\n        t += res.x;\n    }\n    return vec4(t, res.xy, i);\n}\n#else// CFG_USING_ENHANCED_RAYMARCHING\nvec2  gTexelSize  ; // Pixel size   (screen domain).\nfloat gTexelRadius; // Pixel radius (screen domain).\n\nvec4 castRay(vec3 ro, vec3 rd)\n{\n\tgTexelSize    = 1. / iResolution.xy;\n\tgTexelRadius  = length(gTexelSize) ;\n    \n    float t   = kNearPlaneDist, stepLength = 0., prevRad = kFarPlaneDist, prevErr = kFarPlaneDist, err, k = 1.2;\n    vec2  res = vec2(kFarPlaneDist, 0);\n\tint   i   = kMaxSteps;\n    for (; (i >= 0) && (t < kFarPlaneDist); --i)\n    {\n        res = mapScene(ro + rd * t);\n        bool  sor = (k > 1.) && ((prevRad + res.x) < stepLength);\n        if (sor)\n        {//\tError detectado, deja de aplicar la optimización \"over-relaxation raymarching\".\n            stepLength-= k * stepLength;\n            k = 1.;            \n        }        \n        else\n            stepLength = res.x * k;\n\n        prevRad = res.x;\n        err = res.x / t;\n        if (!sor)\n        {// Actualiza el error.\n            if (err < prevErr     ) { res.x = t; prevErr = err; }\n            if (err < gTexelRadius) break; // Aplica \"screen-space aware intersection point selection\".\n        }\n        t  += stepLength;\n    }\n    return vec4(t, res.xy, kMaxSteps - i);\n}\n#endif//CFG_USING_ENHANCED_RAYMARCHING\n\n//==============================================================================\n//\tUTILIDADES\n//==============================================================================\n\n//\tCalcula el sombreado para la superficie. Para ello, traza un rayo desde la superficie hasta la luz, y determina\n//\tsi es posible llegar hasta la luz sin encontrar otra superficie antes. Si es posible llegar hasta la luz, el\n//\tpunto estará iluminado. En caso contrario, el punto estará sombreado.\n//\tAdemás, para cada paso del rayo computa la distancia mínima al objeto más cercano y utiliza ese valor para calcular\n//\tla penumbra.\n//\tMás información sobre el algoritmo en https://iquilezles.org/articles/rmshadows\n//\tEntradas:\tro   - Posición en mundo de la superficie.\n//\t\t\t\trd   - Dirección desde \"ro\" hasta la luz para la cual queremos calcular el sombreado.\n//\t\t\t\ttmin - Distancia desde \"ro\" hasta el inicio del rayo (evita arterfactos por precisión de flotante).\n//\t\t\t\ttmax - Distancia entre \"ro\" y la luz (permite descartar cuando llegamos a la luz).\n//\t\t\t\tk    - Factor de penumbra (cuanto más mayor, la sombra es más dura).\n//\tSalida: \tFactor de sombreado (0 para sombreado, 1 para iluminado, valores intermedios representan penumbra).\n#ifndef\tCFG_NO_SHADOWS\nfloat computeSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k)\n{\n    float res = 1.0;\n    float ph  = 1e20;\n    for( float t = tmin; t < tmax;)\n    {\n        float h = mapScene(ro + rd*t).x;\n        if( h < 0.001)\n            return 0.;\n        float y = h * h / (2. * ph);\n        float d = sqrt(h*h - y*y);\n        res = min(res, k*d / max(0.0,t - y));\n        ph  = h;\n        t  += h;\n    }\n    return res;\n}\n#else\nfloat computeSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k) { return 1.0; }\n#endif//CFG_NO_SHADOWS\n\n//\tCalcula la oclusión ambiental de la superficie. Para ello, muestrea a distintas distancias desde la posición en \n//\tmundo para la superficie, y calcula la oclusión ambiental aplicando un filtro de paso bajo: los valores de\n//  distancia obtenidos más cercanos a la superficie tienen más peso, y a medida que nos alejamos tienen menos.\n//\tEl proceso que se sigue es el siguiente:\n//\t\t- Para cada iteración, calcula una posición en mundo alejada de la superficie 1/N del total de muestras.\n//\t\t- Calcula la distancia desde esa posición a la superficie más cercana.\n//\t\t- Cuanto más cercana sea esa distancia a la distancia original entre la superficie de entrada y la calculada\n//\t\t  en la iteración actual, menos oclusión hay.\n//\tEntradas:\tpos\t- Posición en mundo para la superficie.\n//\t\t\t\tnor - Normal de la superficie.\n//\tSalida:\t\tFactor de oclusión (0 para totalmente ocluido, 1 para totalmente visible).\n#ifndef CFG_NO_AO\nfloat computeAO(vec3 pos, vec3 nor)\n{\n\tfloat  occ = 0.0;\n    float  sca = 1.0;\n    for( int i = 0; i < 5; ++i)\n    {\n        float hr = 0.01 + 0.12 * float(i) / 4.0;\n        vec3  aopos = nor * hr + pos;\n        float dd = mapScene(aopos).x;\n        occ += -(dd - hr) * sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 3.0*occ, 0.0, 1.0);    \n}\n#else\nfloat computeAO(vec3 pos, vec3 nor) { return 1.0; }\n#endif//CFG_NO_AO\n\n//  Calcula la normal de la superficie en \"pos\" mediante derivación del gradiente de la función de distancia.\n//\tEntradas:\tpos - Posición en mundo de la superficie.\n//\tSalida:\t\tVector normal de la superficie.\nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(kEpsilon, 0, 0);\n\treturn normalize(vec3(mapScene(pos + epsilon.xyy).x - mapScene(pos - epsilon.xyy).x, mapScene(pos + epsilon.yxy).x - mapScene(pos - epsilon.yxy).x, \n        mapScene(pos + epsilon.yyx).x - mapScene(pos - epsilon.yyx).x));\n}\n\n//\tcomputeCameraMatrix() calcula la matriz de cámara.\n//\tEntradas:\tro - Posición de la cámara (eye).\n//\t\t\t\tta - Posición en mundo a la que mira la cámara (lookAt).\n//\t\t\t\tcr - Rotación del vector front, de 0 a 2*π radianes.\n//\tSalida:\t\tMatriz de cámara.\nmat3 computeCameraMatrix(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3 (sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n    return mat3(cu, cv, cw);\n}\n\n//\tMateriales, luces y colores.\nvec3[] gMaterials  = vec3[](vec3(1, 0, 0), vec3( 1, 1,.9));\nvec3[] gLightPos   = vec3[](vec3(4, 4, 4), vec3(-4, 4,-4));\nvec3[] gLightCol   = vec3[](vec3(1,.9,.5), vec3(.5,.9, 1));\nvec3   gAmbientCol = vec3(.1,.2,.3);\n\n//\tcomputeShading() calcula la iluminación con difusa de Lambert y especular de Blinn-Phong.\n//\tEntradas:\tpos - Posición en mundo de la superficie.\n//\t\t\t\tnor - Normal de la superficie.\n//\t\t\t\tviewVector - Vector vista.\n//\t\t\t\tmatID      - Índice de material en gMaterials.\n//\t\t\t\tlightID    - Índice de luz en gLightPos y gLightCol.\n//  Salida:\t\tColor resultante.\nvec3 computeShading(vec3 pos, vec3 nor, vec3 viewVector, int matID, int lightID)\n{\n    //VARIABLES\n    float rough = 0.1;\n    float fres = 0.25;\n    float metalic = 0.0;    \n    \n\tvec3  col = vec3(0);\n    vec3 halfVec  = normalize(viewVector + normalize(gLightPos[lightID] - pos));\n\tcol = col + gLightCol[lightID] * gMaterials[matID] * clamp(dot(nor, normalize(gLightPos[lightID] - pos)), 0., 1.); // Cálculo de difusa.\n    //col = col + gLightCol[lightID] * gMaterials[matID] * clamp(dot(nor, -viewVector), 0., 1.); // Cálculo de difusa.\n\t//col = col + gLightCol[lightID] * pow(clamp(dot(nor, halfVec), 0., 1.), 5.); // Cálculo de especular.\n    \n\t//FRESNEL\n    //float FRESNEL = pow((fres + (1.0 - fres) * (1.0 - dot(nor,-viewVector))), 5.0); \n    float FRESNEL = fres + (1.0 - fres) * pow((1.0 - dot(viewVector, halfVec)), 5.0f);\n    \n    //G-GGX(v)  NO SE USA\n    //float roughCuadrado = pow(rough, 2.f);\n    //float NV = 2.0 * dot(nor, viewVector);\n    //float NVCuadrado = NV * NV;\n    //float G_GGX =  NV / (dot(nor, viewVector) + sqrt(roughCuadrado + (1.f - roughCuadrado) * pow(dot(nor,viewVector),2.0)));\n    \n    //G-implicit\n    float G_implicit = (dot(nor, gLightPos[lightID])) * (dot(nor,viewVector));\n    \n    //D-GGX(m)\n    float alphaPow = pow(rough,2.0); \n  \tfloat divisor = kPi * pow((((pow(dot(nor,halfVec),2.0)) * ((alphaPow - 1.0))) + 1.0),2.0); \n    float D_GGX = (alphaPow / divisor); \n    \n    /*float alphaPow = pow(rough, 2.0); \n  \tfloat divisor = kPi * pow((((pow(dot(nor,halfVec),2.0)) * ((alphaPow - 1.0))) + 1.0), 2.0); \n    float D_GGX = (alphaPow / divisor); */\n    \n    //BRDF\n    float MulFGD = (FRESNEL * G_implicit * D_GGX) / (4.f);\n    vec3 BRDF = col + gLightCol[lightID] * MulFGD;\n    \n    //return col;\n    return BRDF;\n}\n\n\n//==============================================================================\n//\tENTRYPOINT\n//==============================================================================\n\n//  Función principal.\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy; // Coordenadas UV en el rango [0,1].\n\tvec2 p  = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y; // Coordenadas UV en el rango [0,1] con Aspect Ratio aplicado.\n    \n    vec3 pos, nor, col; // Posición, normal, color.\n    vec4 res; // Resultados del trazado de rayos.\n\n\t// Configura la cámara.\n    vec3 ro = vec3(sin(iTime * .35) * (4. + sin(iTime)), 1, cos(iTime * .35) * (3. + cos(iTime)));\n    vec3 ta = vec3(0);\n    mat3 ca = computeCameraMatrix(ro, ta, 0.0);\n    vec3 rd = ca * normalize(vec3(p.xy,  2.0));\n    \n    // Traza el rayo y calcula la posición en mundo de la superficie impactada.\n    res = castRay(ro, rd);\n    pos = ro + rd * res.x;    \n    \n#\tifdef   CFG_USING_DISCONTINUITY_REDUCTION\n  \t// Aplica la optimización \"discontinuity reduction\" para mejorar la adaptación del espacio esférico al de pantalla.\n    float coneSize  = tan(kPi / 6.) / (iResolution.y);\n    float error     = 0.;\n    for (int  i = 0; i < 3; ++i)\n    {\n        pos    -= rd *    (error - mapScene(pos).x);\n        error   = coneSize * length(ro  - pos);\n    }\n#\tendif//\tCFG_USING_DISCONTINUITY_REDUCTION\n\n    // Calcula la normal.\n    nor = computeNormal(pos);\n    \n    // Para cada luz, computa la iluminación y el sombreado.\n    for (int i = 0; i < gLightPos.length(); ++i)\n    {\n\t\tcol+= computeShading(pos, nor, rd, int(res.z), i) * computeSoftShadow(pos, normalize(gLightPos[i] - pos), .025, length(gLightPos[i] - pos), 25.);\n    }\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    col = col + gAmbientCol * gMaterials[int(res.z)] * mix(computeAO(pos, nor), 1., dot(col, W));\n\n#   ifdef   CFG_SHOW_WORLDPOS\n    col = pos;\n#   endif// CFG_SHOW_WORLDPOS\n\n#   ifdef   CFG_SHOW_NORMALS\n    col = nor;\n#   endif// CFG_SHOW_NORMALS\n\n#   ifdef   CFG_SHOW_STEPS\n    col = mix(vec3(0, 1, 0), vec3(1, 0, 0), res.w / float(kMaxSteps));\n#   endif// CFG_SHOW_STEPS\n\n#   ifdef   CFG_SHOW_DISTANCE\n    col = vec3(res.x / (kFarPlaneDist - kNearPlaneDist));\n#   endif// CFG_SHOW_DISTANCE\n    \n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#ifndef CFG_NO_POSTPROD\n//\tFXAA (autor: Mudlord).\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2  p         = fragCoord.xy/iResolution.xy;\n    vec2  pp        = 1.0 / iResolution.xy;\n    vec4  color     = texture(iChannel0, vec2(fragCoord.xy * pp));\n    vec3  luma      = vec3(0.299, 0.587, 0.114);\n    float lumaNW    = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.,-1.)) * pp).xyz, luma);\n    float lumaNE    = dot(texture(iChannel0, (fragCoord.xy + vec2( 1.,-1.)) * pp).xyz, luma);\n    float lumaSW    = dot(texture(iChannel0, (fragCoord.xy + vec2(-1., 1.)) * pp).xyz, luma);\n    float lumaSE    = dot(texture(iChannel0, (fragCoord.xy + vec2( 1., 1.)) * pp).xyz, luma);\n    float lumaM     = dot(color.xyz, luma);\n    float lumaMin   = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax   = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2  dir       = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * (1.0/8.0)), (1.0/128.0));\n    float rcpDirMin = 2.5 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(8.0, 8.0), max(vec2(-8.0, -8.0), dir * rcpDirMin)) * pp;\n\n    vec3 rgbA = 0.5 * \n    (\n        texture(iChannel0, fragCoord.xy * pp + dir * (1. / 3. -.5)).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * (2. / 3. -.5)).xyz\n    );\n    vec3 rgbB = rgbA * 0.5 + 0.25 * \n    (\n        texture(iChannel0, fragCoord.xy * pp + dir *-.5).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * .5).xyz\n    );\n\n    float lumaB = dot(rgbB, luma);\n    fragColor = vec4((lumaB < lumaMin) || (lumaB > lumaMax) ? rgbA : rgbB, color.w);\n}\n#else\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n}\n#endif//CFG_NO_POSTPROD",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//==============================================================================\n//\tCONFIGURACIÓN\n//==============================================================================\n\n//\tCFG_USING_ENHANCED_RAYMARCHING utiliza una versión mejorada del algoritmo de trazado de rayos, que implementa\n//\tlas optimizaciones \"over-relaxation raymarching\" y \"screen-space aware intersection point selection\" descritas en\n//\tel paper \"Enhanced Sphere Tracing\" de Benjamin Kelinert et al. (http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf).\n\t#define CFG_USING_ENHANCED_RAYMARCHING\n\n//  CFG_USING_DISCONTINUITY_REDUCTION corrige el patrón esférico derivado de la discontinuidad entre el espacio de\n//\tpantalla (proyección 2D) y el espacio de mundo (posición del rayo y distancia a la superficie). Dicha discontinuidad\n//  aparece debido a la proyección del espacio esférico (que tiene profundidad) en el espacio de pantalla.\n//\tEl algoritmo está descrito en el mismo paper \"Enhanced Sphere Tracing\" indicado anteriormente.\n  \t#define CFG_USING_DISCONTINUITY_REDUCTION\n\n//#define CFG_SHOW_WORLDPOS\t// Descomentar para mostrar posiciones en mundo.\n//#define CFG_SHOW_NORMALS\t// Descomentar para mostrar normales.\n//#define CFG_SHOW_STEPS\t// Descomentar para mostrar pasos del Raymarcher.\n//#define CFG_SHOW_DISTANCE\t// Descomentar para mostrar distancias.\n//#define CFG_NO_SHADOWS    // Descomentar para desactivar las sombras.\n//#define CFG_NO_AO         // Descomentar para desactivar la oclusión ambiental.\n//#define CFG_NO_POSTPROD\t// Descomentar para desactivar los FX de post-producción.\n\nconst float kNearPlaneDist =   0.1;\t// Distancia al plano cercano.\nconst float kFarPlaneDist  =  50.0;\t// Distancia al plano lejano.\nconst float kEpsilon       = 0.001;\t// Valor de epsilon para comparaciones de distancia.\nconst float kPi\t\t\t   = 3.14159265359;\nconst int   kMaxSteps      =    64;\t// Número máximo de pasos del trazado de rayos.\nconst int   kMaxLightSteps =    16; // Número máximo de pasos del trazado de rayos de iluminación. ",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}