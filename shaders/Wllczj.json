{
    "Shader": {
        "info": {
            "date": "1627509864",
            "description": "a thing i made a while ago while playing with automatic differentiation",
            "flags": 0,
            "hasliked": 0,
            "id": "Wllczj",
            "likes": 4,
            "name": "trippy mandelbrot",
            "published": 3,
            "tags": [
                "fractal",
                "mandelbrot",
                "ad",
                "automaticdifferentiation"
            ],
            "usePreview": 0,
            "username": "unnick",
            "viewed": 303
        },
        "renderpass": [
            {
                "code": "#define res iResolution.xy\n#define tau 6.283\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec4 _mul(vec4 a, vec4 b) { //multiply 2 dual-complex numbers\n    return vec4(\n        cmul(a.xy, b.xy),\n        cmul(a.xy, b.zw) + cmul(a.zw, b.xy)\n        //(a.x*b.z + a.z*b.x) - (a.y*b.w + a.w*b.y),\n        //(a.x*b.w + a.z*b.y) + (a.y*b.z + a.w*b.x)\n    );\n}\n\nvec2 csqr(vec2 z) {\n    return vec2(z.x*z.x - z.y*z.y, 2.*z.x*z.y);\n}\n\nvec4 _sqr(vec4 z) {\n    return vec4(csqr(z.xy), cmul(z.zw, z.xy * 2.));\n}\n\nvec2 cinv(vec2 z) {\n    return z / dot(z,z) * vec2(1,-1);\n}\n\nvec4 _inv(vec4 z) {\n    return vec4(\n        cinv(z.xy),\n        cmul(z.zw, -cinv(cmul(z.xy, z.xy)))\n    );\n}\n\nvec2 cexp(vec2 z) {\n    return vec2(cos(z.y), sin(z.y)) * exp(z.x);\n}\n\nvec4 _exp(vec4 z) {\n    vec2 tmp = cexp(z.xy);\n    return vec4(tmp, cmul(z.zw, tmp));\n}\n\nvec4 _log(vec4 z) {\n    return vec4(\n        log(dot(z.xy,z.xy)) * .5,\n        atan(z.y,z.x),\n        cmul(z.zw, cinv(z.xy))\n    );\n}\n\n// i havent tested these (or maybe i have and i forgot, i probably made this before even the world event)\nvec4 _sin(vec4 z) {\n    return _mul((_exp(_mul(z, vec4(0,1,0,0))) - _exp(_mul(z, vec4(0,-1,0,0)))), vec4(0,-.5,0,0));\n}\n\nvec4 _cos(vec4 z) {\n    return (_exp(_mul(z, vec4(0,1,0,0))) + _exp(_mul(z, vec4(0,-1,0,0)))) * .5;\n}\n\nvec4 _tan(vec4 z) {\n    return _mul(_sin(z), _inv(_cos(z)));\n}\n\nvoid mainImage(out vec4 col, in vec2 coord) {\n    col = vec4(0);\n    for(int smpl = 0; smpl < 3; smpl++) {\n        vec4 c = vec4(((coord + fract(vec2(.754877, .56984) * float(smpl)) - .5) * 2. - res) / res.y, 1, 0);\n        c = c * exp(-iTime) + vec4(-1.7465226,0.0000280,0,0);\n        vec4 z = vec4(0);\n        int i;\n        // lcm(1,2...8) is better known for other properties\n        for(i = 0; i < 420; i++) {\n            if(dot(z.xy,z.xy) > 1e3) break;\n            z = _sqr(z) + c;\n        }\n        float l = dot(z.xy, z.xy);\n        vec2 dl = mat2(z.zw * vec2(1,-1), z.wz) * z.xy;\n        dl /= l;\n        l = log(l);\n        dl /= l*.5;\n        l = log(l*.5);\n        col.rgb += (sqrt(cos((log(length(dl)) * .3 + iTime - vec3(0,1,2)/3.) * tau) * .5 + .5));\n        \n        //i dont know what these comments are for\n        \n        //* (max(dot(normalize(vec3(cos(iTime*tau),sin(iTime*tau),1)), vec3(normalize(dl), 1.) * sqrt(.5)), 0.) * .6 + .4);\n        //col = vec4(float(i) / 1000.);\n    }\n    col /= 3.;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}