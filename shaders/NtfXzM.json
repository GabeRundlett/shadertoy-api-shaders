{
    "Shader": {
        "info": {
            "date": "1625314884",
            "description": "A way to render planets from dem texture (exemples in comment)\n\n   Earth:       https://www.ngdc.noaa.gov/mgg/global/\n   Planets:    https://astrogeology.usgs.gov/tools/map-a-planet-2",
            "flags": 32,
            "hasliked": 0,
            "id": "NtfXzM",
            "likes": 4,
            "name": "Fork Dem render firebreath 537",
            "published": 3,
            "tags": [
                "water",
                "planet",
                "ground"
            ],
            "usePreview": 0,
            "username": "firebreathz",
            "viewed": 340
        },
        "renderpass": [
            {
                "code": "// Created by sebastien durand - 04/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-------------------------------------------------------\n\n// Relief (low = big!) values : [2..20]\n#define H_COEFF 5.\n\n// With / Without water \n#define WITH_WATER\n\n#define WATER_OPACITY_COEFF 2.5\n#define WATER_OPACITY_INIT 1.\n\n#define WITH_MOUSE_CONTROL \n\n#define WITH_SHADOWS\n#define WITH_AO  // Good with a lot of rays but need multi pass\n#define NB_AO  4 // Reduce if slow\n\n\n// -------------------------------\n// DO NOT CHANGE\n// -------------------------------\n\n\n#define PI 3.14159265359\n\n#define NO_ID 0\n#define GROUND_ID 1\n#define DEEP_ID 2\n\n#define NO_INTERSECTION 9999.\n\n\n#define COLOR_BACK vec3(.42,.46,.48)\n#define COLOR_WATER vec3(.3, .12, .08) \n \nconst float dd = .02;     // ray step \n\n// ------------------------------------------------------------------------------\n\nint intersectSphere(vec3 ro, vec3 rd, float r, out float t1, out float t2) {\n    float b = dot(ro,rd), d = b*b - dot(ro,ro) + r*r;\n    if (d <= 0.) return -1;\n    t1 = -b-sqrt(d);\n    t2 = -2.*b-t1;\n    return t1 > 0. ? 1 : t2 > 0. ? 2 : 0;\n}\n\nvec3 toSpherical(vec3 p) {\n    float r = length(p);\n    return vec3(asin(p.z/r),               // lat\n                atan(p.y, p.x)+PI,         // lon\n                H_COEFF*(r-1.)); // alti (meters data)\n}\n\n// -------------------------------------------------------------------\n\nfloat hash1( float seed) {\n    return fract(sin(seed)*43758.545312);\n}\n\nvec2 hash2( float seed) {\n    return fract(sin(vec2(seed*43758.545312,(seed+.1)*22578.145912)));\n}\n\nfloat hash( const in vec3 p ) {\n    return fract(sin(dot(p,vec3(127.1,311.7,758.5453123)))*43758.5453123);\n}\n\n\nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture (iChannel0, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     iChannelResolution[0].xy);\n}\n\n// ------------------------------------------------------------------\n\nfloat altitudeMeter(vec3 p) {\n    vec3 s = toSpherical(p);\n    vec2 p2 = s.yx/PI;  // Lon, Lat, H in Grib\n    \n    // replace with your dem texture in EPSG:4326 projection\n    // ---------------------------------------------------\n    p2.y += 1.;\n    float h1 = (.9*texture(iChannel2, .5*p2).x + .5*texture(iChannel2, p2).x - .37 - mix(.5*texture(iChannel2, 4.*p2).x, .2, abs(p.z+p.x)));\n   \n    p.xyz = p.zxy;\n    s = toSpherical(p);\n    p2 = s.yx/PI;  // Lon, Lat, H in Grib\n    p2.y += 1.;\n  \n\tfloat h2 = (.9*texture(iChannel2, .5*p2).x + /*.5*texture(iChannel2, p2).x */-.2 - mix(.5*texture(iChannel2, 4.*p2).x, .2, abs(p.z+p.x)));\n    return 100.*mix(h1,h2, smoothstep(0.,1.,abs(p.x)));\n    // ---------------------------------------------------\n}\n\nfloat altitude(vec3 p) {\n    return H_COEFF*(length(p)-1.)-altitudeMeter(p)/100.;\n}\n\nvec3 normalAt( vec3 p) {\n    vec3 e = vec3 (.001, -.001, 0); \n    return normalize(e.xyy * altitude(p + e.xyy)\n                   + e.yyx * altitude(p + e.yyx)\n                   + e.yxy * altitude(p + e.yxy)\n                   + e.xxx * altitude(p + e.xxx));\n}\n\n// bisect\nfloat preciseSurfaceGround( vec3 ro,  vec3 rd, float dmin, float dmax) {\n    float dm = dmin;\n    vec3 p; \n    for (int j=0; j<6;j++) {\n        dm = (dmin + dmax)*.5;  \n        p = ro+rd*dm;\n        if (altitude(p) < 0.) dmax = dm;  \n        else dmin = dm;\n    }\n    return dm;  \n}\n\nvec2 rayGround(vec3 ro,  vec3 rd,  float dmin,  float dmax, out vec3 out_n, out float out_val) {\n    \n    float t1, t2;\n    // Test bounding sphere\n    int type = intersectSphere(ro, rd, .5/H_COEFF+1., t1, t2);\n    if (type > 0) {\n        dmin = max(dmin,t1);\n        dmax = min(dmax,t2);\n\n        // Go step by step until the ray traverse the ground\n        float d, h, rand = dd*hash1(dot(ro+rd*dmin,vec3(127.1,311.7,758.5453123)));\n        for(d = dmin+rand; d<dmax+dd; d += dd) {\n            h = altitude(ro+rd*d);\n            if (h <= 0.) break;\n        }\n\n        // Precise the true intersection point\n        if (d <= dmax) {\n            d = preciseSurfaceGround(ro, rd, max(dmin, d-dd), min(d,dmax));\n            out_n = normalAt(ro+rd*d);\t\t\t\t\n            out_val = altitude(ro+rd*d);\n            return vec2(d, GROUND_ID);\n        }\n    }\n\treturn vec2(NO_INTERSECTION, NO_ID);\n}\n\n\n#ifdef WITH_SHADOWS\nfloat doShadow( vec3 ro,  vec3 rd,  float dMax) {\n    vec3 n;\n    float val, dMin = dd*.1;\n    vec2 res = rayGround(ro, rd, dMin, dMax, n, val);\n    return res.x>dMin && res.x <= dMax ? 1. - clamp((dMax-res.x)/dMax,0.,1.) : 1.;\n}\n#endif\n\n\n#ifdef WITH_AO\nvec3 randomHemisphereDirection(vec3 n,  float seed) {\n    vec2 r = 2.*PI*hash2(seed);\n    vec3 dr = vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));\n    float k = dot(dr,n);\n    return k == 0. ? n : normalize(k*dr);\n}\n\nfloat doAmbiantOcclusion( vec3 ro,  vec3 n, float dMax) {\n    float val, ao = 0., seed = ro.x+ro.y+.12345*ro.z;\n    vec3 n2, rd;\n    vec2 res;\n    for (int i=0;i<NB_AO; i++){\n        rd = randomHemisphereDirection(n, seed);    \n        seed += .1;\n        res = rayGround(ro, rd, .03*dd, 1., n2, val);\n        if (int(res.y) != NO_ID && res.x > 0. && res.x < dMax) {\n            ao += clamp((dMax-res.x)/dMax,0.,1.);\n        }\n    }\n    return (1.-ao/float(NB_AO));\n}\n#endif\n\n\n// -----------------------------------------------------------------\n\n// Shading\nvec3 doShading(int id, vec3 rd, vec3 p, vec3 n, vec3 light,  vec3 col) { \n    float diffuse = max(0., dot(n, light)),\n          rimMatch =  1. - max( 0. , dot( n , -rd ) );\n    vec3 rimCol  = vec3 (.4,.6,1.)*rimMatch;\n\n    float occ = 1.;\n#ifdef WITH_AO\n    occ = doAmbiantOcclusion(p+n*.001/*.01*rd*dd*/, n, .08);\n#endif\n     \n    vec3 hal = normalize( light-rd );\n\tfloat \n        amb = clamp( .5, 0., 1. ),\n     \tdif = clamp( dot( n, light ), 0., 1. ),\n     \tbac = clamp( dot( n,-light), 0., 1. ),\n     \tfre = pow( clamp(1.0+dot(n,rd),0.,1.), 2. );\n        \n#ifdef WITH_SHADOWS\n    if (dif >0.) {\n        dif *= (doShadow(p-.2*rd*dd, light, .6));  \n    }\n#endif\n\n\tvec3 lin = vec3 (0.);\n    lin += .7*dif*vec3 (1.,.8,.55);\n    lin += .4*amb*vec3 (.4,.6,1.)*occ;\n    lin += .5*bac*vec3 (.25)*occ;\n    lin += .25*fre*vec3 (1)*occ;\n\n    float spe = max(0., dot(light, reflect(rd, n)));\n    spe = dif*pow(spe,29.);;              \n\n\tvec3 c = col*lin;\n\tc += (id==GROUND_ID?.1f:.5f)*spe;\n    c+= .2f * rimCol * occ;\n\n    return pow(c,vec3(.55f)); \t   \n}\n\n\n// Camera\nvec3 RD( vec3 ro, vec3 ta, vec3 up, vec2 uv, vec2 res, float h) {\n    vec2 p = (2.*uv-res)/res.y;\n    vec3 \n        w = normalize(ta - ro),\n        u = normalize(cross(w, up)),\n        v = normalize(cross(u,w));\n    return normalize( p.x*u + p.y*v + h*w );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 uv ) {\n    // Background\n    vec2 q = uv/iResolution.xy;\n    vec3 col = COLOR_BACK * pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y),.3f)\n    \t\t + .05*hash(vec3(q,1.));\n\n    // Camera\n#ifdef WITH_MOUSE_CONTROL\n    vec4 qtVu = Loadv4(1);\n    mat3 vuMat = QToRMat(qtVu);\n    vec3 rd = normalize (vec3((2.*uv-iResolution.xy)/iResolution.y, 3.5)) * vuMat,\n    \t ro = vec3 (0., 0., -4.5) * vuMat;\n#else\n\tvec3 ro = 4.5*normalize(vec3(cos(.5*iTime), sin(.5*iTime), .1*cos(.15*iTime))),\t\n         rd = RD(ro, vec3(0), vec3(1), uv, iResolution.xy, 3.5);\n#endif\n    // Light\n    vec3 n,p, lightDir = normalize(ro+vec3(0,10,10));\n\n    // Find intersection\n\tfloat val, tmax = 5.f;\n    vec2 res = rayGround(ro, rd, 0., tmax, n, val);\n\n    // Shading\n    if (res.x > 0. && res.x < NO_INTERSECTION) {\n       \n        if (int(res.y) == GROUND_ID) {\n            p = ro + res.x*rd;\n\t\t\tfloat h = altitudeMeter(p);\n \n            col = mix(.2*vec3(.6,.5,.4), texture(iChannel1, vec2(h/50.,.5)).xyz, .7);\n            col *= .8 +.3*hash(p); // a little bit dirty\n            col = pow(col, vec3(.7));\n\t\t\t\n#ifdef WITH_WATER\n            vec3 colw = texture(iChannel1, vec2(0)).xyz; \n            colw = colw*.25 + .75*exp(-COLOR_WATER*(-h*.002)); \n            col = mix(colw,col, smoothstep(-0.1,0.1,h));\n#endif\n            col = doShading(int(res.y), rd, p, n, lightDir, col);\n        }\n    }\n    \n#ifdef WITH_WATER\n\t// Add water effect\n\tfloat dminSea, dmaxSea;\n    if (intersectSphere(ro, rd, 1., dminSea, dmaxSea)>0) {\n        if (dminSea <= res.x) {\n            p = ro+rd*dminSea;\n            float dist = min(res.x,dmaxSea) - dminSea;\n            col = col * exp(-COLOR_WATER*(WATER_OPACITY_INIT + 20.*WATER_OPACITY_COEFF*dist));\n            n = normalize(p);\n            float specular = max(0., dot(lightDir, reflect(rd, n)));\n            specular = pow(specular,29.);\n            col += .4*specular;\n        }\n    }\n#endif\n\n    fragColor = vec4(col, 1.);\n}\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Mouse control\n//----------------------------------------------\n\nconst float pi = 3.14159;\n\n\nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture (iChannel0, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     iChannelResolution[0].xy);\n}\n/*\nvec4 QtMul(vec4 q1, vec4 q2) {\n    return vec4(cross(q1.xyz,q2.xyz) + q1.w*q2.xyz + q2.w*q1.xyz, q1.w*q2.w - dot(q1.xyz,q2.xyz));\n}\n*/\n\nvec4 QMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n     q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n     q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n   - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n   - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\n\nvec4 EulToQ (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\n\nvec4 qtVu;\n\n\nvec3 VInit (int n)\n{\n  float fn;\n  fn = float (n);\n  return 2. * normalize (vec3 (Hashff (fn), Hashff (fn + 0.3),\n     Hashff(fn + 0.6)) - 0.5);\n}\n\nvoid OrientVu (inout vec4 qtVu, vec4 mPtr, inout vec4 mPtrP, bool init)\n{\n  vec3 vq1, vq2;\n  vec2 dm;\n  float mFac;\n    \n  if (! init) {\n    qtVu = vec4 (0., 0., 0., 1.);\n    mPtrP = vec4 (99.,0., -1., 0.);\n      \n  } else {\n      \n    if (mPtr.z > 0.) {\n      if (mPtrP.x == 99.) mPtrP = mPtr;\n      mFac = 1.5;\n      dm = - mFac * mPtrP.xy;\n      vq1 = vec3 (dm, sqrt (max (1. - dot (dm, dm), 0.)));\n      dm = - mFac * mPtr.xy;\n      vq2 = vec3 (dm, sqrt (max (1. - dot (dm, dm), 0.)));\n      qtVu = normalize(QMul(vec4(cross (vq1, vq2), dot (vq1, vq2)), qtVu));\n      mPtrP = mPtr;\n    } else {\n        mPtrP = vec4 (99., 0., -1., 0.);\n    }\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat;\n  float tCur;\n  int pxId = int(fragCoord.x);\n \n  if (pxId > 2) discard;\n    \n  tCur = 5.*(1.+.5*sin(.5*iTime))+2.*iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n    \n  qtVu = Loadv4 (1);\n  mPtrP = Loadv4 (2);\n  \n  if (iFrame < 10) {\n    OrientVu(qtVu, mPtr, mPtrP, false);\n   \n  } else {\n      \n    OrientVu (qtVu, mPtr, mPtrP, true);\n    stDat = Loadv4(0);\n    ++stDat.x;\n      \n    if (mPtrP.z < 0.) \n        qtVu = normalize(QMul (EulToQ (0.2 * (tCur - stDat.z) * pi * vec3 (-0.27, -0.34, -0.11)), qtVu));\n      \n    stDat.z = tCur;\n  }\n\n  if (pxId == 1) stDat = qtVu;\n  else if (pxId == 2) stDat = mPtrP;\n        \n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nconst float txRow = 64.;\n\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi = float (idVar);\n  vec2 d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\n\nmat3 QToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define WAVES 8.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\n\tfloat time = iTime * 1.0;\n\t\n\tvec3 color = vec3(0.0);\n\n\tfor (float i=0.0; i<WAVES + 1.0; i++) {\n\t\tfloat freq = texture(iChannel0, vec2(i / WAVES, 0.0)).x * 7.0;\n\n\t\tvec2 p = vec2(uv);\n\n\t\tp.x += i * 0.04 + freq * 0.03;\n\t\tp.y += sin(p.x * 10.0 + time) * cos(p.x * 2.0) * freq * 0.2 * ((i + 1.0) / WAVES);\n\t\tfloat intensity = abs(0.01 / p.y) * clamp(freq, 0.35, 2.0);\n\t\tcolor += vec3(1.0 * intensity * (i / 5.0), 0.5 * intensity, 1.75 * intensity) * (3.0 / WAVES);\n\t}\n\n\tfragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 18,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}