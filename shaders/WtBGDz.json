{
    "Shader": {
        "info": {
            "date": "1559045494",
            "description": "Applying layering techniques to a distance field to produce some algorithmic vector art.",
            "flags": 0,
            "hasliked": 0,
            "id": "WtBGDz",
            "likes": 47,
            "name": "Algorithmic Vector Art",
            "published": 3,
            "tags": [
                "bubble",
                "truchet",
                "vector",
                "art",
                "render",
                "design",
                "style",
                "layer",
                "pipe"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1668
        },
        "renderpass": [
            {
                "code": "/*\n\n\tAlgorithmic Vector Art\n\t----------------------\n\n\tThis example focuses on applying layering techniques to a distance field.\n    Algorithmically speaking, there's nothing particularly new here -- I just \n    wanted to put something artsy together.\n\n\tBack in the math days, it used to be all about the theory. I still appreciate \n    the reasoning behind certain graphics routines, and still enjoy tweaking code \n\tto make things go faster. However, these days, my favorite part of the rendering\n\tprocess is the decorative side of things... It's not exactly my forte, but I\n\tenjoy it anyway. :)\n\n\tThis particular example is rendered in a sticker style, which is a vector \n\tgraphics cliche you'll see all over the place. I guess it's popular because it's\n\ttrivial to produce, but has decent visual impact. In essence, you render some\n\tthick (usually contrasting) outer layers, the main colored layer, and some\n\thighlighting. The latter is produced via some simple distance-field operation\n    trickery. It's also relatively cheap to produce as well, which helps.\n\n\tThe forground distance field is just some simple Truchet-based tiling, and the\n\tbackground is some overlapping shapes that are produced in a similar way to\n\tVoronoi -- None of which are difficult to code.\n\n\tThe code and comments were written from top to bottom without a lot of \n\tforethought, so I wouldn't take any of it too seriously. The main purpose was \n\tshow that it's possible to render realtime content in a lot of the static \n\tvector graphic styles that you see on the net.\n\n\n*/\n\n\n// I put this in as an afterthought. It didn't make the cut, but it's interesting. :)\n//#define LEAFY\n\n// A cooler look.\n//#define BLUE\n\n// Display the grid, in order to see the individual tiles.\n//#define SHOW_GRID\n\n// Remove the pipes in the foreground. Used for debug purposes, but I've left\n// it there for anyone who'd like to see the background only.\n//#define REMOVE_FOREGROUND\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\nfloat hash21(vec2 p){\n    \n    return fract(sin(dot(p, vec2(27.917, 57.543)))*43758.5453);\n}\n\n\nfloat dist(vec2 p, float rnd){\n    \n    \n    #ifdef LEAFY\n    // Leaves.\n    \n    \tp = rot2(6.2831*rnd + fract(rnd*57. + .37)*iTime/2.)*p;\n    \n        #if 1\n        // Leaf 1.\n        float r = length(p) + sqrt(abs(p.x/8.));\n        #else\n        // Leaf 2.\n        float r = pow(dot(pow(abs(p), vec2(2.)), vec2(1)), 1./2.) + abs(p.x);\n        #endif\n        return r/1.4142 - .0;\n    #else \n    // Bubbles -- Much simpler. :)\n        return length(p);\n\n    #endif\n    \n}\n\n\n// IQ's 2D signed box formula: I tried saving calculations by using the unsigned one, and\n// couldn't figure out why the edges and a few other things weren't working. It was because\n// functions that rely on signs require signed distance fields... Who would have guessed? :D\nfloat sBox(vec2 p, vec2 b){\n\n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// Pipe distance field pattern, consisting of three simply constructed Truchet tiles.\nvec2 PipePattern(vec2 p, float lw){\n    \n    // Distance field variables.\n    float d = 1e5, d2 = 1e5;\n    \n\n\tvec2 ip = floor(p); // Cell ID.\n    p -= ip + .5; // Cell's local position. Range [vec2(-.5), vec2(.5)].\n\n    \n    // Using the cell ID to generate some unique random numbers.\n    //\n    float rnd = hash21(ip + 12.53); // Cell type selection.\n    float rnd2 = hash21(ip); // Individual random tile flipping.\n\n \n    if(rnd2>.6){\n        \n        // Standard, double arc Truchet tile.\n        \n        // Random tile flipping.\n        p.y *= (rnd>.5)? -1. : 1.;\n\n        // Diagonal repeat symmetry, in order to draw two arcs with one call.\n        p = p.x>-p.y? p : -p;\n\n        // Creating two annuli at diagonal corners.\n        float dc = abs(length(p - .5) - .5);\n        d = min(d, dc);\n\n        // Without diagonal symmetry, you'd need to draw the other arc.\n        //dc = abs(length(p + .5) - .5);\n        //d = min(d, dc);\n        \n    }\n    else if(rnd2>.3){\n        \n        \n        // A single line running down the middle of the tile, with dots on\n        // the two remaining edges.\n        \n        // Random tile flipping.\n        p = (fract(rnd*151. + .76)>.5)? p.yx : p;\n\n        // Line.\n        d = min(d, sBox(p, vec2(0, .5)));\n\n        // Two dots.\n        p.x = abs(p.x); // Repeat trick.\n        d = min(d, length(p - vec2(.5, 0)));            \n        \n    }\n    else {\n\n        // Cross over lines. This necessitates two distance fields, since \n        // there is rendering order to consider. This tile by itself would\n        // create a weave pattern.\n        \n        // Random tile flipping.\n        p = (fract(rnd*57. + .34)>.5)? p.yx : p;\n        \n        // Verticle line.\n        d = min(d, sBox(p, vec2(0, .5)));\n        // Horizontal line.\n        d2 = min(d2, sBox(p, vec2(.5, 0)));\n       \n    }\n\n \n    // Field width, or giving the pipe pattern some width.\n    d -= lw/2.;\n    d2 -= lw/2.;\n \n   \n    return vec2(d, d2);\n    \n    \n}\n\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(41, 289)));\n    //return fract(vec2(262144, 32768)*n)*2. - 1.; \n    \n    // Animated.\n    p = fract(vec2(262144, 32768)*n);\n    return sin(p*6.2831853 + iTime); \n    \n}\n\n\n// Based on IQ's gradient noise formula.\nfloat n2D3G( in vec2 p ){\n   \n    vec2 i = floor(p); p -= i;\n    \n    vec4 v;\n    v.x = dot(hash22(i), p);\n    v.y = dot(hash22(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22(i + 1.), p - 1.);\n\n#if 1\n    // Quintic interpolation.\n    p = p*p*p*(p*(p*6. - 15.) + 10.);\n#else\n    // Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n#endif\n\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n}\n\n\n// Smooth fract function.\nfloat sFract(float x, float sf){\n    \n    x = fract(x);\n    return min(x, (1. - x)*x*sf);\n    \n}\n\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\n//float fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\n\n// The grungey texture -- Kind of modelled off of the metallic Shaderto texture,\n// but not really. Most of it was made up on the spot, so probably isn't worth \n// commenting. However, for the most part, is just a mixture of colors using \n// noise variables.\nvec3 GrungeTex(vec2 p){\n    \n \t// Some fBm noise.\n    //float c = n2D(p*4.)*.66 + n2D(p*8.)*.34;\n    float c = n2D(p*3.)*.57 + n2D(p*7.)*.28 + n2D(p*15.)*.15;\n   \n    // Noisey bluish red color mix.\n    vec3 col = mix(vec3(.25, .1, .02), vec3(.35, .5, .65), c);\n    // Running slightly stretched fine noise over the top.\n    col *= n2D(p*vec2(150., 350.))*.5 + .5; \n    \n    // Using a smooth fract formula to provide some splotchiness... Is that a word? :)\n    col = mix(col, col*vec3(.75, .95, 1.2), sFract(c*4., 12.));\n    col = mix(col, col*vec3(1.2, 1, .8)*.8, sFract(c*5. + .35, 12.)*.5);\n    \n    // More noise and fract tweaking.\n    c = n2D(p*8. + .5)*.7 + n2D(p*18. + .5)*.3;\n    c = c*.7 + sFract(c*5., 16.)*.3;\n    col = mix(col*.6, col*1.4, c);\n    \n    // Clamping to a zero to one range.\n    return clamp(col, 0., 1.);\n    \n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/min(800., iResolution.y);\n    \n    // Scaling and translation.\n    float gSc = 5.;\n    vec2 p = uv*gSc + vec2(.5, 0)*iTime;\n    // Rotation, for something different.\n    //vec2 p = rot2(3.14159/6.)*(uv*gSc + vec2(.5, 0)*iTime);\n    \n    vec2 oP = p;\n    \n        // Line width and edge width.\n    const float lw = .425;\n    const float ew = .04;\n    // Smoothstepping factor.    \n    float sf = 1./iResolution.y*gSc;    \n      \n    // Three instances of the pipe pattern: The pattern itself, one for the \n    // shadow and another for some highlighting.\n    vec2 df = PipePattern(p, lw);\n    vec2 dfSh = PipePattern(p - vec2(-.03, -.05)*2., lw);\n    vec2 dfHi = PipePattern(p - vec2(.03, .05)*1.1, lw); \n\n     \n    // Two textures. One that matches the pipe movement, and a static one for the background.\n    //\n    // Background texture.\n    vec3 tx = GrungeTex(uv*1. + .5);\n    tx = smoothstep(-.1, .5, tx);\n    tx = mix(tx, vec3(1)*dot(tx, vec3(.299, .587, .114)), .75);\n    tx *= vec3(1, .9, .8);\n    //\n    // Used on the pipe colored layer... A bit wasteful, but this isn't a taxing example.\n    vec3 tx2 = GrungeTex(p/gSc*1. + .5);\n    tx2 = smoothstep(-.1, .5, tx2);\n    tx2 = mix(tx2, vec3(1)*dot(tx2, vec3(.299, .587, .114)), .75);\n    tx2 *= vec3(1, .9, .8);\n\n    // Pipe color.\n    vec3 lCol = tx2*2.2*vec3(1, .05, .3);\n    lCol = mix(lCol, lCol.xzy, uv.y*.25 + .25);\n    //\n    // Outer stroke color. White is simpler, but you could try things like vec3(1, .8, .6), ETC.\n    vec3 outerCol = vec3(1);\n\n    \n    \n    #ifdef LEAFY\n    // Autumn leaves.\n    lCol = mix(lCol.yxz, lCol, uv.y*.25 + .75);\n    lCol = mix(lCol, vec3(1)*dot(lCol, vec3(.299, .587, .114)), .5);\n    #endif\n    \n     \n \n///////   \n    \n    vec3 bg = max(max(tx.x, tx.y), tx.z)*vec3(1);\n    //vec3 bg = = dot(tx, vec3(.299, .587, .114))*vec3(1);\n\n    \n    // Initiate the scene color to the background.\n    vec3 col = bg;\n    \n    \n    #ifdef LEAFY\n    // Brown background.\n    col = (tx*2.2*vec3(.8, .6, .45)*.5);\n    col = mix(col, col.xzy, uv.y*.25 + .25);\n    col = mix(col, col.yxz, .15);\n    #endif\n    \n    \n    // BACKGROUND LAYER RENDERING.\n    \n    // The background bubbles: I made it up as I went along, but in essence, it's\n    // just a few layers, and algorithmically similar to a Voronoi routine.\n    float cir = 1e5, cirHi = 1e5, cirSh = 1e5;\n    \n    const float sc = 3.5; // Object scale.\n    \n    // Grey color.\n    vec3 gr = dot(tx, vec3(.299, .587, .114))*vec3(1.5);\n    // Colored layer. Pink, in this case.\n    vec3 co = (tx*2.2*vec3(1, .05, .3));\n    co = mix(co, co.xzy, uv.y*.25 + .25);\n    \n    for(int j = 3; j>=-3; j--){ // Top to bottom rendering, for the 3D distance look.\n        for(int i = 3; i>=-3; i--){ // Right to left.\n            \n            vec2 s = uv*gSc*sc - vec2(1., .5)*iTime;\n            \n            \n            vec2 is = floor(s + vec2(i, j)); // Cell ID.\n            s -= is + .5; // Cell coordinates.\n            if(mod(is.x, 2.)>.5) s.y += .5; // Staggered hexagon-like scale look.\n            \n            vec2 ofs = vec2(hash21(is + 4.33), hash21(is + 1.57)) - .5;\n            ofs = sin(ofs*6.2831 + vec2(1.57, 0) + iTime/2.);\n            \n            // Random object size.\n            float sz = .15 + hash21(is + 4.52)*.45;\n            \n            // Shadow layer.\n            cirSh = dist(s + ofs + vec2(.03, .05)*sc, hash21(is + 7.38)) - sz;\n            // Normal layer.\n            cir = dist(s + ofs, hash21(is + 7.38)) - sz; \n            // Highlighting layer.\n            cirHi = dist(s + ofs - vec2(.03, .05)*1.1*sc, hash21(is + 7.38)) - sz;\n            cirHi = max(cirHi, cir - ew*.5*sc); \n            \n            // Set the object to a grey color, and a random few pink... What a mess. \n            // You can safely ignore the code. :)\n            vec3 bCol = gr;\n            #ifndef LEAFY\n            if(hash21(is + 4.63)>.85) {\n            #endif\n                bCol = co;\n            #ifndef LEAFY\n            }\n            #endif\n            \n            #ifdef LEAFY\n            // Autumn leaves.\n            bCol = mix(bCol.yxz, bCol, .5 + hash21(is)*.3);\n            #endif\n            \n            // Blue.\n            //bCol = mix(bCol.zxy, bCol.zyx, -uv.y*.25 + .75);\n    \n                \n            // The layers: Shadow, strokes, coloring, and highlighting.\n            col = mix(col, vec3(0), (1. - smoothstep(0., sf*sc*4., cirSh - ew*6.))*.5);\n            col = mix(col, outerCol, (1. - smoothstep(0., sf*sc, cir - ew*5.))*.9);\n            col = mix(col, vec3(0), (1. - smoothstep(0., sf*sc, cir - ew*2.))*.95);\n    \t\tcol = mix(col, bCol, (1. - smoothstep(0., sf*sc, cir + ew)));\n            col = mix(col, bCol/2., (1. - smoothstep(0., sf*sc, cirHi + ew*1.3*sc))*.95);\n            col = mix(col, vec3(1), (1. - smoothstep(0., sf*sc, cirHi + ew*2.3*sc))*.75);\n        }\n    }\n    \n    \n    #ifdef REMOVE_FOREGROUND\n    // Saving the background.\n    vec3 bgCol = col;\n    #endif\n    \n   \n    \n  \n    // FOREGROUND LAYER RENDERING.\n  \n    // Bottom layer: Shadows, strokes, color, and highlighting.\n    // The distance field trickery is due to the fact that rendering order needs\n    // to be considered. \n    col = mix(col, vec3(0),  (1. - smoothstep(0., sf*4., min(dfSh.x, dfSh.y) - ew*1.5))*.75);\n    col = mix(col, outerCol, (1. - smoothstep(0., sf, df.x)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, df.x + ew*1.5)));\n    col = mix(col, lCol,  (1. - smoothstep(0., sf, df.x + ew*3.5)));\n    float dHiX = min(dfHi.x, dfHi.y); dHiX = max(dHiX, df.x - ew*.5); \n    col = mix(col, lCol/2.,  (1. - smoothstep(0., sf, dHiX + ew*3.8))*.95);\n    col = mix(col, vec3(1),  (1. - smoothstep(0., sf, dHiX + ew*4.8))*.95);\n     \n\t// Top layer.\n    // ew*1.5 is extra shadow width.\n    float dShY = max(dfSh.y, max(dfSh.x - ew*1.5, df.x + ew*1.5)); \n    col = mix(col, vec3(0),  (1. - smoothstep(0., sf*4., dShY - ew*1.5))*.75);\n \tcol = mix(col, outerCol, (1. - smoothstep(0., sf, df.y)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, df.y + ew*1.5)));\n    col = mix(col, lCol,  (1. - smoothstep(0., sf, df.y + ew*3.5)));    \n    \n    // Hack, to fix the shadow lines that appear at the grid joins. Comment it out to\n    // see a visual explanation.\n    float dHiY = min(dfHi.y,  max(dfHi.x, -(df.x)));//df.x+ew*1.5\n    dHiY = max(dHiY, df.y - ew*.5); \n\tcol = mix(col, lCol/2.,  (1. - smoothstep(0., sf, dHiY + ew*3.8))*.95);\n\tcol = mix(col, vec3(1),  (1. - smoothstep(0., sf, dHiY + ew*4.8))*.95);\n    \n\n\n    #ifdef SHOW_GRID\n    // GRID.\n    vec2 ip = floor(p); // Cell ID.\n    p -= ip + .5; // Cell's local position. Range [vec2(-.5), vec2(.5)].\n    float grid = max(abs(p.x), abs(p.y)) - .5;\n    grid = abs(grid) - ew/4.;\n    //col = mix(col, vec3(1),  (1. - smoothstep(0., sf, grid - ew)));\n\tcol = mix(col, vec3(1, .9, .8),  (1. - smoothstep(0., sf, grid - ew/1.5))*.65);\n\tcol = mix(col, vec3(0),  (1. - smoothstep(0., sf, grid)));\n\t#endif\n    \n    \n    // Cheap paper grain.\n    //vec3 rn3 = vec3(hash21(oP), hash21(oP + 2.37), hash21(oP + 4.83));\n    //col *= .7 + .3*rn3.xyz  + .3*rn3.xxx;\n\t \n    \n    // Fake 8-bit color style.\n    //col = floor(col*7.999)/7.;\n    \n    \n    #ifdef REMOVE_FOREGROUND\n    // Just the background.\n    col = bgCol;\n    #endif\n    \n    \n    #ifdef BLUE\n    // Blue.\n    col = mix(col.zxy, col.zyx, -uv.y*.25 + .75);\n    #endif\n     \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625);\n    // Colored variation.\n    //col = mix(col.zyx, col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625));\n    \n     \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}