{
    "Shader": {
        "info": {
            "date": "1541207270",
            "description": "drag mouse to set 2 boxes.\n\nparent: \nhttps://www.shadertoy.com/view/ltdBWj\n\nautomatically composes offset sheet musics, with alignment and hull-kerning",
            "flags": 0,
            "hasliked": 0,
            "id": "Xl3fWf",
            "likes": 3,
            "name": "starguitar7,audiovisual kerning",
            "published": 3,
            "tags": [
                "intersect",
                "synthesis",
                "aperiodic",
                "culling",
                "aabv",
                "kerning",
                "starguitar",
                "quadraticfield",
                "hash41",
                "nancarrow"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 828
        },
        "renderpass": [
            {
                "code": "void mainImage(out ve3 o,ve1 u\n){o=entryImage(iTime,u,iResolution,iMouse)\n ;}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//self  : https://www.shadertoy.com/view/Xl3fWf\n//parent: https://www.shadertoy.com/view/ltdBWj\n//parent: https://www.shadertoy.com/view/XlcBDj\n//parent: https://www.shadertoy.com/view/lldfDB\n//parent: https://www.shadertoy.com/view/MttfWB\n//kerning, synthesis, aperiodic, culling, aabv, starguitar, quadraticfield, hash41, nancarrow,intersect\n\n/*\ndrag mouse to set blue boxes  (starguitar 5,7 fold to 1d)\n- source is 2 blue boxes, that either\n- - contain another\n- - intersect\n- - are seperate\n- target is 1 yellow box; iff(not seperate) return AABV; else return box that is closer to uv.\n- - composites of all red boxes become a hull-curve, that auto-merge where they overlap\n\niMouse.xz set centers of 2 boxes\niMouse.zw set 2 halfwidths of 2 boxes\ncan be represented as triangles (red and green)\n, where imouse.xy sets +one triangle top\n, where imouse.zw sets +one triangle top\nline intersections (2 o 3 yellow dots) equate box intersections\n//if (bottom intersection.y<=0) the boxes intersect ([<=] for closedInterval, [<] for openInterval boxes)\n//top intersection.xy sets an AABV upper bound of both boxes\n\nIt alway bugged me how to define midi sheets, but also as distance field.x\n, where a note stops and another note starts, often at the same moment\nthis is a min() of 2 notes, that may or may not be the same single long note.\nthe whole .y domain is only relevant for visualization here.\nin a \nhttps://www.shadertoy.com/results?query=starguitar\nshader the .y domain will be \"frequency\" or \"keyboard key\" == frequency, scaled by a note key using;\nhttps://www.shadertoy.com/view/4ttBD4\n*/\n\n/*\nassume uv.x to be time\nassume uv.y to be frequency (piano key id)\n\nblue is a usual distance field, for now only rectangles are defined with this the \"starguitar\" extension\n- bright blue  means negative distance to a box surface\n- bright green means \"-(green) more iTime till first note starts\" (it counts up)\n\ngreen or red only measure Distance.x\ngreen is the (negative) distance to the nearest box to the right.\nred   is the (negative) distance to the nearest box to the left.\n\nuv.xy taps one point in time for one freuency. if its blue, there is a note played at iTime.x\n- green == how long this note has been played (till iTime == now)\n- red   == how long till this note ends       (till iTime == now) //not needed for pluck/percussion instruments\n\nred and green are negated (!)\n- to avoid overlap, when using the same fract() or smin() functions as for \"blue\"\n- to make the inherent (parallel projection) frustrum culling debugging easier.\n\nand only an min() union is defined, that was tricky enough\n- any break between 2 notes will appear yellow (or black with negateRG)\n- , this the negative-color of the note in terms of duration.\nred and green are negated to use the same smin() function to make them visible\n, without overlapping too much.\n*/\n\n//invert redGreen\n//#define negateRG\n\n//alternative color sceme fallof; *=1.-log(abs())\n#define showGradLog\n\n/*\n\"starguitar\" defines shapes, where .w is the usual distance field as in the hg_sdf collection\nwhile .xy define center and (half)length of a note\nthe min() max() mixing cases for this had to be debugged in here\nbecause there are multiple different ways to bound this.\n\na possible extension to this, with derivatives, may even generate\nhttps://www.youtube.com/watch?v=4t0jDUQ2aJ4\nhttps://www.youtube.com/watch?v=RIz3klPET3o\nhttps://www.youtube.com/watch?v=XJpVbUICUb4\nbut procedurally\n*/\n\n\n\n#define vec1 float\n#define pi acos(-1.)\n#define tau pi*2.\n//float tau=6.2831853071795864769252867665590057683943387987502116419;//trig definition can be better for smarter compilers.\n#define eul 2.7182818284590452353602874713526624977572470936999595749\n//eul=exp(1.)???\n//\"goldenRatio\"=phi+1=Phi :where: 1/phi=phi-1&&1/Phi=Phi-1\n//https://en.wikipedia.org/wiki/Golden_ratio\n#define phi (sqrt(5.)*.5-.5)\n//goldenRatio is great fun with fract(),good for hashes.\n#define Phi (sqrt(5.)*.5+.5)\n#define sat(x)clamp(x,0.,1.)\n#define dd(a)dot(a,a)\n#define u5(a)((a)*.5+.5)\n#define u2(a)((a)*2.-1.)\n//#define ss(a,u)smoothstep(a,-a,u)//bad namespace for this,more trouble than its worth\nvec1 suv(vec4 a){return dot(vec4(1),a);}vec1 suv(vec3 a){return dot(vec3(1),a);}vec1 suv(vec2 a){return a.x+a.y;}//sum of vector\n#define minx(a,b)mix(b,a,step(a.x,b.x))\n#define manx(a,b)mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b)-minx(-a,-b)\n\n\n//2d zoom\n#define ViewZoom 8.\n//divide by/aa for hairline drawing and sharp smoothstep()\n#define Aa(r) (min(r.x,r.y)/ViewZoom)\n#define fra(t,u,r,m)(u-.5*r.xy)*ViewZoom/r.y\n\n//array indexing srarts at 0 within chinese remainders.\n#define ve0 float\n#define ve1 vec2\n#define ve2 vec3\n#define ve3 vec4\n\nve0 ma(ve1 a){return max(a.x,a.y);}\n\n#define inf 99999.\n\n#define tiny 0.0001\n    \nvec2 gLLxX(vec2 A,vec2 B,vec2 C,vec2 D//get intersection of line[a,b] and line[c,d]\n){vec2 b=B-A,d=D-C,c=C-A\n ;float dotperp=b.x*d.y-b.y*d.x\n ;dotperp=max(abs(dotperp),tiny)*sign(dotperp)//jumps from -tiny to +tiny, lazy 0-avoidance, lines are never parallel!\n ;float t=(c.x*d.y-c.y*d.x)/dotperp\n ;return vec2(A.x+t*b.x,A.y+t*b.y);}//http://wiki.secondlife.com/wiki/Geometric\n//return distance to [wedge.rounded.circle],circle/IniniteLineSegment end at m.xy,the other line is horizontal.\n\n#define ls2(a,c) dd((a-(c*sat((dot(a,c)/dd(c))))))\n//sqared orthogonal projection ,ls()sub ,is squared distance\n#define ls(a,b,c) sqrt(ls2((a-b),(c-b)))\n//pointAdistance to (diagonal) lineSegment from B to C\n\nvec4 gLLxXnp(vec4 n//return 2 intersections of 4 diagonals (2x 2d pyramid tips)\n){return vec4(vec2(n.x-n.y,0)-( n.x-n.y-n.z-n.w)*.5\n             ,vec2(n.z-n.w,0)-(-n.x-n.y+n.z-n.w)*.5);}//very sopecial lineLine intersection case.\n\n//skeletons and intervals:\n//vec2 interval=vec2(start,end)    , assumes startyend     , otherwise resersd\n//vec2 skeleton=vec2(center,width) , assumes positive width, otherwise resersd\n//i2s() or a2i() to NOT sort outputs, but maintain the reversed-state.\nvec2 i2s(vec2 a){return (a.y+vec2(1,-1)*a.x)*.5;}//interval vec2(start,end) to skeleton vec2(center,width)\nvec2 s2i(vec2 a){return (a.x+vec2(-1,1)*a.y);}//skeleton vec2(center,width) to interval vec2(start,end)\n\n//m.xy is one skeleton, m.zw is another skeleton, one usecase is 2 overlapping notes in a midi sheet.\n//miNote() automatically fuses overlapping notes, allows for pseudo-kernign and left-endian phasing.\n//if(skeletons overlap) return skeleton AABV\n//else return skeleton that is closest to [t] (ceates c0Discontinuity just like floor())\nvec2 miNote(float t,vec4 m//parent: https://www.shadertoy.com/view/XlcBDj\n){if(m.x>m.z)m=m.zwxy//must be sorted\n ;m.yw=abs(m.yw)//below code only allows for width>=0\n ;vec4 k=gLLxXnp(m)\n ;if(k.w<0.//2 ranges are speerate, return tange that is closest to u.x\n ){m.xy=mix(m.zw,m.xy,step(t,k.z))      \n  ;return m.xy\n ;}else{//else( 2 ranges intersect  (open intervals) (or one is inside the other))\n  ;if(max(k.y,k.w)<max(m.w,m.y) //iff (one ranges is completely inside the other) return larger range\n  ){return mix(m.xy,m.zw,step(m.y,m.w))\n  ;}else \n   ;float center=mix(m.x-m.y,m.z+m.w,.5)//needs to be tone is interval-coords.\n   ;return vec2(center,center-m.x+m.y) //but the branching i can only to in skeleton-coordinates\n ;}}\n\nvec3 miNote(float t,vec3 a,vec3 b){return vec3(miNote(t,vec4(a.xy,b.xy)),min(a.z,b.z));}\n//i should possibly define a maNote (max()) \n//but usually componists do not define music with boolean_AND!\n\n//above are min() unions for below data structure of a \"1d box skeleton\" (humble beginnings)\n//u=uv\n//c=center\n//w=width\nvec3 note(float u,float c,float w){return vec3(c,w,abs(u-c)-w);}\n\nve3 entryImage(ve0 t,ve1 u,ve2 r,ve3 m){\n ;ve3 c=ve3(0,0,0,1)\n ;u   =fra(t,u   ,r,m)\n ;if(m.z>0.){\n  ;m.xy=fra(t,m.xy,r,m)\n  ;m.zw=fra(t,m.zw,r,m)\n ;}else{//iMouse is cos(hash41Aperiodic())\n   ;m=sqrt(vec4(5,11,3,13))-vec4(21,2,1,17) //QuadraticField: see: https://www.shadertoy.com/view/Xt3BDB\n   ;m=sin(m*t*.04)//time as seed for hash m.\n   ;//m=fract(m*4500.)//optional obfuscation\n   ;m.yw=m.yw*.5+.5//mirror symmetry on y=0\n   ;m.yw=m.yw*.3+.3//minimum key width\n   ;m*=ViewZoom*.4//view scale\n ;}\n ;m.yw=abs(m.yw)//below code only allows for width>=0\n //;vec2 centers=vec2(0,1) //centers of 2 boxes\n //;vec2 widthx=vec2(.5,.6)//width.x of 2 boxes\n //;vec2 widthy=vec2(.5,.6)//width.y of 2 boxes     \n ;vec3 a=note(u.x,m.x,m.y)-.1   //a note centwred ad m.x, with width m.y\n ;vec3 b=note(u.x,m.z,m.w)-.1   //a note centwred ad m.z, with width m.w\n ;vec2 dd=vec2(.1,1.)\n ;vec3 d=note(u.x,dd.x,dd.y)-.1 //a note centwred at .1, with width .4\n     //d is \"3rd note\" , inserted AFTER (in program code time) the first other notes are min() merged\n     //this constrains the notes TIME.x to be NEVER between all other previously added notes\n     //akin to a FIFO or FILO stack, you are just not allowed to add a token anywhere\n     //, except at the top or bottom end !!!\n     //otherwise it messes up temporality. [see darwinbots wiki]\n //aboveare shape function, below is a novel type of min()\n ;a=miNote(u.x,a,b)   //optional fold since starguitar7\n ;a=miNote(u.x,a,d)   //optional fold since starguitar7\n      \n //above composites multiple notes (1d, one frequency for now)\n //usually notes are mostly mod() fract()\n //, but you often have the issue of needing to mix silly note lengths: https://www.youtube.com/watch?v=g0gNoELvpPo\n //this is where miNote(u.x,a,b) unifies 2 notes to 2 long note, IFF they overlap \n //(open interval overlap allows 1 note too start the same moment another note ends)\n //which allows for more flexibility in composing\n //,but the main purpose is to define notes & frequencies\n // in terms of defining an sdf (blue/yellow area)\n //\n //below we turns that composition into a waaveform,multiplied by a hull/ease.\n \n ;c.xyz=a //catch one note to have that define \"color\"\n ;float frequency=9.\n ;float phase=c.y //c.y align left; -c.y align right\n ;vec2 h;\n ;h.x= c.x-c.y-u.x+1.\n ;h.y=-c.x-c.y+u.x+1.\n ;h.xy=sat(h.xy)                         //optional easeTween linear\n ;//h.xy=smoothstep(vec2(0),vec2(1),h.xy)//optional easeTween hermite3\n ;c.w=max(h.x,h.y)-1.                          //tricky commutative var shuffling\n ;c.y=u.y-sin((u.x-c.x+phase)*frequency)*c.w*2. //tricky commutative var shuffling\n ;c.x=0.\n ;c.x=        abs(ma(abs(u-vec2( m.x-.1,0))-vec2( m.y-.1,1.0))) //red box (debug a note)\n ;c.x=min(c.x,abs(ma(abs(u-vec2( m.z-.1,0))-vec2( m.w-.1,1.1))))//red box (debug a note)\n ;c.x=min(c.x,abs(ma(abs(u-vec2(dd.x-.1,0))-vec2(dd.y-.1,1.2))))//red box (debug a note)\n ;c.x-=.02\n ;c.yw=abs(c.yw+u.y)-.1\n     \n #ifdef negateRG\n ;c.xy=-c.xy\n #endif\n ;vec4 l=vec4(1)\n #ifdef showGradLog\n ;l=(1.-log(abs(c.xyzw*.4+1.)))\n #endif\n ;c.x=mix(smoothstep(.01,-.01,c.x)*l.x,fract(c.x)*l.x,.3)\n ;c.y=mix(smoothstep(.01,-.01,c.y)*l.y,fract(c.y)*l.y,.4)\n ;c.z=mix(smoothstep(.01,-.01,c.z)*l.z,fract(c.z)*l.z,.4)\n ;c.w=mix(smoothstep(.01,-.01,c.w)*l.w,fract(c.w)*l.w,.6)\n \n ;//c.xy*=(1.-log(abs(c.xy)))//nah, just too confucing\n ;//c.y=0.\n     //;c.xy=vec2(0)\n ;c.xy=mix(c.xy,sat(c.ww),.5)\n ;c.w=1.\n ;c=sat(c)\n ;return c\n ;}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}