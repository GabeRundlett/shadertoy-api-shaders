{
    "Shader": {
        "info": {
            "date": "1631034119",
            "description": "Simple terrain, some reflection and trying to play with camera. Is it optimized ? OF COURSE NOT :D ",
            "flags": 0,
            "hasliked": 0,
            "id": "NsG3zh",
            "likes": 5,
            "name": "大龙猫 - Canyon Flight",
            "published": 3,
            "tags": [
                "terrain",
                "camera",
                "clipping"
            ],
            "usePreview": 0,
            "username": "totetmatt",
            "viewed": 286
        },
        "renderpass": [
            {
                "code": "float box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.y,q.z)));\n}\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nvec2 sdf(vec3 p){\n  p.z +=mod(iTime,100.);\n      vec2 id = floor(p.xz);\n      p.xz = asin(sin(p.xz)*.8);\n  vec2 h;\n\n    \n    vec4 pp = vec4(p,1.);\n    float mm = 10000.;\n    for(float i =0.;i<=16.;i++){\n            pp.xyz = abs(pp.xyz)-1.1;\n            pp.xz *=rot(.785*i+i);\n            \n            pp.yz *=rot((.29)*i);\n            float m =  min(pp.x,min(pp.y,pp.z));\n            mm = min(mm,m); // This was on nusan video I recently saw. Quite nice\n            pp*=1.11;\n            pp.xy = pp.x < pp.y ? pp.yx:pp.xy;\n            pp.x -=3.1;\n    }\n    h.x =     (length(pp.xyz)-1.5-mm*.01)/pp.a;\n    h.x = max(abs(length(p)-2.)-1.1,-h.x);\n    h.x = mix(box(p,vec3(1.)),h.x*.7,.5);\n    h.y = 1.;\n    h.x = max(-(length(pp.xz)-3.6)/pp.a,h.x);\n    \n    vec2 t;\n    t.x = dot(p,vec3(0.,1.,.0))-sin(pp.x*.1+pp.z*.1)*.1;\n    t.y = 2.;\n    h = t.x < h.x  ? t:h;\n    return h;\n}\n#define ao(rp,n,k) (sdf(rp+n*k).x/k)\n#define AO(rp,n) (ao(rp,n,.1)+ao(rp,n,.5)+ao(rp,n,.7))\n#define q(s) s*sdf(p+s).x\nvec3 norm(vec3 p,float ee){vec2 e= vec2(-ee,ee);return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(.1);\n    vec3 ro = vec3(0.,2.+sin(iTime*.33+3.0)*1.4,-5.);\n    vec3 rt = vec3(cos(iTime*.33)*2.,sin(iTime*.5),0.);\n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z,vec3(0.,-1.,0.)));\n    vec3 y = normalize(cross(z,x));\n    \n    vec3 rp = ro;\n    uv *=rot(cos(iTime*.3));\n    vec3 rd = mat3(x,y,z)*normalize(vec3(uv,1.));\n    float dd =0.;\n    vec2 d;\n    d.y =-1.;\n    vec3 light = vec3(1.,2.,-3.);\n    for(float i=0.;i<=128.;i++){\n        d = sdf(rp);\n        dd +=d.x;\n        if(dd > 10.) {d.y= -1.; break;}\n        if(d.x<.001){\n            vec3 n = norm(rp,.0003);\n            if(d.y == 2.){\n                rd = normalize(reflect(rd,n));\n                rp +=rd*.01;\n                col +=vec3(.1,.1,.4);\n                continue;\n            }\n            float diff = max(0.,dot(normalize(light-rp),n));\n            col += vec3(1.)*diff;\n            col = mix(vec3(.1,.1,.2),vec3(1.,.9,.7),AO(rp,n)/1.7);\n            break;\n        }\n    rp+=rd*d.x;\n    }\n    if(d.y==-1.) col += mix(vec3(.2,.4,.8),vec3(.5,.6,.9),uv.y);\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}