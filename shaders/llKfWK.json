{
    "Shader": {
        "info": {
            "date": "1567292683",
            "description": "https://www.shadertoy.com/view/MtGBWV",
            "flags": 32,
            "hasliked": 0,
            "id": "llKfWK",
            "likes": 3,
            "name": "Beckoning",
            "published": 3,
            "tags": [
                "2d"
            ],
            "usePreview": 0,
            "username": "dashsc",
            "viewed": 415
        },
        "renderpass": [
            {
                "code": "#define iTime iTime*TIMESCALE\n//http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec3 col = texture(iChannel0, uv).rgb;\n    float cs = (col.r+col.g+col.b)/3.;\n\tcol = mix(col,hsv2rgb(vec3(cs+iTime*0.1,cs+0.2,1.)),mix(1.-cs,cs-1.,sin(iTime*0.2)));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.1415926536\n#define TWO_PI 6.2831853072\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define iTime iTime*TIMESCALE\n#define edge 0.0205*(sin(tan(iTime*1.))+2.)\n\nfloat pModPolar(inout vec2 p, float repetitions);\nmat2 rotMat2 (in float a );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n\tvec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n//    uv -= 0.5;\n//    uv *= 2.;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n  vec3 color = vec3(pow(vec3(0.16862745098039217, 0.01568627450980392, 0.01568627450980392), vec3(2.2)));\n\n  const vec3 yellow = pow(vec3(1, 0.9882352941176471, 0.09803921568627451), vec3(2.2));\n  const vec3 blue = pow(vec3(0.0784313725490196, 0.5215686274509804, 0.8), vec3(2.2));\n\n  vec2 q = 0.9 * uv;\n\n  float l = length(q);\n  float a = atan(q.y, q.x);\n\n  float ring1 = smoothstep(edge, 0., abs(l - tan(2.2+iTime*0.5)*0.17));\n  color = mix(color, vec3(1, 0, 0), ring1);\n\n  // Tick 1\n  float tickEdge = mix(20. * edge, 2. * edge, saturate(l * 0.1));\n  float ticks1 = smoothstep(tickEdge, 0., mod(a, PI * 0.125));\n  ticks1 *= smoothstep(0.0125 + edge, 0.0125, (abs(l - tan(1.21*iTime+1.)*0.15)));\n  color = mix(color, yellow, ticks1);\n\n  vec2 polQ = q;\n  float polC = pModPolar(polQ, 10.);\n\n  // Boxes\n  vec2 polAbsQ = abs(polQ - vec2(0.135, 0));\n  float boxes1 = smoothstep(edge, 0., abs(max(tan(0.5+polAbsQ.x+iTime*0.5), tan(polAbsQ.y-iTime*0.5)) - 0.025));\n  color = mix(color, blue, boxes1);\n\n  // Tick 2\n  float ticks2 = smoothstep(5. * edge, 0., mod(a - PI * 0.1, PI * 0.2));\n  ticks2 *= smoothstep(0.025 + edge, 0.025, abs(l - (tan(iTime*0.96)+1.)*0.3));\n  color = mix(color, vec3(1), ticks2);\n\n  // Circles 1\n  float polQL = length(polQ - vec2((tan(iTime+1.)+1.)*0.3, 0));\n  float circle1 = smoothstep(edge, 0., polQL - 0.0125);\n  color = mix(color, vec3(1, 0, 0), circle1);\n\n  // Ring 2\n  float ring2 = smoothstep(edge, 0., abs(l - (tan(iTime-2.5)+1.)*0.2));\n  color = mix(color, yellow, ring2);\n\n  // Diamonds\n  vec2 pol2Q = q;\n  float pol2C = pModPolar(pol2Q, 30.);\n  vec2 pol2RotQ = pol2Q - vec2((sin(iTime*0.89)+1.)*0.3, 0);\n  pol2RotQ.y *= 2.;\n  pol2RotQ *= rotMat2(PI * 0.25);\n  vec2 pol2AbsQ = abs(pol2RotQ);\n  float diamonds1 = smoothstep(edge, 0., abs(max(pol2AbsQ.x, pol2AbsQ.y) - 0.025));\n  color = mix(color, blue, diamonds1);\n\n  // Dashed Ring 1\n  float dashRing1 = smoothstep(edge, 0., abs(l - (tan(iTime*0.2)+1.)*0.3));\n  dashRing1 *= smoothstep(PI * 0.02 + 2. * edge, PI * 0.02, mod(a, TWO_PI * 0.041667));\n  color = mix(color, vec3(1), dashRing1);\n\n  // Concentric Squares 1\n  vec2 quadQ = q;\n  float s = (tan(iTime)+1.)*0.3;\n  pModPolar(quadQ, 8.);\n  vec2 quadAbsQ = abs(quadQ - vec2(0.540, 0));\n  float quadAbsD = max(quadAbsQ.x, quadAbsQ.y);\n  float concSqr11 = smoothstep(edge, 0., abs(quadAbsD - s));\n  color = mix(color, vec3(1, 0, 0), concSqr11);\n  float concSqr12 = smoothstep(edge, 0., abs(quadAbsD - s*0.75));\n  color = mix(color, yellow, concSqr12);\n  float concSqr13 = smoothstep(edge, 0., abs(quadAbsD - s*0.5));\n  color = mix(color, blue, concSqr13);\n  float concSqr14 = smoothstep(edge, 0., abs(quadAbsD - s*0.265));\n  color = mix(color, vec3(1, 0, 0), concSqr14);\n\n  // White squiggle\n  float rOffset = 0.0125 * sin(20. * a);\n  float squiggle = smoothstep(edge, 0., abs(l - rOffset - 0.525));\n  squiggle *= smoothstep(PI * 0.125 + edge, PI * 0.125, abs(mod(a, PI * 0.5) - PI * 0.25));\n  // color = mix(color, vec3(1), squiggle);\n\n  // White Dots\n  quadQ = q * rotMat2(iTime*0.1 * PI);\n  pModPolar(quadQ, 8.);\n  float quadQL = length(quadQ - vec2((sin(iTime)+1.)*0.3, 0));\n  float dots = smoothstep(edge, 0., quadQL - 0.005);\n  color = mix(color, vec3(1), dots);\n  vec2 ouv = fragCoord/iResolution.xy;\n  ouv -= 0.5;\n  ouv *= 0.99;\n  ouv += 0.5;\n  vec3 bak = texture(iChannel0,(ouv)).rgb;\n  float bc = (bak.r+bak.g+bak.b)/3.;\n  float rc = 1.;\n\n  if (bc > 0.9) {\n  \trc = 0.9;  \n    if (bc > 0.999) {\n      bc = 0.;  \n    }\n  }\n  ouv -= 0.5;\n  ouv *= 0.99-((bc*0.06+(cos(iTime)*0.005))-0.035+sin(iTime*0.5)*0.01);\n  ouv += 0.5;\n  vec3 bac = texture(iChannel0,(ouv)).rgb;\n  color += mix(color*0.99,bac*rc,0.94+(sin(iTime)*0.05));\n  fragColor = vec4(color, 1);\n}\n\n// HG_SDF\n#ifndef PI\n#define PI 3.1415926536\n#endif\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n  float angle = 2.*PI/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a,angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x direction\n  // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n  if (abs(c) >= (repetitions/2.)) c = abs(c);\n  return c;\n}\nmat2 rotMat2 (in float a ) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat2(c, -s, s, c);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define TIMESCALE .3",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}