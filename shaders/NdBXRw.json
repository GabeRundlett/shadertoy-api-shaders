{
    "Shader": {
        "info": {
            "date": "1619822242",
            "description": "This was a lot of fun (3x3 system of equations)! I've been trying to figure out how to do it for a while.",
            "flags": 0,
            "hasliked": 0,
            "id": "NdBXRw",
            "likes": 14,
            "name": "Bilinear Patch Ray Intersection",
            "published": 3,
            "tags": [
                "raytracing",
                "ray",
                "raycasting",
                "intersection",
                "parametric",
                "bilinear",
                "patch",
                "systemofequations"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 229
        },
        "renderpass": [
            {
                "code": "// Comment out to see the entire surface\n#define ONLY_PATCH\n\nstruct PatchIsect {\n    bool hit;\n    vec2 t;\n    vec2[2] uv;\n    vec3[2] nor;\n};\n\n// Bilinear patch intersection\n// Parametric equation: mix(mix(a, d, u), mix(b, c, u), v)\n// ---> (a - b + c - d)uv + (d - a)u + (b - a)v + a\n// Involves solving a 3x3 system that has two or no solutions\n// Vertices are expected to be winding in counterclockwise order\nfloat cross2D(in vec2 a, in vec2 b) { return a.y * b.x - a.x * b.y; }\nPatchIsect iBilinearPatch(in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    vec2 m = rd.yz / rd.x;\n    vec3 p = a - b + c - d, q = d - a, r = b - a;\n    vec2 c1 = p.yz - p.x * m, c2 = q.yz - q.x * m, c3 = r.yz - r.x * m;\n    vec2 c4 = (ro.x - a.x) * m + a.yz - ro.yz;\n\n    // Quadratic coefficients (reversed as a trick to deal with edge cases)\n    float qa = cross2D(c4, c2);\n    float qb = cross2D(c4, c1) + cross2D(c3, c2);\n    float qc = cross2D(c3, c1);\n\n    float discr = qb * qb - 4.0 * qa * qc;\n    if (discr > 0.0) {\n        vec2 v = 2.0 * qa / (vec2(-1.0, 1.0) * sqrt(discr) - qb); // Solve for v parameter\n        vec2 u = -(c4.x + c3.x * v) / (c1.x * v + c2.x); // Substitute v and solve for u parameter\n        vec2 t = (p.x * u * v + q.x * u + r.x * v + a.x - ro.x) / rd.x; // Substitute u and v and solve for t parameter\n\n        // Compute normals (cross products of partial derivatives)\n        vec3 n1 = normalize(cross(p * v.x + q, p * u.x + r));\n        vec3 n2 = normalize(cross(p * v.y + q, p * u.y + r));\n\n        return PatchIsect(true, t, vec2[2](vec2(u.x, v.x), vec2(u.y, v.y)), vec3[2](n1, n2));\n    }\n\n    return PatchIsect(false, vec2(-1.0), vec2[2](vec2(0.0), vec2(0.0)), vec3[2](vec3(0.0), vec3(0.0)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 mouse = ivec2(iMouse) == ivec2(0) ? vec2(0.0) : (iMouse.xy - center) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Environment map\n    fragColor = texture(iChannel0, rd);\n\n    // Patch vertices\n    float t1 = iTime, t2 = iTime * 2.0, t3 = iTime * 2.5;\n\n    float c1 = cos(t1), s1 = sin(t1);\n    float c2 = cos(t2), s2 = sin(t2);\n    float c3 = cos(t3), s3 = sin(t3);\n\n    vec3 a = vec3(-1.5, -1.5, -0.5) + vec3(c1, c2, s3) * 0.5;\n    vec3 b = vec3(-1.5,  1.5,  0.5) + vec3(s2, c1, s3) * 0.5;\n    vec3 c = vec3( 1.5,  1.5, -0.5) + vec3(s2, c3, c1) * 0.5;\n    vec3 d = vec3( 1.5, -1.5,  0.5) + vec3(c2, s3, s1) * 0.5;\n\n    // Find the closest hit in front of the camera\n    PatchIsect isect = iBilinearPatch(ro, rd, a, b, c, d);\n    if (isect.hit) {\n        float dist = -1.0;\n        vec3 pos, nor;\n        vec2 patchUv;\n        for (int n=0; n < 2; n++) {\n            #ifdef ONLY_PATCH\n            bool inPatch = all(lessThan(abs(isect.uv[n] - 0.5), vec2(0.5)));\n            #else\n            bool inPatch = true;\n            #endif\n\n            if (isect.t[n] > 0.0 && (dist < 0.0 ? true : isect.t[n] < dist) && inPatch) {\n                dist = isect.t[n];\n                pos = ro + rd * isect.t[n];\n                nor = isect.nor[n];\n                patchUv = isect.uv[n];\n            }\n        }\n\n        // Render the shape if hitting\n        if (dist > 0.0) {\n            vec3 light = -rd;\n            float diff = abs(dot(nor, light));\n            float checkers = 0.5 + 0.5 * mod(dot(floor(patchUv * 8.0), vec2(1.0)), 2.0);\n            fragColor = mix(vec4(checkers, 0.0, 0.0, 1.0), texture(iChannel0, reflect(-rd, nor)), 0.25);\n            fragColor.rgb *= diff;\n        }\n    }\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.75));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}