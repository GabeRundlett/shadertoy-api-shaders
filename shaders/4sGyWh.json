{
    "Shader": {
        "info": {
            "date": "1521680156",
            "description": "Approximate sine integral to approximate antialiased asymmetric triangle wave",
            "flags": 8,
            "hasliked": 0,
            "id": "4sGyWh",
            "likes": 6,
            "name": "Asymmetric triangle wave",
            "published": 3,
            "tags": [
                "sound",
                "antialias",
                "fourier",
                "synth",
                "bandlimited",
                "gibbs",
                "parabolawave"
            ],
            "usePreview": 0,
            "username": "NinjaKoala",
            "viewed": 640
        },
        "renderpass": [
            {
                "code": "/*\nAsymmetric triangle wave implemented as integral of pulse wave,\nand therefore as subtraction of parabola waves\nSee https://www.shadertoy.com/view/MlcSWS for some explanation\n*/\n\nconst float eps=.00034526;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float border=1.3/iResolution.y;\n    \n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tuv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    float t0=mod(iTime,freq_modulus);\n    \n    float audio_freq=get_audio_freq(t0);\n    \n    n=int(.5*iSampleRate/audio_freq);\n    \n    pulse_width=get_pulse_width(t0);\n\n\tfloat freq=.0002*audio_freq;\n\n\tfloat zoom=5.;\n    \n    vec2 uv1=uv;\n    uv1.y-=.25*sign(uv.y);\n    \n    uv1*=zoom;\n\n\tfloat dis1=abs(integral_asym_triangle(uv1.x,freq)-uv1.y);\n\tdis1/=zoom*length(vec2((integral_asym_triangle(uv1.x,freq)-integral_asym_triangle((uv1.x+eps),freq))/eps,1.));\n\n\tfloat dis2=abs(additive_asym_triangle(uv1.x,freq)-uv1.y);\n\tdis2/=zoom*length(vec2((additive_asym_triangle(uv1.x,freq)-additive_asym_triangle((uv1.x+eps),freq))/eps,1.));\n\n\tfloat dis3=abs(simple_asym_triangle(uv1.x,freq)-uv1.y);\n\tdis3/=zoom*length(vec2((simple_asym_triangle(uv1.x,freq)-simple_asym_triangle((uv1.x+eps),freq))/eps,1.));\n\n\tfloat thickness=zoom*.0001;\n\n\tvec3 bg_col=vec3(0);\n\n\tvec3 add_col=vec3(1);\n\tvec3 int_col=vec3(1,0,0);\n\tvec3 smp_col=vec3(0,1,0);\n\n\tvec3 color;\n    \n    if(uv.y>0.){\n    \tcolor=mix(smp_col,bg_col,smoothstep(0.,border,dis3-thickness));\n\t\tcolor=mix(add_col,color,smoothstep(0.,border,dis2-thickness));\n\t\tcolor=mix(int_col,color,smoothstep(0.,border,dis1-thickness));\n    }\n    else{\n        float t1=mod(iTime,wave_modulus);\n        \n        int wave_index=get_wave_index(t1);\n        \n        if(wave_index==0){\n        \tcolor=mix(smp_col,bg_col,smoothstep(0.,border,dis3-thickness));\n        }\n        else if(wave_index==1){\n\t\t\tcolor=mix(add_col,bg_col,smoothstep(0.,border,dis2-thickness));\n        }\n        else{\n\t\t\tcolor=mix(int_col,bg_col,smoothstep(0.,border,dis1-thickness));\n        }\n    }\n    \n\tfragColor=vec4(color,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float pi=3.1416;\nconst int max_n=100;\nint n;\n\nconst float freq_modulus=18.;\nconst float wave_modulus=6.;\n\nfloat pulse_width;\n\nfloat polynomial(vec4 a, float x){\n\treturn (((x*x + a[0])*x*x + a[1])*x*x + a[2])*x*x+a[3];\n}\n\nfloat rational(vec4 a, vec4 b, float x){\n\n\tfloat numerator=polynomial(a,x);\n\tfloat denominator=polynomial(b,x);\n\n\treturn numerator/denominator;\n}\n\nfloat Si(float x){\n\n\tfloat sgn=1.;\n\n\tif(x<0.){\n\t\tsgn=-1.;\n\t\tx=-x;\n\t}\n\n\tif(x<1.){\n\t\tvec4 a = vec4(-1./35280.,1./600.,-1./18.,1.)*3265920.;\n\t\treturn sgn*polynomial(a,x)/3265920.*x;\n\t}\n\telse{\n\n\t\tvec4 a_f=vec4(38.027264,265.187033,335.67732,38.102495);\n\t\tvec4 b_f=vec4(40.021433,322.624911,570.236280,157.105423);\n\n\t\tfloat f=1./x*rational(a_f,b_f,x);\n\n\t\tvec4 a_g=vec4(42.242855,302.757865,352.018498,21.821899);\n\t\tvec4 b_g=vec4(48.196927,482.485984,1114.978885,449.690326);\n\n\t\tfloat g=1./(x*x)*rational(a_g,b_g,x);\n\n\t\treturn sgn*(pi/2.-f*cos(x)-g*sin(x));\n\t}\n}\n\nfloat integral_parabola(float x, float freq){\n    float cur_drv=float(n)*4.*freq;\n\n\tfloat y_1=-Si(.5/freq*(pi/2.)*(2.*freq+cur_drv))*2./pi;\n\tfloat y_2=-Si(-.5/freq*(pi/2.)*(2.*freq+cur_drv))*2./pi;\n\n\tx=mod(x,1./freq)-.5/freq;\n\n\tfloat a=-2./pi;\n\tfloat b=pi/2.*(2.*freq+cur_drv);\n\n\tfloat min_val=.125*(y_2-y_1)/freq+(b*.5/freq*Si(b*.5/freq) + cos(b*.5/freq))*a/b;\n\tfloat max_val=a/b;\n\n\treturn 2.*((.5*(y_2-y_1)*freq*x*x+(b*x*Si(b*x) + cos(b*x))*a/b)-min_val)/(max_val-min_val)-1.;\n}\n\nfloat additive_parabola(float x, float freq){\n\tfloat min_val=0.;\n\tfloat max_val=0.;\n\n\tfor(int k=1;k<=max_n;k+=2){\n\t\tif(k<=n){\n\t\t\tmin_val+=(-1./(float(k*k)));\n\t\t\tmax_val+=(1./(float(k*k)));\n\t\t}\n\t\tif(k+1<=n){\n\t\t\tmin_val+=(1./(float((k+1)*(k+1))));\n\t\t\tmax_val+=(1./(float((k+1)*(k+1))));\n\t\t}\n\t}\n\n\tfloat sum=0.;\n\tx-=.5/freq;\n\n\tfor(int k=1;k<=max_n;k++){\n\t\tif(k<=n){\n\t\t\tsum+=(1./(float(k*k)))*cos(mod(float(k)*2.*pi*x*freq,2.*pi));\n\t\t}\n\t}\n\n\treturn 2.*(sum-min_val)/(max_val-min_val)-1.;\n}\n\nfloat simple_parabola(float x, float freq){\n\tx*=freq;\n\tx=mod(x-.5,1.)-.5;\n\treturn x*x*8.-1.;\n}\n\nfloat integral_asym_triangle(float x, float freq){\n\treturn .4*(integral_parabola(x,freq)-integral_parabola(x-pulse_width/freq,freq));\n}\n\nfloat additive_asym_triangle(float x, float freq){\n\treturn .4*(additive_parabola(x,freq)-additive_parabola(x-pulse_width/freq,freq));\n}\n\nfloat simple_asym_triangle(float x, float freq){\n\treturn .4*(simple_parabola(x,freq)-simple_parabola(x-pulse_width/freq,freq));\n}\n\nfloat get_audio_freq(float t){\n    if(t<6.){\n        return 1046.5022612024;//C8\n    }\n    else if(t<12.){\n        return 2637.0204553030;//E9\n    }\n    else{\n        return 4186.0090448096;//C10\n    }\n}\n\nint get_wave_index(float t){\n    if(t<2.){\n    \treturn 0;\n    }\n    else if(t<4.){\n\t\treturn 1;\n    }\n    else{\n\t\treturn 2;\n    }\n}\n\nfloat get_pulse_width(float t){\n    return mod(t/4.,.5);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec2 mainSound( in int samp,float time){\n    \n    float t0=mod(time,freq_modulus);\n    float t1=mod(time,wave_modulus);\n    \n    float audio_freq=get_audio_freq(t0);\n    \n    n=int(.5*iSampleRate/audio_freq);\n    \n    pulse_width=get_pulse_width(t0);\n    \n    int wave_index=get_wave_index(t1);\n    \n    if(wave_index==0){\n    \treturn vec2(.2*simple_asym_triangle(t0,audio_freq));\n    }\n    else if(wave_index==1){\n    \treturn vec2(.2*additive_asym_triangle(t0,audio_freq));\n    }\n    else{\n    \treturn vec2(.2*integral_asym_triangle(t0,audio_freq));\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}