{
    "Shader": {
        "info": {
            "date": "1480747628",
            "description": "A simple 2D rope demo I quickly hacked together.  Could be improved with stretching/tension forces.  May revisit it later.",
            "flags": 32,
            "hasliked": 0,
            "id": "XlcSRf",
            "likes": 4,
            "name": "2D Rope Example",
            "published": 3,
            "tags": [
                "2d",
                "interactive",
                "multipass",
                "rope"
            ],
            "usePreview": 0,
            "username": "AxleMike",
            "viewed": 890
        },
        "renderpass": [
            {
                "code": "const float MAX_ROPE_POINTS = 20.0;\nconst vec4 txRopePoints = vec4(0.0, 0.0, MAX_ROPE_POINTS, 0.0);\n\n// IsInside/Saving/Loading code is from IQ's shader: https://www.shadertoy.com/view/MddGzf\nfloat IsInside(in vec2 p, in vec2 c) \n{ \n    vec2 d = abs(p - 0.5 - c) - 0.5; \n    return -max(d.x, d.y); \n}\n\nfloat IsInside(in vec2 p, in vec4 c) \n{ \n    vec2 d = abs(p - 0.5 - c.xy - c.zw * 0.5) - 0.5 * c.zw - 0.5; \n    return -max(d.x, d.y); \n}\n\nvec4 LoadRope(in vec2 re)\n{\n    return texture(iChannel0, (0.5 + re) / iChannelResolution[0].xy);\n}\n\nfloat Saturate(in float x)\n{\n    return clamp(x, 0.0, 1.0);\n}\n\nvec2 Saturate(in vec2 v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nfloat sdfCapsule(in vec2 p, in vec2 pointA, in vec2 pointB, in float radius)\n{\n    vec2 lineBA = pointB - pointA;\n    vec2 linePA = p - pointA;\n    float rate = min(max(dot(lineBA, linePA), 0.0) / dot(lineBA, lineBA), 1.0);\n    return length(p - (pointA + rate * lineBA)) - radius; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = (iResolution.x / iResolution.y);\n\tvec2 uv = ((fragCoord.xy / iResolution.xy) * 2.0 - 1.0);\n    uv.x *= aspectRatio;\n    \n    vec3 finalColor = vec3(0.0);\n    \n    for(int i = 0; i < int(MAX_ROPE_POINTS - 1.0); ++i)\n    {\n        float ropeIndex = float(i);\n        vec2 currentPoint = LoadRope(vec2(ropeIndex - 0.5, 0.0)).xy;\n        vec2 nextPoint = LoadRope(vec2(ropeIndex + 1.0 - 0.5, 0.0)).xy;\n\n        if((distance(currentPoint, nextPoint) > 0.0) && (sdfCapsule(uv, currentPoint, nextPoint, 0.075) < 0.0))\n        {\n            finalColor = vec3(mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), (ropeIndex / MAX_ROPE_POINTS)));\n        }\n    }\n\tfragColor = vec4(finalColor, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float MAX_ROPE_POINTS = 20.0;\nconst float MAX_ROPE_SEPERATION = 0.09;\nconst vec4 txRopePoints = vec4(0.0, 0.0, MAX_ROPE_POINTS, 0.0);\n\n// IsInside/Saving/Loading code is from IQ's shader: https://www.shadertoy.com/view/MddGzf\nfloat IsInside(in vec2 p, in vec2 c) \n{ \n    vec2 d = abs(p - 0.5 - c) - 0.5; \n    return -max(d.x, d.y); \n}\n\nfloat IsInside(in vec2 p, in vec4 c) \n{ \n    vec2 d = abs(p - 0.5 - c.xy - c.zw * 0.5) - 0.5 * c.zw - 0.5; \n    return -max(d.x, d.y); \n}\n\nvec4 LoadRope(in vec2 re)\n{\n    return texture(iChannel0, (0.5 + re) / iChannelResolution[0].xy);\n}\n\nvoid StoreRope(in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = (IsInside(fragCoord, re) > 0.0) ? va : fragColor;\n}\n\nvec4 ConstrainRope(in vec4 ropeParameters, in float forceIndex)\n{\n    const float gravityAmount = 0.98;\n    vec2 gravity = iTimeDelta * vec2(0.0, -gravityAmount);\n    \n    vec2 forcePoint = LoadRope(vec2(forceIndex - 0.5, 0.0)).xy;\n    vec2 q = ropeParameters.xy - forcePoint.xy;\n    float pointDistance = length(q);\n\n    if(pointDistance <= 0.0) // catching bug if distance == 0.0\n    {\n        ropeParameters.xy += gravity;\n    }\n    else\n    {\n        float pastLimit = max(pointDistance - MAX_ROPE_SEPERATION, 0.0);\n\n        // clamp rope distance\n        vec2 towardsPrev = normalize(q);\n        ropeParameters.xy += -towardsPrev * pastLimit; \n\n        // is a hack\n        const float tension = 0.01;\n        ropeParameters.zw += -towardsPrev * tension;\n    }  \n    return ropeParameters;\n}\n\nvec4 MoveRope(in vec4 ropeParameters, in float index)\n{\n    const float gravityAmount = 0.98;\n    if(index >= 1.0)\n    {\n        vec2 gravity = iTimeDelta * vec2(0.0, -gravityAmount);\n        ropeParameters.zw += gravity;\n        ropeParameters.xy += ropeParameters.zw;\n\n        ropeParameters = ConstrainRope(ropeParameters, index - 1.0);\n    }\n    return ropeParameters;\n}\n\nvec2 gPinPoint = vec2(0.0, 0.9);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n     float aspectRatio = (iResolution.x / iResolution.y);\n    \n     // don't compute rope if not needed\n    if(fragCoord.x > MAX_ROPE_POINTS || fragCoord.y > 2.0) discard;\n\n    vec4 ropeParameters = LoadRope(fragCoord.xy - 0.5);\n    \n    if(iFrame <= 1) ropeParameters = vec4(gPinPoint.x, gPinPoint.y + floor(fragCoord.x) * -MAX_ROPE_SEPERATION, 0.0, 0.0);\n\n    if((iMouse.z > 0.0) && (fragCoord.x >= 1.0))\n    { \n        ropeParameters = vec4((2.0 * (iMouse.xy / iResolution.xy) - 1.0), 0.0, 0.0);\n        ropeParameters.x *= aspectRatio;\n    }  \n    ropeParameters = MoveRope(ropeParameters, fragCoord.x);\n    \n    fragColor = vec4(0.0);  \n    StoreRope(txRopePoints, ropeParameters, fragColor, fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}