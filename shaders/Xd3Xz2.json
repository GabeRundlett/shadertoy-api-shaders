{
    "Shader": {
        "info": {
            "date": "1460202589",
            "description": "tuto and explaination about classical bugs that indeed are not glsl bugs, but related to calculation of derivative on GPU.\n\nMore issues and tricks on https://shadertoyunofficial.wordpress.com/",
            "flags": 0,
            "hasliked": 0,
            "id": "Xd3Xz2",
            "likes": 3,
            "name": "'bug', MIPmap, derivative, warp2",
            "published": 3,
            "tags": [
                "warp",
                "mipmap",
                "derivative",
                "bug"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 989
        },
        "renderpass": [
            {
                "code": "\n/* MIPmap LOD are based on texture coordinates derivatives.\n   by default approximate derivative are obtained based on the GPU SIMD parallelism, \n   using the value of neighbor pixel within a 2x2 fix neighborhood.\n   (SIMD granuarity is within a warp of 32 pixels or less, but at least a 2x2 fix neighborhood).\n\n   So, slight offset in the image might cause or hide a bug,\n   here, the wrap of atan() along the horizontal line at the left of the center:\n\n   if it occurs inside a warp the derivarive will be huge, while if it occurs between\n   2 warps it won't.\n   Here, we display the derivatives of atan() in y and x, \n   and we offset the left half by one vertical pixel to change the alignement with warp.\n   The line that should appear would cause a MIPmap blur if atan() was used as texture coord.\n\n\n   Note also than R/2 is not always even, with can impact this kind of things at centering.\n   (red disk at bottom left corner).\n\n   see also https://www.shadertoy.com/view/XscSz2\n*/\n\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    vec2 R = iResolution.xy;\n    if (fract(R.y/2.)!=0. && length(U)<30.) { O=vec4(1,0,0,1); return;}\n \n    U = (U+U-R)/R.y; \n    float  t = iTime, eps = float(U.x<-.9)*2./R.y, \n           r = length(U), a = atan(U.y+eps, U.x);\n\n    O = .5+.5*10.*vec4(dFdy(a),dFdx(a),0,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}