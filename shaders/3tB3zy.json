{
    "Shader": {
        "info": {
            "date": "1559936281",
            "description": "Write opengl code in shadertoy...\n\nRecompile it should work. The \"Common\" tab is complaining about a nonexistent error.",
            "flags": 0,
            "hasliked": 0,
            "id": "3tB3zy",
            "likes": 2,
            "name": "ShaderGL",
            "published": 3,
            "tags": [
                "opengl"
            ],
            "usePreview": 0,
            "username": "josplode",
            "viewed": 552
        },
        "renderpass": [
            {
                "code": "// TODO: Handle multiple draws with uniform updates, multiple vbos, attributes\n\n//// Buffer Data ////\n\n// An array of 3 vectors which represents 3 vertices\nSGLptr vertex_data_ptr = 1u;\nGLfloat vertex_data[108] = GLfloat[108](\n    -1.0f,-1.0f,-1.0f, -1.0f,-1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f,-1.0f, -1.0f,-1.0f,-1.0f,\n    -1.0f, 1.0f,-1.0f, 1.0f,-1.0f, 1.0f, -1.0f,-1.0f,-1.0f, 1.0f,-1.0f,-1.0f, 1.0f, 1.0f,-1.0f, \n    1.0f,-1.0f,-1.0f, -1.0f,-1.0f,-1.0f, -1.0f,-1.0f,-1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f,\n    -1.0f, 1.0f,-1.0f, 1.0f, -1.0f,-1.0f, 1.0f, -1.0f,-1.0f,-1.0f, -1.0f, 1.0f, 1.0f,\n    -1.0f,-1.0f, 1.0f, 1.0f,-1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f,-1.0f,-1.0f,1.0f, 1.0f,-1.0f, \n    1.0f,-1.0f,-1.0f, 1.0f, 1.0f, 1.0f, 1.0f,-1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f,-1.0f,\n    -1.0f, 1.0f,-1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f,-1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, \n    -1.0f, 1.0f, 1.0f, 1.0f,-1.0f, 1.0f\n);\n\nSGLptr iso_vert_ptr = 2u;\nGLfloat iso_vert_data[36] = GLfloat[36](\n\t0.000, -1.000, 0.000,\n\t0.723, -0.447, 0.525,\n\t-0.276, -0.447, 0.850,\n\t-0.894, -0.447, 0.000,\n\t-0.276, -0.447, -0.850,\n\t0.723, -0.447, -0.525,\n\t0.276, 0.447, 0.850,\n\t-0.723, 0.447, 0.525,\n\t-0.723, 0.447, -0.525,\n\t0.276, 0.447, -0.850,\n\t0.894, 0.447, 0.000,\n\t0.000, 1.000, 0.000\n);\n\nSGLptr iso_tri_ptr = 3u;\nGLint iso_tri_data[60] = GLint[60](\n1, 2, 3, 2, 1, 6, 1, 3, 4, 1, 4, 5, 1, 5, 6,\n2, 6, 11, 3, 2, 7, 4, 3, 8, 5, 4, 9, 6, 5, 10, 2, 11, 7,\n3, 7, 8, 4, 8, 9, 5, 9, 10, 6, 10, 11, 7, 11, 12, 8, 7, 12,\n9, 8, 12, 10, 9, 12, 11, 10, 12\n);\n\n// Hack to handle pointers.\nfloat SGL_PTR_LOOKUP(SGLptr ptr, uint i) {\n    if (ptr == vertex_data_ptr) {\n        return vertex_data[i];\n    } else if (ptr == iso_vert_ptr) {\n        return iso_vert_data[i];\n    } else if (ptr == iso_tri_ptr) {\n        return float(iso_tri_data[i]);\n    }\n}\n\n//////////////////\n\n// Vertex Shader //\n\nmat4 ModelMatrix;\nmat4 ViewMatrix;\nmat4 ProjectionMatrix;\n\n// Payload {\n// inout vec4 pos\n// inout vec3 norm\n// inout vec2 uv\n// }\n\nvoid SGL_VERTEX_SHADER(in vec4 vPos, out FragmentPayload payload, out vec4 fragCoord) {\n    payload.pos = ModelMatrix * vPos;\n    fragCoord = ProjectionMatrix * ViewMatrix * ModelMatrix * vPos;\n}\n\n///////////////////\n\n// Fragment Shader //\n\nvec3 LightPos = vec3(5., -5., 0.);\nvec3 Color = vec3(1.);\n\n// Payload {\n// in vec4 pos\n// in vec3 norm\n// in vec2 uv\n// }\n\nvoid SGL_FRAGMENT_SHADER(in FragmentPayload payload, out vec4 fragColor) {\n    vec3 toLight = normalize(LightPos - payload.pos.xyz);\n    float cosTheta = max(dot(payload.norm, toLight), 0.5);\n    fragColor = vec4(Color, 1.) * cosTheta;\n}\n\n/////////////////////\n\nmat4 lookAt(vec3 eye, vec3 center, vec3 up) {\n    vec3 zaxis = normalize(center - eye);    \n    vec3 xaxis = normalize(cross(zaxis, up));\n    vec3 yaxis = cross(xaxis, zaxis);\n\n    zaxis = -zaxis;\n\n    mat4 viewMatrix = transpose(mat4(\n      vec4(xaxis.x, xaxis.y, xaxis.z, -dot(xaxis, eye)),\n      vec4(yaxis.x, yaxis.y, yaxis.z, -dot(yaxis, eye)),\n      vec4(zaxis.x, zaxis.y, zaxis.z, -dot(zaxis, eye)),\n      vec4(0, 0, 0, 1)\n    ));\n\n    return viewMatrix;\n}\n\nmat4 perspective() {\n    float n = 1.0;\n\tfloat f = 10.0;\n\tfloat r = 1.0 * iResolution.x / iResolution.y;\n\tfloat t = 1.0;\n\treturn (mat4(n/r, 0, 0, 0,\n      \t\t \t0, n/t, 0, 0,\n      \t\t \t0, 0, -(f+n)/(f-n), -1,\n\t\t\t \t0, 0, -(2.0*f*n)/(f-n), 0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    sglInit((fragCoord / iResolution.xy) - vec2(0.5));\n    \n    // Update uniforms\n    ViewMatrix = lookAt(vec3(sin(iTime), 0.5, cos(iTime)) * 6., vec3(0.), vec3(0., 1., 0.));\n    ProjectionMatrix = perspective();\n    \n    // VAO\n    GLuint vao;\n    glGenVertexArrays(1u, vao);\n    glBindVertexArray(vao);\n    \n    // Vertex buffer\n    GLuint vbo, iso_vbo;\n    glGenBuffers(1u, vbo);\n    glBindBuffer(SGL_ARRAY_BUFFER, vbo);\n    glBufferData(SGL_ARRAY_BUFFER, 36u, vertex_data_ptr, SGL_STATIC_DRAW);\n    \n    glGenBuffers(1u, iso_vbo);\n    glBindBuffer(SGL_ARRAY_BUFFER, iso_vbo);\n    glBufferData(SGL_ARRAY_BUFFER, 12u, iso_vert_ptr, SGL_STATIC_DRAW);\n    \n    // Begin drawing\n    glClearColor(0.1f, 0.2f, 0.7f, 0.f);\n    glClearDepth(1000.f);\n    glClear(SGL_COLOR_BUFFER_BIT | SGL_DEPTH_BUFFER_BIT);\n    \n    // Cubes\n    glBindBuffer(SGL_ARRAY_BUFFER, vbo);\n    \n    ModelMatrix = mat4(1.);\n    glDrawArrays(SGL_TRIANGLES, 0, 36u);\n    \n    Color = vec3(0.6, 0.9, 0.6);\n    ModelMatrix = mat4(\n        0.8, 0, 0, 0,\n        0, 0.5, 0, 0,\n        0, 0, 0.6, 0,\n        1, 1, 0, 1\n    );\n    glDrawArrays(SGL_TRIANGLES, 0, 36u);\n    \n    // Iso\n    glBindBuffer(SGL_ARRAY_BUFFER, iso_vbo);\n    \n    \n    Color = vec3(0.8, 0.4, 0.4);\n    ModelMatrix = mat4(1);\n    \n    for (int x = -2; x <= 2; x += 4) {\n        for (int y = -2; y <= 2; y += 4) {\n            ModelMatrix[3].x = float(x);\n            ModelMatrix[3].z = float(y);\n\n            glDrawElements(SGL_TRIANGLES, 60u, SGL_UNSIGNED_INT, iso_tri_ptr);\n        }\n    }\n    \n    // Process GL commands and calculate pixel color\n    fragColor = sglPixel();\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Unknown error\" is expected.\n\n// Types //\n\n#define GLenum uint\n#define GLuint uint\n#define GLint int\n#define GLsizei uint\n#define GLsizeiptr uint\n#define GLfloat float\n#define GLbitfield uint\n\n// Enums //\n\n#define SGL_TRIANGLES                      0x0004u\n#define SGL_UNSIGNED_INT                   0x1405u\n#define SGL_DEPTH_BUFFER_BIT               0x00000100u\n#define SGL_COLOR_BUFFER_BIT               0x00004000u\n#define SGL_ARRAY_BUFFER                   0x8892u\n#define SGL_STATIC_DRAW                    0x88E4u\n\n// SGL Context\n\nvec4 SGL_COLOR = vec4(0.);\nvec2 SGL_UV;\n\n#define SGL_MAX_VAOS 8\nGLuint SGL_CURRENT_VAO = 0u;\nGLuint SGL_BOUND_VAO = 0u;\n\nstruct VAO_State {\n    GLuint BoundArrayBuffer;\n};\nVAO_State SGL_VAO_STATES[SGL_MAX_VAOS];\n\n// Buffer data lookup\n// This is the hack that allows\n// buffer binding.\n#define SGLptr uint\nSGLptr SGL_CURRENT_PTR = 0u;\n\nSGLptr SGL_PTR() {\n    return SGL_CURRENT_PTR++;\n}\n\nfloat SGL_PTR_LOOKUP(SGLptr ptr, uint i);\n\n#define SGL_MAX_BUFFERS 8\nSGLptr SGL_BUFFER_DATA[SGL_MAX_BUFFERS];\nGLuint SGL_CURRENT_BUFFER = 0u;\n\nvec3 SGL_CLEAR_COLOR;\nfloat SGL_CLEAR_DEPTH;\n\n// SGL Commands //\nstruct SGLcmd {\n    uint id;\n    uint arg0;\n    uint arg1;\n};\n\n\n#define SGL_MAX_COMMANDS 8\nSGLcmd SGL_COMMANDS[SGL_MAX_COMMANDS];\nGLuint SGL_CURRENT_COMMAND = 0u;\n\n#define SGL_CMD_CLEAR \t\t\t0u\n#define SGL_CMD_DRAW_ARRAYS \t1u\n#define SGL_CMD_DRAW_ELEMENTS \t2u\n\n// Shaders //\nstruct FragmentPayload {\n    vec4 pos;\n    vec3 norm;\n    vec2 uv;\n};\n    \nvoid InterpolatePayload(out FragmentPayload payload,\n                        in FragmentPayload f0,\n                        in FragmentPayload f1,\n                        in FragmentPayload f2,\n                        in vec4 test) {\n    payload.pos = (f1.pos * test.y) +\n        \t\t  (f2.pos * test.z) +\n        \t\t  (f0.pos * test.w);\n    payload.norm = (f1.norm * test.y) +\n        \t\t  (f2.norm * test.z) +\n        \t\t  (f0.norm * test.w);\n    payload.uv = (f1.uv * test.y) +\n        \t\t  (f2.uv * test.z) +\n        \t\t  (f0.uv * test.w);\n}\n\nvoid SGL_VERTEX_SHADER(in vec4 vPos, out FragmentPayload payload, out vec4 fragCoord);\nvoid SGL_FRAGMENT_SHADER(in FragmentPayload payload, out vec4 fragColor);\n\n// Rasterization and SGL command processing //\n\n// Stolen from https://www.shadertoy.com/view/MdS3Rz\n\nvec4 inTriangle(vec2 p0, vec2 p1, vec2 p2, vec2 p)\n{\n\tfloat a = 0.5*(-p1.y*p2.x + p0.y*(-p1.x + p2.x) + p0.x*(p1.y - p2.y) + p1.x*p2.y);\n\tfloat s = 1.0/(2.0*a)*(p0.y*p2.x - p0.x*p2.y + (p2.y - p0.y)*p.x + (p0.x - p2.x)*p.y);\n\tfloat t = 1.0/(2.0*a)*(p0.x*p1.y - p0.y*p1.x + (p0.y - p1.y)*p.x + (p1.x - p0.x)*p.y);\n\t\n\tif (s > 0.0 && t > 0.0 && 1.0 - s - t > 0.0) {\n\t\treturn vec4(1.0,s,t,1.0-s-t);\n\t} else {\n\t\treturn vec4(0.0,s,t,1.0-s-t);\n\t}\n}\n\nvoid triangle(inout vec4 c, vec2 p, vec4 pt0, vec4 pt1, vec4 pt2, \n              in FragmentPayload f0,\n              in FragmentPayload f1,\n              in FragmentPayload f2)\n{\n\tvec4 test = inTriangle(pt0.xy / pt0.w, pt1.xy / pt1.w, pt2.xy / pt2.w, p);\n\t\n\tif (test.x != 0.0) {\n\t\tfloat z = ((pt1.z * test.y) / pt1.w +\n\t\t\t\t   (pt2.z * test.z) / pt2.w +\n\t\t\t\t   (pt0.z * test.w) / pt0.w) /\n\t\t\t\t\t(test.y / pt1.w +\n\t\t\t\t\t test.z / pt2.w +\n\t\t\t\t\t test.w / pt0.w);\n\t\tif (z > 0. && z < c.w) {\n            // Interpolate fragment payloads\n            // based on barycentric coordinates\n            FragmentPayload payload;\n            InterpolatePayload(payload, f0, f1, f2, test);\n            \n            // TODO: Make user provide normal data\n            vec3 a = normalize(f1.pos.xyz - f2.pos.xyz);\n            vec3 b = normalize(f1.pos.xyz - f0.pos.xyz);\n            payload.norm = -normalize(cross(a, b));\n            \n            vec4 fragColor;\n            SGL_FRAGMENT_SHADER(payload, fragColor);\n            c = vec4(fragColor.rgb, z);\n\t\t}\n\t}\n}\n\nvoid sglInit(vec2 uv) {\n\tSGL_UV = uv;\n}\n\nvoid sglFlush() {\n    FragmentPayload f0, f1, f2;\n    \n    // Rasterize drawing commands\n    \n    for (uint c = 0u; c < SGL_CURRENT_COMMAND; ++c) {\n        SGLcmd cmd = SGL_COMMANDS[c];\n        switch (cmd.id) {\n            \n        case SGL_CMD_CLEAR:\n            SGL_COLOR.rgb = SGL_CLEAR_COLOR;\n            SGL_COLOR.w = SGL_CLEAR_DEPTH;\n            break;\n            \n        case SGL_CMD_DRAW_ARRAYS:\n            GLuint buffer = SGL_VAO_STATES[SGL_BOUND_VAO].BoundArrayBuffer;\n    \t\tSGLptr ptr = SGL_BUFFER_DATA[buffer-1u];\n            // Draw triangles\n            uint count = cmd.arg0;\n            for (uint t = 0u; t < (count / 3u); ++t) {\n                vec4 p0 = vec4(SGL_PTR_LOOKUP(ptr, t*9u),\n                               SGL_PTR_LOOKUP(ptr, t*9u + 1u),\n                               SGL_PTR_LOOKUP(ptr, t*9u + 2u), 1.);\n                SGL_VERTEX_SHADER(p0, f0, p0);\n                vec4 p1 = vec4(SGL_PTR_LOOKUP(ptr, t*9u + 3u),\n                               SGL_PTR_LOOKUP(ptr, t*9u + 4u),\n                               SGL_PTR_LOOKUP(ptr, t*9u + 5u), 1.);\n                SGL_VERTEX_SHADER(p1, f1, p1);\n                vec4 p2 = vec4(SGL_PTR_LOOKUP(ptr, t*9u + 6u),\n                               SGL_PTR_LOOKUP(ptr, t*9u + 7u),\n                               SGL_PTR_LOOKUP(ptr, t*9u + 8u), 1.);\n                SGL_VERTEX_SHADER(p2, f2, p2);\n                triangle(SGL_COLOR, SGL_UV, p0, p1, p2, f0, f1, f2);\n            }\n            break;\n            \n        case SGL_CMD_DRAW_ELEMENTS:\n            buffer = SGL_VAO_STATES[SGL_BOUND_VAO].BoundArrayBuffer;\n    \t\tSGLptr vptr = SGL_BUFFER_DATA[buffer-1u];\n            SGLptr iptr = cmd.arg1;\n            // Draw triangles\n            uint icount = cmd.arg0;\n            for (uint i = 0u; i < icount; i+=3u) {\n                uint i0 = uint(SGL_PTR_LOOKUP(iptr, i));\n                vec4 p0 = vec4(SGL_PTR_LOOKUP(vptr, i0*3u),\n                               SGL_PTR_LOOKUP(vptr, i0*3u + 1u),\n                               SGL_PTR_LOOKUP(vptr, i0*3u + 2u), 1.);\n                SGL_VERTEX_SHADER(p0, f0, p0);\n                uint i1 = uint(SGL_PTR_LOOKUP(iptr, i+1u));\n                vec4 p1 = vec4(SGL_PTR_LOOKUP(vptr, i1*3u),\n                               SGL_PTR_LOOKUP(vptr, i1*3u + 1u),\n                               SGL_PTR_LOOKUP(vptr, i1*3u + 2u), 1.);\n                SGL_VERTEX_SHADER(p1, f1, p1);\n                uint i2 = uint(SGL_PTR_LOOKUP(iptr, i+2u));\n                vec4 p2 = vec4(SGL_PTR_LOOKUP(vptr, i2*3u),\n                               SGL_PTR_LOOKUP(vptr, i2*3u + 1u),\n                               SGL_PTR_LOOKUP(vptr, i2*3u + 2u), 1.);\n                SGL_VERTEX_SHADER(p2, f2, p2);\n                triangle(SGL_COLOR, SGL_UV, p0, p1, p2, f0, f1, f2);\n            }\n            break;\n            \n        }\n    }\n    \n    SGL_CURRENT_COMMAND = 0u;\n}\n\nvec4 sglPixel() {    \n    sglFlush();\n    \n    return vec4(SGL_COLOR.rgb, 1.);\n}\n\n\n// GL Entrypoints\n\nvoid glGenVertexArrays(in GLsizei n, out GLuint array) {\n    for (GLsizei i = 0u; i < n; ++i) {\n        GLuint currPlusOne = SGL_CURRENT_VAO + 1u;\n        SGL_CURRENT_VAO = currPlusOne;\n    }\n}\n\nvoid glBindVertexArray(in GLuint array) {\n    SGL_BOUND_VAO = array;\n}\n\nvoid glGenBuffers(in GLsizei n, out GLuint buffer) {\n    for (GLsizei i = 0u; i < n; ++i) {\n        GLuint currPlusOne = SGL_CURRENT_BUFFER + 1u;\n        SGL_CURRENT_BUFFER = currPlusOne;\n        buffer = currPlusOne;\n    }\n}\n\nvoid glBindBuffer(in GLenum target, in GLuint buffer) {\n    switch (target) {\n    case SGL_ARRAY_BUFFER:\n    \tSGL_VAO_STATES[SGL_BOUND_VAO].BoundArrayBuffer = buffer;\n        break;\n    }\n}\n\nvoid glBufferData(in GLenum target, in GLsizeiptr size, in SGLptr data, in GLenum usage) {\n    GLuint buffer = SGL_VAO_STATES[SGL_BOUND_VAO].BoundArrayBuffer;\n    SGL_BUFFER_DATA[buffer-1u] = data;\n}\n\nvoid glClearColor(float r, float g, float b, float a) {\n    SGL_CLEAR_COLOR = vec3(r, g, b);\n}\n\nvoid glClearDepth(float depth) {\n    SGL_CLEAR_DEPTH = depth;\n}\n\nvoid glClear(GLbitfield mask) {\n    SGL_COMMANDS[SGL_CURRENT_COMMAND] = SGLcmd(SGL_CMD_CLEAR, 0u, 0u);\n    SGL_CURRENT_COMMAND++;\n}\n\nvoid glDrawArrays(in GLenum mode, in GLint first, in GLsizei count) {\n    // Encode number of primitives to draw in CMD\n    SGL_COMMANDS[SGL_CURRENT_COMMAND] = SGLcmd(SGL_CMD_DRAW_ARRAYS, count, 0u);\n    SGL_CURRENT_COMMAND++;\n    \n    \n    // Need to execute commands so that current\n    // uniform state is contained in calculated\n    // pixel colors.\n    sglFlush();\n}\n\nvoid glDrawElements(in GLenum mode, in GLsizei count, in GLenum type, in SGLptr indices) {\n    SGL_COMMANDS[SGL_CURRENT_COMMAND] = SGLcmd(SGL_CMD_DRAW_ELEMENTS, count, indices);\n    SGL_CURRENT_COMMAND++;\n    sglFlush();\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}