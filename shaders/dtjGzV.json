{
    "Shader": {
        "info": {
            "date": "1673665767",
            "description": "My first shader featuring noise-based terrain. I did some *interesting* things with the raymarching code as well, since the terrain noise function doesn't play well otherwise. Not well optimized or documented because I couldn't be bothered to do so.",
            "flags": 0,
            "hasliked": 0,
            "id": "dtjGzV",
            "likes": 6,
            "name": "Pulsating Pyramid",
            "published": 3,
            "tags": [
                "raymarching",
                "noise",
                "terrain",
                "sky",
                "fog",
                "mountains",
                "lights"
            ],
            "usePreview": 0,
            "username": "A_Toaster",
            "viewed": 236
        },
        "renderpass": [
            {
                "code": "#define EPS 0.00001\n#define MAX_DIST 1500.\n\nconst float fog_density = 0.75;\nconst float fog_falloff = 4.;\nconst float atmo_density = 0.001;\nconst float atmo_falloff = 0.02;\n\nconst vec3 moon_dir = normalize(vec3(0.3, 0.5, 1.));\n\nconst vec3 moon_col =  vec3(0.20, 0.27, 0.75) * 0.1;\n//const vec3 moon_col =  vec3(1.);\n\nconst vec3 orb_col =  vec3(1., 0.6, 0.1);\n\nconst float moon_size = 0.1;\n\nconst vec3 flat_albedo = vec3(0.9, 0.9, 0.9);\nconst vec3 wall_albedo = vec3(0.3, 0.15, 0.15);\nconst vec3 low_albedo = vec3(0.7, 0.7, 0.7);\nconst vec3 pyr_albedo = vec3(0.05, 0.05, 0.05);\nconst vec3 pyr_top_albedo = vec3(1., 1., 0.5);\n\nvec2 hash2( vec2 p )\n{\n\t// texture based white noise\n\treturn textureLod( iChannel0, (p+0.5)/256.0, 0.0 ).xy;\n\t\n    // procedural white noise\t\n\t//return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n\nfloat mountain( in vec2 x )\n{\n    vec2 n1 = texture(iChannel0, x * 0.01).xy;\n    vec2 n2 = texture(iChannel0, (x + n1) * 0.005).xy;\n    float n3 = texture(iChannel0, (x - n2 * 1.) * 0.2).z;\n    float n4 = texture(iChannel0, (x - n2 * 0.5) * 0.4).y;\n    float n5 = texture(iChannel0, x * 0.8).x;\n    x.y = x.y * 0.5;\n    x = x + n2 * 0.25;\n    \n    vec2 p = floor( x );\n    vec2  f = fract( x );\n\n    vec2 res = vec2( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 b = vec2(i, j);\n        vec2  r = vec2(b) - f + hash2(p + b);\n        float d = dot(r, r);\n\n        if( d < res.x )\n        {\n            res.y = res.x;\n            res.x = d;\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    float h = smoothstep(0., 1.75, -res.x + res.y);\n    h = h + ( h * n3 * 0.05) + n4 * 0.005 + n5 * 0.005;\n    return h;\n}\n\nfloat mountain_ring( in vec2 x ) {\n    x = x * 0.2;\n    float circle = smoothstep(2. * 2., 10. * 10., dot(x, x)) + 0.05;\n    float m  = mountain(x * 0.3) * 1.0;\n    return m * circle * 5.;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Bound, not exact\nfloat sdOctahedron( vec3 p, float s)\n{\n    p = abs(p);\n    float m = (p.x + p.y + p.z - s) / 3.0;\n    vec3 o = p - m;\n    vec3 k = min(o, 0.0);\n    o = o + (k.x + k.y + k.z) * 0.5 - k * 1.5;\n    o = clamp(o, 0.0, s); \n    return length(p - o) * sign(m);\n}\n\nfloat map( in vec3 p ) {\n    float mtn_dist = p.y - mountain_ring(p.xz);\n    if(dot(p, p) < 20.){\n        return min(\n            min(\n                p.y - mountain_ring(p.xz),\n                min(\n                    sdOctahedron(abs(p) * vec3(1., 0.5, 1.) - vec3(2.5, 0.4, 1.1), 0.15),\n                    sdOctahedron(abs(p) * vec3(1., 0.5, 1.) - vec3(1.1, 0.4, 2.5), 0.15)\n                )\n            ),\n            min(\n                sdPyramid(p * 0.75, 0.75),\n                sdBox(p, vec3(0.8, 0.05, 0.8))\n            )\n        );\n    }\n    return mtn_dist;\n}\n\nbool mat_pyramid( in vec3 p ){\n    if(dot(p, p) > 20.) return false;\n    float mtn_dist = p.y - mountain_ring(p.xz);\n    float pyr_dist = \n            min(\n                min(\n                    sdOctahedron(abs(p) * vec3(1., 0.5, 1.) - vec3(2.5, 0.4, 1.1), 0.15),\n                    sdOctahedron(abs(p) * vec3(1., 0.5, 1.) - vec3(1.1, 0.4, 2.5), 0.15)\n                ),\n                min(\n                    sdPyramid(p * 0.75, 0.75),\n                    sdBox(p, vec3(0.8, 0.05, 0.8))\n                )\n            );\n    return pyr_dist < mtn_dist;\n}\n\n\n// From https://www.shadertoy.com/view/XdsGDB\n// Set up a camera looking at the scene.\n// origin - camera is positioned relative to, and looking at, this point\n// distance - how far camera is from origin\n// rotation - about x & y axes, by left-hand screw rule, relative to camera looking along +z\n// zoom - the relative length of the lens\nvoid CamPolar( out vec3 pos, out vec3 ray, in vec3 origin, in vec2 rotation, in float distance, in float zoom, in vec2 fragCoord )\n{\n\t// get rotation coefficients\n\tvec2 c = vec2(cos(rotation.x),cos(rotation.y));\n\tvec4 s;\n\ts.xy = vec2(sin(rotation.x),sin(rotation.y)); // worth testing if this is faster as sin or sqrt(1.0-cos);\n\ts.zw = -s.xy;\n\n\t// ray in view space\n\tray.xy = fragCoord.xy - iResolution.xy*.5;\n\tray.z = iResolution.y*zoom;\n\tray = normalize(ray);\n\t\n\t// rotate ray\n\tray.yz = ray.yz*c.xx + ray.zy*s.zx;\n\tray.xz = ray.xz*c.yy + ray.zx*s.yw;\n\t\n\t// position camera\n\tpos = origin - distance*vec3(c.x*s.y,s.z,c.x*c.y);\n}\n\n// From https://iquilezles.org/articles/normalsSDF/\nvec3 calcNormal( in vec3 pos, float dist )\n{\n    float h = max(0.01, 0.001 * dist);\n    #define ZERO (min(iFrame,0)) // non-constant zero\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*h);\n    }\n    return normalize(n);\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<32; i++ )\n    {\n        h = map(ro + rd*t);\n        res = min( res, k*h/t );\n\t\tt += clamp( h, 0.01, 1. );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat softshadow_point( in vec3 ro, in vec3 rd, float mint, float k, float max_dist)\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<64; i++ )\n    {\n        vec3 p = ro + rd*t;\n        \n        h = map(p);\n        res = min( res, k*h/t );\n\t\tt = t + clamp( h, 0.02 + 0.5 * step(20., dot(p, p)), 2. );\n        if(t > max_dist) {\n            break;\n        }\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );\n}\n\n\nbool intersect_precise( in vec3 ro, in vec3 rd, out float dist , out vec3 norm, out int i)\n{\n\tfloat h = 1.0;\n\tdist = 0.0;\n    for(  i=0; i<256; i++ )\n    {\n\t\tif( h < EPS * dist){\n            norm = calcNormal(ro + rd * dist, dist);\n            return true;\n        }\n\t\th = map(ro + rd * dist);\n        dist += h;\n\t\tif( dist > MAX_DIST) return false;\n    }\n    norm = calcNormal(ro + rd * dist, dist);\n    return dot(norm, rd) < 0.2;\n}\n\n// https://iquilezles.org/articles/spherefunctions/\nvec2 sphDistances( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float dist,     // camera to point distance\n               in vec3  rayOri,   // camera position\n               in vec3  rayDir )  // camera to point vector\n{\n    float fogAmount = (fog_density/fog_falloff) * exp(-rayOri.y*fog_falloff) * (1.0-exp( -dist*rayDir.y*fog_falloff ))/rayDir.y;\n    float atmosAmount = (atmo_density/atmo_falloff) * exp(-rayOri.y*atmo_falloff) * (1.0-exp( -dist*rayDir.y*atmo_falloff ))/rayDir.y;\n    float amount = fogAmount + atmosAmount;\n    return mix(moon_col, rgb, exp(-amount));\n}\n\nvec3 sky( in vec3  rgb,      // original color of the pixel\n          in vec3  rayDir )\n{\n    float yi = 1./clamp(rayDir.y, 0.01, 1.);\n    \n    vec2 cloud_uv = rayDir.xz * yi;\n    \n    float cloud = max(0., texture(iChannel1, cloud_uv * vec2(0.1, 0.02)).r - 0.3) * texture(iChannel1, cloud_uv * vec2(0.2, 0.1)).r * rayDir.y * 0.1;\n    \n    // atmosphere amount\n    float amount = (fog_density/fog_falloff + atmo_density/atmo_falloff) * yi;\n    return mix(moon_col, rgb, exp(-amount)) + vec3(1.) * cloud;\n}\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat glare(vec2 uv, vec2 pos, float size, float origin_size)\n{\n    float dist = length(pos - uv);\n    float strength = clamp((size - dist) / size, 0., 1.);\n    strength = pow5(strength);\n    \n    float angle = atan(uv.y - pos.y, uv.x - pos.x);\n    float noise = mix(0.5, texture(iChannel0, vec2(0., angle * 0.07)).x, dist / origin_size);\n    return strength * noise;\n}\n\nvec3 encodeSRGB(vec3 linearRGB)\n{\n    vec3 a = 12.92 * linearRGB;\n    vec3 b = 1.055 * pow(linearRGB, vec3(1.0 / 2.4)) - 0.055;\n    vec3 c = step(vec3(0.0031308), linearRGB);\n    return mix(a, b, c);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.xx;\n    \n    //float m = mountain_ring(uv * 20.);\n    \n    \n    vec2 camRot = vec2(.5,.5)+vec2(-.6,4.5)*(iMouse.yx/iResolution.yx);\n\tvec3 pos, ray;\n\tCamPolar( pos, ray, vec3(0., 1.2, 0.), camRot, 15.0, 1.0, fragCoord );\n    \n    float orb_seq = pow(fract(iTime * 0.08), 2.);\n    float orb_radius = 0.02 / (orb_seq * orb_seq) + 0.01;\n    orb_radius += max(0., (orb_seq - 0.5) * 100.);\n    float orb_intensity = max(0., 0.5 / (orb_radius * orb_radius) - 0.005);\n\n    if(orb_seq > 0.5){\n        orb_intensity = 120. * pow(1. - smoothstep(0.3, 1., orb_seq), 3.);\n    }\n    \n    vec2 orb = sphDistances(pos, ray, vec3(0., 1.2 + 0.25 * orb_radius, 0.), orb_radius);\n    vec2 orb2 = sphDistances(pos, ray, vec3(0., 1.2 + 0.25 * orb_radius, 0.), orb_radius - 0.05);\n    \n    float orb_power = glare(uv, vec2(0.), 0.75, orb_radius * 20.) * orb_intensity * 0.1;\n    \n    float point_light_r = max(20. / orb_radius, 5.);\n    float point_light_height = 1.2 + orb_radius * 0.25;\n    float point_light_power = pow(orb_intensity * orb_radius * 10., 1.);\n    \n    float dist;\n    int i;\n    vec3 normal;\n    bool hit = intersect_precise(pos, ray, dist, normal, i);\n    vec3 col;\n    if(hit) {\n        vec3 hp = pos + ray * dist;\n        \n        \n        vec3 albedo;\n        float spec;\n        if(mat_pyramid(hp)){\n            float tip = smoothstep(0.8, 0.805, hp.y);\n            spec = tip * 0.9;\n            albedo = mix(pyr_albedo, pyr_top_albedo, tip);\n        } else {\n            float wall_amount = smoothstep(0.7, 0.9, dot(normal, vec3(0., 1., 0.)));\n            float low_amount = smoothstep(0.0, 0.02, hp.y);\n        \n            albedo = mix(wall_albedo, mix(low_albedo, flat_albedo, low_amount), wall_amount);\n            spec = mix(0.4, 0.0, wall_amount);\n        }\n        \n        float ao = calcAO(hp, normal);\n        float shadow = softshadow(hp, moon_dir, 0.01, 20.);\n        float diffuse = smoothstep(-1., 1., dot(normal, moon_dir));\n        float spec_brightness = pow5(dot(reflect(ray, normal), moon_dir));\n        \n        vec3 moonlit_col = shadow * ao * mix(albedo * moon_col * diffuse, moon_col * spec_brightness, spec);\n        vec3 pointlit_col = vec3(0.);\n        \n        \n        vec3 point_light_col = orb_col * point_light_power;\n        if(point_light_power > 0.){\n            vec3 point_light_ro = vec3(0., point_light_height, 0.);\n\n            vec3 point_light_dir = point_light_ro - hp;\n            float point_light_dist = length(point_light_dir);\n            float distance_atten = 1. / (point_light_dist );\n            point_light_dir = point_light_dir / point_light_dist;\n\n            float point_shadow = softshadow_point(hp, point_light_dir, 0.01, point_light_r, point_light_dist - 1.);\n\n            float pt_diffuse = smoothstep(-1., 1., dot(normal, point_light_dir));\n            float pt_spec_brightness = pow5(dot(reflect(ray, normal), point_light_dir));\n            \n            pointlit_col = distance_atten * point_shadow * mix(albedo * point_light_col * pt_diffuse, point_light_col * pt_spec_brightness, spec);\n        }\n        \n        float orb_occ = (smoothstep(orb.x, orb.x + 0.3 * orb_radius, dist) * smoothstep(0., 2., orb.x) + smoothstep(orb.y, orb.y + 0.3 * orb_radius, dist)) * 0.5;\n        //if(orb2.y > orb2.x)\n        orb_power += max(0., orb.y - orb.x - orb2.y + orb2.x) * orb_intensity * 10. * orb_occ;\n        \n        col = moonlit_col + pointlit_col;\n        col = applyFog(col, dist, pos, ray);\n    } else {\n        col = sky(vec3(0.), ray);\n        \n        orb_power += max(0., orb.y - orb.x - orb2.y + orb2.x) * orb_intensity * 10.;\n    }\n    \n    col += orb_col * orb_power;\n    // Output to screen\n    fragColor = vec4(encodeSRGB(col),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}