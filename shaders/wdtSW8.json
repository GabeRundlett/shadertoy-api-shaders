{
    "Shader": {
        "info": {
            "date": "1571919565",
            "description": "A minimalist burning forest. I tried to make an animated version of my avatar but ended up swapping the color scheme on its head because it didn't look right.",
            "flags": 0,
            "hasliked": 0,
            "id": "wdtSW8",
            "likes": 13,
            "name": "Burning Forrest",
            "published": 3,
            "tags": [
                "2d",
                "minimalism"
            ],
            "usePreview": 0,
            "username": "SSHantaram",
            "viewed": 448
        },
        "renderpass": [
            {
                "code": "const float PI = 3.141592;\n\n//From http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint hash(uvec2 x) {\n    x = uvec2(0x3504f333, 0xf1bbcdcb)*x; \n    return (x.x^x.y) * 741103597u;\n}\n\n//From https://iquilezles.org/articles/sfrand\nfloat uintBitsToFloat01(uint x) {\n    return uintBitsToFloat((x >> 9u) | 0x3f800000u) - 1.0;\n}\n\nfloat hash(vec2 p) {\n    uvec2 x = floatBitsToUint(p);\n    return uintBitsToFloat01(hash(x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\t//normalize uv\n    \n    // evaluate functions from top to bottom\n    // update result if point is under the function\n    \n    float result = 0.0;\n    int iterCount = 15;\t// number of horizontal bands\n    for (int i = 0; i < iterCount; i++)\n    {\t\n        float iteration = float(i);\n        \n        // transform uv differently for each band (paralax effect)\n        vec2 p = uv;\n        p.x += 0.005*iTime*max(iteration, 8.0);\n        \n        float scale = 80.0;\t// number of divisions (line segments) on screen\n        \n        // reduce divisions for fire/smoke (top 10 bands)\n        if (iteration < 10.0) scale *= pow(0.82, 10.0 - iteration);\n        \n        // get positions of closest sample poins and calculate interpolation value\n    \tfloat leftNeighbour = floor(scale*p.x)/scale;\n    \tfloat rightNeighbour = floor(scale*p.x + 1.0)/scale;\n    \tfloat t = (p.x - leftNeighbour) / (rightNeighbour - leftNeighbour);\n        \n        // setup values\n    \tfloat freq = 145.0;\n        float freq2 = 35.0;\n        float freq3 = 15.0;\n    \tfloat amp = 0.1;\n    \tfloat amp2 = 0.05;\n        float amp3 = 0.02;\n        \n        // different phase for forrest (looks chaotic)\n        float phase = hash(vec2(iteration, 0.0))*PI;\n        float phase2 = hash(vec2(iteration, 0.0))*PI;\n        float phase3 = hash(vec2(iteration, 0.0))*PI;\n        \n        // change some values for fire/smoke (top 10 bands)\n        if (iteration < 10.0)\n        {\n            amp *= pow(0.7, 10.0 - iteration);\n            amp2 *= pow(1.1, 10.0 - iteration);\n            amp3 *= pow(1.3, 10.0 - iteration);\n            \n            // same phase for smoke/fire\n            phase = -(iTime*0.4)*PI;\n\t\t\tphase2 = -(iTime*0.4)*PI;\n        }\n        \n        // function evaluated at left point\n    \tfloat leftVal = amp*(1.0 + sin(freq*leftNeighbour + phase)) +\n            \t\t\tamp2*(1.0 + sin(freq2*leftNeighbour + phase2)) + \n            \t\t\tamp3*(1.0 + sin(freq3*leftNeighbour + phase3));\n        \n        // function evaluated at right point\n    \tfloat rightVal = \tamp*(1.0 + sin(freq*rightNeighbour + phase)) +\n            \t\t\t\tamp2*(1.0 + sin(freq2*rightNeighbour + phase2)) +\n            \t\t\t\tamp3*(1.0 + sin(freq3*rightNeighbour + phase3));\n        \n        // linear interpolation of function between closest sample points\n        // this gives streight lines between points\n    \tfloat val = (1.0 - t)*leftVal + t*rightVal;\n    \n        // update result if point is under the function\n    \tif (uv.y < val + 0.8 - iteration/float(iterCount)) result = iteration/float(iterCount);\n    }\n    \n    vec3 col = vec3(0);\t\t// init color as black\n    result = 1.0 - result;\t// invert result (1.0 on top, 0.0 at the bottom)\n    \n    // get color from result: [0.0, 1.0] => rgb\n    col.r = result;\n    col.g = pow(result, 2.5)*0.75;\t\t\t// exponential function to get yellow-red gradient\n    col.b = (1.0 - result)*0.02 + 0.01;\t\t// add a little blue\n    col -= vec3(1)*uv.y*result*0.2;\t\t\t// add gradient within bands\n    \n    fragColor = vec4(col,1.0);\t// Output to screen\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}