{
    "Shader": {
        "info": {
            "date": "1510235141",
            "description": "MANTA RAYS\n\nIN SPACE\n\nEMBEDDED IN LIGHT RAYS\n\nWhat else is there to say?",
            "flags": 0,
            "hasliked": 0,
            "id": "XlByW3",
            "likes": 3,
            "name": "Space Mantas",
            "published": 3,
            "tags": [
                "lighting",
                "space",
                "volumetric",
                "stars",
                "mantaray"
            ],
            "usePreview": 0,
            "username": "DrLuke",
            "viewed": 983
        },
        "renderpass": [
            {
                "code": "// This work is licensed under a Creative Commons Attribution 4.0 International License.\n// https://creativecommons.org/licenses/by/4.0/\n\n// Inspiration: http://kingsanda.tumblr.com/post/148863003357/schim-schimmel\n\n// I tried building a distance function for dolphins, but gave up. I need better tools for doing that.\n// Maybe even some tool to approximate 3d models with distance functions?\n\n\n\n/* Borrowed functions */\n\n// The MIT License\n// Copyright © 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// From: https://www.shadertoy.com/view/XsXSz4\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// From: https://www.shadertoy.com/view/Xds3zN\nfloat opSMerge(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5*(d2 - d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0-h);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nvec3 CR2(float u, vec3 x0, vec3 x1, vec3 x2, vec3 x3 ) //returns value between x1 and x2\n{\n    return ((2. * x1) + \n            (-x0 + x2) * u + \n            (2.*x0 - 5.*x1 + 4.*x2 - x3) * u * u + \n            (-x0 + 3.*x1 - 3.*x2 + x3) * u *u * u) * 0.5;\n}\n\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Return random noise in the range [0.0, 1.0], as a function of x.\n// From: https://www.shadertoy.com/view/Md2SR3\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n/* END OF borrowed functions */\n\nmat3 rot3(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nfloat sdManta(vec3 p)\n{\n    mat3 rotMat = rot3(vec3(0,1,0), 3.14159*0.25);\n\tfloat r = udRoundBox(rotMat*p, vec3(1,0.03,1), .04);\n    r = opSMerge(r, sdCapsule(p, vec3(0.4,0,0), vec3(-0.5,0,0), 0.2), 0.6);\n    rotMat = rot3(vec3(0,0,1), 3.14159*0.5);\n    r = opSMerge(r, sdConeSection( rotMat*(p-vec3(-2,0,0)), 1., 0.15, 0.), 0.2);\n    \n    return r;\n}\n\nvec3 nManta(vec3 p)\n{\n    #define nepsilon .05\n    return vec3(sdManta(vec3(p.x+nepsilon,p.y,p.z)) - sdManta(vec3(p.x-nepsilon,p.y,p.z)),\n    \t\t\tsdManta(vec3(p.x,p.y+nepsilon,p.z)) - sdManta(vec3(p.x,p.y-nepsilon,p.z)),\n    \t\t\tsdManta(vec3(p.x,p.y,p.z+nepsilon)) - sdManta(vec3(p.x,p.y,p.z-nepsilon)));\n}\n\n\n#define zto(a, b, x) ((x-a)/(b-a))\n#define WPFUN(wa, wb, t, p) if(t > wa.w) { p = mix(wa.xyz, wb.xyz, zto(wa.w, wb.w, t)); }\n\n#define ANIMTIME1 fract((iTime+24.)*0.005)\nvec3 anim1curve(float t)\n{\n    #define WPc 4\n    vec4[WPc] WP;\n    \n    WP[0] = vec4(-8,-16,1, 0);\t// Appear from bottom left\n    WP[1] = vec4(0,-4,15, 0.25);\t// Intersect volume\n    WP[2] = vec4(15,-1,27, 0.5);\t// Turnaround behind volume\n    WP[3] = vec4(40,-25,-15, 0.75);\t// Disappear bottom right\n    \n    int wpindx = 0;\n\tfor(int i = 0; i<WPc; i++)\t// Find out what current waypoint is\n    {\n        if(t > WP[i].w) { wpindx = i; }\n    }\n    \n    vec3 p = CR2(zto(WP[wpindx].w, ((wpindx+1) == WPc) ? 0.25 : WP[wpindx+1].w, t),\n                WP[(wpindx-1) % WPc].xyz,\n                WP[(wpindx+0)      ].xyz,\n                WP[(wpindx+1) % WPc].xyz,\n                WP[(wpindx+2) % WPc].xyz);\n    \n    return p;\n}\n\nstruct animdata\n{\n  vec3 pos;\n  mat3 rot;\n  vec3 origpos;\n};\n\nanimdata anim1(vec3 p)\n{\n    animdata ad;\n    ad.origpos = p;\n    \n    vec3 pos = anim1curve(ANIMTIME1);\n    vec3 dir = normalize(anim1curve(ANIMTIME1 + 0.01) - pos);\n    vec3 ddir = normalize(anim1curve(ANIMTIME1 + 0.1) - pos);\n    \n    float xzang = atan(dir.z, dir.x);\n    float rzang = acos(dir.y / length(dir));\n\n    mat3 rotMat = rot3(vec3(0,1,0), xzang);\n    rotMat *= rot3(vec3(0,0,1), -3.14159*0.5 + rzang);\n    \n    float bankangle = atan(ddir.z, ddir.x) - xzang;\n    bankangle = sign(bankangle) * abs(cos(bankangle*5. + 3.14159)*0.5+0.5);\n    rotMat *= rot3(vec3(1,0,0), -bankangle);\n    \n    p = inverse(rotMat)*(p - pos);\n    \n    ad.pos = p;\n    ad.rot = rotMat;\n    \n    return ad;\n}\n\nfloat lightvolume(vec3 p);\n\nvec3 color1(animdata ad, vec3 lnormal)\n{\n\t\n    vec2 uv = ad.pos.xz;\n    \n    vec3 c = vec3(0.1) + texture(iChannel2, uv*0.1).rgb*0.16*sign(lnormal.y) * (1.-pow(length(uv), 2.));\n    \n\n    float caustics = lightvolume(ad.origpos);\n    caustics =  smoothstep(0.4,1.,1.0-abs(caustics)) * 0.4 + 0.2;\n    \n    #define causticscolor vec3(0.1, 0.3, 1.4)\n    vec3 normal = ad.rot*lnormal;\n    c += causticscolor * caustics * smoothstep(0.3, 0.9, normal.y - normal.x*.5 + normal.z*.3);\n    c -= vec3(0.1) * (1.-smoothstep(0.2, 0.9, normal.y - normal.x*.5 + normal.z*.3));\n    \n    return c;\n}\n\nfloat rmScene(vec3 p)\n{\n    mat3 rotMat = rot3(vec3(0,1,sin(iTime*3.14159*0.01)*0.5), iTime*3.14159*0.5);\n\tfloat r = sdManta(anim1(p).pos);\t// Return distance\n\n    return r;\n}\n\n#define MARCHLIMIT 75\n#define MARCHSTEPFACTOR 0.6\nvec4 march(vec3 s, vec3 d)\n{\n    float dist = 1.0;\t// distance\n    for(int i = 0; i < MARCHLIMIT; i++)\n    {\n        dist += clamp(rmScene(s + d*dist)*MARCHSTEPFACTOR, -10000., 10000.);\n        if(dist > 1000.) {break;}\n    }\n    \n    animdata ad = anim1(s + d*dist);\n    vec3 lnormal = normalize(nManta(ad.pos));\t// Local space normal\n    vec3 normal = ad.rot*lnormal;\t// Global space normal\n    vec4 retval = vec4(0);\n    \n    if(length(ad.pos) < 6.)\n    {\n    \tretval.rgb = color1(ad, lnormal);\n    }\n    \n    retval.a = 1.-step(1000., dist);\t// If ray runs into infinity, mask it out, else keep in scene.\n\treturn retval;\n}\n\n// The light volume is defined by a top and bottom rectangle.\n// The corners of the rectangles are then connected.\n// To simulate lightbeams, each horizontal slice of the volume gets the same noise texture.\n// Because the bottom end is bigger than the top, an illusion of spreading beams is achieved.\n#define TOPCENTER vec3(-4.4,2.,6)\n#define TOPVOLSIZE vec2(5.2,5.2)\n#define BOTTOMCENTER vec3(-0.3,-1.,4.7)\n#define BOTVOLSIZE vec2(7,7)\n#define LIGHTVOLTIME (iTime*0.005)\nfloat lightvolume(vec3 p)\n{\n    float py = (p.y - BOTTOMCENTER.y) / (TOPCENTER.y - BOTTOMCENTER.y);\t// Get position along height of volume\n    \n    vec2 size = mix(BOTVOLSIZE, TOPVOLSIZE, py);\t// Get size of slice of volume at y\n    vec2 poffset = mix(BOTTOMCENTER.xz, TOPCENTER.xz, py);\n    vec2 uv = (p.xz - poffset) / size;\t// Convert to UV coordinate along slice\n    \n    return texture(iChannel0, vec3(uv, LIGHTVOLTIME+cos(uv))).a;\t// Get sample of volume at this point\n}\n\n// Little bit of temporal dithering works wonders to get rid of banding!\n#define LMARCHSTEPS (70 + int(sin(noise*2.*3.14159)*2.))\n#define LMARCHSCALE 5.\n#define LMARCHSTEPDIST(x) (float(x)/float(LMARCHSTEPS))\nfloat lightmarch(vec3 s, vec3 d, float noise)\n{    \n    float intval = 0.0;\n    for(int i = 0; i < LMARCHSTEPS; i++)\n    {\n        intval += lightvolume(s + d*LMARCHSTEPDIST(i)*LMARCHSCALE) + mix(-.5/255., .5/255., noise);\n    }\n    \n    intval /= float(LMARCHSTEPS);\n    \n    intval = pow(intval, 8.)*100.;\n    \n\treturn intval;\n}\n\nvec3 bg(vec2 uv, vec2 fragCoord)\n{\n    float starmask = sdTriangle(vec2(1.8, 1.), vec2(1.2,-0.6), vec2(0.2, -0.86), vec2(uv.x + uv.x * uv.y * 0.6, uv.y));\n    starmask = min(starmask, sdTriangle(vec2(-2.5, 1.), vec2(-1.7,-0.6), vec2(-0.9, -0.86), vec2(uv.x + uv.x * uv.y * 0.6, uv.y))*0.5);\n    \n    float genericstardensity = 0.998 - smoothstep(0.2, -0.4, starmask + texture(iChannel1, uv*0.01).z*0.3 ) *0.2 - texture(iChannel1, uv*0.1).z*0.01;\n    float genericstars = StableStarField(fragCoord*2.5, genericstardensity);\n    vec3 starcol = (vec3(1) + texture(iChannel1, uv*0.1).rgb*0.4) * genericstars;\n    \n    return vec3(starcol);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ((fragCoord.xy * 2.0) / iResolution.xy) - vec2(1);\t// Make UV go from -1 to 1 instead of 0 to 1\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 s = vec3(0,0,0);\n    #define FOCALLEN 1.1\n    vec3 d = vec3(uv, FOCALLEN);\n    \n    vec4 marchdata = march(s, d);\n    \n    float n = texture(iChannel1, fragCoord.xy/iChannelResolution[1].xy + vec2(iTime*10.5192, iTime*0.8542)).x;\t// Noise for dithering\n    float lmarchval = lightmarch(s, d, n);\n\tfloat lmask = sdTriangle(vec2(-1.6, 1.), vec2(0.8,-0.6), vec2(-0.4, -0.86), uv);\n    float beammask = smoothstep(0.6,-0.6, lmask)*lmarchval + mix(-0.5/256., 0.5/256., n);\n    \n    #define beamcolor vec3(0.1, 0.5, 1.4)\n    fragColor = vec4(bg(uv, fragCoord), 0);\n\t\n    fragColor.rgb = mix(fragColor.rgb, marchdata.rgb, marchdata.a);\n    fragColor.rgb += mix(beamcolor*beammask, vec3(0), marchdata.a - smoothstep(-.8,0.4,uv.x));\t// Alphablend raymarched geometry over scene\n    \n    fragColor.a = 1.0;\n    //fragColor.rgb = anim1curve(fract(iTime*0.1));\n    //if(uv.x > 0.0) { fragColor.rgb = vec3(fract(iTime*0.1)); }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}