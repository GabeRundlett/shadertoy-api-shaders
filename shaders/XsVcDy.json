{
    "Shader": {
        "info": {
            "date": "1523238126",
            "description": "Mouse to zig-zag through alphabet; click in lower left to return to animation.",
            "flags": 0,
            "hasliked": 0,
            "id": "XsVcDy",
            "likes": 210,
            "name": "glyphspinner",
            "published": 3,
            "tags": [
                "text",
                "font",
                "rotation",
                "mesmerizing",
                "90scolors"
            ],
            "usePreview": 0,
            "username": "mattz",
            "viewed": 5568
        },
        "renderpass": [
            {
                "code": "/* \"glyphspinner\" by mattz\n   License: https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n   I've been carrying this shader in my head for a long time, \n   glad I finally had some time to work on it!\n\n   Towards the end of developing a shader, I'm always pleased\n   if I realize I've zoned out watching it run instead of \n   putting the finishing touches on it, which certainly was\n   the case here.\n\n   Since I couldn't get the glyph edges nicely antialiased, \n   I decided to leave the backgrounda  bit rough, too, which\n   you can see if you pause the shader. \n\n*/\n\n//#define PERSPECTIVE\n\nconst vec3 bgcolor = vec3(0, 0.1, 0.1);\nconst vec3 color_a = vec3(1.0, 0.4, 0);\nconst vec3 color_b = vec3(0.3, 0, 0.7);\nconst vec3 outline = vec3(1, 0, 0.2);\n\nfloat t = 0.0;\n\n// texture is 1024x1024\nconst float TEX_RES = 1024.;\n\n// texture is 16x16 glyphs\nconst float GLYPHS_PER_UV = 16.;\n\n// since the texture is uint8 it has a bias to represent 0\nconst float TEX_BIAS = 127./255.;\n\n// get font UV coords from screen coords\nvec2 font_from_screen(vec2 tpos, vec2 char_pos) {    \n    return (tpos + char_pos + 0.5)/GLYPHS_PER_UV;\n}\n\n\nfloat sample_dist_gaussian(vec2 uv) {\n\n    float dsum = 0.;\n    float wsum = 0.;\n    \n    const int nstep = 3;\n    \n    const float w[3] = float[3](1., 2., 1.);\n    \n    for (int i=0; i<nstep; ++i) {\n        for (int j=0; j<nstep; ++j) {\n            \n            vec2 delta = vec2(float(i-1), float(j-1))/TEX_RES;\n            \n            float dist = textureLod(iChannel0, uv-delta, 0.).w - TEX_BIAS;\n            float wij = w[i]*w[j];\n            \n            dsum += wij * dist;\n            wsum += wij;\n\n        }\n    }\n    \n    return dsum / wsum;\n}\n\n\n/* Rotate about x-axis */\nmat3 rotX(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\n\n/* Rotate about y-axis */\nmat3 rotY(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n\n}\n\n\nfloat approx_font_dist(vec2 p, int cidx) {\n\n    float d = max(abs(p.x) - 0.25,\n                  max(p.y - 0.3, -0.28 - p.y));\n    \n    vec2 cpos = vec2(float(cidx%16), float(15-cidx/16));\n    vec2 uv = font_from_screen(p, cpos);\n    \n    float fd = sample_dist_gaussian(uv); \n        \n    \n    d = max(d, fd);\n        \n    \n    return d;\n    \n}\n\nvec3 map(in vec3 pos) {\t\n\n    int ca = int(t) % 26;\n    int cb = (ca + 1) % 26;\n    int cc = (ca + 2) % 26;\n\n    float da = approx_font_dist(pos.xy, 65+ca);\n    float dc = approx_font_dist(pos.xy, 65+cc);\n    \n    float ft = fract(t);\n    \n    if (ft > 0.95) {\n        da = mix(min(da, dc), dc, smoothstep(0.95, 1.0, ft));\n    } else if (ft > 0.9) {\n        da = mix(da, min(da, dc), smoothstep(0.9, 0.95, ft));\n    }\n                   \n    float db = approx_font_dist(pos.zy, 65+cb);\n                   \n    \n    return vec3(max(da, db), da, db);\n   \n}\n\n/* IQ's distance marcher. */\nvec3 castRay( in vec3 ro, in vec3 rd) {\n    \n    const int rayiter = 80;\n    const float dmax = 8.;\n\n    const float precis = 0.001;   \n    float h=2.0*precis;\n\n    float t = 0.0;\n    vec2 m = vec2(-1.0);\n\n    for( int i=0; i<rayiter; i++ ) {\n\n        if( abs(h)<precis||t>dmax ) { continue; }\n        \n        t += min(0.25, h);\n        vec3 res = map( ro+rd*t );\n        h = res.x;\n        m = res.yz;\n        \n    }    \n\n    if (t > dmax) { return vec3(-1); }\n    if (abs(h) > 4.0*precis) { return vec3(-1); }\n\n    return vec3(t, m);\n\n}\n\nvec3 shade( in vec3 ro, in vec3 rd ,\n           inout vec3 c){\n\n    vec3 tm = castRay(ro, rd);        \n\n    if (tm.x >= 0.0) {\n\n        vec3 pos = ro + tm.x*rd;\n        \n        vec3 d = map(pos);\n        \n        \n        float flip = mod(t, 2.0) < 1.0 ? -1.0 : 1.0;\n        \n        vec3 fg = mix(color_a, color_b,\n                      step(flip*d.y, flip*d.z));\n                \n        c = mix(fg, outline, smoothstep(0.003, 0.0, abs(d.y-d.z)-0.008));\n\n    }\n\n    return c;\n\n}\n\nfloat scribble(vec2 p, float k) {\n    \n    float scl = k/iResolution.y;\n    \n    float kspiral = 0.2;\n    \n    vec2 c = p*scl;\n    vec2 c0 = floor(c+0.5);\n    \n    float d = 1e5;\n    \n    for (int i=-1; i<2; ++i) {\n        for (int j=-1; j<2; ++j) {\n            \n            vec2 cij = c0 + vec2(float(i), float(j));\n                       \n            vec4 r = textureLod(iChannel1, (cij+0.5)/256., 0.);\n            cij += 0.5*(r.xy - 0.5);\n            \n            vec2 diff = c - cij;\n            float sz = 0.3 + 0.3*(r.z - 0.5);\n            \n            float t = r.z *  10253.5721;\n            float c = cos(t), s = sin(t);\n            \n            diff = mat2(c, -s, s, c) * diff;\n\n            vec2 sq = abs(diff) - sz;\n            float dsqr = max(sq.x, sq.y);\n            \n            if (r.w < 0.5) {\n                \n                if (r.w < 0.25) {\n                    d = min(d, abs(dsqr));\n                } else {\n                    float dx = abs(dot(abs(diff), normalize(vec2(-1,1))));\n                    dx = max(dx, dsqr);\n                    d = min(d, dx);\n                }\n                \n            } else if (r.w < 0.75) {\n                \n                d = min(d, abs(length(diff) - sz));\n                                \n            } else {\n                \n                diff.x = abs(diff.x);\n                \n                float dtri = max(-diff.y, \n                                 dot(diff, vec2(0.8660254037844386, 0.5)));\n                \n                d = min(d, abs(dtri-0.85*sz));\n                \n            }\n\n        }\n    }\n    \n    return step(0., d-0.1);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = (fragCoord.xy - .5*iResolution.xy) * 0.8 / (iResolution.y);\n\n    t = 0.45*max(0.0, iTime-2.0);\n    \n    float s = scribble(fragCoord + 0.45*iTime*vec2(75., 30), 7.);\n\n    vec3 bgdark = mix(bgcolor, vec3(0), 0.6);\n    vec3 bglite = mix(bgcolor, vec3(1), 0.25);\n    vec3 color = mix(bgcolor, bgdark, s);\n    \n    float rad = 0.05*iResolution.y;\n    float m = rad;\n    float x0 = m+rad;\n    \n    if (max(iMouse.x, iMouse.y) > x0) {        \n\n        float row = floor(4.0 - 4.0 * iMouse.y / iResolution.y);\n        float ux = clamp( (iMouse.x - x0) / (iResolution.x - 2.*x0), 0., 1.);\n        \n        if (mod(row, 2.0) != 0.0) { ux = 1.0 - ux; }\n        \n        t = 6.5 * (ux + row) + 1e-5;\n\n    }\n    \n    float u = fract(t);\n    u = smoothstep(0.1, 0.9, u);\n    \n    float midbump = smoothstep(0.5, 0.0, abs(u-0.5));\n\n    float thetay = -1.5707963267948966*u;\n    float thetax = 0.4*midbump;\n\n    mat3 Rview = rotY(thetay)*rotX(thetax); \n\n#ifdef PERSPECTIVE\n    const float f = 1.5;\n    vec3 rd = Rview*normalize(vec3(uv, f));\n    vec3 ro = Rview*vec3(0,0,-f);\n#else\n    vec3 rd = Rview*vec3(0, 0, 1);\n    vec3 ro = Rview*vec3(uv*0.9, -3.5);\n#endif\n    \n    if (max(iMouse.z, iMouse.w) > x0) {\n        \n        vec2 p = fragCoord - iResolution.xy*vec2(0.5, 0);\n        \n        float row = floor(4.0*fragCoord.y/iResolution.y);\n        float rowy = (row + 0.5)* iResolution.y * 0.25;\n         \n        float dx = sign(p.x);\n        float dy = mod(row, 2.0) > 0.0 ? -1.0 : 1.0;\n        dy *= dx;\n        \n        vec2 ctr = vec2(dx*(0.5*iResolution.x - x0),\n                        rowy + dy*rad);\n        \n        float dcirc = 1e5;\n        float dly = abs(p.y - rowy);\n        float dlx = abs(p.x) - (0.5*iResolution.x - m);\n        \n        if (p.x > 0.5 || (row != 0. && row != 3.)) { \n            vec2 dctr = p - ctr;\n            dcirc = abs(length(dctr) - rad);\n            dcirc = max(-dctr.x*dx, max(dctr.y*dy, dcirc));\n            dcirc = min(dcirc, max(dctr.y*-dy, abs(dctr.x-dx*rad)));\n            dlx = abs(p.x) - (0.5*iResolution.x - x0);\n        }\n        \n        float dpath = min(dcirc, max(dlx, dly)) - 2.0;\n        \n        color = mix(color, bglite, smoothstep(1., 0., dpath));\n    }\n    \n    shade(ro, rd, color);\n\n    color = pow(color, vec3(1.0/2.2));\n\n    fragColor = vec4(color, 1);\n\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}