{
    "Shader": {
        "info": {
            "date": "1457322397",
            "description": "Plastic PBR materials with irradiance cubemap progressively computed and folded in Buffer A Texture.",
            "flags": 32,
            "hasliked": 0,
            "id": "ls3Szr",
            "likes": 70,
            "name": "Irradiance cubemap",
            "published": 3,
            "tags": [
                "importancesampling",
                "hdr",
                "ibl",
                "pbr"
            ],
            "usePreview": 0,
            "username": "Bers",
            "viewed": 4863
        },
        "renderpass": [
            {
                "code": "// Author : SÃ©bastien BÃ©rubÃ©\n// Created : Dec 2015\n// Modified : March 2016\n//\n// BufferA :\n//     __________________________________________\n//    |    Face 6      |    Face 6      |        |\n//    |   z- lower     |   z- upper     |MetaData|\n//    |________________|________________|________|\n//    |        |                |                |\n//    |        |                |                |\n//    |Face 3  |     Face 4     |     Face 5     |\n//    |  y+    |       y-       |       z+       |\n//    |________|________________|________________|\n//    |                |                |        |\n//    |                |                |        |\n//    |    Face 1      |    Face 2      |  Face 3|\n//    |      X+        |      X-        |    y+  |\n//    |________________|________________|________|\n//     \n//\n// Same Image-based PBR equations as https://www.shadertoy.com/view/ld3SRr, with the addition\n// of an irradiance cubemap for the diffuse contribution on plastic material (BufferA).\n// \n// Sources:\n// http://www.codinglabs.net/article_physically_based_rendering.aspx\n//\n// License : Creative Commons Non-commercial (NC) license\n//\n\n//----------------------\n// Settings (change them!)\nconst float ROUGHNESS_AMOUNT       = 0.85;//Valid range : [0-1] 0=shiny, 1=rough map\nconst float SKY_COLOR              = 0.0; //[0.0=Red, 1.0=Blue)\nconst float ABL_LIGHT_CONTRIBUTION = 0.5; //[0-1] Additional ABL Light Contribution\n\n//----------------------\n// internal constants\nconst float GEO_MAX_DIST   = 1000.0;\nconst float CAM_FOV        = 2.5; //proj plane width\nconst float MIPMAP_SWITCH  = 0.29; //sampling angle delta (rad) equivalent to the lowest LOD.\nconst int MATERIALID_ENV = 1;\nconst int MATERIALID_OBJ = 2;\n//http://www.filmetrics.com/refractive-index-database/Al/Aluminium\n//http://refractiveindex.info/?shelf=3d&book=liquids&page=water\n//https://seblagarde.wordpress.com/2011/08/17/feeding-a-physical-based-lighting-mode/\nconst vec3  F_ALU_N  = vec3(1.600,0.912,0.695); //(Red ~ 670 nm; Green ~ 540 nm; Blue ~ 475 nm)\nconst vec3  F_ALU_K  = vec3(8.010,6.500,5.800); //(Red ~ 670 nm; Green ~ 540 nm; Blue ~ 475 nm)\nconst vec3  F_GOLD_N = vec3(0.161,0.402,1.242); //(Red ~ 670 nm; Green ~ 540 nm; Blue ~ 475 nm)\nconst vec3  F_GOLD_K = vec3(3.446,2.540,1.796); //(Red ~ 670 nm; Green ~ 540 nm; Blue ~ 475 nm)\nconst float F_DIELECTRIC_PLASTIC = 1.49; //@550nm, does not change much with wavelength for dielectric\nconst float F_DIELECTRIC_WATER   = 1.33; //@550nm\nconst float F_DIELECTRIC_DIAMOND = 2.42; //@550nm\n\nstruct Cam\n{\n    vec3 R;//Right, \n    vec3 U;//Up,\n    vec3 D;//Direction,\n    vec3 o;//origin (pos)\n};\n    \nstruct TraceData\n{\n    float rayLen; //Run Distance\n    vec3  rayDir; //Run Direction\n    float geoDist;//Hit error (might not always converge)\n    vec3  normal; //Hit normal\n    int   matID;  //Hit material ID\n};\n\nmat3  UTIL_axisRotationMatrix(vec3 axis, float theta);\n\n#define saturate(x) clamp(x,0.0,1.0)\n//From Dave Hoskin's hash without sine\n#define MOD3 vec3(.1031,.11369,.13787) \n\n//PBR Equation for a single sample (IBL) or a single point point (ABL)\nvec3 PBR_Equation(vec3 V, vec3 L, vec3 N, float roughness, vec3 ior_n, vec3 ior_k, const bool metallic, const bool bIBL)\n{\n    float cosT = saturate( dot(L, N) );\n    float sinT = sqrt( 1.0 - cosT * cosT);\n    \n\tvec3 H = normalize(L+V);\n\tfloat NdotH = dot(N,H);//Nn.H;\n\tfloat NdotL = dot(N,L);//Nn.Ln;\n\tfloat VdotH = dot(V,H);//Vn.H;\n    float NdotV = dot(N,V);//Nn.Vn;\n    \n    //-----------------------------------------\n\t//            Distribution Term\n    //-----------------------------------------\n    float PI = 3.14159;\n    float alpha2 = roughness * roughness;\n    float NoH2 = NdotH * NdotH;\n    float den = NoH2*(alpha2-1.0)+1.0;\n    float D = 1.0; //Distribution term is externalized from IBL version\n    if(!bIBL)\n        D = (NdotH>0.)?alpha2/(PI*den*den):0.0; //GGX Distribution.\n\t\n    //-----------------------------------------\n\t//            Fresnel Term\n    //-----------------------------------------\n    vec3 F;\n    if(metallic)\n    {\n        //Source: http://sirkan.iit.bme.hu/~szirmay/fresnel.pdf p.3 above fig 5\n        float cos_theta = 1.0-NdotV;//REVIEWME : NdotV or NdotL ?\n        F =  ((ior_n-1.)*(ior_n-1.)+ior_k*ior_k+4.*ior_n*pow(1.-cos_theta,5.))\n\t\t    /((ior_n+1.)*(ior_n+1.)+ior_k*ior_k);\n    }\n    else\n    {\n        //Fresnel Schlick Dielectric formula \n        //Sources: https://en.wikipedia.org/wiki/Schlick%27s_approximation\n        //          http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx\n        //Note: R/G/B do not really differ for dielectric materials\n        float F0 = abs ((1.0 - ior_n.x) / (1.0 + ior_n.x));\n  \t\tF = vec3(F0 + (1.-F0) * pow( 1. - VdotH, 5.));\n    }\n    \n    //-----------------------------------------\n\t//            Geometric term\n    //-----------------------------------------\n    //Source: Real Shading in Unreal Engine 4 2013 Siggraph Presentation\n    //https://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf p.3/59\n    //k = Schlick model (IBL) : Disney's modification to reduce hotness (point light)\n    float k = bIBL?(roughness*roughness/2.0):(roughness+1.)*(roughness+1.)/8.; \n    float Gl = max(NdotL,0.)/(NdotL*(1.0-k)+k);\n    float Gv = max(NdotV,0.)/(NdotV*(1.0-k)+k);\n    float G = Gl*Gv;\n    \n    //-----------------------------------------\n\t//     PBR Equation (ABL & IBL versions)\n    //-----------------------------------------\n    //Two flavors of the PBR equation (IBL/point light).\n    //Personal addition: This parameter softens up the transition at grazing angles (otherwise too sharp IMHO).\n    float softTr = 0.1; // Valid range : [0.001-0.25]. It will reduce reflexivity on edges when too high, however.\n    //Personal addition: This parameter limits the reflexivity loss at 90deg viewing angle (black spot in the middle?).\n    float angleLim = 0.15; // Valid range : [0-0.75] (Above 1.0, become very mirror-like and diverges from a physically plausible result)\n    //Source: http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx\n    if(bIBL)\n        return (F*G*(angleLim+sinT)/(angleLim+1.0) / (4.*NdotV*saturate(NdotH)*(1.0-softTr)+softTr)); //IBL\n    else\n        return D*F*G / (4.*NdotV*NdotL*(1.0-softTr)+softTr);\t//ABL\n}\n\nvec3 PBR_HDRremap(vec3 c)\n{\n    float fHDR = smoothstep(2.900,3.0,c.x+c.y+c.z);\n    //vec3 cRedSky   = mix(c,1.3*vec3(4.5,2.5,2.0),fHDR);\n    vec3 cBlueSky  = mix(c,1.8*vec3(2.0,2.5,3.0),fHDR);\n    return cBlueSky;//mix(cRedSky,cBlueSky,SKY_COLOR);\n}\n\nvec3 PBR_HDRCubemap(vec3 sampleDir, float LOD_01)\n{\n    vec3 linearGammaColor_sharp = PBR_HDRremap(pow(texture( iChannel2, sampleDir ).rgb,vec3(2.2)));\n    vec3 linearGammaColor_blur  = PBR_HDRremap(pow(texture( iChannel3, sampleDir ).rgb,vec3(1)));\n    vec3 linearGammaColor = mix(linearGammaColor_sharp,linearGammaColor_blur,saturate(LOD_01));\n    return linearGammaColor;\n}\n\nvec2 hash22(vec2 p)\n{\n    //From DaveHoskin's hash without sine\n    //https://www.shadertoy.com/view/4djSRW\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\nvec3 PBR_nudgeSample(vec3 sampleDir, float roughness, float e1, float e2, out float range)\n{\n    const float PI = 3.14159;\n    //Importance sampling :\n    //Source : http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx\n    //The higher the roughness, the broader the range.\n    //In any case, wide angles are less probable than narrow angles.\n    range = atan( roughness*sqrt(e1)/sqrt(1.0-e1) );\n    //Circular angle has an even distribution (could be improved?).\n\tfloat phi = 2.0*PI*e2;\n    \n\tvec3 up = vec3(0,1,0); //arbitrary\n\tvec3 tAxis = cross(up,sampleDir);\n\tmat3 m1 = UTIL_axisRotationMatrix(normalize(tAxis),range);\n\tmat3 m2 = UTIL_axisRotationMatrix(normalize(sampleDir), phi);\n        \n\treturn sampleDir*m1*m2;\n}\n\nvec3 PBR_visitSamples(vec3 V, vec3 N, float roughness, bool metallic, vec3 ior_n, vec3 ior_k )\n{\n    //Direct relection vector\n    vec3 vCenter = reflect(-V,N);\n    \n    //------------------------------------------------\n\t//  Randomized Samples : more realistic, but\n    //  a lot of samples before it stabilizes \n    //------------------------------------------------\n    float randomness_range = 0.75; //Cover only the closest 75% of the distribution. Reduces range, but improves stability.\n    float fIdx = 0.0;              //valid range = [0.5-1.0]. Note : it is physically correct at 1.0.\n    const int ITER_RDM = 05;\n    const float w_rdm = 1.0/float(ITER_RDM);\n    vec3 totalRandom = vec3(0.0);\n    for(int i=0; i < ITER_RDM; ++i)\n    {\n        //Random jitter note : very sensitive to hash quality (patterns & artifacts).\n        vec2 jitter = hash22(fIdx*10.0+vCenter.xy*100.0);\n    \tfloat angularRange = 0.;    \n        vec3 sampleDir    = PBR_nudgeSample(vCenter, roughness, jitter.x*randomness_range, jitter.y, angularRange);\n        vec3 sampleColor  = PBR_HDRCubemap( sampleDir, angularRange/MIPMAP_SWITCH);\n        vec3 contribution = PBR_Equation(V, sampleDir, N, roughness, ior_n, ior_k, metallic, true)*w_rdm;\n    \ttotalRandom += contribution*sampleColor;\n\t\t++fIdx;\n    }\n    \n    //------------------------------------------------\n\t//  Fixed Samples : More stable, but creates\n    //  sampling pattern artifacts and the reach is\n    //  limited.\n    //------------------------------------------------\n    fIdx = 0.0;\n    const int ITER_FIXED = 15;\n    const float w_fixed = 1.0/float(ITER_FIXED); //Sample\n    vec3 totalFixed = vec3(0.0);\n    for(int i=0; i < ITER_FIXED; ++i)\n    {\n        //Stable pseudo-random jitter (to improve stability with low sample count)\n        //Beware here! second component controls the sampling pattern \"swirl\", and it must be choosen \n        //             so that samples do not align by doing complete 360deg cycles at each iteration.\n        vec2 jitter = vec2( clamp(w_fixed*fIdx,0.0,0.50),\n                            fract(w_fixed*fIdx*1.25)+3.14*fIdx);\n        float angularRange = 0.;\n        vec3 sampleDir    = PBR_nudgeSample(vCenter, roughness, jitter.x, jitter.y, angularRange);\n        vec3 sampleColor  = PBR_HDRCubemap( sampleDir, angularRange/MIPMAP_SWITCH);\n        vec3 contribution = PBR_Equation(V, sampleDir, N, roughness, ior_n, ior_k, metallic, true)*w_fixed;\n        totalFixed += contribution*sampleColor;\n\t\t++fIdx;\n    }\n    \n    return (totalRandom*float(ITER_RDM)+totalFixed*float(ITER_FIXED))/(float(ITER_RDM)+float(ITER_FIXED));\n}\n\n//Cubemap folding\nstruct MyCubeMap_FaceInfo\n{\n    vec2 uv; //[0-1]\n    float id; //[0=x+,1=x-,2=y+,3=y-,4=z+,5=z-]\n};\n//Cubemap folding\nvec4 MyCubeMap_cube(vec3 ro, vec3 rd, vec3 pos, vec3 size)\n{\n    ro = ro-pos;\n    float cullingDir = all(lessThan(abs(ro),size))?1.:-1.;\n    vec3 viewSign = cullingDir*sign(rd);\n    vec3 t = (viewSign*size-ro)/rd;\n    vec2 uvx = (ro.zy+t.x*rd.zy)/size.zy; //face uv : [-1,1]\n    vec2 uvy = (ro.xz+t.y*rd.xz)/size.xz;\n    vec2 uvz = (ro.xy+t.z*rd.xy)/size.xy;\n    if(      all(lessThan(abs(uvx),vec2(1))) && t.x > 0.) return vec4(t.x,(uvx+1.)/2.,0.5-viewSign.x/2.0);\n    else if( all(lessThan(abs(uvy),vec2(1))) && t.y > 0.) return vec4(t.y,(uvy+1.)/2.,2.5-viewSign.y/2.0);\n    else if( all(lessThan(abs(uvz),vec2(1))) && t.z > 0.) return vec4(t.z,(uvz+1.)/2.,4.5-viewSign.z/2.0);\n\treturn vec4(2000.0,0,0,-1);\n}\n//Cubemap unfolding\n#define SEAMLESS 1\n//Converts a cube face ID & face uv into 2D texture [0-1] uv mapping\nvec2 MyCubeMap_faceToUV(MyCubeMap_FaceInfo info)\n{\n    const float freq = 2.5;\n    info.id   += (info.id>=4.99 && info.uv.y>0.5)?1.:0.;\n#if SEAMLESS\n    const float eps = 0.003;\n    bool bHalf = (info.id>5.99);\n    if(bHalf)\n    {\n        info.uv.y -= 0.5;\n\t\tinfo.uv.y = min(info.uv.y,0.5-eps);\n    }\n    info.uv = min(info.uv,1.-eps);\n    info.uv = max(info.uv,eps);\n#else\n    info.uv.y -= (info.id>5.99)?0.5:0.;\n#endif    \n    \n    vec2 huv = vec2(info.uv.x+info.id,info.uv.y);\n    huv.y = huv.y/freq+floor(huv.x/freq)/freq;\n    return vec2(fract(huv.x/freq),huv.y);\n}\n\nvec4 MAT_triplanarRoughness(vec3 p, vec3 n)\n{\n    p = fract(p+0.5);\n    \n    float sw = 0.20; //stiching width\n    vec3 stitchingFade = vec3(1.)-smoothstep(vec3(0.5-sw),vec3(0.5),abs(p-0.5));\n    \n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    vec4 cX = abs(n.x)*texture(iChannel0,p.zy);\n    vec4 cY = abs(n.y)*texture(iChannel0,p.xz);\n    vec4 cZ = abs(n.z)*texture(iChannel0,p.xy);\n    \n    return  vec4(stitchingFade.y*stitchingFade.z*cX.rgb\n                +stitchingFade.x*stitchingFade.z*cY.rgb\n                +stitchingFade.x*stitchingFade.y*cZ.rgb,cX.a+cY.a+cZ.a)/fTotal;\n}\n\n//The main material function.\nvec4 MAT_apply(vec3 pos, TraceData traceData)\n{\n    vec3 backgroundColor = pow(texture( iChannel2, traceData.rayDir ).xyz,vec3(2.2));\n    \n    if(traceData.matID==MATERIALID_ENV)\n    {\n        return vec4(backgroundColor,1);\n    }\n    \n    //-----------------------------------------\n\t//            Roughness texture\n    //-----------------------------------------\n    vec4 roughnessBuffer = MAT_triplanarRoughness(pos,traceData.normal);\n    float fRoughness = (roughnessBuffer.x+roughnessBuffer.y+roughnessBuffer.z)/3.0;\n    fRoughness = saturate(fRoughness-1.0+ROUGHNESS_AMOUNT)*0.25;\n    fRoughness += roughnessBuffer.w*800.0/iResolution.x;\n    \n    //-----------------------------------------\n\t//         IBL and ABL PBR Lighting\n    //-----------------------------------------\n    vec3 rd  = traceData.rayDir;\n    vec4 col = vec4(0);\n    vec3 V = normalize(-traceData.rayDir);\n    vec3 N = traceData.normal;\n    vec3 L = normalize(vec3(1,1,0));\n    \n    //Position dependent parameters\n    //(this could use some cleaning up)\n    bool bMetallic = fract(pos.x)>0.5;\n    vec3 ior_N = bMetallic?F_ALU_N:vec3(F_DIELECTRIC_PLASTIC);\n    vec3 ior_K = bMetallic?F_ALU_K:vec3(0);\n    vec3 cDiff = vec3(1);\n    if(all(lessThan(pos.xz,vec2(-0.5))))\n\t\tcDiff = vec3(0.02);\n    if(all(greaterThan(pos.xz,vec2(0.5))))\n\t\tcDiff = vec3(0.95,0.05,0.05);\n    if(pos.x>0.5 && bMetallic)\n    {\n        ior_N = F_GOLD_N;\n    \tior_K = F_GOLD_K;\n    }\n    \n    vec4 rVal = MyCubeMap_cube(vec3(0),N,vec3(0),vec3(2));\n    MyCubeMap_FaceInfo faceInfo = MyCubeMap_FaceInfo(rVal.yz,rVal.w);\n    vec3 cHemisphereDiffuse = texture(iChannel1,MyCubeMap_faceToUV(faceInfo),-100.0).rgb;\n    \n    cDiff *= cHemisphereDiffuse;\n    \n    col.rgb = PBR_visitSamples(V, N, fRoughness, bMetallic, ior_N, ior_K);\n    vec3 L0 = PBR_Equation(V,L,N, fRoughness+0.01, ior_N, ior_K, bMetallic, false);\n    col.rgb += L0;\n    if(!bMetallic) col.rgb += cDiff;\n    \n    //-----------------------------------------\n\t//      normal-based edge antialiasing\n    //-----------------------------------------\n    //Fade out to background as the view-normal angles reaches 90deg\n    //This is very application-specific\n    //vec3 backgroundColor = pow(texture( iChannel2, traceData.rayDir ).xyz,vec3(2.2));\n    float aaAmount = 0.15;\n    if(dot(N,traceData.rayDir) > -aaAmount)\n    {\n        float smoothFactor = 1.0-clamp(-dot(N,traceData.rayDir)/(aaAmount), 0.0, 1.0);\n        col.rgb = mix(col.rgb, backgroundColor, smoothFactor);\n    }\n    \n    return col;\n}\n\nstruct DF_out\n{\n    float d;  //Distance to geometry\n    int matID;//Geometry material ID\n};\n\nfloat DF_smoothMerge( float d1, float d2, float d3 )\n{\n    float k = 22.0;\n\treturn -log(exp(-k*d1)+exp(-k*d2)+exp(-k*d3))/k;\n}\n\nfloat DF_cube( vec3 p, vec3 size )\n{\n    vec3 dEdge = abs(p)-size; //distance to cube edge, along each axis\n    float internalDist = max(dEdge.x,max(dEdge.y,dEdge.z)); //Inside cube : manhattan distance, negative values\n    float externalDist = length(max(dEdge,vec3(0))); //Outside cube : euclidian distance where axis dist > 0\n    return externalDist+min(internalDist,0.0); //min(internal,0) to avoid internal/external condition.\n}\n\nfloat DF_sphere( vec3 p, float size )\n{\n\treturn length(p)-size;    \n}\n\nDF_out DF_composition( in vec3 _pos )\n{\n\t//Explanation:\n    //https://iquilezles.org/articles/distfunctions\n    float fRadius = 0.4;\n        \n    //Repetition\n    vec3 pos = _pos;\n    pos.xz = fract(pos.xz+0.5)-0.5;\n    //Limits\n    if(abs(_pos.x)>1.5) \n        pos.x = _pos.x - sign(_pos.x);\n    if(abs(_pos.z)>1.5) \n        pos.z = _pos.z - sign(_pos.z);\n    \n    float sd_sphere = DF_sphere( pos, fRadius ); \n    float sd_cube = DF_cube( pos-vec3(0.0,0.4,0.0), vec3(fRadius)/2.0 ); \n\tfloat sd_sphere2 = DF_sphere( pos-vec3(0.0,0.8,0.0), fRadius/2.0 ); \n    \n    DF_out dfOut;\n    dfOut.d = DF_smoothMerge(sd_sphere,sd_sphere2,sd_cube);\n    dfOut.matID = MATERIALID_OBJ;\n    return dfOut;\n    \n}\n\nvec3 DF_gradient( in vec3 p )\n{\n\tconst float d = 0.001;\n\tvec3 grad = vec3(DF_composition(p+vec3(d,0,0)).d-DF_composition(p-vec3(d,0,0)).d,\n                     DF_composition(p+vec3(0,d,0)).d-DF_composition(p-vec3(0,d,0)).d,\n                     DF_composition(p+vec3(0,0,d)).d-DF_composition(p-vec3(0,0,d)).d);\n\treturn grad;\n}\n\n//o = ray origin, d = direction, t = distance travelled along ray, starting from origin\nvec2 RAYMARCH_distanceField( vec3 o, vec3 dir)\n{\n    //From Inigo Quilez DF ray marching :\n    //https://iquilezles.org/articles/raymarchingdf\n    float tmax = GEO_MAX_DIST;\n    float t = 0.0;\n    float dist = GEO_MAX_DIST;\n    for( int i=0; i<50; i++ )\n    {\n\t    dist = DF_composition( o+dir*t ).d;\n        if( abs(dist)<0.0001 || t>GEO_MAX_DIST ) break;\n        t += dist;\n    }\n    \n    return vec2( t, dist );\n}\n    \nTraceData new_TraceData()\n{\n    TraceData td;\n    td.rayLen = 0.;\n    td.rayDir = vec3(0);\n    td.geoDist = 0.;\n    td.normal = vec3(0);\n    td.matID = MATERIALID_ENV;\n    return td;\n}\n\n\n//o=ray origin, d=ray direction\nTraceData TRACE_geometry(vec3 o, vec3 d)\n{\n    TraceData skyData;\n    skyData.rayLen  = 50.0;\n    skyData.rayDir  = d;\n\tskyData.geoDist = 0.0;\n\tskyData.normal  = -d; //Shere center\n\tskyData.matID   = MATERIALID_ENV;\n    \n    TraceData dfTrace;\n    vec2 rayLen_geoDist = RAYMARCH_distanceField(o,d);\n    vec3 dfHitPosition  = o+rayLen_geoDist.x*d;\n    dfTrace.rayDir     = d;\n    dfTrace.rayLen     = rayLen_geoDist.x;\n    dfTrace.geoDist    = rayLen_geoDist.y;\n    dfTrace.normal     = normalize(DF_gradient(dfHitPosition));\n    dfTrace.matID = MATERIALID_OBJ;\n    \n    if(dfTrace.geoDist>0.01 || skyData.rayLen<dfTrace.rayLen)\n    {\n        return skyData;\n    }\n    else\n    {\n        return dfTrace;\n    }\n}\n\n//Arbitrary axis rotation (around u, normalized)\nmat3 UTIL_axisRotationMatrix( vec3 u, float t )\n{\n    float c = cos(t);\n    float s = sin(t);\n    //  _        _   _           _     _                    _ \n    // |_px py pz_| | m11 m21 m31 |   | px*m11+py*m21+pz*m31 |\n    //              | m12 m22 m32 | = | px*m12+py*m22+pz*m32 |\n    //              |_m13 m23 m33_|   |_px*m13+py*m23+pz*m33_|\n    return mat3(  c+u.x*u.x*(1.-c),     u.x*u.y*(1.-c)-u.z*s, u.x*u.z*(1.-c)+u.y*s,\n\t              u.y*u.x*(1.-c)+u.z*s, c+u.y*u.y*(1.-c),     u.y*u.z*(1.-c)-u.x*s,\n\t              u.z*u.x*(1.-c)-u.y*s, u.z*u.y*(1.-c)+u.x*s, c+u.z*u.z*(1.-c) );\n}\n\n\nCam CAM_animate(vec2 uv, float rotX, bool useMouse)\n{\n    if(useMouse)//Mouse button down : user rotation control\n    {\n        float PI = 3.14159;\n    \trotX = 2.0*PI*(iMouse.x/iResolution.x);\n    }\n    Cam cam;\n    cam.o = vec3(cos(rotX),0.5,sin(rotX))*2.5;\n    cam.D = normalize(vec3(0)-cam.o);\n    cam.R = normalize(cross(cam.D,vec3(0,1,0)));\n    cam.U = cross(cam.R,cam.D);\n    return cam;\n}\n\nvec3 CAM_getRay(Cam cam,vec2 uv)\n{\n    uv *= CAM_FOV;\n    return normalize(uv.x*cam.R+uv.y*cam.U+cam.D);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy) / iResolution.xx;\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    bool bMouseRotate = (iMouse.z > 0.0) ;\n    Cam cam = CAM_animate(uv,iTime*0.3,bMouseRotate);\n    vec3 d = CAM_getRay(cam,uv);\n    \n    vec3 ptGeo = vec3(0);\n    \n    TraceData geometryTraceData = TRACE_geometry(cam.o, d);\n    \n    if(geometryTraceData.rayLen < GEO_MAX_DIST)\n    {\n        ptGeo = cam.o+d*geometryTraceData.rayLen;\n    }\n    \n    vec3 c = MAT_apply(ptGeo,geometryTraceData).rgb;\n    \n    //Vignetting\n    float lensRadius = 0.65;\n    uv /= lensRadius;\n    float sin2 = uv.x*uv.x+uv.y*uv.y;\n    float cos2 = 1.0-min(sin2*sin2,1.0);\n    float cos4 = cos2*cos2;\n    c *= cos4;\n    \n    //Gamma\n    c = pow(c,vec3(0.4545)); //2.2 Gamma compensation\n    \n    fragColor = vec4(c,1.0);\n    \n    vec2 irrandianceBufferSize = vec2(120,75);\n    if(all(lessThan(fragCoord.xy,irrandianceBufferSize+1.)))\n        fragColor = vec4(1);\n    if(all(lessThan(fragCoord.xy,irrandianceBufferSize)))\n        fragColor = texture(iChannel1,(fragCoord.xy)/irrandianceBufferSize);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Author : SÃ©bastien BÃ©rubÃ©\n//Buffer A : Hemisphere integration to compute environment diffuse contribution.\n//           The result is \"cubemapped\" and folded into the current buffer output,\n//           using uvToFace() and faceToRay().\n//           \n//           function \"FaceInfo uvToFace(vec2 uv)\" converts a [0-1] uv input into the cubemap face info (face ID + face UV).\n//           function \"vec3 faceToRay(FaceInfo info)\" converts a face info into a 3D direction.\n//           \n//    BufferA :\n//     __________________________________________\n//    |    Face 6      |    Face 6      |        |\n//    |   z- lower     |   z- upper     |MetaData|\n//    |________________|________________|________|\n//    |        |                |                |\n//    |        |                |                |\n//    |Face 3  |     Face 4     |     Face 5     |\n//    |  y+    |       y-       |       z+       |\n//    |________|________________|________________|\n//    |                |                |        |\n//    |                |                |        |\n//    |    Face 1      |    Face 2      |  Face 3|\n//    |      X+        |      X-        |    y+  |\n//    |________________|________________|________|\n//     \n//#define HIGH_QUALITY //Time needs to be reset when defining this value.\n\n#ifdef HIGH_QUALITY\nconst int SAMPLES_PER_ITERATION = 30;\nconst int CONVERGENCE_FRAME_COUNT = 200;\n#else\nconst int SAMPLES_PER_ITERATION = 5;\nconst int CONVERGENCE_FRAME_COUNT = 100;\n#endif\n\n\n//Arbitrary axis rotation (around normalized u, cos theta, sin theta)\nmat3 UTIL_axisRotationMatrix( vec3 u, float ct, float st )\n{\n    return mat3(  ct+u.x*u.x*(1.-ct),     u.x*u.y*(1.-ct)-u.z*st, u.x*u.z*(1.-ct)+u.y*st,\n\t              u.y*u.x*(1.-ct)+u.z*st, ct+u.y*u.y*(1.-ct),     u.y*u.z*(1.-ct)-u.x*st,\n\t              u.z*u.x*(1.-ct)-u.y*st, u.z*u.y*(1.-ct)+u.x*st, ct+u.z*u.z*(1.-ct) );\n}\n\nvec3 rotateSample(vec3 sampleDir, float range_01, float circular_01, out float range_angle)\n{\n    const float PI = 3.14159;    \n    float theta = 2.0*PI*circular_01;\n    \n\tvec3 notColinear = (abs(sampleDir.y)<0.8)?vec3(0,1,0):vec3(1,0,0);\n\tvec3 othogonalAxis = normalize(cross(notColinear,sampleDir));\n    \n    range_angle = atan( sqrt(range_01)/sqrt(1.0-range_01) );\n    float cost = sqrt(1.0-range_01);//=cos(range_angle);\n    float sint = sqrt(range_01);//=sin(range_angle);\n\tmat3 m1 = UTIL_axisRotationMatrix(othogonalAxis, cost, sint);\n\tmat3 m2 = UTIL_axisRotationMatrix(sampleDir, cos(theta), sin(theta));\n    return sampleDir*m1*m2;\n}\n\nvec3 integrateHemisphere(vec3 normal, float progress)\n{\n    //Add some randomness in between progress steps.\n    float ff = 0.5-(fract(normal.x*4913.)\n\t               +fract(normal.y*4913.)\n\t               +fract(normal.z*4913.))/6.0;\n    \n    progress += max(0.,ff/float(CONVERGENCE_FRAME_COUNT));\n        \n    vec3 up = vec3(0,1,0);\n    vec3 right = normalize(cross(up,normal));\n    up = cross(normal,right);\n\n    vec3 sampledColour = vec3(0,0,0);\n    float index = 0.;\n    float theta = 0.;\n    \n    //http://www.codinglabs.net/article_physically_based_rendering.aspx\n    for(int j=0; j < SAMPLES_PER_ITERATION; ++j)\n    {\n        float circular_angle_01 = index/float(SAMPLES_PER_ITERATION)+fract(progress*87316.)/float(SAMPLES_PER_ITERATION);\n        vec3 sampleVector = rotateSample(normal, progress, circular_angle_01, theta);\n\t\tvec3 linearGammaColor = pow(texture( iChannel0, sampleVector, -100.0 ).rgb,vec3(2.2));\n        float sampledArea = sin(theta);\n\t\tsampledColour += linearGammaColor * cos(theta) * sampledArea;\n\t\tindex ++;\n\t}\n\n    return vec3( 3.14159 * sampledColour / index);\n}\n\nstruct FaceInfo\n{\n    vec2 uv; //[0-1]\n    float id; //[0=x+,1=x-,2=y+,3=y-,4=z+,5=z-]\n};\n\n//receives a faceID + uv, which it converts into a 3D direction from cube center to face point.\nvec3 faceToRay(FaceInfo info)\n{\n    //info.id = [0=x+,1=x-, 2=y+,3=y-, 4=z+,5=z-]\n    //fAxis   = [0.01;0.51; 1.01;1.51; 2.01;2.51]\n    float eps = 0.01;              \n    float fAxis = info.id/2.0+eps;\n    bvec3 axis  = lessThan(abs(floor(fAxis)-vec3(0,1,2)),vec3(eps));\n    vec3 camU = (axis.y)?vec3(0,0,1):vec3(0,1,0);\n    vec3 camD = vec3(axis.x?1:0,axis.y?1:0,axis.z?1:0);\n    vec3 camR = cross(axis.z?-camD:camD,camU);\n    float axisSign = (fract(fAxis)<0.5)?1.:-1.;\n    return  normalize(camR*(info.uv.x*2.-1.)\n                     +camU*(info.uv.y*2.-1.)\n                     +camD*axisSign);\n}\n\n//Converts a 2D texture into its tile uv and its [0..5] index;\nFaceInfo uvToFace(vec2 uv)\n{\n    //huv is the \"horizontally unrolled\" wide uv coord, where u.x=[0-6] and u.y=[0-1].\n    //tuv is the tile uv coord, back to [0-1]. Note: 6th anf 7th tiles are cut in half and combined.\n    const float freq = 2.5;\n    uv *= freq;\n    vec2 huv = vec2(uv.x+freq*floor(uv.y),fract(uv.y));\n    float idx = floor(huv.x);\n    vec2 tuv = vec2(fract(huv.x),huv.y+(idx>5.01?0.5:0.));\n    return FaceInfo( tuv, min(idx,5.) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    FaceInfo info = uvToFace(uv);\n    vec3 rayDir = faceToRay(info);\n    \n    vec3 cBuf = texture(iChannel1,vec2(1),-100.0).xyz;\n    vec2 prevRes = cBuf.xy;\n    float frameCount = cBuf.z;\n\t        \n    vec3 accumColor = texture(iChannel1,uv,-100.0).rgb;\n    if(iTime<0.1 || length(prevRes-iResolution.xy) > 1.)\n    {\n        //Init/reset on resolution change\n        accumColor = vec3(0);\n        frameCount = 0.0;\n    }\n    \n    float progress = frameCount/float(CONVERGENCE_FRAME_COUNT);\n    vec3 cCurrentContribution = integrateHemisphere(rayDir, progress)/float(CONVERGENCE_FRAME_COUNT);\n    vec3 c = accumColor+((progress<1.)?cCurrentContribution:vec3(0.));\n\tfragColor = vec4(c,1.0);\n    \n    //Use top-right texture pixel to store computation resolution & frame count.\n    if(length(uv-vec2(1))<0.01)\n    {\n        fragColor.xyz = vec3(iResolution.xy,frameCount+1.);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Author : SÃ©bastien BÃ©rubÃ©\n//Buffer C : Material Roughness map.\n//           This is just noise, you could implement whatever roughness map you want.\n//           This needs some clean-up, as it was originally coded as 3D noise, but only a 2D slice is used here.\n\n#define saturate(x) clamp(x,0.0,1.0)\nfloat UTIL_distanceToLineSeg(vec2 p, vec2 a, vec2 b)\n{\n    //Scalar projection of ap in the ab direction = dot(ap,ab)/|ab| : Amount of ap aligned towards ab\n    //Divided by |ab| again, it becomes normalized along ab length : dot(ap,ab)/(|ab||ab|) = dot(ap,ab)/dot(ab,ab)\n    //The clamp provides the line seg limits. e is therefore the \"capped orthogogal projection\".\n    //       p\n    //      /\n    //     /\n    //    a--e-------b\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    vec2 e = a+clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0)*ab;\n    return length(p-e);\n}\nvec2 noise(vec2 p)\n{\n    return texture(iChannel1,p,-100.0).xy;\n}\nstruct repeatInfo\n{\n\tvec2 pRepeated;\n    vec2 anchor;\n};\nrepeatInfo UTIL_repeat(vec2 p, float interval)\n{\n    repeatInfo rInfo;\n    rInfo.pRepeated = p / interval; //Normalize\n    rInfo.pRepeated = fract(rInfo.pRepeated+0.5)-0.5; //centered fract\n    rInfo.pRepeated *= interval; //Rescale\n    rInfo.anchor = p-rInfo.pRepeated;\n    return rInfo;\n}\nfloat MAT_scratchTexture(vec2 p)\n{\n    const float squareWidth = 0.10*2.0;\n    const float moveAmp   = squareWidth*0.75;\n    const float lineWidth = 0.0005;\n    float repeatInterval = squareWidth+moveAmp;\n    repeatInfo rInfo = UTIL_repeat(p,repeatInterval);\n    float margin = repeatInterval-squareWidth;\n    \n    vec2 a = moveAmp*noise(rInfo.anchor);\n    vec2 b = -moveAmp*noise(rInfo.anchor+10.0);\n    float dseg = 1000.0*UTIL_distanceToLineSeg(rInfo.pRepeated, a, b)/squareWidth;\n    return saturate(10.0/dseg-0.5)*0.25;\n}\n\nfloat MAT_layeredScratches(vec2 p)\n{\n    const mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n    float I = MAT_scratchTexture(p);\n    p = m2*p;\n    I += MAT_scratchTexture(p*1.11+2.0);\n    p = m2*p;\n    I += MAT_scratchTexture(p*1.24+3.8);\n    p = m2*p;\n    I += MAT_scratchTexture(p*1.34+5.3);\n    p = m2*p;\n    I += MAT_scratchTexture(p*1.34+5.3);\n    p = m2*p;\n    I += MAT_scratchTexture(p*1.34+5.3);\n        \n    return I;\n}\n\nfloat MAT_triplanarScratches(vec3 p, vec3 n)\n{\n    //Idea from http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\n    //Figure 1-23 Triplanar Texturing\n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    return ( abs(n.x)*MAT_scratchTexture(p.zy)\n            +abs(n.y)*MAT_scratchTexture(p.xz)\n            +abs(n.z)*MAT_scratchTexture(p.xy))/fTotal;\n}\n\nvec4 NOISE_trilinearWithDerivative(vec3 p)\n{\n    //Trilinear extension over noise derivative from (Elevated), & using the noise stacking trick from (Clouds).\n\t//Inspiration & Idea from :\n    //https://www.shadertoy.com/view/MdX3Rr (Elevated)\n    //https://www.shadertoy.com/view/XslGRr (Clouds)\n    \n    //For more information, see also:\n    //NoiseVolumeExplained : https://www.shadertoy.com/view/XsyGWz\n\t//2DSignalDerivativeViewer : https://www.shadertoy.com/view/ldGGDR\n    \n    const float TEXTURE_RES = 256.0; //Noise texture resolution\n    vec3 pixCoord = floor(p);//Pixel coord, integer [0,1,2,3...256...]\n    //noise volume stacking trick : g layer = r layer shifted by (37x17 pixels)\n    //(37x17)-> this value is the actual translation embedded in the noise texture, can't get around it.\n\t//Note : shift is different from g to b layer (but it also works)\n    vec2 layer_translation = -pixCoord.z*vec2(37.0,17.0)/TEXTURE_RES; \n    \n    vec2 c1 = texture(iChannel0,layer_translation+(pixCoord.xy+vec2(0,0)+0.5)/TEXTURE_RES,-100.0).rg;\n    vec2 c2 = texture(iChannel0,layer_translation+(pixCoord.xy+vec2(1,0)+0.5)/TEXTURE_RES,-100.0).rg; //+x\n    vec2 c3 = texture(iChannel0,layer_translation+(pixCoord.xy+vec2(0,1)+0.5)/TEXTURE_RES,-100.0).rg; //+z\n    vec2 c4 = texture(iChannel0,layer_translation+(pixCoord.xy+vec2(1,1)+0.5)/TEXTURE_RES,-100.0).rg; //+x+z\n    \n    vec3 x = p-pixCoord; //Pixel interpolation position, linear range [0-1] (fractional part)\n    \n    vec3 x2 = x*x;\n    vec3 t = (6.*x2-15.0*x+10.)*x*x2; //Quintic ease-in/ease-out function.\n    vec3 d_xyz = (30.*x2-60.*x+30.)*x2; //dt/dx : Ease-in ease-out derivative.\n    \n    //Lower quad corners\n    float a = c1.x; //(x+0,y+0,z+0)\n    float b = c2.x; //(x+1,y+0,z+0)\n    float c = c3.x; //(x+0,y+1,z+0)\n    float d = c4.x; //(x+1,y+1,z+0)\n    \n    //Upper quad corners\n    float e = c1.y; //(x+0,y+0,z+1)\n    float f = c2.y; //(x+1,y+0,z+1)\n    float g = c3.y; //(x+0,y+1,z+1)\n    float h = c4.y; //(x+1,y+1,z+1)\n    \n    //Trilinear noise interpolation : (1-t)*v1+(t)*v2, repeated along the 3 axis of the interpolation cube.\n    float za = ((a+(b-a)*t.x)*(1.-t.y)\n               +(c+(d-c)*t.x)*(   t.y));\n    float zb = ((e+(f-e)*t.x)*(1.-t.y)\n               +(g+(h-g)*t.x)*(   t.y));\n    float value = (1.-t.z)*za+t.z*zb;\n    \n    //Derivative scaling (texture lookup slope, along interpolation cross sections).\n    //This could be factorized/optimized but I fear it would make it cryptic.\n    float sx =  ((b-a)+t.y*(a-b-c+d))*(1.-t.z)\n               +((f-e)+t.y*(e-f-g+h))*(   t.z);\n    float sy =  ((c-a)+t.x*(a-b-c+d))*(1.-t.z)\n               +((g-e)+t.x*(e-f-g+h))*(   t.z);\n    float sz =  zb-za;\n    \n    return vec4(value,d_xyz*vec3(sx,sy,sz));\n}\n\n//Stacked perlin noise\nvec3 NOISE_volumetricRoughnessMap(vec3 p, float rayLen)\n{\n    float ROUGHNESS_MAP_UV_SCALE = 6.00;//Valid range : [0.1-100.0]\n    vec4 sliderVal = vec4(0.5,0.85,0,0.5);\n    ROUGHNESS_MAP_UV_SCALE *= 0.1*pow(10.,2.0*sliderVal[0]);\n    \n    float f = iTime;\n    const mat3 R1  = mat3(0.500, 0.000, -.866,\n\t                     0.000, 1.000, 0.000,\n                          .866, 0.000, 0.500);\n    const mat3 R2  = mat3(1.000, 0.000, 0.000,\n\t                      0.000, 0.500, -.866,\n                          0.000,  .866, 0.500);\n    const mat3 R = R1*R2;\n    p *= ROUGHNESS_MAP_UV_SCALE;\n    p = R1*p;\n    vec4 v1 = NOISE_trilinearWithDerivative(p);\n    p = R1*p*2.021;\n    vec4 v2 = NOISE_trilinearWithDerivative(p);\n    p = R1*p*2.021+1.204*v1.xyz;\n    vec4 v3 = NOISE_trilinearWithDerivative(p);\n    p = R1*p*2.021+0.704*v2.xyz;\n    vec4 v4 = NOISE_trilinearWithDerivative(p);\n    \n    return (v1\n\t      +0.5*(v2+0.25)\n\t      +0.4*(v3+0.25)\n\t      +0.6*(v4+0.25)).yzw;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 roughnessNoise = NOISE_volumetricRoughnessMap(vec3(2.0*uv,0),1.0).rgb;\n    float scratchTex = MAT_scratchTexture(2.0*uv);\n    scratchTex += MAT_layeredScratches(uv+0.25);\n    scratchTex += MAT_layeredScratches(uv+vec2(0.35));\n    scratchTex += MAT_scratchTexture(uv+vec2(1.15));\n    scratchTex += MAT_scratchTexture(uv+vec2(2.75));\n    fragColor = vec4(roughnessNoise,scratchTex);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}