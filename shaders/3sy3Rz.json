{
    "Shader": {
        "info": {
            "date": "1570121873",
            "description": "Just playing around with the Koch snowflake in 3d. Use mouse to move, see comments for details.",
            "flags": 0,
            "hasliked": 0,
            "id": "3sy3Rz",
            "likes": 23,
            "name": "3d Koch Snowflake",
            "published": 3,
            "tags": [
                "fasd"
            ],
            "usePreview": 0,
            "username": "BigWIngs",
            "viewed": 953
        },
        "renderpass": [
            {
                "code": "// Koch Snowflake 3D - by Martijn Steinrucken aka BigWings 2019\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// After playing with the koch curve and snowflake in 2d, I tried to\n// make it 3d. What you are seeing here is just a bunch of 2d snowflakes\n// stacked on top of each other while slowly changing the 'hat' angle.\n//\n// Be sure to check out the 2d flake tutorial on YouTube if you are not \n// familiar with it: https://www.youtube.com/watch?v=il_Qg9AqQkE\n\n\nmat2 Rot(float a) {\n    float s = sin(a), c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvec3 GetDir(vec2 uv, vec3 ro, vec3 lookat, float zoom){\n\tvec3 f = normalize(lookat-ro),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f, r),\n        c = ro + f*zoom,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i-ro);                  \n}\n\nvec2 N(float angle) {\n    return vec2(sin(angle), cos(angle));\n}\n\nvec2 FlakeUv(vec2 uv, float angle, float radius) {\n\tuv.x = abs(uv.x);\n    \n    vec3 col = vec3(0);\n    float d;\n    vec2 n = N((5./6.)*3.1415);\n    \n    uv.y += tan((5./6.)*3.1415)*.5;\n   \td = dot(uv-vec2(.5, 0), n);\n    uv -= max(0.,d)*n*2.;\n    \n    float scale = 1.;\n    \n    n = N(angle*(2./3.)*3.1415);\n    uv.x += .5;\n    for(int i=0; i<5; i++) {\n        uv *= 3.;\n        scale *= 3.;\n        uv.x -= 1.5;\n        \n        uv.x = sabs(uv.x, radius);\n        uv.x -= .5;\n        d = dot(uv, n);\n        uv -= smin(0.,d, radius)*n*2.;\n    }\n    \n    d = length(uv - vec2(clamp(uv.x,-1., 1.), 0));\n    uv /= scale;\t// normalization\n    \n    return uv;\n}\n\n\n\nfloat GetDist(vec3 p) {\n    float d = length(p)-1.;\n    \n\n    float y = 1.-abs(p.y*.5);\n\n    vec2 uv = FlakeUv(p.xz*.25, clamp(y,0.,1.), .1);\n    d= uv.y;\n    \n    return d;\n}\n\nvec3 GetNormal(float d, vec3 p) {\n    vec2 e = vec2(.001,0);\n    return normalize(\n        d - vec3(\n            GetDist(p+e.xyy),\n            GetDist(p+e.yxy),\n            GetDist(p+e.yyx)\n            )\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 mouse = iMouse.xy/iResolution.xy; // 0 1 \n    uv *= 1.25;\n    vec3 col = vec3(0);\n    \n    if(mouse.x<.1) mouse.x = iTime*.1;\n    \n    vec3 ro = vec3(0,3, -4);\n    ro.yz *= Rot(mouse.y*3.145);\n    ro.xz *= Rot(-mouse.x*6.2832);\n    \n    vec3 rd = GetDir(uv, ro, vec3(0), 1.);\n    \n    float dS=0.,dO=0.;\n    vec3 p;\n    for(int i=0;i<1000; i++) {\n        p = ro + dO*rd;\n        dS = GetDist(p);\n        if(abs(dS)<.001 || dO>100.) break;\n        dO += dS;\n    }\n    \n    if(dS<.001) {\n    \tvec2 fv = FlakeUv(p.xz, 1., .1);\n    \tvec3 n = GetNormal(dS, p);\n    \tcol += n*.5+.5;\n        col *= dot(n, normalize(vec3(1)))*.4+.6;\n        //col.rg += fv;\n    }\n    //col *= 0.;\n    //vec2 fv = FlakeUv(uv, mouse.y, .2);\n    //col = texture(iChannel0, fv).rgb;\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.,1. );\n    return mix( b, a, h ) + k*h*(1.0-h);\n}\n\nfloat sabs(float p, float k){\n\treturn sqrt(p * p + k * k) - k;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}