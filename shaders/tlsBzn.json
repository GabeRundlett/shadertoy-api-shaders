{
    "Shader": {
        "info": {
            "date": "1595880539",
            "description": "Japanese Summer, hurin",
            "flags": 0,
            "hasliked": 0,
            "id": "tlsBzn",
            "likes": 9,
            "name": "Japanese Summer",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "butadiene",
            "viewed": 365
        },
        "renderpass": [
            {
                "code": "float PI = 3.141592;\n\nmat2 rot(float r){\n  return mat2(cos(r),sin(r),-sin(r),cos(r));\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nfloat cylin( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat hashira(vec3 p,vec2 s){\n  vec2 q = abs(p.xz);\n  vec2 m = max(s-q,0.);\n  return length(max(q-s,0.))-min(m.x,m.y);\n}\n\nfloat box(vec3 p,vec3 s){\n  vec3 q = abs(p);\n  vec3 m = max(s-q,0.);\n  return length(max(q-s,0.))-min(min(m.x,m.y),m.z);\n}\n\nfloat cup(vec3 p){\n  p.xy *= rot(PI);\n  p.y += 0.4;\n  float sd = abs(length(p)-0.4)-0.01;\n  float bd = box(p-vec3(0,-0.45,0),vec3(0.9,0.2,0.9));\n  return max(sd,-bd);\n}\n\n// The MIT License\n// Copyright Â© 2019 Inigo Quilez\nfloat dot2( in vec2 v ) { return dot(v,v); }\nvec4 sdJoint3DSphere( in vec3 p, in float l, in float a, in float w)\n{\n    \n    // if perfectly straight\n    if( abs(a)<0.001 ) return vec4( length(p-vec3(0,clamp(p.y,0.0,l),0))-w, p );\n    \n    // parameters\n    vec2  sc = vec2(sin(a),cos(a));\n    float ra = 0.5*l/a;\n    \n    // recenter\n    p.x -= ra;\n    \n    // reflect\n    vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n\n    float u = abs(ra)-length(q);\n    float d2 = (q.y<0.0) ? dot2( q+vec2(ra,0.0) ) : u*u;\n    float s = sign(a);\n    return vec4( sqrt(d2+p.z*p.z)-w,\n                 (p.y>0.0) ? s*u : s*sign(-p.x)*(q.x+ra),\n                 (p.y>0.0) ? atan(s*p.y,-s*p.x)*ra : (s*p.x<0.0)?p.y:l-p.y,\n                 p.z );\n}\n\n\nvec4 rope1(vec3 p){\n     p.y += 1.;\n   p.x -= 1.;\n   p.yz *= rot(PI);\n\n   float an2 = 0.1*sin(iTime*1.9)*exp(fract(iTime*1.9/(PI*2.)))-0.2;\n   float le2 = 0.6;\n   float wi2 = 0.01;\n   vec4 d4 = sdJoint3DSphere(p, le2, an2, wi2 );\n   p.xy*= rot(-an2);\n   p -= vec3(0,le2/an2*sin(an2),0);\n   p.xy*= rot(-an2);\n   return vec4(p,d4.x);\n}\n\nvec4 cup1(vec3 p1){\n   vec4 rope1obj = rope1(p1);\n  vec3  p = rope1obj.xyz;\n   float d4 = rope1obj.w;\n   float scup = 1.6;\n   float d0 = cup(p*scup)/scup;\n   return vec4(p,min(d0,d4));\n}\n\nvec4 rope2(vec3 p1){\n  vec4 cupobj = cup1(p1);\n vec3  p = cupobj.xyz;\n  float d0 = cupobj.w;\n   p.xy *= rot(0.1*sin(iTime));\n   float an = 0.1*sin(iTime*2.)*exp(fract(iTime*2./(PI*2.)))-0.15;\n   float le = 1.2;\n   float wi = 0.01;\n   vec4 d1 = sdJoint3DSphere(p, le, an, wi );\n   p.xy*= rot(-an);\n   p -= vec3(0,le/an*sin(an),0);\n   p.xy*= rot(-an);\n   p.xz *= rot(iTime*4.+pow(abs(sin(iTime)),4.)*iTime*6.);\n   return vec4(p,min(d1.x,d0));\n}\n\nvec4 paper1(vec3 p1){\n     vec4 rope2obj = rope2(p1);\n  vec3 p = rope2obj.xyz;\n   float d1 = rope2obj.w;\n    float planex = 0.4;\n   float d2 = box(p-vec3(0,planex,0),vec3(0.01,planex,0.1));\n   return vec4(p,min(d2,d1));\n}\n\nfloat hurin(vec3 p){\n \n  \n\n vec4 paper1obj = paper1(p);\n p = paper1obj.xyz;\n float d2 = paper1obj.w;\n  //p.yz *= rot(time);\n  return d2;\n}\n\nfloat ueno(vec3 p){\n  vec3 sp = p;\n  sp.xy *=rot(0.5*PI);\n  sp.x = abs(sp.x)-0.8;\n  float d1 = hashira(sp,vec2(0.2,0.2));\n  sp = p;\n  float spkx = 2.6;\n  sp.x = mod(sp.x,spkx)-0.5*spkx;\n  float d2 = box(sp,vec3(0.1,0.8,0.2));\n  float d3 = box(p-vec3(0,1.8,0),vec3(100,0.2,3));\n  return min(min(d1,d2),d3);\n}\n\nfloat door(vec3 sp){\n  return box(sp-vec3(-7,-4,0),vec3(5,3,0.15));\n}\n\nfloat ana(vec3 p){\n  p.x += 0.2;\n  p.y +=0.15;\n  float k = 0.9;\n  p.xy = mod(p.xy,k)-0.5*k;\n  p.z = abs(p.z)-1.;\n  float d0 = box(p,vec3(0.38,0.38,0.95));\n  return d0;\n}\n\nfloat dist(vec3 p){\n  float d0 = ueno(p);\n  float d3 = door(p);\n  d3 = max(d3,-ana(p));\n\n  return min(min(d0,d3),hurin(p));\n}\n\nvec3 getNormal(vec3 p){\n  vec2 e = vec2(0.001,0.);\n  return normalize(vec3(\n    dist(p+e.xyy)-dist(p-e.xyy),\n    dist(p+e.yxy)-dist(p-e.yxy),\n    dist(p+e.yyx)-dist(p-e.yyx)\n    ));\n}\n\nvec3 woodoorlight(vec3 p,vec3 ld,vec3 normal,vec3 vd){\n  float alp = .5;\n  float dif = pow((alp*max(dot(normal,ld),0.)+(1.-alp)),2.);\n  float nof = fbm(p.xy*1.+p.z*0.3);\n  float nof2 = fbm(20.+p.xy*2.+.4*p.z);\n  vec3 alb = vec3(218.,143.,143.)/255.*(0.2+0.8*nof);\n  if(mod(nof*10.0,2.0)<0.2||mod(nof2*10.0,2.0)<0.2){\n    alb =vec3(0,0,0);\n  }\n  return dif*alb;\n}\n\nvec3 wooduplight(vec3 p,vec3 ld,vec3 normal,vec3 vd){\n  float alp = .5;\n  float dif = pow((alp*max(dot(normal,ld),0.)+(1.-alp)),2.);\n  float nof = fbm(40.+p.xy*1.+p.z*0.3);\n  float nof2 = fbm(30.+p.xy*2.+.4*p.z);\n  vec3 alb = 0.4*vec3(288.,143.,143.)/255.*(0.2+0.8*nof);\n  if(mod(nof*10.0,2.0)<0.2){\n    alb =vec3(0,0,0);\n  }\n  return dif*alb;\n}\n\nvec3 paperlight(vec3 p,vec3 ld,vec3 normal,vec3 vd){\n  float alp = .1;\n  float dif = pow((alp*max(dot(normal,ld),0.)+(1.-alp)),2.);\n  vec3 alb = vec3(1.0);\n  return dif*alb;\n}\n\nvec3 sky(vec3 vd,vec3 ld){\n  float dalp = pow(dot(ld,vd),6.);\n  vec3 blue = normalize(vec3(0.1,0.2,1.));\n  vec3 white = vec3(1);\n  vec3 scol= mix(blue,white,dalp);\n  float fbmem = fbm(6.*vd.yx+iTime*0.1);\n  return mix(vec3(0.1,0.3,0.9),scol+fbmem,clamp(vd.y*2.,0.,1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\nvec2 uv = fragCoord/iResolution.xy;\n    \n    \nvec2 r=iResolution.xy,p=(fragCoord.xy*2.-r)/min(r.x,r.y);\nvec2 pix = vec2(min(iResolution.x,iResolution.y)/64.);\n//p = floor(p*pix)/pix;\nvec3 ta = vec3(0,-2,0);\nvec3 ro = vec3(2,-3,5);\nro -= 1.0*(ta-ro);\nvec3 cdir = normalize(ta-ro);\nvec3 side = cross(cdir,vec3(0,1,0));\nvec3 up = cross(side,cdir);\nfloat fov = 3.0;\nvec3 fcol = vec3(0);\nvec2 glv =vec2(0.0);//floor(gl_FragCoord.xy/2.);\n#define bokashi 8\nfor(int i = 0;i<bokashi;i++){\n  float fi = float(i);\n  vec3 rd = normalize(side*p.x+up*p.y+fov*cdir)+0.008*(vec3(random(vec2(glv+fi+200.)),random(vec2(glv+fi+100.)),random(glv+vec2(fi)))-vec3(0.5));\n  float d,t =0.;\n  float maxdis = 1000.;\n  float mindis = 0.001;\n  \n  for(int i = 0;i<34;i++){\n     d = dist(ro+rd*t);\n     t += d;\n     if(d<mindis||t>maxdis)break;\n  }\n   \n  vec3 col = vec3(0);\n  vec3 sp = ro+rd*t;\n  vec3 ld = normalize(vec3(0.5,1,-1));\n  vec3 vd = rd;\n  vec3 nor = getNormal(sp);\n  if(d<mindis){\n    col = abs(nor);\n    if(door(sp)<mindis){\n      col=woodoorlight(sp,ld,nor,vd);\n      if(0.1>abs(sp.z)&&(ana(sp)<mindis&&abs(nor.z)>0.9)){\n        col = paperlight(sp,ld,nor,vd);\n      }\n    };\n    if(ueno(sp)<mindis){\n    col=wooduplight(sp,ld,nor,vd);\n    }\n    if(rope1(sp).w<mindis){\n      col = clamp(mix(vec3(0.2,0.8,0.8),vec3(1,0.4,0.4),+0.25-rope1(sp).y),0.,1.);\n    }else if(cup1(sp).w<mindis){\n      vec3 scp = rope1(sp).xyz;\n      col = clamp(0.8-scp.yyy,0.,1.)*vec3(0.5,1.,1.5)+vec3(1,0,0)*step(fbm(scp.xy*20.),0.52);\n    }else if(rope2(sp).w<mindis){\n      col = vec3(0.2,0.8,0.8);\n    }else if(paper1(sp).w<mindis){\n      col = clamp(mix(vec3(1),vec3(1,0.4,0.4),paper1(sp).y),0.,1.);\n    }\n  }\n  else{\n    col = sky(vd,ld);\n  }\n  fcol += col;\n}\nfcol = fcol/float(bokashi);\n//col = abs(nor);\n//col = pow(col,vec3(1./2.2));\n\n\n\nfragColor=vec4(fcol,1);}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}