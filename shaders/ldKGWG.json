{
    "Shader": {
        "info": {
            "date": "1456242327",
            "description": "Tokyodemofest GLSL compo 4th",
            "flags": 0,
            "hasliked": 0,
            "id": "ldKGWG",
            "likes": 10,
            "name": "[TDF16]BoostedDrone",
            "published": 3,
            "tags": [
                "drone"
            ],
            "usePreview": 0,
            "username": "yasuo",
            "viewed": 869
        },
        "renderpass": [
            {
                "code": "#define NEAR 0.01\n#define FAR 84.\n#define ITER 84\n\nfloat tt;\nfloat atime;\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nfloat c_0 = 31599.0;\nfloat c_1 = 9362.0;\nfloat c_2 = 29671.0;\nfloat c_3 = 29391.0;\nfloat c_4 = 23497.0;\nfloat c_5 = 31183.0;\nfloat c_6 = 31215.0;\nfloat c_7 = 29257.0;\nfloat c_8 = 31727.0;\nfloat c_9 = 31695.0;\nfloat c_colon = 1040.0;\n\nmat4 matRotateX(float rad)\n{\n\treturn mat4(1,       0,        0,0,\n\t\t\t\t0,cos(rad),-sin(rad),0,\n\t\t\t\t0,sin(rad), cos(rad),0,\n\t\t\t\t0,       0,        0,1);\n}\n\nmat4 matRotateY(float rad)\n{\n\treturn mat4( cos(rad),0,-sin(rad),0,\n\t\t\t\t 0,       1,        0,0,\n\t\t\t\t sin(rad),0, cos(rad),0,\n\t\t\t\t 0,       0,        0,1);\n}\n\nmat4 matRotateZ(float rad)\n{\n\treturn mat4(cos(rad),-sin(rad),0,0,\n\t\t\t\tsin(rad), cos(rad),0,0,\n\t\t\t\t       0,        0,1,0,\n\t\t\t\t\t   0,        0,0,1);\n}\n\nmat3 mat3RotateX(float rad)\n{\n\treturn mat3(1,       0,        0,\n\t\t\t\t0,cos(rad),-sin(rad),\n\t\t\t\t0,sin(rad), cos(rad));\n}\n\nvec4 combine(vec4 val1, vec4 val2 )\n{\n\tif ( val1.w < val2.w ) return val1;\n\treturn val2;\n}\n\n// iq's distance functions\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n\treturn mix(b, a, h) - k * h * (1.0 - h);\n}\n\n\nfloat line(vec2 p, vec2 p0, vec2 p1, float w) {\n    vec2 d = p1 - p0;\n\tfloat WEIGHT = 3.0 / iResolution.x;\n    float t = clamp(dot(d,p-p0) / dot(d,d), tan(iTime *1.0)*1.5,1.0+tan(iTime *1.0)*0.5);\n    vec2 proj = p0 + d * t/1.0;\n    float dist = length(p - proj);\t\t\t\n    dist = 1.0/dist*WEIGHT*(w);\n\t\n    return min(dist*dist,1.0);\n}\n\nfloat staticline(vec2 p, vec2 p0, vec2 p1, float w) {\n    float WEIGHT = 3.0 / iResolution.x;\n    vec2 d = p1 - p0;\n\t\n    float t = clamp(dot(d,p-p0) / dot(d,d), 0.0,1.0);\n    vec2 proj = p0 + d * t/1.0;\n    float dist = length(p - proj);\t\t\t\n    dist = 1.0/dist*WEIGHT*(w);\n\t\n    return min(dist*dist,1.0);\n}\n\nfloat getBit(float num,float bit)\n{\n\tnum = floor(num);\n\tbit = floor(bit);\n\t\n\treturn float(mod(floor(num/pow(2.,bit)),2.) == 1.0);\n}\n\nfloat Sprite3x5(float sprite,vec2 p)\n{\n\tfloat bounds = float(all(lessThan(p,vec2(3,5))) && all(greaterThanEqual(p,vec2(0,0))));\n\t\n\treturn getBit(sprite,(2.0 - p.x) + 3.0 * p.y) * bounds;\n}\n\nfloat Digit(float num,vec2 p)\n{\n\tnum = mod(floor(num),11.0);\n\t\n\tif(num == 0.0) return Sprite3x5(c_0,p);\n\tif(num == 1.0) return Sprite3x5(c_1,p);\n\tif(num == 2.0) return Sprite3x5(c_2,p);\n\tif(num == 3.0) return Sprite3x5(c_3,p);\n\tif(num == 4.0) return Sprite3x5(c_4,p);\n\tif(num == 5.0) return Sprite3x5(c_5,p);\n\tif(num == 6.0) return Sprite3x5(c_6,p);\n\tif(num == 7.0) return Sprite3x5(c_7,p);\n\tif(num == 8.0) return Sprite3x5(c_8,p);\n\tif(num == 9.0) return Sprite3x5(c_9,p);\n\tif(num == 10.0) return Sprite3x5(c_colon,p);\n\t\n\treturn 0.0;\n}\n\n// terrain from https://www.shadertoy.com/view/lt2GRV\nvoid rotate(const float a, inout vec2 v)\n{\n    float cs = cos(a), ss = sin(a);\n    vec2 u = v;\n    v.x = u.x*cs + u.y*ss;\n    v.y = u.x*-ss+ u.y*cs;\n}\n\nfloat dfTerraHills(vec3 p)\n{\n    p.y-=1.0;\n    vec3 pm = p;\n    pm.xz = mod(pm.xz+vec2(8.0),16.0)-vec2(8.0);\n    pm = abs(pm);\n    return (p.y*.8+3.0+pm.x*.1+pm.z*.1);\n}\n\nfloat dfTerra(vec3 p)\n{\n    p.y+=.1;\n    vec3 p2 = p;\n    float height = (sin(p.x*.1)+sin(p.z*.1))*1.5;\n    rotate(.6,p2.xz);\n    return max(dfTerraHills(p2),dfTerraHills(p))+height;\n}\n\nvec4 map( vec3 pos, mat4 m)\n{\n\tfloat d = 10.0;\n\n\tvec4 q = vec4(pos+vec3(0,-3,-50.0),1.0)*m;\n\tvec4 ql = vec4(pos+vec3(0,-3,-50.0)+vec3( 0, 0, iTime*50.0 ),1.0);\n\tvec4 body1 = vec4(vec3(0.35,0.0,0.0),sdBox(q.xyz + vec3( 0, 0, 0 ), vec3(1.0,1.0,13.0) ));\n\tvec4 body2 = vec4(vec3(0.35,0.0,0.0),sdBox(q.xyz + vec3( 0, 0, 0 ), vec3(13.0,1.0,1.0) ));\n\tvec4 body3 = vec4(vec3(0.35,0.0,0.0),sdBox(q.xyz + vec3( 0, 0, 0 ), vec3(3.0,2.0,3.0) ));\n\td = min(d, smin(body1.w, body2.w, 0.2));\n\td = smin(d, body3.w, 0.2);\n\n\tql.z = mod(ql.z, 16.0)-8.0;\n\tvec4 lineL = vec4(vec3(0.5,0.1,0.1),sdBox(ql.xyz + vec3( 17.0, 2.0, 0 ), vec3(0.5,0.01,3.0) ));\n\tvec4 lineR = vec4(vec3(0.5,0.1,0.1),sdBox(ql.xyz + vec3( -17.0, 2.0, 0 ), vec3(0.5,0.01,3.0) ));\n\n\tvec4 wholeBody = vec4(0.33,0.33,0.32,d);\n\n\tvec4 propeller1a = vec4(vec3(0.7,0.7,0.7),sdBox(q.xyz + vec3( 12.0, -1.0, 0 ), vec3(0.5,3.0,0.5) ));\n\tvec4 prot1 = (q+vec4( 12.0, -3.7, 0, 1.0))*matRotateY(-iTime*7.0);\n\tvec4 propeller1b = vec4(vec3(1.0,0.16,0.0),sdBox(prot1.xyz, vec3(0.5,0.1,7.0) ));\n\n\tvec4 propeller2a = vec4(vec3(0.7,0.7,0.7),sdBox(q.xyz + vec3( -12.0, -1.0, 0 ), vec3(0.5,3.0,0.5) ));\n\tvec4 prot2 = (q+vec4( -12.0, -3.7, 0, 1.0))*matRotateY(-iTime*7.5);\n\tvec4 propeller2b = vec4(vec3(1.0,0.16,0.0),sdBox(prot2.xyz, vec3(0.5,0.1,7.0) ));\n\n\tvec4 propeller3a = vec4(vec3(0.7,0.7,0.7),sdBox(q.xyz + vec3( 0.0, -1.0, 12.0 ), vec3(0.5,3.0,0.5) ));\n\tvec4 prot3 = (q+vec4(0.0, -3.7, 12.0, 1.0))*matRotateY(iTime*7.3);\n\tvec4 propeller3b = vec4(vec3(1.0,0.16,0.0),sdBox(prot3.xyz, vec3(0.5,0.1,7.0) ));\n\n\tvec4 propeller4a = vec4(vec3(0.7,0.7,0.7),sdBox(q.xyz + vec3( 0.0, -1.0, -12.0 ), vec3(0.5,3.0,0.5) ));\n\tvec4 prot4 = (q+vec4(0.0, -3.7, -12.0, 1.0))*matRotateY(iTime*7.5);\n\tvec4 propeller4b = vec4(vec3(1.0,0.16,0.0),sdBox(prot4.xyz, vec3(0.5,0.1,7.0) ));\n\n\tvec4 terrain = vec4(0.15,0.15,0.15,dfTerra(pos+vec3( 0, 0, iTime*30.0 )));\n\n\tvec4 temp = combine(terrain,wholeBody);\n\tvec4 temp1 = combine(lineL,lineR);\n\tvec4 temp2 = combine(propeller1a,propeller1b);\n\tvec4 temp3 = combine(propeller2a,propeller2b);\n\tvec4 temp4 = combine(propeller3a,propeller3b);\n\tvec4 temp5 = combine(propeller4a,propeller4b);\n\n\tvec4 temp6 = combine(temp,temp1);\n\tvec4 temp7 = combine(temp2,temp3);\n\tvec4 temp8 = combine(temp4,temp5);\n\tvec4 temp9 = combine(temp6,temp7);\n\tvec4 temp10 = combine(temp8,temp9);\n\n\treturn temp10;\n}\n\nvec2 rot(vec2 p, float a) {\n\treturn vec2(\n\t\tcos(a) * p.x - sin(a) * p.y,\n\t\tsin(a) * p.x + cos(a) * p.y);\n}\n\nvec3 gradientbg(float p)\n{\n\tfloat span = 15.0;\n\tvec3 b0 = vec3(0.15, 0.15, 0.15)   * (step(p,(1.0/span) * 5.0) - (step(p,(1.0/span) * (5.0 - 1.))));\n    vec3 b1 = vec3(0.25, 0.25, 0.25)   * (step(p,(1.0/span) * 4.0) - (step(p,(1.0/span) * (4.0 - 1.))));\n    vec3 b2 = vec3(0.3, 0.3, 0.3)   * (step(p,(1.0/span) * 3.0) - (step(p,(1.0/span) * (3.0 - 1.))));\n    vec3 b3 = vec3(0.32, 0.32, 0.32)   * (step(p,(1.0/span) * 2.0) - (step(p,(1.0/span) * (2.0 - 1.))));\n    vec3 b4 = vec3(0.35,0.35, 0.35) * (step(p,(1.0/span) * 1.0) - (step(p,(1.0/span) * (1.0 - 1.))));\n    return b0 + b1 + b2 + b3 + b4;\n}\n\nvec3 drawRader(vec2 p, vec2 pos, float r){\n    float dist =  sqrt(dot(p+pos, p+pos));\n\tfloat border = 0.006;\n\tfloat circle_radius = 0.15;\n\tvec3 cl = vec3(0);\n\tfloat l = staticline(p+pos,vec2(0),rot(vec2(0.1,0.1),r), 0.5);\n\t\n\tif ( (dist > (circle_radius+border)) || (dist < (circle_radius-border)) ){\n\t\tcl += vec3(0)+vec3(vec3(l)*vec3(1.0,0.16,0.0));\n\t}else{ \n\t\tcl += vec3(0.3)+vec3(vec3(l)*vec3(1.0,0.16,0.0));\n\t}\n\treturn cl;\n}\n\nfloat loopEnd = 20.0;\nvoid drwaScene(out vec4 fragColor, in vec2 fragCoord, vec2 position,vec3 dir) {\n\tfloat aspect = iResolution.x / iResolution.y;\n \tdir = normalize(vec3(position * vec2(aspect, 1.0), 1.0));\n \tvec3 pos;\n\n \tif(mod(iTime,loopEnd) >= 0.0 && mod(iTime,loopEnd) < 5.0) {\n\t\tdir.yz = rot(dir.yz, 1.2 - mod(iTime*(1.0/5.0),1.0));\n\t \tpos = vec3(0.0, 60.0-mod(iTime*(52.0/5.0), 52.0), 35.0-mod(iTime*(30.0/5.0),30.0));\n \t}\n\n \tif(mod(iTime,loopEnd) >= 5.0 && mod(iTime,loopEnd) < 15.0) {\n \t\tdir.yz = rot(dir.yz, 0.2);\n \t\tpos = vec3(0.0, 8.0, 5.0);\n \t}\n\n    /*\n\tif(mod(time,loopEnd) >= 10.0 && mod(time,loopEnd) < 15.0) {\n\t\tdir.xz = rot(dir.xz, (DEG_TO_RAD*180.0));\n \t\tpos = vec3(0.0, 3.0, 115.0);\n\t}\n    */\n\n\tif(mod(iTime,loopEnd) >= 15.0) {\n \t\tdir.yz = rot(dir.yz, 0.2);\n \t\tpos = vec3(0.0, 8.0, 5.0);\n\t}\n\n\tmat4 m = matRotateY(DEG_TO_RAD*45.0)*matRotateX(sin(iTime*2.0)*(DEG_TO_RAD*5.0))*matRotateZ(sin(iTime*1.5)*(DEG_TO_RAD*7.0));\n\n\tvec4 result;\n\tfloat e = 0.0001;\n\tfloat t = e * 2.0;\n\tfloat h = 0.0;\n\tfor (int i = 0; i < ITER; i++)\n\t{\n\t\tif(t < e || t > 20.0) continue;\n\t\tresult = map(pos, m);\n\t\tif (result.w < NEAR || result.w > FAR) break;\n\t\tpos += result.w * dir;\n\t\tt += h;\n\t}\n \n\tvec3 col = map(pos, m).xyz;\n\tvec4 bgCol;\n\tif ( pos.z> 100. )\n\t{\n\t\t// bg\n\t\tposition.y += (sin((position.x + (iTime * 0.3)) * 2.0) * 0.1) + (sin((position.x + (iTime * 0.1)) * 10.0) * 0.01);\n\t\tfloat xpos = 0.2;\n\t\tfloat ypos = 0.13;\n\t\tfloat l = line(position,vec2(0.1+xpos,0.1+ypos),vec2(0.22+xpos,0.1+ypos),0.2);\n\t\tl += line(position,vec2(0.12+xpos,0.12+ypos),vec2(0.2+xpos,0.12+ypos),0.2);\t\t\t\t\n\t\tl += staticline(position,vec2(0.1+xpos,0.1+ypos),vec2(0.22+xpos,0.1+ypos),0.2);\n\t\tl += staticline(position,vec2(0.1+xpos,0.1+ypos),vec2(0.178+xpos,0.3+ypos),0.2);\n\t\tl += staticline(position,vec2(0.22+xpos,0.1+ypos),vec2(0.19+xpos,0.25+ypos),0.2);\n\t\tl += staticline(position,vec2(0.12+xpos,0.12+ypos),vec2(0.2+xpos,0.12+ypos),0.2);\n\t\tl += staticline(position,vec2(0.12+xpos,0.12+ypos),vec2(0.178+xpos,0.27+ypos),0.2);\n\n\t\tcol = gradientbg(position.y+0.1)+(vec3(l)*vec3(1.0,0.16,0.0));\n\t}\n\telse\n\t{\n\t\t// shade\n\t\tvec3 lightPos = vec3(20.0, 20.0, 20.0 );\n\t\tvec3 light2Pos = normalize( lightPos - pos);\n\t\tvec3 eps = vec3( .1, .01, .0 );\n\t\tvec3 n = vec3( result.w - map( pos - eps.xyy, m ).w,\n\t\t\t       result.w - map( pos - eps.yxy, m ).w,\n\t\t\t       result.w - map( pos - eps.yyx, m ).w );\n\t\tn = normalize(n);\n\t\t\t\t\n\t\tfloat lambert = max(.0, dot( n, light2Pos));\n\t\tcol *= vec3(lambert);\n\n\t\tcol += vec3(result.xyz);\n\t}\n\n\tposition = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 cl3 = vec3(0);\n\tcl3 += drawRader(position,vec2(1.23,-0.80),iTime*2.0);\n\tcl3 += drawRader(position,vec2(1.58,-0.80),-iTime*3.0);\n\n\tposition = ( fragCoord.xy /iResolution.xy ) * vec2(256,128);\n\tvec2 cpos = vec2(1.5);\n\tfloat dc = Digit(fract(iTime)*10.0,floor(position-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(fract(iTime)*20.0,floor(position-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(10.0,floor(position-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(fract(iTime)*40.0,floor(position-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(fract(iTime)*50.0,floor(position-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(10.0,floor(position-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(fract(iTime)*70.0,floor(position-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(fract(iTime)*80.0,floor(position-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(fract(iTime)*90.0,floor(position-cpos));\n\n\tvec3 cl2 = vec3(dc)*vec3(0.3,0.3,0.3);\n\n\tfragColor = vec4( col+cl2+cl3, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 position = ( fragCoord.xy / iResolution.xy );\n\tposition -= .5;\n\tvec3 dir = vec3( position, 1.0 );\n\t/*\n\tif(mod(time,20.0) >= 10.0 && mod(time,20.0) < 15.0) {\n\t\tposition = mod(position, .5);\n\t\tposition = position * 2.0 - .5;\n\t\tposition.y /= iResolution.x / iResolution.y;\n\t}\n\t*/\n    drwaScene(fragColor,fragCoord,position,dir);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}