{
    "Shader": {
        "info": {
            "date": "1585835552",
            "description": "The Amiga and its ever-present ball",
            "flags": 0,
            "hasliked": 0,
            "id": "wsfyDs",
            "likes": 17,
            "name": "Amiga Balls",
            "published": 3,
            "tags": [
                "amiga",
                "bounce",
                "recursion",
                "computer"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 492
        },
        "renderpass": [
            {
                "code": "// \"Amiga Balls\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// The Amiga and its ever-present ball\n\n// The Amiga was the best graphics PC when it first appeared.\n\n#define AA   1   // optional antialiasing\n\n#define GURU 0   // optional guru meditation message\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvoid PxInit ();\nvoid PxBgn (vec2 p);\nfloat PxText (vec2 p, int txt);\nfloat PxChar (vec2 p, vec4 c);\n\nmat3 vuMat;\nvec3 ltDir, bPos;\nvec2 sSize, cSpace;\nfloat dstFar, tCur, sMidHt;\nint idObj, nRec;\nconst int nRecMax = 6;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, h;\n  dMin = dstFar;\n  q = p;\n  q.y -= 0.35;\n  d = PrRoundBoxDf (q, vec3 (1., 0.16, 0.7), 0.01);\n  q = p - vec3 (0.7, 0.4, -0.72);\n  d = max (d, - PrBoxDf (q, vec3 (0.17, 0.01, 0.2)));\n  q.y -= -0.02;\n  d = max (d, - PrBoxDf (q, vec3 (0.08, 0.08, 0.03)));\n  q.y -= 0.01;\n  d = max (d, - PrBoxDf (q, vec3 (0.045, 0.05, 0.05)));\n  q = p;\n  q.yz -= vec2 (0.3, -0.72);\n  d = max (d, - PrBoxDf (q, vec3 (1.1, 0.01, 0.03)));\n  q = p;\n  q.x = abs (q.x) - 0.4;\n  q.yz -= vec2 (0.35, -0.72);\n  d = max (d, - PrBoxDf (q, vec3 (0.01, 0.17, 0.03)));\n  q = p;\n  q.x = abs (q.x) - 1.;\n  q.yz -= vec2 (0.35, 0.05);\n  d = max (d, - PrBoxDf (q, vec3 (0.02, 0.007, 0.7)));\n  DMIN (1);\n  q = p;\n  q.x = abs (q.x) - 0.95;\n  q.y -= 0.09;\n  q.x -= 0.02 * q.y;\n  d = PrRoundBoxDf (q, vec3 (0.025 + 0.02 * q.y, 0.09, 0.6), 0.005);\n  q = p;\n  q -= vec3 (-0.05, 0.09, 0.3);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.9, 0.09, 0.02), 0.005));\n  DMIN (2);\n  q = p;\n  q.yz -= vec2 (0.55, 0.05);\n  q.xz = abs (q.xz) - vec2 (0.55, 0.4);\n  d = PrCylDf (q.xzy, 0.05, 0.05);\n  DMIN (3);\n  q = p;\n  q.yz -= vec2 (0.71 + sSize.y, -0.45);\n  d = 0.9 * max (PrRoundBoxDf (q, vec3 (sSize.x + 0.16, sSize.y + 0.12, 0.13), 0.03),\n     - PrRoundBox2Df (q.xy, sSize + 0.01, 0.03));\n  DMIN (4);\n  q = p - vec3 (0.7, 0.4, -0.55);\n  d = PrBoxDf (q, vec3 (0.16, 0.008, 0.16));\n  DMIN (5);\n  q = p;\n  h = sSize.y + 0.05 - 0.1 * (q.z - 0.05);\n  q.yz -= vec2 (0.6 + h, 0.05);\n  d = 0.9 * PrRoundBoxDf (q, vec3 (sSize.x + 0.12, h, 0.6), 0.03);\n  DMIN (6);\n  q = p;\n  q.x = mod (q.x + 1., 2.) - 1.;\n  q -= bPos;\n  d = PrSphDf (q, 0.2);\n  DMIN (11);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = VAR_ZERO; j < 8; j ++) {\n    d = float (j + 1) / 16.;\n    ao += max (0., d - 3. * ObjDf (ro + d * rd));\n  }\n  return 0.4 + 0.6 * clamp (1. - 0.2 * ao, 0., 1.);\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  vec2 q;\n  float d;\n  if (rd.y >= 0.) col = vec3 (0.1, 0.2, 0.3) + 0.2 * pow (1. - rd.y, 5.);\n  else {\n    d = - ro.y / rd.y;\n    q = ro.xz + d * rd.xz;\n    col = mix (mix (vec3 (0.3, 0.1, 0.), vec3 (0.4, 0.2, 0.), smoothstep (0.4, 0.6, Fbm2 (q * vec2 (1., 4.)))),\n       vec3 (0.3, 0.4, 0.5), 1. - min (1., exp2 (2. - 8. * d / dstFar)));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro)\n{\n  vec4 col4;\n  vec3 col, rd, roh, vn, q;\n  vec2 sb, a;\n  float dstObj, ao;\n  bool isBg, isScrn;\n  isBg = false;\n  isScrn = true;\n  for (int k = VAR_ZERO; k <= nRecMax; k ++) {\n    rd = normalize (vec3 (ro.xy, 7.));\n    if (k == 0) ro.xy = vec2 (0.);\n    ro.z -= 20. * sSize.y;\n    rd = vuMat * rd;\n    ro = vuMat * ro;\n    ro.y += sMidHt;\n    dstObj = ObjRay (ro, rd);\n    if (dstObj >= dstFar) isBg = true;\n    else {\n      ro += dstObj * rd;\n      roh = ro;\n      if (idObj != 6) isScrn = false;\n      else {\n        ro.y -= sMidHt;\n        sb = abs (ro.xy) - sSize;\n#if GURU\n        isScrn = (max (sb.x, sb.y) < 0. && ro.z < -0.5 && k < nRec);\n#else\n        isScrn = (max (sb.x, sb.y) < 0. && ro.z < -0.5);\n#endif\n      } \n    }\n#if GURU\n    if (! isScrn || isBg || k == nRec) break;\n#else\n    if (! isScrn || isBg) break;\n#endif\n  }\n  if (isBg) {\n    col = BgCol (ro, rd);\n    if (rd.y < 0.) {\n      roh = ro - (ro.y / rd.y) * rd;\n      if (length (roh.xz) < 2.) col *= ObjAO (roh, vec3 (0., 1., 0.));\n    }\n  } else {\n    col4 = vec4 (0.8, 0.81, 0.79, 0.);\n    PxInit ();\n    if (idObj < 11) {\n      if (idObj == 1) {\n        if (ro.z < -0.65) {\n          col4.rgb *= 1.2;\n          sb = ro.xy - vec2 (-0.82, 0.42);\n          sb.x -= 0.2 * sb.y;\n          if (PxText (sb * 260., 1) > 0.) col4 = vec4 (0.1);\n          else if (PxText ((ro.xy - vec2 (-0.75, 0.21)) * 240., 2) > 0.)\n             col4 = vec4 (0.1, 0.1, 0.8, 0.3);\n          else if (abs (abs (ro.x) - 0.9) < 0.02 && abs (ro.y - 0.3) < 0.008)\n             col4 = (ro.x < 0.) ? vec4 (0., 1., 0., -1.) : ((mod (0.33 * tCur, 1.) < 0.3) ?\n             vec4 (1., 0., 0., -1.) : vec4 (0.4, 0.4, 0.4, 0.1));\n        }\n      } else if (idObj == 2) {\n        col4 *= 0.9;\n      } else if (idObj == 3) {\n        col4.rgb = vec3 (0.4, 0.3, 0.1);\n      } else if (idObj == 4) {\n        if (ro.z < -0.45) col4 *= 1.2;\n        if (ro.z < -0.6 && abs (ro.x) < sSize.x + 0.15 &&\n           abs (ro.y - sMidHt) < sSize.y + 0.11) col4 *= 0.8;\n      } else if (idObj == 5) {\n        col4.rgb = vec3 (0.1);\n      } else if (idObj == 6) {\n        if (length (ro.yz - vec2 (-0.4, -0.05)) < 0.15 &&\n           mod (ro.y + 0.4 - 0.01, 0.04) < 0.02) col4 *= 0.4;\n        else if (ro.z < -0.5) {\n          col4 = vec4 (0.1);\n#if GURU\n          sb = (ro.xy - vec2 (0., 0.6 * sSize.y)) * 340.;\n          if (PxText (sb, 0) > 0.) col4 = vec4 (1., 0., 0., -1.);\n          else if (mod (tCur, 1.) < 0.5) {\n            ro.xy = (abs (sb - vec2 (0., -1.5) * cSpace) - vec2 (29., 7.) * cSpace);\n            if (max (ro.x, ro.y) < 1.25 &&\n               (min (abs (ro.x), abs (ro.y)) < 1.25)) col4 = vec4 (1., 0., 0., -1.);\n          }\n#endif\n        }\n      }\n    }\n    if (! isScrn) {\n      if (col4.a >= 0.) {\n        vn = ObjNf (roh);\n        if (idObj < 11) vn = VaryNf (128. * roh, vn, 0.2);\n        else {\n          sb = Rot2D (vn.xy, -0.1 * pi);\n          a = sign (mod (floor (8. * vec2 (atan (sb.x, vn.z) + 0.6 * pi * tCur, asin (sb.y)) / pi), 2.) - 0.5);\n          col4 = mix (vec4 (1., 0., 0., 0.2), vec4 (0.95, 0.95, 1., 0.2), step (0., a.x * a.y));\n        }\n        ao = ObjAO (roh, vn);\n        col = ao * (col4.rgb * (0.2 + 0.1 * max (0., - dot (vn, normalize (vec3 (ltDir.xz, 0.).xzy))) +\n           0.8 * (max (0., dot (vn, ltDir)))) + col4.a * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.));\n      } else col = col4.rgb;\n    }\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ut;\n  float el, az, zmFac, sr, ds, s, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  ut = abs (uv) - vec2 (1.33, 1.);\n  if (max (ut.x, ut.y) > 0.003) col = vec3 (0.82);\n  else {\n    dstFar = 60.;\n    ltDir = normalize (vec3 (1., 3., -1.));\n    ds = SmoothBump (0.2, 0.8, 0.1, mod (0.043 * tCur, 1.));\n    az = -0.07 * pi * (2. * floor (mod (0.043 * tCur + 0.5, 2.)) - 1.) * (1. - ds);\n    el = -0.01 * pi * (1. - ds);\n    if (mPtr.z > 0.) {\n      az += pi * mPtr.x;\n      el += 0.3 * pi * mPtr.y;\n    }\n    az = clamp (az, -0.4 * pi, 0.4 * pi);\n    vuMat = StdVuMat (clamp (el, -0.4 * pi, 0.01 * pi), az);\n    sSize = 0.55 * vec2 (1.33, 1.);\n    sMidHt = 1.26;\n    nRec = int ((1. - abs (2. * mod (0.1 * tCur, 1.) - 1.)) * float (nRecMax + 1));\n    zmFac = 12. * sSize.y * ds;\n    t = mod (0.3 * tCur, 2.);\n    s = sign (2. * floor (t) - 1.);\n    t = mod (t, 1.);\n    bPos = vec3 (1.5 * s * (0.5 - t), 0.2 + 8. * t * (1. - t), -5.);\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      col += (1. / naa) * ShowScene (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n         sr * (0.667 * a + 0.5) * pi), zmFac));\n    }\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n/*\n Text derived from 8x12 Font shader by Flyguy (Mt2GWD)\n Glyph bitmaps generated from 8x12 font sheet\n   http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n*/\n\n#define g_spc  0\n#define g_exc  1\n#define g_quo  2\n#define g_hsh  3\n#define g_dol  4\n#define g_pct  5\n#define g_amp  6\n#define g_apo  7\n#define g_lbr  8\n#define g_rbr  9\n#define g_ast 10\n#define g_crs 11\n#define g_com 12\n#define g_dsh 13\n#define g_per 14\n#define g_lsl 15\n#define g_0   16\n#define g_1   17\n#define g_2   18\n#define g_3   19\n#define g_4   20\n#define g_5   21\n#define g_6   22\n#define g_7   23\n#define g_8   24\n#define g_9   25\n#define g_col 26\n#define g_scl 27\n#define g_les 28\n#define g_equ 29\n#define g_grt 30\n#define g_que 31\n#define g_ats 32\n#define g_A   33\n#define g_B   34\n#define g_C   35\n#define g_D   36\n#define g_E   37\n#define g_F   38\n#define g_G   39\n#define g_H   40\n#define g_I   41\n#define g_J   42\n#define g_K   43\n#define g_L   44\n#define g_M   45\n#define g_N   46\n#define g_O   47\n#define g_P   48\n#define g_Q   49\n#define g_R   50\n#define g_S   51\n#define g_T   52\n#define g_U   53\n#define g_V   54\n#define g_W   55\n#define g_X   56\n#define g_Y   57\n#define g_Z   58\n#define g_lsb 59\n#define g_rsl 60\n#define g_rsb 61\n#define g_pow 62\n#define g_usc 63\n#define g_a   64\n#define g_b   65\n#define g_c   66\n#define g_d   67\n#define g_e   68\n#define g_f   69\n#define g_g   70\n#define g_h   71\n#define g_i   72\n#define g_j   73\n#define g_k   74\n#define g_l   75\n#define g_m   76\n#define g_n   77\n#define g_o   78\n#define g_p   79\n#define g_q   80\n#define g_r   81\n#define g_s   82\n#define g_t   83\n#define g_u   84\n#define g_v   85\n#define g_w   86\n#define g_x   87\n#define g_y   88\n#define g_z   89\n#define g_lpa 90\n#define g_bar 91\n#define g_rpa 92\n#define g_tid 93\n#define g_lar 94\n\n#define C(g) s += PxChar (p, glph[g]);\n\n#define _spc C(g_spc)  \n#define _exc C(g_exc)\n#define _quo C(g_quo)\n#define _hsh C(g_hsh) \n#define _dol C(g_dol) \n#define _pct C(g_pct) \n#define _amp C(g_amp) \n#define _apo C(g_apo) \n#define _lbr C(g_lbr) \n#define _rbr C(g_rbr) \n#define _ast C(g_ast) \n#define _crs C(g_crs) \n#define _com C(g_com) \n#define _dsh C(g_dsh) \n#define _per C(g_per) \n#define _lsl C(g_lsl) \n#define _0   C(g_0) \n#define _1   C(g_1) \n#define _2   C(g_2) \n#define _3   C(g_3) \n#define _4   C(g_4) \n#define _5   C(g_5) \n#define _6   C(g_6) \n#define _7   C(g_7) \n#define _8   C(g_8) \n#define _9   C(g_9) \n#define _col C(g_col) \n#define _scl C(g_scl) \n#define _les C(g_les) \n#define _equ C(g_equ) \n#define _grt C(g_grt) \n#define _que C(g_que) \n#define _ats C(g_ats) \n#define _A   C(g_A) \n#define _B   C(g_B) \n#define _C   C(g_C) \n#define _D   C(g_D) \n#define _E   C(g_E) \n#define _F   C(g_F) \n#define _G   C(g_G) \n#define _H   C(g_H) \n#define _I   C(g_I) \n#define _J   C(g_J) \n#define _K   C(g_K) \n#define _L   C(g_L) \n#define _M   C(g_M) \n#define _N   C(g_N) \n#define _O   C(g_O) \n#define _P   C(g_P) \n#define _Q   C(g_Q) \n#define _R   C(g_R) \n#define _S   C(g_S) \n#define _T   C(g_T) \n#define _U   C(g_U) \n#define _V   C(g_V) \n#define _W   C(g_W) \n#define _X   C(g_X) \n#define _Y   C(g_Y) \n#define _Z   C(g_Z) \n#define _lsb C(g_lsb) \n#define _rsl C(g_rsl) \n#define _rsb C(g_rsb) \n#define _pow C(g_pow) \n#define _usc C(g_usc) \n#define _a   C(g_a) \n#define _b   C(g_b) \n#define _c   C(g_c) \n#define _d   C(g_d) \n#define _e   C(g_e) \n#define _f   C(g_f) \n#define _g   C(g_g) \n#define _h   C(g_h) \n#define _i   C(g_i) \n#define _j   C(g_j) \n#define _k   C(g_k) \n#define _l   C(g_l) \n#define _m   C(g_m) \n#define _n   C(g_n) \n#define _o   C(g_o) \n#define _p   C(g_p) \n#define _q   C(g_q) \n#define _r   C(g_r) \n#define _s   C(g_s) \n#define _t   C(g_t) \n#define _u   C(g_u) \n#define _v   C(g_v) \n#define _w   C(g_w) \n#define _x   C(g_x) \n#define _y   C(g_y) \n#define _z   C(g_z) \n#define _lpa C(g_lpa) \n#define _bar C(g_bar) \n#define _rpa C(g_rpa) \n#define _tid C(g_tid) \n#define _lar C(g_lar) \n\nvec4 glph[95];\nvec2 cPos;\n\nfloat PxChar (vec2 p, vec4 c)\n{\n  vec2 cb;\n  float pOn, b;\n  p = floor (p - cPos);\n  if (min (p.x, p.y) >= 0. && max (p.x - 8., p.y - 12.) < 0.) {\n    b = 8. * (p.y + 1.) - (p.x + 1.);\n    if (b < 48.) cb = (b < 24.) ? vec2 (c.w, b) : vec2 (c.z, b - 24.);\n    else cb = (b < 72.) ? vec2 (c.y, b - 48.) : vec2 (c.x, b - 72.);\n    pOn = mod (floor (cb.x / exp2 (cb.y)), 2.);\n  } else pOn = 0.;\n  cPos.x += cSpace.x;\n  return pOn;\n}\n\nvoid PxBgn (vec2 p)\n{\n  cPos = floor (p * cSpace);\n}\n\nfloat PxText (vec2 p, int txt)\n{\n  float s;\n  s = 0.;\n  if (txt == 0) {\n#if GURU\n    PxBgn (- vec2 (27., -1.));\n    _S _o _f _t _w _a _r _e _spc _F _a _i _l _u _r _e _per _spc _P _r _e _s _s _spc \n    _l _e _f _t _spc _m _o _u _s _e _spc _b _u _t _t _o _n _spc _t _o _spc \n    _c _o _n _t _i _n _u _e _per\n    PxBgn (- vec2 (17., 1.));\n    _G _u _r _u _spc _M _e _d _i _t _a _t _i _o _n _spc _hsh\n    _8 _2 _0 _1 _0 _0 _0 _3 _per _D _E _A _D _B _E _E _F\n    PxBgn (- vec2 (7., 5.));\n    _B _e _w _a _r _e _exc _spc _C _O _R _O _N _A _exc _exc \n#endif\n  } else if (txt == 1) {\n    PxBgn (- vec2 (2., 0.));\n    _A _M _I _G _A\n  } else if (txt == 2) {\n    PxBgn (- vec2 (4., 0.));\n    _C _o _m _m _o _d _o _r _e\n   }\n  return s;\n}\n\nvoid PxInit ()\n{\n  glph[g_spc] = vec4 (0x000000, 0x000000, 0x000000, 0x000000);\n  glph[g_exc] = vec4 (0x003078, 0x787830, 0x300030, 0x300000);\n  glph[g_quo] = vec4 (0x006666, 0x662400, 0x000000, 0x000000);\n  glph[g_hsh] = vec4 (0x006C6C, 0xFE6C6C, 0x6CFE6C, 0x6C0000);\n  glph[g_dol] = vec4 (0x30307C, 0xC0C078, 0x0C0CF8, 0x303000);\n  glph[g_pct] = vec4 (0x000000, 0xC4CC18, 0x3060CC, 0x8C0000);\n  glph[g_amp] = vec4 (0x0070D8, 0xD870FA, 0xDECCDC, 0x760000);\n  glph[g_apo] = vec4 (0x003030, 0x306000, 0x000000, 0x000000);\n  glph[g_lbr] = vec4 (0x000C18, 0x306060, 0x603018, 0x0C0000);\n  glph[g_rbr] = vec4 (0x006030, 0x180C0C, 0x0C1830, 0x600000);\n  glph[g_ast] = vec4 (0x000000, 0x663CFF, 0x3C6600, 0x000000);\n  glph[g_crs] = vec4 (0x000000, 0x18187E, 0x181800, 0x000000);\n  glph[g_com] = vec4 (0x000000, 0x000000, 0x000038, 0x386000);\n  glph[g_dsh] = vec4 (0x000000, 0x0000FE, 0x000000, 0x000000);\n  glph[g_per] = vec4 (0x000000, 0x000000, 0x000038, 0x380000);\n  glph[g_lsl] = vec4 (0x000002, 0x060C18, 0x3060C0, 0x800000);\n  glph[g_0]   = vec4 (0x007CC6, 0xD6D6D6, 0xD6D6C6, 0x7C0000);\n  glph[g_1]   = vec4 (0x001030, 0xF03030, 0x303030, 0xFC0000);\n  glph[g_2]   = vec4 (0x0078CC, 0xCC0C18, 0x3060CC, 0xFC0000);\n  glph[g_3]   = vec4 (0x0078CC, 0x0C0C38, 0x0C0CCC, 0x780000);\n  glph[g_4]   = vec4 (0x000C1C, 0x3C6CCC, 0xFE0C0C, 0x1E0000);\n  glph[g_5]   = vec4 (0x00FCC0, 0xC0C0F8, 0x0C0CCC, 0x780000);\n  glph[g_6]   = vec4 (0x003860, 0xC0C0F8, 0xCCCCCC, 0x780000);\n  glph[g_7]   = vec4 (0x00FEC6, 0xC6060C, 0x183030, 0x300000);\n  glph[g_8]   = vec4 (0x0078CC, 0xCCEC78, 0xDCCCCC, 0x780000);\n  glph[g_9]   = vec4 (0x0078CC, 0xCCCC7C, 0x181830, 0x700000);\n  glph[g_col] = vec4 (0x000000, 0x383800, 0x003838, 0x000000);\n  glph[g_scl] = vec4 (0x000000, 0x383800, 0x003838, 0x183000);\n  glph[g_les] = vec4 (0x000C18, 0x3060C0, 0x603018, 0x0C0000);\n  glph[g_equ] = vec4 (0x000000, 0x007E00, 0x7E0000, 0x000000);\n  glph[g_grt] = vec4 (0x006030, 0x180C06, 0x0C1830, 0x600000);\n  glph[g_que] = vec4 (0x0078CC, 0x0C1830, 0x300030, 0x300000);\n  glph[g_ats] = vec4 (0x007CC6, 0xC6DEDE, 0xDEC0C0, 0x7C0000);\n  glph[g_A]   = vec4 (0x003078, 0xCCCCCC, 0xFCCCCC, 0xCC0000);\n  glph[g_B]   = vec4 (0x00FC66, 0x66667C, 0x666666, 0xFC0000);\n  glph[g_C]   = vec4 (0x003C66, 0xC6C0C0, 0xC0C666, 0x3C0000);\n  glph[g_D]   = vec4 (0x00F86C, 0x666666, 0x66666C, 0xF80000);\n  glph[g_E]   = vec4 (0x00FE62, 0x60647C, 0x646062, 0xFE0000);\n  glph[g_F]   = vec4 (0x00FE66, 0x62647C, 0x646060, 0xF00000);\n  glph[g_G]   = vec4 (0x003C66, 0xC6C0C0, 0xCEC666, 0x3E0000);\n  glph[g_H]   = vec4 (0x00CCCC, 0xCCCCFC, 0xCCCCCC, 0xCC0000);\n  glph[g_I]   = vec4 (0x007830, 0x303030, 0x303030, 0x780000);\n  glph[g_J]   = vec4 (0x001E0C, 0x0C0C0C, 0xCCCCCC, 0x780000);\n  glph[g_K]   = vec4 (0x00E666, 0x6C6C78, 0x6C6C66, 0xE60000);\n  glph[g_L]   = vec4 (0x00F060, 0x606060, 0x626666, 0xFE0000);\n  glph[g_M]   = vec4 (0x00C6EE, 0xFEFED6, 0xC6C6C6, 0xC60000);\n  glph[g_N]   = vec4 (0x00C6C6, 0xE6F6FE, 0xDECEC6, 0xC60000);\n  glph[g_O]   = vec4 (0x00386C, 0xC6C6C6, 0xC6C66C, 0x380000);\n  glph[g_P]   = vec4 (0x00FC66, 0x66667C, 0x606060, 0xF00000);\n  glph[g_Q]   = vec4 (0x00386C, 0xC6C6C6, 0xCEDE7C, 0x0C1E00);\n  glph[g_R]   = vec4 (0x00FC66, 0x66667C, 0x6C6666, 0xE60000);\n  glph[g_S]   = vec4 (0x0078CC, 0xCCC070, 0x18CCCC, 0x780000);\n  glph[g_T]   = vec4 (0x00FCB4, 0x303030, 0x303030, 0x780000);\n  glph[g_U]   = vec4 (0x00CCCC, 0xCCCCCC, 0xCCCCCC, 0x780000);\n  glph[g_V]   = vec4 (0x00CCCC, 0xCCCCCC, 0xCCCC78, 0x300000);\n  glph[g_W]   = vec4 (0x00C6C6, 0xC6C6D6, 0xD66C6C, 0x6C0000);\n  glph[g_X]   = vec4 (0x00CCCC, 0xCC7830, 0x78CCCC, 0xCC0000);\n  glph[g_Y]   = vec4 (0x00CCCC, 0xCCCC78, 0x303030, 0x780000);\n  glph[g_Z]   = vec4 (0x00FECE, 0x981830, 0x6062C6, 0xFE0000);\n  glph[g_lsb] = vec4 (0x003C30, 0x303030, 0x303030, 0x3C0000);\n  glph[g_rsl] = vec4 (0x000080, 0xC06030, 0x180C06, 0x020000);\n  glph[g_rsb] = vec4 (0x003C0C, 0x0C0C0C, 0x0C0C0C, 0x3C0000);\n  glph[g_pow] = vec4 (0x10386C, 0xC60000, 0x000000, 0x000000);\n  glph[g_usc] = vec4 (0x000000, 0x000000, 0x000000, 0x00FF00);\n  glph[g_a]   = vec4 (0x000000, 0x00780C, 0x7CCCCC, 0x760000);\n  glph[g_b]   = vec4 (0x00E060, 0x607C66, 0x666666, 0xDC0000);\n  glph[g_c]   = vec4 (0x000000, 0x0078CC, 0xC0C0CC, 0x780000);\n  glph[g_d]   = vec4 (0x001C0C, 0x0C7CCC, 0xCCCCCC, 0x760000);\n  glph[g_e]   = vec4 (0x000000, 0x0078CC, 0xFCC0CC, 0x780000);\n  glph[g_f]   = vec4 (0x00386C, 0x6060F8, 0x606060, 0xF00000);\n  glph[g_g]   = vec4 (0x000000, 0x0076CC, 0xCCCC7C, 0x0CCC78);\n  glph[g_h]   = vec4 (0x00E060, 0x606C76, 0x666666, 0xE60000);\n  glph[g_i]   = vec4 (0x001818, 0x007818, 0x181818, 0x7E0000);\n  glph[g_j]   = vec4 (0x000C0C, 0x003C0C, 0x0C0C0C, 0xCCCC78);\n  glph[g_k]   = vec4 (0x00E060, 0x60666C, 0x786C66, 0xE60000);\n  glph[g_l]   = vec4 (0x007818, 0x181818, 0x181818, 0x7E0000);\n  glph[g_m]   = vec4 (0x000000, 0x00FCD6, 0xD6D6D6, 0xC60000);\n  glph[g_n]   = vec4 (0x000000, 0x00F8CC, 0xCCCCCC, 0xCC0000);\n  glph[g_o]   = vec4 (0x000000, 0x0078CC, 0xCCCCCC, 0x780000);\n  glph[g_p]   = vec4 (0x000000, 0x00DC66, 0x666666, 0x7C60F0);\n  glph[g_q]   = vec4 (0x000000, 0x0076CC, 0xCCCCCC, 0x7C0C1E);\n  glph[g_r]   = vec4 (0x000000, 0x00EC6E, 0x766060, 0xF00000);\n  glph[g_s]   = vec4 (0x000000, 0x0078CC, 0x6018CC, 0x780000);\n  glph[g_t]   = vec4 (0x000020, 0x60FC60, 0x60606C, 0x380000);\n  glph[g_u]   = vec4 (0x000000, 0x00CCCC, 0xCCCCCC, 0x760000);\n  glph[g_v]   = vec4 (0x000000, 0x00CCCC, 0xCCCC78, 0x300000);\n  glph[g_w]   = vec4 (0x000000, 0x00C6C6, 0xD6D66C, 0x6C0000);\n  glph[g_x]   = vec4 (0x000000, 0x00C66C, 0x38386C, 0xC60000);\n  glph[g_y]   = vec4 (0x000000, 0x006666, 0x66663C, 0x0C18F0);\n  glph[g_z]   = vec4 (0x000000, 0x00FC8C, 0x1860C4, 0xFC0000);\n  glph[g_lpa] = vec4 (0x001C30, 0x3060C0, 0x603030, 0x1C0000);\n  glph[g_bar] = vec4 (0x001818, 0x181800, 0x181818, 0x180000);\n  glph[g_rpa] = vec4 (0x00E030, 0x30180C, 0x183030, 0xE00000);\n  glph[g_tid] = vec4 (0x0073DA, 0xCE0000, 0x000000, 0x000000);\n  glph[g_lar] = vec4 (0x000000, 0x10386C, 0xC6C6FE, 0x000000);\n  cSpace = vec2 (8., 13.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}