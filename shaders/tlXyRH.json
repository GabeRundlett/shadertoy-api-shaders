{
    "Shader": {
        "info": {
            "date": "1591392360",
            "description": "Gas gas gas",
            "flags": 0,
            "hasliked": 0,
            "id": "tlXyRH",
            "likes": 3,
            "name": "Cool velocimeter",
            "published": 3,
            "tags": [
                "procedural"
            ],
            "usePreview": 0,
            "username": "makaronsito",
            "viewed": 324
        },
        "renderpass": [
            {
                "code": "const float MAX_VEL = 20.;\nconst float MIN_ANGLE = -36.;\nconst float MAX_ANGLE = 120.;\nconst float GROSOR_AGUJA = .1; //porcentaje\nconst float LARGO_AGUJA = .5; //porcentaje\nconst float LARGO_MARCA = .12; //porcentaje\nconst float GROSOR_MARCA = 1.5; //en grados\nconst float ANG_ESP_MARCA = 12.; //en grados\nconst float GROSOR_CIRC = .02; //porcentaje\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float vel = abs(sin(iTime/20.)) * MAX_VEL;\n    \n\tvec3 col = vec3(-1);\n\tvec2 centerUV = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\tfloat velCoef = vel/MAX_VEL;\n\tfloat angle = mix(MIN_ANGLE, MAX_ANGLE, velCoef) + sin(iTime * velCoef * 90.) * velCoef * 3.;\n\tfloat uvDisp = length(centerUV);\n\t\n\t//crea un círculo rojo que delimita la zona en que la aguja gira\n\tif (uvDisp > GROSOR_AGUJA * 1.2 && uvDisp < GROSOR_CIRC + GROSOR_AGUJA * 1.2)\n\t\tcol = vec3(0.1,-1,-1);\n\t\t\n\t//solo renderizamos la parte de la línea que \"se mueve en la dirección adecuada\" creando la ilusión de una aguja\n\tvec2 dir = vec2(cos(radians(angle)), sin(radians(angle)));\n\tfloat dirCos = (centerUV.x*dir.x+centerUV.y*dir.y)/(length(centerUV)*length(dir));\n\tif (length(centerUV) < GROSOR_AGUJA || dirCos > 0.) {\n\t\t//ecuación distancia punto-recta\n\t\tfloat dist = abs(centerUV.y*dir.x - centerUV.x*dir.y) / length(dir);\n\t\tif (dist < GROSOR_AGUJA/2.){\n\t\t\tfloat centerDistCoef = clamp(1.-uvDisp/LARGO_AGUJA,0.,1.);\n\t\t\tfloat lineDistCoef = (GROSOR_AGUJA/2.)/dist-1.;\n\t\t\tcol = vec3(clamp(lineDistCoef * centerDistCoef, 0., 1.),-1.,-1.);\n\t\t}\n\t}\n\t\n\t//ángulo del UV, de 0 a 360\n\tfloat aUV = degrees(atan(centerUV.y/centerUV.x));\n    if (centerUV.x < 0.)\n        aUV += 180.;\n\t\n\t//si nos encontramos en la franja donde debe haber marcas\n\tif (uvDisp > LARGO_AGUJA - LARGO_MARCA && uvDisp < LARGO_AGUJA){\n\t\tif (uvDisp > LARGO_AGUJA-LARGO_MARCA/2. && uvDisp < LARGO_AGUJA + GROSOR_CIRC - LARGO_MARCA/2.)\n\t\t\tcol = vec3(0.1);//asignar color gris al círculo delimitador\n\t\tif (mod(aUV, ANG_ESP_MARCA) < GROSOR_MARCA && aUV < MAX_ANGLE + GROSOR_MARCA && aUV > MIN_ANGLE){ //marcas de velocidad\n\t\t\tif (aUV < 0.)//asignamos el color a cada marca según el ángulo de la línea que siga\n\t\t\t\tcol = vec3(0.3, 0, 1);\n\t\t\telse if (aUV < 90.)\n\t\t\t\tcol = vec3(0, 1, 0.3);\n\t\t\telse\n\t\t\t\tcol = vec3(1, 1, 0.);\n\t\t}\n\t}\n\t\t\n\tfragColor = vec4(col,0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}