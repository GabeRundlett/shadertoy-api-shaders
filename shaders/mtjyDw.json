{
    "Shader": {
        "info": {
            "date": "1691962447",
            "description": "Basically sample points on the function and connect them with line segments",
            "flags": 0,
            "hasliked": 0,
            "id": "mtjyDw",
            "likes": 6,
            "name": "1D Continuous Function Graphing",
            "published": 3,
            "tags": [
                "2d",
                "graph",
                "plot",
                "plotting",
                "graphs"
            ],
            "usePreview": 0,
            "username": "beans_please",
            "viewed": 149
        },
        "renderpass": [
            {
                "code": "/************************/\n/*                      */\n/*  YOUR FUNCTION HERE  */\n/*                      */\n/************************/\nfloat f(float x)\n{\n    return .6 * sin(4. * x + iTime * 3.) * exp(-x * .25);\n}\n\n\n\nconst float zoom = 2.8;  // Zoom-out\nfloat px2uv;             // Pixel to UV conversion factor (defined in main)\nfloat max_thickness;     // Line thickness (defined in main)\n\nfloat dist_f(vec2 p)\n{\n    // We have a line between every something pixels.\n    // The line vertices lie on f(x).\n    int n = int(.5 * iResolution.x);\n    \n    // Total horizontal length of the lines (screen length in UV)\n    float total_len = iResolution.x * px2uv;\n    \n    // Distance between the line vertices (in UV)\n    float step_size = total_len / float(n);\n    \n    // Index range of the lines which we want to check\n    int idx0 = int(floor((p.x - max(max_thickness, step_size)) / step_size));\n    int idx1 = int(floor((p.x + max(max_thickness, step_size)) / step_size));\n    \n    // Initial distance\n    float dist = 1e9;\n    \n    // Find the minimum distance from the lines we chose\n    for (int i = idx0; i <= idx1; i++)\n    {\n        // Point A of the line segment\n        float ax = float(i) * step_size;\n        float ay = f(ax);\n        \n        // Point B of the line segment\n        float bx = float(i + 1) * step_size;\n        float by = f(bx);\n        \n        // Distance\n        dist = min(dist, sd_segment(p, vec2(ax, ay), vec2(bx, by)));\n    }\n    \n    return dist;\n}\n\nvec3 render(vec2 frag_coord)\n{\n    // UV\n    vec2 uv = px2uv * (frag_coord - iResolution.xy * .5);\n    if (iMouse.z > .2)\n    {\n        uv += px2uv * (abs(iMouse.zw) - iMouse.xy);\n    }\n    \n    // Cartoon paper effect\n    uv += (texture(iChannel0, .4 * uv + vec2(13.4823 * SNAP(iTime, .125), 0.)).xy - .5) * .02;\n    \n    // Render grid\n    vec3 col = vec3(1., .9, 0.72);\n    vec3 col_grid = vec3(0.3, 0.1, 0.065);\n    #if 0\n    {\n        // Snap grid lines to pixels\n        // For this to work you need to disable the paper effect above\n        \n        #define SNAP_PX(X) SNAP(X, px2uv)\n        \n        float d = min(abs(uv.x - SNAP_PX(round(uv.x))), abs(uv.y - SNAP_PX(round(uv.y))));\n        if (d < .5 * px2uv) col = mix(col, col_grid, .5);\n        \n        vec2 t = uv * 4.;\n        d = min(abs(t.x - SNAP_PX(round(t.x))), abs(t.y - SNAP_PX(round(t.y))));\n        if (d < .5 * px2uv * 4.) col = mix(col, col_grid, .2);\n        \n        d = min(abs(uv.x), abs(uv.y));\n        if (d < 1. * px2uv) col = col_grid;\n    }\n    #else\n    {\n        // Don't snap to pixels\n        \n        float d = min(abs(uv.x - round(uv.x)), abs(uv.y - round(uv.y)));\n        if (d < .006) col = mix(col, col_grid, .5);\n        \n        vec2 t = uv * 4.;\n        d = min(abs(t.x - round(t.x)), abs(t.y - round(t.y)));\n        if (d < .006 * 4.) col = mix(col, col_grid, .2);\n        \n        d = min(abs(uv.x), abs(uv.y));\n        if (d < .012) col = col_grid;\n    }\n    #endif\n    \n    // Distance from f(x)\n    float d = dist_f(uv);\n    \n    // Render lines\n    float thick = max_thickness;\n    col = mix(col, vec3(.03, .04, 0.6), smoothstep(thick, thick - px2uv, d));\n    \n    return col;\n}\n\nvoid main_image(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Pixel to UV conversion factor\n    px2uv = 2. * zoom / min(iResolution.x, iResolution.y);\n    \n    // Line thickness\n    max_thickness = .03;\n    \n    // Super-sampling\n    vec3 col = vec3(0);\n    {\n        col += render(frag_coord + vec2(-.25, -.25));\n        col += render(frag_coord + vec2(-.25, +.25));\n        col += render(frag_coord + vec2(+.25, +.25));\n        col += render(frag_coord + vec2(+.25, -.25));\n    }\n    col /= 4.;\n    \n    // Output\n    col = pow(col, vec3(1. / 2.2));\n    frag_col = vec4(col, 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define main_image mainImage /* force snake_case */\n\n#define SNAP(X, STEP) ((floor(X / STEP) + .5) * STEP)\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sd_segment(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}