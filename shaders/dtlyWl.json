{
    "Shader": {
        "info": {
            "date": "1691371534",
            "description": "Inspired by Rene Magritte's painting of the same title.",
            "flags": 0,
            "hasliked": 0,
            "id": "dtlyWl",
            "likes": 12,
            "name": "The Kiss",
            "published": 3,
            "tags": [
                "clouds",
                "fbm",
                "sky",
                "painting",
                "stars",
                "bird",
                "svg",
                "reproduction",
                "magritte"
            ],
            "usePreview": 0,
            "username": "A_Toaster",
            "viewed": 236
        },
        "renderpass": [
            {
                "code": "#define WAVE_ITER_MARCH 12\n#define WAVE_ITER_NORM 40\n\n\n\nconst float drag_mult = 0.8;\n\n\nconst float fog_density = 0.001;\nconst float fog_falloff = 0.3;\nconst float atmo_density = 0.0005;\nconst float atmo_falloff = 0.5;\n\nconst vec3 moon_dir = normalize(vec3(0., 1., -0.4));\nconst vec3 moon_col =  vec3(0.20, 0.2, 0.2);\nconst vec3 sun_col =  vec3(4., 7., 12.);\n\nconst vec3 water_col = vec3(0.01, 0.12, 0.2);\n\nvec2 hash_pos( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn fract(sin(p)*43758.5453123);\n}\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0;\n    float amplitude = 0.1;\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn = m * n;\n\t\tamplitude *= 0.4;\n\t}\n\treturn total;\n}\n\n\n// Calculates wave value and its derivative, \n// for the wave direction, position in space, wave frequency and time\nvec2 wavedx(vec2 position, vec2 direction, float frequency, float timeshift) {\n      float x = dot(direction, position) * frequency + timeshift;\n      float wave = exp(sin(x) * 2. - 2.0);\n      float dx = wave * cos(x);\n      return vec2(wave, -dx);\n}\n\nfloat ocean(vec2 p, int iter) {\n    p += vec2(100.0, 100.0);\n    float dir = 0.;\n    float frequency = 0.1; // frequency of the wave, this will change every iteration\n    float timeMultiplier = 1.0; // time multiplier for the wave, this will change every iteration\n    float weight = 1.0;// weight in final sum for the wave, this will change every iteration\n    float value = 0.0; // will store final sum of values\n    for(int i=0; i < iter; i++) {\n        // wave direction vec\n        vec2 d = vec2(sin(dir), cos(dir));\n        // calculate wave data\n        vec2 res = wavedx(p, d, frequency, iTime * timeMultiplier);\n\n        // shift position around according to wave drag and derivative of the wave\n        p += d * res.y * weight * drag_mult;\n\n        // add the results to sums\n        value += res.x * weight;\n\n        // modify next octave parameters\n        weight *= 0.88;\n        frequency *= 1.14;\n        timeMultiplier *= 1.07;\n\n        // \"randomize\" wave direction\n        dir = fract(dir + 0.33)  * 1. - 0.5;\n    }\n    return value * 0.75;\n}\n\nfloat march_waves(vec3 ro, vec3 rd){ \n   float d = 0.; // distance\n   \n   float h;\n   for(int i = 0; i < 64; ++i) {\n       vec3 p = ro + rd * d;\n       h = p.y - ocean(p.xz, WAVE_ITER_MARCH);\n       \n       d += h;\n       if(h < 1e-5) break;\n   }\n   //d += h / rd.y;\n   return d;\n}\n\nvec3 calc_normal(vec2 p) { \n    float c = ocean(p, WAVE_ITER_NORM);\n    float x = ocean(p + vec2(0.03, 0.), WAVE_ITER_NORM);\n    float y = ocean(p + vec2(0., 0.03), WAVE_ITER_NORM);\n    \n    vec3 cx = vec3(0.03, c - x, 0.);\n    vec3 cy = vec3(0., c - y, 0.03);\n    \n    return -normalize(cross(cx, cy));\n}\n\nvec3 night_sky( in vec3  rgb,      // original color of the pixel\n          in vec3  rayDir )\n{\n    float yi = 1./max(abs(rayDir.y), 0.0021);\n    \n    vec2 cloud_uv = rayDir.xz * yi;\n    \n    float cloud = max(0., noise(cloud_uv * vec2(0.5, 0.75)) + 0.4) * (noise(cloud_uv * vec2(1.25, 2.5)) + 1.) * 0.1;\n    \n    // atmosphere amount\n    float amount = (fog_density/fog_falloff + atmo_density/atmo_falloff) * yi + cloud * 0.2;\n    return mix(moon_col, rgb, exp(-amount));\n}\n\nvec3 day_sky(in vec3 rayDir) {\n    float yi = 1./max(abs(rayDir.y), 0.001);\n    \n    vec2 cloud_uv = rayDir.xz * yi;\n    \n    float cloud = max(0., noise(cloud_uv * vec2(0.5, 0.75)) + 0.4) * (noise(cloud_uv * vec2(1.25, 2.5)) + 1.) * 0.1;\n    \n    // atmosphere amount\n    float amount = (fog_density/fog_falloff + atmo_density/atmo_falloff) * yi + cloud * 0.02;\n    return mix(sun_col, vec3(0.), exp(-amount));\n}\n\n\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float dist,     // camera to point distance\n               in vec3  rayOri,   // camera position\n               in vec3  rayDir )  // camera to point vector\n{\n    float fogAmount = (fog_density/fog_falloff) * exp(-rayOri.y*fog_falloff) * (1.0-exp( -dist*rayDir.y*fog_falloff ))/rayDir.y;\n    float atmosAmount = (atmo_density/atmo_falloff) * exp(-rayOri.y*atmo_falloff) * (1.0-exp( -dist*rayDir.y*atmo_falloff ))/rayDir.y;\n    float amount = fogAmount + atmosAmount;\n    return mix(moon_col, rgb, exp(-amount));\n}\n\nfloat dot2(vec2 p) {\n    return dot(p, p);\n}\n\nfloat sdStar(vec2 p) {\n    const float h = 0.5;\n    float k = 0.5*(h+1.0/h);\n    p = abs(p);\n    return ( p.x<1.0 && p.y<p.x*(k-h)+h ) ? \n             k-sqrt(dot2(p-vec2(1,k)))  :\n           sqrt(min(dot2(p-vec2(0,h)),\n                    dot2(p-vec2(1,0))));\n}\n\nvec3 star_layer(vec2 uv, float t) {\n    vec2 idx = floor(uv);\n    vec2 local_pos = fract(uv);\n    \n    vec2 star_pos = hash_pos(idx);\n    vec2 brightness_twinkle = hash_pos(idx + vec2(123., 456.));\n    float star_brightness = fract(brightness_twinkle.x);\n    \n    float twinkle_offset = brightness_twinkle.y;\n    \n    star_brightness *= 0.75 + (0.25 * sin(t + twinkle_offset) * sin((t + twinkle_offset) * 2.76));\n    \n    vec2 offset = star_pos - local_pos;\n    float d = sdStar(offset * 20.) * star_brightness;\n    float star = smoothstep(0., 0.2, -d);\n    \n    vec3 base_col = mix(vec3(1., 0.1, 0.), vec3(2., 1., 0.5), star_brightness);\n    \n    return vec3(base_col * star);\n}\n\n\nvec3 stars(vec2 uv, float t) {\n    return star_layer(uv * 10., t * 2.) \n        + 0.5 * star_layer(uv * 20. + vec2(24., 57.), t * 3.)\n        + 0.3 * star_layer(uv * 50. + vec2(74., 92.), t * 5.);\n\n}\n\nvec3 night_scene(vec2 uv, float max_y) {\n    vec3 col;\n    vec3 rd = normalize(vec3(uv.x, uv.y + max_y * 0.35, 2.));\n    vec3 ro = vec3(0., 5., 0.);\n    \n    // ray goes up, will never hit ocean.\n    if(rd.y > 0.){\n        col = stars(uv, iTime);\n        col = night_sky(col, rd);\n    } else {\n        float dist = march_waves(ro, rd);\n        vec3 hit_pt = ro + rd * dist;\n        float roughness = smoothstep(0., 20., ocean(hit_pt.xz, 40));\n        vec3 norm = calc_normal(hit_pt.xz);\n        float fresnel = pow(max(dot(norm, rd), roughness), 0.2);\n        \n        vec3 reflection_dir = reflect(rd, norm);\n        if(reflection_dir.y < 0.) {\n            fresnel *= 0.25;\n            reflection_dir.y *= -1.;\n        }\n        vec3 reflection = night_sky(vec3(0.), reflection_dir);\n        reflection += moon_col * pow(max(dot(reflection_dir, moon_dir), 0.), 3.);\n        \n        \n        float ndotl = clamp(dot(norm, moon_dir), 0., 1.);\n        vec3 scatter = ndotl * moon_col * mix(water_col, vec3(1.), roughness);\n        \n        col = mix(reflection, scatter, fresnel);\n        \n        col = applyFog(col, clamp(-1. / rd.y, 0.001, 1000.), ro, rd);\n    }    \n    return col;\n}\n\n\nconst float cloudscale = 8.;\nconst float speed = 0.03;\nconst float clouddark = 0.6;\nconst float cloudlight = 0.4;\nconst float cloudcover = -0.4;\nconst float cloudalpha = 5.0;\nconst float skytint = 0.1;\n\nvec3 clouds(vec2 uv, float time, vec3 skycolor) {\n    vec2 uv2 = uv;\n    \n    float q = fbm(uv * cloudscale * 0.5);\n    \n    //ridged noise shape\n\tfloat r = 0.0;\n\tuv2 *= cloudscale;\n    uv2 -= q - time;\n    float weight = 0.8;\n    for (int i=0; i<8; i++){\n\t\tr += abs(weight*noise( uv2 ));\n        uv2 = m*uv2 + time;\n\t\tweight *= 0.7;\n    }\n    \n    //noise shape\n\tfloat f = 0.0;\n    uv2 = uv;\n\tuv2 *= cloudscale;\n    uv2 -= q - time;\n    weight = 0.7;\n    for (int i=0; i<8; i++){\n\t\tf += weight*noise( uv2 );\n        uv2 = m*uv2 + time;\n\t\tweight *= 0.6;\n    }\n    \n    f *= r + f;\n    \n    //noise colour\n    float c = 0.0;\n    uv2 = uv;\n\tuv2 *= cloudscale*2.0;\n    uv2 -= q - time * 2.;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc += weight*noise( uv2 );\n        uv2 = m*uv2 + time * 2.;\n\t\tweight *= 0.6;\n    }\n    \n    //noise ridge colour\n    float c1 = 0.0;\n    uv2 = uv;\n\tuv2 *= cloudscale*3.0;\n    uv2 -= q - time * 3.;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc1 += abs(weight*noise( uv2 ));\n        uv2 = m*uv2 + time * 3.;\n\t\tweight *= 0.6;\n    }\n\t\n    c += c1;\n    \n    vec3 cloudcolor = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*c), 0.0, 1.0);\n   \n    f = cloudcover + cloudalpha*f*r;\n    \n    return mix(skycolor, clamp(skytint * skycolor + cloudcolor, 0.0, 1.0), clamp(f + c, 0.0, 1.0));\n}\n\nvec3 day_scene(vec2 uv, float max_y, float t) {\n    vec3 rd = normalize(vec3(uv.x, uv.y + max_y * 0.35, 2.));\n    vec3 sky = day_sky(rd);\n    \n    // scale the clouds so they move slower closer to the horizon\n    vec2 cloud_uv = uv * vec2(0.3, 1.);\n    cloud_uv.x *= (cloud_uv.y - 1.);\n    return clouds(cloud_uv, t * 0.01 + 50., day_sky(rd));\n}\n\n// non-constant zero\n#define ZERO min(0,iFrame)\n\n// SVG Shader generated with https://gist.github.com/Ninja-Koala/74fa7652fb4de248949ce1e27b989c14\n\nconst float border = 0.002;\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n\t// normal form: x^2 + px + q = 0\n\tfloat p = coeffs[1] / 2.;\n\tfloat q = coeffs[0];\n\n\tfloat D = p * p - q;\n\n\tif (D < 0.){\n\t\treturn 0;\n\t}\n\telse{\n\t\troots[0] = -sqrt(D) - p;\n\t\troots[1] = sqrt(D) - p;\n\n\t\treturn 2;\n\t}\n}\n\n//From Trisomie21\n//But instead of his cancellation fix i'm using a newton iteration\nint solve_cubic(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\tr[0] = offset + u * (m + m);\n\tr[1] = offset - u * (n + m);\n\tr[2] = offset + u * (n - m);\n\n\tvec3 f = ((r + a) * r + b) * r + c;\n\tvec3 f1 = (3. * r + 2. * a) * r + b;\n\n\tr -= f / f1;\n\t\n\treturn 3;\n}\n\nfloat quadratic_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2){\n\t//horner's method\n\tvec2 a_1=a1+t*a2;\n\n\tvec2 uv_to_p=a0+t*a_1;\n\tvec2 tang=a_1+t*a2;\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat quadratic_bezier_dis_approx_sq(vec2 uv, vec2 p0, vec2 p1, vec2 p2){\n\tvec2 a2 = p0 - 2. * p1 + p2;\n\tvec2 a1 = -2. * p0 + 2. * p1;\n\tvec2 a0 = p0 - uv;\n\n\tfloat d0 = 1e38;\n\n\tfloat t;\n\tvec3 params=vec3(0,.5,1);\n\t\n\tif(all(lessThan(uv,max(max(p0,p1),p2)+border)) && all(greaterThan(uv,min(min(p0,p1),p2)-border))){\n\t\tfor(int i=ZERO;i<3;i++){\n\t\t\tt=params[i];\n\t\t\tfor(int j=ZERO;j<3;j++){\n\t\t\t\tt=quadratic_bezier_normal_iteration(t,a0,a1,a2);\n\t\t\t}\n\t\t\tt=clamp(t,0.,1.);\n\t\t\tvec2 uv_to_p=(a2*t+a1)*t+a0;\n\t\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\t\t}\n\t}\n\n\treturn d0;\n}\n\nfloat cubic_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2, vec2 a3){\n\t//horner's method\n\tvec2 a_2=a2+t*a3;\n\tvec2 a_1=a1+t*a_2;\n\tvec2 b_2=a_2+t*a3;\n\n\tvec2 uv_to_p=a0+t*a_1;\n\tvec2 tang=a_1+t*b_2;\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat cubic_bezier_dis_approx_sq(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a2 = (3. * p0 - 6. * p1 + 3. * p2);\n\tvec2 a1 = (-3. * p0 + 3. * p1);\n\tvec2 a0 = p0 - uv;\n\n\tfloat d0 = 1e38;\n\n\tfloat t;\n\tvec3 params=vec3(0,.5,1);\n\n\tif(all(lessThan(uv,max(max(p0,p1),max(p2,p3))+border)) && all(greaterThan(uv,min(min(p0,p1),min(p2,p3))-border))){\n\t\tfor(int i=ZERO;i<3;i++){\n\t\t\tt=params[i];\n\t\t\tfor(int j=ZERO;j<3;j++){\n\t\t\t\tt=cubic_bezier_normal_iteration(t,a0,a1,a2,a3);\n\t\t\t}\n\t\t\tt=clamp(t,0.,1.);\n\t\t\tvec2 uv_to_p=((a3*t+a2)*t+a1)*t+a0;\n\t\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\t\t}\n\t}\n\n\treturn d0;\n}\n\n//segment_dis_sq by iq\nfloat length2( vec2 v ) { return dot(v,v); }\n\nfloat segment_dis_sq( vec2 p, vec2 a, vec2 b ){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length2( pa - ba*h );\n}\n\nint segment_int_test(vec2 uv, vec2 p0, vec2 p1){\n\tp0-=uv;\n\tp1-=uv;\n\n\tint ret;\n\t\n\tif(p0.y*p1.y<0.){\n\t\tvec2 nor=p0-p1;\n\t\tnor=vec2(nor.y,-nor.x);\n\t\t\n\t\tfloat sgn;\n\t\t\n\t\tif(p0.y>p1.y){\n\t\t\tsgn=1.;\n\t\t}\n\t\telse{\n\t\t\tsgn=-1.;\n\t\t}\n\n\t\tif(dot(nor,p0)*sgn<0.){\n\t\t\tret=0;\n\t\t}\n\t\telse{\n\t\t\tret=1;\n\t\t}\n\t}\n\telse{\n\t\tret=0;\n\t}\n\n\treturn ret;\n}\n\nint quadratic_bezier_int_test(vec2 uv, vec2 p0, vec2 p1, vec2 p2){\n\n\tfloat qu = (p0.y - 2. * p1.y + p2.y);\n\tfloat li = (-2. * p0.y + 2. * p1.y);\n\tfloat co = p0.y - uv.y;\n\n\tvec2 roots = vec2(1e38);\n\tint n_roots = solve_quadric(vec2(co/qu,li/qu),roots);\n\n\tint n_ints = 0;\n\n\tfor(int i=ZERO;i<n_roots;i++){\n\t\tif(roots[i] >= 0. && roots[i] <= 1.){\n\t\t\tfloat x_pos = p0.x - 2. * p1.x + p2.x;\n\t\t\tx_pos = x_pos * roots[i] + -2. * p0.x + 2. * p1.x;\n\t\t\tx_pos = x_pos * roots[i] + p0.x;\n\n\t\t\tif(x_pos > uv.x){\n\t\t\t\tn_ints++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn n_ints;\n}\n\nint cubic_bezier_int_test(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\n\tfloat cu = (-p0.y + 3. * p1.y - 3. * p2.y + p3.y);\n\tfloat qu = (3. * p0.y - 6. * p1.y + 3. * p2.y);\n\tfloat li = (-3. * p0.y + 3. * p1.y);\n\tfloat co = p0.y - uv.y;\n\n\tvec3 roots = vec3(1e38);\n\tint n_roots;\n\t\n\tint n_ints=0;\n\n\tif(uv.x<min(min(p0.x,p1.x),min(p2.x,p3.x))){\n\t\tif(uv.y>=min(p0.y,p3.y) && uv.y<=max(p0.y,p3.y)){\n\t\t\tn_ints=1;\n\t\t}\n\t}\n    \telse{\n\t\tif(abs(cu) < .0001){\n\t\t\tn_roots = solve_quadric(vec2(co/qu,li/qu),roots.xy);\n\t\t}\n\t\telse{\n\t\t\tn_roots = solve_cubic(vec3(co/cu,li/cu,qu/cu),roots);\n\t\t}\n\n\t\tfor(int i=ZERO;i<n_roots;i++){\n\t\t\tif(roots[i] >= 0. && roots[i] <= 1.){\n\t\t\t\tfloat x_pos = -p0.x + 3. * p1.x - 3. * p2.x + p3.x;\n\t\t\t\tx_pos = x_pos * roots[i] + 3. * p0.x - 6. * p1.x + 3. * p2.x;\n\t\t\t\tx_pos = x_pos * roots[i] + -3. * p0.x + 3. * p1.x;\n\t\t\t\tx_pos = x_pos * roots[i] + p0.x;\n\n\t\t\t\tif(x_pos > uv.x){\n\t\t\t\t\tn_ints++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn n_ints;\n}\n\nfloat path0_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[162] p=vec2[](vec2(-0.35495,0.0459062),\n\t                   vec2(-0.35495,0.0459062),\n\t                   vec2(-0.347492,0.0525652),\n\t                   vec2(-0.326983,0.0570933),\n\t                   vec2(-0.306473,0.0616215),\n\t                   vec2(-0.269981,0.0522988),\n\t                   vec2(-0.258261,0.0525652),\n\t                   vec2(-0.246541,0.0528316),\n\t                   vec2(-0.175955,0.0570933),\n\t                   vec2(-0.129342,0.0256627),\n\t                   vec2(-0.0827289,-0.005768),\n\t                   vec2(-0.0787335,-0.0148243),\n\t                   vec2(-0.0787335,-0.0148243),\n\t                   vec2(-0.0787335,-0.0148243),\n\t                   vec2(-0.0819298,-0.0065671),\n\t                   vec2(-0.043041,0.0672151),\n\t                   vec2(-0.0041522,0.140997),\n\t                   vec2(0.0390683,0.164218),\n\t                   vec2(0.0742863,0.17408),\n\t                   vec2(0.109504,0.183941),\n\t                   vec2(0.14923,0.193238),\n\t                   vec2(0.173179,0.196619),\n\t                   vec2(0.197127,0.2),\n\t                   vec2(0.202762,0.196619),\n\t                   vec2(0.209242,0.196337),\n\t                   vec2(0.215722,0.196056),\n\t                   vec2(0.227837,0.199155),\n\t                   vec2(0.227837,0.199155),\n\t                   vec2(0.227837,0.199155),\n\t                   vec2(0.230654,0.191829),\n\t                   vec2(0.219948,0.186758),\n\t                   vec2(0.209242,0.181687),\n\t                   vec2(0.219103,0.179996),\n\t                   vec2(0.203325,0.172953),\n\t                   vec2(0.187548,0.165909),\n\t                   vec2(0.18952,0.161683),\n\t                   vec2(0.187266,0.155203),\n\t                   vec2(0.185012,0.148723),\n\t                   vec2(0.181619,0.149106),\n\t                   vec2(0.179323,0.141332),\n\t                   vec2(0.177027,0.133558),\n\t                   vec2(0.173978,0.129777),\n\t                   vec2(0.170033,0.119125),\n\t                   vec2(0.166088,0.108473),\n\t                   vec2(0.157956,0.100811),\n\t                   vec2(0.155845,0.0916192),\n\t                   vec2(0.153734,0.0824279),\n\t                   vec2(0.145564,0.0672452),\n\t                   vec2(0.145564,0.0672452),\n\t                   vec2(0.145564,0.0672452),\n\t                   vec2(0.149278,0.064726),\n\t                   vec2(0.148602,0.0489502),\n\t                   vec2(0.147926,0.0331745),\n\t                   vec2(0.139136,0.023709),\n\t                   vec2(0.139587,0.0203285),\n\t                   vec2(0.140038,0.016948),\n\t                   vec2(0.142742,0.00770787),\n\t                   vec2(0.140939,-0.000180023),\n\t                   vec2(0.139136,-0.00806791),\n\t                   vec2(0.13801,-0.0073918),\n\t                   vec2(0.138686,-0.0112231),\n\t                   vec2(0.139362,-0.0150543),\n\t                   vec2(0.139124,-0.0220527),\n\t                   vec2(0.139124,-0.0220527),\n\t                   vec2(0.139124,-0.0220527),\n\t                   vec2(0.141212,-0.0268884),\n\t                   vec2(0.140553,-0.0368895),\n\t                   vec2(0.139894,-0.0468906),\n\t                   vec2(0.138685,-0.0511768),\n\t                   vec2(0.138685,-0.0511768),\n\t                   vec2(0.138685,-0.0511768),\n\t                   vec2(0.18054,-0.062794),\n\t                   vec2(0.191242,-0.0662382),\n\t                   vec2(0.201944,-0.0696824),\n\t                   vec2(0.219518,-0.0751941),\n\t                   vec2(0.279288,-0.0722574),\n\t                   vec2(0.339058,-0.0693207),\n\t                   vec2(0.352014,-0.0789945),\n\t                   vec2(0.352014,-0.0789945),\n\t                   vec2(0.352014,-0.0789945),\n\t                   vec2(0.35495,-0.0834859),\n\t                   vec2(0.348732,-0.0886682),\n\t                   vec2(0.342513,-0.0938506),\n\t                   vec2(0.343031,-0.0917777),\n\t                   vec2(0.343031,-0.0917777),\n\t                   vec2(0.343031,-0.0917777),\n\t                   vec2(0.342858,-0.0964418),\n\t                   vec2(0.338021,-0.100588),\n\t                   vec2(0.333185,-0.104734),\n\t                   vec2(0.310181,-0.10979),\n\t                   vec2(0.308752,-0.117577),\n\t                   vec2(0.307324,-0.125364),\n\t                   vec2(0.313396,-0.127864),\n\t                   vec2(0.31804,-0.134722),\n\t                   vec2(0.322683,-0.14158),\n\t                   vec2(0.321897,-0.14158),\n\t                   vec2(0.320826,-0.142724),\n\t                   vec2(0.319754,-0.143867),\n\t                   vec2(0.318111,-0.143081),\n\t                   vec2(0.318111,-0.143081),\n\t                   vec2(0.318111,-0.143081),\n\t                   vec2(0.319468,-0.14601),\n\t                   vec2(0.317325,-0.147153),\n\t                   vec2(0.315182,-0.148296),\n\t                   vec2(0.282029,-0.138869),\n\t                   vec2(0.263837,-0.131618),\n\t                   vec2(0.245644,-0.124366),\n\t                   vec2(0.180289,-0.0992132),\n\t                   vec2(0.117571,-0.13448),\n\t                   vec2(0.0548538,-0.169747),\n\t                   vec2(0.023946,-0.192812),\n\t                   vec2(-0.0344535,-0.196406),\n\t                   vec2(-0.092853,-0.2),\n\t                   vec2(-0.121068,-0.182796),\n\t                   vec2(-0.128983,-0.178479),\n\t                   vec2(-0.136897,-0.174162),\n\t                   vec2(-0.135406,-0.174648),\n\t                   vec2(-0.144281,-0.172183),\n\t                   vec2(-0.153155,-0.169718),\n\t                   vec2(-0.167551,-0.164689),\n\t                   vec2(-0.17327,-0.16183),\n\t                   vec2(-0.178989,-0.15897),\n\t                   vec2(-0.179877,-0.159365),\n\t                   vec2(-0.188455,-0.161238),\n\t                   vec2(-0.197033,-0.163112),\n\t                   vec2(-0.200571,-0.16326),\n\t                   vec2(-0.200571,-0.16326),\n\t                   vec2(-0.200571,-0.16326),\n\t                   vec2(-0.201464,-0.161348),\n\t                   vec2(-0.199685,-0.158963),\n\t                   vec2(-0.197906,-0.156578),\n\t                   vec2(-0.198553,-0.157831),\n\t                   vec2(-0.197624,-0.15484),\n\t                   vec2(-0.196694,-0.151848),\n\t                   vec2(-0.193904,-0.150433),\n\t                   vec2(-0.193217,-0.149908),\n\t                   vec2(-0.19253,-0.149382),\n\t                   vec2(-0.191075,-0.148978),\n\t                   vec2(-0.190428,-0.14154),\n\t                   vec2(-0.189781,-0.134102),\n\t                   vec2(-0.189252,-0.128345),\n\t                   vec2(-0.180513,-0.119906),\n\t                   vec2(-0.171773,-0.111468),\n\t                   vec2(-0.170266,-0.110564),\n\t                   vec2(-0.161627,-0.108354),\n\t                   vec2(-0.152988,-0.106144),\n\t                   vec2(-0.152428,-0.106238),\n\t                   vec2(-0.152428,-0.106238),\n\t                   vec2(-0.152428,-0.106238),\n\t                   vec2(-0.166896,-0.0980232),\n\t                   vec2(-0.175565,-0.0851204),\n\t                   vec2(-0.184234,-0.0722176),\n\t                   vec2(-0.212573,-0.0272814),\n\t                   vec2(-0.237097,0.0026865),\n\t                   vec2(-0.241825,0.00846306),\n\t                   vec2(-0.265885,0.048008),\n\t                   vec2(-0.310458,0.0426059),\n\t                   vec2(-0.325515,0.0407811),\n\t                   vec2(-0.349031,0.0434361),\n\t                   vec2(-0.351641,0.0440886),\n\t                   vec2(-0.354251,0.0447412),\n\t                   vec2(-0.35495,0.0459062));\n\n\tivec4[54] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(9,10,11,12),\n\t                        ivec4(12,13,14,15),\n\t                        ivec4(15,16,17,18),\n\t                        ivec4(18,19,20,21),\n\t                        ivec4(21,22,23,24),\n\t                        ivec4(24,25,26,27),\n\t                        ivec4(27,28,29,30),\n\t                        ivec4(30,31,32,33),\n\t                        ivec4(33,34,35,36),\n\t                        ivec4(36,37,38,39),\n\t                        ivec4(39,40,41,42),\n\t                        ivec4(42,43,44,45),\n\t                        ivec4(45,46,47,48),\n\t                        ivec4(48,49,50,51),\n\t                        ivec4(51,52,53,54),\n\t                        ivec4(54,55,56,57),\n\t                        ivec4(57,58,59,60),\n\t                        ivec4(60,61,62,63),\n\t                        ivec4(63,64,65,66),\n\t                        ivec4(66,67,68,69),\n\t                        ivec4(69,70,71,72),\n\t                        ivec4(72,73,74,75),\n\t                        ivec4(75,76,77,78),\n\t                        ivec4(78,79,80,81),\n\t                        ivec4(81,82,83,84),\n\t                        ivec4(84,85,86,87),\n\t                        ivec4(87,88,89,90),\n\t                        ivec4(90,91,92,93),\n\t                        ivec4(93,94,95,96),\n\t                        ivec4(96,97,98,99),\n\t                        ivec4(99,100,101,102),\n\t                        ivec4(102,103,104,105),\n\t                        ivec4(105,106,107,108),\n\t                        ivec4(108,109,110,111),\n\t                        ivec4(111,112,113,114),\n\t                        ivec4(114,115,116,117),\n\t                        ivec4(117,118,119,120),\n\t                        ivec4(120,121,122,123),\n\t                        ivec4(123,124,125,126),\n\t                        ivec4(126,127,128,129),\n\t                        ivec4(129,130,131,132),\n\t                        ivec4(132,133,134,135),\n\t                        ivec4(135,136,137,138),\n\t                        ivec4(138,139,140,141),\n\t                        ivec4(141,142,143,144),\n\t                        ivec4(144,145,146,147),\n\t                        ivec4(147,148,149,150),\n\t                        ivec4(150,151,152,153),\n\t                        ivec4(153,154,155,156),\n\t                        ivec4(156,157,158,159),\n\t                        ivec4(159,160,161,0));\n\n\tif(all(lessThan(uv,vec2(0.35495,0.2)+border)) && all(greaterThan(uv,vec2(-0.35495,-0.2)-border))){\n\t\tfor(int i=ZERO;i<54;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\n\nfloat mask(vec2 mask_uv) {\n    // calculate squared distance to curve\n\tfloat dis_sq;\n    if(all(lessThan(mask_uv,vec2(0.35495,0.2)+border)) && all(greaterThan(mask_uv,vec2(-0.35495,-0.2)-border))){\n\t\tdis_sq=min(dis_sq,path0_dis_sq(mask_uv));\n\t}\n\n    // Calculate signed distance\n\tfloat dis=sign(dis_sq)*sqrt(abs(dis_sq));\n    \n    return smoothstep(-border, 0., dis);\n}\n\n\n\nvec3 encodeSRGB(vec3 linearRGB)\n{\n    vec3 a = 12.92 * linearRGB;\n    vec3 b = 1.055 * pow(linearRGB, vec3(1.0 / 2.4)) - 0.055;\n    vec3 c = step(vec3(0.0031308), linearRGB);\n    return mix(a, b, c);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // calculate centered UV coordinates\n    vec2 uv=fragCoord.xy/iResolution.xy;\n    uv-=.5;\n    float max_y = iResolution.y/iResolution.x;\n    uv.y*=max_y;\n\n\n\n\n    vec2 mask_uv = uv - vec2(0., 0.05);\n\n    float mask = mask(mask_uv);\n    \n    vec3 out_col = vec3(0.);\n    \n    if(mask > 0.) {\n        out_col += night_scene(uv, max_y) * mask;\n    }\n    if(mask < 1.) {\n        out_col += day_scene(uv, max_y, iTime) * (1. - mask);\n    }\n    \n    fragColor = vec4(encodeSRGB(out_col), 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}