{
    "Shader": {
        "info": {
            "date": "1452432230",
            "description": "Animated flag of the Kuomintang",
            "flags": 32,
            "hasliked": 0,
            "id": "ld3GDX",
            "likes": 2,
            "name": "KMT",
            "published": 3,
            "tags": [
                "vector"
            ],
            "usePreview": 0,
            "username": "seanstone",
            "viewed": 774
        },
        "renderpass": [
            {
                "code": "// Created by Reinder Nijhoff 2016\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/ls3GWS\n//\n// car model is made by Eiffie\n// shader 'Shiny Toy': https://www.shadertoy.com/view/ldsGWB\n//\n// demonstrating post process FXAA applied to my shader 'Tokyo': \n// https://www.shadertoy.com/view/Xtf3zn\n//\n// FXAA code from: http://www.geeks3d.com/20110405/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce/3/\n//\n\n#define FXAA_SPAN_MAX 8.0\n#define FXAA_REDUCE_MUL   (1.0/FXAA_SPAN_MAX)\n#define FXAA_REDUCE_MIN   (1.0/128.0)\n#define FXAA_SUBPIX_SHIFT (1.0/4.0)\n\nvec3 FxaaPixelShader( vec4 uv, sampler2D tex, vec2 rcpFrame) {\n    \n    vec3 rgbNW = texture(tex, uv.zw, 0.0).xyz;\n    vec3 rgbNE = texture(tex, uv.zw + vec2(1,0)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSW = texture(tex, uv.zw + vec2(0,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSE = texture(tex, uv.zw + vec2(1,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbM  = texture(tex, uv.xy, 0.0).xyz;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max(\n        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n        FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n    \n    dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n          dir * rcpDirMin)) * rcpFrame.xy;\n\n    vec3 rgbA = (1.0/2.0) * (\n        texture(tex, uv.xy + dir * (1.0/3.0 - 0.5), 0.0).xyz +\n        texture(tex, uv.xy + dir * (2.0/3.0 - 0.5), 0.0).xyz);\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n        texture(tex, uv.xy + dir * (0.0/3.0 - 0.5), 0.0).xyz +\n        texture(tex, uv.xy + dir * (3.0/3.0 - 0.5), 0.0).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n    \n    return rgbB; \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rcpFrame = 1./iResolution.xy;\n  \tvec2 uv2 = fragCoord.xy / iResolution.xy;\n        \n    float splitCoord = (iMouse.x == 0.0) ? iResolution.x/2. + iResolution.x*cos(iTime*.5) : iMouse.x;\n    \n    vec3 col;\n    \n\tvec4 uv = vec4( uv2, uv2 - (rcpFrame * (0.5 + FXAA_SUBPIX_SHIFT)));\n    col = FxaaPixelShader( uv, iChannel0, 1./iResolution.xy );\n    \n    fragColor = vec4( col, 1. );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            },
            {
                "code": "float norm(vec2 v)\n{\n    return sqrt(v.x*v.x + v.y*v.y);\n}\n\nfloat sign (vec2 p1, vec2 p2, vec2 p3)\n{\n    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\n\nvec2 rotate(vec2 v, float tht)\n{\n    return vec2(cos(tht)*v.x - sin(tht)*v.y, sin(tht)*v.x + cos(tht)*v.y);\n}\n\n\n\nbool inTri(vec2 pt, float tht)\n{\n    float AMP = 20.;\n    float SPEED = 2.;\n    vec2 v1 = rotate(vec2(12., 55.), tht);\n    vec2 v2 = rotate(vec2(-12., 55.), tht);\n    vec2 v3 = rotate(vec2(0., 102. + AMP*sin(SPEED*iTime)), tht);\n    \n    bool b1, b2, b3;\n\n    b1 = sign(pt, v1, v2) < 0.0;\n    b2 = sign(pt, v2, v3) < 0.0;\n    b3 = sign(pt, v3, v1) < 0.0;\n\n    return ((b1 == b2) && (b2 == b3));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float PI = 3.141592;\n    float TRI_MIN = 60.;\n    float SPEED = -0.8;\n\tvec2 uv = fragCoord.xy - iResolution.xy/2.0;\n    if(norm(uv) < 50.0) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    else if(inTri(uv, 0.*2.*PI/12. + SPEED*iTime) && (norm(uv) > TRI_MIN)) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    else if(inTri(uv, 1.*2.*PI/12. + SPEED*iTime) && (norm(uv) > TRI_MIN)) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    else if(inTri(uv, 2.*2.*PI/12. + SPEED*iTime) && (norm(uv) > TRI_MIN)) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    else if(inTri(uv, 3.*2.*PI/12. + SPEED*iTime) && (norm(uv) > TRI_MIN)) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    else if(inTri(uv, 4.*2.*PI/12. + SPEED*iTime) && (norm(uv) > TRI_MIN)) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    else if(inTri(uv, 5.*2.*PI/12. + SPEED*iTime) && (norm(uv) > TRI_MIN)) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    else if(inTri(uv, 6.*2.*PI/12. + SPEED*iTime) && (norm(uv) > TRI_MIN)) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    else if(inTri(uv, 7.*2.*PI/12. + SPEED*iTime) && (norm(uv) > TRI_MIN)) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    else if(inTri(uv, 8.*2.*PI/12. + SPEED*iTime) && (norm(uv) > TRI_MIN)) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    else if(inTri(uv, 9.*2.*PI/12. + SPEED*iTime) && (norm(uv) > TRI_MIN)) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    else if(inTri(uv, 10.*2.*PI/12. + SPEED*iTime) && (norm(uv) > TRI_MIN)) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    else if(inTri(uv, 11.*2.*PI/12. + SPEED*iTime) && (norm(uv) > TRI_MIN)) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n\telse fragColor = vec4(13./255., 35./255., 146./255., 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}