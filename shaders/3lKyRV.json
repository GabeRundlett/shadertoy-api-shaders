{
    "Shader": {
        "info": {
            "date": "1611342932",
            "description": "I am having WAY too much fun.",
            "flags": 0,
            "hasliked": 0,
            "id": "3lKyRV",
            "likes": 6,
            "name": "Interlocking Hexgonal Pattern",
            "published": 3,
            "tags": [
                "demo",
                "pattern",
                "tiling",
                "hexagonal",
                "interlocking"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 180
        },
        "renderpass": [
            {
                "code": "struct Surface {\n    float dist;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float gloss;\n};\n\nfloat sdHexLink(in vec3 p, in float radius, in float thickness) {\n    p = abs(p);\n    return max(abs(max(dot(p.xz, vec2(0.5, 0.86602540378)), p.x) - radius), p.y) - thickness;\n}\n\nSurface mapScene(in vec3 p) {\n    p.xy = vec2(atan(p.y, p.x) * 10.0, length(p.xy));\n    p.y -= 10.0;\n\n    float tileSize = 8.0;\n    float thickness = 0.2;\n\n    vec2 repTile = vec2(1.0, 1.73) * tileSize;\n    vec2 hRepTile = 0.5 * repTile;\n\n    vec2 a = mod(p.xz, repTile) - hRepTile;\n    vec2 b = mod(p.xz - hRepTile, repTile) - hRepTile;\n    p.xz = dot(a, a) < dot(b, b) ? a : b;\n\n    float linkSize = 0.35 * tileSize;\n    float basePattern = sdHexLink(p, linkSize, thickness);\n\n    float repAng = 6.28 / 6.0;\n    float hRepAng = 0.5 * repAng;\n    p.xz = sin(mod(atan(p.z, p.x) - hRepAng, repAng) - hRepAng + vec2(1.57, 0.0)) * length(p.xz);\n    float links = sdHexLink(p.xzy - vec3(0.575 * tileSize, 0.0, 0.0), linkSize, thickness);\n\n    return Surface(min(basePattern, links), vec3(0.2, 0.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(1.0), 16.0);\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy).dist - mapScene(p - e.xyy).dist,\n                          mapScene(p + e.yxy).dist - mapScene(p - e.yxy).dist,\n                          mapScene(p + e.yyx).dist - mapScene(p - e.yyx).dist));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, -iTime * 20.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float c = cos(iTime), s = sin(iTime);\n    rd.xy *= mat2(c, -s, s, c);\n\n    vec3 l = vec3(-0.58, 0.58, 0.58);\n\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        Surface scene = mapScene(p);\n        if (scene.dist < 0.001) {\n            vec3 n = getNormal(p);\n            fragColor.rgb += scene.ambient;\n\n            float lambertian = max(0.0, dot(n, l));\n            fragColor.rgb += scene.diffuse * lambertian;\n\n            if (lambertian > 0.0) {\n                vec3 r = reflect(l, n);\n                float specAngle = max(0.0, dot(r, rd));\n                fragColor.rgb += scene.specular * max(0.0, pow(specAngle, scene.gloss));\n            }\n\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += scene.dist;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}