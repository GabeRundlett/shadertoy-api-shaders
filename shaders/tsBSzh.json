{
    "Shader": {
        "info": {
            "date": "1552865113",
            "description": "https://www.shadertoy.com/view/MlByWh\nlets you move in distorted space, but\n- time is not distorted, and your movement is unaffected.\nthe green distanceField is from\nhttps://www.shadertoy.com/view/Ws2Szz\nshader has ni EnvLight,  improvised lighting models",
            "flags": 49,
            "hasliked": 0,
            "id": "tsBSzh",
            "likes": 2,
            "name": "Riftborn Blackole",
            "published": 3,
            "tags": [
                "logeps",
                "riftborn",
                "blackholecanvas"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 400
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 o, in vec2 u){\n o=texture(iChannel0,u/1./iResolution.xy, -100.0 );\n  //o+=mainImage2(o,u);\n}\n\n//its all in buffA\n\n//https://www.shadertoy.com/view/tsBSzh\n\n\n/*\nhttps://www.shadertoy.com/view/MlByWh\nlets you move in distorted space, but\n- time is not distorted, and your movement is unaffected.\nthe green distanceField is from\nhttps://www.shadertoy.com/view/Ws2Szz\nshader has ni EnvLight,  improvised lighting models\n\nis based on  [blackhole canvaas]\nbut should be based on\nhttps://www.shadertoy.com/view/llcfRj\n*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//mosue and arrow-keys to move\n//it uses a quaternion camera\n//there is a blackhole in the set, that does not distort time\n//it uses only globalIllumination, but near-infinite reflections\n\n//...deal with it\n\n//below code is a messy union of:\n//  https://www.shadertoy.com/view/MlByWh\n//  https://www.shadertoy.com/view/Ws2Szz\n\n\n\n\n\n//3d deformation black hole\n//self  : https://www.shadertoy.com/view/ltjyzR\n//parent: https://www.shadertoy.com/view/llc3R8\n\n//reflectiveness of the green shape\n//sorry, this shaders ambient light is next to nonesistent.\n#define Reflectiveness .61\n\n\n#define GreenScale 10.\n\n#define repeatScale 16.\n\n\n//camera acceleration factor\n#define Thusting 1.5\n\n\nvoid displace(inout vec3 p){p=-p;\n    p.xyz-=1.*vec3(8010,8010,9010)/GreenScale;}\n//move the field so that the initial camera has a better startting position\n//this is a lot less confusing with displace()\n\n\n#define BlackHoleMass 0.61\n\n#define doBlackHole\n\n\n//Mass distorts space\n//, but time (and all camera movement) remains uniform\n//this begs the question\n// how a blakck hole distrts occlusion in a SIMPLE model\n\n//raymarch iterations, dynamiceps has fast convergense, dont worry about high rvalues!\n#define iterRm 1000.\n//far clipping sphere\n//this shader has a \"strange bug\" of turning blue over time\n//not sure if this is due to the black hole or some zfar climming code error.\n#define zFar 2000.\n//[e*]=[epsilon] sets your heuristic precision.\n//Larger [e*] infrease framerate, make the world \"chubbier\".\n//Epsilon is split in 2 \"half spaces, seperating by distance to camera\"; An inside or outside of..\n// eThreshold, Radius of sphere around camera,switches [epsilon modes];\n#define eThreshold 111.\n// eNear-mode (in eThreshold) for better nearby reflections.\n//  if (s<eNear){close enough}\n#define eNear .01\n// eFar-mode (out eThreshold)\n//  ,world gets log()aytmically more chubby by this factor.\n//  if (0.<log(t*t*eFar/s)){close enough}\n//  eNear mode has Better precision for reflections.\n#define eFar .000002\n//one factor is also he cameras distance to vec3(0)\n//, increasing precision loss where small e* get roundedtoo much\n//  eFar  mode has Better precision for long corridors and horizons\n\n\n\n//large enough Mass is NOT black, light can always escape_time it.\n//because within this shader, time is uniform \n//(and basically zFar==infinite within loberps() marching)\n//- which is a a simple false model\n//we can toggle between [black hole] and [naked singularity]\n//- that is, given [infinite time], the black hole ceases to have an event horizon.\n//via[blackHoleIsEscapeable]\n//ie, there is no schwarzshild radius, only \"sphere inversion\"\n//in this model,uniform time makes a [constant schwarzshild radius]=1.\n//in reality,time is not uniform, [schwarzshild radius]~=[mass]\n\n//#define blackHoleIsEscapeable\n//but because itsd based on some physically silly assumptions, its off by default, and you see a black sphere.\n\n//scene scaling for VR (poorly implemented concept placeholder)\n#define scaleVR 1.\n\n#define camMovement 0\n//0=use this as BuffA to have camera movement with collision detection.\n//1=static camera\n//2=camera moves over time\n//4=camera moves by mouse\n//6=camera moves over time and by mouse\n//nonzero camMovement is faster and bufferless (can be mainImage only)\n\n#if (camMovement==0)\n //agility\n #define THRUST Thusting*iTimeDelta*scaleVR\n #define ROLL 1.0*iTimeDelta\n #define ROTATE 4.0*iTimeDelta\n //camera collision sphere radius\n #define TOO_CLOSE .3\n //todo: TOO_CLOSE should internally scale with movement speed\n //controls (i may have swapped left and right here, do not overthing this one)\n #define LEFT_ARROW 39\n #define RIGHT_ARROW 37  \n #define UP_ARROW 38\n #define DOWN_ARROW 40\n#endif\n\n\n//user interface is better when it sets first derivatives\n//and these set their antiderivativesa (above) over time (each frame)\n//as in, each frame we add velocity to speed\n//as in, each frame we rotate bRot0 by bRot1\n\n//we buffer vec4, 4d positions, and quaternions\n//a 4d rotation would be 2 quaternions, 1 occtinion\n//, this is fibration math, and i will delay it.\n//therefore only quaternion rotation within 3d space is being done.\n//while positions are buffered in 4d.\n//a 4d position allows the 4th domain to be equal to \"parallel portal worlds\"\n\n//buffer a position\n#define bPos0 0.\n//buffer change (first derivative) of bPos0 over time\n#define bPos1 2.\n\n//buffer a rotation\n#define bRot0 1.\n//buffer change (first derivative) of bRot0 over time\n#define bRot1 3.\n//bRot1 has a few problems with it.\n//main issue is small angle precision loss for rotations\n//and the thing that rotations are rings\n//, 90Â° in both directions is equal.\n//so you would not be able to tell if you rotate left or right.\n//but this is rare, since we divide by /iTimeDelta\n//and too say \"screw you qlerp\",\n//because we qslerp(bRot0,bRot1,iTimeDelta)) \n\n/*\nGravitational waves:\nThis shader has a simple spherical gradient for \"gravity well\"\nrelative movement of the black hole does not cause gravitational waves.\nGravitational waves would require a 3d buffer (or deterministic gradient)\nand tracing through that voxel buffer requires like 6mb of vRam.\nMultiple black holes should be like a metaball.\n\nGravity Wells trough portals, have the problem that \n the well is euclidean distance, and portals make that hard to estimte.\nGravity wells trough portals are the traveling #salesman problem\n, but VERY non-euclidean, because mutable portals add mutable nodes.\n\n*/\n\n\n//---lib.core:\n#define PI acos(-1.)  \n#define PIB acos(0.)\n#define dd(a) dot(a,a)\n#define sat(a) clamp(a,.0,1.)\n#define u2(a) ((a)*2.-1.)\n#define u5(a) ((a)*.5+.5)\n#define perp(a) vec2(a.y,-a.x)\nfloat det2d(vec2 a, vec2 b){return a.x*b.y-a.y*b.x;}//2d determinant(mat2(a,b))==det2d(a,b)==perpendicular dotproduct\n\n/*\n//----lib.hash for scatter-noise\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n//hash function by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p){p=fract(p*HASHSCALE4.xyz)\n;p+=dot(p,p.yxz+19.19);return fract((p.xxy+p.yxx)*p.zyx);}\nfloat h12(in vec2 p){\n return fract(float(iFrame)+sin(dot(p,vec2(13.3145,17.7391)))*317.7654321);}\n/**/\n\n\n//---lib.quaterion\n//Null_Rotation_quaternion, the [[identity] of a quaternion]\nvec4 qid(){return vec4(0,0,0,1);}\n//return quaternion of Axis+Angle rotation input\nvec4 aa2q(vec3 axis, float angle){return vec4(normalize(axis)*sin(angle*.5),cos(angle*.5));}\n// A Quaternion is a normalized axis-angle rotation. (this is simplext identity)\n// A Quaternion rotates around an axis .xyz by an angle .w (pi*2==fullRotation)\n//More generally (less simple):\n// A Quaternion is a complex number with 3 \"imaginary\" domains; i=.x,j=.y,k=.z where i*i=-1... i*j*k=-1;\n//\n//return quaternion of an vec3(pitch,yaw,roll) input:\n#define qpyrs(s,c,a) vec4(s.x*c.y,a*s.y*c.x,s.x*s.y,c.x*c.y)*c.z\nvec4 qpyr(vec3 o){o*=.5;vec3 s=sin(o),c=cos(o);return qpyrs(s,c,1.)+qpyrs(c,s,-1.);}\n//\n//rotating a rotation by a rotation is not commutative (except in 2d)\n//return q2, rotated by q1, order matters when unsigned(axes) are not identical.\nvec4 qmul(vec4 q1, vec4 q2){return vec4(q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz)\n,(q1.w*q2.w)-dot(q1.xyz,q2.xyz));}\n//you negate a rotation by inverting the quaternion.\nvec4 qinv(vec4 q){return vec4(-q.xyz,q.w)/dot(q,q);}//inverse quaternion\n//return point p, rotated by q;\nvec3 qmul(vec4 q, vec3 p){return qmul(q,qmul(vec4(p,.0),qinv(q))).xyz;}\n//return Axis.xyz + angle.w of quaternion:\nvec4 q2aa(vec4 q){return vec4(q.xyz/sqrt(1.0-q.w*q.w),acos(q.w)*2.0);}//assumed q is normalized coverts to axis&angle\n//return the quaternion rotation that would be needed to turn;\n// to looking from position vec3(0) at vec3(0,0,1); to look_at [b]\nvec4 qlookat(vec3 b){return aa2q(vec3(-b.y,b.x,0.0),acos(b.z/length(b)));}//point in direction v\n//qlookat() can be used to define a quaternion\n//, without calculating axis or angle;\n//below is a general form of qlookat()\n//below it a naive lazy low precision (and untested) approach to quaternions.\n// but naive is always a good start:\n//\n//return shortest rotation what would be needed to turn;\n// to looking from position vec3(0) at [a]; to look at [b], assume both to be normalized.\nvec4 qrotBetween(vec3 a,vec3 b){const vec2 r=vec2(0,1);\n;float f=dot(dd(a),dd(b));// product of the lengths of the arguments\n;if(f!=0.){f=sqrt(f)\n ;float e=dot(a,b)/f;// normalized dotproduct of the arguments (cosine)\n//;vec3 c=vec3(det2d(a.yz,b.yz)\n//            ,det2d(a.zx,b.zx)\n//            ,det2d(a.xy,b.xy))/aabb // normalized crossproduct of the arguments\n ;vec3 c=cross(a,b)/f//normalized crossproduct of the arguments\n ;float d=dd(c)// squared length of the normalized crossproduct (sine)\n ;if (d!=0.// test if the arguments are not (anti)parallel\n ){float s\n  ;if (e>-sqrt(2.)*.5)s=1.+e//cosine adjusts s\n  ;else s=d/(1.+sqrt(1.-d)) //sine   adjusts s\n  ;return vec4(c,s)/sqrt(d+s*s)//return normalized quaternion\n ;}\n ;if (e>0.)return r.xxxy // the arguments are parallel, or anti-parallel if not true:\n ;float m=dd(a); // the length of one argument projected on the XY-plane\n if(m!=0.\n ){a=sqrt(a)\n  ;return vec4(a.y,-a.x,0,0)/m; // return a rotation with the axis in the XY-plane\n ;}return r.yxxx;}//parallel to Z-axis case,rotate around X-axis\n;return r.xxxy;}//too small angle, return null-rotation;\n//http://wiki.secondlife.com/wiki/LlRotBetween#Replacement\n//\n//[quaternion spherical linear interpolation] between 2 quaterion rotations in 3d space.\nvec4 qslerp(vec4 a,vec4 b,float f)\n{float d=dot(a,b),t=acos(abs(d)),o=(1./sin(t))\n;return normalize(a*sin(t*(1.-f))*o*sign(d)+b*sin(t*f)*o);}\n\n\n\n//struct FarLight{vec3 d;vec4 color;};        \nstruct PointLight{vec3 position;vec4 color;};\n\n    \nvec3 repeat(vec3 v){return vec3(mod(v.x,repeatScale*2.)-repeatScale,v.y,mod(v.z,10.));}\n\n\n#define time (iTime)\n\n#define PI acos(-1.)\n#define TAU (PI*2.)\n\n#define RID(p,r) (floor((p+r/2.)/r))\n#define REP(p,r) (mod(p+r/2., r) - r/2.)\n\nfloat hash(float n){return fract(sin(n)*43758.5453);}\n\nfloat noise(in vec3 x\n){vec3 p=floor(x)\n ;vec3 f=fract(x)\n ;f=f*f*(3.-2.*f)\n ;float n=p.x+p.y*57.+113.*p.z\n ;float res=mix(mix(mix(hash(n+ 0.),hash(n+  1.),f.x)\n ,                  mix(hash(n+57.),hash(n+ 58.),f.x),f.y)\n ,              mix(mix(hash(n+113.),hash(n+114.),f.x)\n ,                  mix(hash(n+170.),hash(n+171.),f.x),f.y),f.z)\n ;return res;}\n\nmat2 rot(float a\n){float ca=cos(a);float sa=sin(a)\n ;return mat2(ca,-sa,sa,ca);}\n\nfloat sdPlane(vec3 p, vec4 n){return dot(p,n.xyz)-n.w;}\n\nfloat solid(vec3 p, float s\n){float dist=-1000.\n ;vec3 dir=vec3(0,1,0)\n ;float h=3.\n ;float v=6.\n ;mat2 hr=rot(TAU/h)\n ;mat2 vr=rot(TAU/v)\n ;for(float j=0.;j<v;++j\n ){for(float i=0.;i<h;++i\n  ){float ran=(hash(s+j*i)-.5)\n   ;dist=max(dist,sdPlane(p, vec4(dir,1.+ran)))\n   ;dir.xz*=hr;}\n  ;dir.yz*=vr;}\n ;return dist;}\n\nfloat map(vec3 p\n){vec3 cp=p\n ;vec3 pid=RID(p, 80.)\n ;p=REP(p, 80.)\n ;p.xy*=rot(pid.z*.5)\n ;p.zy*=rot(pid.x*.5)\n ;p.xz*=rot(pid.y*.5)\n ;p.z-=time\n ;p.y+=2.\n ;p.xy*=rot(p.z*.1)\n ;p.y-=2.\n ;p.xy*=rot(time*.05)\n ;float dist=1000.\n ;p*=2.\n ;float r=6.\n ;vec3 id=RID(p, r)\n ;p=REP(p , r)\n ;float nois=noise(id)\n ;float t=time*(nois+.2)\n ;p.xz*=rot(t)\n ;p.xy*=rot(t*.5)\n ;p.yz*=rot(t*.25)\n ;dist=solid(p,nois)*.25\n ;dist=max(dist,length(id.xy)-2.)\n ;return dist;}\n\n\n\n\nfloat distFromPlane (vec3 p){\n//;return dot(vec3(0,1,0), p)+1.5 //just a plane\n;displace(p)\n    ;return map(p/GreenScale)*GreenScale\n    \n    \n    ;}//normal,offset\n\nfloat sphere1(vec3 u){\n    ;displace(u)\n ;vec3 s=vec3(0,0,8);//(vec3(0.0,cos(iTime),8.0+0.5*sin(iTime)))\n ;return (length(repeat(u)-s)-1.5)\n //;return (length((u)-s)-1.5)\n ;}\n\n//accumulate color (infinite reflections with specular)\n//[r]reflective surface fraction (1=perfect mirror 0=100% matte)\n//[o]color Accumulator\n//[u]viewRayOrigin    (gets reflected by [n])\n//[d]viewRayDirection (gets reflected by [n])\n//[s]Farlight, parallel light source has angle and color (for specular) \n//[l]used-up percentage of matte-light (1.-[reflective surface fraction] adds to this)\n//[C]diffuse material color (often a constant)\n//[n]surface normal\nvoid accCol(float r,inout vec4 o,inout vec3 u,inout vec3 d,inout float l,vec3 s,vec4 c,vec3 n){\n;//o+=pow(abs(dot(s,d)),180.)*.8;//specular (is very cheap within reflections)  \n//lazy specular within a modulo tesselation looks bad.\n;d=reflect(d,n)\n;u+=d\n;float m=(1.-l)*r,p=m+l;\n;o.xyz=(o.xyz*l+c.xyz*m)/p;\n;l=p ;}\n\n\n//The complete distance field is a min of all other distance fields.\n//Tther distance fields are seperated\n// to independently get other surface properties, this is a BVH  that resolves TextureID\nfloat gd(vec3 u, float t){\n//sphere is animated\n;vec3 s=(vec3(0.0,cos(iTime),8.0+0.5*sin(iTime)))\n;float distP=distFromPlane(u)\n;float distS=(length(repeat(u)-s)-1.5);\nreturn min(distP,distS);}\n\nbool eMode(float t,float s)\n{if(t<eThreshold)return s<eNear//better for short distance reflections\n;return 0.<log(t*t*eFar/s);}//better for long distance\n\n//problem here is that the set is 2 subsets.\n//no big issue, just rethinking conventions.\n\n\n//a raymarcher with infinite reflection,barelyNewtonian distortion, no AO\nvec4 MarchBlackHole(vec3 u,vec3 d){\n;float l=0.//acc [matte used], every reflection increases [matte used]\n,dLast=0.//last distance to an object\n,t=0.; //distance to camera\n;vec3 s=normalize(vec3(sin(iTime),.4,cos(0.43*iTime)))//pos sun\n,h=vec3(5.*sin(.6*iTime),5,15.+5.*iTime+4.*cos(.2*iTime))//pos black hole\n\n;vec4 o=vec4(0,0,0,1)\n//;vec3 h=vec3(5.*sin(.6*iTime),116,15.+5.*iTime+4.*cos(.2*iTime)) //position of black hole\n,cPlane =vec4(.4,.7,.4,1)\n,cSphere=vec4(.9,.2,.1,1);//colors\n;for(float i=0.;i<iterRm;++i\n){float dS=sphere1(u),dP=distFromPlane(u)\n ,dN=dd(u-h),dM=sqrt(dN)//distances\n #ifdef doBlackHole\n  ;float f=BlackHoleMass/dN//pulling force, mass of black hole\n  //;f=22.*(.02+.5*((cos(0.1*iTime)+1.)))/dN //mass of black hole\n  //;o*=smoothstep(-f,0.,.1*dM*f);//black hole has a darker reflection \n  #ifndef blackHoleIsEscapeable\n  ;if(dM<f)return o;//if raymarched inside event horizon, break.\n  #endif\n #endif\n //distances to 2 shapes\n ;if(eMode(t,dS)\n ){accCol(.5,o,u,d,l,s,cSphere,normalize(vec3(0,0,8)-repeat(u)));//explicit normal of sphere1()\n ;if(l>.99)break;}//out if reflectiveness\n ;if(eMode(t,dP)\n   \n ){accCol(Reflectiveness,o,u,d,l,s,cPlane,vec3(0,1,0));\n ;if(l>.99)break;}//out fof reflectiveness\n ;dLast=min(min(dS,dP),dM)\n ;t+=dLast\n //artificial blue horizon IS a BV that can look like a globe while the black hole is stronger.\n ;if((dM)>zFar)break//enforce horizon for a blue sky line\n #ifdef doBlackHole\n // ;d=normalize(d-dLast*f)//distortion by black hole\n ;d=normalize(d-dLast*f*(u-h)*sqrt(dM*.001))\n #else\n ;d=normalize(d);   \n #endif\n ;u+=d*dLast*sqrt(dM*.001) //u moves along the ray      \n //;d=normalize(d-dLast)//black hole bends ray (and shoortens ray)\n//  #endif\n// ;u+=d*dLast//u moves along the ray\n;}\n#ifdef doBlackHole\n//;u+=d*force\n#endif\n;o.xyz=(o.xyz*l+vec3(.2,.5,.9)*(1.-l));//remaining [l] becomes blue sky\n//;float angle=dot(sun,d)\n//below reflects a modulo light on the floor that does not exist\n//still okay.\n//;o += pow((abs(angle)),180.)*.8;\n;return o;}\n\n#if (camMovement==0)\n //---lib.buffer, originally from iq, modified\n float isInside(vec2 p,float c){vec2 d=abs(p-.5-vec2(0,c))-.5;return -max(d.x,d.y);}\n vec4 load(float r){return texture(iChannel0,(.5+vec2(0,r))/iChannelResolution[0].xy,-100.);}\n float key(in int k){return texture(iChannel1,vec2((float(k)+0.5)/256.,.25)).x;}\n //movement with buffer and collision detection\n //set camera position and rotation. (and meybe some derivatives over time of these?\n //this gts buffered in the lower left fragments.\n //these then get loaded by each fragment to render a camera view.\n void steer(out vec4 o,vec2 u){//asll colision detection is in this function!\n ;if(iFrame<1){if(isInside(u,bPos0)>.0)o=vec4(1,0,0,0)//init position\n  ;else        if(isInside(u,bRot0)>.0)o=vec4(0,0,0,1)//init rotation\n  ;else        if(isInside(u,bRot1)>.0)o=vec4(0,0,0,1)//init rotation\n  ;else        if(isInside(u,bRot1)>.0)o=vec4(0,0,0,1)//init rotation\n ;}else{vec4 p=load(bPos0),q=load(bRot0)//next frame\n  ;vec3 fw=qmul(q,vec3(0,0,1)) //this can be done simpler\n  ,b=p.xyz+fw*p.w*.2;float t=1.;\n  ;if(gd(b,t)>TOO_CLOSE)p.xyz=b;else //check each domain independently.\n      //this can be simplified with mstretch()==analstretching():\n  {;vec3 ass=vec3(gd(vec3(b . x,p.yz ),t)\n                 ,gd(vec3(p.x,b.y,p.z),t)\n                 ,gd(vec3(p.xy , b.z ),t))\n  ;p.xyz=mix(b.xyz,p.xyz,sign(vec3(TOO_CLOSE+1.)-ass));}\n  ;p.w+=THRUST*(key(UP_ARROW)-key(DOWN_ARROW));  \n  ;if(isInside(u,bRot0)>.0  //store normalized rotation\n  ){vec2 m=vec2(0)\n   ;if(iMouse.z>.0){//if(mous button down)\n   ;vec2 n=iMouse.xy-abs(iMouse.zw);n.x=-n.x;m.xy-=n/iResolution.xy;}\n   #ifdef USE_AUTO_PILOT\n    else{//auto pilot requires [p]osition\n    ;float d=gd(p.xyz)\n    ;b=qmul(q,vec3(d,0,0))\n    ;float d2=gd(p.xyz+b)\n    ;m.x=sign(d2-d)*ROTATE/(.1+2.*d*d);}\n   #endif\n   ;float r=ROLL*(key(RIGHT_ARROW)-key(LEFT_ARROW)); \n   ;o=normalize(qmul(q,qpyr(vec3(m.yx*ROTATE,r))));}//store rotation\n  else if(isInside(u,bPos0)>.0)o=p //store position\n  ;}   \n ;}\n#endif\n\n//this is the render image, the larger frame of the PiP.\n//vec4 mainImage2(out vec4 o,vec2 u){\nvec4 mainVR2(out vec4 o, in vec2 u,vec3 A,vec3 D){\n;vec3 d=normalize(vec3((2.0*u-iResolution.xy)/iResolution.y,1.0))\n#if (camMovement==0)\n ;vec3 l=load(bPos0).xyz\n ;d=qmul((load(bRot0)),d);\n#else \n ;vec3 l=vec3(10);//insert function thqat sets camera position\n ;vec4 q=vec4(0,0,0,1)//inser function that controls camera rotation\n #if(camMovement&2)\n //mod() for better precision over time.\n ;q=qpyr(mod(iTime*.5*vec3(1,1.61,sqrt(3.)),acos(-1.)*2.))//pitch,yaw,roll rotate over time.  \n ;d=qmul(q,d);\n #endif\n #if(camMovement&4)\n ;q=qpyr(mod(vec3(iMouse.xy*4./iResolution.yx,0),acos(-1.)*2.))//mouse.xy constol pitch,yaw\n ;d=qmul(q,d);\n #endif\n#endif\n//;d=normalize(d);//neglible difference   \n;return MarchBlackHole(l,d);}\n     \n//PiP Splitscreen, lower left pixels in veiw space buffer camera parameters for movement.\nvoid BufferSplit(out vec4 o,vec2 u,in vec3 A,in vec3 D){;\n#if (camMovement==0)\n if(all(lessThan(u,vec2(1.5,2.5))))steer(o,u);else    \n#endif\n o=mainVR2(o,u,A,D);}//this branch can be split in 2 frame buffers.\n//this is the only reason it exists as seperate function.\n\n//Shitty VR ignores [A]=HeadSetPosition and [D]=HeadSetLookingDirection\n// You can only move your view with keyboard and mouse.\n// Its up to you to inclide these vectors\n// Will not get much out of it, as shaderty VR support is not so good.\n// This is tricky and the pipelines are bad and this framework is bad.\nvoid mainVR(out vec4 o,in vec2 u,in vec3 a,in vec3 d){;\n  BufferSplit(o,u,a,d);}\n\n//field of view in radians\n//seems to somehow have no effect ,man this was copied\n//from someone who didnt clean up his stuff.\n#define fov vec2(25.)\nvec2 modmx(vec2 m)\n{return PI*mix(vec2(1.-m.x,m.y*.35),vec2(1,0),step(iMouse.z,.0));}\n\n//mainImage() to mainVR() projection simulates VR:\n//[camPos]==offset of the VH headsed (in meters?)\n//[m.xy] sets Euler rotations of a VR headset with a mouse.\nvoid mainImage(out vec4 O,in vec2 U){O=vec4(0);//for compatibility\n;const vec3 u=vec3(0)//u=cameraPosition is a simple offset\n;const float r=360./acos(-1.),d=acos(-1.)/180.//360/pi ; pi/180\n;vec2 m=modmx(u2(iMouse.xy/iResolution.xy))\n,f=fov;f.x=atan(tan(f.y/r)*iResolution.x/iResolution.y)*r\n;mat3 c\n;c[0]=vec3(cos(m.x),0,sin(m.x))//camera.right\n;m.x+=PI*.5\n;c[1]=vec3(cos(m.x)*cos(m.y),sin(m.y),sin(m.x)*cos(m.y))//cameraFwd\n//;c[2]=-cross(c[0],c[1]))//camUp\n;f=(2.*U/iResolution.xy-1.)*sin(f*d)/sin(PI*.5-f*d)\n;c[0]=u-c[1]+f.x*c[0]-f.y*cross(c[0],c[1]);\n;mainVR(O,U,c[0],normalize(c[0]-u));}\n//https://www.shadertoy.com/view/XlBGzm\n\n/*\n//simpler camera setup, no movement\nvoid mainImage2( out vec4 o, in vec2 u){\n//;vec3 sun=(normalize(vec3(sin(iTime))))\n;u=u.xy/iResolution.y-vec2(.5)\n;u.x*=iResolution.x/iResolution.y;\n;vec3 r=vec3(0,3,5.*iTime)//rayOrigin\n,d=normalize(vec3(u,1))//ray direction\n;o=MarchBlackHole(r,d);}\n*/\n\n/*\n- changelog:\noptimized steer() branching, still can not skip iFrameNull or init()\nadded optional bufferles rotations\nadded rotBetween\nminor cleanups\nminor namespace changes\n*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}