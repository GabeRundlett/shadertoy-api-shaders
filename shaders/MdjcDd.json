{
    "Shader": {
        "info": {
            "date": "1494470625",
            "description": "mouse changes camera\n\nthis extends\nhttps://www.shadertoy.com/view/lsBcDt\nwith the text triClone() pattern of \nhttps://www.shadertoy.com/view/4dKXR3\nso that every fragment only checks the glyphs within the same triangle. \ngood for \"mode7\"",
            "flags": 0,
            "hasliked": 0,
            "id": "MdjcDd",
            "likes": 7,
            "name": "triangle tiling with addresses",
            "published": 3,
            "tags": [
                "triangle",
                "text",
                "simplex",
                "font",
                "pattern",
                "tiling",
                "homogeneous",
                "tiles",
                "address"
            ],
            "usePreview": 1,
            "username": "ollj",
            "viewed": 974
        },
        "renderpass": [
            {
                "code": "//self   = https://www.shadertoy.com/view/MdjcDd\n//parent1= https://www.shadertoy.com/view/lsBcDt //triangle color addresses\n//parent2= https://www.shadertoy.com/view/4dKXR3 //text triClone() triangle tiling for\n//child  = https://www.shadertoy.com/view/4sXBzr //text rectangle tiling \n\n/*\nthe three humbers in every triangle (and the rgb colors of triangles)\nhave rather unintuitive 3d addresses on a 2d plane:\n\nThere 3 values needed to uniquely address any triangle tile\nin a 2d triangle pattern:\n\nBecause there are 3 boundary dimensions,\n... one boundarie for each triangle side, \n... and only 1 of 3 coordinates changes \n... between any neighboring triangles:\n\n\nThe FIRST  value in RED   changes when you cross a diagonal   boundary\n... of a tiagonal that goes from bototm LEFT  to top RIGHT\n\nThe SECOND value in GREEN changes when you cross a horizontal boundary\n\nThe THITD  value in BLUE  changes when you cross a diagonal   boundary\n... of a tiagonal that goes from bototm RIGHT to top LEFT\n*/\n\n\n/*\ndarkDistanceToTriangleBorder =[dist]= \n...= distance to borders of a triangle\n\nCoordsInASquareInRedBlue.xy=[squareXY]=\n...= .xy coordinates within a skewed square.\n\nis mixed as [squareXY*dist] in hte very end.\n*/\n\n\n//  ---end of header\n//start of modifiable defines\n\n\n\n//Cheap inverse 3d plane projection. can be disabled by not being [1]\n//Has iMouse.y linear:interpolate between \"top down\" and a \"mode7\"\n//(which only makes sense if you look straight forward, mouse on right border)\n#define MODE7 1\n//the awesome part is how this actually projects\n//two triangles into \"almost_squares\" within screenspace.\n\n//change \"iTime\" to change progression of time \n//or to set a timestamp.\n#define time iTime\n\n//fast oscillating over time, range [0..1]\n#define times (sin(time)*.5+.5)\n//tric is a vec3 that stores tile id. \n//to render this in visible color space we do\n//tric=fract(floor(tric)*tricScale);\n//to show trianglePos in a visible color space\n//only for \"null island\", that color is always =0=fract(0)\n//\"null island\" has tilepos(0,0,0)\n//and is named after: https://www.youtube.com/watch?v=bjvIpI-1w84\n#define tricScale times\n\n//medium oscillating over time, range [0..1]\n#define times2 (sin(time*.3)*.5+.5)\n//final color mix between 2 different displays of:\n//display tiangleId within visible color space.\n//and\n//display CoordsInASquareInRedBlue.xy * darkDistanceToTriangleBorder \n#define finalmix times2\n//because CoordsInASquareInRedBlue.xy \n//is easier for bilinear interpolation. as it is only a vec2 adress.\n\n//slow oscillating over time, range [0..1]\n#define times3 (cos(time*.2)*.5+.5)\n//lerps zoom level=\"height above Mode7 Plane\"\n#define ViewZoom 9.*(times3+.5)\n\n\n\n//above defines can easily be modified.\n//-----------------end of modifiables---------------------------\n//modifying anything below is trickier.\n\n//irrational numbers are defines in hopes of\n//...compilers being smart enough to substitute a/a=1 (for a!=0)\n#define p32 sqrt(3.)\n//p322=.866\n#define p322 (p32*.5)\n//p173= .5/(.866)\n#define p173 (.5/p322)\n\n//float vmin(vec3 p){return min(min(p.x,p.y),p.z);}\nfloat vmax(vec3 p){return max(max(p.x,p.y),p.z);}\n\n#define r2(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n//rotate p by angle r: p=r(p,r);\n#define r(p,r) (cos(r)*p+sin(r)*vec2(-p.y,p.x))\n//vec2 r(vec2 p,float t){return cos(r)*p+sin(r)*vec2(-p.y,p.x);\n//}//from https://www.shadertoy.com/view/XlfGzH\n\n\n//glyph texture addresses:\n#define FONT_SPACE 0.5\nconst vec2 vFontSize  = vec2(8.0, 15.0);  // multiples of 4x5 work best\n#define SPACE tp.x-=FONT_SPACE;\n#define S(a) c+=char(a);   tp.x-=FONT_SPACE;\n#define _sub   S(45);   // -\n#define _add   S(43);   // + \n/*\n#define _note  S(10);   //\n#define _star  S(28);   // *\n#define _smily S(29);           \n#define _ tp.x-=FONT_SPACE;\n#define _exc   S(33);   // !\n#define _comma S(44);   // ,\n#define _dot   S(46);   // .\n#define _slash S(47);   // /\n#define _0 S(48);\n#define _1 S(49);\n#define _2 S(50);\n#define _3 S(51);\n#define _4 S(52);\n#define _5 S(53);\n#define _6 S(54);\n#define _7 S(55);\n#define _8 S(56);\n#define _9 S(57);\n#define _ddot S(58);   // :\n#define _sc   S(59);   // ;\n#define _less S(60);   // <\n#define _eq   S(61);   // =\n#define _gr   S(62);   // >\n#define _qm   S(63);   // ?\n#define _at   S(64);   // at sign \n#define _A S(65);\n#define _B S(66);\n#define _C S(67);\n#define _D S(68);\n#define _E S(69);\n#define _F S(70);\n#define _G S(71);\n#define _H S(72);\n#define _I S(73);\n#define _J S(74);\n#define _K S(75);\n#define _L S(76);\n#define _M S(77);\n#define _N S(78);\n#define _O S(79);\n#define _P S(80);\n#define _Q S(81);\n#define _R S(82);\n#define _S S(83);\n#define _T S(84);\n#define _U S(85);\n#define _V S(86);\n#define _W S(87);\n#define _X S(88);\n#define _Y S(89);\n#define _Z S(90);\n#define _a S(97);\n#define _b S(98);\n#define _c S(99);\n#define _d S(100);\n#define _e S(101);\n#define _f S(102);\n#define _g S(103);\n#define _h S(104);\n#define _i S(105);\n#define _j S(106);\n#define _k S(107);\n#define _l S(108);\n#define _m S(109);\n#define _n S(110);\n#define _o S(111);\n#define _p S(112);\n#define _q S(113);\n#define _r S(114);\n#define _s S(115);\n#define _t S(116);\n#define _u S(117);\n#define _v S(118);\n#define _w S(119);\n#define _x S(120);\n#define _y S(121);\n#define _z S(122);\n*/\n\n#define tpp tp.x+=FONT_SPACE\n#define tpm tp.x-=FONT_SPACE\nvec2 tp=vec2(0);//text position\nvoid SetTextPosition(vec2 p,float x,float y){//x=line, y=column\n tp=10.0*p;tp.x=tp.x+17.-x;tp.y=tp.y-9.4+y;}\n//return number of decimal digits of [f], with [d]leading zeroes.\nint getNumberOfDigits(in int f,in int d){\n for(int n=0;n<10;n++){f/=10;if(f==0)break;d++;}return d;}\nfloat char(int c){vec4 f=any(lessThan(vec4(tp,1,1),vec4(0,0,tp))) \n ?vec4(0):texture(iChannel0,.0625*(tp+vec2(c-c/16*16,15-c/16)));  \n return f.x;}\n/*\n//display [f]fraction with [d]leadingZeros \nfloat drawFract(int d,float f){float c=0.;f=fract(f)*10.; \n for(int i=1;i<60;i++){c+=char(48+int(f));tpm; \n  d--;f=fract(f)*10.;if(d<=0||f==0.) break;\n }tpp*float(d);return c;}\n*/\n//draw [v]int with a minimum # of [m]glyphs\nfloat drawInt(int v,int m){float c=0.;\n if(v<0){v=-v;_sub//if(m<1){m=1;}else m--;\n  }else{_add//if(v<0){v=-v;if(m<1){m=1;}else m--;\n }//sign handling\n int f=v,d=1;d=getNumberOfDigits(f,d);//for(int n=0;n<10;n++){f/=10;if(f==0)break;d++;} \n //d=max(m,d);\n tpm*float(d);\n for(int n=1;n<11;n++){tpp;c+=char(48+(v-((v/=10)*10)));if(n>=d)break;} \n tpm*float(d);return c;}//https://www.shadertoy.com/view/ldByDw\n/*\n//display [v]float with [p]decimalPrecision and [m]maxDigits\nfloat drawFloat(float v,int p,int m){float c=0.,tpx=tp.x-FONT_SPACE*float(m);\n if (v<0.){c=char(45);v=-v;}tp.x-=FONT_SPACE; //write \"-\"\n c+=drawInt(int(v),1);c+=char(46);SPACE;//write floor()+\".\"+fract()    \n c+=drawFract(p,fract(v));tp.x=min(tp.x,tpx);return c;}\n//shorter defaults\nfloat drawFloat(float v)      {return drawFloat(v,2,5);} \nfloat drawFloat(float v,int p){return drawFloat(v,p,2);} \nfloat drawInt(int v)          {return drawInt(v,1);}\nvec3 drawColor=vec3(1.);\nvoid SetGlyphColor(float r,float g,float b){drawColor=vec3(b,g,b);}\n*/\n\n//return color of glyphs for [p], glyph-numerals set by [i]\nvec3 glyphs(vec2 p,vec3 i){\n p*=.65;//optional, making glyphs as large as possible\n vec3 r=vec3(0.);//accumulator for glyph color.\n float d=length(p);r=.02*vec3(fract(d*9.));//optional debug\n //above line draws 2 circles showing the abbs()tiling within a square.\n //...that lets write text for each triangle.\n //for simplicity a skewed square is cut horizontally.\n float x=16.,y=8.2;//offsets\n #define di(a,b) SetTextPosition(p,x,y+b);r+=drawInt(int(floor(i[a])),0)\n di(0,0.)*vec3(1,.4,.4);//first line in red\n di(1,1.)*vec3(.4,1,.4);//second line in green\n di(2,2.)*vec3(.4,.4,1);//third line in blue\n return r;}\n\n//return position of a triangle within triangle tiling for [u]  \nvec3 tri(vec2 u){u*=mat2(1,-p173,0,2.*p173);     \n return vec3(u,1.-u.x-u.y);}\n//return distace to border with: \n//float distanceToTriangleBorder=vmax(tri2DistToBorder(tri(u)));\nvec3 tri2DistToBorder(vec3 g){return abs(2.*fract(g)-1.);}\n//return position.xy within slanted square. sign of (.z-.5) tells you the triangle.\n//positionXYInASquare=tri2inPos(tri(u)).xy\nvec3 tri2inPos(vec3 g){g=fract(g);\n                       \n vec3 b=1.-vec3(1.-g.xy,g.z);\n return mix(g,b,step(length(g)-1.,0.));}\n //if(length(g)-1.>0.){g=b;}return g;}//makes more sense to me to have it \"square\"\n//https://www.shadertoy.com/view/lsBcDt\n\nvec2 pmod(vec2 p, float s){float h=s*.5;\n return mod(p+h,s)-h;}//return floor((p+h)/s);\n\n//tiling\nvec2 triClone(vec2 u,float d){\n mat2 m=mat2(1,-p173,0,2.*p173);//skew a square of 2 bilateral triangles\n u*=m;u=pmod(u,1.);//...into 2 trilateral triangles, pmod()\n u*=inverse(m);//and then inverse the skewing.\n u.y=-u.y;u.y+=mix(.4,-.04,step(-u.y,0.));\n u.y-=.6*.5;//shift on y\n u.y=-u.y;//flip on y\n return u;}\n\n//screenspace framing\nvec2 frame(vec2 u){vec2 R=iResolution.xy;\n return ViewZoom*(u-R/2.)/R.y;u*=ViewZoom;}\n\nvoid mainImage( out vec4 O, vec2 U){\n //U.x+=iResolution.x*.5;//optional, for other camera constrains in mode7\n vec2 n=iMouse.xy-iResolution.xy*.5;//for mouse movement\n vec2 u=frame(U-n);//m=frame(iMouse.xy);\n #if (MODE7==1)\n  const float w=5.;//w sets \"height of horizon\"\n  vec2 mode7=u;mode7.y=mode7.y-3.*w;\n  mode7=-1.*w*vec2(mode7.x/mode7.y,4.*w/mode7.y);//simple planar projection\n  u=mix(mode7,u,(iMouse.y/iResolution.y));//mixing 2 modey by iMouse.y\n  //u=mode7;//non-mixing alternative\n #endif   \n vec3 tric=tri(u);//tile id\n vec2 t=triClone(u+vec2(0.,p322),1.);//where to draw text.\n vec3 text=glyphs(t,tric),//text color\n toBorder=tri2DistToBorder(tric),//distance to tile border\n squareXY=tri2inPos(tric);//position within a slanted square tile (.z to be ignored)\n float dist=vmax(toBorder);dist=1.-.2*fract(dist*6.);\n squareXY.z*=.1;squareXY=squareXY.yzx;//swivel for contrast\n tric=fract(floor(tric)*tricScale);//modulo of color tri() \n O =vec4(text+mix(tric,squareXY*dist,finalmix),1.);}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}