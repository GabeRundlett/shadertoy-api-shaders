{
    "Shader": {
        "info": {
            "date": "1620726612",
            "description": "sdf raymarching scene",
            "flags": 0,
            "hasliked": 0,
            "id": "sdBSzc",
            "likes": 3,
            "name": "scene abc",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf"
            ],
            "usePreview": 0,
            "username": "sirjofri",
            "viewed": 225
        },
        "renderpass": [
            {
                "code": "vec3 camrot = vec3(-0.4, 0.2, 0.);\nvec3 campos = vec3(3., 10., 4.);\nvec3 ambi = vec3(0.6, .8, .9);\nvec3 lightA = vec3(9., 10., 10.);\nvec3 lightB = vec3(20., 8., 7.);\nvec3 lightC = vec3(6., -12., 2.);\nvec3 lightcol = vec3(1., .9, .7);\nfloat ballspeed = 2.;\n\nfloat sdist = .0001;\n\nvec3 calcRayDir(vec3 d)\n{\n    mat3 yaw = mat3(\n        cos(camrot.x), -sin(camrot.x), 0.,\n        sin(camrot.x),  cos(camrot.x), 0.,\n        0.           ,  0.           , 1.\n    );\n    mat3 pitch = mat3(\n        1.,            0.,             0.,\n        0., cos(camrot.y), -sin(camrot.y),\n        0., sin(camrot.y),  cos(camrot.y)\n    );\n    mat3 roll = mat3(\n        cos(camrot.z),  0., sin(camrot.z),\n        0.,             1.,            0.,\n        -sin(camrot.z), 0., cos(camrot.z)\n    );\n    \n    d *= roll;\n    d *= pitch;\n    d *= yaw;\n    return normalize(d);\n}\n\nfloat noise(vec3 pos, int n)\n{\n    float x = 0.;\n    float on = float(n);\n    while (n-- > 0){\n        float y = .04-float(n)/on*.01;\n        x += cos(pos.y+sin(pos.x)*2.+sin((pos.x-pos.y)*.3)*3.)*y;\n        pos *= 4.59;\n    }\n    return x;\n}\n\nvec2 ground(vec3 pos)\n{\n    float d = pos.z\n        + smoothstep(0., 1., pow((pos.x+sin(pos.y*.6))*.4, 2.) + noise(pos*.4, 2)*2.)*(-2.)+2.\n        + sin(pos.x*.3+cos(pos.y*.4+1.))*.9\n        + sin(pos.x*1.+cos(pos.y*.5))*.1\n        + noise(pos*.8+sin(pos.y*1.2+pos.x*1.1+iTime*8.)*.02, 5);\n    return vec2(d, d < sdist ? 1. : 0.);\n}\n\nvec2 mysphere(vec3 pos)\n{\n    float d = sdSphere(vec3(-.6+cos(iTime*ballspeed), -7.+sin(iTime), .7-sin(iTime*ballspeed)), 1., vec3(pos.x, mod(pos.y, -30.), pos.z));\n    return vec2(d, d < sdist ? 2. : 0.);\n}\n\nvec2 dist(vec3 pos)\n{\n    vec2 a = mysphere(pos);\n    vec2 b = ground(pos);\n    return vec2(\n        min(a.x, b.x),\n        max(a.y, b.y)\n    );\n}\n\nvec2 march(vec3 ro, vec3 rd, int steps)\n{\n    float d = 0.;\n    for (int i=0; i<steps; i++) {\n        vec2 n = dist(ro + rd*d);\n        d += n.x;\n        if (n.x < sdist)\n            return vec2(d, n.y);\n    }\n    return vec2(100., 0.);\n}\n\nfloat shadow(vec3 ro, vec3 l)\n{\n    vec3 rd = normalize(l - ro);\n    float d = march(ro+rd*.5, rd, 128).x;\n    return d*.01;\n}\n\n/* Thanks iq */\nvec3 calcNormal(vec3 p)\n{\n    const float h = 0.2;\n    #define ZERO (min(iFrame,0))\n    vec3 n = vec3(0.);\n    for (int i=ZERO; i<4; i++)\n    {\n        vec3 e = 0.5773*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.);\n        n += e*dist(p+e*h).x; /* btw: s/pos/p */\n    }\n    return normalize(n);\n}\n\nfloat calcAO(vec3 pos, vec3 normal)\n{\n    float dst = 1.;\n    float d = dist(pos + normal*dst).x;\n    return clamp(mix(.8, 1., d/dst), 0., 1.);\n}\n\nvec3 color(vec3 p, float mat)\n{\n    vec3 gridcol = mix(vec3(.2, .4, 0.), vec3(0.4, .8, 0.), worldGrid(p*4.));\n    vec3 ballcol = vec3(.1, .3, 1.);\n    if (mat <= 0.1)\n        return gridcol;\n    if (mat <= 1.1)\n        return gridcol;\n    if (mat <= 2.1)\n        return ballcol;\n    return vec3(0.);\n}\n\nvec3 pp(vec3 col)\n{\n    return pow(col, vec3(1./1.8));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x -= iResolution.y/iResolution.x/2.;\n    uv -= .5;\n    \n    camrot.z = sin(iTime*2.5)*.02;\n    camrot.y = .2 + sin(iTime*ballspeed)*.03 +sin(iTime*.9)*.02;\n    camrot.x = -.4 + sin(iTime*ballspeed)*.03 +sin(iTime*2.3)*.005;\n    vec3 ro = campos;\n    vec3 rd = calcRayDir(vec3(uv.x, -2., uv.y));\n    \n    vec2 mr = march(ro, rd, 256);\n    float d = mr.x;\n    vec3 wp = ro + rd*d;\n    \n    vec3 norm = calcNormal(wp);\n    vec3 nao;\n    nao.x = mix(.1, .5, dot(normalize(lightA-wp), norm));\n    nao.y = mix(.1, .5, dot(normalize(lightB-wp), norm));\n    nao.z = mix(.1, .5, dot(normalize(lightC-wp), norm));\n    float ns = clamp(nao.x + nao.y + nao.z, 0., 1.);\n    float ao = clamp(calcAO(wp, norm), 0., 1.);\n    ao *= ns;\n    \n    vec3 s;\n    s.x = mix(0., .3, shadow(wp, lightA));\n    s.y = mix(0., .3, shadow(wp, lightB));\n    s.z = mix(0., .2, shadow(wp, lightC));\n    vec3 lightmix = (s.x+s.y+s.z)*lightcol + .01*ambi;\n\n    vec3 col = color(wp, mr.y);\n    col *= lightmix;\n    col *= ao;\n    \n    float dfog = clamp(mix(0., 1., d*.01), 0., 1.);\n    col = mix(col, ambi*.9, dfog);\n    col = pp(col);\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float worldGrid(vec3 pos)\n{\n    float x = smoothstep(-.2, .2, sin(pos.x));\n    float y = smoothstep(-.2, .2, sin(pos.y));\n    return (x+y)/2.;\n}\n\nfloat sdSphere(vec3 pos, float r, vec3 p)\n{\n    return distance(pos, p) - r;\n}\n\nfloat sdBox(vec3 pos, vec3 dim, vec3 p)\n{\n    return length(max(vec3(0), abs(p-pos)-dim));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}