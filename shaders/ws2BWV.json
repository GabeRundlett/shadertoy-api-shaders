{
    "Shader": {
        "info": {
            "date": "1590912683",
            "description": "crummy attempt at copying and pasting code from the web to make something that people want for no reason other than its unique and hard to find",
            "flags": 2,
            "hasliked": 0,
            "id": "ws2BWV",
            "likes": 3,
            "name": "Good Faith - Madeon Webcam",
            "published": 3,
            "tags": [
                "webcam",
                "colorfilter",
                "colorbalance",
                "madeon",
                "goodfaith"
            ],
            "usePreview": 0,
            "username": "jackwitherell",
            "viewed": 529
        },
        "renderpass": [
            {
                "code": "//in lieu of a docstring or any kind of documentation, I offer this\n\n//id rather you just reach out to me on discord if you wanna know how any of this works\n//please don't learn from my code it's disgusting and i'm tired\n\n\n\n//garbage maths\nfloat antidist(float br, float rang){\n    return (sin(        (1.0-abs(rang-br))*(3.14159/4.0)        ));\n}\n\n// stolen code!!!! https://www.shadertoy.com/view/XljGzV\nvec3 rgb2hsl( in vec3 c ){\n  float h = 0.0;\n\tfloat s = 0.0;\n\tfloat l = 0.0;\n\tfloat r = c.r;\n\tfloat g = c.g;\n\tfloat b = c.b;\n\tfloat cMin = min( r, min( g, b ) );\n\tfloat cMax = max( r, max( g, b ) );\n\n\tl = ( cMax + cMin ) / 2.0;\n\tif ( cMax > cMin ) {\n\t\tfloat cDelta = cMax - cMin;\n        \n        //s = l < .05 ? cDelta / ( cMax + cMin ) : cDelta / ( 2.0 - ( cMax + cMin ) ); Original\n\t\ts = l < .0 ? cDelta / ( cMax + cMin ) : cDelta / ( 2.0 - ( cMax + cMin ) );\n        \n\t\tif ( r == cMax ) {\n\t\t\th = ( g - b ) / cDelta;\n\t\t} else if ( g == cMax ) {\n\t\t\th = 2.0 + ( b - r ) / cDelta;\n\t\t} else {\n\t\t\th = 4.0 + ( r - g ) / cDelta;\n\t\t}\n\n\t\tif ( h < 0.0) {\n\t\t\th += 6.0;\n\t\t}\n\t\th = h / 6.0;\n\t}\n\treturn vec3( h, s, l );\n}\n//also stolen, source is above\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\n//heavily butchered version of gimp's color balance, thanks stackoverflow https://stackoverflow.com/questions/50522249/color-balance-with-core-image\nvec3 balanceFilter(highp vec3 textureColor, float brightness) {\n\n    float lightness = brightness; //hguefe\n\n    const float a = 0.25;\n    const float b = 0.333;\n    const float scale = 0.7;\n\n    //hack 0, dismiss old way of handling 'color offsets', cram in some green in the midtones (pretty much the only part of this function I didn't butcher\n    vec3 midtones = (((lightness - b) /  a + 0.5) * clamp ((lightness + b - 1.0) / -a + 0.5, 0.0, 1.0) * scale) * vec3(-0.1,0.5,-0.1);\n\n    highp vec3 newColor = textureColor.rgb + midtones ;\n    \n    //hack 1, cram in some red in the shadows\n    newColor=newColor+vec3(-0.1*lightness+0.24,0.0,0.0);\n    \n    highp vec3 newHSL = rgb2hsl(newColor);\n    //hack 2, improperly use this functionality and create some inverse lum boy thing\n    highp float oldLum = sqrt( 0.299*pow(textureColor.r,2.0) + 0.587*pow(textureColor.g,2.0) + 0.114*pow(textureColor.b, 2.0) );\n    \n    \n    //hack 3, cram in some blum/\n    textureColor.rgb = hsl2rgb(vec3(newHSL.xy, oldLum))+vec3(0.0,0.0,lightness);\n\n    return textureColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // standard boilerplate shadertoy, ignore this if you're from the internet\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    col = texture(iChannel0,uv).rgb;\n    \n    //stolen code!!! https://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color\n    float brightness = sqrt( 0.299*pow(col.r,2.0) + 0.587*pow(col.g,2.0) + 0.114*pow(col.b, 2.0) );\n    \n    //inverted canvas\n    col = 1.0 - col;\n    \n    //col = vec3(col.r + 0.299*(antidist(brightness, 0.1) - antidist(brightness, 0.7)),\n    //           col.g + 0.587*(antidist(brightness, 0.5) - antidist(brightness, 0.1) - antidist(brightness, 0.9)),\n    //           col.b + 0.3*(antidist(brightness, 0.9) - antidist(brightness, 0.3))\n    //          );\n    \n    col = balanceFilter(col, brightness);\n    \n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "webcam",
                        "id": 31,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/webcam.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}