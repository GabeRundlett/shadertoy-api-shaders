{
    "Shader": {
        "info": {
            "date": "1569236009",
            "description": "Reflection is very noisy when without AA :(",
            "flags": 0,
            "hasliked": 0,
            "id": "3dd3WB",
            "likes": 22,
            "name": "Energy Lab",
            "published": 3,
            "tags": [
                "3d",
                "raymarch"
            ],
            "usePreview": 0,
            "username": "kaneta",
            "viewed": 908
        },
        "renderpass": [
            {
                "code": "#define AA 1\n\n#define FLT_EPS  5.960464478e-8\n\n#define MAT_FLOOR 0.\n#define MAT_PIPE 1.\n#define MAT_CAGE 2.\n#define MAT_BALL 3.\n#define MAT_LIGHT 4.\n\nconst float pi = acos(-1.0);\nconst float pi2 = pi * 2.0;\nfloat time;\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nvec2 pmod(vec2 p, float r) {\n    float a = pi/r - atan(p.x, p.y);\n    float n = pi2/r;\n    a = floor(a/n)*n;\n    return p * rot(a);\n}\n\n// by http://mercury.sexy/hg_sdf/\nfloat fOpDifferenceRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r - b), vec2(0));\n\treturn min(-r, max (a, -b)) + length(u);\n}\n\nfloat fOpPipe(float a, float b, float r) {\n\treturn length(vec2(a, b)) - r;\n}\n\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n\n// by https://iquilezles.org/articles/distfunctions\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat cylinder(vec3 p, float r, float h) {\n    float d = length(p.xz) - r;\n\tp.y = abs(p.y) - h;\n    return max(d, p.y);\n}\n\nfloat torus(vec3 p, float r, float s) {\n\tvec2 q = vec2(length(p.xz) - s, p.y);\n    return length(q) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.z) ? dot(p.xz,sc) : length(p.xz);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nvec2 min2(vec2 a, vec2 b) {\n\treturn a.x < b.x ? a : b;\n}\n\nvec2 lightTube(vec3 p, float r) {\n    p.xz *= rot(pi * 0.2);\n\tp.xz = pmod(p.xz, 5.0);\n    //p.z -= 5.1;\n    float a = pi * 0.1;\n\tfloat s1 = sdCappedTorus(p, vec2(sin(a), cos(a)), 8.05, 0.1);\n    return vec2(s1, MAT_LIGHT);\n}\n\nvec2 cage(vec3 p) {\n    p.y += sin(time) * 0.1;\n    p.xy *= rot(-pi*0.5);\n    p.yz *= rot(time * 0.5);\n    p.yz = pmod(p.yz, 7.0);\n    p.yx = pmod(p.yx, 7.0);\n    \n\treturn vec2(torus(p, 0.025, 0.55), MAT_CAGE);\n}\n\nvec2 object(vec3 p) {\n    vec2 s = vec2(sphere(p - vec3(0.0, cos(time) * 0.1, 0.0), 0.25), MAT_BALL);\n    vec2 c = cage(p);\n\treturn min2(s, c);\n}\n\nfloat energyAnim(float z) {\n\tfloat et = mod(z + time, pi2);\n    float etOffset = pi * 1.5;\n    return (smoothstep(etOffset - 0.2, etOffset, et) - smoothstep(etOffset + 0.2, etOffset + 0.4, et));\n}\n\nvec2 room(vec3 p) {\n    p.y = -abs(p.y);\n    // Floor\n    vec2 tile = fract(p.xz * 8.0) * 2.0 - 1.0;\n    tile = abs(tile) - 0.5;\n    float dd = max(max(tile.x, tile.y), 0.0);\n    \n    float flor = fOpDifferenceStairs(p.y, cylinder(p, 8.0, 4.0), 4.0, 15.);\n    flor = fOpUnionStairs(flor, cylinder(p - vec3(0.0, -4.0, 0.0), 1.0, 1.0), 1.0, 5.);\n    \n    // Pipe\n    p.xz = pmod(p.xz, 5.0);\n    float pipeDent = (smoothstep(0.4, 0.5, fract(p.z*10.0)) - smoothstep(0.5, 0.6, fract(p.z*10.0)));\n\n    float energy = energyAnim(p.z);\n    float pipe = fOpPipe(flor - 0.05, abs(p.x + sin(p.z*2.0) * 0.1), 0.07) + pipeDent * 0.01 - energy * 0.05;\n    \n    // Floor dent along the pipe\n    flor = fOpDifferenceRound(flor + dd * 0.02, pipe, 0.1);\n    \n    return min2(vec2(flor * 0.9, MAT_FLOOR), vec2(pipe * 0.9, MAT_PIPE));\n}\n\nvec2 map(vec3 p) {\n    //p.x += sin(p.x * 5.0) * 0.1;\n\tvec2 o = object(p - vec3(0.0, -2.0, 0.0));\n    vec2 r = room(p);\n    \n    vec2 d = min2(r, o);\n    \n    d = min2(d, lightTube(p - vec3(0.0, -3.85, 0.0), 5.0));\n    p.xz *= rot(time * 2.0);\n    d = min2(d, lightTube(p - vec3(0.0, 0.0, 0.0), 6.0));\n    \n    return d;\n}\n\nvec2 shadowMap(vec3 p) {\n    //p.x += sin(p.x * 5.0) * 0.1;\n\tvec2 o = cage(p - vec3(0.0, -2.0, 0.0));\n    vec2 r = room(p);\n    \n    vec2 d = min2(r, o);\n    \n    return d;\n}\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(1.0, -1.0) * 0.00005;\n    return normalize(\n        e.xyy * map(p+e.xyy).x+\n        e.yxy * map(p+e.yxy).x+\n        e.yyx * map(p+e.yyx).x+\n        e.xxx * map(p+e.xxx).x\n        );\n}\n\nvec3 normal2(vec3 pos)\n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nfloat shadow(vec3 p, vec3 ray, float ma) {\n    float t = 0.1;\n    float res = 1.0;\n    for(int i = 0; i < 24; i++) {\n        if (t > ma) break;\n        vec3 pos = p + ray * t;\n        float d = shadowMap(pos).x;\n        if (d < 0.0001) return 0.0;\n        t += d;\n        res = min(res, 10.0 * d / t);\n    }\n    return res;\n}\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvec3 origin;\n\nfloat roughnessToExponent(float roughness)\n{\n    return clamp(2.0 * (1.0 / (roughness * roughness)) - 2.0, FLT_EPS, 1.0 / FLT_EPS);\n}\n\nvec3 light(vec3 p, vec3 n, vec3 v, vec3 lp, vec3 baseColor, float roughness, float reflectance, float metallic, vec3 radiance) {\n    vec3 ref = mix(vec3(reflectance), baseColor, metallic);\n\n    vec3 l = lp - p;\n    float len = length(l);\n    l /= len;\n    \n    vec3 h = normalize(l + v);\n    \n    vec3 diffuse = mix(1.0 - ref, vec3(0.0), metallic) * baseColor / pi;\n    \n    float m = roughnessToExponent(roughness);\n\tvec3 specular = ref * pow( max( 0.0, dot( n, h ) ), m ) * ( m + 2.0 ) / ( 8.0*pi );\n    return (diffuse + specular) * radiance * max(0.0, dot(l, n)) / (len*len);\n}\n\nvec3 evalLights(vec3 p, vec3 n, vec3 ray, vec3 baseColor, float roughness, float reflectance, float metallic) {\n    // Object Light\n    vec3 lp = vec3(0.0, -2.0 + cos(time) * 0.1, 0.0);\n    vec3 v = lp - p;\n    float len = length(v);\n    v /= len;\n    vec3 result = light(p, n, -ray, lp, baseColor, roughness, reflectance, metallic, vec3(0.6, 0.05, 0.01) * (sin(time) * 0.5 + 0.5) * 20.0) * shadow(p + n * 0.005, v, len);\n    \n    // Camera Light\n    result += light(p, n, -ray, origin, baseColor, roughness, reflectance, metallic, vec3(3.0));\n    return result;\n}\n\nvoid getSurfaceParams(vec3 p, vec2 mat, out vec3 outBaseColor, out vec3 outEmission, out float outRoughness, out float outReflectance, out float outMetallic) {\n    outBaseColor = vec3(0.0);\n    outEmission = vec3(0.0);\n    outRoughness = 1.0;\n    outMetallic = 0.0;\n    outReflectance = 0.04;\n    if (mat.y == MAT_FLOOR) {\n        outBaseColor = vec3(0.5);\n        outRoughness = 0.05;\n    } else if (mat.y == MAT_PIPE) {\n        outBaseColor = vec3(0.9);\n        outRoughness = 0.15;\n        outMetallic = 1.0;\n    \tp.xz = pmod(p.xz, 5.0);\n    \tfloat pipeDent = (smoothstep(0.4, 0.5, fract(p.z*10.0)) - smoothstep(0.5, 0.6, fract(p.z*10.0)));\n    \tfloat energy = energyAnim(p.z);\n        outEmission = mix(vec3(0.6, 0.05, 0.01), vec3(0.01, 0.05, 0.6), clamp(p.z * 0.2, 0.0, 1.0)) * 4.0 * energy * (1.0 - pipeDent);\n    } else if (mat.y == MAT_CAGE) {\n        outBaseColor = vec3(1.000, 0.766, 0.336);\n        outRoughness = 0.15;\n        outMetallic = 1.0;\n    } else if (mat.y == MAT_BALL) {\n        outBaseColor = vec3(0.6);\n        outEmission = vec3(0.6, 0.05, 0.01) * 4.0 * (sin(time) * 0.5 + 0.5);\n        outRoughness = 0.2;\n        outReflectance = 0.0;\n    } else if (mat.y == MAT_LIGHT) {\n        outBaseColor = vec3(0.6);\n        outEmission = vec3(4.0);\n        outRoughness = 0.2;\n        outReflectance = 0.0;\n    }\n}\n\nvoid trace(vec3 p, vec3 ray, float tmax, int ite, out vec3 outPos, out vec2 outMat, out float depth) {\n    float t = 0.1;\n    vec3 result = vec3(0.0), pos;\n    vec2 mat;\n    for(int i = 0; i < ite; i++) {\n        if (t > tmax) break;\n        pos = ray * t + p;\n        mat = map(pos);\n        if (mat.x < 0.0001) break;\n        t += mat.x;\n    }\n    depth = t;\n    outPos = pos;\n    outMat = mat;\n}\n\nvec3 shade(vec3 p, vec3 ray, vec2 mat) {\n    vec3 baseColor, emission;\n    float roughness, metallic, reflectance;\n    \n    getSurfaceParams(p, mat, baseColor, emission, roughness, reflectance, metallic);\n    vec3 n = normal(p);\n    \n    vec3 result = evalLights(p, n, ray, baseColor, roughness, reflectance, metallic) + emission;\n    vec3 f0 = vec3(1.0);\n    for(int i=0; i<1; i++) {\n    \tf0 *= mix(vec3(reflectance), baseColor, metallic);\n        vec3 secondPos;\n        vec2 secondMat;\n        float depth;\n        ray = reflect(ray, n);\n        trace(p + n * 0.001, ray, 100.0, 24, secondPos, secondMat, depth);\n        getSurfaceParams(p, secondMat, baseColor, emission, roughness, reflectance, metallic);\n        n = normal(secondPos);\n        p = secondPos;\n        result += (evalLights(secondPos, n, ray, baseColor, roughness, reflectance, metallic) + emission) * f0;\n    }\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 col = vec3(0.0);\n    int aa = AA;\n    float tt = 0.0;\n    float depth;\n    for(int y=0; y<aa; y++) {\n        vec2 fc;\n        fc.y = fragCoord.y + float(y)/float(aa);\n        for(int x=0; x<aa; x++) {\n            fc.x = fragCoord.x + float(x)/float(aa);\n            p = (fc.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n            time = iTime + tt;\n            origin = vec3(sin(time * 0.1)*1.0 + cos(time * 0.5)*0.5, sin(time * 0.3) * 1.0 + cos(time * 1.0)*0.25 + sin(time * 3.0)*0.1 - 1.0, 5.0);\n            vec3 target = vec3(0.0, -2., 0.);\n            vec3 fo = normalize(target - origin);\n            vec3 si = normalize(cross(vec3(0.0, 1.0, 0.0), fo));\n            vec3 up = normalize(cross(fo, si));\n            vec3 ray = normalize(fo * (2.5 + (sin(time * 0.5)*0.5 + 0.5)*2.0 + (1.0 - dot(p, p)) * 0.05) + si * p.x + up * p.y);\n\n            tt += 0.04 / float(aa*aa);\n            vec3 surfacePos;\n            vec2 surfaceMat;\n            trace(origin, ray, 100.0, 99, surfacePos, surfaceMat, depth);\n            col += acesFilm(shade(surfacePos, ray, surfaceMat) * 2.0);\n        }\n    }\n    col /= float(aa*aa);\n\n    col = pow(col, vec3(1.0/2.2));\n    \n    p = fragCoord.xy / iResolution.xy;\n    p *=  1.0 - p.yx;\n    float vig = p.x*p.y * 30.0;\n    vig = pow(vig, 0.1);\n\n    fragColor = vec4(col * vig,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}