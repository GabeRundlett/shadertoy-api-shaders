{
    "Shader": {
        "info": {
            "date": "1566930961",
            "description": ":)",
            "flags": 32,
            "hasliked": 0,
            "id": "wtBSWy",
            "likes": 2,
            "name": "태극기",
            "published": 3,
            "tags": [
                "2d",
                "flag",
                "korea",
                "southkorea",
                "taegeukgi"
            ],
            "usePreview": 0,
            "username": "dubu",
            "viewed": 222
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 color = texture(iChannel0, uv).rgb;\n    \n    \n    color = vec3(1.9,1.95,2.4)*color/(1.0+color);\n    \n  \tcolor *= 0.2 + 0.8 * saturate(pow(128. * uv.x * uv.y * (1.-uv.x) * (1.-uv.y), 0.2));\n    \n    fragColor = vec4(pow(color, vec3(1./1.8)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265\n#define TAU (2.*PI)\n#define PHI (sqrt(5)*0.5 + 0.5)\n\n#define DOF_STRENGTH (0.1)\n#define DOF_THRESHOLD 0.5\n#define DOF_NUM_ITERATIONS 10.0\n\n// sane functions\nfloat saturate(float x){\n    return clamp(x,0.0,1.0);\n}\nfloat map(float value, float low1, float high1, float low2, float high2){\n\treturn low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\n// Triplanar mapping\nvec3 BlendNormal(vec3 normal){\n\tvec3 blending = abs(normal);\n\tblending = normalize(max(blending, 0.00001));\n\tblending /= vec3(blending.x + blending.y + blending.z);\n\treturn blending;\n}\nvec3 TriplanarMapping (sampler2D tex, vec3 normal, vec3 position) {\n\tvec3 normalBlend = BlendNormal(normal);\n\tvec3 xColor = texture(tex, position.yz).rgb;\n\tvec3 yColor = texture(tex, position.xz).rgb;\n\tvec3 zColor = texture(tex, position.xy).rgb;\n\n  \treturn (xColor * normalBlend.x + yColor * normalBlend.y + zColor * normalBlend.z);\n}\n\n// Smooth noise\n\nconst mat2 smm2 = mat2(1.6,-1.2,1.2,1.6);\nfloat Noise( in vec2 p )\n{\n    return 0.5*(cos(6.2831*p.x) + cos(6.2831*p.y));\n}\nfloat SmoothNoise( vec2 p )\n{\n    p *= 0.0013;\n\n    float s = 1.0;\n\tfloat t = 0.0;\n\tfor( int i=0; i<2; i++ )\n\t{\n        t += s*Noise( p );\n\t\ts *= 0.5 + 0.1*t;\n        p = 0.97*smm2*p + (t-0.5)*0.2;\n\t}\n\treturn t;\n}\n\n// SDF\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec4 v) {\n\treturn min(min(v.x, v.y), min(v.z, v.w));\n}\n\n#if 1\nfloat fBoxCheap(vec3 p, vec3 b) {\n\treturn vmax(abs(p) - b);\n}\n#else\nfloat fBoxCheap(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n#endif\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvoid pTwist(inout vec2 p, float a){\n    float c = cos(a);\n    float s = sin(a);\n    p = mat2(c,-s,s,c)*p;\n}\n\nstruct Hit{\n \tfloat d;\n    int ID;\n} _Hit;\n\nHit OpUnionHit(Hit a, Hit b){\n    if(a.d < b.d)return a;\n    return b;\n}\n\n\n// PBR\n#define PBR_EPSILON 1e-4\n\nstruct Material{\n    vec3 albedo;\n    vec3 metallic;\n    float roughness;\n} _Material;\n    \nstruct GeometricContext{\n    vec3 position;\n    vec3 normal;\n    vec3 viewDir;\n} _GeometricContext;\n\nstruct IncidentLight{\n\tvec3 direction;\n    vec3 color;\n    bool visible;\n} _IncidentLight;\n\nstruct PointLight{\n    vec3 position;\n    vec3 color;\n    float visibleDistance;\n    float decay;\n} _PointLight;\n\nstruct ReflectedLight{\n    vec3 directDiffuse;\n    vec3 directSpecular;\n    vec3 indirectDiffuse;\n    vec3 indirectSpecular;\n} _ReflectedLight;\n\n\nbool TestLightInRange(const in float lightDistance, const in float cutoffDistance){\n    return any(bvec2(cutoffDistance == 0.0, lightDistance < cutoffDistance));\n}\nfloat punctualLightIntensityToIrradianceFactor(const in float lightDistance,\n                                               const in float cutoffDistance,\n                                               const in float decayExponent){\n    if(decayExponent > 0.0){\n     \treturn pow(saturate(-lightDistance / cutoffDistance + 1.0), decayExponent);   \n    }\n    \n    return 1.0;\n}\nvoid GetPointDirectLightIrradiance( const in PointLight pointLight,\n                                    const in vec3 geometryPosition,\n                                    out IncidentLight directLight){\n    vec3 L = pointLight.position - geometryPosition;\n    directLight.direction = normalize(L);\n    \n    float lightDistance = length(L);\n    if(TestLightInRange(lightDistance, pointLight.visibleDistance)){\n        directLight.color = pointLight.color;\n        directLight.color *= punctualLightIntensityToIrradianceFactor(lightDistance, pointLight.visibleDistance, pointLight.decay);\n        directLight.visible = true;\n    }else{\n        directLight.color = vec3(0.0);\n        directLight.visible = false;\n    }\n}\n\nvec3 DiffuseColor(vec3 albedo, vec3 metallic){\n    return mix(albedo, vec3(0.0), metallic);\n}\nvec3 SpecularColor(vec3 albedo, vec3 metallic){\n    return mix(vec3(0.04), albedo, metallic);\n}\nvec3 DiffuseBRDF(vec3 diffuseColor){\n    return diffuseColor / PI;\n}\n\nvec3 F_Schlick(vec3 specularColor, vec3 V, vec3 H){\n    return (specularColor + (1.0 - specularColor) * pow(1.0 - saturate(dot(V,H)), 5.0));\n}\nfloat D_GGX(float a, float dotNH){\n \tfloat a2 = a*a;\n    float dotNH2 = dotNH*dotNH;\n    float d = dotNH2 * (a2 - 1.0) + 1.0;\n    return a2 / (PI*d*d);\n}\nfloat G_SmithSchlickGGX(float a, float dotNV, float dotNL){\n    float k = a*a*0.5 + PBR_EPSILON;\n    float gl = dotNL / (dotNL * (1.0 - k) + k);\n    float gv = dotNV / (dotNV * (1.0 - k) + k);\n    return gl*gv;\n}\n\nvec3 SpecularBRDF(const in IncidentLight directLight,\n                  const in GeometricContext geometry,\n                  vec3 specularColor,\n                  float roughnessFactor){\n    vec3 N = geometry.normal;\n    vec3 V = geometry.viewDir;\n    vec3 L = directLight.direction;\n    \n    float dotNL = saturate(dot(N, L));\n    float dotNV = saturate(dot(N, V));\n    vec3 H = normalize(L+V);\n    float dotNH = saturate(dot(N, H));\n    float dotVH = saturate(dot(V, H));\n    float dotLV = saturate(dot(L, V));\n    float a = roughnessFactor * roughnessFactor;\n    \n    vec3 F = F_Schlick(specularColor, V, H);\n    float D = D_GGX(a, dotNH);\n    float G = G_SmithSchlickGGX(a, dotNV, dotNL);\n    \n    return (F*(G*D)) / (4.0 * dotNL * dotNV + PBR_EPSILON);\n}\n\nvoid RE_Direct(const in IncidentLight directLight,\n               const in GeometricContext geometry,\n               const in Material material,\n               inout ReflectedLight reflectedLight){\n\tfloat dotNL = saturate(dot(geometry.normal, directLight.direction));\n    vec3 irradiance = dotNL * directLight.color;\n    \n    irradiance *= PI;\n    \n    vec3 diffuse = DiffuseColor(material.albedo, material.metallic);\n    vec3 specular = SpecularColor(material.albedo, material.metallic);\n    \n    reflectedLight.directDiffuse += irradiance * DiffuseBRDF(diffuse);\n    \n    float roughness = map(material.roughness, 0., 1., 0.025, 1.);\n    reflectedLight.directSpecular += irradiance * SpecularBRDF(directLight, geometry, specular, roughness);\n}\n\n\n// PBR Utils\nfloat GetMipFromRoughness(float roughness){\n\tfloat level = 3.0 - 1.15 * log2( roughness );\n\treturn max(10.0 - 1.0 - level, 0.0);\n}\n\n\n\n\n// Flag stuff\n#define SMOOTHNESS (0.002 / (myResolution.y/1080.))\nvec2 myResolution;\n\nconst vec3 BLACK\t= (vec3(0.)/255.0);\nconst vec3 WHITE\t= (vec3(255.)/255.0);\nconst vec3 RED\t\t= (vec3(205., 46., 58.)/255.0);\nconst vec3 BLUE\t\t= (vec3(0., 71., 160.)/255.0);\n\nconst vec2 NW\t\t= normalize(vec2(-3.0, 2.0));\n\nfloat cross2(vec2 u, vec2 v){\n    return smoothstep(SMOOTHNESS, -SMOOTHNESS, u.x*v.y-u.y*v.x);\n}\n\nfloat dCircle(vec2 p, float r){\n    return smoothstep(SMOOTHNESS, -SMOOTHNESS, length(p) - r*0.5);\n}\nfloat dBox(vec2 p, vec2 s){\n    return smoothstep(SMOOTHNESS, -SMOOTHNESS, max(abs(p.x)-s.x*0.5, abs(p.y)-s.y*0.5));\n}\nfloat dStripe(vec2 p, float i, float a, float g){\n    float c = cos(a);\n    float s = sin(a);\n    mat2 m2 = mat2(c, -s, s, c);\n    vec2 q = p * m2;\n    \n    q.y -= 0.75+1./24.;\n    q.y -= (3./24.)*i;\n    \n    return dBox(q, vec2(1./2., 1./12.)) - dBox(q, vec2(1./24., 1./12.)) * g;\n}\n\nvec3 taegeukgi(vec2 p){\n    vec3 col = WHITE;\n    \n    col = mix(col, mix(BLUE, RED, vec3(cross2(NW, p))), dCircle(p, 1.0));\n    \n    col = mix(col, RED, dCircle(p-NW*0.25, 0.5));\n    col = mix(col, BLUE, dCircle(p+NW*0.25, 0.5));\n    \n    col = mix(col, BLACK, dStripe(p, 0., atan(NW.x, NW.y), 0.));\n    col = mix(col, BLACK, dStripe(p, 1., atan(NW.x, NW.y), 0.));\n    col = mix(col, BLACK, dStripe(p, 2., atan(NW.x, NW.y), 0.));\n    \n    col = mix(col, BLACK, dStripe(p, 0., atan(NW.x, -NW.y), 0.));\n    col = mix(col, BLACK, dStripe(p, 1., atan(NW.x, -NW.y), 1.));\n    col = mix(col, BLACK, dStripe(p, 2., atan(NW.x, -NW.y), 0.));\n    \n    col = mix(col, BLACK, dStripe(p, 0., atan(-NW.x, NW.y), 1.));\n    col = mix(col, BLACK, dStripe(p, 1., atan(-NW.x, NW.y), 0.));\n    col = mix(col, BLACK, dStripe(p, 2., atan(-NW.x, NW.y), 1.));\n    \n    col = mix(col, BLACK, dStripe(p, 0., atan(-NW.x, -NW.y), 1.));\n    col = mix(col, BLACK, dStripe(p, 1., atan(-NW.x, -NW.y), 1.));\n    col = mix(col, BLACK, dStripe(p, 2., atan(-NW.x, -NW.y), 1.));\n    \n    return col;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define FOV 0.4\n#define NUM_BOUNCES 15\n\n#define SKY_COLOR vec3(170., 220., 255.)/255.\n\n#define MAX_STEPS\t\t\t512\n#define SURFACE_DIST\t\t1e-4\n#define MAX_DIST\t\t\t100.0\n#define NUM_AO_STEPS\t\t8.\n#define NUM_SHADOW_STEPS\t4\n\n#define MAT_FLAG 0\n#define MAT_POLE 1\n\nconst int NUM_LIGHTS = 3;\nPointLight pointLights[NUM_LIGHTS];\n\nvec3 SampleCubemap(vec3 rd, in float mip){\n    pR(rd.xz, 0.5);\n    return texture(iChannel0, rd, mip).xyz * vec3(0.3, 0.45, 0.55);\n}\n\nMaterial GetMaterial(in vec3 p, inout vec3 n, in Hit hit){\n    Material mat;\n    \n    if(hit.ID == MAT_FLAG){\n        mat.albedo = taegeukgi(p.xy);\n        mat.roughness = 1.0;\n        mat.metallic = vec3(0.0);\n    }else if(hit.ID == MAT_POLE){\n        mat.albedo = vec3(0.9);\n        mat.roughness = 0.3;\n        mat.metallic = vec3(1.0);\n    }\n    \n    return mat;\n}\n\nHit Flag(vec3 p){\n    float t = mod(iTime, PI);\n    \n    p.z += sin(p.x*5.-t*10.+p.y*Noise(vec2(p.x+p.y-13.7)))*0.1*(p.x+1.0)*(0.7+0.5*Noise(vec2(iTime*0.1)));\n    \n    float d = fBoxCheap(p, vec3(1.5, 1.0, 0.01));\n    d *= 0.3;\n    \n    return Hit(d, MAT_FLAG);\n}\nHit Pole(vec3 p){\n    float d = fCylinder(p+vec3(1.5, 2.0, 0.0), 0.1, 3.1);\n    \n    return Hit(d, MAT_POLE);\n}\nHit FlagPole(vec3 p){\n    Hit flag = Flag(p);\n    Hit pole = Pole(p);\n    \n    return OpUnionHit(flag, pole);\n}\nHit GetDist(vec3 p){\n    Hit flagpole = FlagPole(p);\n    \n    return flagpole;\n}\n\n\nvec3 GetNormal(vec3 pos){\n \tvec2 e = vec2(1.0,-1.0)*0.00001;\n    return normalize( e.xyy*GetDist( pos + e.xyy ).d + \n\t\t\t\t\t  e.yyx*GetDist( pos + e.yyx ).d + \n\t\t\t\t\t  e.yxy*GetDist( pos + e.yxy ).d + \n\t\t\t\t\t  e.xxx*GetDist( pos + e.xxx ).d );\n}\nfloat CalcAO(vec3 ro, vec3 rd){\n    float k = 1.0;\n    float occ = 0.0;\n    for(float i = 0.0; i < NUM_AO_STEPS; ++i){\n        float len = 0.15 * i + 0.125;\n        float dist = GetDist(rd * len + ro).d;\n        occ += k * (len - dist);\n        k *= 0.5;\n    }\n    return saturate(1.0-occ);\n}\nfloat CalcShadow(in vec3 ro, in vec3 rd, in float maxT){\n    float res = 1.0;\n    float t = 0.01;\n    float ph = 1e10;\n    \n    for(int i = 0; i < NUM_SHADOW_STEPS; ++i){\n        float h = GetDist(rd * t + ro).d;\n        \n        if(h < SURFACE_DIST)return 0.;\n        \n        float y = h*h/(2.*ph);\n        float d = sqrt(h*h-y*y);\n        res = min(res, 5.*d/max(0.,t-y));\n        ph = h;\n        \n        t += h*0.95;\n        \n        if(res < SURFACE_DIST || t >= maxT) break;\n    }\n    \n    return saturate(res);\n}\nHit RayMarch(vec3 ro, vec3 rd, int bounce){\n\tfloat dO = 0.;\n    Hit hit;\n    \n    int steps = MAX_STEPS;\n    \n    if(bounce > 0){\n        steps /= bounce*4;\n    }\n    \n    for(int i = 0; i < steps; i++){\n        vec3 p = dO*rd+ro;\n        hit = GetDist(p);\n        dO += hit.d;\n        if(hit.d < SURFACE_DIST || dO > MAX_DIST){\n            break;\n        }\n    }\n    return Hit(dO, hit.ID);\n}\nvec4 GetColor(vec3 ro, vec3 rd){\n    int bounce = 0;\n    float depth = 0.;\n    \n    vec3 res = vec3(0.0);\n    \n    vec3 carry = vec3(1.0);\n    float lastRoughness = 0.0;\n    \n    for(int bounce = 0; bounce <= NUM_BOUNCES; ++bounce){\n        Hit hit = RayMarch(ro, rd, bounce);\n        if(bounce == 0)depth = hit.d;\n\n        if(hit.d >= MAX_DIST){\n            float mip = GetMipFromRoughness(lastRoughness);\n            res += SampleCubemap(rd, mip+3.0) * carry;\n            break;\n        }\n\n        vec3 p = rd * hit.d + ro;\n        vec3 n = GetNormal(p);\n        vec3 v = normalize(ro-p);\n        \n        GeometricContext geometry;\n        geometry.position = p;\n        geometry.normal = n;\n        geometry.viewDir = v;\n\n        Material material = GetMaterial(p, n, hit);\n        \n        \n        ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n        IncidentLight directLight;\n        \n        vec3 s = vec3(0.0);\n        for(int lightIndex = 0; lightIndex < NUM_LIGHTS; ++lightIndex){\n            GetPointDirectLightIrradiance(pointLights[lightIndex], geometry.position, directLight);\n            \n            if(directLight.visible){\n                vec3 L = pointLights[lightIndex].position - geometry.position;\n            \tfloat shadow = CalcShadow(p, normalize(L), length(L));\n            \n                directLight.color *= shadow;\n                \n                RE_Direct(directLight, geometry, material, reflectedLight);\n            }\n        }\n        \n        vec3 specular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n        vec3 diffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n        \n        vec3 col = vec3(0.0);\n        col += specular;\n        col += diffuse;\n        \n        col += vec3(0.02) * material.albedo;\n        \n        float ao = CalcAO(p, n);\n        col *= ao*ao;\n        \n        res += col * carry;\n        \n        carry = material.albedo * carry * (1.0 - material.roughness);\n        lastRoughness = material.roughness;\n\n        // bounce ray\n        rd = rd - 2.0*dot(rd, n)*n;\n        ro = p + rd*0.01;\n    }\n    \n    return vec4(res, depth);\n}\n\nvoid InitLights(){\n    pointLights[0].color = vec3(1.0, 1.0, 0.8)*1.;\n    pointLights[0].position = vec3(5.0, 5., 3.);\n    pointLights[0].visibleDistance = 100.0;\n    pointLights[0].decay = 1.0;\n    \n    pointLights[1].color = vec3(1.0, 1.0, 0.7 );\n    pointLights[1].position = vec3(5., 5.5, 0.);\n    pointLights[1].visibleDistance = 10.0;\n    pointLights[1].decay = 1.0;\n    \n    pointLights[2].color = vec3(1.0, 0.7, 0.9 );\n    pointLights[2].position = vec3(-2., 1.5, -2.);\n    pointLights[2].visibleDistance = 10.0;\n    pointLights[2].decay = 1.0;\n}\n\nvec4 CalcImage(in vec2 fragCoord){\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    myResolution = iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    \n    vec3 lookAt = vec3(0.0, 0., 0.);\n    vec3 cameraPosition = vec3(cos(iTime*0.3)*6., sin(iTime*1.2)+1.0, sin(iTime*0.3)*6.);\n    \n    vec3 forward = normalize(lookAt-cameraPosition);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x ));\n    vec3 up = normalize(cross(forward,right));\n\n    vec3 ro = cameraPosition; \n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    vec4 tot = GetColor(ro, rd);\n    \n    vec3 color = tot.rgb;\n    float depth = tot.a;\n    \n    \n    return vec4(color,depth);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    InitLights();\n    \n    vec4 color = CalcImage(fragCoord);\n    \n    fragColor = color;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}