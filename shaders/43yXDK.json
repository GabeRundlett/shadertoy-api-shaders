{
    "Shader": {
        "info": {
            "date": "1720512704",
            "description": "A different approach to the chaos game algorithm (executing it in reverse without a PRNG / stochastic process, making it suitable for GPU computation).",
            "flags": 0,
            "hasliked": 0,
            "id": "43yXDK",
            "likes": 6,
            "name": "Reverse Chaos Game (Basics)",
            "published": 3,
            "tags": [
                "chaosgame"
            ],
            "usePreview": 0,
            "username": "sanblu",
            "viewed": 105
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2024 Sandro Blum\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Note: This is the shader for showing the basic algorithm. \n// For a visually more pleasing demonstration see: https://www.shadertoy.com/view/MXKSDy\n\n/*\n --- REVERSE CHAOS GAME ---\n \n -- Background --\n \n Initially I just wanted to implement the classic chaos game (https://en.wikipedia.org/wiki/Chaos_game),\n but doing so with a decent quality and efficiently on a GPU turned out infeasible.\n (It's a stochastic process that involves creating a height-map requiring atomic adds.)\n Before giving up I had one more thought: Shouldn't it be possible to just start with a specific pixel and then play the chaos game backwards?\n That basically just means: Take the current point and a vertex and just double the distance to get a new point.)\n I was expecting that I would then have to do some sort of \"probabilistic backtracking\" (similar to the chaos game), but things turned out much simpler:\n In order to stay within the main polygon as long as possible, you always have have to pick the vertex that is closest to the current point. Nice, no PRNG needed!\n \n The resulting images (sierpinski triangle etc.) looked identical to those of the chaos game.\n Also playing with the \"cut factor\" (0.5/2.0 by default) worked the same way and with identical results just as in the classic chaos game approach.\n The last missing piece were the chaos game \"restriction rules\": At first, when I added them they just seemed to work out of the box.\n But then I noticed that depending on the cut factor some of the rules would lead to an image that looks \"truncated\".\n I have not yet figured out how to resolve that, if you have a hint/idea, please let me know.\n \n -- Algorithm --\n \n See reverseChaosGame(..) function below with comments.\n \n -- Restriction Rules --\n \n As mentioned above, the algorithm seems to give aesthetic results only for a subset of restriction rules (I have hard-coded those in the arrays below).\n To see an example of a rule that does not work -> uncomment line 69.\n \n -- Visualization --\n \n There are endless ways to visualize the algorithm's results, polygon distance as used here is just one example.\n See a number of examples here: https://www.shadertoy.com/view/MXKSDy\n \n -- Help! :) --\n \n If you happen to have some knowledge related to the chaos game / fractals / IFS, I'm very thankful for any comments that give me some context:\n Is the approach I'm taking here a common approach? Is there a specific name (other than \"chaos game\") for that approach?\n I'm pretty sure it's not something new I'm doing here, but I'm also wondering why I have not seen this approach being described before, especially when searching for ways to execute the chaos game on a GPU in parallel.\n \n*/\n\n\n#define PI 3.14159265359\n#define FLT_MAX 3.402823466e+38\n#define CENTER vec2(0.5, 0.5)\n#define MAX_N 6\n\n#define ITERATIONS 7\n\n// triangle\n//#define N 3\n//#define CUT_FACTOR 0.5\n//#define RULE AESTHETIC_RULES_N3[int(iTime / PI) % 2]\n\n// square\n//#define N 4\n//#define CUT_FACTOR 0.56\n//#define RULE AESTHETIC_RULES_N4[int(iTime / PI) % 5]\n\n\n// pentagon\n#define N 5\n#define CUT_FACTOR 0.618\n#define RULE AESTHETIC_RULES_N5[int(iTime / PI) % 6]\n\n// hexagon\n//#define N 6\n//#define CUT_FACTOR 0.667\n//#define RULE AESTHETIC_RULES_N6[int(iTime / PI) % 13]\n\n\n// for some background on chaos game rules see e.g. https://community.wolfram.com/groups/-/m/t/1025180\nconst int AESTHETIC_RULES_N3[2] = int[2](6, 7);\nconst int AESTHETIC_RULES_N4[5] = int[5](5, 10, 11, 14, 15);\nconst int AESTHETIC_RULES_N5[6] = int[6](12, 13, 18, 19, 30, 31);\n//const int AESTHETIC_RULES_N5[6] = int[6](2, 2, 2, 2, 2, 2); // example of a rule that looks \"truncated\"\nconst int AESTHETIC_RULES_N6[13] = int[13](9, 20, 21, 28, 29, 34, 35, 42, 43, 54, 55, 62, 63);\n\n// https://iquilezles.org/articles/distfunctions2d/\n// https://www.shadertoy.com/view/wdBXRW\nfloat sdPolygon( in vec2[MAX_N] v, in vec2 p, in int n )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i = 0, j = n - 1; i < n; j = i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w = p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\nvec2[MAX_N] polygonVertices(in int n) {\n    vec2[MAX_N] vertices;\n    float angleIncrement = 2.0 * PI / float(n);\n    for (int i = 0; i < n; i++) {\n        float angle = 0.5 * PI + angleIncrement * float(i);\n        vertices[i] = vec2(0.5 + 0.5 * cos(angle), 0.5 + 0.5 * sin(angle));\n    }\n    return vertices;\n}\n\nbool getBit(in int value, in int bitPosition) {\n    return (value & (1 << bitPosition)) != 0;\n}\n\nbool checkRule(in int prevVertex, in int newVertex, in int n, in int rule) {\n    if (prevVertex < 0 || rule < 0) {\n        return true;\n    }\n    int vertexModuloOffset = (prevVertex - newVertex + n) % n;\n    return getBit(rule, vertexModuloOffset);\n}\n\n// main algorithm: it's very similar to the \"chaos game\" but in reverse (and not stochastic and thus easy to calculate)\n// - step 1) initially, we define a polygon with N vertices\n// - step 2) for each pixel we start with an initial point P (= the pixel coordinates)\n// - step 3) determine the vertex V of the polygon that is closest to P\n//           optional: exclude certain vertices based on a predefined rule (e.g. exclude the vertex that was chosen in the previous iteration)\n// - step 4) double the distance between P and V (in the direction of V) -> this leads to a new point P\n// - repeat 3) 4) for a predefined number of iterations\n// - step 5) assign brightness value to the pixel with which we started, based on the processed iterations and/or the resulting final point P\n//           (the possibilities are almost endless, examples: a) length of final P b) minimum distance across all iterations c) distance of final P to polygon ...)\nfloat reverseChaosGame(in vec2 uv, in int n, in float cutFactor, in int iterations, in int rule) {\n\n    int prevVertexIndex = -1;\n    \n    // step 1\n    vec2[MAX_N] vertices = polygonVertices(n);\n    \n    float reverseCutFactor = 1.0 / (1.0 - cutFactor);\n    float value = FLT_MAX;\n    \n    // step 2\n    vec2 p = uv;\n\n    for (int i = 0; i < iterations; i++) {\n        float minDist = FLT_MAX;\n        int closestVertexIndex = -1;\n        // step 3\n        for (int j = 0; j < n; j++) {\n            if (!checkRule(prevVertexIndex, j, n, rule)) {\n                continue;\n            }\n\n            float dist = distance(p, vertices[j]);\n            if (dist < minDist) {\n                minDist = dist;\n                closestVertexIndex = j;                \n            }\n        }        \n        vec2 closestVertex = vertices[closestVertexIndex];\n        // step 4\n        p = closestVertex + reverseCutFactor * (p - closestVertex);\n        prevVertexIndex = closestVertexIndex;\n        \n        // step 5\n        value = min(value, abs(sdPolygon(vertices, p, n)));        \n    }\n    \n    return pow(value, 0.25);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // center coordinates and correct aspect ratio\n    float aspectRatio = iResolution.x/iResolution.y;\n    uv.x = uv.x * aspectRatio - (aspectRatio - 1.0) * 0.5;\n    \n    float cutFactor = (CUT_FACTOR - 0.075 + sin(PI * 0.5 + iTime * 0.5) * 0.075);\n    \n    float value = reverseChaosGame(uv, N, cutFactor, ITERATIONS, RULE);   \n    fragColor = vec4(vec3(value), 1.0);            \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}