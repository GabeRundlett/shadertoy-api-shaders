{
    "Shader": {
        "info": {
            "date": "1558675711",
            "description": "I don't know why, but the voronoi distance function seems to be wrong, judging by the weird artifacts. I thought the voronoi distance function should be analytically correct: projection of displacement from midpoint along edge between two closest centers.",
            "flags": 0,
            "hasliked": 0,
            "id": "Wt23z1",
            "likes": 2,
            "name": "3D voronoi test [bug]",
            "published": 3,
            "tags": [
                "3d",
                "voronoi",
                "test",
                "bug"
            ],
            "usePreview": 0,
            "username": "ShnitzelKiller",
            "viewed": 617
        },
        "renderpass": [
            {
                "code": "//Rendering sparse boxes with voronoi cells inside. But the voronoi cells are buggy, help\n\n#define FDIST 0.5\n#define EPS 0.001\n#define THICKNESS 0.01\n#define ITERS 30\n#define TOL 0.01\n\nstruct Record {\n    float t;\n    int material;\n    vec3 n;\n};\n\nvec3 hash3D(in vec3 uv) {\n    mat3 m = mat3(2114.2,1241.6,-9818.559,-33.8, -188.8, 1488.1, 8910.2, -55.4, 1881.2);\n    return fract(m*sin(m*uv));\n}\n\n//distance to the next grid cell\nfloat traceBox(in vec3 ro, in vec3 rd) {\n    vec3 fo = fract(ro);\n    vec3 io = floor(ro);\n    vec3 q = -(fo-.5)/rd+abs(0.5/rd);\n    return min(q.x, min(q.y, q.z));\n}\n\n//returns:\n//x: distance to voronoi border\n//yzw: normal\nvec4 voronoi(in vec3 ro) {\n    \n    vec3 fo = fract(ro);\n    vec3 io = floor(ro);\n    vec3 offset = hash3D(io);\n    \n    vec3 vp1, vp2;\n    vec2 d = vec2(99.);\n    \n    for (int i=-1; i<=1; i++) {\n        for (int j=-1; j<=1; j++) {\n            for (int k=-1; k<=1; k++) {\n                vec3 disp = vec3(i,j,k);\n                vec3 center = disp+hash3D(io+disp);\n                vec3 r = fo - center;\n                float lr = length(r);\n                if (lr < d.x) {\n                    d.y = d.x;\n                    vp2 = vp1;\n                    d.x = lr;\n                    vp1 = center;\n                } else if (lr < d.y) {\n                    d.y = lr;\n                    vp2 = center;\n                }\n            }\n        }\n    }\n    vec3 e = vp2-vp1; //edge between two closest centers\n    vec3 p = fo - 0.5*(vp1+vp2); //displacement of current point from edge midpoint\n    vec3 orth = dot(e,p)/dot(e,e)*e; //projection of above displacement along edge\n    float lorth = length(orth); //distance from voronoi border?\n    return vec4(lorth-THICKNESS, orth/lorth);\n}\n\nRecord raymarch(in vec3 ro, in vec3 rd) {\n    Record outRecord;\n    outRecord.t = 0.;\n    for (int i=0; i<ITERS; i++) {\n        vec3 currpos = ro+rd*outRecord.t;\n        vec3 ipos = floor(currpos);\n        float maxt = traceBox(currpos, rd);\n        float dist = 1000.;\n        \n        if (hash3D(ipos).x > 0.95) {\n            //render voronoi here\n            vec4 res = voronoi(ro+outRecord.t*rd);\n            outRecord.n = res.yzw;\n            dist = res.x;\n            if (dist < 0. && outRecord.material == 0) {\n                //end if we entered a new grid cell inside a voronoi wall\n                outRecord.t -= EPS;\n                outRecord.material = 1;\n                outRecord.n = -rd;\n                return outRecord;\n            }\n        }\n        if (dist < maxt) {\n            //raymarch within this grid cell\n            outRecord.t += dist;\n            outRecord.material = 1;\n            if (dist < TOL) {\n                return outRecord;\n            }\n        } else {\n            //jump to next grid cell\n            outRecord.t += maxt+EPS;\n            outRecord.material = 0;\n        }\n    }\n    outRecord.material = 0;\n    return outRecord;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ro = vec3(1., 1., 1.)*(iTime+1.);\n    vec3 up = vec3(0., 1., 0.);\n    vec3 w = normalize(-ro);\n    vec3 u = cross(w, up);\n    vec3 v = cross(u, w);\n    vec2 coord = vec2(((fragCoord.x/iResolution.x)-0.5)/iResolution.y*iResolution.x,fragCoord.y/iResolution.y-0.5);\n    vec3 rd = normalize(w*FDIST+u*coord.x+v*coord.y);\n    Record record = raymarch(ro, rd);\n    vec3 col;\n    if (record.material == 0) {\n    \tcol = vec3(0.);\n    } else {\n        col = record.n*.5+.5;\n    }\n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}