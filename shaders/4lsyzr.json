{
    "Shader": {
        "info": {
            "date": "1503195135",
            "description": "mouse.xy sets upper and lower radii (blue and red), \nThe larger radius will always be red.\nA r3d/largest radius rounds the middle part (green), oscillating between \"circle\" and \"nearly flat\"\n\nShape input is overly constrained for now",
            "flags": 0,
            "hasliked": 0,
            "id": "4lsyzr",
            "likes": 5,
            "name": "Moss MossesEgg",
            "published": 3,
            "tags": [
                "heart",
                "egg",
                "egg",
                "ear",
                "superprim",
                "earvagegg",
                "tangentcapsule",
                "mosss"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 934
        },
        "renderpass": [
            {
                "code": "/*\nsketch showing underlying trigonometry:\nhttp://imgur.com/a/WjcwM\n\nThis is a dirty first draft, inefficient and with no clear context, \nbecause i got too tired of this for today to optimize oand clean it contextually.\nIt lacks user friendly oconstrains, like, flickering if m.y is too high or too low\nbecause i have not decided on ui constrains beyond basic functionality:\n\nmouse.xy sets upper and lower radii (blue and red), \nthe larger radius will alway be red.\na r3d/largest radius rounds the middle part (green)\nits radius is set by \n*/\n#define  rac mix(.5,3.,sin(iTime)*.5+.5)\n//.5== circle;  5.= pretty straight red segment;  +inf=straight red segment.\n/*\nthe 3rd/larger circle contains the 2 smaller circles and touches them at 1 point.\nThis results in a very precise egg-shaped distance field:\n\nA rounder \"tangential capsule\" has the middle part not as straight line, \nbut a 3rd large circle with a radius \nthat contains the other 2 circles and touches them once.\n\nif (3rd circle has infinite radius) this would be [tangentCapsule superprim].\n\nthe whole shapes implicit curve is constrained to 0<=y<=1 due to the input setup.\n\n*/\n\n\n\n/*\ntiny framework 2017-08\nI use \"bisymmetry\" as shorthand for \"gradient from symmetry to assymmetry\"\n*/\n\n/* end__.Head\n   start.Parameters\n*/\n\n//apply:  c=abs(c)-.05; making the distance field an outline of itself.\n#define toisoline\n\n\n//zoom of view Frame\n#define ViewZoom 1.5\n\n\n/* end__.Parameters\n   start.Static\n*/\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define fra(u) (u-.5*iResolution.xy)*ViewZoom/iResolution.y\nv0 mav(v1 a){return max(a.y,a.x);}\nv0 mav(v2 a){return max(a.z,mav(a.xy));}\nv0 mav(v3 a){return max(mav(a.zw),mav(a.xy));}\n#define miv(a) -maxv(-a)\n#define dd(a) dot(a,a)\n//making a triangle wave;\n#define fr(a) fract(a)\n#define ss2t(a) a=abs(a*2.-1.)\n#define grid(u) mav(abs(fr(u)*2.-1.))\n//#define mStretch(c,m) v=mix(v-m,mix(0.,v,step(v,0.)),step(v,m));\n//stretch      ; centric, most commonly used, therefore atomic\n#define mStretch(u,m) .5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretch nimus; positive values do not change\n#define mStretchM(u,m) mStretch((u*2.+m),m)*.5\n//vec2  mStretchM(vec2  u,vec2  m){m*=.5;u= u+m;return  mStretch(u,m);}\n//stretch plus ; negative values do not change\n#define mStretchP(u,m) mStretch((u*2.-m),m)*.5\n//based on #define analstretching(u,m) mix(u-m,mix(vec2(0.),u,step(u,vec2(0.))),step(u,m))\n//above is special case that can include the sat() generalization below +u.x;\n\n//these branchless comparators compare [c] with [0.0] to return [a]==true or [b]==false;\n//based on \n//  https://www.reddit.com/r/askmath/comments/6aag2g/simplifying_stepa00step00a/\n//(c> 0)?a:b\n#define greater(a,b,c)   mix(a,b,step(c,0.))\n//(c< 0)?a:b\n#define less(a,b,c)      mix(a,b,step(0.,c))\n//(c==0)?a:b\n#define equals(a,b,c)    mix(b,a,step(c,0.)+step(0.,c)-1.)\n//----------- mirror symmetry mirror == swap outputs--------------------\n//(c!=0)?a:b\n#define unequal(a,b,c)   mix(a,b,step(c,0.)+step(0.,c)-1.)\n//(a>=0)?a:b   \"unless   \"=not less   ==greater OR equal\n#define unless(a,b,c)    mix(b,a,step(0.,c))\n//(c<=0)?a:b   \"ungreater\"=not greater==less    OR equal\n#define ungreater(a,b,c) mix(b,a,step(c,0.))\n\n/* end__.Static\n   start.Implicit\n*/\n//a generalization of clamp(a,0.,1.); for m=vec2(1)\nv0 sat(v0 a,v1 m){    \n a=.5*(sign(a)+m.x)*a+m.y;\n a=(sign(2.-a)+1.)*(a-2.)+2.; \n return a*.5;}\nv0 sat(v0 a){return sat(a,v1(1));}//return clamp(a,0.,1.); \n\n\n//fast good monochrome distance field visualization.\n//blue is grid, red and green are distance fields\nv2 rg(v2 c,v1 u){v0 fsaa=1./min(iResolution.x,iResolution.y);\n return vec3(c.rg=mix(fract(c.rg*4.),smoothstep(fsaa,-fsaa,c.rg),\n  .5+(atan(c.rg))/acos(-1.)),grid(u));}\n\n//return circle-circle-intersection.x; r.x=circle.left.radius;r.y=circle.right.radius;r.z=circles-centers.distance\nfloat cci(vec3 r){float d=r.z*2.;r*=r;return(r.x-r.y+r.z)/d;}\n//does not check for non-intersecticn cases! intersection.y is not important here.   \n \n\n//rectangle from v1(0) to v1(m)\nv0 rect(v1 u,v3 m){return mav(abs(u*2.-m.xy)-m.xy)*.5;}\n//for a \"class\" of ring/arc shapes.\nv1 arc(v1 u,v3 m){return v1(m.x-abs(m.y),dd(u));}\n\n//return signed distance of u to line trough m.xy and m.zw\nfloat sd2l(vec2 u, vec4 m){\n //vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n //c.g=min(length(u-d),length(u-e))-.1;//draw 2 points\n vec2 f=m.zw-m.xy;f=vec2(-f.y,f.x);//calculate dorated differential\n return dot(u-m.xy,(f));//signed distance to line \n //more generally, f should be normalized here for proper caling.\n //but scaling is irrelevant as we only care fror the sign \n}\n /**/\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n v1 u=fra(U);\n v2 c=v2(0);\n v3 m=v3(fra(iMouse.xy),fra(iMouse.zw));\n    \n\n //m.xy=abs(m.xy);//mouse is always positive.\n /*main*/\n\n u.y+=.5; \n m.y+=.5;\n\n if(iMouse.z<=0.)m.xy=vec2(cos(iTime),sin(iTime*.61))*.4;\n \n //m.y=0.;\n m.xy=min(m.xy,vec2(.49999));\n m.xy=max(m.xy,vec2(-.49999));\n m=abs(m);\n if(m.x>m.y)m.xy=m.yx;\n \n\n vec3 ad=vec3(m.y-rac,m.y,rac);   //tangential large circle\n vec3 d=vec3(0,m.y,m.y);          //smaller upper circle .xy=center .z=radius\n    \n vec3 ae=vec3(m.x-rac,1.-m.x,rac); //tangential large circle\n vec3 e=vec3(0,1.-m.x,m.x);       //smaller lower circle .xy=center .z=radius\n    \n    \n //u.y-=m.x;\n    \n //c.g=length(u-d.xy)-d.z;\n //c.g=length(u-ad.xy)-ad.z;\n\n \n\n \n    \n vec3 hig=vec3(0,1.-m.x,rac-m.x);//upper intersect ring\n vec3 low=vec3(0,m.y,rac-m.y);//lower intersect ring\n  vec2 i=vec2(0);//center of 2 large circles, to be calculated by intersection\n  i.y=ad.y-cci(vec3(low.z,hig.z,ad.y-ae.y));//circle circle intersection.y\n  float y=m.y-i.y;\n  c.r=min(abs(length(u-hig.xy)-hig.z),abs(length(u-low.xy)-low.z));\n  i.x=-sqrt(low.z*low.z-y*y);//circle circle intersection.x\n \n    \n    \n    \n    \n    \n    \n    \n c.g=max(length(u-ad.xy)-ad.z,-length(u-d.xy)+d.z);\n c.b=max( length(u-ae.xy)-ae.z,-length(u-e.xy)+e.z);\n \n   \n c.r=min(c.r,abs(u.y-i.y));\n c.r=min(c.r,abs(u.x-i.x));\n \n    \n      u.x=abs(u.x);\n    \n  c.r=smoothstep(.1,-.1,c.r);//yes, this shows circlecircle intersection.\n c.r=length(u-i)-low.z-m.y;//yes this is the middle one!!!!!!!!!!!!\n \n  \n    \n    \n float da=sd2l(u,vec4(i,d.xy));\n float db=sd2l(u,vec4(i,e.xy));\n    c=vec3(0);\n         if(da<.0)c.b=length(u-d.xy)-d.z;\n else if(db>.0)   c.g=length(u-e.xy)-e.z; \n  else c.r=length(u-i)-low.z-m.y;\n \n \n    \n//remaining problem is the branching, calculating if u is above or below a line\n    \n \n    \n    \n    \n    \n /*O*/\n #ifdef toisoline\n c=abs(c)-.03;\n #endif\n v0 fsaa=1./min(iResolution.x,iResolution.y);\n c=mix(fract(c*4.),smoothstep(fsaa,-fsaa,c),.6);\n return c*.3+c.yzx*.7;}\n\nvoid mainImage(out vec4 O, vec2 U){O=vec4(c(U),1);\n}\n//#define mainImage(O,U)O=vec4(c(U),1);\n/* end__.Main\n   start.Tail\n*/\n\n\n/*\nthe BISYMETRY PRINCIPLE: v3\n- In a quest to increase symmetry for performance and modular shaders. (in contextual biases)\n- - utilize  https://en.wikipedia.org/wiki/List_of_planar_symmetry_groups\n- - utilize linear-algebra-deformed mirror borders that define branches.\n- - Only write atomic special cases and transformations, \n- - ...to construct general functions from.\n- - Instead of writing a general function, \n- - ...to be fed with a lot of parameters set to 0 or 1 to turn them into \"special cases\"\n- - this way general functions can be made into special \"shortcut\" functions more easily.\n- - this way special functions can more easily be extended, generalized.\n...\n- it appears the \"ideal bisymmetrically optimized function looks something like this:\nfloat demo(vec2 u,vec4 m){//u= uv fragment position; m=iMouse.xyzw both likely transformed\n u.x=abs(u.x-1.); u.y=-u.y*.5; //symmetry modifiers are likely \"outsourced\"\n float a=sign(m.x-1.)+1.;\n float b=sign(m.y+1.)+u.x;\n float c=sign(m.z+m.x)-m.y;\n float c=-sign(m.z-u.x);\n //above are all sign-factors, below is the final binomial, both rarely are shared subroutines.\n return u.x*(a+b)*(c+2.)*d*0.5-u.y//the *.5 and -u-y can likely be \"outsourced\"\n}\n- how you transform binomials and branches depends on the bias from your context.\n- in general, it makes sense to delay sqrt() or length() as much as possible.\n- ... while also keeping brnches that are shortcuts \n- ... eg: usually abs(length()) begs to be a shortcut.\n...\n- this whole PRINCIPLE screams FRACTAL and SUPERPRIM ! \n- - https://www.shadertoy.com/results?query=superprim\n- this PRINCIPLE more easily delays sqrt() or length() till the end of a function, \"outsource\"able\n\nHOW TO\n- rearrange your branches so that sqrt() or length() is delayed as much as possible.\n- abs(length()) can not be delayed, therefore it may as well be treated as a shortcut.\n- ... meaning, if(your shape contains abs(length())) that branch stays as if() branch!\n- all other brahcnes usually end up being equally omplex trees of equally complex branches.\n- in that case, an openCL coders eyes open to reveal how to make long pipelines:\n- Substitute functions with identities to reveal their underlying bisymmetries.\n- - substitute max() to if()then() to mix(step)) to mix(sign()) to sums of sign()\n- - - for details on identities see - https://www.shadertoy.com/view/ldBfzc\n- - because there is often a lot of symmetry performance \"lost\" in if-branches, or max()=-min(-)\n- End up precalculating the specifics of a function, \n- Get a sum that you can easily modify \n- transform the sum into binominals of precalculated variabls, that make sense in the context.\n- - this is \"ultimate code golf\", as the best soluion depends on the functions context.\n- Modify underliing partial simple bisymmetries of the functions \"specifics\"\n- Bisymmetry turns out to be mostly about (mutually exclusive matrices of) Binimials.\n...\n- Using only fullRotation*N/24 , makes it more likely that terms cancel each other out.\n- if (symmetry) 2 symmetric subroutine-values tend to cancel factors out, \n- ... down to sign(a)*sign(a)=1.\n- Your function(s) turns into a \"family of bisymmetrical functions\" \n- ... that are more easily generalized or specialized.\n- ... that are more easily made work-save against undefineds like: \n- ... a=atan(0.,0.)*tan(acos(.0))*log2(0.)*pow(0,0)*a/0.\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}