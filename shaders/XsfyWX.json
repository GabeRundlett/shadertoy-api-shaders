{
    "Shader": {
        "info": {
            "date": "1490281379",
            "description": "error is that a rotation is not rotated in buffA\n\nbuffA most likely needs quaternions",
            "flags": 48,
            "hasliked": 0,
            "id": "XsfyWX",
            "likes": 1,
            "name": "007 CameraControl 2",
            "published": 3,
            "tags": [
                "camera",
                "keyboard",
                "rotation",
                "friction"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 699
        },
        "renderpass": [
            {
                "code": "/*\nControls:\nAll keys have accelertion/momentum and friction over time to them:\n\n[Arrows]==[e][s][d][f],[space]==[pgUp],[pgDn] => strave\n[w][r], roll=rotate around view axis\n\nHold Left Mousebutton for mouselook:\n[Mouse.x]=rotate around camera.up-axis\n[Mouse.y]=rotate around camera.right-axis\n*/\n\n#define PIB asin(1.)\n#define PI  acos(-1.)\n#define TAU (PI*2.)\n/*\nx*0.5=Pi  =1/2 full    rotation in radians =\nacos(-1)  =1   half    rotation in radians = \nasin(1)*2 =2   quarter rotation in radians\ni know x=fullRotation (Tau) , but is is also = simple acos(y) or asin(y) ?\n*/\n\n//start.Constants.modifiable\n#define kMaxIterations 512\n\n//#define dynamicEps\n/*\n...\nNO dynamicEps is better than dynamic epsilon for \"low altitude\" cameras.\ndynamiceps is better for high altitude cameras and convex/asteroid-field-sets.\n...\ndynamiceps makes more sense with roughly 4x kMaxIterations\nthen dynamicEps gives much more fps when you are flying high above a rough plane.\nbecause it increments epsilon a tiny bit every step.\nmaking very fragment take roughly the same time\nso on higher resolutions the slowest fragments no longer slow down as much.\ndynamicEps can be better for VERY concave but open scenes (like a skyline)\ndynamicEps converges faster (more linearily) on convex scenes (asteroid fields).\n...\ndynamicEps can be set to give higher detail close up and longer max distance.\n which is relevant if your code accumulates multiple reflections of one ray.\ndynamicEps creates a lot more artefacts overall, to be hidden in noise.\n*/\n\n#ifdef dynamicEps\nconst float FPSmultipier=1e25;//increase for faster fps and more sdistortions over distance.\n//for FPSmultipier range [1e1..1e36] you can treak framerate almost linearily. \n//higher multipliers = higher fps == flatter horizoon == more horizon bleeding into the sky.\n//this depends on screen resolution and is limited by kMaxIterations\n//const float FPSmultipier=1e35;//to have the distortion noticable close up.\n#endif\n\n//End.Constants.modifiable\n//\n//Start.Constants.Static.Global:\n\n//this must be identical in each buffer for cross-refferencig addresses:\n//get buffered data from iChannel0\n#define get2(a,b) texture(iChannel0,vec2(a,b+.5)/iResolution.xy,1.)\n#define get(a)    texture(iChannel0,vec2(a,  .5)/iResolution.xy,1.)\n#define getz(a) get(a).xyz\n//positions in nth derivatives\n//float pos1=1.5;//position.overTime==Acceleration\nfloat pos0=3.5;//position\n//rotations in nth derivatives\n//float rot1=5.5;//rotation.overTime==AngularMomentum\nfloat rot0=7.5; //rotation.overTime\nfloat fow=9.5;  //a slider used to set fow.\n//\n//Start.Constants.Static.Global:\n\n/*\n#define v3p(b) a.xyz*a.b\nmat3 EulerToMat(vec3 p){vec3 s=sin(p),c=cos(p);\n return mat3(c.z*c.x,-c.z*s.x,c.z*s.x*s.y+s.z*c.y\n ,s.x ,c.x*c.y ,-c.x*s.y\n ,-s.z*c.x ,s.z*s.x*c.y+c.z*s.y ,-s.z*s.x*s.y+c.z*c.y);}\n//http://www.euclideanspace.com/maths/geometry/rotations/conversions/eulerToMatrix/\n*/\n\n#define r2(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n\nvoid opU(inout float a,float b){a=min(a,b);}\n//return distance of [p]Point to box [s]size box [r]Roundness\nfloat dfBox(vec3 p,vec3 s,float r){return length(max(abs(p)-s+vec3(r),0.0))-r;}\n\n//MaterialColor() is a placeholder reminder that\n//EVERY space in 3d is assigned a material\n//and this function does it.\n//by calling a simpler COPY of df();\n//because in the end df() can hit a \"surface\" anywhere.\n//because MaterialColor() is likely called in df();\n//vec3 MaterialColor(vec3 p){return vec3(.5);}\n\n//offset mod() for repeating space, xplained by \"hg_sdf\"\n#define pMod(x,d) (mod(x+d*.5,d)-d*.5)\nfloat df(vec3 p){\n float r=p.z-.06*sin(1.5*length(p.xy             )-iTime)\n            -.04*sin(1.5*length(p.xy*.61-vec2(55))-iTime);\n                 p.z+=.5;\n //p.z=pMod(p.z,100.);\n vec3 q=vec3(pMod(p.xy,vec2(20,10)),p.z);\n opU(r,length(q-vec3(0,0,5))-1.);\n q=vec3(pMod(p.xy,vec2(17,13)),p.z);\n opU(r,dfBox(q-vec3( 3, 1,1.05),vec3(2),0.015));\n q=vec3(pMod(p.xy,vec2(61,21)),p.z);\n opU(r,dfBox(p-vec3(-3, 1,1.05),vec3(2),1.2));\n opU(r,dfBox(p-vec3( 0,-3,1.05),vec3(2),.7));return r;}\n\nvec3 normal(vec3 p){const vec2 e=vec2(.01,0);\n vec3 n=vec3(df(p+e.xyy)-df(p-e.xyy),df(p+e.yxy)-df(p-e.yxy),df(p+e.yyx)-df(p-e.yyx));\n if(length(n)<0.01)return vec3(0);//makes is easier to distinguish if the camera is far from any surface.\n return normalize(n);}\n\n//vec3 normal(vec3 p){const vec2 e=vec2(.01,0);return normalize(vec3(\n// df(p+e.xyy)-df(p-e.xyy),df(p+e.yxy)-df(p-e.yxy),df(p+e.yyx)-df(p-e.yyx)));}\n\n#ifdef dynamicEps\n//this is experimental tweaking\nconst float verysmallpositive=FPSmultipier*0.0000000000000000000000000000000000000117;//3.5/1e40;//taking 1./1e40 as planck constant for floats in gl.\nconst float almostone=1.+verysmallpositive*20.;\n//i find values like these to cause a scene with a horizon co compile as fast as a scene that looks down at a flat ground.\n#endif\nfloat raymarch(vec3 o,vec3 i){float e,d;for(int j=0;j<kMaxIterations;j++){float p=df(o+i*d);if(p<e)return d;d+=p;\n#ifdef dynamicEps                                 \n e=e+verysmallpositive+e*almostone;\n#endif\n }return d;}\n\n//float shadow(vec3 o,vec3 i){const float minDist=1.;float r=1.,t=.25;\n// for(int j=0;j<10;j++){r=min(r,4.*df(o+i*t)/t),t+=.25;}return r;}\n\nfloat ambientOclussion(in vec3 p,in vec3 n){float s=.1,r=1.;vec4 v=vec4(n*s,s),m=vec4(p,0.)+v;\n for(int i=0;i<5;i++){r-=(m.w-df(m.xyz))*.25;m+=v;}return max(r,0.);}\n\nfloat softShadow(in vec3 o,in vec3 i,float n,float m){\n float r=1.,t=n,k=.05;const float s=100.,u=1.+.78/sqrt(s*.5);\n //not perfect, decent for s range[10.100]\n for(float j=0.;j<s;j++){float h=df(o+i*t)/(s+1.);\n  if(h<0.)return 0.;r=min(r,(k*h/t));\n  t=t*u+h;//mod by ollj allows for smaller [n]\n     if(t > m)break;}return r*s*79./length(i);}\n//based on: https://iquilezles.org/articles/rmshadows\n\nvoid camera(vec2 q,vec3 e,vec3 t,vec3 u,out vec3 o,out vec3 i,float v){\t\n vec3 z=normalize(t-e),x=normalize(cross(z,u)),y=normalize(cross(x,z))*q.y;x*=q.x;//vec3 x,y,z==vec3 u,v,w\n float f=acos(dot(z,normalize(x))),//fow.xy\n s=(10./(2.*tan(abs(f)/2.)));o=e+(x+y)*(.15+.5*v)*s;i=normalize((e+z*2.+(x+y)*s)-o);}\n\n//return f[x] of a SeeSaw curve with [w]avelength and [a]mplitude; returns range [0..amp]\n#define seesaw(x,w,a) (mod(x,w)*a)\n//set [a]mplitude = 1/[w]avelength\n#define seesaw2(x,w) seesaw(x,w,1./w)\n///return sin(t), shifted to range [0...1]\nfloat sinP(float t){return(sin(t)+1.)*.5;}\n#define clampe(a) clamp(-.2+1.4*(iMouse.a/e.a*2.),0.,2.)\n\n\n#define ir iResolution\nvec2 frame(vec2 i){i/=ir.xy;//center i=(0,0), aspect ratio independently.\n //i.x/=ir.y/ir.x;i-=.5;//centric circle\n i-=.5;\n i.x/=ir.y/ir.x;//centric circle,aligned left\nreturn i*2.;}//returns i range [-1,1] on the axis with less pixels\n\n//rotation.3d:\n//return [p] rotated by axis [a] by angle [r];\n#define R(p,a,r) (p*cos(r)+cross(a,p)*sin(r)+a*dot(a,p)*(1.-cos(r)))\n//https://en.wiaipedia.rrg/wiai/Rrdrigues%27_rrtatirn_frrmula\n#define Raa(p,a) R(p,a.xyz,a.w)\n\n\n//#define t1(s) sin(iTime*s)\n//sine around .5, scaled by a.\n//#define ta(s,a) (t1(s)*a+.5)\n\n//project i on a screen with distance f.\nvec3 fow3(vec2 i, float f){return vec3(i*f,-1.);}//to be normalized at some oint\n\nvoid mainImage3(out vec4 r,in vec2 i){r.w=1.;\n  //CameraFunctions.Start\n  //float zoom=65.;       //scaling factor, larger values \"zoom out\" more.\n  vec3 cameraPosition=getz(pos0)*20000.; //position of camera\n  cameraPosition+=vec3(33);   //offset to unmoved camera\n  vec4 cameraRotation=get(rot0);\n  cameraRotation.xyz=cameraRotation.zxy;            \n  cameraRotation.w  =length(cameraRotation.xyz);\n  cameraRotation.xyz=cameraRotation.xyz/cameraRotation.w ;\n  float fow=get(fow).x;\n  i=frame(i);            //2d scaling of viewframe, AspectRatio and offset.xy\n  //i*=zoom;\n  vec3 o=vec3(i,1.);     //o=Rayorigin.scale==zoom,for parallel projection==DisplayDistance for nonparallel.needs some trigonometry to be user friendly.                                      \n  vec3 d=vec3(0,0,1.);   //d=RayDirection,parallel extruded to 3d, keeping frame() 2d. for simplicity, default looking direction == positive.z; \n  d=normalize(d);\n  d=fow3(i.xy,1.3);       //set a 3d ray direction\n  d=normalize(d);\n                                                        \n  //below 2 lines are debug overwrites\n  //cameraRotation=vec4(0,1,0,iTime);//cameraRotation.w=mod(cameraRotation.w,acos(-1.)*2.);\n  //cameraPosition=vec3(0,0,30);\n                                                                            \n                                           \n  d=Raa(d,cameraRotation);//RayRirection.rotate by camera.Rotation\n  o=Raa(o,cameraRotation);//RayOrigin.rotate by camera.Rotation                                \n  o+=cameraPosition*2.;      //RayOrigin\n  d=normalize(d)*.9;\n  //CameraFunctions.End\n                                \n                                      \n                                      \n  //TracingFunctions.Start:    \n  vec3 p=o+d*raymarch(o,d);//p.xyz==were raymarching hits a surface.\n  vec3 light0p=vec3(21.,10.,20.);\n  vec3 light0=normalize(light0p);//normalize(light0Dir*9.0-p);\n  vec3 n=normal(p);\n  //following branch catches a lot of perspective issues:                              \n  //if (length(p-e)>600.)n=vec3(0);//set normal of p>\"zFar\" to -t.\n  //else \n      if(n==vec3(0))n=vec3(0);//set normal of p<\"zNear\" to t.\n  vec3 c=n*.5+.5;\n  //float s=shadow(p+n*.1,vec3(1,2,3));\n  vec3 tolight=light0p-p;\n  float s=ambientOclussion(p,n)*softShadow(p,tolight,.005,length(tolight));\n  //c*=s;\n  c=c*.5+c*s*.5;//mix(c-vec3(.1),c,s);\n  //c*=max(dot(n,normalize(vec3(1,2,3))),0.)*.5+.5;//diffuse light\n  if(dot(n,light0)>0.){float s=min(1.,pow(max(0.,dot(reflect(-light0,n),normalize(o-p))),50.));\n  r.xyz=mix(c,vec3(1),s*.75);}\n  r.xyz=c;   \n  //TracingFunctions.End:\n    \n    \n    \n //2d framing circle\n  /* //2d frame()\n i*=zoom;\n float z=seesaw2(length(i),1.);\n i=seesaw2(i,vec2(1.));\n vec4 r2d=vec4(i,z,1);\n r2d=pow(r2d,vec4(8.));\n float grey =1.-max(max(r2d.x,r2d.y),r2d.z)*t1(.5)*.5;\n r2d=vec4(vec3(grey),1);//greyscale makes for easier linear interpolation by mult;\n    */\n\n //PostCorrection.end\n //debugging, gamma correction, blending over time:\n //vec4 r3d=vec4(d,1);\n //r3d.xyz=r3d.xyz*.5+.5;//shift negatives into visible range\n //r=r3d;\n //r=mix(r3d,r2d,.5);//ta(10.,.125));\n //PostCorrection.end\n}\n\n#define clampe(a) clamp(-.2+1.4*(iMouse.a/e.a*2.),0.,2.)\nvoid mainImage(out vec4 r,in vec2 i){\n //r=get2(i.x*.1,r.y);//show BufA\n r.xyz=texture(iChannel0,.3*i/iResolution.xy).xyz;//show BufA overt time\n if(i.x>35.)//splitscreenCondition\n mainImage3(r,i);//keep splitscreens independent. \n}\n\n//credits:\n//previous variant: https://www.shadertoy.com/view/MlyGDy //006 euler ui canvas by ollj\n//and               https://www.shadertoy.com/view/XlyGDy //control sceme\n//merger of         https://www.shadertoy.com/view/XtG3DG //inversed perspective by HLorenzi\n//modified by ollj (no globals; no shadow; no materials; no slider)\n\n//Distance Functions by iquilezles.org \n//Distance Functions by hg_sdf, a collection of scene.org",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//I REALLY do not like how 3d rotations are non-commutative, but thats how it is:\n//order of rotations in 3d matters.\n\n//disregarding that, this shader takes inputs that represent rotations around 3 axis\n//in a way tht has them commutatively modify ONE vec3\n//whos direction sets an axis\n//and whos length sets an angle\n\n//which is just a different wy of modifying a rotation\n//while pressing multiple keys at once, making order of key parsing irrelevant.\n\n//the trick for friction is that your keys directly modify the first derivatives.\n//that get diminished over time, and that modify a 0th derivative over time.\n\n//the tricky part is how position is affectedby rotation\n\n//use for first person movement; uncomment for 3rd person movement, where the agent is at the camera target.\n#define FirstPerson\n//uncommenting this may just be a buggy mess.\n\n//Start.Constants.Static.Global:\n\n//this must be identical in each buffer for cross-refferencig addresses:\n//get buffered data from iChannel0\n#define get2(a,b) texture(iChannel0,vec2(a,b+.5)/iResolution.xy,1.)\n#define get(a)    texture(iChannel0,vec2(a,  .5)/iResolution.xy,1.)\n#define getz(a) get(a).xyz\n//positions in nth derivatives\nfloat pos1=1.5;//position.overTime==Acceleration\nfloat pos0=3.5;//position\n//rotations in nth derivatives\nfloat rot1=5.5;//rotation.overTime==AngularMomentum\nfloat rot0=7.5; //rotation.overTime\nfloat fov =9.5;  //a slider used to set fow.\n//\n//Start.Constants.Static.Global:\n\n//get keyboard input from iChannel3\n//(y==.5) true while held down,\n//(y==1.5) true for 1 frame when toggled from unpressed to pressing\n//(y>1.5)  if(b==0) toggle between true and false \n#define ki0(a) texture(iChannel3,(vec2(a,0.5))/vec2(256.,3.)).x \n\n//how much of x1 gets added to x0; larger factor==more accelleration per frame.\n#define AccelP 9.*iTimeDelta\n#define AccelR 1.*iTimeDelta\n//maximum absolute speeds (directional and rotational), hard cap\n#define SpeedMaxP 100000.\n#define SpeedMaxR 10.\n//friction, positional and rotational\n#define FrictionP .9*iTimeDelta\n#define FrictionR .1*iTimeDelta\n\n//#define set(a,b) if(gl_FragCoord.x==a.x+0.5&&gl_FragCoord.y==a.y+0.5){b;return true;}\n//#define set(a,b) if(gl_FragCoord.xy==a.xy+0.5){b;return true;}\n//#define set(a,b) if(a.xy+0.5==gl_FragCoord.xy){b;return true;}\n//#define clampe(a) clamp(-.2+1.4*(iMouse.a/e.a*2.),0.,2.)\n\n//for now,the axisangle solution performs better than quaternions.\n//return matrix of normalized quternion\n//mat3 quatToMat(vec3 q){return mat3(0);}\n//vec3 RotPByQuaternion(vec3 p,vec4 q){return vec3(0);}\n\n#define v3p(b) a.xyz*a.b\n//return mat3 of a.xyz=<-axis a.z<-angle;\nmat3 AxisAngle2Mat(vec4 a){float c=cos(a.z);\nreturn c*mat3(1)+(1.-c)*mat3(v3p(x),v3p(y),v3p(z))\n      +sin(a.z)*mat3(0.,-a.z,a.y,a.z,0.,-a.x,-a.y,a.x,0.);}\n//http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToMatrix/index.htm\n\n//vec2 sc(float p){return vec2(sin(p),cos(p)};}\n\n/*\nfloat mulC(vec3 p){return p.x*p.y*p.z);}                            \nvec4 Euler2AxisAngle(vec3 p){p*=.5;//.xyz=heading,altitude,bank\n vec3 s=sin(p),c=cos(p);\n vec4 r;\n r.w=2.*acos(mulC(c)-mulC(s));\n r.x=s.x*s.y*c.z+c.x*c.y*s.z\n// x=s1  s2  c3 +c1  c2  s3\n r.y=s.x*c.y*c.z+c.x*s.y*s.z\n// y=s1  c2  c3 +c1  s2  s3\n r.z=c.x*s.y*c.z-s.x*c.y*c.z\n// z=c1  s2  c3 -s1  c2  s3\n return r;}\n*/\n\n\nmat3 EulerToMat(vec3 p){vec3 s=sin(p),c=cos(p);\n return mat3(c.z*c.x,-c.z*s.x,c.z*s.x*s.y+s.z*c.y\n ,s.x ,c.x*c.y ,-c.x*s.y\n ,-s.z*c.x ,s.z*s.x*c.y+c.z*s.y ,-s.z*s.x*s.y+c.z*c.y);}\n//http://www.euclideanspace.com/maths/geometry/rotations/conversions/eulerToMatrix/\n\n\n//sets hard max absolute speed limits, does not do exponential friction.\n//maxcap sets a hard max speed, absolute length.\nvec3 maxCap(vec3 r,float m){return min(r/(1.+max(abs(length(r))-m,0.)),r);}\n //float a=max(abs(length(r))-m,0.);//a tells by how much r is too long:\n //0= max length, or shorter. //1=2x longer than allowed. to multiply by 1/2\n //2=3x as long as allowed.  to multiply by 1/3  //... to multiply by 1/(1+a), to divide by /(1+a)\n\n\n//rotation.3d:\n//return [p], rotated by [a]Axis and Angle[r], in radians;\n#define R(p,a,r) (cos(r)*p +(1.-cos(r))*dot(p,a)*a +sin(r)*cross(a,p))\n#define Raa(p,a) R(p,a.xyz,a.w)\n\n#define FirstPerson\n\n#define rp return vec4(p,1.);}if(a==\n//to fix (too tricky within shadertoy):\n//does not care for mass or volume or surface effects.\n//AccelP|AccelR accellerate linearily over time. but accelleration should diminish with speed.\nvec4 setP(float a){\n if(a==pos1){vec3 p=getz(pos1)*FrictionP;\n  float y=max(ki0(83.5),ki0(37.0))-max(ki0(70.5),ki0(39.5));\n  float x=max(ki0(69.5),ki0(38.5))-max(ki0(68.5),ki0(40.0));\n  float z=max(ki0(32.5),ki0(33.5))-max(ki0(67.5),ki0(34.0));//jump/crouch\n  vec3 m=vec3(x,y,z);\n  m=maxCap(m,1.);//diagonal movement capped to length 1.\n  p+=m;\n rp pos0){vec3 p=getz(pos0);\n  #ifdef FirstPerson\n  //p+=(getz(pos1)*EulerToMat(getz(rot0)))*AccelP;//euler rotation variant\n  p+=Raa(p,get(rot0))*AccelP;//axisAngle Rotation variant\n  #else\n  p+=getz(pos1)*AccelP;//this is old nonsense\n  #endif\n rp rot1){vec3 p=getz(rot1)*FrictionR;\n  float z=max(ki0(82.5),ki0(35.5))-max(ki0(87.5),ki0(36.0));//.z s rolling;\n  vec2 xy=(iMouse.xy/iResolution.xy)-.5;\n  vec3 m=vec3(-xy.x,z,-xy.y);\n  m=maxCap(m,1.);//diagonal rotation capped to length 1.\n  p+=m;\n rp rot0){\n  vec3 p=getz(rot0)+getz(rot1)*AccelR;\n rp fov){\n  vec3 p=getz(fov);\n  p.x+=(ki0(49.5)-ki0(50.5))*.01;\n  //p=clamp(vec3(0),vec3(1),p);\n  return vec4(p,1.);\n }return vec4(0);}\n\nvoid mainImage(out vec4 r,in vec2 i){\n if (i.y<=1.)r=setP(i.x);\n  else r=get2(i.x,i.y-.6);//optionaly copy to row with delay.\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}