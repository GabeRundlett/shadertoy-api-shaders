{
    "Shader": {
        "info": {
            "date": "1550169832",
            "description": "\"Infinite Spinal Squid\" - Shader showdown practice session 007.\nLive coded on Twitch with 25 minutes time limit.\nPracticing live on TWITCH every Tuesdays around 20:30 UK time.\nhttps://www.twitch.tv/evvvvil_\n",
            "flags": 0,
            "hasliked": 0,
            "id": "3s23Dc",
            "likes": 17,
            "name": "[TWITCH] Infinite Spinal Squid",
            "published": 3,
            "tags": [
                "sun",
                "time",
                "demoscene",
                "sky",
                "abstract",
                "limit",
                "live",
                "battle",
                "shadershowdown",
                "glare",
                "spine",
                "coding",
                "twitch",
                "showdown",
                "squid"
            ],
            "usePreview": 0,
            "username": "evvvvil",
            "viewed": 960
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\"Infinite Spinal Squid\" - Shader Showdown practice session 007\n\n// WHAT THE FUCK IS THE SHADER SHOWDOWN?\n// The \"Shader Showdown\" is a demoscene live-coding shader battle competition.\n// 2 coders battle for 25 minutes making a shader from memory on stage. \n// The audience votes for the winner by making noise or by voting on their phone.\n// Winner goes through to the next round until the final where champion is crowned.\n// Live coding shader software used is BONZOMATIC made by Gargaj from Conspiracy:\n// https://github.com/Gargaj/Bonzomatic\n\n// Every tuesdays around 20:30 UK time I practise live on TWITCH.\n// This is the result of session 007. \n\n// COME SEE LIVE CODING EVERY TUESDAYS HERE: https://www.twitch.tv/evvvvil_\n\n// evvvvil / DESiRE demogroup\n\n// \"A squid eating dough in a polyethylene bag is fast and bulbous.\" - Captain Beefheart\n\nvec2 sc,e=vec2(0.00035,-.00035);float t,tt,att,su;vec3 np,pp; //Global fucking variables because we're internafuckingtional\n//Cheap fucking box function (actually stollen from UNC I think, not picking IQ's pockets on this one)\nfloat bo(vec3 p,vec3 r){vec3 q=abs(p)-r;return max(max(q.x,q.y),q.z);}//Still stolen from someone though, come on, I'm too cool to be that clever.\n\n//Simple 2d rotate function, nothing to see here, move along, find the angry mother and introduce her to DMT\nmat2 r2(float r) {return mat2(cos(r),sin(r),-sin(r),cos(r));}\n\n//Fucking bits function which makes the fucking bit/piece it is a base shape which we clone and repeate to create the whole geometry in mp function\nvec2 fb( vec3 p )//Base piece look like a train track, couple of parralel rectangles with some perpendicular ones in middle\n{\n  vec2 h,t=vec2(bo(abs(p)-vec3(2,0,0),vec3(0.3,0.3,10)),5); //t is the blue bits: 2 rectangles symetry cloned along the x axis\n  h=vec2(1000,3);//h is the black bits, we make it really high, just like me, so we can add shapes by using min function\n  for(int i=0;i<6;i++) {\n    h.x=min(h.x,bo(abs(p)-vec3(0,0,0.5*float(i)),vec3(2,0.1,0.1)));//keep adding one black rectangle per iteration and shift it\n    h.x=min(h.x,bo(abs(p)-vec3(2,0,0.5*float(i)),vec3(0.2,0.5,0.2)));//keep adding one smaller black rectangle per iteration and shift it\n  }\n  t.x=min(t.x,0.8*(length(p-vec3(0,0,6))-1.7));//this creates a sphere in between blue bits\n  t=(t.x<h.x)?t:h;\n  t.x*=0.5;//This make the shape more defined so that we don't get artifact (glitches that look like shit)\n  return t;\n}\n//Map function / scene / Where the geometry is made.\nvec2 mp( vec3 p )//We make a whole complex geometry based on one single piece defined in fb\n{//We do that by fucking with the position p in a new variable np(new position) then we pass np to fb\n\tp.xy*=r2(sin(p.z*.2)*.5+tt*.5);//This does an overall twist and constant rotation \n  \tnp=p;  //Told you we were gonna fuck with p in a new variable np, take fucking notes broski, this isn't your girlfriend's shitty yoga class\n  \tatt=length(p-vec3(0,0,sin(tt*2.)*20.))-5.;//We create reverse-attractor, it's a sphere that pushes the geometry out\n  \tnp.z=mod(p.z+tt*10.,15.)-7.5; //this make the geometry infinite along the z axis, because, yeah you guess right, Einstein, it's a fucking infinite squid\n  \tfor(int i=0;i<3;i++){\n    \tnp=abs(np)-vec3(0.2,0.2+att*0.2,0);//every loop iteration we push geometry out on x axis and depending on attractor on y axis\n    \tnp.xy*=r2((cos(np.z*.2*float(i))));//rotaroo the fuckeroo: we rotate  a bit more each iteration, making it more interesting\n  \t}\n  \tvec2 h,t=fb(np);//Now we finished fucking with p we pass it through fb to create the whole geom from one \"fucking bit\"\n\n  \tpp=abs(p)-vec3(3.2,1.+sin(p.z*0.2),0)-att*0.2;//we create one more new position this time called pp and it's gonnu be for the splines + cubes\n  \tpp.z=mod(pp.z-tt*10.,4.)-2.;//make this pp splines and cube infiintie on z axis again\n  \t\n  \th=vec2(bo(pp,vec3(0.2+att*0.03)),6);//h is gonna be the hollow cubes - one box minus one sphere\n \th.x=max(-(length(pp)-(0.3+att*0.03)),h.x);//boolean operation removes sphere from cube\n  \th.x*=0.7;//make them cubes more defined so we dont get artifacts\n  \tt=(t.x<h.x)?t:h;//This mixes the squid inner geometry with the cubes\n  \th=vec2(bo(pp,vec3(0.1+att*0.01,0.1+att*0.01,30)),5);//Here, broh, the fucking splines, yeah, stick, around, it, all\n  \th.x*=0.8;//more definition less fucking artifact, more pumped pecs, more lasting impression on girls\n\tt=(t.x<h.x)?t:h;//mixes rest with the splines\n\treturn t;\n}\n\n//Main raymarching loop with material ID flex, because driving on the wrong side of the motorway is more fun while sniffing glue!\nvec2 tr( vec3 ro,vec3 rd )\n{\n\tvec2 h,t=vec2(0.1);//0.1 is our near plane\n    for(int i=0;i<128;i++){\n        h=mp(ro+rd*t.x);//get result of running map function at this ray pos\n        if(h.x<.0001||t.x>50.) break;//Get out early if we hit geom (<precision which is 0.0001) or we hit far plane (t.x>50)\n        t.x+=h.x;t.y=h.y;//t.y=h.y passes the material ID\n    }\n    if(t.x>50.) t.x=0.;//if we hit far plane then make result 0 to do \"some\" optimization\n    return t;//always return this return that, you're a fucking broken record you know that?\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5; uv /= vec2(iResolution.y / iResolution.x, 1);//Boilerplate code building uvs by default in BONZOMATIC\n    //Modulo time because I fucking hate noisey sins or whatever the fuck glitches after certain time, hey? (stops it all getting fucking noisy)  \n    tt=mod(iTime*.5,100.);\n    \n   \tvec3 ro=vec3(14,7.+sin(tt*2.)*15.,5.+cos(tt)*15.), //Camera ro=ray origin, rd=ray direction, co=final color, fo=fog, ld=light direction\n    cw=normalize(vec3(0.)-ro),cu=normalize(cross(cw,vec3(0,1,0))),cv=normalize(cross(cu,cw)),\n    rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo,bk,ld=normalize(vec3(0.2,.2,-.5));//co=final color, fo=fogcolor, bk=backgroundColorm ld=light direction\n    su=clamp(dot(ld,rd),0.,1.);//Su=sun, feels good to play god again but fucking hell Pedro I didn't buy that glue for that.\n    bk=vec3(1,.5,0)*pow(su,4.)+vec3(0.5,.6,.6)-rd.y*0.4;//bk=background mix of sky + sun. Playing god again, fuck yeah there are no side effects to this drug.\n    co=fo=bk; //setting up default color as fog and background color\n\tsc=tr(ro,rd);t=sc.x;//sc=scene. We get the scene by shooting rays, big one this yeah, bigger than your ass look in those jeans. \n  if(t>0.){\n    //We hit some geometry so let's get the current position (po) and build some normals (no). You do the Maths while I serenade them fuckin' angels.\n    vec3 po=ro+rd*t,no=normalize(e.xyy*mp(po+e.xyy).x+e.yxy*mp(po+e.yxy).x+e.yyx*mp(po+e.yyx).x+e.xxx*mp(po+e.xxx).x),    \n    \n    //LIGHTING MICRO ENGINE BROSKI \n    //Default albedo is blue with gradient depending on distance to attractor. (al=albedo)\n    al=vec3(0,0.5+att*0.02,1);  \n\t//Different material id? Changeacolourooo... It's all very black and white, like when I'm right and you're wrong\n    if(sc.y<5.) al=vec3(0);\n    if(sc.y>5.) al=vec3(1);\n    float dif=max(0.,dot(no,ld)),//dif = diffuse because I dont have time to cook torrance\n    //ao = ambient occlusion, aor = ambient occlusion range\n    aor=t/50.,ao=exp2(-2.*pow(max(0.,1.-mp(po+no*aor).x/aor),2.)),    \n    //Fresnel blends the geometry in the background with some sort of gradient edge reflection colouring mother fucker\n    fre=pow(1.+dot(no,rd),4.); // yeah  maybe it should be reflected but who gives a shit broski, if you do then fuck you\n    //Fake sub surface scattering, sort of reverse ambient occlusion trick from tekf, big up tekf! https://www.shadertoy.com/view/lslXRj\n    vec3 sss=vec3(.5)*smoothstep(0.,1.,mp(po+ld*0.4).x/0.4),\n    spec=vec3(.5)*pow(max(dot(reflect(-ld,no),-rd),0.),10.);//specular by shane. Even better than the feeling of stroking used tea bags\n    co=mix(spec+al*(.2+.8*ao)*(dif+sss),bk,min(fre,0.5));//Final result of color, crunching everything into an RGB shit sandwich\n\tco+=0.5*vec3(1,.5,0)*pow(su,3.);//Post processing sunglare effect: much better than being slapped across the face with a fish\n    co=mix(co,fo,1.-exp(-.00003*t*t*t));//Fog is lovely reminds me of dipping my hand in warm honey while watching angels get naked\n  }  \t\n  //Add some sort of tone mapping... but it's fake like a Hipster's craft beer trying to be a Belgian brew.\n  fragColor = vec4(pow(co,vec3(0.45)),1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}