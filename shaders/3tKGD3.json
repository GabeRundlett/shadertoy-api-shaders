{
    "Shader": {
        "info": {
            "date": "1580063417",
            "description": "3D Hypercube",
            "flags": 0,
            "hasliked": 0,
            "id": "3tKGD3",
            "likes": 6,
            "name": "3D Hypercube",
            "published": 3,
            "tags": [
                "3d",
                "hypercube"
            ],
            "usePreview": 0,
            "username": "zovox",
            "viewed": 1389
        },
        "renderpass": [
            {
                "code": "\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n#define FAR (PI*2.0)\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0)*iTime+1000.0+last_height)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.0, 1.0, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR))*.25+.5))\n#define circle(x) (vec2(cos((x)*PI), sin((x)*PI)))\n#define saw(x) fract( sign( 1.- mod( abs(x), 2.) ) * abs(x) )\n\nfloat last_height = 0.0;\nfloat beat = 0.0;\n\nfloat sphere(vec3 rp, vec3 rd, vec3 bp, float r) {\n    \n    vec3 oc = rp - bp;\n    float b = 2.0 * dot(rd, oc);\n    float c = dot(oc, oc) - r*r;\n    float disc = b * b - 4.0 * c;\n\n    if (disc < 0.0)\n        return 0.0;\n\n    // compute q as described above\n    float q;\n    if (b < 0.0)\n        q = (-b - sqrt(disc))/2.0;\n    else\n        q = (-b + sqrt(disc))/2.0;\n\n    float t0 = q;\n    float t1 = c / q;\n\n    // make sure t0 is smaller than t1\n    if (t0 > t1) {\n        // if t0 is bigger than t1 swap them around\n        float temp = t0;\n        t0 = t1;\n        t1 = temp;\n    }\n    \n    return (t1-t0)/r;\n}\n\n\nfloat line(vec3 rp, vec3 rd, vec3 a, vec3 b, float r) {\n    vec3 pa = rp - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    \n    vec3 ray = rd;\n    vec3 ray2 = normalize(b-a);\n\n    float a1 = dot(ray,ray);\n    float b1 = dot(ray,ray2);\n    float c = dot(ray2,ray2);\n    float d = dot(ray,rp-a);\n    float e = dot(rp-a,ray2);\n\n    float t1 = (b1*e-c*d)/(a1*c-b1*b1);\n    float t2 = (a1*e-b1*d)/(a1*c-b1*b1);\n\n    float dist = length((rp+ray*t1)-(a+ray2*t2));\n    return dist > r || t2 < r || t2 > length(a-b)+r? 0.0 : 1.0-dist/r;\n}\n\nconst int NUM_ANGLES = 5;\nconst int ELBOWS = 0;\nconst int WRISTS = 1;\nconst int FINGERS = 2;\nconst int KNEES = 3;\nconst int ANKLES = 4;\n// stance structure:\n//{\n//\tvec4(leftLegOmega, leftLegTheta, rightLegOmega, rightLegTheta)),\n//\tvec4(relativeLeftElbowOmega, relativeLeftElbowTheta, relativeRightElbowOmega, relativeRightElbowTheta)),\n//\tvec4(relativeLeftWristOmega, relativeLeftWristTheta, relativeRightWristOmega, relativeRightWristTheta)),\n//\tvec4(relativeLeftFingersOmega, relativeLeftFingersTheta, relativeRightFingersOmega, relativeRightFingersTheta)),\n//\tvec4(leftLegOmega, LeftLegTheta, rightLegOmega, rightLegTheta)),\n//\tvec4(relativeLeftKneeOmega, relativeLeftKneeTheta, relativeRightKneeOmega, relativeRightKneeTheta)),\n//\tvec4(relativeLeftAnkleOmega, relativeLeftAnkleTheta, relativeRightAnkleOmega, relativeRightAnkleTheta)),\n//}\n//\n// Vertices\nconst vec3 lbf = vec3(-0.5,-0.5,-0.5);\nconst vec3 rbf = vec3( 0.5,-0.5,-0.5);\nconst vec3 lbb = vec3(-0.5,-0.5, 0.5);\nconst vec3 rbb = vec3( 0.5,-0.5, 0.5);\n\nconst vec3 ltf = vec3(-0.5, 0.5,-0.5);\nconst vec3 rtf = vec3( 0.5, 0.5,-0.5);\nconst vec3 ltb = vec3(-0.5, 0.5, 0.5);\nconst vec3 rtb = vec3( 0.5, 0.5, 0.5);\n\n\nfloat dancer(vec3 p, vec3 rd) {\n    \nfloat t = mod(time,1.0);\nfloat s = sin(time)/PI/GR;\n\nvec3 lbfi = vec3(-0.5+s,-0.5+s,-0.5+s);\nvec3 rbfi = vec3( 0.5-s,-0.5+s,-0.5+s);\nvec3 lbbi = vec3(-0.5+s,-0.5+s, 0.5-s);\nvec3 rbbi = vec3( 0.5-s,-0.5+s, 0.5-s);\n\nvec3 ltfi = vec3(-0.5+s, 0.5-s,-0.5+s);\nvec3 rtfi = vec3( 0.5-s, 0.5-s,-0.5+s);\nvec3 ltbi = vec3(-0.5+s, 0.5-s, 0.5-s);\nvec3 rtbi = vec3( 0.5-s, 0.5-s, 0.5-s);\n\nvec3 lbf_lbfi = mix(lbf,lbfi,t);\nvec3 ltf_ltfi = mix(ltf,ltfi,t);\nvec3 lbb_lbbi = mix(lbb,lbbi,t);\nvec3 ltb_ltbi = mix(ltb,ltbi,t);\n\nvec3 rbb_lbb = mix(rbb,lbb,t);\nvec3 rbf_lbf = mix(rbf,lbf,t);\nvec3 rtf_ltf = mix(rtf,ltf,t);\nvec3 rtb_ltb = mix(rtb,ltb,t);\n\nvec3 lbfi_rbfi = mix(lbfi,rbfi,t);\nvec3 lbbi_rbbi = mix(lbbi,rbbi,t);\nvec3 ltfi_rtfi = mix(ltfi,rtfi,t);\nvec3 ltbi_rtbi = mix(ltbi,rtbi,t);\n\nvec3 rbbi_rbb = mix(rbbi,rbb,t);\nvec3 rbfi_rbf = mix(rbfi,rbf,t);\nvec3 rtfi_rtf = mix(rtfi,rtf,t);\nvec3 rtbi_rtb = mix(rtbi,rtb,t);\n    \n    float d = 0.0;\n\n    float radius = .025;\n\t// outside\n\td += line(p,rd,lbf_lbfi,rbf_lbf,radius);\n\td += line(p,rd,lbb_lbbi,rbb_lbb,radius);\n\td += line(p,rd,ltf_ltfi,rtf_ltf,radius);\n\td += line(p,rd,ltb_ltbi,rtb_ltb,radius);\n\n\td += line(p,rd,lbf_lbfi,lbb_lbbi,radius);\n\td += line(p,rd,ltf_ltfi,ltb_ltbi,radius);\n\td += line(p,rd,lbf_lbfi,ltf_ltfi,radius);\n\td += line(p,rd,lbb_lbbi,ltb_ltbi,radius);\n\n\td += line(p,rd,rbf_lbf,rbb_lbb,radius);\n\td += line(p,rd,rtf_ltf,rtb_ltb,radius);\n\td += line(p,rd,rbf_lbf,rtf_ltf,radius);\n\td += line(p,rd,rbb_lbb,rtb_ltb,radius);\n\n    // inside\n\td += line(p,rd,lbfi_rbfi,lbbi_rbbi,radius);\n\td += line(p,rd,ltfi_rtfi,ltbi_rtbi,radius);\n\td += line(p,rd,lbfi_rbfi,ltfi_rtfi,radius);\n\td += line(p,rd,lbbi_rbbi,ltbi_rtbi,radius);\n\n\td += line(p,rd,lbbi_rbbi,rbbi_rbb,radius);\n\td += line(p,rd,lbfi_rbfi,rbfi_rbf,radius);\n\td += line(p,rd,ltfi_rtfi,rtfi_rtf,radius);\n\td += line(p,rd,ltbi_rtbi,rtbi_rtb,radius);\n\n\td += line(p,rd,rbfi_rbf,rtfi_rtf,radius);\n\td += line(p,rd,rbbi_rbb,rtbi_rtb,radius);\n\td += line(p,rd,rbfi_rbf,rbbi_rbb,radius);\n\td += line(p,rd,rtfi_rtf,rtbi_rtb,radius);\n\n    // connections\n\td += line(p,rd,rtbi_rtb,rtb_ltb,radius);\n\td += line(p,rd,rbfi_rbf,rbf_lbf,radius);\n\td += line(p,rd,rbbi_rbb,rbb_lbb,radius);\n\td += line(p,rd,rtfi_rtf,rtf_ltf,radius);\n\t\n\td += line(p,rd,ltfi_rtfi,ltf_ltfi,radius);\n\td += line(p,rd,ltbi_rtbi,ltb_ltbi,radius);\n\td += line(p,rd,lbfi_rbfi,lbf_lbfi,radius);\n\td += line(p,rd,lbbi_rbbi,lbb_lbbi,radius);\n\n    return d;\n}\n\nvec4 draw(vec3 ro, vec3 rd, vec2 uv0) {\n    float depth = dancer(ro, rd);\n    \n    float weight = clamp(depth, 0.0, 1.0);;\n    \n    return vec4(flux(depth+time*PI)*weight, weight);//clamp(+(1.0-weight)*sample, 0.0, 1.0);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    //coordinate system\n    vec2 uv0 = fragCoord.xy / iResolution.xy;\n    vec2 uv = (uv0* 2.0 - 1.0)*vec2(iResolution.x / iResolution.y, 1.0);\n    \n    //camera\n    vec3 rd = normalize(vec3(uv, -1.0));\n    vec3 ro = vec3(0.0, 0.0, 1.0);\n    \n    float t = time;\n    vec3 axis = rormal();//vec3(0.0, 1.0, 0.0);\n    \n    ro = rotatePoint(ro, axis, t);\n    rd = rotatePoint(rd, axis, t);\n    ro *= FAR/PI;\n    \n    fragColor = draw(ro, rd, uv0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}