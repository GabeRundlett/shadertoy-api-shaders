{
    "Shader": {
        "info": {
            "date": "1593779781",
            "description": "Left: atan() discontinuity spoils the hardware derivatives  ( white arc ) used for antialiasing circles (or anything else).\nRight: managing it.\nClick to directly display fwidth(U) or Jacobian",
            "flags": 0,
            "hasliked": 0,
            "id": "WlScRW",
            "likes": 7,
            "name": "Tuto: managing atan discontinuit",
            "published": 3,
            "tags": [
                "antialiasing",
                "derivative",
                "fwidth",
                "tuto",
                "discontinuity",
                "jacobian"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 515
        },
        "renderpass": [
            {
                "code": "// --- Managing discontinuity when computing hardware derivatives ( -> Jacobian, fwidth )\n// See also: computing Jacobian to cancel distortions https://www.shadertoy.com/view/WlByRW\n\nvoid mainImage(out vec4 O,  vec2 u ){\n\n    vec2 R = iResolution.xy,  I, z, \n         U = (u - .5*R) / R.y,                           // normalized coordinates\n         D = vec2(6,-1);\n\n    U*=2.; U-=.5; U/=dot(U,U); U+=.5;                    // distortion\n    float a = atan(U.y, U.x)/6.283;   \n    U = log(length(U)) +  a * D - .3*iTime;              // spiraling\n                       // a cause a discontinuity. unseen in spiral because param fits.\n    vec2 dFx = dFdx(U), dFy = dFdy(U); // but derivatives (fwidth,dFdx,dFdy) will get a +1 or -1 jump\n    if (u.x/R.x<.5)                                      // --- left: the naive way\n        z = fwidth(U);\n    else {                                               // --- right: eliminating the jump trough discontinuity\n        float dax = dFdx(a), day = dFdy(a),\n               dx = abs(dax) > .5 ? sign(dax) : 0.,      // detect the jump\n               dy = abs(day) > .5 ? sign(day) : 0.;      // ( jump is +- 1 since atan/2PI, 0.5 threshold is large )\n        dFx -= D*dx, dFy -= D*dy,                        // eliminates in derivatives\n        z = abs(dFx)+abs(dFy);                           // recomputes fwidth manually\n/* shorter:\n    dax = dFdx(a), day = dFdy(a);\n    dFX = dFdx(U) - ( abs(dax) > .5 ? D*sign(dax) : R-R ),\n    dFY = dFdy(U) - ( abs(day) > .5 ? D*sign(day) : R-R );  \n    -> Jacobian, det, width, length...\n*/     \n    }\n                                                         // --- display\n    U.x+=.5; I = round(U); U = fract(U);                 // show distorted checker  \n    O = vec4(.5*U,0,0); \n    \n    if (iMouse.z <= 0.)                                  // draw antialiased circles\n        O += smoothstep(3.*length(z),0., abs(length(U*2.-1.) - .5)-.01 ); \n    else {                                               // draw derivatives\n#if 1                                                    //   fwidth   \n        O += vec4(z,0,0);                                  \n     // O += length(z);              \n#else                                                    //   Jacobian   \n        mat2 M = inverse(transpose(mat2(dFx, dFy)))/R.y; // Jacobian to go back to screen\n        O  = vec4( .5+ M);\n     // O += max( 0., -30.*determinant(M)*R.y );\n#endif\n    }\n    if (abs(u.x-R.x/2.)<2.) O.b ++;                      // separator\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}