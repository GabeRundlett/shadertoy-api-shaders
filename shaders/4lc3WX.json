{
    "Shader": {
        "info": {
            "date": "1471907937",
            "description": " Pseudo-random noise generation using 64-bit linear feedback shift registers (LFSRs) seeded with a noise texture and the pixel position.",
            "flags": 32,
            "hasliked": 0,
            "id": "4lc3WX",
            "likes": 15,
            "name": "LFSR Noise Generation",
            "published": 3,
            "tags": [
                "noise",
                "random",
                "bits",
                "lfsr"
            ],
            "usePreview": 0,
            "username": "Flyguy",
            "viewed": 1642
        },
        "renderpass": [
            {
                "code": "\n#define BITS_PER_FLOAT 16.0\n\n#define LSB 0      // 1-Bit Noise\n#define GREY 1     // 8-Bit Greyscale\n#define RGB 2\t   // Direct Passthough (normalized to 0-1)\n#define REGISTER 3 // Register Bits (choose register with REGISTER_UV)\n\n#define VIEW_MODE RGB\n\n#define REGISTER_UV 0,0\n\nfloat SelectComp(vec4 v4, float i)\n{\n\ti = floor(i);\n    return (i == 0.0) ? v4.w : \n    \t   (i == 1.0) ? v4.z :\n    \t   (i == 2.0) ? v4.y :\n    \t   (i == 3.0) ? v4.x : 0.0;\n}\n\nbool Bit(vec4 i64, float i)\n{\n    float n = floor(SelectComp(i64, i / BITS_PER_FLOAT));\n    \n    i = mod(floor(i), BITS_PER_FLOAT);\n    \n    return mod(floor(n / exp2(i)), 2.0) == 1.0;  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 color = vec4(0);\n    \n    #if(VIEW_MODE == LSB)\n    \tcolor = vec4(mod(texture(iChannel0, uv).w, 2.0));\n    \n    #elif(VIEW_MODE == GREY)\n   \t\tcolor = vec4(mod(texture(iChannel0, uv).w, 256.0) / 255.0);\n    \n    #elif(VIEW_MODE == RGB) \n    \tcolor = texture(iChannel0, uv) / (exp2(BITS_PER_FLOAT)-1.0);\n    \n    #elif(VIEW_MODE == REGISTER)\n    \tvec4 bits = texture(iChannel0, vec2(REGISTER_UV)/iResolution.xy);\n    \n    \tcolor = vec4(Bit(bits, floor((1.0 - uv.x) * BITS_PER_FLOAT * 4.0)));\n    #endif\n    \n\tfragColor = color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n/*\nLinear Feedback Shift Register (LFSR)\n\nA feedback bit is calculated by XORing together bits from selected taps in the register.\nThen all bits in the register are shifted left with the feedback bit being shifted into the LSB.\n\nMSB                          <-- Shift                            LSB\n|-------X------| |-------Y------| |-------Z------| |-------W------|\n1010101010101010 1010101010101010 1010101010101010 1010101010101010<________________________\n|          |                      |                  |      |  ___                           |\n|(63)  (52)|                  (31)|              (13)|   (6)|_|   |    ___                   |\n|          |                      |                  |________|XOR|___|   |    ___           |\n|          |                      |                           |___|  _|XOR|___|   |    ___   |\n|          |                      |_________________________________| |___|  _|XOR|___|   |  |\n|          |________________________________________________________________| |___|  _|XOR|__|(feedback)\n|___________________________________________________________________________________| |___|\n*/\n\n#define BITS_PER_FLOAT 16.0\n\n//Seed registers using a noise texture (prevents patterns in the first few frames).\n#define TEXTURE_SEED\n\n//Returns component 'i' of vec4 'v4'.\nfloat SelectComp(vec4 v4, float i)\n{\n\ti = floor(i);\n    return (i == 0.0) ? v4.w : \n    \t   (i == 1.0) ? v4.z :\n    \t   (i == 2.0) ? v4.y :\n    \t   (i == 3.0) ? v4.x : 0.0;\n}\n\n//Extracts bit 'i' from the 64-bit number in 'i64'.\nbool Bit(vec4 i64, float i)\n{\n    float n = floor(SelectComp(i64, i / BITS_PER_FLOAT));\n    \n    i = mod(floor(i), BITS_PER_FLOAT);\n    \n    return mod(floor(n / exp2(i)), 2.0) == 1.0;  \n}\n\n//Shifts bits left by 1 & inserts 'cin' into the LSB.\nvec4 ShiftLeft(vec4 i64, bool cin)\n{\n    vec4 shifted = vec4(0);\n    \n    shifted.x = i64.x*2.0 + float(Bit(i64, 3.0 * BITS_PER_FLOAT - 1.0));\n    shifted.y = i64.y*2.0 + float(Bit(i64, 2.0 * BITS_PER_FLOAT - 1.0));\n    shifted.z = i64.z*2.0 + float(Bit(i64, 1.0 * BITS_PER_FLOAT - 1.0));\n    shifted.w = i64.w*2.0 + float(cin);\n    \n    shifted = mod(shifted, exp2(BITS_PER_FLOAT));\n    \n    return shifted;\n}\n\n//Calculates the feedback bit by XORing multiple taps together.\nbool Feedback(vec4 i64)\n{\n    bool cin = false;\n    \n    //Taps\n    cin = cin ^^ Bit(i64, 6.0);\n    cin = cin ^^ Bit(i64, 13.0);\n    cin = cin ^^ Bit(i64, 31.0);\n    cin = cin ^^ Bit(i64, 52.0);\n    cin = cin ^^ Bit(i64, 63.0);\n    \n    return cin;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec4 bits = (texture(iChannel0, uv));\n    \n    //Initial seed\n    //Re-initializes if all bits are zero to handle resolution changes.\n    if(iFrame < 10 || bits == vec4(0))\n    {\n        #ifdef TEXTURE_SEED\n        \tbits = texture(iChannel1, fragCoord / iChannelResolution[1].xy);\n        \tbits *= exp2(BITS_PER_FLOAT) - 1.0; \n        \tbits += floor(fragCoord.xyxy + 255.0);\n        #else\n        \tbits.xy += (fragCoord.xy + 255.0);\n        \tbits.z += (fragCoord.x + fragCoord.y);\n        \tbits.w += fragCoord.x * fragCoord.y;\n        #endif\n        \n        bits = mod(bits, exp2(BITS_PER_FLOAT));\n    }\n    \n    bool feedback = Feedback(bits);\n    \n    bits = ShiftLeft(bits, feedback);\n    \n    fragColor = bits;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}