{
    "Shader": {
        "info": {
            "date": "1702496869",
            "description": ".",
            "flags": 0,
            "hasliked": 0,
            "id": "DtVfWK",
            "likes": 7,
            "name": "cube planet v1",
            "published": 3,
            "tags": [
                "cube",
                "space",
                "planet"
            ],
            "usePreview": 0,
            "username": "dkaraush",
            "viewed": 199
        },
        "renderpass": [
            {
                "code": "float cube(vec3 p, float r) {\n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nmat4 rotation3d(vec3 axis, float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat4(\n    oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n    0.0,                                0.0,                                0.0,                                1.0\n  );\n}\n\nvec3 scenerotate(vec3 pos) {\n    return (rotation3d(vec3(1.0, 0.5, 1.0), 1.0 + iTime / 10.0) * vec4(pos, 1.0)).xyz; \n}\nvec3 cubepos(vec3 pos) {\n    return scenerotate(pos - vec3(0.0, 0.0, 5.0));\n}\n\nfloat scene(vec3 pos) {\n    vec3 p = cubepos(pos);\n   return mix(cube(p, 1.5), length(p) - 2.0, (sin(iTime) + 1.0) / 2.0);\n}\n\nvec3 normal(vec3 p) {\n    float EPSILON = 0.001;\n    return normalize(vec3(\n        scene(p + vec3(EPSILON, 0.0, 0.0)),\n        scene(p + vec3(0.0, EPSILON, 0.0)),\n        scene(p + vec3(0.0, 0.0, EPSILON))\n    ) - scene(p));\n}\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nvec3 world(vec3 pos) {\n    //if (iMouse.z <= 0.0) {\n    //    const float S = 100.;\n    //    pos = ceil((pos - 0.1) * S) / S;\n    //}\n    pos = mix(pos, normalize(pos), .5 * (1.0 - length(pos)));\n    \n    float height = 0.0;\n    float ns = 0.0;\n    \n    vec3 apos = abs(pos);\n    float mx = max(max(apos.x - apos.y - apos.z, apos.y - apos.x - apos.z), apos.z - apos.x - apos.y) / 1.5;\n    mx = mix(.8, 1., mx);\n    \n    height += (.08 + noise(pos * 1.0) * mx) * 3.; ns += 3.;\n    height += (.08 + noise(pos * 4.0) * mx) * 5.; ns += 5.;\n    height += (.1 + noise(pos * 4.5) * mx) * 4.; ns += 4.;\n    height += noise(pos * 5.0) * 2.; ns += 2.;\n    height += noise(pos * 10.0) * .5; ns += .5;\n    height += noise(pos * 20.0) * .5; ns += .5;\n    height += noise(pos * 30.0) * .5; ns += .5;\n    height += noise(pos * 40.0) * .5; ns += .5;\n    height += noise(pos * 50.0) * .5; ns += .5;\n    //height += noise(pos * 60.0) * .5; ns += .5;\n    //height += noise(pos * 70.0) * .5; ns += .5;\n    \n    height /= ns;\n    \n    const vec3 SNOW = vec3(1.0);\n    const vec3 STONE =  vec3(.68627, .68627, .68627); // #AFAFAF\n    const vec3 GRASS2 = vec3(.05098, .57254, .10196); // #0D921A\n    const vec3 GRASS1 = vec3(.07058, .79215, .14117); // #12CA24\n    const vec3 SAND =   vec3(.98431, .89411, .08627); // #12CA24\n    const vec3 WATER1 = vec3(.23921, .58431, .98823); // #3D95FC\n    const vec3 WATER2 = vec3(.17254, .43137, .73725); // #2C6EBC\n    \n    if (height < 0.5) {\n        return mix(WATER2, WATER1, height / .5);\n    } else if (height < 0.52) {\n        return SAND;\n    } else if (height > 0.9) {\n        return SNOW;\n    } else if (height > 0.85) {\n        return STONE;\n    }\n    return mix(GRASS1, GRASS2, (height - .5) / .52);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.y;\n    uv.x -= .5 * (iResolution.x / iResolution.y - 1.);\n\n    vec3 pos = vec3(0.0);\n    vec3 dir = normalize(vec3(uv.x - .5, uv.y - .5, 1.));\n    \n    vec3 p = pos;\n    float dist = 0.0;\n    float lastdist = 0.0;\n    for (int i = 0; i < 42; ++i) {\n        lastdist = scene(p);\n        dist += lastdist;\n        if (lastdist <= 0.0) {\n            break;\n        }\n        p += dir * lastdist;\n    }\n    \n    if (lastdist <= 0.5) {\n        vec4 color = vec4(world(cubepos(p)), 1.0);\n        vec3 normal = normal(p);\n\n        const vec3 lightPos = vec3(0.0, 0.0, -5.0);\n        vec3 lightDir = normalize(scenerotate(lightPos) - scenerotate(p));\n        float ambient = 0.3;\n        float diffuse = 0.7 * max(dot(normal, lightDir), 0.0);\n\n        fragColor = color * (ambient + diffuse);\n    } else {\n        fragColor = vec4(0.0);\n        \n        float starnoise = noise(normalize(cubepos(pos - p)) * 550.0);\n        starnoise *= starnoise;\n        starnoise *= starnoise;\n        const float starthreshold = .85;\n        if (starnoise > starthreshold) {\n            fragColor = vec4(2.0 * (starnoise - starthreshold) / (1. - starthreshold));\n        }\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}