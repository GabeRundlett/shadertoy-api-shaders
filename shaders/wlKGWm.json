{
    "Shader": {
        "info": {
            "date": "1579234779",
            "description": "a bunch of spheres",
            "flags": 32,
            "hasliked": 0,
            "id": "wlKGWm",
            "likes": 26,
            "name": "a bunch of spheres",
            "published": 3,
            "tags": [
                "dof",
                "glass",
                "caustics",
                "bloom",
                "pathtracing",
                "depthoffield",
                "aperture"
            ],
            "usePreview": 0,
            "username": "loicvdb",
            "viewed": 909
        },
        "renderpass": [
            {
                "code": "vec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 bloom(float scale, float threshold, vec2 fragCoord){\n    float logScale = log2(scale)+1.0;\n    vec3 bloom = vec3(0);\n    for(int y = -1; y <= 1; y++)\n        for(int x = -1; x <= 1; x++)\n            bloom += textureLod(iChannel0, (fragCoord+vec2(x, y) * scale)/iResolution.xy, logScale).rgb;\n    \n    return max(bloom/9.0 - vec3(threshold), vec3(0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    \n    vec3 bloomSum = bloom(.02 * iResolution.y, .5, fragCoord) * .2\n        \t\t  + bloom(.10 * iResolution.y, .1, fragCoord) * .2;\n    \n    fragColor = vec4(ACESFilm(col + bloomSum), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//uncomment this line to give very pixel the same seed on each frame\n//#define CONST_SEED\n\n\n\n#define Pi 3.14159265359\n\n#define MaxSteps 200\n#define MaxBounces 50\n#define MaxDist 10.0\n#define MinDist .001\n#define SPPPerFrame 2\n\n#define LightIndex 1\n#define PlaneIndex 2\n#define SpheresIndex 3\n\n\nvec3 CamPos = vec3(0, .75, -3);\nvec3 CamRot = vec3(.3, 0., 0.);\nfloat CamFocalLength = 1.;\nfloat CamFocalDistance = 3.;\nfloat CamAperture = .05;\nfloat CamLensDistortion = .8; //positive = barrel, negative = pincushion, zero = none\n\nvec3 LightPos = vec3(0., 1., 0.);\nvec3 LightColor = vec3(.7, .5, .3) * 250.;\nfloat LightRadius = .2;\n\nvec3 SpheresColor = vec3(.7, .8, 1.);\nfloat SpheresRadius = .1;\nfloat SpheresIoR = 1.45;\n\nvec3 PlaneColor = vec3(1.);\n\n\nfloat seed;\n\nfloat randomFloat(){\n    return fract(sin(seed++)*43758.54536156);\n}\n\nvec2 roundTo(vec2 v, vec2 p){\n    return p*floor(v/p+.5);\n}\n\nvec2 polar2Cartesian(vec2 pos){\n    return vec2(cos(pos.x)*pos.y, sin(pos.x)*pos.y);\n}\n\nvec2 cartesian2Polar(vec2 pos){\n    return vec2(atan(pos.y, pos.x), length(pos));\n}\n\nfloat vornoi(vec3 pos){\n    \n    vec2 center = polar2Cartesian(roundTo(cartesian2Polar(pos.xz), vec2(Pi*2./50., .5)));\n    return length(vec3(center.x, 0., center.y) - pos);\n}\n\nfloat deSpheres(vec3 pos){\n    return vornoi(pos) - SpheresRadius;\n}\n\nfloat dePlane(vec3 pos){\n    return pos.y+SpheresRadius+2.*MinDist;\n}\n\nfloat deLight(vec3 pos){\n    return length(pos-LightPos)-LightRadius;\n}\n\nfloat distanceEstimation(vec3 pos, out int materialIndex){\n    float deS = deSpheres(pos);\n    float deP = dePlane(pos);\n    float deL = deLight(pos);\n    float de = min(min(deS, deP), deL);\n    if(deS == de)\n        materialIndex = SpheresIndex;\n    else if(deP == de)\n        materialIndex = PlaneIndex;\n    else\n        materialIndex = LightIndex;\n    return de;\n}\n\nfloat distanceEstimation(vec3 pos){\n    int placeHolder;\n    return distanceEstimation(pos, placeHolder);\n}\n\nmat3 rotationMatrix(vec3 rotEuler){\n    float c = cos(rotEuler.x), s = sin(rotEuler.x);\n    mat3 rx = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    c = cos(rotEuler.y), s = sin(rotEuler.y);\n    mat3 ry = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    c = cos(rotEuler.z), s = sin(rotEuler.z);\n    mat3 rz = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    \n    return rz * rx * ry;\n}\n\n\nvec3 ortho(vec3 v) {\n  return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\n//could've used a simpler approach since it's only used for the plane (with a normal of [0,1,0])\nvec3 getCosineWeightedSample(vec3 dir) {\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = vec2(randomFloat(), randomFloat());\n\tr.x = r.x * 2.0 * Pi;\n\tr.y = pow(r.y, .5);\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;\n}\n\n//not the most efficient technique but I mean it's only used once per bounce\nvec3 normalEstimation(vec3 pos){\n  vec3 xDir = vec3(MinDist, 0, 0);\n  vec3 yDir = vec3(0, MinDist, 0);\n  vec3 zDir = vec3(0, 0, MinDist);\n  return normalize(vec3(distanceEstimation(pos + xDir),\n\t  \t\t\t\t\tdistanceEstimation(pos + yDir),\n  \t\t\t\t\t\tdistanceEstimation(pos + zDir))\n\t\t\t\t - vec3(distanceEstimation(pos)));\n}\n\nfloat fresnel(vec3 dir, vec3 normal, float ior) {\n  float cosi = dot(dir, normal);\n  float etai = 1.0;\n  float etat = ior;\n  if (cosi > 0.0) {\n    float tmp = etai;\n    etai = etat;\n    etat = tmp;\n  }\n  float sint = etai / etat * sqrt(max(0.0, 1.0 - cosi * cosi));\n  if (sint >= 1.0) return 1.0;\n  float cost = sqrt(max(0.0, 1.0 - sint * sint));\n  cosi = abs(cosi);\n  float sqrtRs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost));\n  float sqrtRp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost));\n  return (sqrtRs * sqrtRs + sqrtRp * sqrtRp) / 2.0;\n}\n\nbool trace(inout vec3 pos, in vec3 dir, in float dSign, out int materialIndex){\n    \n    for(int i = 0; i < MaxSteps; i++){\n        float dist = distanceEstimation(pos, materialIndex);\n        if(dSign*dist > MaxDist) return false;\n        if(dSign*dist < MinDist) return true;\n        pos += dir*dSign*dist;\n    }\n    return false;\n}\n\nvec3 pathTrace(vec3 pos, vec3 dir){\n    \n    vec3 abso = vec3(1.);\n    \n    float dSign = sign(distanceEstimation(pos));\n    int materialIndex;\n    for(int i = 0; i < MaxBounces; i++){\n        if(!trace(pos, dir, dSign, materialIndex)) break;\n        if(materialIndex == LightIndex) return i==0 ? vec3(0.) : LightColor*abso;\n        vec3 normal = normalEstimation(pos);\n        float dist = distanceEstimation(pos);\n        if(materialIndex == PlaneIndex){\n            abso *= PlaneColor;\n            dir = getCosineWeightedSample(normal);\n        }\n        // if you're scared of branching close your eyes for a second\n        if(materialIndex == SpheresIndex){\n            if(randomFloat() > fresnel(dir, normal, SpheresIoR)){\n            \tabso *= SpheresColor;\n                bool d = dot(dir, normal) < 0.;\n                vec3 n = d ? normal : -normal;\n                float etai = d ? 1./SpheresIoR : SpheresIoR;\n               \tdir = refract(dir, n, etai);\n            } else {\n                dir = reflect(dir, normal);\n            }\n        }\n        dSign = dot(dir, normal) < 0. ? -1. : 1.;\n        pos += dSign * 2. * MinDist * normal;\n    }\n    return vec3(0.);\n}\n\n//n-blade aperture\nvec2 sampleAperture(int nbBlades, float rotation){\n    \n    float alpha = 2.0*Pi / float(nbBlades);\n    float side = sin(alpha/2.0);\n    \n    int blade = int(randomFloat() * float(nbBlades));\n    \n    vec2 tri = vec2(randomFloat(), -randomFloat());\n    if(tri.x+tri.y > 0.0) tri = vec2(tri.x-1.0, -1.0-tri.y);\n    tri.x *= side;\n    tri.y *= sqrt(1.0-side*side);\n    \n    float angle = rotation + float(blade)/float(nbBlades) * 2.0 * Pi;\n    \n    return vec2(tri.x * cos(angle) + tri.y * sin(angle),\n                tri.y * cos(angle) - tri.x * sin(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    #ifdef CONST_SEED\n    \tseed = mod(iTime, 184.3158915);\n    #else\n    \tseed = mod(fragCoord.x*.6868628+fragCoord.y*.6595975+iTime, 184.3158915);\n    #endif\n    \n    \n    vec2 uv = (fragCoord+vec2(randomFloat(), randomFloat())-iResolution.xy/2.0) / iResolution.y;\n    \n    \n    vec3 focalPoint = vec3(uv * CamFocalDistance / CamFocalLength, CamFocalDistance);\n    vec3 aperture = CamAperture * vec3(sampleAperture(6, 0.0), 0.0);\n    vec3 rayDir = normalize(focalPoint-aperture);\n    \n    rayDir.xy /= pow(rayDir.z, CamLensDistortion);\n    rayDir = normalize(rayDir);\n    \n    mat3 CamMatrix = rotationMatrix(CamRot);\n\n    rayDir *= CamMatrix;\n    aperture *= CamMatrix;\n    \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if(iMouse.w > 0.) fragColor.a = 0.;\n    for(int i = 0; i < SPPPerFrame; i++){\n        fragColor.a++;\n        fragColor.rgb = mix(fragColor.rgb, pathTrace(CamPos+aperture,rayDir), 1./fragColor.a);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}