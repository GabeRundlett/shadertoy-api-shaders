{
    "Shader": {
        "info": {
            "date": "1593081416",
            "description": "Converted from a liveshading session that happened during the Pancake Conference 2020.\nNot very optimal, tons of artefacts, but was fun to do.\nhttps://psenough.github.io/pancake/",
            "flags": 0,
            "hasliked": 0,
            "id": "wtXcW2",
            "likes": 16,
            "name": " Pancake Conf 2020 LiveShading",
            "published": 3,
            "tags": [
                "raymarching",
                "distancefield",
                "liveshading"
            ],
            "usePreview": 0,
            "username": "Alkama",
            "viewed": 599
        },
        "renderpass": [
            {
                "code": "const float pi=acos(-1.0);\nfloat t,st,m;\n#define sat(a) clamp(a,0.,1.)\nvec2 amod(vec2 p,float m) { float a=mod(atan(p.x,p.y),m)-m*.5; return vec2(cos(a),sin(a))*length(p); }\nmat2 rot(float a) { float c=cos(a),s=sin(a); return mat2(c,s,-s,c); }\nfloat sphere(vec3 p, float r) { return length(p)-r; }\nfloat caps(vec3 p, float h, float r) { p.y-=clamp(p.y,0.,h); return length(p)-r; }\n///////////////////////////////////////////////////////////////////\n// Simplex  Noise 2D (by IQ): https://www.shadertoy.com/view/Msf3WH\nvec2 hash( vec2 p ) {\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\nfloat fnoise(vec2 uv) {\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float f  = 0.5000*noise( uv ); uv = m*uv;\n    f += 0.2500*noise( uv ); uv = m*uv;\n    f += 0.1250*noise( uv ); uv = m*uv;\n    f += 0.0625*noise( uv ); uv = m*uv;\n    return f;\n}\n///////////////////////////////////////////////////////////////////\nfloat scene(vec3 p) {\n  if(length(p)-1.5>.1) return .1;\n  float nz=fnoise(p.xz*8.)*.0001;\n\n  float o=100.;\n  vec3 pp=p;\n  pp*=vec3(1,10.,1);\n  o=min(o,sphere(1.02*pp, 1.)*.1+nz*2.);\n  pp-=vec3(0,1.1+.4*sin(t*6.),0); o=min(o,sphere(1.12*pp, 1.)*.1+nz*6.);\n  pp-=vec3(0,1.1+.4*sin(t*4.),0); o=min(o,sphere(1.1*pp, 1.)*.1+nz*6.);\n  pp-=vec3(0,1.1+.4*sin(t*10.),0); o=min(o,sphere(1.2*pp, 1.)*.1+nz*4.);\n  pp-=vec3(0,1.1+.0*sin(t*4.),0); o=min(o,sphere(1.2*pp, 1.)*.1+nz*4.);\n  vec3 p2=p;\n  p2.xz=amod(p2.xz,pi*.01);\n  p2.xy*=rot(-pi*.34);\n  p2 -= vec3(.55,0,0);\n  float plate=caps(p2,1.2-.05*sin(p.x*p.y*p.z*10.),.05-.01*sin(p.x*p.z*20.));\n  if(plate<o) m=5.;\n  return min(o,plate);\n}\nvec3 camdir(vec2 uv, vec3 og, vec3 tg, float z) {\n  vec3 f=normalize(tg-og);\n  vec3 s=normalize(cross(vec3(.3*sin(t+sin(st)),1,0),f));\n  vec3 u=normalize(cross(f,s));\n  return normalize(f*z+uv.x*s+uv.y*u);\n}\nvec3 normal(vec3 p) {\n  vec2 e=vec2(.001,0);\n  return normalize(scene(p)-vec3(scene(p-e.xyy),scene(p-e.yxy),scene(p-e.yyx)));\n}\nfloat pales(vec2 uv, float screen, float number) {\n  uv*=rot(-t*screen);\n  return floor(smoothstep(.1,.2,cos(atan(uv.y,uv.x)*number)));\n}\nvec4 march(vec3 og, vec3 dir, int it, float tr, float mx) {\n  float d=0.;\n  vec3 p=og;\n  for(int i=0; i<it; i++) {\n    float h=scene(p)*.8;\n    if(abs(h)<tr || d>mx) break;\n    d+=h;\n    p+=dir*h;\n  }\n  return vec4(p,d);\n}\nfloat shadow(vec3 p, vec3 lp) {\n  vec3 ldir=normalize(lp-p);\n  float ldist=length(lp-p);\n  float d=march(p,ldir,100,.0001,5.).w;\n  if(d<ldist) {\n    return .5;\n  } else {\n    return 1.;\n  }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord.xy / iResolution.xy - .5) * vec2(iResolution.x/iResolution.y, 1.);\n\n  t = mod(.4*iTime,10.*pi);\n  float ft=floor(t);\n  float dt=fract(t);\n  st=ft+dt*dt;\n  m=0.;\n\n  vec2 uv2 = uv;\n  uv2.xy+=.4*vec2((sin(st)+.2*sin(t*2.)),sin(st*.5));\n  vec3 bg=vec3(0);\n  bg+=pales(uv2,.4,30.);\n  bg-=pales(uv2,.2,28.);\n  bg+=pales(uv2,-.6,20.);\n  bg-=pales(uv2,-.3,18.);\n  bg=mix(vec3(1.,.9, .5),vec3(1.,.4, .1),sat(bg));\n  float ccc=1.-length(uv2*(1.+.2*sin(t*8.)));\n  bg+=ccc;\n  bg += .05*step(.9,bg.ggg);\n  vec3 col=bg;\n  \n  vec3 eye=3.*vec3(.1,.35,.1);\n  eye += 2.*vec3(sin(st)+.2*sin(t*2.),.2*sin(st*.5),cos(st-sin(t)));\n  vec3 target=vec3(.2*sin(st*4.),.1*sin(st*2.),.2*cos(st));\n  vec3 dir=camdir(uv,eye,target,.75);\n  \n  vec3 lp=vec3(1,3,-2);\n  lp.xz+=1.5*vec2(sin(t*8.),cos(t*6.));\n  \n  vec4 hit=march(eye,dir,400,.001,5.);\n  float d=hit.w;\n  if(d<5.){\n    vec3 p=hit.xyz;\n    vec3 n=normal(p);\n    vec3 ld=normalize(lp-p);\n    float diff=abs(dot(n,ld));\n    if(m==0.) {\n      float miaou=smoothstep(.96,1.,abs(n.y));\n      col=diff*mix(vec3(1.,.9,.5),vec3(1.,.4,.1),miaou);\n      col-=.5*pow(.5+.5*fnoise(p.xz*(5.-p.y)), 4.);\n    } else {\n      float spec=sat(pow(abs(dot(dir,reflect(ld,n))),50.));\n      float fres=1.-sat(pow(abs(1.-dot(n,-dir)),5.));\n      col=sat(vec3(.8+spec)*fres)*cos(dir);\n    }\n    col*=shadow(p,lp);\n  }\n    \n  fragColor = vec4(pow(col,vec3(1./2.2)),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}