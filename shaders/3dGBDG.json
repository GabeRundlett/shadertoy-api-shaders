{
    "Shader": {
        "info": {
            "date": "1607799297",
            "description": "Recreation of \"Blob\" by Henrik Rydgard from [url=https://webglsamples.org/blob/blob.html]https://webglsamples.org/blob/blob.html[/url].",
            "flags": 0,
            "hasliked": 0,
            "id": "3dGBDG",
            "likes": 6,
            "name": "Blob - WebGLSamples",
            "published": 3,
            "tags": [
                "blob",
                "recreation",
                "webglsamples"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 184
        },
        "renderpass": [
            {
                "code": "/*\nRecreation of \"Blob\" by Henrik Rydgard: https://webglsamples.org/blob/blob.html\nI hope to recreate more too :)\n\nNo more fishy specular lighting now!\n*/\n\n#define NUMBER_OF_BLOBS 10.0\n\n#define SIN_15 0.2588190451\n#define COS_15 0.96592582628\n\n// Inigo Quilez's polynomial smooth minimum from https://iquilezles.org/articles/smin:\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat mapScene(in vec3 p) {\n    p.yz *= mat2(COS_15, SIN_15, -SIN_15, COS_15);\n    float c = cos(0.25 * iTime), s = sin(0.25 * iTime);\n    p.xz *= mat2(c, -s, s, c);\n\n    vec3 q = abs(p + vec3(0.0, 3.0, 0.0)) - vec3(8.0, 0.25, 8.0);\n    float scene = max(q.x, max(q.y, q.z));\n    for (float blob=0.0; blob < NUMBER_OF_BLOBS; blob++) {\n        float s1 = 0.2 * blob, s2 = cos(blob), s3 = sin(blob);\n        vec3 position = 5.0 * vec3(sin(s1 * iTime) * cos(s1 * iTime), cos(s2 * iTime), sin(s3 * iTime));\n        scene = smin(scene, length(p - position) - 1.5, 2.0);\n    }\n\n    return scene;\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),\n                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),\n                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    fragColor = vec4(0.24375, 0.16125, 0.07875, 1.0);\n    float dt = 0.0;\n    for (int iter=0; iter < 250; iter++) {\n        vec3 p = ro + rd * dt;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n            vec3 r = reflect(l, n);\n            fragColor.rgb = 0.5 * max(0.0, dot(n, l)) + 0.5 * vec3(0.824, 0.706, 0.549);\n            fragColor.rgb += 0.5 * pow(max(0.0, dot(r, rd)), 16.0);\n            break;\n        }\n\n        if (dt > 100.0) {\n            break;\n        }\n\n        dt += d;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}