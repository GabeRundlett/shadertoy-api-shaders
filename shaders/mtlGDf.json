{
    "Shader": {
        "info": {
            "date": "1672606176",
            "description": "some genuary loop doodling...",
            "flags": 0,
            "hasliked": 0,
            "id": "mtlGDf",
            "likes": 50,
            "name": "Genuary1 - perfect lada loop",
            "published": 3,
            "tags": [
                "loop",
                "cars",
                "lada",
                "genuary"
            ],
            "usePreview": 1,
            "username": "flockaroo",
            "viewed": 790
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  lada taigaperfect loop - genuary1\n//\n\n#define LOOPING\n\n#define RandTex iChannel2\n \n////////////////////////\n//// quaternions, sdf's, helper funcs\n////////////////////////\n\n#define PI  3.14159265359\n#define PI2 6.28318530718\n#define PIH 1.57079632679\n\n#define ROTM(ang) mat2(cos(ang-vec2(0,PIH)),-sin(ang-vec2(0,PIH)))\n\n//#define ENABLE_MATERIALS \n#ifdef ENABLE_MATERIALS\n#define SET_PREV_MAT(x) if(abs(d-d_mat)>.0001) mat=(x); d_mat=d;\n#else\n#define SET_PREV_MAT(x) \n#endif\n\n\nvec3 rotZ(float ang,vec3 v) { return vec3(ROTM(ang)*v.xy,v.z); }\n\nvec2 uvSmooth(vec2 uv,vec2 res)\n{\n    // no interpolation\n    //return uv;\n    // sinus interpolation\n    return uv+1.*sin(uv*res*PI2)/(res*PI2);\n    // iq's polynomial interpolation\n    vec2 f = fract(uv*res);\n    return (uv*res+.5-f+3.*f*f-2.0*f*f*f)/res;\n}\n\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return (v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v ));\n}\n\nvec4 angVec2Quat(vec3 ang)\n{\n    float lang=length(ang);\n    return vec4(ang/lang,1) * sin(vec2(lang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\nvec4 axAng2Quat(vec3 ax, float ang)\n{\n    return vec4(normalize(ax),1)*sin(vec2(ang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\n// iq's sdf primitives\nfloat distBox( vec3 p, vec3 halfSize)\n{\n    vec3 q = abs(p) - halfSize;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat distBoxR( vec3 p, vec3 halfSize, float r) { return distBox( p, halfSize-r ) - r ; }\n\nfloat distCyl( vec3 p, float r, float h )\n{\n  vec2 d = vec2( length(p.xy)-r, abs(p.z) - h*.5 );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat distCylR( vec3 p, float r, float h, float R )\n{\n  vec2 d = vec2( length(p.xy)-(r-R), abs(p.z) - (h*.5-R) );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0))-R;\n}\n\nfloat distTorus(vec3 p, float R, float r)\n{\n    return length(p-vec3(normalize(p.xy),0)*R)-r;\n}\n\nfloat dDirLine(vec3 p, vec3 c, vec3 dir, float l)\n{\n    p-=c;\n    dir=normalize(dir);\n    float dp=dot(p,dir);\n    //return length(p-dp*dir);\n    return max(max(length(p-dp*dir),-dp),dp-l);\n}\n\n// iq's exponantial smooth-min func\nfloat smin( float a, float b, float k )\n{\n    k=3./k;\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n// iq's polynomial smooth-min func\nfloat smin_( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// flatness: // 0->sphere, 100-> nearly cylindric\nfloat distTire(vec3 p, float r, float w, float h, float flatness)\n{\n    float l=length(p.xy);\n    //p=abs(p);\n    float d=1000.;\n    // outer sphere\n    float rfl=r*(1.+flatness);\n    d=min(d,length(vec2(l+rfl-r,p.z))-rfl);\n    float rz=-(rfl-r)+sqrt(rfl*rfl-p.z*p.z);\n    //d=min(d,l-rz);\n    float ang = atan(p.x,p.y);\n    p.z+=cos(ang*64.)*w*.01*smoothstep(.87*r,1.*r,l);\n    // main torus\n    d=max(d,length(vec2(l-r+h*.5,p.z))-w*.5);\n    //d=max(d,-l+r*.61);\n    float w_l=sqrt(w*w-h*h); // w_laufflaeche\n    float dz=.243*w_l;\n    float zfr=mod(p.z,dz);\n    float z=p.z-zfr+dz*.5;\n    // rillen\n    d=max(d,-length(vec2(l-rz,p.z-z))+dz*.2);\n    // rim radius\n    d=max(d,-(l-(r-h)));\n    return d;\n}\n\nfloat distRim(vec3 p, float r, float w, float sh)  // outer rim radius, rim width;\n{\n    vec3 p0=p;\n    p.z=abs(p.z);\n    float ang0 = atan(p.y,p.x);\n\n    float d=1000.,d2,d3;\n    float dmain=length(p.xy)-r-sh;\n    float dplane=-p.z+w*.5;\n    d=-smin_(dplane,-dmain,.005);\n    \n    d2=-smin_(-(dmain+.005),-(dplane-.005),.01);\n    d=-smin_(-d,d2,.01);\n    \n    d2=-smin_(-(dmain+.02),-(dplane-.045),.01);\n    d=-smin_(-d,d2,.01);\n    \n    d2=dmain+.04;\n    d=-smin_(-d,d2,.01);\n    \n    dplane=-p0.z+w*.5;\n    d2=-smin_(-(dmain+.04),dplane+.015,.1);\n    float c5=cos(ang0*5.);\n    c5=-c5*.5+.5;\n    c5*=c5;\n    c5*=c5;\n    c5=1.-c5;\n    c5=mix(c5,0.,1.-clamp(((dmain+r+sh)-.045)/.03,0.,1.));\n    d3=-smin_(-(dmain+.115),-(dplane-.01*(.8+.5*c5)),.04);\n    d2=abs(-smin_(-d2,d3,.01))-.0015;\n    d2=max(d2,-p0.z-.01);\n    d=min(d,d2);\n    \n    float mang,ang;\n    float dang;\n\n    // rim holes\n    dang=PI2/12.;\n    mang=mod(ang0,dang);\n    ang=ang0-mang+dang*.5;\n    vec2 cs=cos(ang-vec2(0,PIH));\n    d=max(d,-distCyl(p-vec3(r*.65*cs*(1.+3.*p.z),0.),.085*r,w*1.5));\n    \n    p=p0-vec3(0,0,.07);\n    \n    // screw holes\n    dang=PI2/5.;\n    mang=mod(ang0+dang*.5,dang);\n    ang=ang0-mang+dang*.5;\n    d2=distCyl(p-vec3(r*.3*cos(ang-vec2(0,PIH)),w*.05),.016,w*.19);\n    // screws\n    d=min(d, d2+.005);\n\n    // axle\n    d=min(d, distCyl(p,.045-.01,w*.25-.01)-.01);\n    return d;\n}\n\nfloat distWheelDim(vec3 p, float w_mm, float h_perc, float rimD_inch, float shoulder_mm, float flatness)\n{\n    float w=w_mm*.001;\n    float h=w*h_perc/100.;\n    float d=10000.,d2;\n    float rrim=rimD_inch*.5*.0254;\n    d2=distTire(p, rrim+h, w, h, flatness );\n    d=min(d,d2);\n    float rimw=sqrt(w*w-h*h)+shoulder_mm*.001*2.5;\n    d2=distRim(p, rrim, rimw, shoulder_mm*.001 );\n    d=min(d,d2);\n    return d;\n}\n\n\nbool intersectBox(vec3 p, vec3 dir, vec3 size)\n{\n    size*=.5*sign(dir);\n\n    vec3 vmin = (-size-p)/dir;\n    vec3 vmax = ( size-p)/dir;\n    \n    float tmin=vmin.x, tmax=vmax.x;\n    \n    if ((tmin > vmax.y) || (vmin.y > tmax)) return false; \n    tmin=max(tmin,vmin.y);\n    tmax=min(tmax,vmax.y);\n \n    if ((tmin > vmax.z) || (vmin.z > tmax)) return false; \n    tmin=max(tmin,vmin.z);\n    tmax=min(tmax,vmax.z);\n \n    return true; \n}\n\nvec4 getRand(vec2 coord)\n{\n    vec4 c=vec4(0);\n    c+=texture(RandTex,coord+.003*iTime);\n    c+=texture(RandTex,coord/2.+.003*iTime)*2.;\n    c+=texture(RandTex,coord/4.+.003*iTime)*4.;\n    c+=texture(RandTex,coord/8.+.003*iTime)*8.;\n    return c/(1.+2.+4.+8.);\n}\n\n#define FloorZ -.66\n//#define HomePos vec3(0,0,-FloorZ*1.5)\n//#define CamDist0 18.\n\n// environment just a sky and some dark floor\nvec4 myenv(vec3 pos, vec3 dir, float period_)\n{\n#ifdef CUBEMAP    \n    return texture(iChannel1,dir.yzx);\n#endif\n    vec3 sun = normalize(vec3(1,1,1));\n    vec3 skyPos=pos+dir/abs(dir.z)*(120.-pos.z);\n    float cloudPat=(1.+.4*(getRand(skyPos.xy*.0002).x-.5));\n    vec3 colHor=vec3(.3,.4,.5)+.4;\n    float dirl=dot(dir,sun);\n    vec3 clouds=mix(vec3(1.)*(1.-2.*dirl),vec3(.8,1.,1.2),cloudPat);\n    vec3 colSky=mix(vec3(1.5,.75,0.)*3.,clouds,clamp(7.*dir.z,0.,1.));\n    //colSky=mix(colSky,vec3(1),cloudPat);\n    //colSky*=mix(1.,cloudPat,dir.z*5.);\n    vec3 colFloor=vec3(.45);\n    \n    vec3 col=mix(colSky,colFloor,1.-smoothstep(-.01,.01,dir.z));\n    col=mix(colHor,col,clamp(abs(dir.z*5.)-.1,0.,1.));\n    \n    col*=.9;\n    \n    //float sunang=acos(dot(dir,sun));\n    float sunang=atan(length(cross(dir,sun)),dot(dir,sun));\n    col+=15.*clamp(2.*exp(-sunang/.02),0.,1.);\n    col+=2.*clamp(2.*exp(-sunang/.20),0.,1.);\n    \n    return vec4(col,1);\n}\n\n\n\n#define Res vec2(iResolution.xy)\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n\n#define enable_glass true\n\nvec3 Delta=vec3(-.769,-1.073,-.669);\n\n#define LoopNumFrames 240\n\nfloat distCar(vec3 p)   \n{\n    p+=Delta;\n    p=transformVecByQuat(p,axAng2Quat(vec3(1,0,0),.023));\n    float d=100000.,d2;\n    vec3 p00=p;\n    p.x=abs(p.x);\n    vec3 p0=p;\n    vec3 psq=p*p;\n\n    #ifdef ENABLE_MATERIALS \n    float d_mat=1001., mat=-1.;\n    #endif\n    SET_PREV_MAT(BG);\n    \n    vec3 frontWheelPos=vec3(1.44*.5,1.25,-.45);\n    vec3 rearWheelPos=vec3(1.42*.5,-1.05,-.5);\n    \n    //d=min(d,distBox(p-vec3(0,0,-.05),vec3(1.65,3.45,.7)*.5));\n    //d=min(d,distBox(p-vec3(0,-.5,.55),vec3(1.65,2.4,.55)*.5));\n    bool front = p0.y>0.; \n    vec3 pwheel = front?frontWheelPos:rearWheelPos;\n    // -- 15 ----- wheel cases (precalc) ------------\n    float dWheelcases=distCylR((p-pwheel+vec3(0,0,-.1-(front?-.018:.0))).zyx,.4,.7,.1);\n    \n    float wcext=.01+(p.z+.5)*.1;\n\n    // -- 0 ---------- main box -------------\n    d=min(d,\n          distBoxR(p-vec3(0,0,.2),\n                   vec3(1.63-(psq.y*psq.y*.1+1.)*psq.y*.01-psq.z*.521-smoothstep(0.25,0.35,p.z)*(p.z-.25)*.0\n                        +wcext*(1.-smoothstep(wcext*.3,wcext,dWheelcases))\n//                        +wcext*exp(-dWheelcases*dWheelcases/wcext/wcext)\n                        ,\n                        3.6- min(psq.z*psq.z*20.*step(0.,p.y),.1) - (psq.z+psq.x)*.1  -step(0.,-p.y)*smoothstep(0.,.2,p.z)*max(p.z-.2,0.)*1.1,\n                        1.3-psq.y*psq.y*psq.y*.015*(.5+.5*step(0.,-p.z))-step(0.,p.z)*(psq.x*.2+psq.y*.035+p.y*.04))*.5,\n                        .03-min(p.y*.03,0.)));\n    float dmainBox=d;\n    \n    // -- 1 ---------- hood/windshield cut -------------\n    float dwin =dot(p-vec3(0,1.5-psq.x*(.3-(p.z-.8)*.4),0.7)*.5,normalize(vec3(0,1.,1)));\n    float dhood=dot(p-vec3(0,1.5-psq.x*(2.-(p.y-.75)*1.),0.74-.1*(p.y-.75)*(p.y-.75))*.5,normalize(vec3(0,.07,1)));\n    //dwin=10000.;\n    d=-smin_(-d,-smin_(dwin,dhood,.03),max(.001,.05-.0*(p.y*.01)));\n    //d=-min(-d,-min(dwin,dhood));\n\n    float dwin2 =dot(p-vec3(0,1.64-psq.x*.3,0.7)*.5,normalize(vec3(0,1.5,1)));\n    float dhood2=dot(p-vec3(0,1.5,0.36)*.5,normalize(vec3(0,.04,1)));\n    d2=-min(-d,-min(dwin2,dhood2));\n    d+=exp(-abs(d2)/.006)*.006;\n    \n    p=p-vec3(0,0,-.01*psq.y);\n\n    // -------- absatz hood ---------------    \n    d2=distBoxR(p-vec3(0.,1.37,.3),vec3(.9,1,.5)*.5,.07);\n    d+=.015*(1.-smoothstep(-.015,.015,d2))*clamp(1.7-p0.y,0.,1.);\n    \n    // -- 2 ---------- side versenkung windows --------------\n    d2=distBoxR(p-vec3(.9-p.z*.2,0,.57),vec3(.1,3.25-p.z*.75,.59)*.5+.02,.15)-.02;\n    d=-smin_(-d,d2,.01);\n\n    SET_PREV_MAT(CARBODY);\n    \n    float dwincut=1000.;\n    // -- 3 ---------- side win rear -----------\n    p=p-vec3(0,-.88,.55);\n    d2=distBoxR(p,vec3(3.,.82-.8*(p.z)*step(0.,-p.y),.37)*.5,.063-p.y*.05);\n    //d+=clamp(-d2,0.,.01);\n    //d+=smoothstep(0.,1.,-d2/.01)*.01;\n    ////d+=exp(-abs(d2)/.006)*.006;\n#ifdef ENABLE_MATERIALS \n    //if(enable_glass) { SET_PREV_MAT(GLASS); }\n#endif\n    dwincut=min(dwincut,d2);\n    p=p0;\n\n    // -- 4 ---------- side stripe --------------\n    d2=distBox(p-vec3(0,0,.16-.01*(p.y+.4)*(p.y+.4)),vec3(3.,3.3,.07)*.5);\n    //d+=clamp(-d2,0.,.01);\n    d+=smoothstep(0.,1.,-d2/.01)*.01;\n\n    // -- 5 ---------- door -------------\n    d2=distBoxR(p-vec3(0,.1,.235),vec3(3.,1.03,1.09)*.5,.07-.1*(p.z+.3));\n    d2=-smin_(-(dwin+.03),-d2,.07);\n    d+=exp(-abs(d2)/.006)*.01;\n    SET_PREV_MAT(CARBODY);\n\n    // -- 6 ---------- side win front -----------\n    d2=-smin_(-d2-.05,p.z-.36,.03);\n    //d+=clamp(-d2,0.,.01);\n    //d+=smoothstep(0.,1.,-d2/.01)*.01;\n    ////d+=exp(-abs(d2)/.006)*.006;\n    dwincut=min(dwincut,d2);\n    \n    // -- 7 ---------- front window -----------\n    p=p0-vec3(0,0,.53);\n    //d2=distBoxR(p,vec3(1.4,5.,.37)*.5,.05);\n    d2=dmainBox+.065-psq.x*.1*p.z;\n    d2=-smin(-d2,dhood-.015,.05);\n    //d+=clamp(-d2,0.,.01);\n    //d+=smoothstep(0.,1.,-d2/.015)*.01;\n    dwincut=min(dwincut,d2);\n#ifdef ENABLE_MATERIALS \n    //if(enable_glass) { SET_PREV_MAT(GLASS); }\n#endif\n\n    // -- 8 ---------- rear window -----------\n    p=p0-vec3(0,-1.7,.5);\n    d2=distBoxR(p,vec3(1.15-p.z*.3,1.,.35)*.48,.07);\n    d+=smoothstep(0.,1.,-(d2-.03+.03*p.z)/.01)*.01;\n    SET_PREV_MAT(CARBODY);\n    //d+=smoothstep(0.,1.,-d2/.01)*.01;\n    dwincut=min(dwincut,d2);\n    //d=max(d,-d2);\n#ifdef ENABLE_MATERIALS \n    //if(enable_glass) { SET_PREV_MAT(GLASS); }\n#endif\n\n    // ------- bottom absatz ------------\n    d2=p0.z+.345;\n    d+=.02*min(exp2(-d2/.02),1.);\n\n    // -- 15 ----- wheel cases (apply) ------------\n    d=-smin_(-d,dWheelcases,.005);\n    \n    SET_PREV_MAT(p0.z<-.345?GUMMI:CARBODY);\n\n    // ------------- cut out interior, cutout windows, add windows + window lips\n    float d_inner=d+.06;\n    d=max(d,-d_inner); SET_PREV_MAT(BLACKPLASTIC); \n    d=-smin_(-d,dwincut,.01);\n    SET_PREV_MAT(CARBODY); \n    d=min(d,length(vec2(dwincut,d_inner-.045))-.01);\n    SET_PREV_MAT(GUMMI); \n    d=min(d,length(vec2(dwincut,d_inner-.045)+vec2(1,-1)*.008)-.0025);\n    SET_PREV_MAT(CHROME); \n    if(enable_glass) { d=min(d,d_inner-.045); SET_PREV_MAT(GLASS); }\n    \n    // -- 9 ---------- rear door -----------\n    p=p0-vec3(0,-1.7,.25);\n    d2=distBoxR(p,vec3(1.35-psq.z*.35,.5+p0.z*.5,.97)*.5,.07);\n    d+=exp(-abs(d2)/.006)*.01;\n\n    // -- 11 ---------- rear license plate box -----------\n    p=p0-vec3(0,-1.885,.04);\n    d2=distBoxR(p,vec3(.65+p.z*.3,.2,.2)*.5,.03);\n    d=max(d,-d2);\n    SET_PREV_MAT(CARBODY);\n    p=p0-vec3(0,-1.775,.14);\n    d2=distBoxR(p,vec3(.68,.05,.04)*.5,.005);\n    d=min(d,d2);\n\n    // -- 10 ---------- rear blinker -----------\n    p=p0-vec3(.68,-1.8,.0);\n    d2=distBoxR(p,vec3(.2-p.z*.2*step(0.,-p.x),.3,.3)*.5,.03);\n    d=min(d,d2);\n    d=max(d,dmainBox-.01);\n    SET_PREV_MAT(BLACKPLASTIC);\n    d-=smoothstep(.007,.01,-d2)*.001;\n    SET_PREV_MAT(p.z<0.06?(p.x>0.0?(p.z>-.05?GLASS:ORANGEGLASS):REDGLASS):REDGLASS);\n    \n    // -- 12 ---------- front blinker -----------\n    p=p0-vec3(.6,1.75,.15);\n    d2=distBoxR(p,vec3(.25,.095,.12)*.5,.03);\n    d=max(d,-d2);\n    SET_PREV_MAT(BLACKPLASTIC);\n    d=min(d,-smin_(-d2-.025,-p.y+.01,.01));\n    SET_PREV_MAT(p.x<0.03?ORANGEGLASS:GLASS);\n\n    // -- 13 ---------- grill -----------\n    p=p0-vec3(.0,1.78-psq.x*.05,-.05);\n    d2=distBoxR(p,vec3(1.48+.02-p.y*.3,.2,.265-psq.x*.03+.02-p.y*.3)*.5,.06-p.z*.15);\n    d=max(d,-d2);\n    // ----- einbuchtung rund um scheinwerfer -----\n    float d2b=-smin_(-d2,p.x-.48,.02);\n    vec2 pl=(p-vec3(.61,0,0)).xz; float lpl=length(pl);\n    float yo=mix(.02,max(-d2b-.016,0.)*.5,1.-exp2((-lpl+.1)/.0075));\n    d2=-smin_(-d2,-.1+lpl,.005);\n    d2=-smin_(-d2,-abs(p.y-.01)+.035-yo,.005);\n    // ----- cooling slits -----\n    vec3 pi=vec3(0,0,(clamp(floor(p.z/.029),-4.,3.)+.5)*.029);\n    d2=-smin_(-d2,distBox(p-pi,vec3(.96,.2,.02)*.5),.01);\n    // ----- lada logo -------\n    p.y-=.03;\n    d2=min(d2,distBoxR(p,vec3(.04+p.z*.1,.02,.07),.005));\n    d=min(d,d2);\n    SET_PREV_MAT(BLACKPLASTIC);\n\n    // ----- scheinwerfer -----\n    float lsph=length(p-vec3(.61,-.273-.03,0));\n    d=min(d,max(max(lsph-.3,-p0.y+1.65),lpl-.09));\n    SET_PREV_MAT(CHROME);\n\n    // -- 14 ---------- bumpers -----------\n    p=p0; p.y=abs(p.y);\n    p=p-vec3(0,1.87-.03*psq.x,-.25);\n    d2=distBoxR(p,vec3(1.62,.1,.1)*.5,.02);\n    d=min(d,d2);\n    SET_PREV_MAT(CHROME);\n    p-=vec3(.76-p.y*.15,-.065,0);\n    d2=distBoxR(p,vec3(.113,.25,.113)*.5,.02);\n    d2=max(d2,dot(p,vec3(-1,-.4,0))-.03);\n    d=min(d,d2);\n    SET_PREV_MAT(GUMMI);\n    \n    // ------- wheels, axes ------------\n    //d=max(d,-distCylR((p-rearWheelPos+vec3(0,0,-.1)).zyx,.4,.7,.1));\n    // ------- axes ------\n    #if 0\n    p=(p0-pwheel*vec3(0,1,1));\n#ifdef USE_SIMDATA\n    float leftSgn=sign(p00.x);\n    float rear=front?0.:1.;\n    vec3 wo=vec3(mix(WheelDistF,WheelDistR,rear)*.5,0,0);\n\n    // wheel offsets\n    vec4 qf=axAng2Quat(vec3(0,1,0),(WheelOffsFL-WheelOffsFR)/WheelDistF*leftSgn);\n    vec4 qr=axAng2Quat(vec3(0,1,0),(WheelOffsRL-WheelOffsRR)/WheelDistR*leftSgn);\n    vec4 axQuat=front?qf:qr;\n    float axOffs=mix(WheelOffsFR+WheelOffsFL,WheelOffsRR+WheelOffsRL,rear)*.5;\n\n    p=transformVecByQuat(p,axQuat);\n    p.z-=axOffs;\n#endif\n    d=min(d,distCylR(p.zyx,.12*(1.-.6*smoothstep(0.05,.2,p.x)),1.44,.05));\n    #endif\n    p=(p0-pwheel);\n\n    vec3 wo=vec3(0,0,0);\n#ifdef USE_SIMDATA\n    float leftSgn=sign(p00.x);\n    float rear=front?0.:1.;\n    wo=vec3(mix(WheelDistF,WheelDistR,rear)*.5,0,0);\n\n    // wheel offsets\n    vec4 qf=axAng2Quat(vec3(0,1,0),(WheelOffsFL-WheelOffsFR)/WheelDistF*leftSgn);\n    vec4 qr=axAng2Quat(vec3(0,1,0),(WheelOffsRL-WheelOffsRR)/WheelDistR*leftSgn);\n    vec4 axQuat=front?qf:qr;\n    float axOffs=mix(WheelOffsFR+WheelOffsFL,WheelOffsRR+WheelOffsRL,rear)*.5;\n    // wheel axis rot + offset\n    p=transformVecByQuat(p+wo,axQuat)-wo;\n    p.z-=axOffs;\n#endif\n    d=min(d,distCyl(p.zyx-vec3(0,0,-.72),.12*(1.-.6*smoothstep(0.05,.2,p.x+.72)),1.55));\n    SET_PREV_MAT(CHASSIS);\n#ifdef USE_SIMDATA\n    // steering rotation of front wheels\n    vec4 q=axAng2Quat(vec3(0,0,1),leftSgn*(1.-.1*leftSgn*sign(SteerAng))*-SteerAng*(front?1.:0.));\n    p=transformVecByQuat(p+vec3(.1,0,0),q)-vec3(.1,0,0);\n    // wheel rotations\n    float rot=-WheelRot.x*.7;\n    p=transformVecByQuat(p,axAng2Quat(vec3(1,0,0),rot));\n#endif\n#define PROPER_WHEELS\n#ifndef PROPER_WHEELS\n    d=min(d,distCylR(p.zyx,.35,.2,.05));\n#else\n    // newer viva ...broader tires\n    p.yz*=ROTM(-float(iFrame)/float(LoopNumFrames)*PI2*3.); \n    d=min(d, distWheelDim(p.yzx,185.,75.,16.,12.,.2));\n    // old niva\n    //d=min(d, distWheelDim(p.yzx,175.,80.,16.,12.,.2));\n#endif\n    SET_PREV_MAT(length(p.yz)<.215?CHROME:GUMMI);\n    \n#ifdef ENABLE_MATERIALS \n    return vec2(d,mat);\n#else\n    return d;\n#endif\n}\n\n\n/*float dist(vec3 pos)\n{\n    float fact=pow(100.,fract(-float(iFrame)/float(LoopNumFrames)));\n    pos*=fact;\n    float R=2.,r=.01;\n    float d=100000.;\n    \n    d=min(d,distCar(pos));\n    d=min(d,distCar((pos+Delta*00.)/100.)*100.);\n    d=min(d,distCar((pos+Delta*0000.)/10000.)*10000.);\n    \n    return d/fact;\n}*/\n\n// iq's superb compile optimization - thanks a lot!!\nfloat dist(vec3 pos)\n{\n    float fact=pow(100.,fract(-float(iFrame)/float(LoopNumFrames)));\n    pos*=fact;\n    float R=2.,r=.01;\n    float d=100000.;\n    \n    for( int i=min(0,iFrame); i<3; i++ )\n    {\n        float sca = pow(100.0,float(i));\n        d=min(d,distCar((pos+Delta*00.)/sca)*sca);\n    }\n    \n    return d/fact;\n}\n\n/*vec3 getGrad(vec3 p, float eps) \n{ \n    vec2 d=vec2(eps,0); \n    float d0=dist(p);\n    return vec3(dist(p+d.xyy)-d0,dist(p+d.yxy)-d0,dist(p+d.yyx)-d0)/eps; \n}*/\n\n// iq's superb compile optimization - thanks a lot!!\nvec3 getGrad(vec3 p, float eps) \n{ \n    vec3 n = vec3(0.0);\n    for( int i=min(0,iFrame); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*dist(p+eps*e);\n    }\n    return n;\n}\n\nfloat march(inout vec3 pos, vec3 dir)\n{\n    float eps=.003;\n    for(int i=0;i<120;i++)\n    {\n        float d=dist(pos);\n        pos+=dir*d*.6;\n        if (d<eps) return 1.;\n    }\n    return 0.;\n}\n\n#define MOUSE_PHI   (iMouse.x/Res.x*12.)\n#define MOUSE_THETA (iMouse.y/Res.y*12.)\n\nvoid getTrafo(inout vec3 pos, inout vec3 dir, vec2 fc)\n{\n    vec2 sc=(fc-Res*.5)/Res.x*2.;\n    float tanFOVh=1./2.5;\n    dir=normalize(vec3(0,0,-1./tanFOVh)+vec3(sc,0));\n    pos=vec3(0,0,6.1);\n    #ifdef LOOPING\n    pos.xy*=ROTM(-1.057-float(iFrame)/float(LoopNumFrames)*PI2);\n    dir.xy*=ROTM(-1.057-float(iFrame)/float(LoopNumFrames)*PI2);\n    #endif\n    float ph = MOUSE_PHI;\n    float th = MOUSE_THETA;\n    if (iMouse.x<1.) { \n        ph=3.6;\n        #ifdef LOOPING\n        ph=4.;\n        #endif\n        th=1.3;\n    }\n    pos.yz=ROTM(th)*pos.yz;\n    dir.yz=ROTM(th)*dir.yz;\n    pos.xy=ROTM(ph)*pos.xy;\n    dir.xy=ROTM(ph)*dir.xy;\n}\n\nvec4 ovlCol( vec2 fragCoord )\n{\n    vec4 col=vec4(0);\n    vec2 sc=(fragCoord-iResolution.xy*.5)/iResolution.x;\n    float m2sc=.205;\n    \n    float ph04=fract(MOUSE_PHI/PI*2.*.25)*4.;\n    float backFact =max(clamp(-3.+ph04,0.,1.),clamp(1.-ph04,0.,1.));\n    float sideFact =min(clamp( 0.+ph04,0.,1.),clamp(2.-ph04,0.,1.));\n    float frontFact=min(clamp(-1.+ph04,0.,1.),clamp(3.-ph04,0.,1.));\n    float sideFact2=min(clamp(-2.+ph04,0.,1.),clamp(4.-ph04,0.,1.));\n    sideFact=max(sideFact,sideFact2);\n    float scFact=sideFact2>0.?1.:-1.;\n    col+=sideFact *texture(iChannel0,(ROTM(.023*scFact)*sc*vec2(scFact,1))/Res0*556.+.5+vec2(-.033,.1));\n    col+=frontFact*texture(iChannel1,sc/Res1*556.+.5+vec2(-.252,.1));\n    col+=backFact *texture(iChannel1,sc/Res1*556.+.5+vec2(.26,.1));\n    col.xyz-=exp(-sc.x*sc.x/.001/.001);\n    col.xyz-=exp(-sc.y*sc.y/.001/.001);\n    vec2 sinsc=sin(sc/m2sc*2.*PI);\n    col.yz-=.3*exp(-sinsc.x*sinsc.x/.03/.03);\n    col.yz-=.3*exp(-sinsc.y*sinsc.y/.03/.03);\n    col.xz-=exp(-(sc.x-3.74*.5*m2sc)*(sc.x-3.74*.5*m2sc)/.001/.001);\n    col.xz-=exp(-(sc.x+3.74*.5*m2sc)*(sc.x+3.74*.5*m2sc)/.001/.001);\n    col.xz-=exp(-(sc.y-1.64*.5*m2sc)*(sc.y-1.64*.5*m2sc)/.001/.001);\n    col.xz-=exp(-(sc.y+1.64*.5*m2sc)*(sc.y+1.64*.5*m2sc)/.001/.001);\n    return col;\n}\n\nuniform float ovlFade;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 ovl=ovlCol( fragCoord );\n    vec3 pos,dir;\n    getTrafo(pos,dir,fragCoord);\n    float m=march(pos,dir); //m=1.;\n    vec3 left=normalize(cross(vec3(0,0,1),dir));\n    vec3 up  =normalize(cross(left,dir));\n    vec3 g=getGrad(pos,.0003);\n\n    float lg=length(g);\n    vec3 n=g/(lg+.000001);\n    \n    float ao=1.;\n    float sc=1.7,scmin=.01;\n    float df=dist(pos+n*scmin*.2)/(scmin*.2);\n    for(int i=0;i<30;i++)\n    {\n        float ao2=clamp(dist(pos+n*sc)/(sc/df),0.,1.);\n        ao*=mix(ao2,1.,\n        1.-sqrt(sc)*.2\n        );\n        sc*=.7;\n        if(sc<scmin) break;\n    }\n    ao*=m*.5+.5;\n    \n    fragColor.xyz=(n*.15+.85);\n    \n    vec3 R=reflect(dir,n);\n    vec4 refl=myenv(vec3(0),R,1.);\n    float fres=1.-abs(dot(R,n));\n    fres*=fres*fres;\n    fres=.1+.7*fres;\n    fragColor=mix(fragColor,refl*(ao*.35+.65),fres);\n    \n    fragColor.xyz*=ao;\n    fragColor=mix(clamp(fragColor,0.,1.),ovl,ovlFade);\n    \n    fragColor.w=1.;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}