{
    "Shader": {
        "info": {
            "date": "1455434688",
            "description": "Illustrating the effect of gamma space in shading. Without gamma correction on the left ; with gamma correction on the right (hint: the right is the one you want). Notice how the light adds up when the two spot lights intersect.\n\nClick and drag to control",
            "flags": 0,
            "hasliked": 0,
            "id": "lsVGzK",
            "likes": 7,
            "name": "Gamma correctness: lights",
            "published": 3,
            "tags": [
                "raytracing",
                "sphere",
                "gamma",
                "gammacorrection",
                "linear",
                "lights"
            ],
            "usePreview": 0,
            "username": "Zavie",
            "viewed": 1014
        },
        "renderpass": [
            {
                "code": "/*\n\nThis shader demonstrates the effect of gamma\ncorrection in rendering.\n\nInspired by:\nhttp://renderwonk.com/blog/index.php/archive/adventures-with-gamma-correct-rendering/\n\nMove the mouse to see the difference between\nshading with no gamma correction (on the left)\nand with gamma correction (on the right).\n\nSee also: https://www.shadertoy.com/view/llBGz1\n\n--\nZavie\n\n*/\n\n#define MAX_BOUNCES 2\nfloat gamma = 2.2;\n\n// ---8<----------------------------------------------------------------------\n// Material\n\nstruct Material\n{\n    vec3 c;\t\t// diffuse color\n    float f0;\t// specular color (monochrome)\n};\n\n// ---8<----------------------------------------------------------------------\n// Geometry\n\nstruct Ray\n{\n    vec3 o;\t\t// origin\n    vec3 d;\t\t// direction\n};\n\nstruct Hit\n{\n    float t;\t// solution to p=o+t*d\n    vec3 n;\t\t// normal\n    Material m;\t// material\n};\nconst Hit noHit = Hit(1e10, vec3(0.), Material(vec3(-1.), -1.));\n\nstruct Plane\n{\n    float d;\t// solution to dot(n,p)+d=0\n    vec3 n;\t\t// normal\n    Material m;\t// material\n};\n\nstruct Sphere\n{\n\tfloat r;\t// radius\n    vec3 p;\t\t// center position\n    Material m;\t// material\n};\n\nHit intersectPlane(Plane p, Ray r)\n{\n    float dotnd = dot(p.n, r.d);\n    if (dotnd > 0.) return noHit;\n\n    float t = -(dot(r.o, p.n) + p.d) / dotnd;\n    return Hit(t, p.n, p.m);\n}\n\nHit intersectSphere(Sphere s, Ray r)\n{\n\tvec3 op = s.p - r.o;\n    float b = dot(op, r.d);\n    float det = b * b - dot(op, op) + s.r * s.r;\n    if (det < 0.) return noHit;\n\n    det = sqrt(det);\n    float t = b - det;\n    if (t < 0.) t = b + det;\n    if (t < 0.) return noHit;\n\n    return Hit(t, (r.o + t*r.d - s.p) / s.r, s.m);\n}\n\nbool compare(inout Hit a, Hit b)\n{\n    if (b.m.f0 >= 0. && b.t < a.t)\n    {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nHit intersectScene(Ray r)\n{\n    Sphere s = Sphere(1., vec3(0., 1., 0.), Material(vec3(1.0), 0.04));\n    Plane p  = Plane(0., vec3(0., 1., 0.), Material(vec3(1.0), 0.04));\n\n    Hit hit = noHit;\n    compare(hit, intersectPlane(p, r));\n    compare(hit, intersectSphere(s, r));\n    return hit;\n}\n\n// ---8<----------------------------------------------------------------------\n// Lights\n\nstruct DirectionalLight\n{\n    vec3 d;\t\t// Direction\n    vec3 c;\t\t// Color\n};\n\nstruct SpotLight\n{\n    vec3 p;\t\t// Position\n    vec3 d;\t\t// Direction\n    float fa;\t// Falloff start cos\n    float fb;\t// Falloff end cos\n    vec3 c;\t\t// Color\n};\n\nDirectionalLight sunLight = DirectionalLight(normalize(vec3(-2., 1., 1.)), vec3(.1));\nSpotLight spotLights[2];\n\nvoid InitLights()\n{\n    float t = abs(fract(.2*iTime)*2.-1.);\n    spotLights[0] = SpotLight(vec3(mix(-1.5, -0.2, t), 3., 1.), vec3(0., -1., 0.), .9, .902, vec3(1.));\n    spotLights[1] = SpotLight(vec3(mix(+1.5, +0.2, t), 3., 1.), vec3(0., -1., 0.), .9, .95, vec3(1.));\n}\n\nvec3 skyColor(vec3 d)\n{\n    return vec3(0.01);\n}\n\nfloat pow5(float x) { return x * x * x * x * x; }\n\n// Schlick approximation\nfloat fresnel(vec3 h, vec3 v, float f0)\n{\n  return pow5(1. - clamp(dot(h, v), 0., 1.)) * (1. - f0) + f0;\n}\n\nfloat epsilon = 4e-4;\n\nvec3 accountForDirectionalLight(vec3 p, vec3 n, DirectionalLight l)\n{\n    if (intersectScene(Ray(p + epsilon * l.d, l.d)).m.f0 < 0.)\n    {\n        return clamp(dot(n, l.d), 0., 1.) * l.c;\n    }\n    return vec3(0.);\n}\n\nvec3 accountForSpotLight(vec3 p, vec3 n, SpotLight l)\n{\n    vec3 d = normalize(l.p - p);\n    float sqrDist = dot(l.p - p, l.p - p);\n    Hit test = intersectScene(Ray(p + epsilon * d, d));\n\n    if (test.t * test.t > sqrDist)\n    {\n        float atten = smoothstep(l.fa, l.fb, dot(l.d, -d)) / sqrDist;\n        return atten * clamp(dot(n, d), 0., 1.) * l.c;\n    }\n    return vec3(0.);\n}\n\nvec3 radiance(Ray r)\n{\n    vec3 accum = vec3(0.);\n    vec3 attenuation = vec3(1.);\n\n    for (int i = 0; i <= MAX_BOUNCES; ++i)\n    {\n        Hit hit = intersectScene(r);\n\n        if (hit.m.f0 >= 0.)\n        {\n            float f = fresnel(hit.n, -r.d, hit.m.f0);\n\n            vec3 hitPos = r.o + hit.t * r.d;\n\n            // Diffuse\n            vec3 incoming = vec3(0.);\n            incoming += accountForDirectionalLight(hitPos, hit.n, sunLight);\n            incoming += accountForSpotLight(hitPos, hit.n, spotLights[0]);\n            incoming += accountForSpotLight(hitPos, hit.n, spotLights[1]);\n\n            accum += (1. - f) * attenuation * hit.m.c * incoming;\n\n            // Specular: next bounce\n            attenuation *= f;\n            vec3 d = reflect(r.d, hit.n);\n            r = Ray(r.o + hit.t * r.d + epsilon * d, d);\n        }\n        else\n        {\n            accum += attenuation * skyColor(r.d);\n            break;\n        }\n    }\n    return accum;\n}\n\n// ---8<----------------------------------------------------------------------\n// Scene\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitLights();\n\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\n    float o1 = 0.25;\n    float o2 = 0.75;\n    vec2 msaa[4];\n    msaa[0] = vec2( o1,  o2);\n    msaa[1] = vec2( o2, -o1);\n    msaa[2] = vec2(-o1, -o2);\n    msaa[3] = vec2(-o2,  o1);\n\n    vec3 color = vec3(0.);\n    for (int i = 0; i < 4; ++i)\n    {\n        vec3 p0 = vec3(0., 1.1, 4.);\n        vec3 p = p0;\n        //vec3 p = vec3(0., (2. * (iMouse.y==0.?.5*iResolution.y:iMouse.y) / iResolution.y - 1.), 0.) + p0;\n        vec3 offset = vec3(msaa[i] / iResolution.y, 0.);\n        vec3 d = normalize(vec3(iResolution.x/iResolution.y * uv.x, uv.y, -1.5) + offset);\n        Ray r = Ray(p, d);\n        color += radiance(r) / 4.;\n    }\n\n    float compareLimit = (iMouse.z > 0. ? iMouse.x : abs(fract(0.1*iTime) * 2. - 1.) * iResolution.x);\n\tif (compareLimit < fragCoord.x)\n        fragColor = vec4(pow(color, vec3(1./gamma)),1.0);\n    else\n        fragColor = vec4(color*2.,1.0); // Fudge x2 factor to compensate for darkened result.\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}