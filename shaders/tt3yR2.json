{
    "Shader": {
        "info": {
            "date": "1616630251",
            "description": "Attempting to render 3d geometry in the style of hand-drawn pixel art.\n\nRotate the shapes with the mouse.",
            "flags": 32,
            "hasliked": 0,
            "id": "tt3yR2",
            "likes": 98,
            "name": "Pixel Art Aesthetics",
            "published": 3,
            "tags": [
                "3d",
                "retro",
                "pixelart"
            ],
            "usePreview": 0,
            "username": "ChrisK",
            "viewed": 3049
        },
        "renderpass": [
            {
                "code": "// CRT EFFECTS HAPPEN HERE\n\n// this code is mostly reused from https://www.shadertoy.com/view/MdyyWt\n\n//toggle CRT effects with these\n   #define SCANLINES\n   #define SHADOW_MASK\n   //#define SCREEN_SHAPE\n   //#define LIGHT_EFFECTS\n\n#define SCREEN_CURVE_RADIUS\t\t5.0\n#define SCREEN_CORNER_RADIUS\t0.1\n#define BRIGHTNESS      \t\t1.5\n#define PIXEL_SHARPNESS   \t\t2.0\n#define LINE_SHARPNESS\t\t\t6.0\n#define MASK_STRENGTH\t\t\t0.15\n\n\n#define gaussian(a,b)\texp2((a)*(a)*-(b))\n\n\nvec2 curveScreen( vec2 uv ) {\n    float r = 3.14159265*0.5/SCREEN_CURVE_RADIUS;\n    float d = 1.0-cos(uv.x*r)*cos(uv.y*r);\t\t//distance to screen\n    float s = cos(r);\t\t\t\t\t\t\t//scale factor to re-fit window\n    return uv / (1.0-d) * s;\n}\n\n\nfloat discardCorners( vec2 pos ) {\n    pos = abs(pos);\n    pos.x = pos.x*1.333-0.333;\t\t\t\t\t\t\t\t\t\t\t// 4:3 aspect ratio correction\n    if( min(pos.x, pos.y) < 1.0-SCREEN_CORNER_RADIUS ) return 1.0;\t\t// not near corner -- break early\n    float d = distance( pos, vec2(1.0-SCREEN_CORNER_RADIUS) );\n    return float( d<SCREEN_CORNER_RADIUS );\n}\n\n\nvec3 getSample( vec2 pos, vec2 off ) {\n\t//get nearest emulated sample\n\tvec2 ir = IRES * TILES;\n    pos = floor(pos*ir) + vec2(0.5) + off;\n\tvec3 col = vec3(0.0);\n\tif ( pos.x>=0.0 && pos.x<=ir.x*2.0 && pos.y>=0.0 && pos.y<=ir.y ) {\n        col = texelFetch( iChannel0, ivec2(pos), 0).rgb;\n        col = pow( ( (col + 0.055) / 1.055), vec3(2.4) );\t\t// SRGB => linear\n\t}\n\treturn col;\n}\n\n\nvec3 getScanline( vec2 pos, float off ) {\n\t// 3-tap gaussian filter to get colour at arbitrary point along scanline\n    vec2 ir = IRES * TILES;\n    float d = 0.5-fract(pos.x*ir.x);\n\tvec3 ca = getSample( pos, vec2(-1.0, off ) );\n\tvec3 cb = getSample( pos, vec2( 0.0, off ) );\n\tvec3 cc = getSample( pos, vec2( 1.0, off ) );\n\tfloat wa = gaussian( d-1.0, PIXEL_SHARPNESS );\n\tfloat wb = gaussian( d,     PIXEL_SHARPNESS );\n\tfloat wc = gaussian( d+1.0, PIXEL_SHARPNESS );\n\treturn ( ca*wa + cb*wb + cc*wc ) / ( wa+wb+wc);\n}\n\n\nvec3 getScreenColour( vec2 pos ) {\n\t//Get influence of 3 nearest scanlines\n    vec2 ir = IRES * TILES;\n    float d = 0.5-fract(pos.y*ir.y);\n\tvec3 ca = getScanline( pos,-1.0 );\n\tvec3 cb = getScanline( pos, 0.0 );\n\tvec3 cc = getScanline( pos, 1.0 );\n    float wa = gaussian( d-1.0, LINE_SHARPNESS );\n\tfloat wb = gaussian( d,     LINE_SHARPNESS );\n\tfloat wc = gaussian( d+1.0, LINE_SHARPNESS );\n    return ( ca*wa + cb*wb + cc*wc );\n}\n\n\nvec3 SlotMask_PixelPerfect( vec2 pos ) {\n    //pos /= 1.0 + floor( iResolution.y / 1440.0 );\n    pos /= 1.0 + floor( iResolution.y / (IRES.y*15.0) );\n    float glow = 0.5;\n    float f = mod(pos.x,3.0);\n    vec3 col = vec3( (f<=1.0), (f>1.0&&f<=2.0), (f>2.0) );\n    col += vec3( (f<1.5 || f>=2.5), (f>0.5 && f<=2.5), (f>1.5 || f<=0.5) ) * glow;\n    col *= ( mod(pos.y+(fract(pos.x/6.0)>0.5?1.5:0.0),3.0)<1.0 ) ? glow : 1.0;\n    col /= 1.0+glow;\n    return col;\n}\n\n\nvec3 ACESFilm( vec3 x ) {\n    return clamp((x*(2.51*x + 0.03)) / (x*(2.43*x + 0.59) + 0.14), 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = fragCoord / iResolution.xy;\n   \tpos = pos*2.0 - 1.0;\n    pos.x *= iResolution.x/iResolution.y*(IRES.y/IRES.x);\t\t\t\t\t\t// 4:3 aspect\n    \n    #ifdef SCREEN_SHAPE\n    pos = curveScreen(pos);\t\t\t\t\t\t\t\t\t\t\t// curve screen\n    #endif\n    \n    if(max( abs(pos.x), abs(pos.y) )<1.0) {\t\t\t\t\t\t\t// skip everything if we're beyond the screen edge\n    \t\n        vec3 col = vec3(1.0);\n        \n        #ifdef SCREEN_SHAPE\n        col *= discardCorners(pos);\n        #endif\n        \n        #ifdef LIGHT_EFFECTS\n        col *= 1.0 - sqrt(length(pos)*0.25);\t\t\t\t\t\t// vignette\n        #endif\n        \n        pos = pos*0.5 + 0.5;\n\n        #ifdef SCANLINES\n\t\tcol *= getScreenColour( pos );\n        #else\n        col *= getSample( pos, vec2(0.0) );\n        #endif\n        \n        #ifdef SHADOW_MASK\n        vec3 shadowmask = SlotMask_PixelPerfect( fragCoord );\n        col *= mix( vec3(1.0-MASK_STRENGTH), vec3(1.0+MASK_STRENGTH), shadowmask);\n        #endif\n        \n        #ifdef LIGHT_EFFECTS\n\t\tcol *= BRIGHTNESS;\n    \tcol = ACESFilm(col);\n        #endif\n    \n    \tcol = pow( col, vec3(1.0/2.4) ) * 1.055 - 0.055;\t\t\t// linear => SRGB\n    \n    \tfragColor = vec4( col, 1.0 );\n    }\n    \n    //fragColor = texelFetch( iChannel0, ivec2(fragCoord), 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// 3D CALCULATIONS HAPPEN HERE\n\n// shapes are generated using simplified versions of\n// the functions described by Inigo Quilez in this article:\n// https://iquilezles.org/articles/intersectors \n\n\n#define rot2(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nint shape = 0;\n\nvec3 rotate ( vec3 p, vec3 r ) {\n    p.yz *= rot2(r.x);\n    p.xz *= rot2(-r.y);\n    p.xy *= rot2(r.z);\n    return p;\n}\n\n\nfloat IntersectUnitCube ( vec3 ro, vec3 rd ) {\n    vec3 tmin = (0.5-ro)/rd;\t\t\t\t\t\t\t// distances to positive planes\n    vec3 tmax = (-0.5-ro)/rd;\t\t\t\t\t\t\t// distances to negative planes\n    vec3 rmin = min(tmin, tmax);\t\t\t\t\t\t// distances to front-facing planes\n    vec3 rmax = max(tmin, tmax);\t\t\t\t\t\t// distances to back-facing planes\n    float dback  = min( min(rmax.x, rmax.y), rmax.z );\t// distance to nearest back-facing side\n    float dfront = max( max(rmin.x, rmin.y), rmin.z );\t// distance to furthest front-facing side (possible collision distance)\n    return dback>=dfront ? dfront : -dfront;\n}\n\n\nfloat IntersectSphere ( vec3 ro, vec3 rd, float rad ) {\n    float b = dot(ro,rd);\n    float h = b*b - dot(ro,ro) + rad*rad;\n    return (h<0.0) ? -1.0 : -b-sqrt(h);   // -b+sqrt(h) = backface distance\n}\n\n\nfloat IntersectXUnitCylinder ( vec3 ro, vec3 rd, float rad ) {\n    vec3 oc = ro + vec3(0.5,0.0,0.0);\n    float a = 1.0 - rd.x*rd.x;\n    float b = dot(oc,rd) - oc.x*rd.x;\n    float c = oc.y*oc.y + oc.z*oc.z - rad*rad;\n    float h = b*b - a*c;\n    if( h<0.0 ) return -1.0;              // miss\n    h = sqrt(h);\n    float t = (-b-h)/a;\n    float y = oc.x + t*rd.x;\n    if( y>0.0 && y<1.0 ) return t;        // body hit?\n    t = (float(y>=0.0) - oc.x)/rd.x;\n    return ( abs(b+a*t)<h ) ? t : -1.0;   // cap hit?\n}\n\n\nfloat IntersectCone( vec3 ro, vec3 rd, float h, float r ) {\n    vec3  oa = ro - vec3(0.0, h*0.5, 0.0);\n    float m0 = h*h;\n    float m1 = oa.y*-h;\n    float m2 = rd.y*-h;\n    if( m1<0.0 && dot(oa*m2-rd*m1, oa*m2-rd*m1)<(r*r*m2*m2) ) return -m1/m2;  // cap hit?\n    float hy = m0 + r*r;\n    float k2 = m0*m0            - m2*m2*hy;\n    float k1 = m0*m0*dot(rd,oa) - m1*m2*hy + m0*r*r* m2;\n    float k0 = m0*m0*dot(oa,oa) - m1*m1*hy + m0*r*r*(m1*2.0 - m0);\n    float t = ( -k1-sqrt(k1*k1 - k2*k0) ) / k2;\n    float y = m1 + t*m2;\n    return ( y>=0.0 && y<=m0 ) ? t : -1.0;   // body hit?\n}\n\n\nvec4 getrendersample ( vec3 ro, vec3 rd ) {\n    float rl;\n    switch(shape) {\n    case 0:\n        rl = IntersectUnitCube( ro, rd );\n        break;\n    case 1:\n        rl = IntersectSphere( ro, rd, 0.6 );\n        break;\n    case 2:\n        rl = IntersectXUnitCylinder( ro, rd, 0.6 );\n        break;\n    case 3:\n        rl = IntersectCone( ro, rd, 1.2, 0.6 );\n        break;\n    }\n    \n    if ( rl > 0.0 ) {\n\t\tvec3 xyz = ro + rd*rl;\n        \n        vec3 nor;                 // surface normal\n        float dith = 0.0;         // how much lighting is dithered across surface\n        switch(shape) {\n        case 0: // unit cube\n            nor = round( xyz*1.00001 );\n            break;\n        case 1: // sphere\n            nor = normalize(xyz); dith = 0.35;       \n            break;\n        case 2: // unit length x-cylinder\n            if (abs(xyz.x)>0.4999) { nor = vec3(0.0,0.0,sign(xyz.x)); } else { nor = vec3(0.0,normalize(xyz.yz)); dith = 0.35; }\n            break;\n        case 3: // cone (h=1.2, r=0.6)\n            if (abs(xyz.y)>0.5999) { nor = vec3(0.0,sign(xyz.y),0.0); } else { nor = normalize(vec3(xyz.x,-(length(xyz.xz)/2.0),xyz.z)); dith = 0.35; }\n            break;\n        }\n        \n        // material ID\n        float mat = (xyz.x>0.0 ^^ xyz.y>0.0 ^^ xyz.z>0.0) ? 1.0 : 2.0;\n        \n        // lambertian diffuse\n        vec3 ld = normalize( vec3(1,2,1) );\n        float br = max( dot(-ld,nor), 0.0);\n        \n        // phong specular\n        float spec = 0.0;\n        if (br>0.0) {\n            vec3 h = -normalize(ld+rd);\n            spec = pow( dot(nor,h), 500.0);\n        }\n        \n        // depth\n        float depth = rotate(xyz, -vec3(iTime*0.5)).z + 5.0;\n        \n        return vec4( mat, br, dith, spec );\n    } else {\n        return vec4( 0.0 );\n\t}\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy/IRES;\n    uv = uv*2.0 - 1.0;\n\n    vec2 tile = floor( (uv+1.0)*0.5 );\n    shape = int( floor( mod(tile.x,2.0) )\n               + floor( mod(tile.y,2.0) ) * 2.0 );\n\n    uv = mod( uv+1.0, vec2(2.0) ) - 1.0;\n    uv.y *= IRES.y/IRES.x;\n    \n    //vec3 r = vec3(iTime*0.5);\n    vec3 r = vec3( -iMouse.yx/iResolution.yx*7.0, 0.0 ); \n    \n    vec3 campos = vec3(0.0,0.0,-2.5);\n    vec3 camray = normalize( vec3(uv,1.35) );\n    campos = rotate( campos, r );\n    camray = rotate( camray, r );\n     \n    fragColor = getrendersample( campos, camray );\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//#define IRES vec2(120, 120)\n#define IRES (vec2(16, 9)*5.0)\n\n#define TILES 2.0",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// CONVERTING 3D DATA TO 'PIXEL ART' HAPPENS HERE\n\n// Just dropping the resolution and crushing the colour data would be simple, but making it\n// appear 'hand-made' presents a few challenges. I'm attempting to roughly translate my\n// thought process when drawing pixel art into code here, so I targeted the following goals:\n\n// 1) NICE, HAND-PICKED COLOURS\n// I think a lot of the aesthetic appeal in pixel art (and the fun in making it) comes from\n// getting a lot out of very little, so the smaller the palette is, the better. I'm using a\n// hand-picked palette of 9 colours here. These colours mostly make up two gradients, which\n// correspond to the orange and blue materials at different levels of brightness. Both\n// gradients use the same dark outline and specular highlight colours, for simplicity.\n\n// 2) AESTHETICALLY APPEALING BALANCE OF FLATNESS AND DETAIL\n// Lighting gradients across flat surfaces are rare in pixel art, even when they are physically\n// accurate. For this reason, I differentiate between flat and curved surfaces. The diffuse\n// lighting on curved surfaces is dithered with a bayer matrix, but flat surfaces are left\n// perfectly flat, with no lighting variation from one side to another. On objects with more\n// texture it would be better to replace the bayer matrix with a pattern that better described\n// the surface, or maybe a normal map (so that the surface details rotate with the geometry).\n\n// 3) USING DARK OUTLINES TO CLEARLY SEPERATE 'SPRITES' FROM 'BACKGROUND'\n// Self-explanatory. On the highlighted sides of the objects, these outlines are coloured to\n// match the object material, for a bit of extra visual interest. They are also anti-aliased,\n// but very approximately, based off of a set of intuitive rules rather than anything with\n// any physical accuracy. For more complicated 'sprites' with overlapping geometry, it would\n// also be desirable to have some internal outlines seperating ovelapping elements.\n\n// I think these three things go a long way toward achieving the pixel art look, at least in\n// this very simple case.\n\n\n#define SPEC_DITHER   0.01\n\n#define BG_COL        vec3( 0.6, 0.8, 0.8 )\n#define OUTLINE       vec3( 0.2, 0.0, 0.1 )\n#define HIGHLIGHT     vec3( 1.0, 1.0, 0.8 )\n\n\nconst vec3 palette_a[5] = vec3[5](OUTLINE,\n                                  vec3( 0.6, 0.0, 0.3 ),\n                                  vec3( 1.0, 0.2, 0.1 ),\n                                  vec3( 1.0, 0.7, 0.2 ),\n                                  HIGHLIGHT );\n                            \nconst vec3 palette_b[5] = vec3[5](OUTLINE,\n                                  vec3( 0.0, 0.2, 0.5 ),\n                                  vec3( 0.1, 0.5, 0.7 ),\n                                  vec3( 0.2, 0.7, 1.0 ),\n                                  HIGHLIGHT );\n\nconst mat4 bayer = mat4( 0,  8,  2, 10,\n  \t\t\t\t\t\t12,  4, 14,  6,\n   \t\t\t\t\t\t 3, 11,  1,  9,\n   \t\t\t\t\t\t15,  7, 13,  5)/16.0;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 fc = fragCoord.xy;\n\n    vec4 shape = texelFetch(iChannel0,ivec2(fc),0);\n    vec4 n = texelFetch(iChannel0,ivec2(fc)+ivec2(0,1),0);\n    vec4 s = texelFetch(iChannel0,ivec2(fc)-ivec2(0,1),0);\n    vec4 e = texelFetch(iChannel0,ivec2(fc)+ivec2(1,0),0);\n    vec4 w = texelFetch(iChannel0,ivec2(fc)-ivec2(1,0),0);\n    \n    int neighbours      = int(n.x>0.0) + int(s.x>0.0) + int(e.x>0.0) + int(w.x>0.0);\n    int lightneighbours = int(n.y>0.0) + int(s.y>0.0) + int(e.y>0.0) + int(w.y>0.0);\n    \n    vec3 col = BG_COL;\n    int br = -1;\n    \n    if( shape.x <= 0.0 ) {\n        // background stripes\n        if( sin((fc.x+fc.y)/5.0+iTime*5.0)>0.0 ) col = HIGHLIGHT;\n    \n        // outlines\n        if (neighbours > 0) {\n            shape.x = max( max(n.x,s.x), max(e.x,w.x) );\n            br = ( lightneighbours == neighbours ) ? 1 : 0;\n            \n            //when bordering brightest areas:\n            if ( max(max(n.y,s.y),max(e.y,w.y)) > 0.5 ) {\n                // search diagonals -- if 2/8 or fewer neighbours are occupied, then lighten 1 step more\n                // together with a darkened pixel inside the shape, this will improve the AA on the line\n                vec4 ne = texelFetch(iChannel0,ivec2(fc)+ivec2( 1, 1),0);\n                vec4 nw = texelFetch(iChannel0,ivec2(fc)+ivec2( 1,-1),0);\n                vec4 se = texelFetch(iChannel0,ivec2(fc)+ivec2(-1, 1),0);\n                vec4 sw = texelFetch(iChannel0,ivec2(fc)+ivec2(-1,-1),0);\n                neighbours += int(ne.x>0.0) + int(nw.x>0.0) + int(se.x>0.0) + int(sw.x>0.0);\n                if (neighbours<=2) br++;\n            }\n        }\n    } else {\n        ivec2 buv = ivec2( mod( fc, 4.0 ) );\n        float ba = bayer[buv.x][buv.y];\n    \n        // face shading\n        shape.y -= ba*shape.z;\n        //br = int(shape.y) + 1;\n        \n        br = int( ceil( shape.y*2.0 ) ) + 1;\n        \n        // specular highlight\n        if (shape.w-ba*SPEC_DITHER > 0.001 ) br++;\n        if (shape.w-ba*SPEC_DITHER*2.0 > 0.001 ) br++;\n        br = min(br,4);\n        \n        // darken to approximate anti-aliasing on edges of bright area\n        if ( br>=3 && lightneighbours<=2 ) br--;\n    }\n    \n    if ( br >= 0 ) {\n        col = (shape.x>1.5) ? palette_b[br] : palette_a[br];\n    }\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}