{
    "Shader": {
        "info": {
            "date": "1708741819",
            "description": "asdf",
            "flags": 0,
            "hasliked": 0,
            "id": "X3SGzd",
            "likes": 17,
            "name": "AO Vox 12 cam",
            "published": 3,
            "tags": [
                "voxel",
                "dda",
                "gyroid"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 256
        },
        "renderpass": [
            {
                "code": "\n/*\nNotes to self mostly about the ao:\n\n1. the getUV has to be set up specifically. \nn*p.yx NOT n*p.xy! The order of the other two are fine\n\n2. Remember we are checking INSIDE neighboring cells\nso we need to move to nor*0.501 NOT 0.5\n\n3. maptest is still \"float(map(ceil(p)-0.5) < 0.001);\"\n\n4. I think I get it. The only reason uvs work here\nis because this map never has occlusion in the\nopposite direction. On the right side when p.x is positive\nocclusion always comes from the right. on the left\nwhen it's negative occlusion only comes from the left.\nsame for the other dimentions.\n\nand if I flip the map to a sphere we are looking at \nit's the opposite. We only see occlusion from the other side.\n\nbut I guess a smart move would be to do\nuv = abs(uv-0.5) or something so no matter the side it always \nworks? Did'nt work?\n\nI can clearly see the issue when I try to use ABS(p) before\nmaking the circle\n\n\n5. I do this test:\nfloat map(vec3 p){\n    //\n    float pl = 5.-p.z;//(length(p)-8.);\n    p.xy = abs(p.xy)-5.;\n    float ci = (length(p-vec3(0.,0.,5.))-4.);\n    return min(pl,ci);\n}\n\n6. if we flip the n*p.yx to n*p.xy I think we just\nhave to flip the wa(uv.y,uv.y,uv.x... to\nqa(uv.x,uv.x,uv.y...)\n*/\n\n#define addH t.y = t.x < h.x ? t.y : h.y;  t.x = min(t.x,h.x)\n\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n\n\nvec2 path(float z){\n    return vec2(sin(z*0.1+z*0.01)*9., cos(z*.05)*10.);\n}\nfloat gyroid (vec3 p) { return dot(sin(p),cos(p.yzx)); }\nvec2 map(vec3 p){\n\n    vec2 t = vec2(gyroid(p/4.),2.);\n    t.x = max(t.x,-(length(p.xy-vec2(path(p.z).xy))-4.));\n    vec2 h = vec2(12.+p.y,2.);\n    addH;\n    return t;\n    \n \n    \n}\nvec3 gn;\n\n//based ib xor's branchless voxel traversal\nfloat mint(vec3 ro, vec3 rd){\n    vec3 t = (fract(-ro*sign(rd))+1e-3)/abs(rd);\n    gn = t.x < t.y && t.x < t.z ? \n         vec3(1.,0.,0.)*-sign(rd.x) : \n         t.z < t.y && t.z < t.x ? \n         vec3(0.,0.,1.)*-sign(rd.z) : \n         vec3(0.,1.,0.)*-sign(rd.y);\n         \n    return min(t.x,min(t.y,t.z));\n}\n\nfloat globalID = 0.;\n//based ib xor's branchless voxel traversal\nvec3 cst(vec3 ro,vec3 rd){\n    float t;\n    for(float i=0.;i<100.;i++){\n        t = mint(ro,rd);\n        ro += rd*t;\n        vec2 ret = map(ceil(ro)-0.5);\n        if(ret.x < 0.001){globalID = ret.y; break;}\n    }\n    return ro;\n}\n\n\nfloat shadow(vec3 ro,vec3 lp){\n    vec3 ld = lp/max(0.,length(lp));\n    float t, acct = 0.;\n    for(float i=0.;i<16.;i++){\n        t = mint(ro,ld);\n        ro += ld*t;\n        acct += t;\n        //if we hit somethign reutrn 0.3\n        if(map(ceil(ro)-0.5).x < 0.00){return 0.3;}\n        //if we pass the light then return 1.\n        if(length(lp) < acct)return 1.;\n    }\n    return 1.;\n}\nvec2 getUV(vec3 p){\n    //for z to work, the getUV function have to line up\n    //with vc in the ao function\n    //I also had to fix the normal \n    //there is a  big difference between using \n    //abs of the gn*p.xy.. and getting n = abs(gn)\n    //FIRST!\n    vec3 n = abs(gn);\n    return (n.x*p.yz + n.y*p.zx + n.z*p.xy);\n    //return abs(gn.x*p.yz + gn.y*p.zx + gn.z*p.xy);      \n}\n\n\nfloat mapTest(vec3 p){\n    return float(map(ceil(p)-0.5).x < 0.001);\n}\n\n//Based on IQ's Voxel AO/Egdes Shader but \n//un rolled and written to work with my normal and getUV functions\nfloat ao(vec3 vos, vec3 nor, vec3 dir){\n        vec2 uv = fract(getUV(vos));\n        dir = abs(nor)*0.501;\n\n        float occ = 1.0;\n        vos = ceil(vos)-0.5;\n        \n        occ = 0.;\n        //we just need to make sure we go INTO the \n        //next cell so it's 0.501 not 0.5\n        \n        //update, I fliped the components in dir and\n        //in getUV AND in wa and got rid of .xyzw\n        vec3 v1 = vos + nor + dir.zxy;\n        vec3 v2 = vos + nor - dir.zxy;\n        vec3 v3 = vos + nor + dir.yzx;\n        vec3 v4 = vos + nor - dir.yzx;\n        vec4 vc = vec4( mapTest(v1),mapTest(v2),mapTest(v3),mapTest(v4)  );\n        vec2 st = 1.0 - uv;\n        \n        //              r    l    u    d       \n        vec4 wa = vec4( uv.x, st.x, uv.y, st.y)*vc;\n\n        \n        vec3 v5 = vos + nor + dir.yzx + dir.zxy;\n        vec3 v6 = vos + nor - dir.yzx + dir.zxy;\n        vec3 v7 = vos + nor - dir.yzx - dir.zxy;\n        vec3 v8 = vos + nor + dir.yzx - dir.zxy;\n        vec4 vd = vec4( mapTest(v5),mapTest(v6),mapTest(v7),mapTest(v8)  );\n       // vec2 st = 1.0 - uv;\n       \n                     //uv.x*uv.y because up is uv.y and right is uv.x\n        vec4 wb = vec4(uv.x*uv.y*(1.-vc.x)*(1.-vc.z),\n                       //if we hit top-right, remove right and top\n                       uv.x*st.y*(1.-vc.w)*(1.-vc.x),\n                       //if we hit bottom-right, remove bottom and right\n                       st.x*st.y*(1.-vc.w)*(1.-vc.y),\n                       //if we hit bottom-left, remove botttom and left\n                       st.x*uv.y*(1.-vc.z)*(1.-vc.y))*vd;\n                       //if we hit top-left...\n                       \n                       //*(1.0-vc.xzyw)*(1.0-vc.zywx);\n        //ok and now I understand how IQ went from \n        //what I have above to his one liner.\n        //he really just took each column of 1.-x terms\n        // and rolled it into a 1.-vector4\n        \n\n        occ = wa.x + wa.y + wa.z + wa.w\n                   + wb.x + wb.y + wb.z + wb.w;\n        \n           \n        \n        occ = 1.0 - occ/8.0;\n        occ = occ*occ;\n        occ = occ*occ;\n        //occ *= amb;\n        \n        return occ;\n}\n\n//from shane\nfloat brickShade(vec2 p){\n    \n    p = fract(p);\n    return clamp(pow(16.*p.x*p.y*(1.-p.x)*(1.-p.y), 0.25),0.,1.);\n    \n}\n\n\nfloat brick(vec2 p){\n    vec2 op = p;\n    vec2 fp = fract(p*0.1);\n\tp = fract(p*vec2(0.5))*2.;\n    float pattern = (1.-texture(iChannel3,(fp)).b*0.0);\n    float rounding = (brickShade(p)*.5 +.5);\n    float txt = (0.3*texture(iChannel2,op*0.15).x);\n    return rounding*1.5+txt;\n}\n\n\nfloat bumpSurf3D( in vec3 p, in vec3 n){\n\n    return brick(getUV(p));\n    \n}\n\n//from shane\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpSurf3D(p, nor);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy, nor),\n                      bumpSurf3D(p - e.yxy, nor),\n                      bumpSurf3D(p - e.yyx, nor) )-ref)/(2.*e.x);                     \n          \n    //grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n\n    vec3 f = normalize(l-p),\n\n        r = normalize(cross(vec3(0,1,0), f)),\n\n        u = cross(f,r),\n\n        c = f*z,\n\n        i = c + uv.x*r + uv.y*u,\n\n        d = normalize(i);\n\n    return d;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy*2. - iResolution.xy)/iResolution.y;\n    float speed = 4.*iTime;\n    vec3 ro = vec3(path(speed).xy,speed);\n    vec3 lk = vec3(path(speed+15.).xy*vec2(0.2,.1),2.)+ro;\n    vec3 rd = getRayDir(uv,ro,lk,1.6);\n    \n    rd = normalize(rd);\n    vec3 li = ro+normalize(ro)*vec3(0.,1.,-1.);\n    vec3 p = cst(ro,rd);\n    vec3 bumpNorm = doBumpMap(p,gn,0.3);\n    \n    \n    vec3 ld = normalize(li-p);\n    //another fancy way to do this from \n    //some of Shane's older shaders\n    //vec3 ld = li-p;\n    //float ldist = max(length(ld),0.001);\n    //ld /= ldist;\n    float diff = max(dot(ld,bumpNorm),0.0);\n    float spec = pow(max(dot(reflect(-ld,bumpNorm),-rd),0.),30.);\n    vec2 vuv = fract(getUV(p));\n    vec3 col = vec3(0.7);\n \n    vec3 id = floor(p);\n    float idd = hash13(id);\n    vec3 blockCol;\n\n    float tm = texture(iChannel1,(vuv+idd*20.)*0.01).b;\n    vec3 txt = texture(iChannel2,getUV(p)*0.15).rgb;\n    vec3 tint = 0.1*cos(vec3(1.,2.,4.)/2.+idd*5345.45+tm*10.);\n    \n    \n    blockCol = mix(vec3(1.,0.8,0.3),vec3(0.9,0.6,0.3),idd+tm*2.)+tint;\n   \n    col = ( diff*pow(blockCol,vec3(1.4)) + spec*vec3(1.,0.7,0.6))*0.75;\n    float fresnel = pow(1.+dot(bumpNorm,rd),15.);\n    //we lose a lot of depth at certain angles so I use\n    //frenel to bring it back\n    col += clamp(fresnel,0.,0.1);\n\n    vec3 rrd = reflect(rd,bumpNorm);\n    vec3 skyThing = mix(vec3(0.6, 0.4, 0.3), vec3(0.8), smoothstep(-1.,1.,uv.y));\n\n    col = clamp(col,0.,1.);\n    col *= ao(p,gn,gn)*shadow(p+gn*0.001, li-p);\n    float t = length(p-ro);\n    float fog = smoothstep(0.,1.,t/70.);\n    col = mix(col,skyThing*0.5+0.1,fog);\n    col = pow(col,vec3(0.85));\n\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.1415926\n#define addH t.y = t.x < h.x ? t.y : h.y;  t.x = min(t.x,h.x)\nfloat rnd(vec2 p){\n    vec2 seed = vec2(13.234, 72.1849);\n    return fract(sin(dot(p,seed))*43251.1234);    \n}\n\nmat2 rot(float a){\n     float c = cos(a),s = sin(a);\n     return mat2(c, -s, s, c);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}