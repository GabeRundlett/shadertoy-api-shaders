{
    "Shader": {
        "info": {
            "date": "1673664518",
            "description": "春节烟花特效",
            "flags": 0,
            "hasliked": 0,
            "id": "dt2Gzc",
            "likes": 9,
            "name": "春节烟花",
            "published": 3,
            "tags": [],
            "usePreview": 0,
            "username": "koerriva",
            "viewed": 206
        },
        "renderpass": [
            {
                "code": "\n#define rad(x) radians(x)\nfloat np = 100.;\nfloat snp = 20.;\nfloat R = 0.032;\nfloat R_RATIO = 0.04;\nfloat ACC_RATIO = 0.03;\nfloat ANG = 90.;\n\nvec2 N22(vec2 p)\n{\n    vec3 a = fract(p.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\nvec3 burst(vec2 st,vec2 pos,float r,vec3 col){\n    st -= pos;\n    r = 0.6*r*r;\n    return (r/dot(st,st))*0.6*col;\n}\n\nvec2 get_pos(vec2 u,vec2 a,vec2 p0,float t,float ang){\n    vec2 d = p0 + vec2(u.x*cos(ang),u.y*sin(ang)) * t + 0.5*a*t*t;\n    return d;\n}\n\nvec2 get_velocity(vec2 u,vec2 a,float t,float ang){\n    return vec2(u.x*cos(ang),u.y*sin(ang)) + a*t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    float aspect = iResolution.x / iResolution.y;\n    vec3 col = vec3(0.0);\n    float t = mod(iTime, 10.);\n\n    vec2 u = vec2(0.);                ///< 初速度\n    const vec2 acc = vec2(0.0, -9.8); ///< 重力加速度 acc\n    float ang = rad(ANG);             ///< 上升粒子的发射角度\n\n    vec3 particles = vec3(0.0); //particle\n\n    for (float i = 0.; i < np; i++)\n    {\n        float r = R;\n        vec2 rand = N22(vec2(i));\n\n        /// @note 爆炸前的粒子上升\n\n        /// 初始位置\n        vec2 ip = vec2(sin(30.*rand.x) * aspect, -1. + r);\n\n        /// 真正初始化速度\n        u = vec2(sin(5.*rand.x), 5. + sin(4.*rand.y));\n\n        float t_i = t - i / 5.; ///< 时间差异化\n        vec2 s = get_pos(u, acc, ip, t_i, ang);\n        vec2 v = get_velocity(u, acc, t_i, ang);\n\n        /// 计算竖直向上的运动时间\n        float t_up = u.y * sin(ang) / abs(acc.y);\n        /// 根据时间计算出向上运动的最大高度\n        vec2 h_max = get_pos(u, acc, ip, t_up, ang);\n\n        vec3 pcol = vec3(cos(i), cos(iTime), sin(iTime));\n\n\n        if (v.y < -0.5) ///< 下落速度超过一定大小则消失\n        {\n            r = 0.0;    ///< 隐藏\n        }\n\n        particles += burst(uv, s, r, pcol); ///< 发射上升的粒子\n\n\n        /// @note 爆炸后的粒子扩散\n        /// 当粒子停止上升，且粒子的当前时间已经达到了上升的时间\n\n        if (v.y > -6.5 && v.y < 0.0 && t_i >= t_up /*&& SPAWN == 1*/)\n        {\n            /// 把一个圆根据角度分成若干份扇形\n            float unit = (360. / snp);\n            for (float j = 0.0; j < snp; j++)\n            {\n                float ang = rad(j * unit);\n\n                float r = 0.035;             ///< 心形粒子的半径\n                r -= (t_i - t_up) * R_RATIO; ///< 根据时间差来改变粒子的大小（变小）\n\n                /// --------------------------------------------------\n                /// @note 根据（单位圆的）角度计算笛卡尔坐标\n                float x = cos(ang); //coords of unit circle\n                float y = sin(ang);\n                /// 心形公式\n                y = y + abs(x) * sqrt( (8. - abs(x)) / 50.0 );\n                /// 心形速度向量，随着时间而变小\n                vec2 heart = vec2(x * x + y * y) * (0.4 / (t_i * sqrt(t_i)));\n\n                /// 根据心形的当前速度和加速度、初始位置等更新粒子的位置\n                vec2 S = get_pos(heart, acc * ACC_RATIO, h_max, t_i - (t_up), ang);\n                /// --------------------------------------------------\n\n                //vec3 pcol = vec3(1.);\n                particles += burst(uv, S, max(0.0, r), pcol);\n            }\n        }\n    }\n    col = particles;\n\n    fragColor = vec4(col,  1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}