{
    "Shader": {
        "info": {
            "date": "1557838280",
            "description": "Left: New. Right: IQ's 3D Grad Noise\n\nEvery 2 secs: distances 0 -> 10 mil -> 1 bil\n\nGoal:\n- 3D gradient noise at very far distances\n- Generate roughly the same values across all high-end GPU hardware\n\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "wlXGWX",
            "likes": 9,
            "name": "High Precision 3D Gradient Noise",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "noise",
                "gradient",
                "hash"
            ],
            "usePreview": 0,
            "username": "nelstuff",
            "viewed": 964
        },
        "renderpass": [
            {
                "code": "/*\n\n2019 Nel (@nelstuff)\nBased on IQ's https://www.shadertoy.com/view/Xsl3Dl and https://www.shadertoy.com/view/XlXcW4\n\nGoal:\n- 3D gradient noise at very far distances\n- Generate roughly the same values across all high-end GPU hardware (so no \"fract(sin)\")\n\nAssumption:\n- Able to provide a true integer coordinate and a float offset to this coordinate\n\n*/\n\n\n//===============================================================================================\n// High Precision 3D Gradient Noise\n//===============================================================================================\n\n\n// Based on IQ's Integer Hash - II  https://www.shadertoy.com/view/XlXcW4\nvec3 inthash( uvec3 x ){\n    const uint k = 1103515245U;  // GLIB C\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    //Convert uvec3 to vec3\n    // Insert the result into a float's mantissa: https://stackoverflow.com/a/17479300\n    const uvec3 ieeeMantissa = uvec3(0x007FFFFFu); \t// binary32 mantissa bitmask\n    const uvec3 ieeeOne      = uvec3(0x3F800000u); \t// 1.0 in IEEE binary32\n    x &= ieeeMantissa;                     \t\t\t// Keep only mantissa bits (fractional part)\n    x |= ieeeOne;                          \t\t\t// Add fractional part to 1.0\n    vec3  f = uintBitsToFloat( x );       \t\t\t// Range [1:2]\n    return -3.0+2.0*f;                        \t\t// Range [-1:1]\n    \n    // Other method to convert uvec3 to vec3\n    //return -1.0 + 2.0 * vec3(x)*(1.0/float(0xffffffffU));\n}\n\n\n// High Precision 3D Gradient Noise\n// ix: integer coordinate, fx: float offset to the integer coordinate\nfloat newnoise(in ivec3 ix, in vec3 fx){\n    // grid\n    uvec3 p = uvec3(ix + ivec3(floor(fx)) );\n    vec3 w = fract(fx);\n    vec3 u = w*w*(3.0-2.0*w);\n    return mix( mix( mix( dot( inthash( p  ), w  ), \n                      dot( inthash( p + uvec3(1,0,0) ), w - vec3(1.0,0.0,0.0) ), u.x),\n                 mix( dot( inthash( p + uvec3(0,1,0) ), w - vec3(0.0,1.0,0.0) ), \n                      dot( inthash( p + uvec3(1,1,0) ), w - vec3(1.0,1.0,0.0) ), u.x), u.y),\n            mix( mix( dot( inthash( p + uvec3(0,0,1) ), w - vec3(0.0,0.0,1.0) ), \n                      dot( inthash( p + uvec3(1,0,1) ), w - vec3(1.0,0.0,1.0) ), u.x),\n                 mix( dot( inthash( p + uvec3(0,1,1) ), w - vec3(0.0,1.0,1.0) ), \n                      dot( inthash( p + uvec3(1,1,1) ), w - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n// Fractal Brownian Motion \nfloat newfractal(ivec3 ixyz, vec3 fxyz){ \n    // instead of floats, we need to use integer period and integer lacunarity\n    const int period = 2; \n    const int octaves=3;\n    const int lacunarity = 2; \n    const float persistence = 0.6;\n    \n    float value = 0.0;\n    float curpersistence = 1.0;\n\n    ivec3 ispace = ixyz / period;\n    vec3 fspace = vec3(ixyz - ispace * period) / vec3(period) + fxyz / vec3(period);\n\n    for (int i = 0; i < octaves; i++){\n        value += newnoise(ispace, fspace) * curpersistence;\n        curpersistence *= persistence;\n        ispace *= lacunarity;\n        fspace *= float(lacunarity);\n    }\n    return value;\n}\n\n//===============================================================================================\n// Baseline: IQ's 3D Gradient Noise  https://www.shadertoy.com/view/Xsl3Dl\n//===============================================================================================\n\nvec3 hash( vec3 p ){ // replace this by something better\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat oldnoise( in vec3 p ){\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\tvec3 u = f*f*(3.0-2.0*f);\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat oldfractal(vec3 xyz){ \n    const float frequency = 0.5; \n    const int octaves=3;\n    const float lacunarity = 2.0; \n    const float persistence = 0.6;\n    \n    float value = 0.0;\n    float curpersistence = 1.0;\n\n    vec3 space = xyz * frequency;\n\n    for (int i = 0; i < octaves; i++){\n        value += oldnoise(space) * curpersistence;\n        curpersistence *= persistence;\n        space *= lacunarity;\n    }\n    return value;\n}\n\n//===============================================================================================\n// Image (https://www.shadertoy.com/view/Xsl3Dl)\n//===============================================================================================\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // sphere center\t\n\tvec3 sc = vec3(0.0,1.0,0.0);\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\t\n\t// raytrace-plane\n\tfloat h = (0.0-ro.y)/rd.y;\n\tif( h>0.0 ) { \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tvec3 di = sc - pos;\n\t\tfloat l = length(di);\n\t\tocc = 1.0 - dot(nor,di/l)*1.0*1.0/(l*l); \n\t}\n\n\t// raytrace-sphere\n\tvec3  ce = ro - sc;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\th = b*b - c;\n\tif( h>0.0 ){\n\t\th = -b - sqrt(h);\n\t\tif( h<tmin ) { \n\t\t\ttmin=h; \n\t\t\tnor = normalize(ro+h*rd-sc); \n\t\t\tocc = 0.5 + 0.5*nor.y;\n\t\t}\n\t}\n\n    // shading/lighting\t\n\tvec3 col = vec3(0.9);\n\tif( tmin<100.0 )\n\t{\n\t    pos = ro + tmin*rd;\n\t    float f = 0.0;\n        \n        // varying distance every 2 secs\n        int dist = 0;\n        int t = int(floor(iTime*0.5));\n        if(t % 3 == 1){\n            dist = int(1e+7);\n        }else if(t % 3 == 2){\n            dist = int(1e+9);\n        }\n\t\t\n        //left\n\t\tif( p.x<0.0 ){\n\t\t\tf = newfractal(ivec3(0, 0, dist), 16.0*pos );\n\t\t}\n        //right\n\t\telse{\n            f = oldfractal(vec3(0, 0, dist) + 16.0*pos );\n\t\t}\n\t\t\n\t\t\n\t\tf = smoothstep( -0.7, 0.7, f );\n\t\tf *= occ;\n\t\tcol = vec3(f*1.2);\n\t\tcol = mix( col, vec3(0.9), 1.0-exp( -0.003*tmin*tmin ) );\n\t}\n\t\n\tcol = sqrt( col );\n\t\n\tcol *= smoothstep( 0.006, 0.008, abs(p.x) );\n\t\n\tfragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}