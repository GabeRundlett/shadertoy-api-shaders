{
    "Shader": {
        "info": {
            "date": "1572206946",
            "description": "simplified monochrome fork of \nhttps://www.shadertoy.com/view/3lB3Rc\nto print out for coloring with pens or as aquarell\n\nContinuing on from BigWIngs's double simplex Truchet weave pattern.",
            "flags": 0,
            "hasliked": 0,
            "id": "3scSRS",
            "likes": 12,
            "name": "Double Simplex Truchet Weave Cap",
            "published": 3,
            "tags": [
                "triangle",
                "simplex",
                "truchet",
                "pattern",
                "double",
                "weave",
                "zentangle"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 586
        },
        "renderpass": [
            {
                "code": "/*\n\n\n\tDouble Simplex Truchet Weave\n\t----------------------------\n\n\tAll too often, I'll be in the middle of coding something, then someone on \n    Shadertoy will post some interesting concept that sends me off on a tangent. \n\tBigWIngs puts up a lot of examples along those lines.\n\n    The other day, he posted a double quad Truchet that resulted in a really \n\tintense looking weave pattern -- The link is below. The basic premise was to \n\tdouble the usual amount of connecting points per side, then run\trandom \n\tsegments between them. It's such a simple idea, but opens up a heap of \n\tpossibilities.\n\n\tAnyway, BigWIngs also sketched up a very basic double sided simplex weave as \n\ta proof of concept, so this is just an extension on it.\n\n\tI was pleasantly surprised by how quickly it came together. Most of the time,\n\tthings that should take five minutes wind up taking much longer. The process\n\twas relatively quick because I was able to repurpose my quad version without\n\ttoo many incidents.\n\n\tIn regard to the lighting, I basically hacked away with a few samples to get \n\tthe look I wanted. There's very little science in there, so I wouldn't take \n\tany of it seriously... And I hope you like a monochrome palette -- It's the\n\tone I choose when I'm too lazy to make colors work. :D Either way, there's a\n\t\"CENTER_STRIPE\" define there for anyone who requires a splash of color.\n\n    Like the quad variation, if you wanted to produce a 3D extruded version,\n\tyou'd probably have to replace the Bezier curves with a mixture of arcs and \n\tlines, as it would be much faster.\n\n\tAt some point, I'd like to put together a proper 3D version, but I should \n\tprobably get back to what I'm supposed to be coding at the moment. :)\n\n\n\n\tBased On:\n\n    Double Triangle Truchet Doodle- BigWIngs\n\thttps://www.shadertoy.com/view/Ml2yzD\n\n\tCube-mapped Double Quad Truchet - BigWIngs\n\thttps://www.shadertoy.com/view/wlSGDD\n\n    Double Sided Quad Truchet - Shane\n\thttps://www.shadertoy.com/view/wl2GRG\n\n\n*/\n\n// I was undecided as to whether I wanted color, or not. Perhaps too busy?\n// Anyway, I've included it as an option.\n//#define CENTER_STRIPE\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Standard vec2 to float hash - Based on IQ's original.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(141.213, 289.197)))*43758.5453); }\n\n\n// Unsigned distance to the segment joining \"a\" and \"b\".\nfloat distLine(vec2 a, vec2 b){\n    \n     \n\tb = a - b;\n\tfloat h = clamp(dot(a, b)/dot(b, b), 0., 1.);\n    return length(a - b*h);\n}\n\n\n// IQ's signed distance to a quadratic Bezier. Like all of IQ's code, it's\n// quick and reliable. :)\n//\n// Quadratic Bezier - 2D Distance - IQ\n// https://www.shadertoy.com/view/MlKcDD\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){\n  \n    // p(t)    = (1 - t)^2*p0 + 2(1 - t)t*p1 + t^2*p2\n    // p'(t)   = 2*t*(p0 - 2*p1 + p2) + 2*(p1 - p0)\n    // p'(0)   = 2*(p1 - p0)\n    // p'(1)   = 2*(p2 - p1)\n    // p'(1/2) = 2*(p2 - p0)\n    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n     // If I were to make one change to IQ's function, it'd be to cap off the value \n    // below, since I've noticed that the function will fail with straight lines.\n    float kk = 1./max(dot(b,b), 1e-6); // 1./dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        res = sqrt( res );\n    }\n    \n    return res;\n}\n\n// Rendering the smooth Bezier segment. The idea is to calculate the midpoint\n// between \"a.xy\" and \"b.xy,\" then offset it by the average of the combined normals\n// at \"a\" and \"b\" multiplied by a factor based on the length between \"a\" and \"b.\"\n// At that stage, render a Bezier from \"a\" to the midpoint, then from the midpoint\n// to \"b.\" I hacked away to come up with this, which means there'd have to be a more\n// robust method out there, so if anyone is familiar with one, I'd love to know.\nfloat doSeg(vec2 p, vec4 a, vec4 b, float r){\n    \n    // Mid way point.\n   vec2 mid = (a.xy + b.xy)/2.; // mix(a.xy, b.xy, .5);\n    \n    // The length between \"a.xy\" and \"b.xy,\" multiplied by... a number that seemed\n    // to work... Worst coding ever. :D\n    float l = length(b.xy - a.xy)*1.732/6.; // (1.4142 - 1.)/1.4142;\n \n    // Points on the same edge each have the same normal, and segments between them\n    // require a larger arc. There was no science behind the decision. It's just \n    // something I noticed and hacked a solution for. Comment the line out, and you'll \n    // see why it's necessary. By the way, replacing this with a standard semicircular \n    // arc would be even better, but this is easier.\n    if(abs(length(b.zw - a.zw))<.01) l = r; \n  \n    // Offsetting the midpoint between the exit points \"a\" and \"b\"\n    // by the average of their normals and the line length factor.\n    mid += (a.zw + b.zw)/2.*l;\n\n    // Piece together two quadratic Beziers to form the smooth Bezier curve from the\n    // entry and exit points. The only reliable part of this method is the quadratic\n    // Bezier function, since IQ wrote it. :\n    float b1 = sdBezier(p, a.xy, a.xy + a.zw*l, mid);\n    float b2 = sdBezier(p, mid, b.xy + b.zw*l, b.xy);\n    \n    // Return the minimum distance to the smooth Bezier arc.\n    return min(b1, b2);\n}\n\n\n// vec4 swap.\nvoid swap(inout vec4 a, inout vec4 b){ vec4 tmp = a; a = b; b = tmp; }\n \n\nvec4 triPattern(vec2 p){\n    \n\n    // Scaling constant.\n    const float gSc = 4.;\n    p *= gSc;\n    \n    // Keeping a copy of the orginal position.\n    vec2 oP = p;\n    \n    // Smoothing factor: This can do my head in, sometimes. If you don't take screen\n    // resolution into account, the fullscree image can look too blurry. If you do, the\n    // image can look too crisp and lose something in the translation... Then there's PPI\n    // to consider... Damned if you do, damned if you don't. :D\n    float sf = 4./450.*gSc;\n    sf*=.3;\n    //float sf = 4./min(750., iResolution.y)*gSc;\n    \n    \n     \n    // SIMPLEX GRID SETUP\n    \n    vec2 s = floor(p + (p.x + p.y)*.36602540378); // Skew the current point.\n    \n    p -= s - (s.x + s.y)*.211324865; // Use it to attain the vector to the base vertex (from p).\n    \n    // Determine which triangle we're in. Much easier to visualize than the 3D version.\n    //float i = p.x < p.y? 1. : 0.; // Apparently, faster than: i = step(p.y, p.x);\n    //vec2 ioffs = vec2(1. - i, i);\n    \n    // Amalgamating to the two lines above into this.\n    vec2 ioffs = p.x < p.y? vec2(0, 1) : vec2(1, 0);\n    \n    \n    // Vectors to the other two triangle vertices.\n    vec2 ip0 = vec2(0), ip1 = ioffs - .2113248654, ip2 = vec2(.577350269);\n    \n    // Make the vertices match up by swapping two of the vertices on alternate triangles. \n    // Actually, it's not really necessary here, but if you want to check neighboring\n    // properties, etc, it's a habit worth getting into.\n    if(ioffs.x<.5) { vec2 tmp = ip0; ip0 = ip2; ip2 = tmp; }\n    \n    \n    // Centralize everything, so that vec2(0) is in the center of the triangle.\n    vec2 ctr = (ip0 + ip1 + ip2)/3.; // Centroid.\n    //\n    ip0 -= ctr; ip1 -= ctr; ip2 -= ctr; p -= ctr;\n    \n   \n    \n    \n    // Displaying the 2D simplex grid. Basically, we're rendering lines between\n    // each of the three triangular cell vertices to show the outline of the \n    // cell edges. There are faster ways to achieve this, but this will do.\n    float tri = min(min(distLine(p - ip0, p - ip1), distLine(p - ip1, p - ip2)), \n                  distLine(p - ip2, p - ip0));\n    \n    // Connecting points around the triangles. Two for each side. I should probably\n    // use a bit of trigonometry and hard code these, but I was feeling lazy. :)\n    const float offs = .204124; // Approx: length(ip0 - ip1)/4., or 1./sqrt(24.);\n    vec2 m01s = mix(ip0, ip1, .5 + offs);\n    vec2 m01t = mix(ip0, ip1, .5 - offs);\n    vec2 m12s = mix(ip1, ip2, .5 + offs);\n    vec2 m12t = mix(ip1, ip2, .5 - offs);\n    vec2 m20s = mix(ip2, ip0, .5 + offs);\n    vec2 m20t = mix(ip2, ip0, .5 - offs);\n    \n    // The boundary normals for each point. I should probably hardcode these as well.\n    vec2 n01 = -normalize(mix(ip0, ip1, .5));\n    vec2 n12 = -normalize(mix(ip1, ip2, .5));\n    vec2 n20 = -normalize(mix(ip2, ip0, .5));\n    \n    // Points, and their respective normals, to pass to the segment function.\n    vec4[6] pnt = vec4[6](vec4(m01s, n01), vec4(m01t, n01), \n                          vec4(m12s, n12), vec4(m12t, n12),\n                          vec4(m20s, n20), vec4(m20t, n20));\n    \n    \n    \n    // Shuffling the 6 array points and normals. I think this is the Fisher–Yates method, \n    // but don't quote me on it. It's been a while since I've used a shuffling algorithm, \n    // so if there are inconsistancies, etc, feel free to let me know.\n    //\n    // For various combinatorial reasons, some non overlapping tiles will probably be \n    // rendered more often, but generally speaking, the following should suffice.\n    //\n    for(int i = 5; i>0; i--){\n        \n        // Using the cell ID and shuffle number to generate a unique random number.\n        float fi = float(i);\n        \n        // Random number for each triangle: The figure \"s*3 + ioffs + 1\" is unique for\n        // each triangle... I can't remember why I felt it necessary to divide by 3,\n        // but I'll leave it in there. :)\n        float rs = hash21((s*3. + ioffs + 1.)/3. + fi/6.);\n        \n        // Other array point we're swapping with.\n        //int j = int(floor(mod(rs*6e6, fi + 1.)));\n        // I think this does something similar to the line above, but if not, let us know.\n        int j = int(floor(rs*(fi + .9999)));\n        swap(pnt[i], pnt[j]);\n        \n    }    \n\n    \n    vec3 d; // Distances for all three triangle cell segments.\n    \n    float dPnt = 1e5; // Distance for the edge points.\n    \n    for(int i = 0; i<3; i++){\n        \n        // The Bezier segments for each layer.\n        d[i] =  doSeg(p,  pnt[i*2], pnt[i*2 + 1], offs);\n        \n        // The two edge points for each side.\n        dPnt = min(dPnt, length(p - pnt[2*i].xy));\n        dPnt = min(dPnt, length(p - pnt[2*i + 1].xy));\n    }\n    \n    \n    d -= .05; // Giving the segment some width.\n    dPnt -= .0125; // Edge point size.\n    \n  \n    // Overall cell color and bump value.\n    vec3 col = vec3(1.);\n    //float bump = -.5;\n    \n    // Concentric triangle background pattern.\n    float pat = 1.;//clamp(cos(tri*96.)*.5 + .5, 0., 1.);\n    \n    // Background triangle borders.\n    //col = mix(col, col*1.5, 1. - smoothstep(0., sf, tri - .01));\n    //col = mix(col, col*.5, 1. - smoothstep(0., sf, tri - .0));\n \t\n    // Extra base shadowing for the bump pass.\n    //bump = mix(bump, 0., (1. - smoothstep(0., sf*3., min(min(d.x, d.y), d.z) - .03))*.5);\n\n    \n    // Rendering the layers. The bump value is similar to the color value, but differs slightly,\n    // in places, so ultimately needs its own variable. Obviously, this means doubling up on \n    // calculations, but thankfully, this is a 2D... ish example.\n    for(int i = 0; i<3; i++){\n        \n        // Shadows, stroke, color, etc.\n        //col = mix(col, vec3(.0), (1. - smoothstep(0., sf*3., d[i] - .03))*.85);\n        col = mix(col, vec3(.0), 1. - smoothstep(0., sf, d[i] - .02));\n        col = mix(col, vec3(1), 1. - smoothstep(0., sf, d[i]));\n//        col = mix(col, vec3(.03), 1. - smoothstep(0., sf, d[i] + .01));\n\n        \n\n    }\n    \n    // Return the color and bump value.\n    return vec4(col, 1.);\n    \n}\n \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Aspect correct pixel coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/min(750., iResolution.y);\n    \n    // Scaling and translation.\n\tuv = rot2(3.14159/12.)*(uv + vec2(.1, .05)*iTime);\n     \n    // Three color samples.\n    vec4 col = triPattern(uv);\n \n    fragColor = (max(col, 0.));\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}