{
    "Shader": {
        "info": {
            "date": "1687353473",
            "description": "Inspired by NR4s variant https://www.shadertoy.com/view/DdsyDX i gave it a try using an iterative scheme.\nThe technique is similar to https://www.shadertoy.com/view/ctBSWR and like there, it works ok but needed some fiddling to remove artifacts.",
            "flags": 0,
            "hasliked": 0,
            "id": "dsSczR",
            "likes": 5,
            "name": "Iterative Cissoid distance",
            "published": 3,
            "tags": [
                "2d",
                "sdf",
                "lagrange",
                "cissoid"
            ],
            "usePreview": 0,
            "username": "NinjaKoala",
            "viewed": 185
        },
        "renderpass": [
            {
                "code": "const int num_iterations=20;\n\nfloat cissoid(vec2 uv, float a, out vec2 grad){\n\tgrad = vec2(3.*uv.x*uv.x+uv.y*uv.y,(2.*uv.x-4.*a)*uv.y);\n\n\treturn dot(uv,uv)*uv.x-2.*a*uv.y*uv.y;\n}\n\nfloat lagrange_curve(vec2 uv, vec2 p2, float a, out vec2 grad){\n\tgrad = vec2(2.*(2.*a + uv.x + p2.x)*uv.y - 6.*uv.x*p2.y,(4.*a + uv.x)*uv.x - 2.*(2.*a - uv.x)*p2.x + (3.*uv.y - 2.*p2.y)*uv.y);\n\treturn (dot(uv,uv) + 2.*uv.x*p2.x + 4.*(uv.x - p2.x)*a)*uv.y - (3.*uv.x*uv.x + uv.y*uv.y)*p2.y;\n}\n\nvec2 iteration(vec2 p, vec2 p2, float a){\n\tfloat p_val1, p_val2;\n\tvec2 p_grad1, p_grad2;\n\n\tp_val2 = lagrange_curve(p,p2,a,p_grad2);\n\tp -= (p_grad2*p_val2)/dot(p_grad2,p_grad2);\n\n\tp_val1 = cissoid(p,a,p_grad1);\n\tp -= (p_grad1*p_val1)/dot(p_grad1,p_grad1);\n\n\treturn p;\n}\n\nfloat cissoid_dis(vec2 uv, float a){\n\tvec2 p0 = vec2(2.*a,uv.y+5.*a*sign(uv.y));\n\n\tfloat cusp_dis = length(uv);\n\n\tif(a > .15 && uv.x > 0. && cusp_dis < .05){\n\t\tp0.x = 0.;\n\t}\n\n\tfor(int i=0;i<num_iterations;i++){\n\t\tp0 = iteration(p0,uv,a);\n\t}\n\n\treturn min(cusp_dis,distance(p0,uv));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat border=2./iResolution.x;\n\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tuv-=.5;\n    uv.y*=iResolution.y/iResolution.x;\n\n\tvec2 mouse=iMouse.xy/iResolution.xy;\n\tmouse-=.5;\n    mouse.y*=iResolution.y/iResolution.x;\n\n\tfloat fac = .5+.5*sin(iTime*.2+1.);\n\n\tfloat dis = cissoid_dis(uv,fac);\n\n\t//iq's sd color scheme\n\tvec3 col = (dis>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp2(-12.0*abs(dis));\n\tcol *= 0.7 + 0.2*cos(480.0*dis);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,3.0*border,abs(dis)) );\n\n\tvec2 grad;\n\tfloat val = lagrange_curve(uv,mouse,fac,grad);\n\n\tfloat mdis = cissoid_dis(mouse,fac);\n\n\tcol = mix(vec3(1,0,0), col, smoothstep(0.,border,abs(distance(mouse,uv)-mdis)));\n\t//col = mix(vec3(0), col, smoothstep(0.,border,abs(val)/length(grad)));\n\n\tfragColor=vec4(col,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}