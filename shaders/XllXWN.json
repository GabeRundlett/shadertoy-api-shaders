{
    "Shader": {
        "info": {
            "date": "1439092883",
            "description": "Fully procedural Midgar city from Final Fantasy VII",
            "flags": 8,
            "hasliked": 0,
            "id": "XllXWN",
            "likes": 59,
            "name": "[SIG15] Midgar",
            "published": 3,
            "tags": [
                "3d",
                "raymarch",
                "sound",
                "midgar",
                "final",
                "fantasy"
            ],
            "usePreview": 1,
            "username": "davidbargo",
            "viewed": 4737
        },
        "renderpass": [
            {
                "code": "// Created by David Bargo - davidbargo/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define ITR 100\n#define FAR 150.\n#define PI 3.141592\n#define precis 0.001\n#define time iTime\n\n\nmat3 rot_x(float a)\n{\n    float sa = sin(a); \n    float ca = cos(a); \n    return mat3(1.,0.,0., 0.,ca,sa, 0.,-sa,ca);\n}\n\nmat3 rot_z(float a)\n{\n    float sa = sin(a); \n    float ca = cos(a); \n    return mat3(ca,sa,0., -sa,ca,0., 0.,0.,1.);\n}\n\n//----------------------------------------------------------------------------------------\n// From Dave_Hoskins\nvec2 hash22(vec2 p){\n    p  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\nvec3 hash33(vec3 p){\n    p  = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p += dot(p.yzx, p.xyz  + vec3(21.5351, 14.3137, 15.3219));\n    return fract(vec3(p.x * p.z * 95.4337, p.x * p.y * 97.597, p.y * p.z * 93.8365));\n}\n\nfloat hash12(vec2 p)\n{\n    p  = fract(p * vec2(443.8975,397.2973));\n    p += dot(p.xy, p.yx+19.19);\n    return fract(p.x * p.y);\n}\n//----------------------------------------------------------------------------------------\n\n//----------------------------------------------------------------------------------------\n// Distance functions by iq\nfloat ssphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sbox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat ubox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat urbox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat cyl( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat caps( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat torus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat length8(vec2 p)\n{\n    p *= p;\n    p *= p;\n    return pow(dot(p, p), 0.125);\n}\n\nfloat tube( vec3 p, vec2 t )\n{\n  return length(vec2(length8(p.xz)-t.x,p.y))-t.y;\n}\n\n//----------------------------------------------------------------------------------------\n// From iq\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n//----------------------------------------------------------------------------------------\n\nfloat fbm(vec3 p) \n{\n    return 0.65*noise(p) + 0.35*noise(m*p*2.02);\n}\n\n\nfloat matid = 0.;\nfloat light = 0.;\n\nfloat map(vec3 p)\n{    \n    // center bottom\n    float mn2 = cyl(p+vec3(p.x*0.35, 0.0, 0.2-0.1*p.y), vec2(0.64,0.98));\n    matid = 1.;\n    \n    // center middle\n    float mn = cyl(p+vec3(p.x*0.5,-1.,0.2-0.1*p.y), vec2(0.4,0.45));\n    matid += step(mn, mn2);\n    mn2 = min(mn, mn2);\n    \n    // side towers\n    float signx = sign(-p.x);\n    float stw = mix(0.2, 0.24, smoothstep(0.65, 0.7, p.y));\n    stw = mix(stw, 0.2, smoothstep(0.9, 0.95, p.y));\n    stw = mix(stw, 0.24, smoothstep(1.15, 1.22, p.y));\n    mn = caps(p + vec3( signx*0.75, 2.,0.3), vec3(0.,0.0,0.), vec3(0.0,3.2,0.), stw);   \n    matid = mix(matid, 3., step(mn, mn2));\n    mn2 = min(mn, mn2);\n    \n    // top main\n    mn = urbox(p+vec3(0.,-2.64,-0.09), vec3(0.06, 0.39, 0.2), 0.1);\n    \n    // top support\n    mn = min(mn, urbox(p+ vec3(0.12*signx, -1.8,-0.21 - 0.2*smoothstep(2.2, 1.8,p.y)), vec3(-0.01, 1., 0.06), 0.05));\n    matid = mix(matid, 4., step(mn, mn2));\n    mn2 = min(mn, mn2);\n    \n    // polar coords\n    vec3 pc = vec3(length(p.xz)*0.5, p.y*0.5, atan(p.z,p.x) - PI/16.);\n    \n    // mini towers\n    vec3 ps = pc;\n    float mtl = step(-3.22, pc.z)*step(pc.z, -2.67);\n    ps.z = (0.5+0.5*sin((ps.z)*48. - 1.))*0.15;\n    ps.x += -.87;\n    ps.x*=2.;\n    mn = caps(ps, vec3(0.), mtl*vec3(0.0,0.23,0.0), 0.07*mtl);\n    ps.x += -.17;\n    mn = min(mn, caps(ps, vec3(0.), mtl*vec3(0.0,0.17,0.0), 0.07*mtl));\n    matid = mix(matid, 5., mtl*step(mn, mn2));\n    mn2 = min(mn, mn2);\n    \n    // small wall lights\n    ps = pc;\n    ps.z = (0.5+0.5*sin((ps.z)*40. - 2.3))*0.06;\n    ps.y -= 0.14;\n    float wlc = smoothstep(0.78, 0.68, ps.x);\n    ps.x += -0.69;\n    float ss = 0.06*smoothstep(0.06, 0.03, ps.x) - 0.025*wlc;\n    float sls = step(-1.65, pc.z)*step(pc.z, -1.46) + step(-2.45, pc.z)*step(pc.z, -1.95);\n    mn = ssphere(ps, ss*sls);\n    \n    // big wall lights\n    ps = pc;\n    ps.z = (0.5+0.5*sin((ps.z)*48. + 1.))*0.12;\n    ps.y -= 0.27;\n    float wl = smoothstep(2.01, 1.9, ps.x);\n    ps.x += -2. + 0.08*wl;\n    float sb = 0.1*smoothstep(0.08, 0.03, ps.x) - 0.025*wl;\n    float slb = step(2.215, abs(pc.z))*step(abs(pc.z), 2.495) + step(-0.14, pc.z)*step(pc.z, 0.15);\n    mn = min(mn, ssphere(ps, sb*slb) + FAR*(1. - slb));\n    \n    matid = mix(matid, 6., step(mn, mn2));\n    mn2 = min(mn, mn2);\n    \n    // platforms\n    vec3 pl = pc;\n    float plr = step(abs(pl.z + 0.6), 0.33);\n    pl.z = 0.5+0.5*sin((pl.z)*8. + PI);\n    \n    vec3 hashp = hash33(floor(p*7.)/7.);\n    vec2 polarhash = hash22(floor(pc.zz*8.)/8. + 0.75)*0.6;\n    float bra = smoothstep(0., 1.2, pc.x);\n    bra *= bra; bra *= bra; bra *= bra;\n    float br = step(0.15*bra*bra, abs(pc.z + 0.55 + 0.1*hashp.z));\n    float bdgs = hash12(floor(pc.xz*32.)/32.);\n    bdgs *= step(bdgs, 0.5)*0.04;\n    mn = sbox(pl + vec3(-2.8+mix(polarhash.x, 1.5, plr),0.0,-0.3),\n              br*vec3(2.15 - mix(polarhash.x, 1.5, plr), 0.05 + step(pc.x, 1.9)*bdgs, 0.6));\n    matid = mix(matid, 7., step(mn, mn2));\n    mn2 = min(mn, mn2);\n    \n    // wall columns\n    ps = pc;\n    ps.z = 0.5+0.5*sin((ps.z)*8.);\n    float w = smoothstep(0.57, 0., pc.y);\n    ps.x += -2.;\n    mn = max(urbox(ps, vec3(0.075+0.025*w,0.38,-0.06 + 0.05*w), 0.1), -urbox(ps, vec3(0.07, 1.,-0.048), 0.05));\n\tmatid = mix(matid, 8., step(mn, mn2));\n    mn2 = min(mn, mn2);\n    \n    // back main building\n    mn = sbox(p+vec3(0.,0.0,-0.25+0.1*p.y), vec3(0.472, 0.98, 0.34));\n    mn = min(mn, sbox(p+vec3(0.,-.81,-0.4+0.1*p.y), vec3(0.262, 0.64, 0.36)));\n    \n    // building center tubes\n    mn = min(mn, cyl(p+ vec3(0.34*signx, -1.1+0.6*abs(p.x), 0.3), vec2(0.07, 0.5)));\n    mn = min(mn, cyl(p+ vec3(0.35*signx, -1.05+0.6*abs(p.x), 0.15), vec2(0.07, 0.5)));\n    mn = min(mn, cyl(p+ vec3(0.36*signx, -1.+0.6*abs(p.x), 0.), vec2(0.07, 0.5)));\n    \n    // building center cylinder\n    float sinpx = sin(p.x*100.);\n    float tw = mix(0.2, 0.25 + 0.005*sinpx, smoothstep( -0.4, -0.35, p.x));\n    tw =       mix( tw, 0.3,                smoothstep(-0.25, -0.15, p.x));\n    tw =       mix( tw, 0.3  + 0.005*sinpx, smoothstep( 0.15,   0.3, p.x));\n    tw =       mix( tw, 0.2,                smoothstep(  0.3,  0.42, p.x));\n    \n    mn = min(mn, cyl(p.yxz+vec3(-1.8, 0., 0.1), vec2(tw, 0.45)));\n    \n    mn = min(mn, torus((p.xzy+vec3(-0.04, 0.1, -1.8))*rot_z(1.2), vec2(0.32, 0.044)));\n    \n    // building back\n    float ba = smoothstep(0.925, 0., p.y);\n    mn = min(mn, max( urbox(p+ vec3(0.2*signx, -0.9,-1.2 + ba*1.5),\n                             vec3(0.1-p.y*0.08, 0.45, 0.2 + ba*0.88), 0.1),\n                     -urbox(p+vec3(0.2*signx, -1.2, -1.2), vec3(0.02, 0.3, 0.15), 0.01))); // bottom back\n    mn = min(mn, cyl(p.yxz+vec3(-0.6, 0.28*signx, -1.), vec2(0.12,0.2))); // back tube\n    \n    vec3 pos = (p+ vec3(0.4*signx, -1.1,-0.58))*rot_x(-PI*0.22);\n    mn = min(mn, urbox(pos, vec3(-0.01, 0.66, 0.04 + 0.16*smoothstep(-0.85, 0.85, pos.y)), 0.05));\n       \n    pos = (p+vec3(0.,-1.95,-0.4))*rot_x(PI*0.15);\n    pos.z -= 0.2*smoothstep(0.5,0.0,pos.y);\n    mn = min(mn, urbox(pos, vec3(0.01, 0.76, 0.1 + 0.12*smoothstep(0.5,0.0, pos.y)), 0.1)); // top back\n    \n    mn = min(mn, urbox(p+vec3(0.,-2.94,-0.2), vec3(0.01, 0.4, 0.01), 0.001)); // antenna\n    \n    mn = min(mn, tube(p+vec3(-signx*0.25,-2.34 - 0.3*p.z*step(0., p.z),-0.2), vec2(0.5, 0.05)));\n    \n    // center tubes\n    mn = min(mn, tube(p.zxy+vec3(1.43 ,0., -0.1), vec2(0.4, 0.1))); //center\n    mn = min(mn, cyl(p+vec3(0.,0.,1.85), vec2(0.46, 0.22)));\n    mn = min(mn, cyl(p+vec3(0.,0.,1.85), vec2(0.24, 0.3)));\n    \n    mn = min(mn, tube((p.zxy+vec3(0.25 ,1.2, -0.1))*rot_z(PI/6.), vec2(0.4, 0.14))); // right 1  \n    mn = min(mn, tube((p.xzy+vec3(0.7 , -0.3, -0.1))*rot_z(-PI/8.), vec2(0.8, 0.1))); // right 2   \n    mn = min(mn, tube((p.xzy+vec3(0.5, -0.5, -0.4))*rot_z(-PI/4.), vec2(0.8, 0.1))); // right 3   \n    mn = min(mn, tube((p.xzy+vec3(-1., 1., -0.4))*rot_z(-PI/4.), vec2(0.4, 0.1))); // left 1\n    mn = min(mn, tube(p.xzy+vec3(-1.3, 0., -0.2), vec2(0.4, 0.08))); // left 2\n    \n    // back towers \n    mn = min(mn,  cyl(p + vec3(0.76, 2., -0.3),   vec2(0.2-smoothstep(1.6, 2.1, p.y)*0.14, 4.0)));  \n    mn = min(mn,  cyl(p + vec3(0.64, 2., -0.64), vec2(0.2-smoothstep(1.8, 2.3, p.y)*0.14, 4.2)));\n    \n    // small platforms\n    float cp = step(-2., pc.z)*0.06;\n    mn = min(mn, ubox(pl + vec3(-0.83+cp,0.0,0.), vec3(0.17-cp,0.09*(step(pc.z, -0.1)+step(2.1, pc.z)),0.85)));\n    \n    // sectors walls\n    ps = pc;\n    ps.z = 0.5+0.5*sin((ps.z)*8. +0.7);\n    ps.x += -1.325;\n    mn = min(mn, sbox(ps, vec3(0.6,0.065+pc.x*0.052,0.02)));\n\n    ps.z = 0.5+0.5*sin((pc.z)*8. -0.7);\n    mn = min(mn, sbox(ps, vec3(0.6,0.065+pc.x*0.052,0.02)));\n    \n\t// first wall\n    ps = pc;\n    ps.z = 0.;\n    ps.y += 1.;\n    ps.x += -0.65;  \n    mn = min(mn, urbox(ps, vec3(0.0,1.13,2.), 0.05));\n    \n    // second wall\n    ps = pc;\n    ps.z = 0.5+0.5*sin((ps.z)*72.);\n    ps.x += -2.;   \n    mn = min(mn, sbox(ps, br*vec3(0.1, min(0.25, 0.24 - ps.x*1.1), 0.993+2.*step(ps.y, 0.13))));\n    \n    // presecond wall\n    mn = min(mn, sbox(pl + vec3(-1.9,-0.06,-0.35), br*vec3(0.1, 0.005+pc.x*0.052+step(1.86, pc.x)*0.005, 0.6)));\n\n    // sectors connector tube\n    ps.x += 0.7;\n    ps.y += -0.02;\n    mn = min(mn, sbox(ps, br*vec3(0.03,0.03,2.)));\n    \n    matid = mix(matid, 0., step(mn, mn2));\n    return min(mn, mn2);\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n    float h=precis*2.0;\n    float d = 0.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n        h = map(ro+rd*d);\n    }\n        \n    return d;\n}\n\nfloat smalllights(vec3 pc)\n{\n    vec3 ps = pc;\n    ps.z = (0.5+0.5*sin((ps.z)*40. - 2.3))*0.06;\n    ps.y -= 0.14;\n    float wlc = smoothstep(0.78, 0.68, ps.x);\n    ps.x += -0.69;\n    ps.x = min(ps.x-0.05, 0.);\n    float sc = step(-1.65, pc.z)*step(pc.z, -1.46) + step(-2.45, pc.z)*step(pc.z, -1.95);\n    return ssphere(ps, 0.02*(2.*sc -1.));\n}\n\nfloat biglights(vec3 pc)\n{\n    vec3 ps = pc;\n    ps.z = (0.5+0.5*sin((ps.z)*48. + 1.))*0.1;\n    ps.y -= 0.27;\n    float wl = smoothstep(1.62, 1.52, ps.x);\n    ps.x += -1.95 + 0.08*wl;\n    ps.x = min(ps.x-0.005, 0.);\n    \n    float sl = step(2.215, abs(pc.z))*step(abs(pc.z), 2.495) + step(-0.14, pc.z)*step(pc.z, 0.15);\n    return ssphere(ps, 0.04*(2.*sl -1.)+.01*(pc.x-1.95));\n}\n\nfloat lights(vec3 p)\n{\n    vec3 pc = vec3(length(p.xz)*0.5, p.y*0.5, atan(p.z,p.x) - PI/16.);\n    float sl = smalllights(pc);\n    \n    float bl = biglights(pc);\n    light = step(bl, sl);\n    \n    return min(bl, sl);\n}\n\nvec3 marchlights(in vec3 ro, in vec3 rd, float far)\n{\n    light = 0.;\n    \n    float h=precis*2.0;\n    float d = 0.;\n    for( int i=0; i<60; i++ )\n    {\n        if( abs(h)<precis || d>far ) break;\n        d += h;\n        h = lights(ro+rd*d);\n    }\n    \n    if (d < far)\n    {\n        vec3 lpos = (ro+rd*d);\n        float dist = length(lpos.xz);\n        \n        if (light == 0.)\n        {\n            float ld = precis*2.;\n            \n            for( int i=0; i<30; i++ )\n            {\n                if( h > precis*2.) break;\n                vec3 lposb = (lpos+rd*ld);\n                vec3 pc = vec3(length(lposb.xz)*0.5, lposb.y*0.5, atan(lposb.z,lposb.x) - PI/16.);\n                h = smalllights(pc);\n                ld += max(abs(h), precis*2.);\n            }\n\t\t\t\n            light = smoothstep(2.2, 0., dist)*ld*ld*10.;\n        }\n        else if (light == 1.)\n        {\n            float ld = precis*2.;\n            \n            for( int i=0; i<40; i++ )\n            {\n                if( h > precis*2.) break;\n                vec3 lposb = (lpos+rd*ld);\n                vec3 pc = vec3(length(lposb.xz)*0.5, lposb.y*0.5, atan(lposb.z,lposb.x) - PI/16.);\n                h = biglights(pc);\n                ld += max(abs(h), precis*2.);\n            }\n\t\t\t\n            light = smoothstep(6.7, 0., dist)*ld*ld*1.5;\n        }\n    }\n\n    return vec3(1.,1.,0.7)*fract(light);   \n}\n\nfloat makolight(vec3 p)\n{\n    p.y *= 0.3;\n    return ssphere(p, 1.15);\n}\n\nvec3 makocolor(vec3 p)\n{\n    float n = noise(p.xzz);\n        \n    vec3 pc = vec3(length(p.xz)*0.5, p.y, atan(p.z,p.x));\n\t\n    float hl = mix(0.4, 1., smoothstep(-2.8, -2.7, pc.z));\n    hl = mix(hl, 0.4, smoothstep(-1.8, -1.65, pc.z));\n    hl = mix(hl, 1., smoothstep(-1.5, -1.4, pc.z));\n    hl = mix(hl, 0.6, smoothstep(-1., -0.9, pc.z));\n    hl = mix(hl, 1., smoothstep(-0.7, -0.6, pc.z));\n    hl = mix(hl, 0.5, smoothstep(-0.2, -0.05, pc.z));\n    hl = mix(hl, 1., smoothstep(0.05, 0.2, pc.z));\n    hl = mix(hl, 0.4, smoothstep(1., 1.2, pc.z));\n    hl = mix(hl, 0.9, smoothstep(1.9, 2.2, pc.z));\n    hl = mix(hl, 0.4, smoothstep(2.8, 3., pc.z));\n    \n    float intensity = 0.25*smoothstep((0.7+0.8*n)*hl, 0., p.y)*step(pc.x, 0.6);\n    \n\n    float mp = intensity*fbm(vec3(30.*p.x,1.5*p.y-2.*time,p.z*30.));\n    return mp*mix(vec3(0.0, 0.4, 0.8), \n              mix(vec3(0.2, 0.9, 0.6), \n                  vec3(0.5, 0.5, 0.0), smoothstep(0.3 + 0.3*n, 0.6 + 0.6*n, p.y)), smoothstep(-0.5, 0.3 + 0.3*n, p.y));\n\n}\n\nvec3 marchmako(in vec3 ro, in vec3 rd, float far)\n{\n    vec3 color = vec3(0.);\n    float h=precis*2.0;\n    float d = h;\n    \n    for( int i=0; i<50; i++ )\n    {\n        if( abs(h)<precis || d>far ) break;\n        d += h;\n        h = makolight(ro+rd*d);\n    }\n    \n    if (d < far)\n    {\n        color = makocolor(ro+rd*d);\n            \n        // back face\n        d += h;\n        for(int i = 0; i < 50; i++)\n        {\n            if(h > precis*2. || d > far) break;           \n            h = makolight(ro+rd*d);\n            d += max(abs(h), precis*2.);\n        }\n        if (d < far) \n        {\n            color += makocolor(ro+rd*d);\n        }\n    }\n        \n    return color;\n}\n\nfloat tex(in vec3 q)\n{\n    vec3 h = hash33(floor(q*4.)/4.);\n    return (h.x+h.y+h.z)*0.1;\n}\n\nfloat mapN(in vec3 p)\n{\n    float d= map(p);\n    d += tex(p*10.)*0.005;\n    return d;\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.008;\n\treturn normalize(e.yxx*mapN(p + e.yxx) + e.xxy*mapN(p + e.xxy) + \n\t\t\t\t\t e.xyx*mapN(p + e.xyx) + e.yyy*mapN(p + e.yyy) );   \n}\n\n//from iq\nfloat getAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.13*float(i)/3.;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1. - 3.5*occ, 0.0, 1.0 );    \n}\n\nvec3 shinralogo(vec2 pos, vec2 center, float size)\n{\n    vec2 absp = vec2(abs(pos.x - center.x), abs(pos.y - center.y)*1.3);\n    float clogo = step(size, absp.y + absp.x);\n    float blogo = step(absp.y, size*0.8)*step(absp.x, size*0.8);\n    vec3 col = vec3(step(absp.y, size)*step(absp.x, size));\n    col.r -= 0.8*clogo*blogo;\n    float gb = 1. - (1.-blogo)*clogo;\n    col.gb -= gb*step(2.*(pos.y - center.y) - absp.x*4., 0.4*size);\n    return clamp(col, 0., 1.);\n}\n\nfloat tri(in float x)\n{\n    return abs(fract(x)-.5);\n}\n\n// From nimitz\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    \n    //Triangular deformation (used to break sphere intersection pattterns)\n    p.x += (tri(p.z*50.)+tri(p.y*50.))*0.006;\n    p.y += (tri(p.z*50.)+tri(p.x*50.))*0.006;\n    p.z += (tri(p.x*50.)+tri(p.y*50.))*0.006;\n    \n\tfor (float i=0.;i<2.;i++)\n    {\n        vec3 q = fract(p*250.)-0.5;\n        vec3 id = floor(p*250.);\n        float rn = hash33(id).z;\n        float c2 = 1.-smoothstep(-0.2,.4,length(q));\n        c2 *= step(rn,0.005+i*0.014);\n        c += c2*(mix(vec3(1.0,0.75,0.5),vec3(0.85,0.9,1.),rn*30.)*0.5 + 0.5);\n        p *= 1.15;\n    }\n    return c*c*smoothstep(-0.1, 0., p.y);\n}\n\nfloat platformTex(vec2 p)\n{\n\tfloat hp = hash12(floor(p));\n    vec2 fp = fract(p);\n    \n    float s = sign(fp.x - hp);   \n    float ha = hash12(floor(p-vec2(s, 0.0)));\n    float hb = hash12(floor(p+vec2(0.0, s))) + s;\n    float hc = hash12(floor(p+vec2(s, s))) + s;\n    \n    vec2 p1 = vec2(hp, ha);\n    vec2 p2 = vec2(hb, hc);\n\n    vec2 sp = sign(p1 - p2);\n    vec2 sp1 = p1*sp;\n\tvec2 sp2 = -p2*sp;\n    vec2 f = max(abs(fp - (p1+p2)*0.5) - (sp1+sp2)*0.5 + 0.033, 0.0);\n    return clamp(1.0 - dot(f, f)*1000., 0.0, 1.0);\n}\n\nvec3 cam()\n{\n    float t = time*0.25 - 0.5;\n    vec3 pos = vec3(-6.5, 7.3, -11.5);\n    pos = mix(pos, vec3(-6.5, 1.2, -3.2), smoothstep(1., 10., time));\n    pos = mix(pos, vec3(0., 3.5, -8.5), smoothstep(8., 18., time)); \n    pos = mix(pos, vec3(9.5, 7.2, -2.5), smoothstep(16., 26., time));    \n    pos = mix(pos, vec3(9.5, 6.2, -2.5), smoothstep(25., 27., time));    \n    pos = mix(pos, vec3(4.5, 1., 4.5), smoothstep(29., 36., time));    \n    pos = mix(pos, vec3(-1., 1., 4.5), smoothstep(34., 42., time));\n    pos = mix(pos, vec3(13.*sin(t),8.+2.5*sin(t+0.1),-13.*cos(t)), smoothstep(40., 50., time));\n    \n    return pos;\n}\n\nvec3 target()\n{\n    vec3 ta = vec3(0.0,0.7,0.0);\n    ta = mix(ta, vec3(0.0,1.9,0.0), smoothstep(1., 10., time));\n    ta = mix(ta, vec3(0.0,1.6,0.0), smoothstep(9., 18., time));    \n    ta = mix(ta, vec3(0.0,1.,0.0), smoothstep(16., 26., time));    \n    ta = mix(ta, vec3(0.0,-1.,0.0), smoothstep(24., 27., time));   \n    ta = mix(ta, vec3(0.0,-3.,5.0), smoothstep(26.5, 30., time));  \n    ta = mix(ta, vec3(0.0,1.,4.0), smoothstep(30.5, 36., time));   \n    ta = mix(ta, vec3(-1.0,1.,0.0), smoothstep(34., 42., time));\n    ta = mix(ta, vec3(0.0,0.7,0.0), smoothstep(40., 50., time));\n    \n    return ta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 p = fragCoord.xy/iResolution.xy-0.5;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = cam();\n    vec3 ta = target();\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n    \n    float d = march(ro,rd);\n    \n    vec3 col = stars(rd);\n     \n    if ( d < FAR )\n    {\n        vec3 pos = ro+d*rd;\n        float mid = matid;\n        vec3 nor = normal(pos);\n        \n        \n        vec3 pc = vec3(length(pos.xz), pos.y, atan(pos.z,pos.x) - PI/16.);\n        vec3 pl = pc;\n        pl.z = 0.5+0.5*sin(pl.z*8. + PI);\n          \n        vec3 lpos = vec3(0., 0.38, 0.);\n        lpos.xz = 1.25*normalize(pos.xz);\n        vec3 lt = (lpos - pos);\n        vec3 lgt = 0.15*lt;\n        \n        vec3 lgtp = (ta + 0.5*normalize(pos - ta) - pos)*0.5;\n        \n        float dif = clamp( dot( nor, lgt ), 0.0, 1.0 ) + 0.4*clamp( dot( nor, lgtp ), 0.0, 1.0 );\n        float spe = pow(clamp( dot( reflect(rd,nor), lgt ), 0.0, 1.0 ),7.);\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 3.0 );\n        vec3 brdf = vec3(1.)*2.*dif;\n        \n        col = vec3(0.04,0.04,0.02);\n        \n        float ao = getAO(pos,nor);\n\n        if (mid == 1.)\n        {\n            col = col*brdf +.03*fre;\n            col *= ao;\n            \n            float l = 0.5 + 0.5*sin(pos.y*98.);\n            l *= l*step(pos.y, 0.95);\n            float h = hash12(floor(pos.xy*31.)/31.);\n            h = 0.9*step(0.7, h);\n            col += vec3(1. - h*0.7, 1. - h,0.)*l*l*0.1;\n        }\n        else if (mid == 2.)\n        {\n            col += shinralogo(pos.xy, vec2(0., 1.22), 0.12)*0.5;\n            col = col*brdf +.03*fre;\n            col *= ao;\n            \n            float l = 0.5 + 0.5*sin(pos.y*98.);\n            \n            l *= l*step(abs(pos.y - 1.19), 0.19)*step(0.15, abs(pos.x));\n            float h = hash12(floor(pos.xy*31.)/31.);\n            h = 0.9*step(0.8, h);\n            col += vec3(1. - h*0.7, 1. - h,0.)*l*l*0.1;\n        }\n        else if (mid == 3.)\n        {\n            col = col*brdf +.03*fre;\n            col *= ao;\n            \n            float l = 0.5 + 0.5*sin(pos.y*98.);\n            l *= l*step(pos.y, 1.15)*(step(pos.y, 0.65) + step(0.95, pos.y));\n            float h = hash12(floor(pos.xy*31.)/31.);\n            h = 0.9*step(0.8, h);\n            col += vec3(1. - h*0.7, 1. - h,0.)*l*l*0.1;\n        }\n        else if (mid == 4.)\n        {\n            col += shinralogo(pos.xy, vec2(0., 2.5), 0.06)*0.5;\n            \n            col = col*(0.05) +.03*fre;\n            col *= ao;\n            \n            float l = 0.5 + 0.5*sin(pos.y*98.);\n            l *= l*step(pos.z, -0.16*step(pos.y, 2.88))*step(pos.y, 3.05)*step(2.6, pos.y);\n            float h = hash12(floor(pos.xy*23.)/23.);\n            h = 0.9*step(0.5, h);\n            col += vec3(1. - h*0.7, 1. - h,0.)*l*l*0.1;\n        }    \n        else if (mid == 5.)\n        {\n            col = col*brdf +.03*fre;\n            col *= ao;\n            \n            float d = mix(step(abs(pos.y - 0.49), 0.01), step(abs(pos.y - 0.38), 0.01), step(1.82, pl.x));\n            \n            col += vec3(1., 1.,0.)*d*0.1;\n        }       \n        else if (mid == 6.)\n        {\n            col = col*brdf +.03*fre;\n            col *= ao;\n            \n            col += 0.5*mix(smoothstep(1.448, 1.458, pl.x), smoothstep(4.08, 4.11, pl.x), step(2.5, pl.x));\n            \n        }        \n        else if (mid == 7.)\n        {\n            float f = 0.;\n            vec3 l = vec3(0.);\n            \n            if (pl.x < 3.6)\n            {\n                float br = step(0.4, abs(pc.z + 0.46));\n            \tcol += vec3(0.5, 0.35, 0.)*noise(pos*5.5)*(0.3 + 0.7*br);\n                l = vec3(0.5, 0.3, 0.)*step(0.993, hash12(floor(pos.xz*50.)/50.))*step(pl.x, 3.4)*br;\n            }\n            else\n            {\n\t\t\t\tvec2 pt = vec2(pc.x, pc.z*7.);\n                col += platformTex(pt)*0.04;\n                float el = step(4.18, pl.x)*smoothstep(0.51, 0.42, pl.z*10.0/pl.x)*smoothstep(-0.2, -0.18, -pl.y)*smoothstep(5.7, 4.3, pl.x);       \n            \tl = vec3(1.,1.,0.7)*(0.02*el*smoothstep(0., 0.2, col.r));\n            }\n \n            col = col*0.05 + 0.03*fre;\n            col *= ao;          \n            col += l;\n        }       \n        else if (mid == 8.)\n        {\n            col += shinralogo(pl.xy, vec2(4.02, 0.6), .16)*0.5;\n            \n            float rl = hash12(floor((pos.xz )*0.25 + 1.5)/1.);\n            float st = 0.5 + 0.5*sin(time*(2.+rl) + rl*10.); \n            col += vec3(0.0, 0.75, 0.3)*smoothstep(0.85, 1., pos.y);\n            col = col*0.05 +.03*fre;\n            col *= ao*(4. - 3.*mix(1., smoothstep(0.95, 0.75, pos.y), st));\n            col += (0.25 + 0.75*st)*vec3(0.1, 1., 0.7)*smoothstep(0.95, 0.75, pos.y)*step(0.998, pl.z)*step(abs(pl.x - 4.), 0.16);\n        }       \n        else \n        {\n            col = col*brdf +.03*fre;\n            col *= ao;          \n        }\n          \n        // fake platform lights\n        float el = step(4.18, pl.x)*smoothstep(0.51, 0.42, pl.z*10.0/pl.x)*smoothstep(-0.2, -0.18, -pl.y)*smoothstep(5.7, 4.3, pl.x);       \n        col += vec3(1.,1.,0.7)*(0.6*el*smoothstep(4.22, 4.2, pl.x));\n                \n        col *= smoothstep(90.0, 0.0, dot(pos, pos));\n        col *= smoothstep(-0.6, -0.1, pos.y);\n    }\n\n    col += marchlights(ro, rd, d);\n    col += marchmako(ro, rd, d);\n    col = pow(clamp(col*1.5,0.,1.), vec3(0.416667))*1.055 - 0.055; //sRGB\n        \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by David Bargo - davidbargo/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n/*\n\tSong: Aerith's theme slightly modified to fit in the 60s limit\n\tI'm using the same kind of sequencer iq implemented in https://www.shadertoy.com/view/ldXXDj\n*/\n\nfloat instrument( float freq, float time )\n{    \n    float y = 0.70*sin(6.2831*freq*time)*exp(-0.0075*freq*time);\n    y += 0.20*sin(2.01*6.2831*freq*time)*exp(-0.0055*freq*time);\n    y *= clamp( time/0.004, 0.0, 1.0 );\n\treturn y;\t\n}\n\nfloat instrument2( float freq, float time )\n{    \n    float ph = sin(6.2831*freq*time);\n    ph *= 0.2+0.8*max(0.0,6.0-0.01*freq);\n    ph *= exp(-time*freq*0.2);\n   \n    float y = 0.70*sin(6.2831*freq*time+ph)*exp(-0.005*freq*time);\n    y += 0.20*sin(2.01*6.2831*freq*time+ph)*exp(-0.0055*freq*time);\n    y += 0.16*sin(4.01*6.2831*freq*time+ph)*exp(-0.009*freq*time);\n    y *= clamp( time/0.004, 0.0, 1.0 );\n\n\treturn y;\t\n}\n\n#define D(a) b+=a;x+=step(b,t)*(b-x);\n\n#define tint 0.00184\n\nfloat doChannel1( float t )\n{\n    float x = t;\n    float y = 0.0;\n    float b = 0.0;\n     \n    D(1280.)D(1340.)D(3076.)D(1536.)D(1536.)D(4608.)D(1536.)\n    y += instrument2(369.99, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(4160.)D(6144.)D(1536.)D(4608.)\n    y += instrument2(392.0, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(2816.)D(3072.)D(1536.)D(1536.)D(4608.)D(1536.)\n    y += instrument2(440.0, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(4352.)D(6144.)D(1536.)D(4608.)\n    y += instrument2(493.88, tint*(t-x) );\n    \n    x = t; b = 0.0;\n    D(3008.)D(4608.)D(1536.)D(4608.)D(1536.)\n    y += instrument2(554.37, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(1472.)D(3072.)D(1536.)D(4608.)D(1536.)D(4608.)D(14400.)D(384.)\n    y += instrument2(587.33, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(31424.)\n    y += instrument2(659.26, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(19904.)D(192.)D(10944.)\n    y += instrument2(739.99, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(28160.)D(768.)D(1920.)\n    y += instrument2(783.99, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(19328.)D(6144.)D(2880.)D(384.)\n    y += instrument2(880.0, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(18944.)D(3068.)D(3076.)D(3456.)\n    y += instrument2(987.77, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(21632.)D(768.)D(2304.)\n    y += instrument2(1108.73, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(18176.)D(384.)D(2688.)D(3072.)D(4800.)\n    y += instrument2(1174.66, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(26216.)D(24.)\n    y += instrument2(1318.51, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(22976.)D(192.)\n    y += instrument2(1479.98, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(896.)\n    y += instrument2(246.94, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(2432.)D(4608.)D(1536.)D(4608.)D(1536.)\n    y += instrument2(277.18, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(1088.)D(2880.)D(1536.)D(4608.)D(1536.)D(4608.)\n    y += instrument2(293.66, tint*(t-x) );\n\n    return y;\n}\n\n\nfloat doChannel2( float t )\n{\n    float x = t;\n    float y = 0.0;\n    float b = 0.0;\n    \n    D(704.)\n    y += instrument(329.63, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(896.)D(1152.)D(4800.)D(1728.)D(4416.)D(1728.)\n    y += instrument(369.99, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(2240.)D(2880.)D(5760.)\n    y += instrument(392.0, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(2432.)D(3072.)D(192.)D(960.)D(6144.)\n    y += instrument(440.0, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(3584.)D(768.)D(1248.)\n    y += instrument(493.88, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(3776.)D(30144.)\n    y += instrument(554.37, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(3968.)D(15936.)D(192.)D(9024.)D(4416.)\n    y += instrument(587.33, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(25472.)D(768.)D(1920.)D(768.)\n    y += instrument(659.26, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(19328.)D(3648.)D(192.)D(5184.)D(384.)D(2496.)D(384.)\n    y += instrument(739.99, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(18944.)D(3072.)D(3072.)D(3456.)D(2880.)\n    y += instrument(783.99, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(18560.)D(3072.)D(768.)D(2304.)D(6336.)\n    y += instrument(880.0, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(18176.)D(3072.)D(3072.)D(6528.)\n    y += instrument(987.77, tint*(t-x) );\n    \n    x = t; b = 0.0;\n    D(12416.)\n    y += instrument(246.94, tint*(t-x) );\n    \n    x = t; b = 0.0;\n    D(7040.)D(2304.)D(3840.)D(2304.)\n    y += instrument(277.18, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(512.)D(9600.)D(1536.)D(4608.)\n    y += instrument(293.66, tint*(t-x) );\n\n    return y;\n}\n\n\nfloat doChannel3( float t )\n{\n    float x = t;\n    float y = 0.0;\n    float b = 0.0;\n    \n    D(2240.)\n    y += instrument(329.63, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(936.)D(1112.)D(3456.)D(7680.)\n    y += instrument(369.99, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(3968.)\n    y += instrument(392.0, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(22400.)\n    y += instrument(92.5, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(22016.)\n    y += instrument(98.0, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(23168.)\n    y += instrument(103.83, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(20864.)D(2688.)D(3456.)\n    y += instrument(110.0, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(21248.)D(2688.)D(576.)\n    y += instrument(123.47, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(24704.)\n    y += instrument(138.59, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(10112.)D(10368.)D(4608.)\n    y += instrument(146.83, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(25472.)\n    y += instrument(164.81, tint*(t-x) );\n    \n    x = t; b = 0.0;\n    D(20096.)\n    y += instrument(185.0, tint*(t-x) );\n    \n    x = t; b = 0.0;\n    D(9344.)D(576.)D(5568.)\n    y += instrument(220.0, tint*(t-x) );\n    \n    x = t; b = 0.0;\n    D(8576.)D(1152.)D(4992.)D(1152.)\n    y += instrument(246.94, tint*(t-x) );\n    \n    x = t; b = 0.0;\n    D(2432.)D(5376.)D(6144.)D(2112.)\n    y += instrument(277.18, tint*(t-x) );\n\n    x = t; b = 0.0;\n    D(16256.)\n    y += instrument(293.66, tint*(t-x) );\n\n    return y;\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    float t = time/tint;\n    vec2 y = vec2(0.5,0.5)*doChannel1(t);\n    y += vec2(0.25,0.75)*doChannel2(t);\n    y += vec2(0.75,0.25)*doChannel3(t);\n    return y*.8;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 38
                    }
                ],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}