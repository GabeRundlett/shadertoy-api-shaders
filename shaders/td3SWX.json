{
    "Shader": {
        "info": {
            "date": "1572988268",
            "description": "Experiment with 3d Truchet tiles",
            "flags": 0,
            "hasliked": 0,
            "id": "td3SWX",
            "likes": 9,
            "name": "Shadertober 31 Tangle -jaburns",
            "published": 3,
            "tags": [
                "raymarch",
                "truchet"
            ],
            "usePreview": 0,
            "username": "jaburns",
            "viewed": 547
        },
        "renderpass": [
            {
                "code": "#define EPS         0.005\n#define ITERATIONS  100\n#define MAX_DIST    50.\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat hash31( vec3 p )\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,91.495))) * 43758.5453);\n}\n\n\nmat2 rot( float theta )\n{\n    float c = cos( theta );\n    float s = sin( theta );\n    return mat2( c, s, -s, c );\n}\n\nfloat tile( vec3 op, vec3 p, int kind, vec3 cell ) // kind: [0,8)\n{\n    const float PI_4 = 3.14159/4.;\n    const float PI_2 = 3.14159/2.;\n    const vec2 SC = vec2(sin(PI_4), cos(PI_4));\n    const mat2 ROT = mat2(cos(PI_4), sin(PI_4), -sin(PI_4), cos(PI_4));\n    const mat2 ROT2 = mat2(cos(PI_2), sin(PI_2), -sin(PI_2), cos(PI_2));\n    const mat2 nROT = mat2(cos(PI_4), -sin(PI_4), sin(PI_4), cos(PI_4));\n    \n    op /= 2.;\n    float to = dot(op,op);\n    float rb = .05 + .02*sin(to);\n    \n    if (kind >= 4) p.yz = p.zy;\n    for (int i = 0; i < kind % 4; ++i) p.yz *= ROT2;   \n    \n    vec3 q;\n    q = p;\n    q.xy += vec2(-.5,.5);\n    q.xy *= ROT;\n    float A = sdCappedTorus( q, SC, .5, rb );\n\n    q = p.xzy;\n    q.xy += vec2(.5,.5);\n    q.xy *= nROT;\n    float B = sdCappedTorus( q, SC, .5, rb );\n    \n    q = vec3(p.y, -p.z, p.x);\n    q.xy += vec2(-.5,.5);\n    q.xy *= ROT;\n    float C = sdCappedTorus( q, SC, .5, rb );\n    \n    return min(A, min(B, C));\n}\n\nstruct Map\n{\n    float dist;\n    vec3 cell;\n};\n\nMap map( vec3 p )\n{\n    vec3 q = mod(p + .5, 1.) - .5;\n    vec3 cell = floor(p + .5);\n    int kind = int(8.*hash31(cell));\n   \n    float leftBox   = 1000.; //sdBox( p - vec3( 1, 0,0), vec3(.5) );\n\tfloat rightBox  = sdBox( p - vec3(-1, 0,0), vec3(.5) );\n    float bottomBox = sdBox( p - vec3( 0,-1,0), vec3(.5) );\n    float boxes = min(bottomBox, min(leftBox, rightBox));\n    boxes = 1000.;\n    \n    float tile = tile(p, q, kind, cell);\n        \n    return Map(min(boxes, tile), cell);\n}\n\nstruct March\n{\n    vec3 pos;\n    float dist;\n    float ao;\n};\n   \nMarch march( vec3 ro, vec3 rd )\n{\n    Map dist;\n    float totalDist = 0.0;\n    int i;\n    for(  i =0; i < ITERATIONS; ++i )\n    {\n        dist = map( ro );\n        if( dist.dist < EPS || totalDist > MAX_DIST ) break;\n        totalDist += dist.dist;\n        ro += dist.dist * rd;\n    }\n    \n    return March( ro, dist.dist < EPS ? totalDist : -1.0, .25*float(i) / 100. );\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(EPS, 0);\n    return normalize(vec3(\n        map(p + e.xyy).dist - map(p - e.xyy).dist,\n        map(p + e.yxy).dist - map(p - e.yxy).dist,\n        map(p + e.yyx).dist - map(p - e.yyx).dist));\n}\n\nvec3 skybox( vec3 d )\n{\n    return .4 + .3*normalize(d);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(5.5,.5,.5);\n    vec3 rd = normalize(vec3(uv, 1));\n    \n    float t = .3*iTime;\n    ro.xy *= rot(.4*t);\n    rd.yz *= rot(.7*t);\n    rd.xz *= rot(.3*t);\n\n    March m = march( ro, rd );\n    \n\tvec3 bgcolor = skybox(rd);\n    vec3 color = bgcolor;\n    float lightness = 0.;\n    \n    if( m.dist >= 0.0 )\n    {\n        color = .6+.4*cos(m.pos.zxy+m.pos.xyz);\n        vec3 normal = getNormal(m.pos);\n        color = mix(color, 2.*skybox(reflect(rd, normal)), .4);\n        \n        lightness = max(0., (exp(-.1*(m.dist)) - m.ao));\n    }\n    \n    const float GAMMA = 2.2;\n    color = pow(color, vec3(1. / GAMMA));\n    fragColor = vec4(mix(bgcolor,color,lightness),1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}