{
    "Shader": {
        "info": {
            "date": "1611449747",
            "description": "Approach to align texture along bezier spline.",
            "flags": 0,
            "hasliked": 0,
            "id": "tt33WX",
            "likes": 5,
            "name": "Texture along spline",
            "published": 3,
            "tags": [
                "bezier",
                "curve",
                "image"
            ],
            "usePreview": 0,
            "username": "blurryroots",
            "viewed": 596
        },
        "renderpass": [
            {
                "code": "/**\nBezier Spline Texture\nBy blurryroots innovation qanat OÃœ\n*/\n// Shadertoy Educational License\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n// You are free however, to incorporate this work within the Shadertoy\n// ecosystem, e.g. by forking.\n// This work may incorporate other permissivly shared, educational work,\n// which is attributed appropriatly. Please do so as well.\n// Thanks to https://www.shadertoy.com/user/iq for inspiring this license.\n\n\n#define MouseV (iMouse.y / iResolution.y)\n#define MouseU (iMouse.x / iResolution.x)\n#define UV_DEBUG 0\n#define SHOW_CONTROL_RIG 1\n#define DEFORM_BEZIER 1\n\n//Inspired by https://www.shadertoy.com/view/4ljfRD\nfloat drawLine (vec2 p1, vec2 p2, vec2 uv, float a)\n{\n    float r = 0.;\n    float one_px = 1. / iResolution.x; //not really one px\n    \n    // get dist between points\n    float d = distance(p1, p2);\n    \n    // get dist between current pixel and p1\n    float duv = distance(p1, uv);\n\n    //if point is on line, according to dist, it should match current uv \n    r = 1.-floor(1.-(a*one_px)+distance (mix(p1, p2, clamp(duv/d, 0., 1.)),  uv));\n        \n    return r;\n}\n\nvec3 DrawLine(vec2 A, vec2 B, vec2 UV, float Thickness, vec3 Color)\n{\n    vec2 Direction = normalize(B - A);\n    float Dist = distance(A, B);\n    \n    vec3 Right = cross(vec3(Direction, 0.), vec3(0., 0., 1.));\n    \n    return vec3(0.);\n}\n\nvec2 QuadraticBezier(vec2 A, vec2 B, vec2 C, float t)\n{\n\tvec2 AB = mix(A, B, t);\n\tvec2 BC = mix(B, C, t);\n\n\tvec2 P = mix(AB, BC, t);\n\n\treturn P;\n}\n\nvec2 CubicBezier(float t, vec2 A, vec2 B, vec2 C, vec2 D)\n{\n\tvec2 AB = mix(A, B, t);\n\tvec2 BC = mix(B, C, t);\n\tvec2 CD = mix(C, D, t);\n\n\tvec2 P = QuadraticBezier(AB, BC, CD, t);\n\n\treturn P;\n}\n\nvec2 DeformUVByControlPoints_Linear(vec2 UV, vec2 A, vec2 TangentA, vec2 TangentB, vec2 B)\n{\n    float x;\n    \n    if (UV.x <= TangentA.x) {\n    \tx = (UV.x - A.x) / (TangentA.x - A.x);\n        \n        UV.y += 0.5 - mix(A.y, TangentA.y, x);\n    }\n    else if (UV.x <= TangentB.x) {\n        x = (UV.x - TangentA.x) / (TangentB.x - TangentA.x);\n        \n        UV.y +=  0.5 - mix(TangentA.y, TangentB.y, x);\n        \n    }\n    else if (UV.x <= B.x) {\n        x = (UV.x - TangentB.x) / (B.x - TangentB.x);\n        \n        UV.y += 0.5 - mix(TangentB.y, B.y, x);\n    }\n    \n    return UV;\n}\n\nvec2 DeformUVByControlPoints_Bezier(vec2 UV, vec2 A, vec2 TangentA, vec2 TangentB, vec2 B)\n{\n\tfloat uvx = UV.x;\n    \n    vec2 NewUV = UV;\n    NewUV.y += 0.5 - CubicBezier(UV.x, A, TangentA, TangentB, B).y;\n\t\t\n\treturn NewUV;\n}\n\nvec3 OverlayControlRig(vec2 uv, vec2 Start, vec2 StartControl, vec2 End, vec2 EndControl, float size)\n{\n \tvec3 rigColor = vec3(0.);\n    \n    vec2 aspect = vec2(1., iResolution.y / iResolution.x);\n    // render control points\n    if (length((Start - uv) * aspect) < size) {\n    \trigColor += vec3(1.,1.,0.);\n    }\n    if (length((StartControl - uv) * aspect) < size) {\n    \trigColor += vec3(0.,1.,0.);\n    }\n    if (length((End - uv) * aspect) < size) {\n    \trigColor += vec3(0.,1.,1.);\n    }\n    if (length((EndControl - uv) * aspect) < size) {\n    \trigColor += vec3(0.,0.,1.);\n    }\n    \n    // draw lines for each control point segment\n    float lines = 0.\n        + drawLine(Start, StartControl, uv, 5.)\n        + drawLine(StartControl, EndControl, uv, 5.)\n        + drawLine(EndControl, End, uv, 5.)\n        ;\n    rigColor += vec3(lines, 0., 0.);\n    \n    return rigColor;\n}\n\nvec2 SheerEdges(vec2 UV, float LeftShearDistance, float RightShearDistance)\n{\n\tfloat RightShearSpaceX = UV.x - (2. * RightShearDistance * UV.y) + RightShearDistance;\n\tvec2 ShearRightUV = vec2(RightShearSpaceX, UV.y);\n\n\tfloat TotalLeftShearDistance = LeftShearDistance + -1. * RightShearDistance;\n\n    float TotalShearSpaceX = ShearRightUV.x - (2. * TotalLeftShearDistance * ShearRightUV.y) + TotalLeftShearDistance;\n    vec2 TotalShearUV = vec2(TotalShearSpaceX, ShearRightUV.y);\n\n    float DestretchX = TotalShearUV.x / (1. - (2. * TotalLeftShearDistance * ShearRightUV.y) + TotalLeftShearDistance);\n    TotalShearUV.x = DestretchX;\n\n\treturn TotalShearUV;\n}\n\nvec2 DeformAndSheer(vec2 UV, vec2 Start, vec2 StartControl, vec2 EndControl, vec2 End, float SkewLeft, float SkewRight)\n{\n    return DeformUVByControlPoints_Bezier(SheerEdges(UV, SkewLeft, SkewRight), Start, StartControl, EndControl, End);\n}\n\nvec2 RightVector(vec2 a, vec2 b)\n{\n    vec2 aa = a;\n    vec2 ba = b;\n    \n    vec2 diff = ba - aa;\n    vec2 right = vec2(diff.y, -diff.x);\n    \n    return vec2(right.x, right.y) + aa;\n}\n\nfloat PointSlope(vec2 a, vec2 b)\n{\n    vec2 diff = b - a;\n    return diff.y / diff.x;\n}\n\nvec2 InterceptionOfHorizontalLine(vec2 a, vec2 b, float line)\n{\n    float x = ((line - a.y) / PointSlope(a, b)) + a.x;\n    return vec2(x, line);\n}\n\nvec2 ToView(vec2 P)\n{\n     return P * iResolution.xy;\n}\n\nvec2 ToUV(vec2 P)\n{\n     return P / iResolution.xy;\n}\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 StartPointAndControl = vec4(0.1, 0.5, 0.33, 0.4);\n    vec4 EndPointAndControl = vec4(MouseU, MouseV, 0.9, 0.5);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ToUV(fragCoord);\n    vec2 aspect = vec2(1., iResolution.y / iResolution.x);\n    \n    // Setup Start, End and respective Control Points\n    vec2 Pstart = StartPointAndControl.rg;\n\tvec2 PstartControl = StartPointAndControl.ba;\n    \n\tvec2 PendControl = EndPointAndControl.xy;\n    vec2 Pend =EndPointAndControl.zw;\n    \n    vec3 color = vec3(0.);\n    \n    vec2 StartSkewControl = RightVector(Pstart * iResolution.xy, PstartControl * iResolution.xy)/iResolution.xy;      \n    float SkewStart = (InterceptionOfHorizontalLine(Pstart, StartSkewControl, 1.).x - Pstart.x) / aspect.y;\n    \n    vec2 EndSkewControl = RightVector(Pend * iResolution.xy, PendControl * iResolution.xy)/iResolution.xy;      \n    float SkewEnd = (InterceptionOfHorizontalLine(Pend, EndSkewControl, 1.).x - Pend.x) / aspect.y;\n    \n    // borders\n    vec2 clamped_uv = vec2((uv.x - Pstart.x) / (Pend.x - Pstart.x), uv.y);\n    \n    vec2 deformed_uv = DeformAndSheer(ToView(clamped_uv, \n                                      Pstart, PstartControl,\n                                      PendControl, Pend,\n                                      SkewStart, SkewEnd);\n    \n    color += texture(iChannel0, deformed_uv).rgb;\n    \n    if (0. > deformed_uv.x) color *= 0.;\n    if (0. > deformed_uv.y) color *= 0.;\n    if (1. < deformed_uv.x) color *= 0.;\n    if (1. < deformed_uv.y) color *= 0.;\n    \n    #if SHOW_CONTROL_RIG\n    color = max(OverlayControlRig(uv, Pstart, PstartControl, Pend, PendControl, 0.01), color);\n    #endif\n    \n    if (length((EndSkewControl - uv) * aspect) < 0.01) {\n    \tcolor += vec3(1.,1.,1.);\n    } \n    color += vec3(0,1,0) * drawLine(Pend, EndSkewControl, uv, 5.);\n    \n    fragColor = vec4(color, 1.0);\n}\n*/\nvec2 CaluclateUVs(vec2 UV, vec2 Start, vec2 StartControl, vec2 End, vec2 EndControl, vec2 Dimensions)\n{\n    float Aspect = Dimensions.y / Dimensions.x;\n\t// Calculate the skew amount for the start point.\n    vec2 StartSkewControl = RightVector(Start * Dimensions.xy, StartControl * Dimensions.xy) / Dimensions.xy;      \n    float SkewStart = (InterceptionOfHorizontalLine(Start, StartSkewControl, 1.).x - Start.x) / Aspect;\n    \n    // Calculate the skew amount for the end point.\n    vec2 EndSkewControl = RightVector(End * Dimensions.xy, EndControl * Dimensions.xy) / Dimensions.xy;      \n    float SkewEnd = (InterceptionOfHorizontalLine(End, EndSkewControl, 1.).x - End.x) / Aspect;\n    \n    // Reproject TexCoords so x=0 is at the start point and x=1 is at the end point. \n    vec2 PointSpaceUV = vec2((UV.x - Start.x) / (End.x - Start.x), UV.y);\n    // Take the reprojected uvs deform them along a cubic spline and sheer the start and end edges.\n    vec2 DeformationSpaceUV = DeformAndSheer(PointSpaceUV,\n    \tStart, StartControl,\n    \tEndControl, End, \n    \tSkewStart, SkewEnd\n    );\n\n    return DeformationSpaceUV;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 StartPointAndControl = vec4(0.2, 0.5, 0.33, 0.4);\n    vec4 EndPointAndControl = vec4(0.8, 0.5, MouseU, MouseV);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 Dimensions = iResolution.xy;\n    vec2 TexCoords = ToUV(fragCoord);\n    \n    // Setup Start, End and respective Control Points\n    vec2 Start = StartPointAndControl.rg;\n\tvec2 StartControl = StartPointAndControl.ba + vec2(0., .2*sin(iTime));    \n    vec2 End = EndPointAndControl.xy;\n\tvec2 EndControl = EndPointAndControl.zw;\n    \n    vec2 DeformationSpaceUV = CaluclateUVs(TexCoords, Start, StartControl, End, EndControl, Dimensions);\n    \n    vec3 FinalColor = vec3(0.);\n    // Sample texture with deformed uvs.\n    FinalColor += texture(iChannel0, DeformationSpaceUV).rgb;\n    // Cut wrapped artefacts around deformed uv projection.\n    if (0. > DeformationSpaceUV.x) FinalColor *= 0.;\n    if (0. > DeformationSpaceUV.y) FinalColor *= 0.;\n    if (1. < DeformationSpaceUV.x) FinalColor *= 0.;\n    if (1. < DeformationSpaceUV.y) FinalColor *= 0.;\n    \n    #if SHOW_CONTROL_RIG\n    // Show cubic spline control points.\n    FinalColor += OverlayControlRig(TexCoords, Start, StartControl, End, EndControl, 0.01);\n    #endif\n    \n    fragColor = vec4(FinalColor, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}