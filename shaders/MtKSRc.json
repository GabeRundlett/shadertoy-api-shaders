{
    "Shader": {
        "info": {
            "date": "1485383507",
            "description": "Music: \"Low Frequency Flow\" by Dakota (2 place in Riverwash 2014 Streaming Music Compo Poland)\n[url=https://soundcloud.com/marek-ku-mierz]Dakota on Soundcloud[/url]",
            "flags": 64,
            "hasliked": 0,
            "id": "MtKSRc",
            "likes": 96,
            "name": "â™« Low Frequency Flow",
            "published": 3,
            "tags": [
                "raymarching",
                "cubes"
            ],
            "usePreview": 0,
            "username": "patu",
            "viewed": 10675
        },
        "renderpass": [
            {
                "code": "// Low Frequency Flow\n\n#define t (iChannelTime[0] - .1)\n\nconst float patternTime = 175. * 4. / 64.; // BPM * BEAT_LENGTH_(ROWS) / PATTERN_LENGTH_(ROWS)\n\nfloat \n    patternNumber = 0.,//floor(t / patternTime),\n    vol,\n    t_min = .001,\n\tMAX_DIST = 30.;\n\nconst int MAX_ITERATIONS = 260; // :(\n\nvec4 hash(vec4 h) {\n    return fract(sin(h) * 43758.5);\n}\n\n// IQ\nfloat noise(vec3 p) {\n\tvec3 ip = floor(p);\n    p -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n    p *= p * (3.-2.*p); \n    h = mix(hash(h), hash(h + s.x), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\n// http://mercury.sexy/hg_sdf/\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nvec3 dF(vec3 p) {\n    vec2 c = floor(p.xz - .5) - .5;\n\t\n    p.y += noise(c.xxy * 10.5) * 4. + sin(c.x * .5) + sin(c.y * .5 + t) * 1. + 2.; \n    \n    p.xz = mod(p.xz - .5, vec2(1.)) - .5;\n    \n    pR(p.xz, c.x + t * 2. - c.y);\n    pR(p.yx, c.x + t * 2.2);\n\n    return vec3(                \n        fBox(p / 2., vec3(0.03) + hash(c.xyxy).r * .14),\n        c\n    );\n}\n\n// http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\nvec3 trace(vec3 o, vec3 d) {\n    float omega = 1.;\n    float ts = t_min;\n    float candidate_error = 1e2;\n    float candidate_t = t_min;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float pixelRadius = .002;\n    float functionSign = dF(o).x < 0. ? -1. : 1.;\n    vec3 mp;\n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\n        mp = dF(d * ts + o);\n        float signedRadius = functionSign * mp.x;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        \t(radius + previousRadius) < stepLength;\n        \n        if (sorFail) {\n            omega = 1.;\n            stepLength -= omega * stepLength;\n        } else {\n        \tstepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / ts;\n        if (!sorFail && error < candidate_error) {\n            candidate_t = ts;\n            candidate_error = error;\n        }\n        if (!sorFail && error < pixelRadius || ts > MAX_DIST) break;\n        ts += stepLength * .4;\n   \t}\n    if (\n        (ts > MAX_DIST || candidate_error > pixelRadius)\n    \t) return vec3(1e32, 0., 0.);\n    \n    return vec3(candidate_t, mp.yz);\n}\n\n// IQ\n#define delta vec3(.001, 0., 0.)\nvec3 getNormal(vec3 pos) {    \n   vec3 n;  \n   n.x = dF( pos + delta.xyy ).x - dF( pos - delta.xyy ).x;\n   n.y = dF( pos + delta.yxy ).x - dF( pos - delta.yxy ).x;\n   n.z = dF( pos + delta.yyx ).x - dF( pos - delta.yyx ).x;\n   \n   return normalize(n);\n}\n\n// IQ\nfloat getAO(in vec3 hitp, in vec3 normal) {\n    float dist = 4.;\n    return clamp(dF(hitp + normal * dist).x / dist, .2, 1.);\n}\n\nvec3 getObjectColor(vec3 p, vec3 n, inout vec2 mat) {\n    vec3 col = vec3(0, 4.5, 9);   \n\n    if (noise(mat.xyx) < .35 + abs(sin(t * .3) * .2)) {\n     \tcol += vec3(1, .5, 0) * ceil(noise(mat.yxx * 29.)) * pow(\n            texture(iChannel0, vec2(mat.x / 32. + t * .01, .25)).r * 4., 4.);   \n    }\n    \n    return col * 2.;\n}\n\n// Shane, https://www.shadertoy.com/view/4dt3zn\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, inout vec2 mat) {\n\tvec3 col = vec3(0);\n    \n    vec3 ld = lp - sp;\n    float lDist = max(length(ld), .001); \n    \n    ld /= lDist; \n\n    float atten = 2.5 / (1. + lDist * .525 + lDist * lDist * .05);\n    float diff = max(dot(sn, ld), .1);\n    float spec = pow(max(dot(reflect(-ld, sn), -rd), .1), .6);\n\n    col = getObjectColor(sp, sn, mat) * (diff + .1) * spec * .2 * atten;\n    return col * 2.;\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    patternNumber = floor(t / patternTime);\n    vec2 \n\t\touv = fragCoord.xy / iResolution.xy,\n        uv = ouv - .5;\n\t\n    uv *= tan(.5 * radians(min(150., max(45., noise(patternNumber * vec3(.8)) * 150.))));\n    \n    float \n        sk = sin(t * .1 + patternNumber) * 12.,\n        ck = cos(t * .04) * 2.,\n    \tcamZ = t * 1.4 + 1.6;\n    \n    vec3 \n        light = vec3(0, 3, 0),      \n    \tsceneColor = vec3(0),\n        \n        vuv = vec3(0, 1, 0) + noise(patternNumber * vec3(-1, .2, -.4)),\n    \tro = vec3(0, ck, camZ) + noise(patternNumber * vec3(2)) * vec3(10, 2, 100),\t\t\n    \tvpn = normalize(vec3(\n            sk, \n            -2,\n            ck + 3. \n        )),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro),\n\t\t\n        sky = noise(rd * 2. + rd.yxz * 1.4 + t * .2) * .19 * vec3(0, .5, 1),       \n        lp = light + ro,\n        \n        tr = trace(ro, rd),        \n        sn;\n\n    vol = texture(iChannel0, vec2(.4, .25)).r * 2.; \n\n    if (tr.x < MAX_DIST) {\n        ro += rd * tr.x;\n        sn = getNormal(ro);\n        sceneColor += doColor(ro, rd, sn, lp, tr.yz);\n        sceneColor *= getAO(ro, sn);             \n        //sceneColor = mix(sceneColor, sky, tr.x / MAX_DIST);\n    } else \n     \tsceneColor = sky;    \n   \n    fragColor.rgb = sceneColor * 2. * min(t * .35, 1.);\n \n\t// stubbe, https://www.shadertoy.com/view/XtdGR7\n    fragColor.rgb *= ouv.x * (1.-ouv.x) * ouv.y * (1.-ouv.y) * 32. * .75 + .25;    \n    \n} \n\n// patu, http://bit.ly/shadertoy-plugin",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 6862,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/marek-ku-mierz/low-frequency-flow"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}