{
    "Shader": {
        "info": {
            "date": "1698845630",
            "description": "Breathing Terrain (meditation).\nThis shader demonstrates generation of smooth random functions, over space and time.",
            "flags": 32,
            "hasliked": 0,
            "id": "cldyRn",
            "likes": 4,
            "name": "Breathing Terrain",
            "published": 3,
            "tags": [
                "2d",
                "fractal",
                "terrain",
                "generative",
                "meditaion"
            ],
            "usePreview": 0,
            "username": "ersh",
            "viewed": 158
        },
        "renderpass": [
            {
                "code": "//#define T(X)     texelFetch(iChannel0, X, 0)\n\nvec4 T(ivec2 x, int maxx) {\n  return x.x > 0 && x.x < maxx ? texelFetch(iChannel0, x, 0) : vec4(0.);\n}\n\nfloat stylize(float cc, float tf, float ts) {\n    float pw = pow(cc,0.8);\n    float cr = (floor(pw*30. + ts)-ts)/30. + fract(cc*30. + tf)/20.;\n    return cr;\n}\n\nfloat stylize2(float cc, float tf, float ts) {\n    float pw = cc * 1.06;//pow(cc,0.8);\n    float cr = (floor(pw*5. + ts)-ts)/5. + fract(cc*10. + tf);\n    return cr;\n}\n\nfloat atan2f(vec2 v, float sc, float sh, float sha) {\n    float a = v.y != 0. ? atan(v.x / v.y) : 3.14159265358/2.;\n    return fract((a / 3.1415926 + sha) * sc + sh);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    int maxx = int(iResolution.x)-1;\n\n    // Land\n    float c = T(ivec2(int(fragCoord.x), 3), maxx).r + 0.4;\n    if (c > uv.y) {\n        float cc = uv.y - c + 0.8;\n        fragColor = vec4(vec3(stylize(cc, 0., 0.))*vec3(0.7, 0.5, 0.3), 1.0);\n        return;\n    }\n\n    vec2 cs = iResolution.xy*vec2(0.75, 0.65);\n    float d = distance(fragCoord.xy, cs);\n    float r = min(iResolution.x, iResolution.y) * 0.17;\n\n    // Sun\n    cs = iResolution.xy*vec2(0.75, 0.65);\n    d = distance(fragCoord.xy, cs);\n    r = min(iResolution.x, iResolution.y) * 0.17;\n    r *= pow(T(ivec2(int(atan2f(fragCoord - cs, 5., iTime / 40., 0.5)*iResolution.x), 2), maxx).r + 0.5, 5.) * 5. + 0.4;\n    if (d < r) {\n        float cc = d / r;\n        fragColor = vec4(vec2(stylize(1.-cc*0.2, iTime/3., iTime/5.)), 1.-cc, 1.0);\n        return;\n    }\n    \n    // Stars\n    for (int i = 0; i < 20; i++) {\n        cs = iResolution.xy * (hash21(float(i+1)) * vec2(1., 0.6) + vec2(0, 0.4));\n        d = distance(fragCoord.xy, cs);\n        r = min(iResolution.x, iResolution.y) * 0.1;\n        r *= pow(T(ivec2(int(atan2f(fragCoord - cs, 2., -iTime * (hash11(float(i+1))-0.5)/10., float(i*2))*iResolution.x), 6+i), maxx).r + 0.5, 9.) * 5. + 0.03;\n        if (d < r) {\n            float cc = d / r;\n            fragColor = vec4(vec3(stylize2(1.-cc*0.3, iTime*1.5, iTime)), 1.0);\n            return;\n        }\n    }\n\n    // Cloud\n    for (int n = 0; n < 4; n += 1) {\n        float h = (T(ivec2(fragCoord.x, 2), maxx).r + 0.0) * 0.1;\n        cs = iResolution.xy*vec2(0.45 - float(n) * 0.05, 0.45 + h);\n        d = distance(fragCoord.xy * vec2(1.,1.), cs);\n        r = min(iResolution.x, iResolution.y) * (0.21 - float(n)*0.015);\n        float sc = smoothstep(0.41 + h, 0.44 + h, uv.y);\n        //float sc = 1.-pow(1.-smoothstep(0.41, 0.44, uv.y), 2.);\n        r *= (T(ivec2(int(atan2f(fragCoord - cs, 1., 3.1415926/2., -iTime * (float(n) - 1.4) / 100.)*iResolution.x), 4+n), maxx).r + 0.5) * 0.5 * sc + 0.1;\n        if (d < r) {\n            float cc = d / r;\n            //fragColor = vec4(vec3(stylize((1.-cc*0.1), iTime/5., iTime/15.) * (smoothstep(0.41, 0.5, uv.y)*0.9 + 0.1)), 1.0);\n            fragColor = vec4(1.0);\n            return;\n        }\n    }\n    \n\n    // Water\n    if (uv.y < 0.35) {\n        c = T(ivec2(int(fragCoord.x), 2), maxx).r/5. + 0.35;\n        float cc = 1. - pow(uv.y - c + 0.9, 10.);\n        fragColor = vec4(0.,  vec2(stylize(cc, -iTime/3., -iTime/5.))* vec2(0.4, 0.45), 1.0);\n        return;\n    }\n\n    // Sky\n    float cc = uv.y * 1.3 - 0.5;\n    //float cc = (1.-uv.y) * 1.1 - 0.1;\n    fragColor = vec4(0., 0., stylize(cc, -iTime/8., iTime/12.), 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//#define T(X)     texelFetch(iChannel0, X, 0)\n\nvec4 T(ivec2 x, int maxx) {\n  return x.x > 0 && x.x < maxx ? texelFetch(iChannel0, x, 0) : vec4(0.);\n}\n\nint tier_n(int x) {\n  if ((x & 0xffff) == 0) { return 16; }\n  int ret = 0;\n  if ((x & 0xff) == 0) { ret += 8; x >>= 8; }\n  if ((x & 0x0f) == 0) { ret += 4; x >>= 4; }\n  if ((x & 3) == 0) { ret += 2; x >>= 2; }\n  if ((x & 1) == 0) { ret += 1; }\n  return ret;\n}\n\nint tier_s(int x) {\n  if ((x & 0xffff) == 0) { return 0x10000; }\n  int ret = 1;\n  if ((x & 0xff) == 0) { ret <<= 8; x >>= 8; }\n  if ((x & 0x0f) == 0) { ret <<= 4; x >>= 4; }\n  if ((x & 3) == 0) { ret <<= 2; x >>= 2; }\n  if ((x & 1) == 0) { ret <<= 1; }\n  return ret;\n}\n\nint pow2ceil(int x) {\n  x |= x >> 1;\n  x |= x >> 2;\n  x |= x >> 4;\n  x |= x >> 8;\n  x |= x >> 16;\n  return x+1;\n}\n\nfloat pow_of_2_adj(vec2 iResolution) {\n  return  iResolution.y / iResolution.x / pow(2., ceil(log(iResolution.x)/log(2.)) - 3.);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 50.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rand(ivec2 nx, int t, float tm)\n{\n    if (nx.x == 0) return 0.;\n//    if (t < 5) return 0.;\n//    return 0.1;\n    vec2 p = (vec2(nx) + mod(tm, 200.) * 1501. + 50.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    float sh = sin(float(t + nx*5) + iTime/2.) / float(t+1) / iResolution.x * iResolution.y;\n    return (fract((p3.x + p3.y) * p3.z) - 0.5 + sh) / 2. / iResolution.x * iResolution.y;\n}\n\nfloat randt(ivec2 nx, int t, float y) {\n    float tm = ((100. + iTime + y*33.33)*(1. - y * 0.01)  + float(nx.x)/100.)/float(t+1);\n    float tt = floor(tm), tf = fract(tm);\n    return mix(rand(nx, t, tt), rand(nx, t, tt+1.), smoothstep(0., 1., tf));\n}\n\n//#define MOD(X)  ((X + iResolution_i.x) % iResolution_i.x)\n#define MOD(X)  X\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.y > 30.) return;\n    ivec2 fragCoord_i = ivec2(fragCoord);\n    ivec2 iResolution_i = ivec2(iResolution);\n    int maxx = iResolution_i.x-1;\n    int pow2_mid_adj = (pow2ceil(iResolution_i.x) - iResolution_i.x) >> 1;\n    int tier =  tier_n(fragCoord_i.x + pow2_mid_adj);\n    int st = (1 << tier); //tier_s(fragCoord_i.x);\n\n    float c = randt(fragCoord_i, tier, fragCoord.y) * float(st) * pow_of_2_adj(iResolution.xy);\n    //if (tier < tier_n(pow2ceil(iResolution_i.x))-2) {\n        c += (T(ivec2(MOD(fragCoord_i.x - st), fragCoord_i.y), maxx).r + T(ivec2(MOD(fragCoord_i.x + st), fragCoord_i.y), maxx)).r / 2.;\n    //}\n    fragColor = vec4(vec3(c), 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}