{
    "Shader": {
        "info": {
            "date": "1612302936",
            "description": "I hate gpus ",
            "flags": 0,
            "hasliked": 0,
            "id": "WtcfRN",
            "likes": 49,
            "name": "Dar 413",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 866
        },
        "renderpass": [
            {
                "code": "\n// Fork of \"Day 410\" by jeyko. https://shadertoy.com/view/tlKcDd\n// 2021-02-02 11:34:36\n\n\n// Cyclic Noise from nimitz. \n// fwidth analytic SDF AA suggested by Fabrice (another solution suggested before that by mla)\n\n// Why does the fwidth totally break in far off distances and look blocky AAAAAAAAAAAAAAAAAAAA\n\n\nconst float slices = 124.;\n\nconst float sliceDepth = 3.5;\n\nfloat yOffs = 3.5;\n\nconst float width = 0.;\n\nconst float aaSteps = 2.; // aa unused\n\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\n#define offs(z,x) + (sin(z + sin(x))*0.5 - sin(x*0.5)*0.5)\n\nfloat fun(vec3 p){\n    float f = 0.;\n    \n    p.z += iTime;\n    f += cyclicNoise(p*1. + vec3(0,iTime*0.,0), false, iTime*0.)\n        - 0.5;\n    /*\n        - mix(-0.,1.,smoothstep(0.,0.4,-p.y))*0.\n        + 0.*mix(1.,0.,smoothstep(0.,1.,-abs(p.y )+ yOffs ));\n      */  \n    //f = max(f,-dot(p.xy,p.xy) + 0.);\n\n    //f = max(f,-length(p.y) + 0.51);\n    f = opSmoothSubtraction( f,\n        opSmoothUnion(\n            length(p.x + offs(p.z,p.x) ) - 0.2,\n            p.y,\n            1.5\n        )\n        , 0.4 );\n\n    \n    //f = opSmoothSubtraction(-f,p.y+ 0.3,0.1);\n    \n    //f = max(f,-p.y + 0.);\n    \n    return f;\n}\n\n\nvec3 get(in vec2 fragCoord){\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(1);\n    \n    vec3 ro = vec3(0,yOffs,0);\n    \n    vec3 rd = normalize(vec3(uv,3.6));\n    rd.yz *= rot(0.33);\n    \n    \n    for(float i = 0.; i < slices ; i++ ){\n        \n        float t = plaIntersect( ro - vec3(0,i/slices*sliceDepth,0.), rd, vec4(0,1,0,1.) );\n        vec3 p = ro + rd*t;\n        \n        float fn = fun(p);\n        \n        \n        \n        \n        vec3 c = pal(0.5,vec3(0.6,0.05,.15),vec3(4.9,1.,9),1.,i/slices*22. + iTime*1.);\n        \n        \n        float fw = fwidth(fn);\n        \n        \n        fw = mix(fw, fw/4.,smoothstep(1.,0.,i/slices));\n        float d = (fn)/fw;\n        /*\n        if(fwidth(fn) < dFdx(uv.x)*4.)\n            d = fn*220.01;\n        */\n        \n        float n = cyclicNoiseb((p - vec3(0,0,-iTime))*mix(7.,110.,i/slices) + vec3(0,i*0.,0), false, 0.);\n        \n        //n = mix(n*1.,0.,smoothstep(1.,0.04,i/slices));\n        \n        //n /= fwidth(n)*22.001;\n        \n        n = pow(abs(n),2.);\n        \n        //d -= (n*2. - 1.)*0.9*smoothstep(0.1,1.,i/slices);\n        \n        d -= (n*2. - 1.)*0.9;\n        \n        \n        //d = mix(d,3.,n);\n        float g = smoothstep(1.,0.,abs(d )- width - n - (1. - i/slices)*0.);\n        float gb = smoothstep(1.,0.,d - width);\n        \n        //g = max(g,-n + 0.05);\n        \n        col = mix(col, vec3(1), gb );\n        col = mix(col, vec3(0), g);\n        col = max(col,0.);\n\n\n         \n        \n        /*\n            col = mix(col, c*c*0.7, gb);\n            col = mix(col, c*2., g);\n        \n        }*/\n        \n    }\n    \n    /*\n    \n    \n    fn = opSmoothSubtraction(-fn, p.z - 2.,0.5);\n    \n\n    float fw = fwidth(fn)*1. ;\n    //float fw = 0.001;\n    //float fw = length(vec2(dFdx(fn),dFdy(fn))) + 0.0 ;\n\n\n    float d = (fn)/fw;\n    \n    float n = cyclicNoiseb((p - vec3(0,0,-iTime))*110. + vec3(0,0.,0), false, 0.);\n\n    n = pow(n,1.);\n    d -= (n*2. - 1.)*1.;\n\n    //d = mix(d,3.,n);\n    float g = smoothstep(1.,0.,d - 2.5 - n);\n    \n    g = max(g,-n + 0.05);\n\n    col = mix(col, vec3(0), g);\n    col = max(col,0.);\n    \n    */\n    // ------- bird ------- // \n    {\n        float no = cyclicNoiseb(( - vec3(4,1,iTime*0.5)), false, 0.);\n\n        ro.z += sin(iTime)*0.3 + no*2.;\n\n        ro.x -= no;\n        ro.y +=  + cos(iTime*1.5 + sin(iTime*2.5))*0.05 - no*0.2;\n        rd.xy *= rot(sin(iTime)*0.1) - no*0.2;\n\n        float t = plaIntersect( ro - vec3(0,sliceDepth - 1.,0.), rd, vec4(0,1,0,1.) );\n        vec3 p = ro + rd*t;\n        vec3 op = p;\n\n\n        #define smsin(a) smoothstep(0.,1.,sin(a))*sign(a) \n\n\n        float wt = fract(iTime/2.)*1.;\n\n        if(mod(floor(iTime/2.),3.) < 1.)\n            wt *= 0.;\n\n        float wingsoffs = sin(abs(op.x)*5. + iTime/1.*3.14)*0.46; \n\n        wt = pow(wt,0.6);\n        wingsoffs *= smoothstep(1.,0.,wt)*smoothstep(0.,0.7,wt)*4.;\n\n        wingsoffs = mix(wingsoffs*0.6,wingsoffs,smoothstep(0.,0.2,abs(p.x)));\n        float n = cyclicNoiseb((p - vec3(0,0,iTime*0.))*110., false, 0.);\n        n = pow(abs(n),2.);\n\n        t += cyclicNoiseb(( p - vec3(0,0,iTime*2.))*9., false, 0.)*0.02;\n\n        p.xz -= vec2(0,7);\n        p.x = abs(p.x);\n\n        p.z *= 1.;\n        p.xz +=  vec2(0,wingsoffs*0.5);\n        float bird = length(p.xz) - 0.1;\n\n        float bd = sdBox(p.xz*vec2(1,0.3)*rot(0.25*2.6),vec2(0.06));\n\n        bd = max(bd, -sdBox(vec2(abs(p.x),p.z) - vec2(0.14,0),vec2(0.1,0.4)));\n        //bd = \n\n        bird = min(bird, bd );\n\n        p = ro + rd*t;\n\n        p.xz -= vec2(0,7);\n        p.x = abs(p.x);\n\n        p.z *= 1. + smoothstep(0.,1.,p.x*17.);\n\n\n\n        //fn = opSmoothSubtraction(-fn, p.z - 2.,0.5);\n\n\n        p.z += wingsoffs;\n\n        float dwings = sdBox(p.xz - vec2(0.1,0),vec2(.14,0.1));\n        dwings = min(dwings, sdBox((p.xz - vec2(0.25,-0.04))*rot(0.5),vec2(.1,0.1)));\n\n        if(p.z < 0.){\n            dwings -= cyclicNoiseb(op*144.*vec3(1,1,0.2) + vec3(0,iTime,iTime*4.), false, 0.)*0.1;\n        }\n\n\n        bird = min(bird,dwings);\n        //d -= (n*2. - 1.)*0.9*smoothstep(0.1,1.,i/slices);\n\n        bird -= (n*2. - 1.)*0.005;\n\n\n\n\n        float fw = fwidth(bird)*1. ;\n\n        bird /=fwidth(bird);\n\n\n        col = mix(col, vec3(1) - cyclicNoiseb(( - vec3(op.xz,1.))*140.*vec3(1,0.2,1), true, 0.)*0. , smoothstep(1.,0.,bird));\n\n        col = mix(col, vec3(0), smoothstep(1.,0.,abs(bird) - n));\n        col = max(col,0.);\n        }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    \n    for(float i =0.; i < aaSteps*aaSteps + min(float(iFrame),0.)   ; i++){\n    \tcol += get(fragCoord + vec2(mod(i,aaSteps),floor(i/aaSteps))/aaSteps);\n    }\n    col /= aaSteps*aaSteps;\n    \n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    col = max(col, 0.);\n\t\n    \n    col = pow(col,vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n#define pal(a,b,c,d,e) ((a) +(b)*sin((c)*(d) + (e)))\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n\n// TRIANGLE MODE - substitutes sine for tri \n//#define sin(a) (asin(sin(a)))\n//#define sin(a) (fract((a) /3.14/2.)*1. - 0.)\n\nfloat sdBox(vec2 p, vec2 s){\n    p = abs(p) - s;\n    return max(p.x,p.y);\n}\n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\nfloat cyclicNoise(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    float amp = 1.;\n    float gain = 0.8 + sin(p.z*0.2)*0.2;\n    const float lacunarity = 1.6;\n    const int octaves = 5;\n    \n    const float warp =1.2;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .2;\n    \n    vec3 seed = vec3(-4,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\nfloat cyclicNoiseb(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    float amp = 1.;\n    float gain = 0.8 + sin(p.z*0.2)*0.2;\n    const float lacunarity = 1.4;\n    const int octaves = 2;\n    \n    const float warp = 1.2;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .2;\n    \n    vec3 seed = vec3(-4,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    } else{\n        //return 0.;\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\n\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}