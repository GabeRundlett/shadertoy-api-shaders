{
    "Shader": {
        "info": {
            "date": "1593868311",
            "description": "this shader just plots the phase of a random rational function, the left side plots it with the hue while the right side plots lines where the phase is 90 or -90 degrees (red and blue colors respectively).",
            "flags": 32,
            "hasliked": 0,
            "id": "tlsyDl",
            "likes": 15,
            "name": "complex rational function",
            "published": 3,
            "tags": [
                "2d",
                "complex",
                "multipass"
            ],
            "usePreview": 0,
            "username": "unnick",
            "viewed": 384
        },
        "renderpass": [
            {
                "code": "/* resemblance to the sun's magnetic field is purely coincidental :)\n *\n * but the lines on the right side do correspond\n * to the field lines of a bunch of electrons and protons\n * placed at the poles and zeros of the rational function\n */\n\nvoid mainImage(out vec4 col, in vec2 coord) {\n    ivec2 pos = ivec2(coord);\n    \n    col = fetch(pos);\n    \n    vec2 phase = col.xy;\n    float detail;\n    \n    #ifdef use_analytic_derivatives\n    detail = length(col.zw) / res.y * 2. * zoom * phase_mul;\n    #else\n    {\n        vec2 c = col.xy;\n        vec2 r = fetch(pos + ivec2(1,0)).xy;\n        vec2 u = fetch(pos + ivec2(0,1)).xy;\n        vec2 l = fetch(pos - ivec2(1,0)).xy;\n        vec2 d = fetch(pos - ivec2(0,1)).xy;\n        float a = angle_diff(u, c) + angle_diff(c, d);\n        float b = angle_diff(r, c) + angle_diff(c, l);\n        detail = length(vec2(a,b)) * .5 * phase_mul;\n    }\n    #endif\n    \n    for(int i = 0; i < phase_doublings; i++) phase = sqr(phase);\n    \n    if(coord.x < (iMouse.w == 0. ? res.x / 2. : iMouse.x)) {\n        col.rgb = mat2x3(1,-.5,-.5, 0,sqrt(3.)/2.,-sqrt(3.)/2.) * phase;\n        detail *= .8;\n        if(detail > .05) col.rgb *= detail < tau * .5 ? sin(detail)/detail : 0.;\n        col.rgb = col.rgb * .5 + .5;\n    } else {\n        float ld = abs(phase.x) / detail;\n        col.rgb = (phase.y < 0. ? vec3(0,0,1) : vec3(1,0,0)) * (ld > 1. ? 0. : 1. - ld);\n    }\n    \n    col.rgb = sqrt(col.rgb);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec2 randpos(int i) {\n    vec4 rand = hash(i);\n    vec2 tmp = sincos(iTime * (rand.x + 1.) * 1. + rand.y * tau);\n    return mul(tmp * vec2(rand.z - .5, 1.), sincos(rand.w * tau));\n}\n\nvoid mainImage(out vec4 col, in vec2 _coord) {\n    ivec2 coord = ivec2(_coord);\n    if(coord.x >= width || coord.y >= height) discard;\n    int idx = (coord.x << (1 + height_log2)) + (coord.y << 1);\n    col.xy = randpos(idx  ) + offset;\n    col.zw = randpos(idx+1) - offset;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define res iResolution.xy\n#define tau 6.283185\n#define fetch(pos) texelFetch(iChannel0, pos, 0)\n\n#define zero min(iFrame, 0)\n\n//#define use_analytic_derivatives\n#define zoom 1.5\n#define height_log2 4\n#define width 16\n#define phase_doublings 1\n#define offset vec2(0,.05)\n\n#define height (1 << height_log2)\n#define phase_mul float(1 << phase_doublings)\n\nvec4 hash(int x) {\n    x *= 0x7feb352d;\n    x ^= x >> 16;\n    x *= 0x846ca68b;\n    return vec4(\n        (x >>  0) & 0xFF,\n        (x >>  8) & 0xFF,\n        (x >> 16) & 0xFF,\n        (x >> 24) & 0xFF\n    ) / 256.;\n}\n\n//complex multiplication\nvec2 mul(vec2 a, vec2 b) {\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\n//complex div\nvec2 div(vec2 a, vec2 b) {\n    return vec2(a.x*b.x + a.y*b.y, a.y*b.x - a.x*b.y);\n}\n\n//complex square\nvec2 sqr(vec2 z) {\n    return vec2(z.x*z.x - z.y*z.y, z.x*z.y*2.);\n}\n\nvec2 sincos(float a) {\n    return vec2(cos(a), sin(a));\n}\n\nfloat angle_diff(vec2 a, vec2 b) {\n    return atan(a.y*b.x - a.x*b.y, a.x*b.x + a.y*b.y);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage(out vec4 col, in vec2 coord) {\n    vec2 pos = (coord * 2. - res) / res.y * zoom;\n    vec2 phase = vec2(1,0);\n    vec2 phase_grad = vec2(0);\n    for(int y = 0; y < height + zero; y++) {\n        for(int x = 0; x < width + zero; x++) {\n            vec4 tmp = fetch(ivec2(x, y));\n            vec2 z;\n            z = pos - tmp.xy;\n\n            phase = mul(phase, z);\n            \n            #ifdef use_analytic_derivatives\n            phase_grad += z / dot(z,z);\n            #endif\n            z = pos - tmp.zw;\n            \n            phase = normalize(mul(phase, z * vec2(-1,1)));\n            #ifdef use_analytic_derivatives\n            phase_grad -= z / dot(z,z);\n            #endif\n        }\n    }\n    \n    col.xy = phase;\n    col.zw = phase_grad;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}