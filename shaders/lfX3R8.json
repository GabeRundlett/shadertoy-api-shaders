{
    "Shader": {
        "info": {
            "date": "1702721697",
            "description": "Shaders glitch for device",
            "flags": 0,
            "hasliked": 0,
            "id": "lfX3R8",
            "likes": 1,
            "name": "Glitch shaders",
            "published": 3,
            "tags": [
                "glitch"
            ],
            "usePreview": 1,
            "username": "IAMDEAD",
            "viewed": 261
        },
        "renderpass": [
            {
                "code": "float segments = 0.5;     // на будущее\nfloat radius = 0.6;       // скейл радиуса\nfloat brightnes = 1.0;    // по сути яркость (если можно таковой назвать)\nfloat tail_size = 0.3;   // работает реверсивно, чем больше значение - тем меньше хвост\nfloat snake_color = 2.0;  // 1.0 = red, 2.0 = green, 3.0 = blue; - если harColour по нулям, работать будет как я запланировал \n\nvec3 m_affects = vec3(0.2,0.1,1.0);\n\nfloat get_noise(vec2 co) { return (fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453)) * 0.5; }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 screen_res = vec4(iResolution.xy, 1.0 / iResolution.xy);\n    vec2 texcoord = fragCoord * screen_res.zw;\n\n\n    // узкая полоска искажений\n    vec4 timers = vec4(iTime, iTime * 10.0, iTime / 10.0, sin(iTime));\n    float problems = fract(timers.z * 5.0 * (1.0 + 2.0 * m_affects.x));\n    \n    vec2 uv = texcoord;\n    uv.x += (m_affects.x > 0.09 && uv.y > problems - 0.01 && uv.y < problems) ? sin((uv.y - problems) * 5.0 * m_affects.y) : 0.0;\n\n    // широкая полоска искажений\n    float AMPL = 0.13;\n    problems = cos((fract(timers.z * 2.0) - 0.5) * 3.1416) * 2.0 - 0.8;\n    if (m_affects.x > 0.15 && uv.y > problems - AMPL && uv.y < problems + AMPL)\n        uv.x -= cos(4.71 * (uv.y - problems) / AMPL) * sin(fract(timers.z) * 6.2831 * 90.0) * 0.02 * (AMPL - abs(uv.y - problems)) / AMPL;\n    else\n        uv.x -= 0.0;\n\n    // тряска влево-вправо в финальной стадии\n    uv.x += (m_affects.x > 0.38) ? (m_affects.y - 0.5) * 0.04 : 0.0;\n\n    \n    vec4 t_vp2 = texture(iChannel0, uv);\n\n    // Шум при выбросе\n    float noise = get_noise(uv * timers.z) * m_affects.x * m_affects.x * 10.0;\n    t_vp2.r += noise;\n    t_vp2.g += noise;\n    t_vp2.b += noise;\n\n    //отключение экрана\n    t_vp2.rgb = m_affects.x > 0.41 ? vec3(0.0, 0.0, 0.0) : t_vp2.rgb;\n\n    fragColor = vec4(t_vp2.rgb, m_affects.z);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}