{
    "Shader": {
        "info": {
            "date": "1530907830",
            "description": "A glass block, not using SDF raymarching, but using plane instersectings.",
            "flags": 0,
            "hasliked": 0,
            "id": "lsKfW3",
            "likes": 5,
            "name": "Glass block",
            "published": 3,
            "tags": [
                "ray",
                "glass",
                "box",
                "refract"
            ],
            "usePreview": 0,
            "username": "0xAA55",
            "viewed": 724
        },
        "renderpass": [
            {
                "code": "\nfloat PI = 3.1415926535897932384626;\nfloat glass_eta = 1.458;\nvec3 glass_color = vec3(.1);\nfloat glass_impurity = .01;\n\nstruct box_t\n{\n    vec3 p, d; // Position, Dimension\n    mat3 r; // Rotation\n};\n\nmat3 rot_x(float ang)\n{\n    float sang = sin(ang);\n    float cang = cos(ang);\n    return mat3\n    (\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, cang,-sang),\n        vec3(0.0, sang, cang)\n    );\n}\n\nmat3 rot_y(float ang)\n{\n    float sang = sin(ang);\n    float cang = cos(ang);\n    return mat3\n    (\n        vec3( cang, 0.0, sang),\n        vec3(  0.0, 1.0, 0.0),\n        vec3(-sang, 0.0, cang)\n    );\n}\n\nmat3 rot_z(float ang)\n{\n    float sang = sin(ang);\n    float cang = cos(ang);\n    return mat3\n    (\n        vec3( cang, sang, 0.0),\n        vec3(-sang, cang, 0.0),\n        vec3(0.0, 0.0, 1.0)\n    );\n}\n\nmat3 rot_axis(vec3 v, float ang)\n{\n    float sang = sin(ang);\n    float cang = cos(ang);\n    return mat3\n    (\n        vec3\n        (\n            (1.0 - cang) * v.x * v.x + cang,\n            (1.0 - cang) * v.x * v.y - sang * v.z,\n            (1.0 - cang) * v.x * v.z + sang * v.y\n        ),\n        vec3\n        (\n            (1.0 - cang) * v.y * v.x + sang * v.z,\n            (1.0 - cang) * v.y * v.y + cang,\n            (1.0 - cang) * v.y * v.z - sang * v.x\n        ),\n        vec3\n        (\n            (1.0 - cang) * v.z * v.x - sang * v.y,\n            (1.0 - cang) * v.z * v.y + sang * v.x,\n            (1.0 - cang) * v.z * v.z + cang\n        )\n    );\n}\n    \nmat3 rot_yaw_pitch_roll(vec3 ypr)\n{\n    return rot_z(ypr.z) * rot_x(ypr.y) * rot_y(ypr.x);\n}\n\nbool box_raycast(box_t box, vec3 start, vec3 n_ray, out vec3 castpoint, out vec3 normal, out vec2 uv, out float castdist, inout bool isfrominside)\n{\n    mat4 box_mat = mat4\n    (\n        vec4(box.r[0], 0.),\n        vec4(box.r[1], 0.),\n        vec4(box.r[2], 0.),\n        vec4(box.p, 1.)\n    );\n    bool inside = false;\n    \n    mat4 box_mat_inv = inverse(box_mat);\n    \n    vec3 start_local = (box_mat_inv * vec4(start, 1.)).xyz;\n    vec3 ray_local = (box_mat_inv * vec4(n_ray, 0.)).xyz;\n    \n    vec3 sv = step(abs(start_local), box.d);\n    if(sv.x > .5 && sv.y > .5 && sv.z > .5) inside = true;\n    if(inside && !isfrominside) return false;\n    if(inside || isfrominside) start_local = -start_local;\n    \n    vec3 rat = 1.0 / ray_local;\n    vec3 trp = rat * start_local;\n    vec3 dim = box.d * abs(rat);\n    \n    vec3 t1 = -trp - dim;\n    vec3 t2 = -trp + dim;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n    \n\tif( tN > tF || (!isfrominside && tF < 0.0) ) return false;\n    \n    vec3 nor = -sign(ray_local)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n    castpoint = start + n_ray * tN;\n    castdist = abs(tN);\n    normal = (box_mat * vec4(nor,0.)).xyz;\n    isfrominside = inside;\n    \n    vec3 cp_local = (box_mat_inv * vec4(castpoint, 1.)).xyz;\n    \n    uv = (nor.x * cp_local.yz + nor.y * cp_local.zx + nor.z * cp_local.xy) *.5 + .5;\n    \n    return true;\n}\n\n// Can change this function to render some featured environment\nvec4 sky_sample(vec3 ray)\n{\n    return texture(iChannel0, ray);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 xy = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n    \n    vec2 mouse_rotation = ((iMouse.xy / iResolution.y) * 2. -1.) * PI;\n    if(length(iMouse.xy) < 0.000001) mouse_rotation = vec2(0);\n    \n\tvec2 yawpitch = vec2(mouse_rotation.x, -mouse_rotation.y);\n    mat3 viewmat = rot_yaw_pitch_roll(vec3(yawpitch, 0));\n    \n    mat3 rot_m = rot_yaw_pitch_roll(vec3(iTime * .3, iTime * .2, iTime * .1));\n    \n    vec3 ray = normalize(vec3(xy, 1)) * viewmat;\n    vec3 eyepos = vec3(0., 0., -5.) * viewmat;\n    \n    box_t bx = box_t(vec3(0, 0, 0), vec3(1.25, 1.25, 1.25), rot_m);\n    \n    vec3 trace_org = eyepos;\n    vec3 trace_ray = ray;\n    \n    vec4 color = vec4(0);\n    \n    vec3 castpnt, castnormal;\n    vec2 castuv;\n    float castdist;\n\tbool isfrominside;\n    \n\t// Surface reflect color\n\tvec4 surface_color = vec4(0);\n    \n    isfrominside = false;\n    if(box_raycast(bx, trace_org, trace_ray, castpnt, castnormal, castuv, castdist, isfrominside))\n\t{\n        color = vec4(0);\n        float inside_distance = 0.;\n\t\t\n\t\tif(!isfrominside)\n\t\t{\n\t\t\ttrace_org = castpnt;\n\t\t\ttrace_ray = refract(trace_ray, castnormal, 1. / glass_eta);\n\t\t\tsurface_color = sky_sample(reflect(ray, castnormal)) * (1. - abs(dot(ray, castnormal)));\n\t\t}\n        \n\t\t// If I use uint type, or use \"for(iter = xx\", it may not compatible for iPhone X\n        for(float iter = 0.0; iter < 64.; iter ++)\n        {\n            bool frominside = true;\n            box_raycast(bx, trace_org, trace_ray, castpnt, castnormal, castuv, castdist, frominside);\n            \n            inside_distance += castdist;\n            \n            float k;\n            float eta = glass_eta;\n            float dot_ni = dot(castnormal, trace_ray);\n            \n            k = 1. - eta * eta * (1. - dot_ni * dot_ni);\n            if(k >= 0.)\n            {\n                trace_org = castpnt;\n        \t\ttrace_ray = eta * trace_ray - (eta * dot_ni + sqrt(k)) * castnormal;\n                color = mix(sky_sample(trace_ray),\n                            vec4(glass_color, 1.),\n                            clamp(glass_impurity * inside_distance, 0., 1.));\n                break;\n            }\n            \n\t\t\t// Total reflect\n            trace_ray = reflect(trace_ray, castnormal);\n            trace_org = castpnt;\n        }\n\t\tcolor += surface_color;\n\t}\n    else\n    {\n        color = sky_sample(trace_ray);\n    }\n\t\n\tfragColor = color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}