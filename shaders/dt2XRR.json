{
    "Shader": {
        "info": {
            "date": "1675604980",
            "description": "Based on the Independence Day movie.",
            "flags": 0,
            "hasliked": 0,
            "id": "dt2XRR",
            "likes": 66,
            "name": "Independence Day (50 secs)",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "space",
                "fog",
                "glow",
                "stars",
                "modelling",
                "lazer",
                "movie",
                "cineshader"
            ],
            "usePreview": 1,
            "username": "dean_the_coder",
            "viewed": 3401
        },
        "renderpass": [
            {
                "code": "// 'Independence Day' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/dt2XRR\n// (YouTube: https://youtu.be/54QtASjzvBY)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// Based on the Independence Day movie.\n// I learnt a few more tricks in this one, and trying\n// to improve my lighting and effects skills. (I'm no artist!)\n// It's funny how adding a few barely noticeable effects can\n// make such a difference when added together. (See the faint\n// glow around the Earth. Subtle, but effective.)\n//\n// Tricks to aid performance:\n//   - Precalculate function results and simplify calculations\n//     when possible (see GLSL Shader Shrinker).\n//     E.g. Precalculated rotation matrices, and SDF functions (cone())\n//     that can have hard-coded constants in them.\n//   - Check if the ray point is too far away from an object\n//     to bother with modelling fine details.\n//     (See the ship() SDF).\n//   - Lots of domain repetition and axis mirroring.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, tater,\n// and a bunch of others for sharing their time and knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define MIN_DIST\t2e-4\n#define START_DIST\t1.\n#define MAX_DIST\t3e2\n#define MAX_STEPS\t1e2\n#define MAX_RDIST\t10.\n#define MAX_RSTEPS\t40.\n#define SHADOW_STEPS\t30.\n#define LIGHT_RGB\tvec3(.4, 1, 1.5)\n#define R\tiResolution\n#define Z0\tmin(iTime, 0.)\n#define I0\tmin(iFrame, 0)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0., 1., a)\n\nfloat t, // Global time.\n      fade = 1.;\nvec3 g; // 'Glow'\n\nstruct Hit {\n\tfloat d;\n\tint id;\n\tvec3 p;\n};\n\nvoid U(inout Hit h, float d, int id, vec3 p) { if (d < h.d) h = Hit(d, id, p); }\n\nvoid minH(inout Hit h, Hit h2) { U(h, h2.d, h2.id, h2.p); }\n\nfloat min2(vec2 v) { return min(v.x, v.y); }\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\n\nfloat dot3(vec3 v) { return dot(v, v); }\n\nfloat sum2(vec2 v) { return dot(v, vec2(1)); }\n\n// Thnx Dave_Hoskins - https://www.shadertoy.com/view/4djSRW\nfloat h11(float p) {\n\tp = fract(p * .1031);\n\tp *= p + 3.3456;\n\treturn fract(p * (p + p));\n}\n\nvec2 h22(vec2 p) {\n\tvec3 v = fract(p.xyx * vec3(.1031, .103, .0973));\n\tv += dot(v, v.yzx + 333.33);\n\treturn fract((v.xx + v.yz) * v.zy);\n}\n\nfloat h31(vec3 p3) {\n\tp3 = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 333.3456);\n\treturn fract(sum2(p3.xy) * p3.z);\n}\n\nfloat h21(vec2 p) { return h31(p.xyx); }\n\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\n\t// Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, sum2(s.yz)) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\n// Two n31 results from two scales.\nvec2 n331(vec3 p, vec2 s) {\n\tvec2 ns;\n\tfor (int i = I0; i < 2; i++)\n\t\tns[i] = n31(p * s[i]);\n\n\treturn ns;\n}\n\nfloat n21(vec2 p) { return n31(vec3(p, 1)); }\n\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec3 rxy(vec3 p, float a) {\n\tp.xy *= rot(a);\n\treturn p;\n}\n\nvec3 rxz(vec3 p, float a) {\n\tp.xz *= rot(a);\n\treturn p;\n}\n\nvec3 ryz(vec3 p, float a) {\n\tp.yz *= rot(a);\n\treturn p;\n}\n\nvec3 ax(vec3 p) { return vec3(abs(p.x) - .2, p.yz); }\n\nvec3 ay(vec3 p, float d) { return vec3(p.x, abs(p.y) - d, p.z); }\n\nfloat rep(float p) { return p - 48. * floor(p / 48. + .5); }\n\nvec2 rep2(vec2 p) { return p - vec2(7, 10) * floor(p / vec2(7, 10) + .5); }\n\nvec2 mody2(vec2 p) { return vec2(p.x, mod(p.y, 102.)); }\n\nfloat box(vec3 p, vec3 b) { return length(max(abs(p) - b, 0.)); }\n\nfloat box2d(vec2 p, vec2 b) {\n\tvec2 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max2(q), 0.);\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tp.z -= clamp(p.z, 0., h);\n\treturn length(p) - r;\n}\n\nfloat tor(vec3 p, float r1, float r2) { return length(vec2(length(p.xz) - r1, p.y)) - r2; }\n\nfloat cone(vec3 p, float h) {\n\tvec2 q = vec2(length(p.xz), p.y),\n\t     k1 = vec2(2.4, h),\n\t     k2 = vec2(2.4, 2. * h),\n\t     ca = vec2(q.x - min(q.x, (q.y < 0.) ? 0. : 2.4), abs(q.y) - h),\n\t     cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0., 1.);\n\treturn ((cb.x < 0. && ca.y < 0.) ? -1. : 1.) * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdOctahedron(vec3 p) {\n\tp = abs(p);\n\treturn (p.x + p.y + p.z - 20.) * .57735027;\n}\n\nvec3 rayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nfloat fakeEnv(vec3 n) {\n\t// Thanks Blackle.\n\treturn length(sin(n * 2.5) * .35 + .6) / 1.7;\n}\n\nvec3 starz(vec3 rd) {\n\tfloat f,\n\t      st = t - 36.;\n\trd.xy *= rot(st * .08);\n\n\t// Earth.\n\tvec2 s,\n\t     ns = n331(rd, vec2(67.821, 20.0948));\n\trd.y += 15.55;\n\n\t// Land.\n\tf = length(rd.xy) - 15.;\n\tvec3 c = S(.1, .05, f + .05) * vec3(1, 1.8, 2);\n\tc *= .7 + S(.24, .7, dot(ns, vec2(.1, .4)));\n\n\t// Atmosphere/Glow\n\tc += (S(.1, -.2, abs(f)) + S(.5, -6., f)) * vec3(1.5, 1.5, 2.5);\n\n\t// Stars (faded out near Earth).\n\trd *= 22.;\n\ts = h22(floor(rd.xy));\n\tc += vec3(s.y * S(.05 * s.x * s.y, 0., length(fract(rd.xy) - .1 - s * .8)) * S(0., .35, f));\n\treturn c;\n}\n\nvec3 skyCol(vec3 rd) {\n\tfloat f = fakeEnv(rd);\n\tf *= .6 + .4 * S(40., 37., t);\n\treturn vec3(.03, .13, .2) * f * f;\n}\n\nfloat scratches(vec3 p) {\n\tfloat f = 0.;\n\tfor (float i = 1.; i <= 3.; i++)\n\t\tf = max(f, S(.01, 0., abs(fract(rxz(p + 10. + i, i * .31).z) - .5)));\n\n\treturn f;\n}\n\n#define SKY_ID\t0\n#define METAL_ID\t1\n#define METAL_DARK_ID\t2\n#define LAZER_ID\t3\n#define BELOW_ARE_REFLECTIVE\t7\n#define GLASS_ID\t8\n\nHit ship(vec3 p) {\n\tvec3 op,\n\t     oop = p;\n\n\t// Mirror on x - Half the work. :)\n\tp.x = abs(p.x);\n\n\t// Subtle glow around the ship.\n\tg.x += .003 / (.1 + dot(p, p)) * S(1., 0., p.z + 1.5);\n\top = p;\n\n\t// Body.\n\tfloat d, b, x, l,\n\t      f = S(0., -3.6, p.z - 1.);\n\tp.z *= -.25 * f + 1. - .1 * sign(p.z);\n\tp.x += f * .4;\n\tp.x += S(-1., 2., p.z - 1.) * .4;\n\td = length(p + vec3(0, 4.4, 0)) - 5.1;\n\td = smin(d, length(p - vec3(0, 8.5, 0)) - 9., -.1);\n\n\t// Ray too far away? Skip the details...\n\tif (d > 2.) return Hit(d, METAL_ID, p);\n\tf = abs(abs(1.4 - op.x) - 1.5) + abs(op.z * .5);\n\td += .02 * max(S(.06, .03, op.x), S(1.13, 1.1, f) - S(1., .97, f));\n\n\t// Nose cut-out.\n\tb = d;\n\tf = cone(ryz(op, -.15) - vec3(0, .64, -2.25), 1. - .02 * S(.7, .9, sin(atan(p.x, p.z + 2.5) * 32.)));\n\td = smin(d, -f, -.05);\n\n\t// Sail thing.\n\tp = ryz(op - vec3(-.35 - .12 * p.z, 1.13, -.3), .25 + .01 * p.z * p.z);\n\tf = cap(p, 2.8, .7);\n\tf = smin(f, .15 - d, -.1);\n\tx = f;\n\tf = smin(f, .06 - op.x, -.02);\n\n\t// Sail side cut-outs.\n\tf = smin(f, -cap(rxz(p - vec3(.9, .1, 1), -.06), 2., .3), -.05);\n\n\t// Sail cut-out design.\n\tl = length(op.yz - vec2(1.3, -.28));\n\tf += .015 * S(0., -.03, abs(l - .2) - .04);\n\tf += .015 * S(-.03, -.1, op.z) * S(-.38, -.3, op.z) * step(op.y, 1.3) * S(.25, .3, l);\n\td = min(d, f);\n\n\t// Scratch design.\n\td -= .003 * scratches(oop);\n\n\t// Gun blisters.\n\td = smin(d, cap(op - vec3(2, -.18, -.5), .5, .13), .1);\n\n\t// Grills.\n\td = min(d, tor(ay(ay(op.yxz + vec3(.17, 0, 1.68), .12), .05), .15, .012));\n\tHit h = Hit(d, METAL_ID, p);\n\n\t// Sail thing inner.\n\tx = max(x + .03, op.x - .08);\n\tx = min(x, max(abs(length(op.xy - vec2(0, 1)) - .025) - .001, abs(op.z) - 1.));\n\n\t// Gunz.\n\tp = op - vec3(2, -.23 + op.z * .15, -.6);\n\tx = min(x, cap(p, .5, .06 - .002 * abs(sin(p.z * 120.))));\n\tx = smin(x, .04 - length(p.xy), -.02);\n\tU(h, x, METAL_DARK_ID, op);\n\n\t// Cockpit window.\n\tf = tor(op + vec3(0, .56, -.3), 1., 1.18);\n\td = smin(f, b + .02, -.1);\n\tU(h, d, GLASS_ID, op);\n\tif (h.id == GLASS_ID) {\n\t\tf = S(0., .15, abs(op.y - .25) - .16);\n\t\tf = max(f, S(.03, 0., abs(op.y - op.x * 1.5 + .1)) * .5);\n\t\tf = max(f, S(.05, .03, abs(op.x * .12 + .04 - op.y)) * 1.9);\n\t\td = min(d, d - f * .01);\n\t\tU(h, d, METAL_DARK_ID, op);\n\t}\n\n\t// Sail mount.\n\td = .03 - .07 * p.z;\n\td += sat(sin(p.z * 40.) * .0125);\n\td = box(op - vec3(0, .7, .6), vec3(d, .14, 1)) - .17;\n\n\t// Rear fins.\n\tp = op;\n\tp.x -= .65;\n\tp.y += .05;\n\tp.z -= 2.6 - .5 * p.x;\n\tx = .007 * sin(p.x * 73.);\n\td = min(d, box(p, vec3(.5, .1 + x - .3 * p.z, .18 + x) - .03) - .03);\n\tU(h, d, METAL_DARK_ID, op);\n\treturn h;\n}\n\n// Two combined twisting cubes with infinite length.\nfloat twisty(vec2 p, float l, float s) {\n\tfloat d = box2d(p.xy * rot(l), vec2(s));\n\treturn d < 3. ? smin(d, box2d(p.xy * rot(-l), vec2(s)), .3) : d;\n}\n\nfloat shipRack(vec3 p) {\n\tfloat d = length(ax(p - vec3(0, 1.8, -.5))) - .02;\n\tg.x += 3e-4 / (d * d);\n\tp.y -= 1.8;\n\treturn min(d, twisty(p.xy, p.z, .1));\n}\n\nfloat backTower(vec3 p) {\n\tfloat d, f,\n\t      gy = dot(sin(p * 2.4), cos(p.yzx * 2.4));\n\tgy = S(0., .1, abs(gy) - 1.2);\n\tp.yz -= vec2(5, 50);\n\tp = ay(p, 13.);\n\tp = ay(p, 13.);\n\tp = ay(p, 13.);\n\tp.xz *= mat2(.96891, .2474, -.2474, .96891);\n\td = sdOctahedron(p);\n\n\t// Lights.\n\tf = abs(p.y + 4.);\n\tf = max(d, abs(f - .4));\n\tf = max(f, -gy);\n\tg.y += gy * 5e-5 / (.005 + f * f);\n\treturn d;\n}\n\nfloat columns(vec3 p) {\n\tp.z += 24. * sat(p.x);\n\tp.x = abs(p.x) - 20. - h11(floor(p.z / 48.)) * 20.;\n\tp.z = rep(p.z - 24.);\n\treturn twisty(p.xz, p.y * .05, 3. + n21(p.xy) * .5) - 1.;\n}\n\nvec3 lazerP(vec3 p) {\n\tp.z += mod(t, 3.) * 220. - 30.;\n\treturn p;\n}\n\nvec2 shipTunnelPos(vec2 p, float st) { return (.2 + .8 * S(10., 7.7, st)) * vec2(sin(st * -.765625 + 3.141) * 5. * S(0., 3., st), 3. + sin(st * -1.828125) * 2.125); }\n\nHit sdf(vec3 p) {\n\t// sr - Ship rotation.\n\tvec3 op = p,\n\t     sr = vec3(0);\n\tHit h;\n\th.d = 1e7;\n\tif (t < 16.) {\n\t\t//\n\t\t// Stage 1 - Racked scene.\n\t\t//\n\t\tU(h, backTower(p), METAL_DARK_ID, p);\n\n\t\t// We need ships. Lots of ships...\n\t\tp.xz = rep2(p.xz);\n\n\t\t// Ship racks.\n\t\tU(h, shipRack(p), METAL_DARK_ID, p);\n\n\t\t// Too far away from ships/racks - Squeeze a few more FPS...\n\t\tif (p.y > 3. || p.y < -9.) return h;\n\n\t\t// Add the ship(s).\n\t\tfloat x = floor((abs(op.x) - 3.5) / 7.),\n\t\t      z = floor((op.z - 5.) / 10.),\n\t\t      chaser = sat(x + z + 2.),\n\t\t      drop = S(9.5, 14., t - 2.5 * chaser + x * .4) * 3.2 * float(x <= z && z <= 0.);\n\t\tp.y += drop * drop * drop * 3.;\n\t\tp.z -= drop;\n\t\tsr = vec3(-.5 * drop, -2.5 * S(.3, 1.5, drop), .5 * S(.1, 1., drop));\n\t\tsr.x += (1. - chaser) * sin(t * 2.) * sin(t * 2.) * .1 * S(5.5, 6., t) * S(10., 9.5, t);\n\t}\n\telse if (t < 36.) {\n\t\t//\n\t\t// Stage 2,3 - Pillars.\n\t\t//\n\t\tfloat adv = 140. * t,\n\t\t      d = 1e7;\n\t\tU(h, columns(p - vec3(0, 0, adv)), METAL_DARK_ID, p);\n\t\tif (t > 17.5 && t < 34.) {\n\t\t\td = cap(lazerP(op), 10., .01);\n\t\t\tU(h, d, LAZER_ID, p);\n\t\t\tg.y += .001 / (.001 + d * d);\n\t\t}\n\n\t\tsr.z += cos(t + 1.) * .2;\n\t\tp.xy += sin(t) * vec2(3, 2);\n\t\tp.yz += vec2(2, S(34., 37., t) * MAX_DIST);\n\t}\n\telse {\n\t\t//\n\t\t// Stage 4 - Escape tunnel.\n\t\t//\n\t\tfloat st = t - 36.,\n\t\t      d = 1e7;\n\t\tst *= 1.2;\n\t\tvec3 tp = rxy(p, st * .09 - .6);\n\t\ttp.z += 50. - st * 35.;\n\t\tfor (float i = 0.; i < 3.; i++) {\n\t\t\t// Wall.\n\t\t\tfloat td = tp.y + 20.;\n\n\t\t\t// Cut-out trough.\n\t\t\ttd = smin(td, -box2d(tp.xy + vec2(-10, 20), vec2(6, 2)), -.2);\n\n\t\t\t// Beams.\n\t\t\tvec2 cp = tp.xz + vec2(i * 4. + 4., 1e2 + 20. * i);\n\t\t\tcp.x += 10. * sin(12.9 * floor(cp.y / 102.));\n\t\t\td = min(d, twisty(mody2(cp), tp.y * .2, 1.));\n\t\t\ttp.xy *= mat2(-.50485, .86321, -.86321, -.50485);\n\t\t\td = smin(d, td, 2.);\n\t\t}\n\n\t\td = max(d, -tp.z - 3e2);\n\t\tif (d < .2) d -= .025 * scratches(tp * .1);\n\t\tU(h, d, METAL_DARK_ID, tp);\n\t\tp.xy += shipTunnelPos(p.xy, st);\n\t\tp.z += 6.;\n\t\tsr.z += shipTunnelPos(p.xy, st + 2.).x * .05;\n\t}\n\n\tp = rxz(p, sr.y);\n\tp = ryz(p, sr.x);\n\tp = rxy(p, sr.z);\n\tminH(h, ship(p));\n\n\t// Nothing is perfectly sharp.\n\th.d -= .01;\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .1;\n\tvec3 n = vec3(0);\n\tfor (int i = I0; i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * sdf(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 lp, vec3 ld, vec3 n) {\n\t// Quick abort if light is behind the normal.\n\tif (dot(ld, n) < -.1) return 0.;\n\tfloat d,\n\t      s = 1.,\n\t      t = .01,\n\t      mxt = length(p - lp);\n\tfor (float i = Z0; i < SHADOW_STEPS; i++) {\n\t\td = sdf(t * ld + p).d;\n\t\ts = min(s, 15. * d / t);\n\t\tt += max(.01, d);\n\t\tif (mxt - t < .5 || s < .001) break;\n\t}\n\n\treturn S01(s);\n}\n\n// Quick 2-level ambient occlusion.\nfloat ao(vec3 p, vec3 n) {\n\tconst vec2 h = vec2(.2, 1);\n\tvec2 ao;\n\tfor (int i = I0; i < 2; i++)\n\t\tao[i] = sdf(h[i] * n + p).d;\n\n\treturn sat(min2(ao / h));\n}\n\n// Sub-surface scattering. (Thanks Evvvvil)\nfloat sss(vec3 p, vec3 ld) { return S01(sdf(.05 * ld + p).d / .05); }\n\nvec3 lights(vec3 p, vec3 ro, vec3 rd, vec3 n, Hit h) {\n\tvec3 lp, ld, c, l, col,\n\t     sky = skyCol(rd);\n\tif (h.id == SKY_ID) return t > 36. ? starz(rd) : sky;\n\tfloat fg,\n\t      ss = 0.,\n\t      shine = 1.;\n\tlp = t < 16. ? vec3(20, 8, -10) : vec3(-5, 1, -10);\n\tif (t > 36.) lp = vec3(30, -3.4, 35. * t - 1640.);\n\tld = normalize(lp - p);\n\tc = vec3(.5, .4, .3);\n\n\t// Cache noise.\n\tvec2 ns = n331(h.p, vec2(20, 38));\n\tif (h.id == METAL_ID) {\n\t\tshine = 1. - sum2(ns) * .1;\n\t\tc *= shine;\n\t\tss = sss(p, ld) * .5;\n\t}\n\telse if (h.id == METAL_DARK_ID) {\n\t\tshine = 1. - sum2(ns) * .1;\n\t\tc *= shine * .2;\n\t\tss = sss(p, ld) * .5;\n\t}\n\telse if (h.id == GLASS_ID) {\n\t\tshine = 1. - sum2(ns) * .95;\n\t\tc *= shine * .02;\n\t}\n\telse c = vec3(9); // Lazer\n\t// Specular imperfections.\n\tshine = .2 + .8 * ns.x * ns.y;\n\n\t// Key light, reverse, sky.\n\tl = sat(vec3(dot(ld, n), dot(-ld.xz, n.xz), n.y));\n\tif (h.id != LAZER_ID) {\n\t\t// Subsurface scattering.\n\t\tl.x += ss;\n\n\t\t// Diffuse.\n\t\tl.xy = .1 + .9 * l.xy;\n\n\t\t// Ambient occlusion.\n\t\tl.yz *= .1 + .9 * ao(p, n);\n\n\t\t// Light contributions (key, reverse, sky).\n\t\tl *= vec3(1, .4, .2);\n\n\t\t// Specular (Blinn-Phong)\n\t\tl.x += pow(sat(dot(normalize(ld - rd), n)), 10.) * shine;\n\n\t\t// Shadow.\n\t\tl.x *= .1 + .9 * shadow(p, lp, ld, n);\n\n\t\t// Light falloff\n\t\tl.x *= dot(lp, lp) / (1. + dot3(lp - p));\n\n\t\t// Lazer light-up.\n\t\tif (t > 16. && t < 34.) {\n\t\t\tlp = lazerP(p) - vec3(0, 0, 5);\n\t\t\tc += S(20., 10., abs(lp.z - p.z)) * S(5., 0., abs(p.x)) * sat(.5 + dot(normalize(p - lp), n)) * vec3(.01, 1, .01);\n\t\t}\n\t}\n\n\tcol = mix((sum2(l.xy) * LIGHT_RGB + l.z * sky) * c, sky, S(.7, 1., 1. + dot(rd, n)) * .2);\n\tfg = t < 36. ? 4e-4 : 2e-5;\n\tfg = exp(dot3(p - ro) * -fg); // Distance Fog.\n\treturn mix(sky, col, fg);\n}\n\nfloat addFade(float a) { return min(1., 2. * abs(t - a)); }\n\nvec4 march(vec3 ro, vec3 rd) {\n\t// March the scene.\n\tvec3 dv, n, col,\n\t     p = ro;\n\tfloat i,\n\t      d = START_DIST;\n\tHit h;\n\tfor (i = Z0; i < MAX_STEPS; i++) {\n\t\tif (d > MAX_DIST) {\n\t\t\th.id = SKY_ID;\n\t\t\tbreak;\n\t\t}\n\n\t\th = sdf(p);\n\t\tif (abs(h.d) < MIN_DIST * d) break;\n\t\td += h.d;\n\t\tp += h.d * rd;\n\t}\n\n\t// Floaty particles.\n\tdv = rd;\n\tfor (i = 1.5; i < d && t < 16.; i += 4.) {\n\t\tvec3 vp = ro + dv * i;\n\t\tvp.yz -= t * .05;\n\t\tg.x += .2 * (1. - S(0., mix(.05, .02, sat((i - 1.) / 19.)), length(fract(vp - ro) - .5)));\n\t\tdv.xz *= mat2(.87758, .47943, -.47943, .87758);\n\t}\n\n\tcol = g.x * LIGHT_RGB + g.y * vec3(.1, 1.5, .3);\n\tcol += lights(p, ro, rd, n = N(p, d), h);\n\tif (h.id > BELOW_ARE_REFLECTIVE) {\n\t\t// We hit a reflective surface, so march reflection.\n\t\trd = reflect(rd, n);\n\t\tp += n * .01;\n\t\tro = p;\n\t\td = .01;\n\t\tfor (i = Z0; i < MAX_RSTEPS; i++) {\n\t\t\tif (d > MAX_RDIST) {\n\t\t\t\th.id = SKY_ID;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\th = sdf(p);\n\t\t\tif (abs(h.d) < MIN_DIST * d) break;\n\t\t\td += h.d;\n\t\t\tp += h.d * rd;\n\t\t}\n\n\t\t// Add a hint of the reflected color.\n\t\tcol += .2 * lights(p, ro, rd, N(p, d), h);\n\t}\n\n\tcol = pow(max(vec3(0), col), vec3(.4545));\n    return vec4(col, (1. - sat(3. * d / MAX_DIST)) * 0.25);\n}\n\n#define rgba(col)\tcol * fade\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tt = mod(iTime, 50.);\n\tfade = addFade(0.) * addFade(16.) * addFade(36.) * addFade(50.);\n\tg = vec3(0);\n\tvec2 uv = (fc - .5 * R.xy) / R.y;\n\tvec3 lookAt = vec3(0),\n\t     ro = vec3(0, .001, -6);\n\tif (t < 16.) {\n\t\t// Stage 1 - Hanging.\n\t\tro = mix(vec3(-4, 2, -1), vec3(-1, -1, -7), S(0., 7., t));\n\t\tfloat st = S(6.5, 13., t);\n\t\tro = mix(ro, vec3(1, .8, -6), st);\n\t\tlookAt = vec3(0, st, 0);\n\t}\n\telse if (t < 22.)\n        // Stage 2 - Pillar corridor.\n        ro = vec3(sin(t), 6, 14);\n\telse if (t < 36.) {\n\t\t// Stage 3 - Side-on pillars.\n\t\tro = vec3(8, 0, 3. * cos(t * .6) - 3.);\n\t\tro += S(30., 34., t) * vec3(-9, 0, 15);\n\t\tlookAt.y = -1.;\n\t}\n\telse {\n\t\t// Stage 4 - Escape tunnel.\n\t\tro.y++;\n\t\tro.z += 15.;\n\t}\n    \n\t// View bob.\n\tro += .1 * sin(iTime * vec3(.9, .7, .3));\n    \n\tvec4 col = march(ro, rayDir(ro, lookAt, uv));\n    \n\tcol.rgb *= 1. - .3 * dot(uv, uv); // Vignette.\n\tcol.rgb += (h21(fc) - .5) / 64.; // Grain\n    \n\tfragColor = rgba(col);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}