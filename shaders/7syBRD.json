{
    "Shader": {
        "info": {
            "date": "1657733900",
            "description": "I had to study how to make a color mix and implement in my code.\n\nI noticed that I must use a vec4 with alpha for these type of calculations, now, the ball has correct color and the square drawing is correct.",
            "flags": 0,
            "hasliked": 0,
            "id": "7syBRD",
            "likes": 0,
            "name": "007 - Bouncing ball color mix",
            "published": 3,
            "tags": [
                "mix",
                "beginner",
                "color",
                "square",
                "ball",
                "learning",
                "colormix",
                "mixnormal"
            ],
            "usePreview": 0,
            "username": "PiGIon",
            "viewed": 204
        },
        "renderpass": [
            {
                "code": "// 2022.07.13\n// 2022.08.14 - removal of blend normal function, replaced by mix\n\n#define PI 3.14159265\n\n// matrix functions\nmat2 rot2D(float ang);\n\n// time cycling functions\nfloat cycle(float perSecond);\nfloat rangeCycle(float size, float perSec);\n\n// shape functions\nfloat circle(vec2 uv, vec2 origin, float size);\nfloat square(vec2 uv, vec2 origin, float size, float ang);\n\n// color blending functions\nvec4 blendNormal(vec4 base, vec4 blend);\n\n// returns a back and forth 0.0 to 1.0 per second\nfloat cycle(float perSecond) {\n    float d = fract((iTime + iTimeDelta) * perSecond);\n    \n    // step 0.5 is used to reverse the keyframe, to get a coming and going effect\n    // since the cut point is 0.5, we need to get original place (e.g. 1 again) if d is exactly to 0.5\n    // this means that it cycles from 0...1...0 every second\n    return 2. * ( d>.5 ? 1.-d : d );\n}\n\n// returns alpha value of a circle with antiAlias\nfloat circle(vec2 uv, vec2 origin, float size) {\n    float antiAlias = 1.5/iResolution.y; // TODO: don't recalculate this every time\n\n    return smoothstep(size + antiAlias, size - antiAlias, length(uv - origin));\n}\n\n// returns alpha value of a square with antiAlias\nfloat square(vec2 uv, vec2 origin, float size, float ang) {\n    vec2 o = (uv - origin) * rot2D(ang);\n    float antiAlias = 1.5/iResolution.y;\n    \n    vec2 range = vec2(size + antiAlias, size - antiAlias);\n    \n    return smoothstep(range.x, range.y, abs(o.x)) * smoothstep(range.x, range.y, abs(o.y));\n}\n\n// matrix rot2D based on pi\nmat2 rot2D(float ang) {\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n}\n\n// returns -size to size cycle\nfloat rangeCycle(float size, float perSec) {\n    return mod(iTime*perSec - size, size) - .5*size;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec4 O = fragColor;\n\n    float shapeSize = 0.1 + cycle(0.3999) * 0.4;\n    vec2 shapeOrigin = vec2(rangeCycle(5., -1.88), 0.);\n\n    float c = cycle(1.);\n    // range from bottom of screen to top of screen, determined by the shape size\n    shapeOrigin.y = shapeSize - 1. + (1. - shapeSize)*(2. * c);\n    \n    vec4 bg = vec4(0., 0., 0.14, 1.);\n    vec4 cColor = vec4(0.89, 0., 0., circle(uv, shapeOrigin, shapeSize));\n\n    // I need to discover the size of the section of the circle, here, I use pythagorean theorem to do it\n    vec4 sColor = vec4(0, 0.87, 0., \n            square(uv, shapeOrigin, sqrt((pow(shapeSize/2., 2.) + pow(shapeSize/2., 2.))), rangeCycle(PI, -1.33)));\n    \n\n    O = mix(bg, cColor, cColor.w);\n    O = mix(O, sColor, sColor.w);\n    \n    fragColor = O;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}