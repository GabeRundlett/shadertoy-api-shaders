{
    "Shader": {
        "info": {
            "date": "1533673797",
            "description": "Work in progress. Fast Z-order or Morton code merge sort of particles. Merge sort is fast with binary search so log2 number of passes, but relies on merging sorted parts, so we cannot use it easily on particles updated every frame. Lot of unused code too.",
            "flags": 32,
            "hasliked": 0,
            "id": "4ltczj",
            "likes": 9,
            "name": "WIP Fast Z-order Sort",
            "published": 3,
            "tags": [
                "wip",
                "sort",
                "merge",
                "quadtree",
                "morton",
                "zorder",
                "bitonic"
            ],
            "usePreview": 0,
            "username": "emh",
            "viewed": 794
        },
        "renderpass": [
            {
                "code": "bool sorted0 = false;\nbool sorted2 = false;\n\n//#define condFetch(x) (sorted0 ? texelFetch(iChannel0, ivec2(x), 0) : texelFetch(iChannel2, ivec2(x), 0))\n//#define condFetch(x) (sorted0 ? texelFetch(iChannel0, ivec2(x), 0) : texelFetch(iChannel2, ivec2(x), 0))\n\n#define condFetch(x) texelFetch(iChannel3, ivec2(x), 0)\n\nfloat textColor(vec3 bgColor) {\n  float r = bgColor.r * 255.0,\n        g = bgColor.g * 255.0,\n        b = bgColor.b * 255.0;\n  float yiq = (r * 299.0 + g * 587.0 + b * 114.0) / 1000.0;\n  return (yiq >= 128.0) ? 0.0 : 1.0;\n}\n\nvec2 vmin(vec2 v1, vec2 v2) {\n    return length(v1) < length(v2) ? v1 : v2;\n}\n\nstruct mRet {\n    int Am;\n    vec4 v;\n};\n\nmRet getM(int m, vec2 res, vec2 pres) {\n    vec2 fc = vec2(fromLinear(m, res));\n    vec4 v = condFetch(fc);\n    int Am = toIndex(v.xy * pres, pres);\n    return mRet(Am, v);\n}\n\nint binarySearchLeftMost(int T, vec2 pres, vec2 res, in vec2 fragCoord, out vec4 col) {\n    int n = int(res.x * res.y);\n    int L = 0;\n    int R = n;\n    const int maxBin = 100;\n    int bx = 0;\n    int by = 20;\n    int i = 0;\n    for (i = 0; i < maxBin && L < R; i++) {\n        int m = (L + R) / 2;\n        int Am = getM(m, res, pres).Am;\n        //col += print(fragCoord - vec2(0.0, by + i * 15), float(i), 3, 0);\n        //col += print(fragCoord - vec2(50.0, by + i * 15), float(m), 10, 0);\n        //col += print(fragCoord - vec2(150.0, by + i * 15), float(L), 10, 0);\n        //col += print(fragCoord - vec2(250.0, by + i * 15), float(R), 10, 0);\n        L = Am < T ? m + 1 : L;\n        R = Am >= T ? m : R;\n    }\n    //col += print(fragCoord - vec2(0.0, 0.0), float(T), 10, 0);\n    int ret = i < maxBin - 1 ? L : -1;\n    //col += print(fragCoord - vec2(bx + 100, 0.0), float(ret), 10, 0);\n    return ret;\n}\n\nint binarySearchRightMost(int T, vec2 pres, vec2 res, in vec2 fragCoord, out vec4 col) {\n    int n = int(res.x * res.y);\n    int L = 0;\n    int R = n;\n    const int maxBin = 100;\n    int bx = 400;\n    int by = 20;\n    int i = 0;\n    for (i = 0; i < maxBin && L < R; i++) {\n        int m = (L + R) / 2;\n        int Am = getM(m, res, pres).Am;\n        //col += print(fragCoord - vec2(bx + 0, by + i * 15), float(i), 3, 0);\n        //col += print(fragCoord - vec2(bx + 50, by + i * 15), float(m), 10, 0);\n        //col += print(fragCoord - vec2(bx + 150, by + i * 15), float(L), 10, 0);\n        //col += print(fragCoord - vec2(bx + 250, by + i * 15), float(R), 10, 0);\n        L = Am <= T ? m + 1 : L;\n        R = Am > T ? m : R;\n    }\n    //col += print(fragCoord - vec2(bx, 0.0), float(T), 10, 0);\n    int ret = i < maxBin - 1 ? L - 1 : -1;\n    //col += print(fragCoord - vec2(bx + 100, 0.0), float(ret), 10, 0);\n    return ret;\n}\n\nvoid indexPlay(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 col = vec3(0.0);\n    vec2 res = getRes(iResolution.xy);\n    vec2 uv = floor(fragCoord / iResolution.xy * res);\n    ivec2 div = maxDiv(res);\n    vec2 colorUV = fragCoord / iResolution.xy;\n    int n = int(res.x * res.y);\n    int m = int(iResolution.x * iResolution.y);\n    \n    vec4 color = vec4(colorUV, 0.5, 1.0);\n    fragColor = color;\n    int index2 = int((fragCoord.x + fragCoord.y * iResolution.x) * float(div.x) / (iResolution.x * iResolution.y));\n    index2 = (index2 + iFrame * 100) % div.x;\n    vec2 rfc = vec2(fromIndex(index2, res));\n    vec2 colorUV2 = rfc / res;\n    vec4 color2 = vec4(colorUV2, 0.5, 1.0);\n    fragColor = color2;\n    //return;\n    \n    //int index = toIndex(fragCoord, iResolution.xy, col);\n    int index = toIndexCol(uv, res, col);\n    //div.x = int(res.x * res.x);\n    int scaledIndex = int(float(index) / float(div.x) * iResolution.x * iResolution.y);\n    int scaledIndex2 = int(float(index + 1) / float(div.x) * iResolution.x * iResolution.y);\n    int revIndex = int(float(scaledIndex) * float(div.x) / (iResolution.x * iResolution.y));\n    vec2 fc = vec2(fromIndex(revIndex, res));\n    vec2 fc2 = vec2(fromIndex(revIndex + 1, res));\n    vec2 fc3 = vec2(fromIndex(revIndex + 2, res));\n    vec2 fc4 = vec2(fromIndex(revIndex + 3, res));\n    \n    vec2 fcy = uv;\n    //fcy.y = res.y - fcy.y;\n    vec2 mfc = vec2(ivec2(fcy) * div.y / ivec2(res));\n    vec2 error1 = abs(fc - mfc);\n    vec2 error2 = abs(fc2 - mfc);\n    vec2 error3 = abs(fc3 - mfc);\n    vec2 error4 = abs(fc4 - mfc);\n    vec2 error = vmin(error1, vmin(error2, vmin(error3, error4)));\n    float r = float(scaledIndex) / (iResolution.x * iResolution.y);\n    fragColor = vec4(r);\n    if (scaledIndex != scaledIndex2) {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n    //return;\n    \n    vec2 dfc = mod(fragCoord, iResolution.xy / float(div.y));\n    float b1 = print(dfc, float(error.x), 4, 0);\n    float b2 = print(dfc - vec2(50.0, 0.0), float(error.y), 4, 0);\n    fragColor = vec4(b1 + b2);\n    \n    //float b = print(mod(fragCoord, iResolution.xy / float(div.y)) * 1.0, float(index), 4, 0);\n    float b3 = print(fragCoord, float(div.x) / (iResolution.x * iResolution.y), 10, 3);\n    //col = vec3(float(int(col.r) ^ int(b)));\n    //b = float(int(uv.x + uv.y) % 2 ^ int(b));\n    fragColor = vec4(vec3(b3), 1.0);\n    fragColor = vec4(col, 1.0);\n    //fragColor = vec4(error.x, 0.0, error.y, 1.0);\n}\n\nfloat doDistance(in vec2 fragCoord, vec2 colorUV) {\n    vec2 res2 = iResolution.xy;\n    float t = 1.0; //(sin(iTime) + 1.0) / 2.0 + 0.1;\n    fragCoord = ((fragCoord / res2 - 0.5) * t + 0.5) * res2;\n    //vec2 res2 = vec2(256.0);\n    //vec3 col = vec3(0.0);\n    vec2 powerOfTwoRes = getRes(res2);\n    //vec2 res = res2;\n    vec2 uv = floor(fragCoord / res2 * powerOfTwoRes);\n    ivec2 div = maxDiv(powerOfTwoRes);\n    //vec2 colorUV = fragCoord / iResolution.xy;\n    int n = int(powerOfTwoRes.x * powerOfTwoRes.y);\n    int m = int(res2.x * res2.y);\n    \n\t//fragColor *= 0.0;\n    int uvIndex = toIndex(uv, powerOfTwoRes);\n    //uvIndex = m / 2;\n    vec4 frcol = vec4(0.0);\n    int index3 = binarySearchLeftMost(uvIndex, powerOfTwoRes, res2, fragCoord, frcol);\n    int index4 = binarySearchRightMost(uvIndex, powerOfTwoRes, res2, fragCoord, frcol);\n    //int index3 = binarySearchLeftMost(n, iFrame, res, fragCoord, fragColor);\n    //return;\n    //index3 = binarySearchLeftMost(n, 0, res);\n    \n    mRet mret = getM(index3, res2, powerOfTwoRes);\n    int foundIndex = mret.Am;\n    vec4 v = mret.v;\n    float d = distance(colorUV, v.xy);\n    \n    int j = 0;\n    int a = min(index3, index4);\n    int b = max(index3, index4);\n    for (int j = 0; j < 1; j++) {\n        int i = a + j;\n        mRet mret = getM(i, res2, powerOfTwoRes);\n        int foundIndex = mret.Am;\n        vec4 v = mret.v;\n        d = min(d, distance(colorUV, v.xy));\n    }\n        \n    float ret = index3 < 0 ? -1.0 : d;\n    return ret;\n}\n\nvoid lookup(out vec4 fragColor, in vec2 fragCoord) { \n\tvec2 res2 = iResolution.xy;\n    int k = 10;\n    float mul = 1.0;\n    const float MAX = 1.0e10;\n    float rd = 0.0;\n    float mind = MAX;\n    vec2 powerOfTwoRes = getRes(res2);\n    vec2 colorUV = fragCoord / iResolution.xy;\n    for (int dx = -k; dx <= k; dx++) {\n        for (int dy = -k; dy <= k; dy++) {\n            vec2 delta = vec2(dx, dy);\n            vec2 delta2 = vec2(sign(float(dx)) * exp2(abs(float(dx))), sign(float(dy)) * exp2(abs(float(dy))));\n            \n            vec4 indexAndVel = texelFetch(iChannel1, ivec2(fragCoord + mul * delta), 0);\n            vec2 v = indexAndVel.zw;\n            int i = int(indexAndVel.x);\n            mRet iret = getM(i, res2, powerOfTwoRes);\n            vec2 newPos = iret.v.xy; // + v * float(iFrame % getMaxPasses(iResolution.xy));\n        \tfloat d = distance(colorUV, newPos);\n            mind = i < 0 ? mind : min(d, mind);\n            rd = i < 0 ? rd : d + rd;\n            \n            /*\n            i = int(texelFetch(iChannel1, ivec2(fragCoord + mul * delta2), 0).x);\n        \td = distance(colorUV, getM(i, res2, powerOfTwoRes).v.xy);\n            mind = i < 0 ? mind : min(d, mind);\n            rd = i < 0 ? rd : d + rd;\n\t\t\t*/\n        }\n    }\n    //fragColor = rd == MAX ? vec4(0.0) : vec4(rd * 1000.0);\n    //fragColor = vec4(rd * 0.05);\n    //mind = mind > 0.01 ? 0.0 : mind;\n    fragColor = vec4(mind * 500.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) { \n    sorted0 = texelFetch(iChannel0, ivec2(0), 0).b >= 1.0;\n\tsorted2 = texelFetch(iChannel2, ivec2(0), 0).b >= 1.0;\n    \n    vec3 col = vec3(0.0);\n    vec2 res = getRes(iResolution.xy);\n    vec2 uv = floor(fragCoord / iResolution.xy * res);\n    ivec2 div = maxDiv(res);\n    vec2 colorUV = fragCoord / iResolution.xy;\n    int n = int(res.x * res.y);\n    int m = int(iResolution.x * iResolution.y);\n    fragColor += print(fragCoord, float(n), 10, 0);\n    //return;\n    \n    /*\n    vec4 color3 = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    //color3.ba *= 0.0;\n    fragColor = vec4(float(toIndex(color3.xy * res, res)) / float(n)); //vec4(color3.xy / length(color3.xy), 0.0, 1.0);\n    //fragColor = color3 + vec4(0.0, 0.0, float(toIndex(color3.xy * res, res)) / float(n), 0.0);\n    fragColor = color3;\n    //return;\n    //fragColor = vec4(0.0, 0.0, color3.b, 1.0);\n    fragColor = vec4(color3.b, 0.0, 0.0, 1.0);\n    //return;\n    fragColor = \n        color3.a > 0.0\n        \t? \n        \t\tcolor3.b > 0.0\n        \t\t\t? vec4(0.0)\n        \t\t\t: vec4(1.0)\n        \t: vec4(color3.b, color3.b > 0.0 ? vec3(0.0) : vec3(length(color3.rg)));\n \t*/\n    \n    lookup(fragColor, fragCoord);\n    \n    vec2 sz = vec2(0.3);\n    vec2 tv = fragCoord.xy / iResolution.x / sz;\n    if (tv.y < 1.0 && tv.x < 1.0) {\n        if (tv.x < 0.33) {\n            fragColor = texture(iChannel0, tv);\n        } else if (tv.x < 0.66) {\n            fragColor = texture(iChannel2, tv);\n        } else {\n            fragColor = condFetch(ivec2(tv * iResolution.xy));\n        }\n    } else {\n        if (fragCoord.x < iResolution.x * 1.0 / 3.0) {\n            \n        } else {\n            \n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const int MAX_ITER = 12;\nconst int maxBin = 32;\n\nint getMaxPasses(vec2 res) {\n    return int(ceil(log2(res.x * res.y)));\n}\n\nint D(vec2 p, float n) {\n    int i=int(p.y), b=int(exp2(floor(30.-p.x-n*3.)));\n    i = ( p.x<0.||p.x>3.? 0:\n    i==5? 972980223: i==4? 690407533: i==3? 704642687: i==2? 696556137:i==1? 972881535: 0 )/b;\n \treturn i-i/2*2;\n}\n\nint Dbg(vec2 p) {\n    int i = int(p.y);\n    return int(p.x >= -1.0 && p.x <= 4.0 && p.y >= -1.0 && p.y <= 7.0);\n}\n\n\nfloat print(vec2 i, float num, int digits, int decimals) {\n    i /= 2.0;\n    int o = 0;\n    for (float n = float(digits - 1); n >= -float(decimals); n--) { \n        if ((i.x -= 4.0) < 3.0) {\n            // digit\n            o = D(i, floor(mod(num / pow(10.0, n), 10.0)));\n            break;\n        }\n    }\n    return float(o);\n}\n\nvec2 printBG(vec2 i, float num, int digits, int decimals) {\n    i /= 2.0;\n    int o = 0;\n    int bg = 0;\n    for (float n = float(digits - 1); n >= -float(decimals); n--) { \n        // background\n    \tbg += Dbg(i - vec2(4.0, 0.0));\n        if ((i.x -= 4.0) < 3.0) {\n            // digit\n            o = D(i, floor(mod(num / pow(10.0, n), 10.0)));\n            break;\n        }\n    }\n    return vec2(o, bg);\n}\n\n\n\nivec2 maxDiv(in vec2 resolution) {\n    ivec2 res = ivec2(resolution);\n    int div = 1;\n    int div2 = 1;\n    for (int i = 0; i < MAX_ITER; i++) {\n        res /= 2;\n        if (res.x == 0 && res.y == 0) break;\n        div *= 4;\n        div2 *= 2;\n    }\n    return ivec2(div, div2);\n}\n\nvec2 getRes(vec2 res) {\n    return vec2(exp2(ceil(log2(max(res.x, res.y)))));\n}\n\nint toIndexCol(in vec2 fragCoord, in vec2 resolution, inout vec3 col) {\n    int xl = int(fragCoord.x);\n    int yl = int(fragCoord.y);\n    ivec2 res = ivec2(resolution);\n    int div2 = 1;\n    /*\n    for (int i = 0; i < MAX_ITER; i++) {\n        res /= 2;\n        div2 *= 2;\n        if (res.x == 0 && res.y == 0) break;\n    }\n    res = ivec2(div2);\n\t*/\n    int index = 0;\n    int div = 1;\n    div2 = 1;\n    bool colorDone = false;\n    for (int i = 0; i < MAX_ITER; i++) {\n        ivec2 rest = res % 2;\n        res /= 2;\n        if (res.x == 0 && res.y == 0) break;\n        div *= 4;\n        div2 *= 2;\n        int x = int(xl >= res.x);\n        int y = int(yl >= res.y);\n        xl -= x * res.x;\n        yl -= y * res.y;\n        //res += x * rest.x;\n        //res += y * rest.y;\n        int thisIndex = y * 2 + x;\n        index = index * 4 + thisIndex;\n        \n        if (!colorDone) {\n            vec2 uv = vec2(xl, yl) / vec2(res);\n            vec2 center = vec2(0.5);\n            float d = distance(uv, center);\n            float r = float(d < 0.25);\n            bool border = d > 0.25 - 0.02 / float(div2) && d < 0.25;\n            if (border) {\n                colorDone = true;\n            } else {\n            \tcol = vec3(float(int(col) ^ int(r)));\n            }\n        }\n    }\n    //return res.x * res.y - index - 1;\n    return index;\n}\n\nint toIndex(in vec2 fragCoord, in vec2 resolution) {\n    vec3 col = vec3(0.0);\n    int index = toIndexCol(fragCoord, resolution, col);\n    //index += 1;\n    return index;\n}\n\nivec2 fromIndex(in int index, in vec2 resolution) {\n    //index -= 1;\n    ivec2 fc = ivec2(0);\n    int div = 1;\n    ivec2 div2 = ivec2(1);\n    ivec2 res = ivec2(resolution);\n    //index = res.x * res.y - index - 1;\n    for (int i = 0; i < MAX_ITER; i++) {\n        res /= 2;\n        //int rx = res.x % 2 == 0 ? 2 : 1;\n        //int ry = res.y % 2 == 0 ? 2 : 1;\n        \n        int thisIndex = index % 4;\n        fc.x += div2.x * (thisIndex % 2);\n        fc.y += div2.y * (thisIndex / 2);\n        index = index / 4;\n        \n        div2 *= 2;\n        if (index == 0) break;\n    }\n    return fc;\n}\n\nivec2 fromLinear(in int index, in vec2 resolution) {\n    //index -= 1;\n    return ivec2(index % int(resolution.x), index / int(resolution.x));\n}\n\nint toLinear(in vec2 fragCoord, in vec2 resolution) {\n    int index = int(fragCoord.x) + int(fragCoord.y) * int(resolution.x);\n    //index += 1;\n    return index;\n}\n\nvec4 updateParticle(in vec4 particle) {\n    vec2 v = particle.xy - particle.zw;\n    //v = vec2(0.0);\n    \n    if (particle.x < 0.0 || particle.x >= 1.0) {\n        v.x = -v.x;\n    }\n    if (particle.y < 0.0 || particle.y >= 1.0) {\n        v.y = -v.y;\n    }\n    \n    particle.zw = particle.xy;\n    particle.xy += v;\n        \n    return particle;\n}\n\nbool isLinearValid(in int index, vec2 iResolution) {\n    vec2 res = iResolution.xy;\n\treturn index < int(exp2(floor(log2(float(toLinear(res - 1.0, res))))));\n}\n\nbool isValid(in vec2 fragCoord, vec2 iResolution) {\n    vec2 res = iResolution.xy;\n    return isLinearValid(toLinear(fragCoord, res), iResolution);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Resources:\n// https://www.ics.uci.edu/~goodrich/pubs/skip-journal.pdf\n// Sorting with GPUs: A Survey: https://arxiv.org/pdf/1709.02520.pdf\n\n// Practice JavaScript implementation: http://jsbin.com/zeyiraw/\n\nconst int MAX_INT = 0x8FFFFFFF;\n\nfloat hash( uvec2 x )\n{\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n    return float(n) * (1.0/float(0xffffffffU));\n}\n\nconst int count = 8;\nint A[count];\nvec4 B[count];\n\nvoid SWAP(int a, int b) {\n    //int small = min(A[a], A[b]);\n    //int big = max(A[a], A[b]);\n    bool cmp = A[a] <= A[b];\n    int small = cmp ? A[a] : A[b];\n    int big = cmp ? A[b] : A[a];\n    vec4 first = cmp ? B[a] : B[b];\n    vec4 second = cmp ? B[b] : B[a];\n    A[a] = small;\n    A[b] = big;\n    B[a] = first; \n    B[b] = second;\n}\n\nivec2 fromLinear2(in int index, in vec2 resolution, int mode) {\n    if (mode == 0) {\n    \treturn ivec2(index % int(resolution.x), index / int(resolution.x));\n    } else {\n        return ivec2(index / int(resolution.y), index % int(resolution.y));\n    }\n}\n\nint toLinear2(in vec2 fragCoord, in vec2 resolution, int mode) {\n    if (mode == 0) {\n    \treturn int(fragCoord.x) + int(fragCoord.y) * int(resolution.x);\n    } else {\n        return int(fragCoord.x) * int(resolution.y) + int(fragCoord.y);\n    }\n}\n\nvoid sort() {\n    // Bitonic sort network from http://pages.ripco.net/~jgamble/nw.html\n    // http://jgamble.ripco.net/cgi-bin/nw.cgi?inputs=8&algorithm=batcher&output=macro\n    \n    /*\n    for (int i = 0; i < count; i++) {\n        for (int j = i + 1; j < count; j++) {\n            SWAP(i, j);\n        }\n    }\n    for (int i = 0; i < count; i++) {\n        for (int j = i + 1; j < count; j++) {\n            SWAP(i, j);\n        }\n    }\n\t*/\n    SWAP(0, 4);\n\tSWAP(1, 5);\n\tSWAP(2, 6);\n\tSWAP(3, 7);\n\tSWAP(0, 2);\n\tSWAP(1, 3);\n\tSWAP(4, 6);\n\tSWAP(5, 7);\n\tSWAP(2, 4);\n\tSWAP(3, 5);\n\tSWAP(0, 1);\n\tSWAP(2, 3);\n\tSWAP(4, 5);\n\tSWAP(6, 7);\n\tSWAP(1, 4);\n\tSWAP(3, 6);\n\tSWAP(1, 2);\n\tSWAP(3, 4);\n\tSWAP(5, 6);\n}\n\nbool compareTwo(int i, int j, vec4 a, vec4 b, int compare, vec2 res2) {\n    //toIndex(self.xy * res2, res2) < toIndex(self2.xy * res2, res2)\n    int ai = toIndex(a.xy * res2, res2);\n    int bi = toIndex(b.xy * res2, res2);\n    float l1 = length(a.xy);\n    float l2 = length(b.xy);\n    //return l1 * float(compare) < l2 * float(compare);\n    if (ai == bi) {\n        //return i * compare < j * compare;\n        if (l1 == l2) {\n            if (a.x == b.x) {\n        \t\treturn a.y * float(compare) < b.y * float(compare);\n            } else {\n                return a.x * float(compare) < b.x * float(compare);\n            }\n        } else {\n            return l1 * float(compare) < l2 * float(compare);\n        }\n    } else {\n    \treturn ai * compare < bi * compare;\n    }\n}\n\nvec4 getPartner(int i, vec2 fc, vec2 res, int TwoStage, int Pass_mod_Stage, int TwoStage_PmS_1, int Pass, int maxIndex, int mode) {\n    // my position within the range to merge\n    int j = int(i % TwoStage);\n\n    int compare = 0;\n\n    bool check1 = i + Pass > maxIndex;\n    bool check2 = i - Pass < 0;\n    bool check = check1 || check2;\n    check = false;\n    if ((j < Pass_mod_Stage) || (j > TwoStage_PmS_1) || check) {\n      // must copy -> compare with self\n      //return vec4(-1.0);\n      compare = 0;\n    } else {\n      // must sort\n      if (mod(float((j + Pass_mod_Stage) / Pass), 2.0) < 1.0) {\n        // we are on the left side -> compare with partner on the right\n        compare = check1 ? 0 : 1;\n      } else {\n        // we are on the right side -> compare with partner on the left\n        compare = check2 ? 0 : -1;\n      }\n    }\n\n    // get the partner\n    int adr = i + compare * Pass;\n    /*if (adr > maxIndex || adr < 0) {\n        return vec4(-1.0);\n    }*/\n    //adr = adr < 0 ? maxIndex - abs(adr % maxIndex) : adr % maxIndex;\n\n    ivec2 fc2 = fromLinear2(adr, res, mode);\n    compare = i < adr ? 1 : -1;\n    return vec4(adr, fc2, compare);\n}\n\nstruct mRet {\n    int Am;\n    vec4 v;\n    bool valid;\n};\n\n//const int debugLen = 16;\nconst int debugLen = 8;\nconst int debugA[debugLen + 1] = int[debugLen + 1](0, 2, 4, 6, 1, 3, 5, 7, 8);\n//const int debugA[debugLen + 1] = int[debugLen + 1](0, 1, 4, 5, 2, 3, 6, 7, 8);\n//const int debugA[debugLen + 1] = int[debugLen + 1](0, 0, 0, 0, 1, 1, 1, 1, 8);\n//const int debugA[debugLen + 1] = int[debugLen + 1](0, 1, 2, 3, 4, 5, 6, 7, 8);\n//const int debugA[debugLen + 1] = int[debugLen + 1](4, 5, 6, 7, 0, 1, 2, 3, 8);\n//const int debugA[debugLen + 1] = int[debugLen + 1](8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 40);\n// pairs for m = 3:\n// 6 1\n// 4 3\n// 2 5\n// 0 7\nint debugT[debugLen];                     \nconst bool debug = false;\n    \nmRet getM(int m, vec2 res, vec2 pres) {\n    if (debug) {\n        return mRet(debugA[m], vec4(debugA[m]), true);\n    }\n    vec2 fc = vec2(fromLinear2(m, res, 0));\n    vec4 v = texelFetch(iChannel0, ivec2(fc), 0);\n    int Am = toIndex(v.xy * pres, pres);\n    int maxIndex = toLinear2(res - 1.0, res, 0);\n    bool valid = m >= 0 && m <= maxIndex && isLinearValid(m, res);\n    return mRet(Am, v, valid);\n}\n\nmRet getMD(int m, vec2 res, vec2 pres) {\n    if (debug) {\n        return mRet(debugA[m], vec4(debugA[m]), true);\n    }\n    vec2 fc = vec2(fromLinear2(m, res, 0));\n    vec4 v = texelFetch(iChannel2, ivec2(fc), 0);\n    int Am = toIndex(v.xy * pres, pres);\n    int maxIndex = toLinear2(res - 1.0, res, 0);\n    bool valid = m >= 0 && m <= maxIndex && isLinearValid(m, res);\n    return mRet(Am, v, valid);\n}\n\n/*\nint binarySearchForMergeB(int n, int T, vec2 pres, vec2 res, in vec2 fragCoord) {\n    int L = 0;\n    int R = n;\n    const int maxBin = 100;\n    int i = 0;\n    for (i = 0; i < maxBin && L < R; i++) {\n        int m = (L + R) / 2;\n        int Am = getM(m, res, pres).Am;\n        L = Am < T ? m + 1 : L;\n        R = Am >= T ? m : R;\n    }\n    int ret = i < maxBin - 1 ? L : -1;\n    return ret;\n}*/\n\nint toRange(int x, int n) {\n    return min(max(0, x), n - 1);\n}\n\n/*\nivec2 pairToRange(int a, int b, int n, int targetOffset) {\n    if (a < 0) {\n        b += -a;\n        a = 0;\n    }\n    if (b < 0) {\n        a += -b;\n        b = 0;\n    }\n    //a = min(max(0, a), n - 1);\n    //b = \n    return ivec2(a, b);\n}*/\n\nbool cutValid(int n1, int n2, int astart, int bstart, int to, int m2, int x, vec2 res, vec2 pres) {\n    int apos = m2 - 1;\n    bool aValid = apos >= 0 && apos < n1;\n    int bpos = to - m2 - 1;\n    bool bValid = bpos >= 0 && bpos < n2;\n    \n    mRet Amret = getM(astart + apos, res, pres);\n    mRet Bmret = getM(bstart + bpos, res, pres);\n    \n    int cv11 = Amret.Am;\n    int cv12 = Bmret.Am;\n    return (\n        aValid && bValid && apos >= 0 && bpos >= 0 ? max(cv11, cv12) <= x\n        : bValid && apos < 0 && bpos >= 0 ? cv12 <= x\n        : aValid && apos >= 0 && bpos < 0 ? cv11 <= x\n        : Amret.valid && Bmret.valid);\n}\n\nbool cutCValid(int n1, int n2, int astart, int bstart, int to, int bm2, int x, vec2 res, vec2 pres) {\n    int apos = to - bm2 - 1;\n    int bpos = bm2 - 1;\n    bool aValid = apos >= 0 && apos < n1;\n    bool bValid = bpos >= 0 && bpos < n2;\n    \n    mRet Amret = getM(astart + apos, res, pres);\n    mRet Bmret = getM(bstart + bpos, res, pres);\n\tint cvc11 = Amret.Am;\n    int cvc12 = Bmret.Am;\n    return (\n    \taValid && bValid && apos >= 0 && bpos >= 0 ? max(cvc11, cvc12) <= x\n        : bValid && apos < 0 && bpos >= 0 ? cvc12 <= x\n        : aValid && apos >= 0 && bpos < 0 ? cvc11 <= x\n        : Amret.valid && Bmret.valid);\n}\n\nmRet checkIndex(int n1, int n2, int astart, int bstart, int to, int apos, vec2 res, vec2 pres) {\n    bool aValid = apos >= 0 && apos < n1;\n    int bpos = to - apos;\n    bool bValid = bpos >= 0 && bpos < n2;\n    \n    mRet Amret = getM(astart + apos, res, pres);\n    mRet Bmret = getM(bstart + bpos, res, pres);\n    \n    int candA = Amret.Am;\n    bool candAv = cutValid(n1, n2, astart, bstart, to, apos, candA, res, pres) && aValid;\n    Amret.valid = Amret.valid && candAv;\n    \n    int candB = Bmret.Am;\n    bool candBv = cutCValid(n1, n2, astart, bstart, to, bpos, candB, res, pres) && bValid;\n    Bmret.valid = Bmret.valid && candBv;\n    \n    if (candAv && candBv) {\n        if (candA < candB) {\n            return Amret;\n        } else {\n            return Bmret;\n        }\n    } else if (candAv) {\n        return Amret;\n    }\n    return Bmret;\n}\n\nmRet binarySearchForMerge(\n    int targetOffset, int n1, int n2, vec2 pres, vec2 res,\n    in vec2 fragCoord, int astart, int bstart, inout vec2 digits) {\n    \n    int L1 = min(max(targetOffset + 1 - n1, 0), n1 - 1);\n    int R1 = min(targetOffset + 1, n1);\n    int L2 = min(max(targetOffset + 1 - n2, 0), n2 - 1);\n    int R2 = min(targetOffset + 1, n2);\n    \n    int OL1 = L1;\n    int OR2 = R2;\n    \n    int i = 0;\n    \n    mRet ret;\n    \n    float bx = -30.0;\n    float by = -15.0;\n    // Looking for m such that there are\n    // apos elements less than A[m] in A\n    // and bpos elements less than A[m] in B.\n    // For given m, how to count elements less than A[m] in A and B.\n    // For given m, decide whether there are more than targetOffset elements less than A[m] in A and B.\n    // For given m, is A[m] such an element that B[bpos] < A[m] and B[bpos + 1] \n\n    vec2 black = vec2(1.0, 0.0);\n    vec2 white = vec2(0.0);\n    \n    bool bValid = true;\n    \n    for (i = 0; i < maxBin && L1 < R1 && (L2 < R2 || !bValid); i++) {\n        int m = (L1 + R1) / 2 + (L1 + R1) % 2;\n        int bm = targetOffset - m;\n        int apos = m;\n        bool aValid = apos >= 0 && apos < n1;\n        int bpos = bm;\n        bValid = bpos >= 0 && bpos < n2;\n        \n        mRet Amret = getM(astart + apos, res, pres);\n        aValid = aValid && Amret.valid;\n        mRet Bmret = getM(bstart + bpos, res, pres);\n        bValid = bValid && Bmret.valid;\n        \n        float bline = -80.0;\n        bool showPos = true;\n        if (showPos) {\n        \tdigits += printBG(fragCoord + vec2(float(targetOffset) * bx, 1.0 * bline + float(i) * by), float(apos), 2, 0);\n        \tdigits += printBG(fragCoord + vec2(float(targetOffset) * bx, 2.0 * bline + float(i) * by), float(bpos), 2, 0);\n        }\n\n        int Am = Amret.Am;\n        int Bm = Bmret.Am;\n\n        digits += printBG(fragCoord + vec2(float(targetOffset) * bx, 3.0 * bline + float(i) * by), float(Am), 2, 0);\n        digits += printBG(fragCoord + vec2(float(targetOffset) * bx, 4.0 * bline + float(i) * by), float(Bm), 2, 0);\n       \n        {\n            float dx = 40.0;\n            int a = L1;\n            int b = R1;\n            int c = L2;\n            int d = R2;\n            \n            float sbx = 300.0;\n            float sbx2 = 550.0;\n            float sx = sbx + float(a) * dx;\n            float ex = sx + dx * float(b - a);\n            float sx2 = sbx2 + float(c) * dx;\n            float ex2 = sx2 + dx * float(d - c);\n            float hs = 20.0 + 55.0 * float(targetOffset);\n            float hy = 5.0;\n            \n            // left, a range\n            digits +=\n                fragCoord.x >= sx &&\n                fragCoord.x <= ex &&\n                fragCoord.y >= hs + hy * float(i * 2) &&\n                fragCoord.y <= hs + hy * float(i * 2 + 1)\n                    ? black\n                    : white;\n            // right, b range\n            digits +=\n                fragCoord.x >= sx2 &&\n                fragCoord.x <= ex2 &&\n                fragCoord.y >= hs + hy * float(i * 2) &&\n                fragCoord.y <= hs + hy * float(i * 2 + 1)\n                    ? black\n                    : white;\n           \t// whole lines for compare\n            digits +=\n                fragCoord.x >= sbx &&\n                fragCoord.x <= sbx + dx * 8.0 &&\n                fragCoord.y >= 6.0 &&\n                fragCoord.y <= 8.0\n                    ? black\n                    : white;\n            digits +=\n                fragCoord.x >= sbx2 &&\n                fragCoord.x <= sbx2 + dx * 8.0 &&\n                fragCoord.y >= 6.0 &&\n                fragCoord.y <= 8.0\n                    ? black\n                    : white;\n        }\n        \n        bool comparison = Am < Bm && aValid && bValid;\n        bool inUpperHalf = comparison;\n        \n        // m + 1 to R1\n        L1 = inUpperHalf ? m : L1;\n        // L1 to m\n        R1 = !inUpperHalf ? m - 1 : R1;\n        // bm + 1 to R2\n        L2 = !inUpperHalf ? bm : L2;\n        // L2 to bm\n        R2 = inUpperHalf ? bm : R2;\n    }\n    mRet error = mRet(-1, vec4(-1.0), false);\n    if (i >= maxBin - 1) {\n        ret = error;\n    } else {\n        int apos = L1;\n        int bpos = targetOffset - L1;\n        bValid = bpos >= 0 && bpos < n2;\n        \n        mRet AL1ret = getM(astart + apos, res, pres);\n        mRet BL1ret = getM(bstart + bpos, res, pres);\n        //return AL1ret;\n        \n        // XXX: AL1ret and BL1ret should be valid I hope\n        int m2 = AL1ret.Am < BL1ret.Am && bValid ? L1 + 1 : L1;\n        int bm2 = OR2 - (m2 - OL1);\n        bool bm2Valid = bm2 >= 0 && bm2 < n2;\n        bool bm2Min1Valid = bm2 - 1 >= 0 && bm2 - 1 < n2;\n        \n        int to = targetOffset;\n\n        mRet cand1 = checkIndex(n1, n2, astart, bstart, to, m2, res, pres);\n        mRet cand2 = checkIndex(n1, n2, astart, bstart, to, bm2, res, pres);\n        cand2.valid = cand2.valid && bm2Valid;\n        mRet cand3 = checkIndex(n1, n2, astart, bstart, to, m2 - 1, res, pres);\n        mRet cand4 = checkIndex(n1, n2, astart, bstart, to, bm2 - 1, res, pres);\n        cand4.valid = cand4.valid && bm2Min1Valid;\n\n        ret = cand1;\n        if (cand2.valid && (cand2.Am < ret.Am || !ret.valid)) {\n            ret = cand2;\n        }\n        if (cand3.valid && (cand3.Am < ret.Am || !ret.valid)) {\n            ret = cand3;\n        }\n        if (cand4.valid && (cand4.Am < ret.Am || !ret.valid)) {\n            ret = cand4;\n        }\n        mRet AnMin1 = getM(astart + n1 - 1, res, pres);\n        mRet BtoMinN = getM(bstart + to - n1, res, pres);\n        mRet BnMin1 = getM(bstart + n2 - 1, res, pres);\n        mRet AtoMinN = getM(astart + to - n2, res, pres);\n        if (targetOffset >= n1 && AnMin1.Am < BtoMinN.Am && BtoMinN.valid) {\n            ret = BtoMinN;\n        }\n        if (targetOffset >= n2 && BnMin1.Am < AtoMinN.Am && AtoMinN.valid) {\n            ret = AtoMinN;\n        }\n        //ret = cand4;\n        //ret.Am += 10 * int(ret.valid);\n    }\n    return ret;\n}\n\n// Returns -1 if not finished, +endFrame if finished\nint mergeColumns(out vec4 fragColor, in vec2 fragCoord, int frame) {\n    \n    vec2 res = iResolution.xy;\n    vec2 pres = getRes(res);\n    \n    const bool columns = false;\n    if (columns) {\n        int n = int(res.y);\n        int base = int(fragCoord.x) - int(fragCoord.x) % 2;\n        bool firstRow = int(fragCoord.x) % 2 == 0;\n        int col1 = base;\n        int col2 = base + 1;\n        int astart = toLinear(vec2(col1, 0), res);\n        int bstart = toLinear(vec2(col2, 0), res);  \n        int targetOffset = n * (firstRow ? 1 : 0) + int(fragCoord.y);\n        \n        /*\n        Find apos and bpos such that\n            targetOffset = apos + bpos\n        and\n            let m = min(a[apos, b[bpos])\n            for all k < apos, l < bpos, a[k] < m and b[l] < m\n        .\n        */\n        vec2 digits = vec2(0.0);\n        mRet a = binarySearchForMerge(targetOffset, n, n, pres, res, fragCoord, astart, bstart, digits);\n        if (a.Am < 0) {\n            fragColor.ba = vec2(1.0, 0.0);\n        } else {\n            fragColor = a.v;\n        }\n    } else {\n        \n        //res = vec2(256.0);\n        //pres = res;\n        \n        int index = toLinear(fragCoord, res);\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        //fragColor.a = 0.0;\n        int self = getM(index, res, pres).Am;\n        int next = getM(index + 1, res, pres).Am;\n        if (self > next) {\n            //fragColor.b = 1.0;\n        } else {\n            //fragColor.b = 0.0;\n        }\n        \n        //int maxPasses = int(ceil(log2(res.x * res.y)));\n        \n        int maxPasses = getMaxPasses(res);\n        int activeFrame = frame;\n        \n        bool noLoop = activeFrame >= maxPasses;\n        //noLoop = false;\n        \n        if (noLoop) {\n            return maxPasses;\n        }\n        int pass = activeFrame % maxPasses;\n        /*\n        int pass = activeFrame % (3 * maxPasses);\n        if (pass >= 2 * maxPasses) {\n        \tupdateParticle(fragColor, fragCoord);\n            return;\n        } else if (pass >= maxPasses) {\n            return;\n        }*/\n        int baseMod = 1 << pass;\n        //int n = 1 << pass;\n        int maxIndex = toLinear2(res - 1.0, res, 0);\n        int n = (1 << pass);\n        if (2 * n >= maxIndex) {\n            return -1;\n        }\n        \n        int base = index - index % (2 * n);\n        bool firstHalf = int(fragCoord.x) % (2 * n) == 0;\n        int astart = base;\n        int bstart = base + n;\n        int targetOffset = index - base;\n        int n1 = n;\n        int n2 = n;\n        if (2 * n > index || base + 2 * n > maxIndex) {\n        \t//n1 -= base + n - maxIndex;\n            //return;\n        }\n        if (base + 2 * n > maxIndex) {\n        \t//n2 -= base + 2 * n - maxIndex;\n        }\n        \n        if (fragCoord.x <= res.x && fragCoord.y <= res.y) {\n            vec2 digits = vec2(0.0);\n            // TODO: doesn't work for n1 != n2\n            mRet a = binarySearchForMerge(targetOffset, n1, n2, pres, res, fragCoord, astart, bstart, digits);\n            if (a.Am < 0 || !a.valid) {\n                //fragColor.b = 1.0;\n            } else {\n                fragColor = a.v;\n            }\n        } else {\n            fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        }\n    }\n\t\n    if (debug) {\n        vec2 digits = vec2(0.0);\n        float bx = -30.0;\n        float by = -15.0;\n        int n = debugLen / 2;\n        int astart = 0;\n        int bstart = n;\n        for (int i = 0; i < debugLen; i++) {\n            int targetOffset = i;\n            mRet a = binarySearchForMerge(targetOffset, n, n, pres, res, fragCoord, astart, bstart, digits);\n            int val = a.Am;\n            if (val < 0) {\n                val = 99;\n            }\n            digits += printBG(fragCoord + vec2(float(i) * bx, by), float(val), 2, 0);\n        }\n        fragColor.ba += digits;\n        return -1;\n    }\n    return -1;\n}\n\n// https://www.shadertoy.com/view/XlcGD8\n// https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter46.html\n// https://stackoverflow.com/questions/26093629/glsl-odd-even-merge-sort\n// https://bl.ocks.org/zz85/cafa1b8b3098b5a40e918487422d47f6\nvoid oddEvenMergeSort(out vec4 fragColor, in vec2 fragCoord) {\n    // stage 0 has pass = 0\n    // stage 1 has pass = 1, pass = 0\n    // stage 2 has pass = 2, pass = 1, pass = 0\n    // ...\n    vec2 res = iResolution.xy;\n    \n    //res = vec2(256.0);\n    vec2 res2 = getRes(res);\n    vec4 self = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    self.ba *= 0.0;\n    int mode = 0;\n    int maxIndex = toLinear2(res - 1.0, res, mode);\n    int fieldSize = int(res.x); //toLinear(res, res);\n    int logFieldsize = int(ceil(log2(float(fieldSize))));\n    int totalSteps = ((logFieldsize + logFieldsize) * (logFieldsize + logFieldsize + 1)) / 2;\n    int frame = iFrame;\n    \n    /*\n    if (frame >= totalSteps) {\n        frame -= totalSteps;\n        mode = 1;\n    }*/\n    \n    //frame = int(iTime) / 1;\n    //float b3 = print(fragCoord, float(totalSteps) / 60.0, 10, 2);\n    //self.b += b3;\n    {\n        vec2 fc = fragCoord;\n        int i = toLinear2(fc, res, mode);\n        int j = i + 1;\n        ivec2 fc2 = fromLinear2(j, res, mode);\n        //fc2 = ivec2(fc + vec2(hash(uvec2(fc)), -1.0));\n        fc2 = ivec2(fc + vec2(0.0, -1.0));\n        //fc2 = ivec2(fc + vec2(1.0, 0.0));\n        vec4 self2 = texelFetch(iChannel0, fc2, 0);\n    \t//self.b = float(length(self2.xy) < length(self.xy));\n        if (!(fragCoord.x >= res.x || fragCoord.y >= res.y)) {\n        \tself.b = float(compareTwo(i, j, self, self2, 1, res2));\n        }\n    }\n    if (frame >= totalSteps) {\n        fragColor = self;\n        return;\n    }\n    \n    int pass = -1;\n    int stage = -1;\n    int loopI = 0;\n    for (loopI = 0; loopI < frame + 1; loopI++) {\n        pass--;\n        if (pass < 0) {\n            stage++;\n            pass = stage;\n        }\n    }\n    \n    float byd = 15.0;\n    float by = -75.0;\n    float bx = -740.0;\n    vec2 digits = vec2(0.0);\n    digits += printBG(fragCoord + vec2(bx, by), float(pass), 5, 0);\n    by += byd;\n    digits += printBG(fragCoord + vec2(bx, by), float(stage), 5, 0);\n    by += byd;\n    digits += printBG(fragCoord + vec2(bx, by), float(loopI), 5, 0);\n    by += byd;\n    digits += printBG(fragCoord + vec2(bx, by), float(totalSteps), 5, 0);\n    by += byd;\n    digits += printBG(fragCoord + vec2(bx, by), float(logFieldsize), 5, 0);\n    self.ba += digits;\n    \n    if (fragCoord.x >= res.x || fragCoord.y >= res.y) {\n        fragColor = vec4(0.0);\n        fragColor = self;\n        return;\n    }\n    \n    int ppass = 1 << pass;\n    int pstage = 1 << stage;\n\n    int TwoStage = 2 * pstage;\n    int Pass_mod_Stage = ppass % pstage;\n    int TwoStage_PmS_1 = TwoStage - Pass_mod_Stage - 1;\n    int Pass = ppass;\n\n    int i = toLinear2(fragCoord, res, mode);\n    ivec4 ret = ivec4(getPartner(i, fragCoord, res, TwoStage, Pass_mod_Stage, TwoStage_PmS_1, Pass, maxIndex, mode));\n    int adr = ret.x;\n    ivec2 fc2 = ret.yz;\n    int compare = ret.w;\n    \n    if (adr < 0 || fc2.x >= int(res.x) || fc2.y >= int(res.y)) {\n        fragColor = self;\n        return;\n    }\n    \n    // double check that partner will mirror us\n    /*\n    ivec4 ret2 = ivec4(getPartner(toLinear(fc2, res), vec2(fc2), res, TwoStage, Pass_mod_Stage, TwoStage_PmS_1, Pass, maxIndex));\n    if (ret2.x < 0 || ret2.yz != ivec2(fragCoord) || ret2.w != -compare) {\n        fragColor = self;\n        return;\n    }*/\n    \n    vec4 partner = texelFetch(iChannel0, fc2, 0);\n\n    // on the left it's a < operation; on the right it's a >= operation\n    //fragColor = (self.x * compare < partner.x * compare) ? self : partner;\n    fragColor = compareTwo(i, adr, self, partner, compare, res2) ? self : partner;\n    //fragColor = (length(self.xy) * float(compare) < length(partner.xy) * float(compare)) ? self : partner;\n}\n\nvoid bitonicMergeSort(out vec4 fragColor, in vec2 fragCoord) {\n\tint index = toLinear2(fragCoord, iResolution.xy, 0);\n    int maxIndex = toLinear2(iResolution.xy - 1.0, iResolution.xy, 0);\n    // forget last particles for now\n    maxIndex -= maxIndex % (count * 2);\n    if (index >= maxIndex) {\n        return;\n    }\n    //index = (index + iFrame) % maxIndex;\n    \n    //partner = index ^ (iFrame % 20); //int(hash(uvec2(iFrame, iFrame) * uint(maxIndex)));\n    //vec4 a = texelFetch(iChannel0, fromLinear(index, iResolution.xy), 0);\n    vec2 res = getRes(iResolution.xy);\n    \n    bool success = true;\n        /*iFrame % 2 == 0\n        \t? (index - index % count + count) <= maxIndex\n    \t\t: (index - index % count + count * count <= maxIndex;*/\n    int target = index % count;\n    //int pass = iFrame % (7 + 3 + 1);\n    int pass = iFrame % (2 + 3 + 1);\n    pass = iFrame <= 2 + 3 + 1 ? pass : 0;\n    bool sortBucketHorizontal = pass == 1;\n    bool mergeBucketsHorizontal = pass >= 2 && pass <= 2 + 3;\n    bool sortBucketVertical = pass == 6;\n    bool mergeBucketsVertical = pass >= 7 && pass <= 7 + 3;\n    int bucketSize = \n        mergeBucketsHorizontal\n        \t? count * int(exp2(float(pass - 2)))\n    \t\t: count * int(exp2(float(pass - 7)));\n    int bucket = index / count;\n    int level = count;\n    //for (int i = 0; i < pass; i++) {\n    //bucket = (bucket + pass) % 2 == 0 ? bucket + 1 : bucket - 1;\n    //}\n    //int bucketOffset = index - bucket * level;\n    vec4 original = vec4(0.0);\n    for (int i = 0; i < count; i++) {\n        //int s = target < count / 2 ? 1 : -1;\n        int partner = \n            sortBucketHorizontal\n            \t? index - target + i\n            \t: index - int(iResolution.x) * (((index / int(iResolution.x)) % count) - i);\n        /*\n        partner =\n            pass > 0\n            \t?\n            \t\t(bucket + i) * level + bucketOffset\n                    //index -\n                    //index % int(pow(float(count), float(pass + 1))) + \n                    //int(pow(float(count), float(pass))) * i\n           \t\t: partner;\n        */    \t\n      \tsuccess = success && partner >= 0 && partner <= maxIndex;\n        ivec2 fc = fromLinear2(partner, iResolution.xy, 0);\n        vec4 a = texelFetch(iChannel0, fc, 0);\n        original = index == partner ? a : original;\n        A[i] = toIndex(a.xy, res);\n        B[i] = a;\n    }\n    sort();\n    \n    //bool unordered = sign((Bi - Ai) * (partner - index)) < 0;\n    if (sortBucketHorizontal || sortBucketVertical) {\n    \tfragColor = success ? B[target] : original;\n    } else if (mergeBucketsHorizontal || mergeBucketsVertical) {\n        int offset = \n            mergeBucketsHorizontal\n            \t? index - index % count\n            \t: index - int(iResolution.x) * ((index / int(iResolution.x)) % count);\n       \tint stride = mergeBucketsHorizontal ? 1 : int(iResolution.x);\n        int aptr = offset ;\n        int partner = (index / count) % 2 == 0 ? aptr + stride * count : aptr - stride * count;\n        int bptr = partner;\n        if (aptr + count > maxIndex || bptr + count > maxIndex) {\n            fragColor = original;\n            //fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n            return;\n        }\n        for (int i = 0; i < 2 * bucketSize; i++) {\n            vec4 a = texelFetch(iChannel0, fromLinear2(aptr, iResolution.xy, 0), 0);\n            vec4 b = texelFetch(iChannel0, fromLinear2(bptr, iResolution.xy, 0), 0);\n            int ai = toIndex(a.xy, res);\n            int bi = toIndex(b.xy, res);\n            bool cmp = compareTwo(aptr, bptr, a, b, 1, res);\n            bool chooseA = \n                ai <= bi &&\n                aptr - offset + stride < bucketSize * stride &&\n            \t!(bptr - offset + stride < bucketSize * stride);\n            //sign((bi - ai) * (bptr - aptr)) < 0;\n            //chooseA = hash(uvec2(fragCoord)) < 0.5;\n            aptr += chooseA ? stride : 0;\n            bptr += chooseA ? 0 : stride;\n            bool onTarget = \n                mergeBucketsHorizontal\n                \t? index % (2 * bucketSize) == i\n                \t: index / int(iResolution.x) % (2 * bucketSize) == i;\n            fragColor =\n                onTarget\n                \t? (chooseA ? a : b)\n                    : fragColor;\n        }\n        /*\n        vec4 a = texelFetch(iChannel0, fromLinear(index, iResolution.xy), 0);\n        int partner = (index + pass) % 2 == 0 ? index + 1 : index - 1;\n        vec4 b = texelFetch(iChannel0, fromLinear(partner, iResolution.xy), 0);\n        int ai = toIndex(a.xy, res);\n        int bi = toIndex(b.xy, res);\n        bool unordered = sign((bi - ai) * (partner - index)) < 0;\n        fragColor = unordered ? b : a;\n\t\t*/\n    } else {\n        fragColor = original;\n    }\n    vec4 self = original;\n    vec4 self2 = texelFetch(iChannel0, fromLinear2(index + 1, iResolution.xy, 0), 0);\n    fragColor.b = float(compareTwo(index, index + 1, self, self2, 1, res));\n}\n\nvoid bubbleSort(out vec4 fragColor, in vec2 fragCoord, int frame) {\n    vec2 res = iResolution.xy;\n    vec2 pres = getRes(res);\n    int n = toLinear2(res - 1.0, res, 0);\n    int k = frame;\n    int index = toLinear2(fragCoord, res, 0);\n    // Examples:\n    \n    // k % 2 == 0 && index % 2 == 0 => dir == 1\n    // k % 2 == 0 && index % 2 == 1 => dir == -1\n    // k % 2 == 1 && index % 2 == 0 => dir == -1\n    // k % 2 == 1 && index % 2 == 1 => dir == 1\n    \n    // k == 0 && index == 0 => index + dir == 0 + 1 = 1\n    // k == 0 && index == 1 => index + dir == 1 - 1 = 0\n    // k == 0 && index == 2 => index + dir == 2 + 1 = 3\n    // k == 0 && index == 3 => index + dir == 3 - 1 = 2\n    // k == 0 && index == 4 => index + dir == 4 + 1 = 5\n    // k == 0 && index == 5 => index + dir == 5 - 1 = 4\n    \n    // k == 1 && index == 0 => index + dir == 0 - 1 = -1\n    // k == 1 && index == 1 => index + dir == 1 + 1 = 2\n    // k == 1 && index == 2 => index + dir == 2 - 1 = 1\n    // k == 1 && index == 3 => index + dir == 3 + 1 = 4\n    // k == 1 && index == 4 => index + dir == 4 - 1 = 3\n    // k == 1 && index == 5 => index + dir == 5 + 1 = 6\n    int dir = index % 2 == k % 2 ? 1 : -1;\n    mRet aRet = getM(index, res, pres);\n    mRet bRet = getM(index + dir, res, pres);\n    mRet aRet2 = getMD(int(aRet.v.z), res, pres);\n    mRet bRet2 = getMD(int(bRet.v.z), res, pres);\n    \n    // update\n    /*\n    aRet.v = updateParticle(aRet.v);\n    bRet.v = updateParticle(bRet.v);\n    aRet.Am = toIndex(aRet.v.xy * pres, pres);\n    bRet.Am = toIndex(bRet.v.xy * pres, pres);\n\t*/\n    \n    if (index + dir < 0 || index + dir >= n || !isLinearValid(index + dir, res)) {\n        fragColor = aRet.v;\n    } else {\n        if (aRet2.Am * dir < bRet2.Am * dir) {\n            fragColor = aRet.v;\n        } else {\n            fragColor = bRet.v;\n        }\n    }\n}\n\nint runPasses(out vec4 fragColor, in vec2 fragCoord, int startFrame) {\n    int frame = iFrame - startFrame;\n    int maxPasses = getMaxPasses(iResolution.xy);\n    //bool sortedB = texelFetch(iChannel0, ivec2(0), 0).b >= 0.0;\n    int bframe = max(0, frame);\n    if (frame < maxPasses || (bframe + 1) % (3 * maxPasses) == 0) {\n        //fragColor = updateParticle(fragColor);\n        //mergeColumns(fragColor, fragCoord, frame);\n        fragColor = texelFetch(iChannel2, ivec2(fragCoord), 0);\n        // predict future at time when sort is done\n        for (int i = 0; i < maxPasses; i++) {\n            fragColor = updateParticle(fragColor);\n        }\n        fragColor = updateParticle(fragColor);\n        \n        fragColor.z = float(toLinear2(fragCoord, iResolution.xy, 0));\n        return -1;\n    }\n    bframe = bframe % (3 * maxPasses);\n    \n    int ret = mergeColumns(fragColor, fragCoord, bframe);\n    if (!isValid(fragCoord, iResolution.xy)) {\n        fragColor = vec4(1.0);\n        return ret;\n    }\n    if (ret < 0) return ret;\n    \n    bubbleSort(fragColor, fragCoord, int(bframe));\n    \n    /*\n    if (bframe == maxPasses) {\n        // catch up\n        for (int i = 0; i < maxPasses - 1; i++) {\n            fragColor = updateParticle(fragColor);\n        }\n    }*/\n    //if (frame % 2 > 0) {\n    //} else {\n    //fragColor = updateParticle(fragColor);\n    //}\n    return 2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // https://www.shadertoy.com/view/MsVBWd\n    float startFrame = texelFetch(iChannel0, ivec2(0), 0).a;\n    if (iFrame == 0 || startFrame < 1.0) {\n        fragColor = vec4(0.0);\n        if (iChannelResolution[1].x > 0.0) {\n            fragColor = texture(iChannel1, fragCoord / iResolution.xy);\n        \t//fragColor.ba = vec2(0.0);\n        \tfragColor.xy = (fragColor.xy - 0.5) * 4.0 + 0.5;\n            fragColor.xy = clamp(fragColor.xy, 0.0, 1.0);\n            fragColor.zw = fragColor.xy + (fragColor.zw - 0.5) * 1.0 / iResolution.xy;\n            fragColor.zw = clamp(fragColor.zw, 0.0, 1.0);\n            if (fragCoord.x <= 1.0 && fragCoord.y <= 1.0) {\n            \tfragColor.a = 1.0 + float(iFrame);\n            }\n        }\n        return;\n    }\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    //oddEvenMergeSort(fragColor, fragCoord);\n    int ret = runPasses(fragColor, fragCoord, int(startFrame));\n    \n    //fragColor.ba += printBG(fragCoord + vec2(-100.0, 0.0), float(startFrame), 5, 0);\n    \n    if (fragCoord.x < 1.0 && fragCoord.y < 1.0) {\n        fragColor.a = startFrame;\n        fragColor.b = float(ret);\n    }\n}\n\n\n\n\n// Old Buffer A test\n/*\n// https://www.shadertoy.com/view/4dd3Wj\n\nfloat xor(float x, float c) { \n    float y=0., s=1.;\n    \n    for (int i = 0; i < 32; i++) {\n       if (x < s && c < s) break;\n       y += s * mod(floor(x/s) + floor(c/s), 2.0);\n       s *= 2.0;\n    }\n    \n    return y;\n    //return intBitsToFloat(floatBitsToInt(x) ^ floatBitsToInt(c));\n}\n\nfloat id(vec2 U, vec2 res) {\n    //return floor(U.x) + res.x * floor(U.y);\n    return float(toLinear(U, res));\n}\n\nvoid swapSort(out vec4 O, vec2 U) {\n    //if (iResolution.y < R) R /= 2.; // for icon resolution\n    vec2 R = iResolution.xy;\n    vec2 res = getRes(iResolution.xy);\n    //R = res;\n\n    float t = float(iFrame);\n    if (iFrame < 0) {\n        //int index = int((U.x + U.y * iResolution.x) / (iResolution.x * iResolution.y) * (res.x * res.y));\n        int index = int(float(toLinear(U, iResolution.xy)) / (iResolution.x * iResolution.y) * (res.x * res.y));\n        vec2 fc = vec2(fromIndex(index, res)) / vec2(res);\n    \tO = vec4(fc, 0.0, 1.0);\n        return;\n    }\n    if (iFrame == 0) {\n    \t//O = texture(iChannel1, U/R);\n        O = vec4(U / iResolution.xy, 0.0, 0.0);\n        return;\n    }\n    //if (mod(t,512.)==10. ) { O = texture(iChannel1, U/R).rrrr; return; }\n    //if (mod(t,512.)==266.) { O = texture(iChannel2, U/R); return; }\n    \n    \n    O =  texture(iChannel0, U/iResolution.xy);\n    \n    //if ( max(U.x,U.y) < R )   // sort array RxR\n    { \n        vec2 U = U / iResolution.xy * res;\n        vec2 S = vec2(xor(U.x,mod(t*1.73+103.7,R.x)),                     // dual location\n                      xor(U.y,mod(t*11.4+51.8 ,R.y)) ) +.5;\n        //if (ceil(S.x) >= res.x || ceil(S.y) >= res.y) {\n        //    return;\n        //}\n        //S = mod(S, iResolution.xy);\n        vec4 OS = texture(iChannel0, S / R.xy);               // its pixel value\n        float l1 = float(toIndex(O.xy * res, res));\n        float l2 = float(toIndex(OS.xy * res, res));\n        //l1 = length(O.xy);\n        //l2 = length(OS.xy);\n    \tif (sign((l2 - l1)*(id(S, iResolution.xy)-id(U, iResolution.xy))) < 0.) O = OS;   // swap if bad ordered\n    }\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n\t\n}\n*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "bool sorted0 = false;\nbool sorted2 = false;\n\n#define condFetch(x) (sorted0 ? texelFetch(iChannel0, ivec2(x), 0) : texelFetch(iChannel2, ivec2(x), 0))\n\nfloat textColor(vec3 bgColor) {\n  float r = bgColor.r * 255.0,\n        g = bgColor.g * 255.0,\n        b = bgColor.b * 255.0;\n  float yiq = (r * 299.0 + g * 587.0 + b * 114.0) / 1000.0;\n  return (yiq >= 128.0) ? 0.0 : 1.0;\n}\n\nvec2 vmin(vec2 v1, vec2 v2) {\n    return length(v1) < length(v2) ? v1 : v2;\n}\n\n/*\nfunction binary_search_leftmost(A, n, T):\n    L := 0\n    R := n\n    while L < R:\n        m := floor((L + R) / 2)\n        if A[m] < T:\n            L := m + 1\n        else:\n            R := m\n    return L\n                */\n\nstruct mRet {\n    int Am;\n    vec4 v;\n};\n\nmRet getM(int m, vec2 res, vec2 pres) {\n    /*\n    vec2 fc = vec2(fromIndex(m, res)) / res * iResolution.xy;\n\tvec4 v = condFetch(iChannel0, ivec2(fc), 0);\n\tint Am = toIndex(v.xy * res, res);\n\t*/\n    vec2 fc = vec2(fromLinear(m, res));\n    vec4 v = condFetch(fc);\n    int Am = toIndex(v.xy * pres, pres);\n    return mRet(Am, v);\n}\n\nmRet getMD(int m, vec2 res, vec2 pres) {\n    /*\n    vec2 fc = vec2(fromIndex(m, res)) / res * iResolution.xy;\n\tvec4 v = condFetch(iChannel0, ivec2(fc), 0);\n\tint Am = toIndex(v.xy * res, res);\n\t*/\n    vec2 fc = vec2(fromLinear(m, res));\n    vec4 v = texelFetch(iChannel3, ivec2(fc), 0);\n    int Am = toIndex(v.xy * pres, pres);\n    return mRet(Am, v);\n}\n\nint binarySearchLeftMost(int T, vec2 pres, vec2 res, in vec2 fragCoord, out vec4 col) {\n    int n = int(res.x * res.y);\n    int L = 0;\n    int R = n;\n    int bx = 0;\n    int by = 20;\n    int i = 0;\n    for (i = 0; i < maxBin && L < R; i++) {\n        int m = (L + R) / 2;\n        int Am = getM(m, res, pres).Am;\n        //col += print(fragCoord - vec2(0.0, by + i * 15), float(i), 3, 0);\n        //col += print(fragCoord - vec2(50.0, by + i * 15), float(m), 10, 0);\n        //col += print(fragCoord - vec2(150.0, by + i * 15), float(L), 10, 0);\n        //col += print(fragCoord - vec2(250.0, by + i * 15), float(R), 10, 0);\n        L = Am < T ? m + 1 : L;\n        R = Am >= T ? m : R;\n    }\n    //col += print(fragCoord - vec2(0.0, 0.0), float(T), 10, 0);\n    int ret = i < maxBin - 1 ? L : -1;\n    //col += print(fragCoord - vec2(bx + 100, 0.0), float(ret), 10, 0);\n    return ret;\n}\n\nint binarySearchRightMost(int T, vec2 pres, vec2 res, in vec2 fragCoord, out vec4 col) {\n    int n = int(res.x * res.y);\n    int L = 0;\n    int R = n;\n    int bx = 400;\n    int by = 20;\n    int i = 0;\n    for (i = 0; i < maxBin && L < R; i++) {\n        int m = (L + R) / 2;\n        int Am = getM(m, res, pres).Am;\n        //col += print(fragCoord - vec2(bx + 0, by + i * 15), float(i), 3, 0);\n        //col += print(fragCoord - vec2(bx + 50, by + i * 15), float(m), 10, 0);\n        //col += print(fragCoord - vec2(bx + 150, by + i * 15), float(L), 10, 0);\n        //col += print(fragCoord - vec2(bx + 250, by + i * 15), float(R), 10, 0);\n        L = Am <= T ? m + 1 : L;\n        R = Am > T ? m : R;\n    }\n    //col += print(fragCoord - vec2(bx, 0.0), float(T), 10, 0);\n    int ret = i < maxBin - 1 ? L - 1 : -1;\n    //col += print(fragCoord - vec2(bx + 100, 0.0), float(ret), 10, 0);\n    return ret;\n}\n\nvoid indexPlay(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 col = vec3(0.0);\n    vec2 res = getRes(iResolution.xy);\n    vec2 uv = floor(fragCoord / iResolution.xy * res);\n    ivec2 div = maxDiv(res);\n    vec2 colorUV = fragCoord / iResolution.xy;\n    int n = int(res.x * res.y);\n    int m = int(iResolution.x * iResolution.y);\n\n    vec4 color = vec4(colorUV, 0.5, 1.0);\n    fragColor = color;\n    int index2 = int((fragCoord.x + fragCoord.y * iResolution.x) * float(div.x) / (iResolution.x * iResolution.y));\n    index2 = (index2 + iFrame * 100) % div.x;\n    vec2 rfc = vec2(fromIndex(index2, res));\n    vec2 colorUV2 = rfc / res;\n    vec4 color2 = vec4(colorUV2, 0.5, 1.0);\n    fragColor = color2;\n    //return;\n\n    //int index = toIndex(fragCoord, iResolution.xy, col);\n    int index = toIndexCol(uv, res, col);\n    //div.x = int(res.x * res.x);\n    int scaledIndex = int(float(index) / float(div.x) * iResolution.x * iResolution.y);\n    int scaledIndex2 = int(float(index + 1) / float(div.x) * iResolution.x * iResolution.y);\n    int revIndex = int(float(scaledIndex) * float(div.x) / (iResolution.x * iResolution.y));\n    vec2 fc = vec2(fromIndex(revIndex, res));\n    vec2 fc2 = vec2(fromIndex(revIndex + 1, res));\n    vec2 fc3 = vec2(fromIndex(revIndex + 2, res));\n    vec2 fc4 = vec2(fromIndex(revIndex + 3, res));\n\n    vec2 fcy = uv;\n    //fcy.y = res.y - fcy.y;\n    vec2 mfc = vec2(ivec2(fcy) * div.y / ivec2(res));\n    vec2 error1 = abs(fc - mfc);\n    vec2 error2 = abs(fc2 - mfc);\n    vec2 error3 = abs(fc3 - mfc);\n    vec2 error4 = abs(fc4 - mfc);\n    vec2 error = vmin(error1, vmin(error2, vmin(error3, error4)));\n    float r = float(scaledIndex) / (iResolution.x * iResolution.y);\n    fragColor = vec4(r);\n    if (scaledIndex != scaledIndex2) {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n    //return;\n\n    vec2 dfc = mod(fragCoord, iResolution.xy / float(div.y));\n    float b1 = print(dfc, float(error.x), 4, 0);\n    float b2 = print(dfc - vec2(50.0, 0.0), float(error.y), 4, 0);\n    fragColor = vec4(b1 + b2);\n\n    //float b = print(mod(fragCoord, iResolution.xy / float(div.y)) * 1.0, float(index), 4, 0);\n    float b3 = print(fragCoord, float(div.x) / (iResolution.x * iResolution.y), 10, 3);\n    //col = vec3(float(int(col.r) ^ int(b)));\n    //b = float(int(uv.x + uv.y) % 2 ^ int(b));\n    fragColor = vec4(vec3(b3), 1.0);\n    fragColor = vec4(col, 1.0);\n    //fragColor = vec4(error.x, 0.0, error.y, 1.0);\n}\n\nfloat doDistance(in vec2 fragCoord, vec2 colorUV) {\n    vec2 res2 = iResolution.xy;\n    float t = 1.0; //(sin(iTime) + 1.0) / 2.0 + 0.1;\n    fragCoord = ((fragCoord / res2 - 0.5) * t + 0.5) * res2;\n    //vec2 res2 = vec2(256.0);\n    //vec3 col = vec3(0.0);\n    vec2 powerOfTwoRes = getRes(res2);\n    //vec2 res = res2;\n    vec2 uv = floor(fragCoord / res2 * powerOfTwoRes);\n    ivec2 div = maxDiv(powerOfTwoRes);\n    //vec2 colorUV = fragCoord / iResolution.xy;\n    int n = int(powerOfTwoRes.x * powerOfTwoRes.y);\n    int m = int(res2.x * res2.y);\n\n\t//fragColor *= 0.0;\n    int uvIndex = toIndex(uv, powerOfTwoRes);\n    //uvIndex = m / 2;\n    vec4 frcol = vec4(0.0);\n    int index3 = binarySearchLeftMost(uvIndex, powerOfTwoRes, res2, fragCoord, frcol);\n    int index4 = binarySearchRightMost(uvIndex, powerOfTwoRes, res2, fragCoord, frcol);\n    //int index3 = binarySearchLeftMost(n, iFrame, res, fragCoord, fragColor);\n    //return;\n    //index3 = binarySearchLeftMost(n, 0, res);\n\n    mRet mret = getM(index3, res2, powerOfTwoRes);\n    int foundIndex = mret.Am;\n    vec4 v = mret.v;\n    float d = distance(colorUV, v.xy);\n    /*ivec2 nfc = ivec2(vec2(fromIndex(index3, res)) * iResolution.xy / res);\n    vec4 v = condFetch(iChannel0, nfc, 0);\n    int foundIndex = toIndex(v.xy * res, res);\n\n\t*/\n\n    int j = 0;\n    int a = min(index3, index4);\n    int b = max(index3, index4);\n    int maxIter = 1;\n    int retIndex = -1;\n    for (int j = 0; j < maxIter; j++) {\n        int i = a + j - maxIter / 2;\n        //if (i > b) break;\n        /*\n        ivec2 nfc = ivec2(vec2(fromIndex(i, res)) * iResolution.xy / res);\n        vec4 v = condFetch(iChannel0, nfc, 0);\n        int foundIndex = toIndex(v.xy * res, res);\n        d = min(d, distance(colorUV, v.xy));\n\t\t*/\n        mRet mret = getM(i, res2, powerOfTwoRes);\n        int foundIndex = mret.Am;\n        vec4 v = mret.v;\n        float d2 = distance(colorUV, v.xy);\n        if (d2 < d) {\n            d = d2;\n            retIndex = i; //foundIndex;\n        }\n    }\n\n    /*\n    ivec2 nfc2 = ivec2(vec2(fromIndex(index3 + 1, res)) * iResolution.xy / res);\n    vec4 v2 = condFetch(iChannel0, nfc2, 0);\n    ivec2 nfc3 = ivec2(vec2(fromIndex(index3 + 2, res)) * iResolution.xy / res);\n    vec4 v3 = condFetch(iChannel0, nfc3, 0);\n    ivec2 nfc4 = ivec2(vec2(fromIndex(index3 + 3, res)) * iResolution.xy / res);\n    vec4 v4 = condFetch(iChannel0, nfc4, 0);\n\n    float d1 = distance(colorUV, v.xy);\n    float d2 = distance(colorUV, v2.xy);\n    float d3 = distance(colorUV, v3.xy);\n    float d4 = distance(colorUV, v4.xy);\n    float d = min(d1, min(d2, min(d3, d4)));\n\t*/\n    //fragColor = vec4(float((index3 + 100 * iFrame) % n) / float(n));\n    //fragColor = vec4(float(index3) / float(n));\n    //fragColor = vec4(float(abs(index3 - foundIndex)) / 100000.0);\n    //float ret = index3 < 0 ? -1.0 : d;\n    return float(retIndex);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    sorted0 = texelFetch(iChannel0, ivec2(0), 0).b >= 1.0;\n\tsorted2 = texelFetch(iChannel2, ivec2(0), 0).b >= 1.0;\n\n    vec3 col = vec3(0.0);\n    vec2 res2 = iResolution.xy;\n    vec2 res = getRes(iResolution.xy);\n    vec2 powerOfTwoRes = res;\n    vec2 uv = floor(fragCoord / iResolution.xy * res);\n    ivec2 div = maxDiv(res);\n    vec2 colorUV = fragCoord / iResolution.xy;\n    int n = int(res.x * res.y);\n    int m = int(iResolution.x * iResolution.y);\n    fragColor += print(fragCoord, float(n), 10, 0);\n    //return;\n\n    vec4 old = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    float oldIndex = old.x;\n    //float oldIndex2 = old.y;\n\n    mRet mret1 = getMD(int(oldIndex), res2, powerOfTwoRes);\n    float d2 = distance(colorUV, mret1.v.xy);\n    //mRet mret3 = getM(int(oldIndex2), res2, powerOfTwoRes);\n    //float d5 = distance(colorUV, mret3.v.xy);\n    //float d2 = min(d4, d5);\n    //float oldIndex = d4 < d5 ? oldIndex1 : oldIndex2;\n\n    float index = doDistance(fragCoord, colorUV);\n\n    mRet mret2 = getM(int(index), res2, powerOfTwoRes);\n    int bufDIndex = int(mret2.v.z);\n    mRet mret3 = getMD(bufDIndex, res2, powerOfTwoRes);\n    \n    float d3 = distance(colorUV, mret3.v.xy);\n    //float d3 = distance(colorUV, mret2.v.xy);\n\n    index = d3 < d2 ? mret2.v.z : oldIndex;\n    vec2 v = d3 < d2 ? mret3.v.xy - mret3.v.zw : old.zw;\n\n    fragColor = vec4(index, 0.0, v);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Resources:\n// https://www.ics.uci.edu/~goodrich/pubs/skip-journal.pdf\n// Sorting with GPUs: A Survey: https://arxiv.org/pdf/1709.02520.pdf\n\n// Practice JavaScript implementation: http://jsbin.com/zeyiraw/\n\nconst int MAX_INT = 0x8FFFFFFF;\n\nfloat hash( uvec2 x )\n{\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n    return float(n) * (1.0/float(0xffffffffU));\n}\n\nconst int count = 8;\nint A[count];\nvec4 B[count];\n\nvoid SWAP(int a, int b) {\n    //int small = min(A[a], A[b]);\n    //int big = max(A[a], A[b]);\n    bool cmp = A[a] <= A[b];\n    int small = cmp ? A[a] : A[b];\n    int big = cmp ? A[b] : A[a];\n    vec4 first = cmp ? B[a] : B[b];\n    vec4 second = cmp ? B[b] : B[a];\n    A[a] = small;\n    A[b] = big;\n    B[a] = first; \n    B[b] = second;\n}\n\nivec2 fromLinear2(in int index, in vec2 resolution, int mode) {\n    if (mode == 0) {\n    \treturn ivec2(index % int(resolution.x), index / int(resolution.x));\n    } else {\n        return ivec2(index / int(resolution.y), index % int(resolution.y));\n    }\n}\n\nint toLinear2(in vec2 fragCoord, in vec2 resolution, int mode) {\n    if (mode == 0) {\n    \treturn int(fragCoord.x) + int(fragCoord.y) * int(resolution.x);\n    } else {\n        return int(fragCoord.x) * int(resolution.y) + int(fragCoord.y);\n    }\n}\n\nvoid sort() {\n    // Bitonic sort network from http://pages.ripco.net/~jgamble/nw.html\n    // http://jgamble.ripco.net/cgi-bin/nw.cgi?inputs=8&algorithm=batcher&output=macro\n    \n    /*\n    for (int i = 0; i < count; i++) {\n        for (int j = i + 1; j < count; j++) {\n            SWAP(i, j);\n        }\n    }\n    for (int i = 0; i < count; i++) {\n        for (int j = i + 1; j < count; j++) {\n            SWAP(i, j);\n        }\n    }\n\t*/\n    SWAP(0, 4);\n\tSWAP(1, 5);\n\tSWAP(2, 6);\n\tSWAP(3, 7);\n\tSWAP(0, 2);\n\tSWAP(1, 3);\n\tSWAP(4, 6);\n\tSWAP(5, 7);\n\tSWAP(2, 4);\n\tSWAP(3, 5);\n\tSWAP(0, 1);\n\tSWAP(2, 3);\n\tSWAP(4, 5);\n\tSWAP(6, 7);\n\tSWAP(1, 4);\n\tSWAP(3, 6);\n\tSWAP(1, 2);\n\tSWAP(3, 4);\n\tSWAP(5, 6);\n}\n\nbool compareTwo(int i, int j, vec4 a, vec4 b, int compare, vec2 res2) {\n    //toIndex(self.xy * res2, res2) < toIndex(self2.xy * res2, res2)\n    int ai = toIndex(a.xy * res2, res2);\n    int bi = toIndex(b.xy * res2, res2);\n    float l1 = length(a.xy);\n    float l2 = length(b.xy);\n    //return l1 * float(compare) < l2 * float(compare);\n    if (ai == bi) {\n        //return i * compare < j * compare;\n        if (l1 == l2) {\n            if (a.x == b.x) {\n        \t\treturn a.y * float(compare) < b.y * float(compare);\n            } else {\n                return a.x * float(compare) < b.x * float(compare);\n            }\n        } else {\n            return l1 * float(compare) < l2 * float(compare);\n        }\n    } else {\n    \treturn ai * compare < bi * compare;\n    }\n}\n\nvec4 getPartner(int i, vec2 fc, vec2 res, int TwoStage, int Pass_mod_Stage, int TwoStage_PmS_1, int Pass, int maxIndex, int mode) {\n    // my position within the range to merge\n    int j = int(i % TwoStage);\n\n    int compare = 0;\n\n    bool check1 = i + Pass > maxIndex;\n    bool check2 = i - Pass < 0;\n    bool check = check1 || check2;\n    check = false;\n    if ((j < Pass_mod_Stage) || (j > TwoStage_PmS_1) || check) {\n      // must copy -> compare with self\n      //return vec4(-1.0);\n      compare = 0;\n    } else {\n      // must sort\n      if (mod(float((j + Pass_mod_Stage) / Pass), 2.0) < 1.0) {\n        // we are on the left side -> compare with partner on the right\n        compare = check1 ? 0 : 1;\n      } else {\n        // we are on the right side -> compare with partner on the left\n        compare = check2 ? 0 : -1;\n      }\n    }\n\n    // get the partner\n    int adr = i + compare * Pass;\n    /*if (adr > maxIndex || adr < 0) {\n        return vec4(-1.0);\n    }*/\n    //adr = adr < 0 ? maxIndex - abs(adr % maxIndex) : adr % maxIndex;\n\n    ivec2 fc2 = fromLinear2(adr, res, mode);\n    compare = i < adr ? 1 : -1;\n    return vec4(adr, fc2, compare);\n}\n\nstruct mRet {\n    int Am;\n    vec4 v;\n    bool valid;\n};\n\n//const int debugLen = 16;\nconst int debugLen = 8;\nconst int debugA[debugLen + 1] = int[debugLen + 1](0, 2, 4, 6, 1, 3, 5, 7, 8);\n//const int debugA[debugLen + 1] = int[debugLen + 1](0, 1, 4, 5, 2, 3, 6, 7, 8);\n//const int debugA[debugLen + 1] = int[debugLen + 1](0, 0, 0, 0, 1, 1, 1, 1, 8);\n//const int debugA[debugLen + 1] = int[debugLen + 1](0, 1, 2, 3, 4, 5, 6, 7, 8);\n//const int debugA[debugLen + 1] = int[debugLen + 1](4, 5, 6, 7, 0, 1, 2, 3, 8);\n//const int debugA[debugLen + 1] = int[debugLen + 1](8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 40);\n// pairs for m = 3:\n// 6 1\n// 4 3\n// 2 5\n// 0 7\nint debugT[debugLen];                     \nconst bool debug = false;\n    \nmRet getM(int m, vec2 res, vec2 pres) {\n    if (debug) {\n        return mRet(debugA[m], vec4(debugA[m]), true);\n    }\n    vec2 fc = vec2(fromLinear2(m, res, 0));\n    vec4 v = texelFetch(iChannel0, ivec2(fc), 0);\n    int Am = toIndex(v.xy * pres, pres);\n    int maxIndex = toLinear2(res - 1.0, res, 0);\n    bool valid = m >= 0 && m <= maxIndex && isLinearValid(m, res);\n    return mRet(Am, v, valid);\n}\n\nmRet getMD(int m, vec2 res, vec2 pres) {\n    if (debug) {\n        return mRet(debugA[m], vec4(debugA[m]), true);\n    }\n    vec2 fc = vec2(fromLinear2(m, res, 0));\n    vec4 v = texelFetch(iChannel2, ivec2(fc), 0);\n    int Am = toIndex(v.xy * pres, pres);\n    int maxIndex = toLinear2(res - 1.0, res, 0);\n    bool valid = m >= 0 && m <= maxIndex && isLinearValid(m, res);\n    return mRet(Am, v, valid);\n}\n\n/*\nint binarySearchForMergeB(int n, int T, vec2 pres, vec2 res, in vec2 fragCoord) {\n    int L = 0;\n    int R = n;\n    const int maxBin = 100;\n    int i = 0;\n    for (i = 0; i < maxBin && L < R; i++) {\n        int m = (L + R) / 2;\n        int Am = getM(m, res, pres).Am;\n        L = Am < T ? m + 1 : L;\n        R = Am >= T ? m : R;\n    }\n    int ret = i < maxBin - 1 ? L : -1;\n    return ret;\n}*/\n\nint toRange(int x, int n) {\n    return min(max(0, x), n - 1);\n}\n\n/*\nivec2 pairToRange(int a, int b, int n, int targetOffset) {\n    if (a < 0) {\n        b += -a;\n        a = 0;\n    }\n    if (b < 0) {\n        a += -b;\n        b = 0;\n    }\n    //a = min(max(0, a), n - 1);\n    //b = \n    return ivec2(a, b);\n}*/\n\nbool cutValid(int n1, int n2, int astart, int bstart, int to, int m2, int x, vec2 res, vec2 pres) {\n    int apos = m2 - 1;\n    bool aValid = apos >= 0 && apos < n1;\n    int bpos = to - m2 - 1;\n    bool bValid = bpos >= 0 && bpos < n2;\n    \n    mRet Amret = getM(astart + apos, res, pres);\n    mRet Bmret = getM(bstart + bpos, res, pres);\n    \n    int cv11 = Amret.Am;\n    int cv12 = Bmret.Am;\n    return (\n        aValid && bValid && apos >= 0 && bpos >= 0 ? max(cv11, cv12) <= x\n        : bValid && apos < 0 && bpos >= 0 ? cv12 <= x\n        : aValid && apos >= 0 && bpos < 0 ? cv11 <= x\n        : Amret.valid && Bmret.valid);\n}\n\nbool cutCValid(int n1, int n2, int astart, int bstart, int to, int bm2, int x, vec2 res, vec2 pres) {\n    int apos = to - bm2 - 1;\n    int bpos = bm2 - 1;\n    bool aValid = apos >= 0 && apos < n1;\n    bool bValid = bpos >= 0 && bpos < n2;\n    \n    mRet Amret = getM(astart + apos, res, pres);\n    mRet Bmret = getM(bstart + bpos, res, pres);\n\tint cvc11 = Amret.Am;\n    int cvc12 = Bmret.Am;\n    return (\n    \taValid && bValid && apos >= 0 && bpos >= 0 ? max(cvc11, cvc12) <= x\n        : bValid && apos < 0 && bpos >= 0 ? cvc12 <= x\n        : aValid && apos >= 0 && bpos < 0 ? cvc11 <= x\n        : Amret.valid && Bmret.valid);\n}\n\nmRet checkIndex(int n1, int n2, int astart, int bstart, int to, int apos, vec2 res, vec2 pres) {\n    bool aValid = apos >= 0 && apos < n1;\n    int bpos = to - apos;\n    bool bValid = bpos >= 0 && bpos < n2;\n    \n    mRet Amret = getM(astart + apos, res, pres);\n    mRet Bmret = getM(bstart + bpos, res, pres);\n    \n    int candA = Amret.Am;\n    bool candAv = cutValid(n1, n2, astart, bstart, to, apos, candA, res, pres) && aValid;\n    Amret.valid = Amret.valid && candAv;\n    \n    int candB = Bmret.Am;\n    bool candBv = cutCValid(n1, n2, astart, bstart, to, bpos, candB, res, pres) && bValid;\n    Bmret.valid = Bmret.valid && candBv;\n    \n    if (candAv && candBv) {\n        if (candA < candB) {\n            return Amret;\n        } else {\n            return Bmret;\n        }\n    } else if (candAv) {\n        return Amret;\n    }\n    return Bmret;\n}\n\nmRet binarySearchForMerge(\n    int targetOffset, int n1, int n2, vec2 pres, vec2 res,\n    in vec2 fragCoord, int astart, int bstart, inout vec2 digits) {\n    \n    int L1 = min(max(targetOffset + 1 - n1, 0), n1 - 1);\n    int R1 = min(targetOffset + 1, n1);\n    int L2 = min(max(targetOffset + 1 - n2, 0), n2 - 1);\n    int R2 = min(targetOffset + 1, n2);\n    \n    int OL1 = L1;\n    int OR2 = R2;\n    \n    int i = 0;\n    \n    mRet ret;\n    \n    float bx = -30.0;\n    float by = -15.0;\n    // Looking for m such that there are\n    // apos elements less than A[m] in A\n    // and bpos elements less than A[m] in B.\n    // For given m, how to count elements less than A[m] in A and B.\n    // For given m, decide whether there are more than targetOffset elements less than A[m] in A and B.\n    // For given m, is A[m] such an element that B[bpos] < A[m] and B[bpos + 1] \n\n    vec2 black = vec2(1.0, 0.0);\n    vec2 white = vec2(0.0);\n    \n    bool bValid = true;\n    \n    for (i = 0; i < maxBin && L1 < R1 && (L2 < R2 || !bValid); i++) {\n        int m = (L1 + R1) / 2 + (L1 + R1) % 2;\n        int bm = targetOffset - m;\n        int apos = m;\n        bool aValid = apos >= 0 && apos < n1;\n        int bpos = bm;\n        bValid = bpos >= 0 && bpos < n2;\n        \n        mRet Amret = getM(astart + apos, res, pres);\n        aValid = aValid && Amret.valid;\n        mRet Bmret = getM(bstart + bpos, res, pres);\n        bValid = bValid && Bmret.valid;\n        \n        float bline = -80.0;\n        bool showPos = true;\n        if (showPos) {\n        \tdigits += printBG(fragCoord + vec2(float(targetOffset) * bx, 1.0 * bline + float(i) * by), float(apos), 2, 0);\n        \tdigits += printBG(fragCoord + vec2(float(targetOffset) * bx, 2.0 * bline + float(i) * by), float(bpos), 2, 0);\n        }\n\n        int Am = Amret.Am;\n        int Bm = Bmret.Am;\n\n        digits += printBG(fragCoord + vec2(float(targetOffset) * bx, 3.0 * bline + float(i) * by), float(Am), 2, 0);\n        digits += printBG(fragCoord + vec2(float(targetOffset) * bx, 4.0 * bline + float(i) * by), float(Bm), 2, 0);\n       \n        {\n            float dx = 40.0;\n            int a = L1;\n            int b = R1;\n            int c = L2;\n            int d = R2;\n            \n            float sbx = 300.0;\n            float sbx2 = 550.0;\n            float sx = sbx + float(a) * dx;\n            float ex = sx + dx * float(b - a);\n            float sx2 = sbx2 + float(c) * dx;\n            float ex2 = sx2 + dx * float(d - c);\n            float hs = 20.0 + 55.0 * float(targetOffset);\n            float hy = 5.0;\n            \n            // left, a range\n            digits +=\n                fragCoord.x >= sx &&\n                fragCoord.x <= ex &&\n                fragCoord.y >= hs + hy * float(i * 2) &&\n                fragCoord.y <= hs + hy * float(i * 2 + 1)\n                    ? black\n                    : white;\n            // right, b range\n            digits +=\n                fragCoord.x >= sx2 &&\n                fragCoord.x <= ex2 &&\n                fragCoord.y >= hs + hy * float(i * 2) &&\n                fragCoord.y <= hs + hy * float(i * 2 + 1)\n                    ? black\n                    : white;\n           \t// whole lines for compare\n            digits +=\n                fragCoord.x >= sbx &&\n                fragCoord.x <= sbx + dx * 8.0 &&\n                fragCoord.y >= 6.0 &&\n                fragCoord.y <= 8.0\n                    ? black\n                    : white;\n            digits +=\n                fragCoord.x >= sbx2 &&\n                fragCoord.x <= sbx2 + dx * 8.0 &&\n                fragCoord.y >= 6.0 &&\n                fragCoord.y <= 8.0\n                    ? black\n                    : white;\n        }\n        \n        bool comparison = Am < Bm && aValid && bValid;\n        bool inUpperHalf = comparison;\n        \n        // m + 1 to R1\n        L1 = inUpperHalf ? m : L1;\n        // L1 to m\n        R1 = !inUpperHalf ? m - 1 : R1;\n        // bm + 1 to R2\n        L2 = !inUpperHalf ? bm : L2;\n        // L2 to bm\n        R2 = inUpperHalf ? bm : R2;\n    }\n    mRet error = mRet(-1, vec4(-1.0), false);\n    if (i >= maxBin - 1) {\n        ret = error;\n    } else {\n        int apos = L1;\n        int bpos = targetOffset - L1;\n        bValid = bpos >= 0 && bpos < n2;\n        \n        mRet AL1ret = getM(astart + apos, res, pres);\n        mRet BL1ret = getM(bstart + bpos, res, pres);\n        //return AL1ret;\n        \n        // XXX: AL1ret and BL1ret should be valid I hope\n        int m2 = AL1ret.Am < BL1ret.Am && bValid ? L1 + 1 : L1;\n        int bm2 = OR2 - (m2 - OL1);\n        bool bm2Valid = bm2 >= 0 && bm2 < n2;\n        bool bm2Min1Valid = bm2 - 1 >= 0 && bm2 - 1 < n2;\n        \n        int to = targetOffset;\n\n        mRet cand1 = checkIndex(n1, n2, astart, bstart, to, m2, res, pres);\n        mRet cand2 = checkIndex(n1, n2, astart, bstart, to, bm2, res, pres);\n        cand2.valid = cand2.valid && bm2Valid;\n        mRet cand3 = checkIndex(n1, n2, astart, bstart, to, m2 - 1, res, pres);\n        mRet cand4 = checkIndex(n1, n2, astart, bstart, to, bm2 - 1, res, pres);\n        cand4.valid = cand4.valid && bm2Min1Valid;\n\n        ret = cand1;\n        if (cand2.valid && (cand2.Am < ret.Am || !ret.valid)) {\n            ret = cand2;\n        }\n        if (cand3.valid && (cand3.Am < ret.Am || !ret.valid)) {\n            ret = cand3;\n        }\n        if (cand4.valid && (cand4.Am < ret.Am || !ret.valid)) {\n            ret = cand4;\n        }\n        mRet AnMin1 = getM(astart + n1 - 1, res, pres);\n        mRet BtoMinN = getM(bstart + to - n1, res, pres);\n        mRet BnMin1 = getM(bstart + n2 - 1, res, pres);\n        mRet AtoMinN = getM(astart + to - n2, res, pres);\n        if (targetOffset >= n1 && AnMin1.Am < BtoMinN.Am && BtoMinN.valid) {\n            ret = BtoMinN;\n        }\n        if (targetOffset >= n2 && BnMin1.Am < AtoMinN.Am && AtoMinN.valid) {\n            ret = AtoMinN;\n        }\n        //ret = cand4;\n        //ret.Am += 10 * int(ret.valid);\n    }\n    return ret;\n}\n\n// Returns -1 if not finished, +endFrame if finished\nint mergeColumns(out vec4 fragColor, in vec2 fragCoord, int frame) {\n    \n    vec2 res = iResolution.xy;\n    vec2 pres = getRes(res);\n    \n    const bool columns = false;\n    if (columns) {\n        int n = int(res.y);\n        int base = int(fragCoord.x) - int(fragCoord.x) % 2;\n        bool firstRow = int(fragCoord.x) % 2 == 0;\n        int col1 = base;\n        int col2 = base + 1;\n        int astart = toLinear(vec2(col1, 0), res);\n        int bstart = toLinear(vec2(col2, 0), res);  \n        int targetOffset = n * (firstRow ? 1 : 0) + int(fragCoord.y);\n        \n        /*\n        Find apos and bpos such that\n            targetOffset = apos + bpos\n        and\n            let m = min(a[apos, b[bpos])\n            for all k < apos, l < bpos, a[k] < m and b[l] < m\n        .\n        */\n        vec2 digits = vec2(0.0);\n        mRet a = binarySearchForMerge(targetOffset, n, n, pres, res, fragCoord, astart, bstart, digits);\n        if (a.Am < 0) {\n            fragColor.ba = vec2(1.0, 0.0);\n        } else {\n            fragColor = a.v;\n        }\n    } else {\n        \n        //res = vec2(256.0);\n        //pres = res;\n        \n        int index = toLinear(fragCoord, res);\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        //fragColor.a = 0.0;\n        int self = getM(index, res, pres).Am;\n        int next = getM(index + 1, res, pres).Am;\n        if (self > next) {\n            //fragColor.b = 1.0;\n        } else {\n            //fragColor.b = 0.0;\n        }\n        \n        //int maxPasses = int(ceil(log2(res.x * res.y)));\n        \n        int maxPasses = getMaxPasses(res);\n        int activeFrame = frame;\n        \n        bool noLoop = activeFrame >= maxPasses;\n        //noLoop = false;\n        \n        if (noLoop) {\n            return maxPasses;\n        }\n        int pass = activeFrame % maxPasses;\n        /*\n        int pass = activeFrame % (3 * maxPasses);\n        if (pass >= 2 * maxPasses) {\n        \tupdateParticle(fragColor, fragCoord);\n            return;\n        } else if (pass >= maxPasses) {\n            return;\n        }*/\n        int baseMod = 1 << pass;\n        //int n = 1 << pass;\n        int maxIndex = toLinear2(res - 1.0, res, 0);\n        int n = (1 << pass);\n        if (2 * n >= maxIndex) {\n            return -1;\n        }\n        \n        int base = index - index % (2 * n);\n        bool firstHalf = int(fragCoord.x) % (2 * n) == 0;\n        int astart = base;\n        int bstart = base + n;\n        int targetOffset = index - base;\n        int n1 = n;\n        int n2 = n;\n        if (2 * n > index || base + 2 * n > maxIndex) {\n        \t//n1 -= base + n - maxIndex;\n            //return;\n        }\n        if (base + 2 * n > maxIndex) {\n        \t//n2 -= base + 2 * n - maxIndex;\n        }\n        \n        if (fragCoord.x <= res.x && fragCoord.y <= res.y) {\n            vec2 digits = vec2(0.0);\n            // TODO: doesn't work for n1 != n2\n            mRet a = binarySearchForMerge(targetOffset, n1, n2, pres, res, fragCoord, astart, bstart, digits);\n            if (a.Am < 0 || !a.valid) {\n                //fragColor.b = 1.0;\n            } else {\n                fragColor = a.v;\n            }\n        } else {\n            fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        }\n    }\n\t\n    if (debug) {\n        vec2 digits = vec2(0.0);\n        float bx = -30.0;\n        float by = -15.0;\n        int n = debugLen / 2;\n        int astart = 0;\n        int bstart = n;\n        for (int i = 0; i < debugLen; i++) {\n            int targetOffset = i;\n            mRet a = binarySearchForMerge(targetOffset, n, n, pres, res, fragCoord, astart, bstart, digits);\n            int val = a.Am;\n            if (val < 0) {\n                val = 99;\n            }\n            digits += printBG(fragCoord + vec2(float(i) * bx, by), float(val), 2, 0);\n        }\n        fragColor.ba += digits;\n        return -1;\n    }\n    return -1;\n}\n\n// https://www.shadertoy.com/view/XlcGD8\n// https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter46.html\n// https://stackoverflow.com/questions/26093629/glsl-odd-even-merge-sort\n// https://bl.ocks.org/zz85/cafa1b8b3098b5a40e918487422d47f6\nvoid oddEvenMergeSort(out vec4 fragColor, in vec2 fragCoord) {\n    // stage 0 has pass = 0\n    // stage 1 has pass = 1, pass = 0\n    // stage 2 has pass = 2, pass = 1, pass = 0\n    // ...\n    vec2 res = iResolution.xy;\n    \n    //res = vec2(256.0);\n    vec2 res2 = getRes(res);\n    vec4 self = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    self.ba *= 0.0;\n    int mode = 0;\n    int maxIndex = toLinear2(res - 1.0, res, mode);\n    int fieldSize = int(res.x); //toLinear(res, res);\n    int logFieldsize = int(ceil(log2(float(fieldSize))));\n    int totalSteps = ((logFieldsize + logFieldsize) * (logFieldsize + logFieldsize + 1)) / 2;\n    int frame = iFrame;\n    \n    /*\n    if (frame >= totalSteps) {\n        frame -= totalSteps;\n        mode = 1;\n    }*/\n    \n    //frame = int(iTime) / 1;\n    //float b3 = print(fragCoord, float(totalSteps) / 60.0, 10, 2);\n    //self.b += b3;\n    {\n        vec2 fc = fragCoord;\n        int i = toLinear2(fc, res, mode);\n        int j = i + 1;\n        ivec2 fc2 = fromLinear2(j, res, mode);\n        //fc2 = ivec2(fc + vec2(hash(uvec2(fc)), -1.0));\n        fc2 = ivec2(fc + vec2(0.0, -1.0));\n        //fc2 = ivec2(fc + vec2(1.0, 0.0));\n        vec4 self2 = texelFetch(iChannel0, fc2, 0);\n    \t//self.b = float(length(self2.xy) < length(self.xy));\n        if (!(fragCoord.x >= res.x || fragCoord.y >= res.y)) {\n        \tself.b = float(compareTwo(i, j, self, self2, 1, res2));\n        }\n    }\n    if (frame >= totalSteps) {\n        fragColor = self;\n        return;\n    }\n    \n    int pass = -1;\n    int stage = -1;\n    int loopI = 0;\n    for (loopI = 0; loopI < frame + 1; loopI++) {\n        pass--;\n        if (pass < 0) {\n            stage++;\n            pass = stage;\n        }\n    }\n    \n    float byd = 15.0;\n    float by = -75.0;\n    float bx = -740.0;\n    vec2 digits = vec2(0.0);\n    digits += printBG(fragCoord + vec2(bx, by), float(pass), 5, 0);\n    by += byd;\n    digits += printBG(fragCoord + vec2(bx, by), float(stage), 5, 0);\n    by += byd;\n    digits += printBG(fragCoord + vec2(bx, by), float(loopI), 5, 0);\n    by += byd;\n    digits += printBG(fragCoord + vec2(bx, by), float(totalSteps), 5, 0);\n    by += byd;\n    digits += printBG(fragCoord + vec2(bx, by), float(logFieldsize), 5, 0);\n    self.ba += digits;\n    \n    if (fragCoord.x >= res.x || fragCoord.y >= res.y) {\n        fragColor = vec4(0.0);\n        fragColor = self;\n        return;\n    }\n    \n    int ppass = 1 << pass;\n    int pstage = 1 << stage;\n\n    int TwoStage = 2 * pstage;\n    int Pass_mod_Stage = ppass % pstage;\n    int TwoStage_PmS_1 = TwoStage - Pass_mod_Stage - 1;\n    int Pass = ppass;\n\n    int i = toLinear2(fragCoord, res, mode);\n    ivec4 ret = ivec4(getPartner(i, fragCoord, res, TwoStage, Pass_mod_Stage, TwoStage_PmS_1, Pass, maxIndex, mode));\n    int adr = ret.x;\n    ivec2 fc2 = ret.yz;\n    int compare = ret.w;\n    \n    if (adr < 0 || fc2.x >= int(res.x) || fc2.y >= int(res.y)) {\n        fragColor = self;\n        return;\n    }\n    \n    // double check that partner will mirror us\n    /*\n    ivec4 ret2 = ivec4(getPartner(toLinear(fc2, res), vec2(fc2), res, TwoStage, Pass_mod_Stage, TwoStage_PmS_1, Pass, maxIndex));\n    if (ret2.x < 0 || ret2.yz != ivec2(fragCoord) || ret2.w != -compare) {\n        fragColor = self;\n        return;\n    }*/\n    \n    vec4 partner = texelFetch(iChannel0, fc2, 0);\n\n    // on the left it's a < operation; on the right it's a >= operation\n    //fragColor = (self.x * compare < partner.x * compare) ? self : partner;\n    fragColor = compareTwo(i, adr, self, partner, compare, res2) ? self : partner;\n    //fragColor = (length(self.xy) * float(compare) < length(partner.xy) * float(compare)) ? self : partner;\n}\n\nvoid bitonicMergeSort(out vec4 fragColor, in vec2 fragCoord) {\n\tint index = toLinear2(fragCoord, iResolution.xy, 0);\n    int maxIndex = toLinear2(iResolution.xy - 1.0, iResolution.xy, 0);\n    // forget last particles for now\n    maxIndex -= maxIndex % (count * 2);\n    if (index >= maxIndex) {\n        return;\n    }\n    //index = (index + iFrame) % maxIndex;\n    \n    //partner = index ^ (iFrame % 20); //int(hash(uvec2(iFrame, iFrame) * uint(maxIndex)));\n    //vec4 a = texelFetch(iChannel0, fromLinear(index, iResolution.xy), 0);\n    vec2 res = getRes(iResolution.xy);\n    \n    bool success = true;\n        /*iFrame % 2 == 0\n        \t? (index - index % count + count) <= maxIndex\n    \t\t: (index - index % count + count * count <= maxIndex;*/\n    int target = index % count;\n    //int pass = iFrame % (7 + 3 + 1);\n    int pass = iFrame % (2 + 3 + 1);\n    pass = iFrame <= 2 + 3 + 1 ? pass : 0;\n    bool sortBucketHorizontal = pass == 1;\n    bool mergeBucketsHorizontal = pass >= 2 && pass <= 2 + 3;\n    bool sortBucketVertical = pass == 6;\n    bool mergeBucketsVertical = pass >= 7 && pass <= 7 + 3;\n    int bucketSize = \n        mergeBucketsHorizontal\n        \t? count * int(exp2(float(pass - 2)))\n    \t\t: count * int(exp2(float(pass - 7)));\n    int bucket = index / count;\n    int level = count;\n    //for (int i = 0; i < pass; i++) {\n    //bucket = (bucket + pass) % 2 == 0 ? bucket + 1 : bucket - 1;\n    //}\n    //int bucketOffset = index - bucket * level;\n    vec4 original = vec4(0.0);\n    for (int i = 0; i < count; i++) {\n        //int s = target < count / 2 ? 1 : -1;\n        int partner = \n            sortBucketHorizontal\n            \t? index - target + i\n            \t: index - int(iResolution.x) * (((index / int(iResolution.x)) % count) - i);\n        /*\n        partner =\n            pass > 0\n            \t?\n            \t\t(bucket + i) * level + bucketOffset\n                    //index -\n                    //index % int(pow(float(count), float(pass + 1))) + \n                    //int(pow(float(count), float(pass))) * i\n           \t\t: partner;\n        */    \t\n      \tsuccess = success && partner >= 0 && partner <= maxIndex;\n        ivec2 fc = fromLinear2(partner, iResolution.xy, 0);\n        vec4 a = texelFetch(iChannel0, fc, 0);\n        original = index == partner ? a : original;\n        A[i] = toIndex(a.xy, res);\n        B[i] = a;\n    }\n    sort();\n    \n    //bool unordered = sign((Bi - Ai) * (partner - index)) < 0;\n    if (sortBucketHorizontal || sortBucketVertical) {\n    \tfragColor = success ? B[target] : original;\n    } else if (mergeBucketsHorizontal || mergeBucketsVertical) {\n        int offset = \n            mergeBucketsHorizontal\n            \t? index - index % count\n            \t: index - int(iResolution.x) * ((index / int(iResolution.x)) % count);\n       \tint stride = mergeBucketsHorizontal ? 1 : int(iResolution.x);\n        int aptr = offset ;\n        int partner = (index / count) % 2 == 0 ? aptr + stride * count : aptr - stride * count;\n        int bptr = partner;\n        if (aptr + count > maxIndex || bptr + count > maxIndex) {\n            fragColor = original;\n            //fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n            return;\n        }\n        for (int i = 0; i < 2 * bucketSize; i++) {\n            vec4 a = texelFetch(iChannel0, fromLinear2(aptr, iResolution.xy, 0), 0);\n            vec4 b = texelFetch(iChannel0, fromLinear2(bptr, iResolution.xy, 0), 0);\n            int ai = toIndex(a.xy, res);\n            int bi = toIndex(b.xy, res);\n            bool cmp = compareTwo(aptr, bptr, a, b, 1, res);\n            bool chooseA = \n                ai <= bi &&\n                aptr - offset + stride < bucketSize * stride &&\n            \t!(bptr - offset + stride < bucketSize * stride);\n            //sign((bi - ai) * (bptr - aptr)) < 0;\n            //chooseA = hash(uvec2(fragCoord)) < 0.5;\n            aptr += chooseA ? stride : 0;\n            bptr += chooseA ? 0 : stride;\n            bool onTarget = \n                mergeBucketsHorizontal\n                \t? index % (2 * bucketSize) == i\n                \t: index / int(iResolution.x) % (2 * bucketSize) == i;\n            fragColor =\n                onTarget\n                \t? (chooseA ? a : b)\n                    : fragColor;\n        }\n        /*\n        vec4 a = texelFetch(iChannel0, fromLinear(index, iResolution.xy), 0);\n        int partner = (index + pass) % 2 == 0 ? index + 1 : index - 1;\n        vec4 b = texelFetch(iChannel0, fromLinear(partner, iResolution.xy), 0);\n        int ai = toIndex(a.xy, res);\n        int bi = toIndex(b.xy, res);\n        bool unordered = sign((bi - ai) * (partner - index)) < 0;\n        fragColor = unordered ? b : a;\n\t\t*/\n    } else {\n        fragColor = original;\n    }\n    vec4 self = original;\n    vec4 self2 = texelFetch(iChannel0, fromLinear2(index + 1, iResolution.xy, 0), 0);\n    fragColor.b = float(compareTwo(index, index + 1, self, self2, 1, res));\n}\n\nvoid bubbleSort(out vec4 fragColor, in vec2 fragCoord, int frame) {\n    vec2 res = iResolution.xy;\n    vec2 pres = getRes(res);\n    int n = toLinear2(res - 1.0, res, 0);\n    int k = frame;\n    int index = toLinear2(fragCoord, res, 0);\n    // Examples:\n    \n    // k % 2 == 0 && index % 2 == 0 => dir == 1\n    // k % 2 == 0 && index % 2 == 1 => dir == -1\n    // k % 2 == 1 && index % 2 == 0 => dir == -1\n    // k % 2 == 1 && index % 2 == 1 => dir == 1\n    \n    // k == 0 && index == 0 => index + dir == 0 + 1 = 1\n    // k == 0 && index == 1 => index + dir == 1 - 1 = 0\n    // k == 0 && index == 2 => index + dir == 2 + 1 = 3\n    // k == 0 && index == 3 => index + dir == 3 - 1 = 2\n    // k == 0 && index == 4 => index + dir == 4 + 1 = 5\n    // k == 0 && index == 5 => index + dir == 5 - 1 = 4\n    \n    // k == 1 && index == 0 => index + dir == 0 - 1 = -1\n    // k == 1 && index == 1 => index + dir == 1 + 1 = 2\n    // k == 1 && index == 2 => index + dir == 2 - 1 = 1\n    // k == 1 && index == 3 => index + dir == 3 + 1 = 4\n    // k == 1 && index == 4 => index + dir == 4 - 1 = 3\n    // k == 1 && index == 5 => index + dir == 5 + 1 = 6\n    int dir = index % 2 == k % 2 ? 1 : -1;\n    mRet aRet = getM(index, res, pres);\n    mRet bRet = getM(index + dir, res, pres);\n    mRet aRet2 = getMD(int(aRet.v.z), res, pres);\n    mRet bRet2 = getMD(int(bRet.v.z), res, pres);\n    \n    // update\n    /*\n    aRet.v = updateParticle(aRet.v);\n    bRet.v = updateParticle(bRet.v);\n    aRet.Am = toIndex(aRet.v.xy * pres, pres);\n    bRet.Am = toIndex(bRet.v.xy * pres, pres);\n\t*/\n    \n    if (index + dir < 0 || index + dir >= n || !isLinearValid(index + dir, res)) {\n        fragColor = aRet.v;\n    } else {\n        if (aRet2.Am * dir < bRet2.Am * dir) {\n            fragColor = aRet.v;\n        } else {\n            fragColor = bRet.v;\n        }\n    }\n}\n\nint runPasses(out vec4 fragColor, in vec2 fragCoord, int startFrame) {\n    int frame = iFrame - startFrame;\n    int maxPasses = getMaxPasses(iResolution.xy);\n    //bool sortedB = texelFetch(iChannel0, ivec2(0), 0).b >= 0.0;\n    int bframe = max(0, frame - maxPasses - 5);\n    if (frame < maxPasses || (bframe + 1) % (3 * maxPasses) == 0) {\n        //fragColor = updateParticle(fragColor);\n        //mergeColumns(fragColor, fragCoord, frame);\n        fragColor = texelFetch(iChannel2, ivec2(fragCoord), 0);\n        // predict future at time when sort is done\n        for (int i = 0; i < maxPasses; i++) {\n            fragColor = updateParticle(fragColor);\n        }\n        fragColor = updateParticle(fragColor);\n        \n        fragColor.z = float(toLinear2(fragCoord, iResolution.xy, 0));\n        return -1;\n    }\n    bframe = bframe % (3 * maxPasses);\n    \n    int ret = mergeColumns(fragColor, fragCoord, bframe);\n    if (!isValid(fragCoord, iResolution.xy)) {\n        fragColor = vec4(1.0);\n        return ret;\n    }\n    if (ret < 0) return ret;\n    \n    bubbleSort(fragColor, fragCoord, int(bframe));\n    \n    /*\n    if (bframe == maxPasses) {\n        // catch up\n        for (int i = 0; i < maxPasses - 1; i++) {\n            fragColor = updateParticle(fragColor);\n        }\n    }*/\n    //if (frame % 2 > 0) {\n    //} else {\n    //fragColor = updateParticle(fragColor);\n    //}\n    return 2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // https://www.shadertoy.com/view/MsVBWd\n    float startFrame = texelFetch(iChannel0, ivec2(0), 0).a;\n    if (iFrame == 0 || startFrame < 1.0) {\n        fragColor = vec4(0.0);\n        if (iChannelResolution[1].x > 0.0) {\n            fragColor = texture(iChannel1, fragCoord / iResolution.xy);\n        \t//fragColor.ba = vec2(0.0);\n        \tfragColor.xy = (fragColor.xy - 0.5) * 4.0 + 0.5;\n            fragColor.xy = clamp(fragColor.xy, 0.0, 1.0);\n            fragColor.zw = fragColor.xy + (fragColor.zw - 0.5) * 1.0 / iResolution.xy;\n            fragColor.zw = clamp(fragColor.zw, 0.0, 1.0);\n            if (fragCoord.x <= 1.0 && fragCoord.y <= 1.0) {\n            \tfragColor.a = 1.0 + float(iFrame);\n            }\n        }\n        return;\n    }\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    //oddEvenMergeSort(fragColor, fragCoord);\n    int ret = runPasses(fragColor, fragCoord, int(startFrame));\n    \n    //fragColor.ba += printBG(fragCoord + vec2(-100.0, 0.0), float(startFrame), 5, 0);\n    \n    if (fragCoord.x < 1.0 && fragCoord.y < 1.0) {\n        fragColor.a = startFrame;\n        fragColor.b = float(ret);\n    }\n}\n\n\n\n\n// Old Buffer A test\n/*\n// https://www.shadertoy.com/view/4dd3Wj\n\nfloat xor(float x, float c) { \n    float y=0., s=1.;\n    \n    for (int i = 0; i < 32; i++) {\n       if (x < s && c < s) break;\n       y += s * mod(floor(x/s) + floor(c/s), 2.0);\n       s *= 2.0;\n    }\n    \n    return y;\n    //return intBitsToFloat(floatBitsToInt(x) ^ floatBitsToInt(c));\n}\n\nfloat id(vec2 U, vec2 res) {\n    //return floor(U.x) + res.x * floor(U.y);\n    return float(toLinear(U, res));\n}\n\nvoid swapSort(out vec4 O, vec2 U) {\n    //if (iResolution.y < R) R /= 2.; // for icon resolution\n    vec2 R = iResolution.xy;\n    vec2 res = getRes(iResolution.xy);\n    //R = res;\n\n    float t = float(iFrame);\n    if (iFrame < 0) {\n        //int index = int((U.x + U.y * iResolution.x) / (iResolution.x * iResolution.y) * (res.x * res.y));\n        int index = int(float(toLinear(U, iResolution.xy)) / (iResolution.x * iResolution.y) * (res.x * res.y));\n        vec2 fc = vec2(fromIndex(index, res)) / vec2(res);\n    \tO = vec4(fc, 0.0, 1.0);\n        return;\n    }\n    if (iFrame == 0) {\n    \t//O = texture(iChannel1, U/R);\n        O = vec4(U / iResolution.xy, 0.0, 0.0);\n        return;\n    }\n    //if (mod(t,512.)==10. ) { O = texture(iChannel1, U/R).rrrr; return; }\n    //if (mod(t,512.)==266.) { O = texture(iChannel2, U/R); return; }\n    \n    \n    O =  texture(iChannel0, U/iResolution.xy);\n    \n    //if ( max(U.x,U.y) < R )   // sort array RxR\n    { \n        vec2 U = U / iResolution.xy * res;\n        vec2 S = vec2(xor(U.x,mod(t*1.73+103.7,R.x)),                     // dual location\n                      xor(U.y,mod(t*11.4+51.8 ,R.y)) ) +.5;\n        //if (ceil(S.x) >= res.x || ceil(S.y) >= res.y) {\n        //    return;\n        //}\n        //S = mod(S, iResolution.xy);\n        vec4 OS = texture(iChannel0, S / R.xy);               // its pixel value\n        float l1 = float(toIndex(O.xy * res, res));\n        float l2 = float(toIndex(OS.xy * res, res));\n        //l1 = length(O.xy);\n        //l2 = length(OS.xy);\n    \tif (sign((l2 - l1)*(id(S, iResolution.xy)-id(U, iResolution.xy))) < 0.) O = OS;   // swap if bad ordered\n    }\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n\t\n}\n*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "struct mRet {\n    int Am;\n    vec4 v;\n};\n\nmRet getM(int m, vec2 res, vec2 pres) {\n    vec2 fc = vec2(fromLinear(m, res));\n    vec4 v = texelFetch(iChannel0, ivec2(fc), 0);\n    int Am = toIndex(v.xy * pres, pres);\n    return mRet(Am, v);\n}\n\n\nvoid bubbleSort(out vec4 fragColor, in vec2 fragCoord, int frame) {\n    vec2 res = iResolution.xy;\n    vec2 pres = getRes(res);\n    int n = toLinear(res - 1.0, res);\n    int k = frame;\n    int index = toLinear(fragCoord, res);\n    // Examples:\n    \n    // k % 2 == 0 && index % 2 == 0 => dir == 1\n    // k % 2 == 0 && index % 2 == 1 => dir == -1\n    // k % 2 == 1 && index % 2 == 0 => dir == -1\n    // k % 2 == 1 && index % 2 == 1 => dir == 1\n    \n    // k == 0 && index == 0 => index + dir == 0 + 1 = 1\n    // k == 0 && index == 1 => index + dir == 1 - 1 = 0\n    // k == 0 && index == 2 => index + dir == 2 + 1 = 3\n    // k == 0 && index == 3 => index + dir == 3 - 1 = 2\n    // k == 0 && index == 4 => index + dir == 4 + 1 = 5\n    // k == 0 && index == 5 => index + dir == 5 - 1 = 4\n    \n    // k == 1 && index == 0 => index + dir == 0 - 1 = -1\n    // k == 1 && index == 1 => index + dir == 1 + 1 = 2\n    // k == 1 && index == 2 => index + dir == 2 - 1 = 1\n    // k == 1 && index == 3 => index + dir == 3 + 1 = 4\n    // k == 1 && index == 4 => index + dir == 4 - 1 = 3\n    // k == 1 && index == 5 => index + dir == 5 + 1 = 6\n    int dir = index % 2 == k % 2 ? 1 : -1;\n    mRet aRet = getM(index, res, pres);\n    mRet bRet = getM(index + dir, res, pres);\n    \n    // update\n    /*\n    aRet.v = updateParticle(aRet.v);\n    bRet.v = updateParticle(bRet.v);\n    aRet.Am = toIndex(aRet.v.xy * pres, pres);\n    bRet.Am = toIndex(bRet.v.xy * pres, pres);\n\t*/\n    \n    if (index + dir < 0 || index + dir >= n || !isLinearValid(index + dir, iResolution.xy)) {\n        fragColor = aRet.v;\n    } else {\n        if (aRet.Am * dir < bRet.Am * dir) {\n            fragColor = aRet.v;\n        } else {\n            fragColor = bRet.v;\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // https://www.shadertoy.com/view/MsVBWd\n    float startFrame = texelFetch(iChannel0, ivec2(0), 0).a;\n    if (iFrame == 0 || startFrame < 1.0) {\n        fragColor = vec4(0.0);\n        if (iChannelResolution[2].x > 0.0) {\n            fragColor = texture(iChannel2, fragCoord / iResolution.xy);\n        \t//fragColor.ba = vec2(0.0);\n        \tfragColor.xy = (fragColor.xy - 0.5) * 4.0 + 0.5;\n            fragColor.xy = clamp(fragColor.xy, 0.0, 1.0);\n            fragColor.zw = fragColor.xy + 10.0 * (fragColor.zw - 0.5) / iResolution.xy;\n            fragColor.zw = clamp(fragColor.zw, 0.0, 1.0);\n            if (fragCoord.x <= 1.0 && fragCoord.y <= 1.0) {\n            \tfragColor.a = 1.0 + float(iFrame);\n            }\n        }\n        return;\n    }\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    //bubbleSort(fragColor, fragCoord, iFrame);\n    \n    fragColor = updateParticle(fragColor);\n    \n    /*\n    bool sorted1 = texelFetch(iChannel1, ivec2(0), 0).b > 1.0;\n    int mp = getMaxPasses(iResolution.xy);\n    int frame = iFrame - int(startFrame);\n    if (sorted1 && isValid(fragCoord, iResolution.xy) && frame % (3 * mp) == mp) {\n        int index = int(texelFetch(iChannel1, ivec2(fragCoord), 0).z);\n       \tfragColor = texelFetch(iChannel0, ivec2(fromLinear(index, iResolution.xy)), 0);\n    }*/\n    \n    if (fragCoord.x < 1.0 && fragCoord.y < 1.0) {\n        fragColor.a = startFrame;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}