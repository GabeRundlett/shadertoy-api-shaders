{
    "Shader": {
        "info": {
            "date": "1587635252",
            "description": "Second step towards building a renderer for https://youtu.be/BtYKDamqo2I?t=334\nMouse click/drag to adjust depth-of-field blur.\n\nStep one: https://www.shadertoy.com/view/td2cDy\nStep three: https://www.shadertoy.com/view/wdXfzN#",
            "flags": 0,
            "hasliked": 0,
            "id": "tsjyWV",
            "likes": 1,
            "name": "Single Layer Blurred Glitter",
            "published": 3,
            "tags": [
                "dof",
                "glitter"
            ],
            "usePreview": 0,
            "username": "qwert33",
            "viewed": 342
        },
        "renderpass": [
            {
                "code": "\nconst vec3 default_debug = vec3(-100, -20, -10);\nconst vec3 orange = vec3(1., .5, 0.);\nconst vec3 cornflowerblue = vec3(100./255., 149./255., 237./255.);\nvec3 debug = default_debug;\n\nfloat blurRadius;\n\n\n#define TAU 6.28318530718\n#define PI TAU/2.\n// Dave Hoskins hash\nfloat hash13(in vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse(vec2 p, in vec2 ab) {\n    if (abs(ab.x-ab.y) < .00001) return length(p) - ab.x;  // haaax due to numerical stability issues.\n\n\tp = abs(p); \n    if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if (d<0.0) {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    } else {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx) + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = ab * vec2(co,si);\n\t\n    return length(r-p) * sign(p.y-r.y);\n}\nfloat sdEllipsoidApproximated( in vec2 p, in vec2 r ) {\n    float k0 = length(p/r);\n \treturn length(p/r) - 1.;\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n\n// How many cells around the central_cell we check for ellipses.\n#define SAMPLE_RADIUS 2\n\nfloat monochrome(vec2 uv) {\n    \n    const float cell_wd = 5.5;\n    vec2 central_cell_center = floor((uv+.5*cell_wd) / cell_wd) * cell_wd;\n    \n\tfloat hashTime = iTime + 100.;  // Don't want thing to be synchonous when the shader starts    \n    \n    int j;\n    float acc = 0.;\n    for (int i = -SAMPLE_RADIUS; i<=SAMPLE_RADIUS; ++i) {\n        for (j = -SAMPLE_RADIUS; j<=SAMPLE_RADIUS; ++j) {\n            vec2 cell_center = central_cell_center + cell_wd*vec2(ivec2(i,j));\n            \n            vec2 cell_hash_pos = cell_center + vec2(1030., 0);\n            float yaw = TAU * hash13(vec3(cell_hash_pos, 2.));\n            float angular_speed = 3. + hash13(vec3(cell_hash_pos, 3.));\n            vec2 angular_vel = angular_speed * vec2(cos(yaw), sin(yaw));\n            float pitch = length(angular_vel) * hashTime * 0.1;\n            vec2 a = normalize(angular_vel);  // axis of rotation - major axis of projected ellipse.\n            vec2 b = vec2(-a.y, a.x) * cos(pitch);  // minor axis\n            vec2 ab = vec2(length(a), length(b));\n            mat2 rot = mat2(a.x, a.y,\n                            -a.y, a.x);\n\n            vec3 normal = vec3(0.0, sin(pitch), cos(pitch));\n            mat3 rot3 = mat3(a.x, a.y, 0.,\n                             -a.y, a.x, 0.,\n                             0., 0., 1.);\n            normal = transpose(rot3) * normal;\n            const vec3 LIGHT_DIR = normalize(vec3(1.5, -1.0, 2.0));\n            float light_per_area = \n                .2 + // ambient\n                50.0 * smoothstep(.98, .99, abs(dot(normal, LIGHT_DIR)));  // cheap (wrong-ish) specular\n            float total_light = light_per_area * ab.x * ab.y;  // total amount of light emitted by this object towards all pixels.\n\n            // Have a random offset from the cell_center.\n            vec2 ellipse_center = cell_center + (.5*cell_wd - ab.x) * vec2(\n            \tsin(hashTime * (.01 + .06*hash13(vec3(cell_hash_pos, 4.)))),\n                cos(hashTime * (.01 + .06*hash13(vec3(cell_hash_pos, 4.))))\n            );\n\t\t\tvec2 ellipse_uv = uv - ellipse_center;   \n            \n            vec2 extended_ab = ab + vec2(blurRadius);\n            //float sd = sdEllipse(transpose(rot)*inner_uv, extended_ab);\n            //float sd = sdEllipsoidApproximated(transpose(rot)*inner_uv, extended_ab);\n            float sd = length(transpose(rot)*ellipse_uv / extended_ab) - 1.;  // Signed distance approximation only accurate for values near zero.\n            float proportional_area = extended_ab.x * extended_ab.y;\n            float edge_blurryness = 0.1/length(extended_ab);\n            float is_in_ellipse = smoothstep(edge_blurryness, -edge_blurryness, sd);\n            acc += is_in_ellipse * (total_light / proportional_area);\n\n            // Debug major/minor axes.\n            //if (abs(dot(uv-ellipse_center, normalize(b))) <.01 && length(uv-ellipse_center) < 1.) acc += .9;\n            //if (abs(dot(uv-ellipse_center, normalize(a))) <.01 && length(uv-ellipse_center) < length(b))  acc += .9;\n\n            acc += 1.-smoothstep(0., .1, abs(length(uv) - blurRadius));\n        }\n    }\n\treturn acc;\n}\n\nvec2 project(vec2 pixel) {\n    vec2 uv = pixel/iResolution.xy - vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv *50.;\n}\n\n\n// antialiasing\nfloat sampleSubpixel(vec2 pixels) {\n\tconst int size = 0; \n    const float numContrb = float(size+1)*float(size+1);\n\tfloat disp = 1.0 / (float(size) + 2.0);\n\tfloat contrb = 0.0;\n\tfor (int j = -size; j <= size; j++) {\n\t\tfor (int i = -size; i <= size; i++) {\n\t\t\tcontrb += monochrome(project(\n                pixels + vec2(float(i) * (disp / 3.0), float(j) * disp)\n            ));\n\t\t}\n\t}\n\treturn contrb / numContrb;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    blurRadius = (iMouse.xy == vec2(0.))? .6 : max(0., length(project(iMouse.xy))-.5);\n    vec3 light = vec3(.1,.2,.9) * sampleSubpixel(fragCoord);\n    light = 1. - exp(-2. * light); // Simulate exposure\n    fragColor = vec4(light, 1.0);\n    if (debug != default_debug) fragColor.rgb = debug;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}