{
    "Shader": {
        "info": {
            "date": "1609434435",
            "description": "Procedural texture sketchbook used for my [url=https://twitter.com/andrei_drexler/status/1334224218565857288]Quake 3 demake[/url].\nUncomment individual textures in the Image tab to view them.\nNote: exclamation mark = WIP/placeholder.",
            "flags": 48,
            "hasliked": 0,
            "id": "WdGGWh",
            "likes": 27,
            "name": "Q321 Texture Sketchbook",
            "published": 3,
            "tags": [
                "procedural",
                "textures",
                "quake",
                "arena"
            ],
            "usePreview": 0,
            "username": "adx",
            "viewed": 850
        },
        "renderpass": [
            {
                "code": "/***************************************************************\nQ321 Texture Sketchbook / Andrei Drexler 2020\nhttps://github.com/andrei-drexler/q321\n\nUncomment one of the textures below (exclamation mark = WIP/placeholder)\n\nControls:\n  arrows, mouse drag  = pan\n  +-, Ctrl+mouse drag = zoom\n  Alt+mouse drag      = scrub time\n  /                   = reset zoom & pan\n  M                   = cycle RGB/alpha mode (checker/checker+alpha test/RGB/alpha/black matte)\n  T                   = toggle tiling\n  C                   = toggle center/left-aligned\n\nPoor-man's 'Go to definition': double-click to select word, Ctrl+F (search), Enter\nCtrl+G = next match, Shift+Ctrl+G = previous match\n***************************************************************/\n\n//#define SHOW_TEXTURE\t\tgcntr2trn,      256, 256 // gothic_floor/center2trn (texture)\n//#define SHOW_TEXTURE\t\tgcntr2trn_m,    256, 256 // gothic_floor/center2trn (map shader)\n//#define SHOW_TEXTURE\t\tglrgbk3b,       512, 512 // gothic_floor/largerblock3b\n//#define SHOW_TEXTURE\t\tglrgbk3bbld,    256, 256 // gothic_block/largerblock3blood (texture)\n//#define SHOW_TEXTURE\t\tglrgbk3bbld_m,  256, 256 // gothic_block/largerblock3blood (map shader)\n//#define SHOW_TEXTURE\t\tglrgbk3bow,\t    256, 256 // gothic_floor/largerblock3b_ow (texture)\n//#define SHOW_TEXTURE\t\tglrgbk3bow_m,   256, 256 // gothic_floor/largerblock3b_ow (map shader)\n//#define SHOW_TEXTURE\t\tgblks15,        256, 256 // ! gothic_block/blocks15\n//#define SHOW_TEXTURE\t\tgblks18c,       256, 256 // gothic_block/blocks18c\n//#define SHOW_TEXTURE\t\tgklblki,        256, 256 // gothic_block/killblock_i\n//#define SHOW_TEXTURE\t\tgklblki4,       256, 256 // ! gothic_block/killblock_i4\n//#define SHOW_TEXTURE\t\tgkblkgmtrn,     256, 256 // ! gothic_block/killblockgeomtrn\n//#define SHOW_TEXTURE\t\tgdmnblk15fx,    256, 256 // ! gothic_block/demon_block15fx\n//#define SHOW_TEXTURE\t\tgtbsbrd09e,     256, 128 // gothic_trim/baseboard09_e\n//#define SHOW_TEXTURE\t\tgtbsbrd09c3,    256, 128 // gothic_trim/baseboard09_c3\n//#define SHOW_TEXTURE\t\tgtbsbrd09o3,    256, 128 // ! gothic_trim/baseboard09_o3\n//#define SHOW_TEXTURE\t\tscmpblk17,      256, 256 // sfx/computer_blocks17 (texture)\n//#define SHOW_TEXTURE\t\tscmpblk17_m,    256, 256 // sfx/computer_blocks17 (map shader)\n//#define SHOW_TEXTURE\t\tgspbdrbb,        64, 256 // gothic_wall/supportborder_blue_b\n//#define SHOW_TEXTURE\t\tgmtlsp4b,       256, 256 // gothic_trim/metalsupport4b\n//#define SHOW_TEXTURE\t\tgwdclg1a,       256, 256 // gothic_ceiling/woodceiling1a\n//#define SHOW_TEXTURE\t\tgwdclg1bd,      256, 256 // gothic_ceiling/woodceiling1b_dark\n//#define SHOW_TEXTURE\t\tgiron01e,       256, 256 // gothic_wall/iron01_e\n//#define SHOW_TEXTURE\t\tgiron01nt3,     128, 256 // ! gothic_wall/iron01_ntech3\n//#define SHOW_TEXTURE\t\tgskull4,        256, 256 // gothic_wall/skull4\n//#define SHOW_TEXTURE\t\tskcpthrt,       256, 256 // skin/chapthroat\n//#define SHOW_TEXTURE\t\tskcpthrt2,      256, 256 // skin/chapthroat2\n//#define SHOW_TEXTURE\t\tskcpthrtooz,    256, 256 // skin/chapthroatooz\n//#define SHOW_TEXTURE\t\tsktongue,\t\t256, 256 // skin/tongue_trans\n//#define SHOW_TEXTURE\t\tcmet52,         256, 256 // base_wall/c_met5_2\n//#define SHOW_TEXTURE\t\tcmet72,         256, 256 // base_wall/c_met7_2\n//#define SHOW_TEXTURE\t\tsteed1gf,       128,  64 // base_wall/steed1gf\n//#define SHOW_TEXTURE\t\tdmnd2c,         256, 256 // base_floor/diamond2c\n//#define SHOW_TEXTURE\t\tdmnd2cjp,       256, 256 // ! sfx/diamond2cjumppad (texture)\n//#define SHOW_TEXTURE\t\tdmnd2cjp_m,     256, 256 // sfx/diamond2cjumppad (map shader)\n//#define SHOW_TEXTURE\t\tdmnd2cow,       256, 256 // base_floor/diamond2c_ow (texture)\n//#define SHOW_TEXTURE\t\tdmnd2cow_m,     256, 256 // base_floor/diamond2c_ow (map shader)\n//#define SHOW_TEXTURE\t\tdmnd2pnt,       256, 256 // ! sfx/pentfloor_diamond2c (texture)\n//#define SHOW_TEXTURE\t\tdmnd2pnt_m,     256, 256 // ! sfx/pentfloor_diamond2c (map shader)\n//#define SHOW_TEXTURE\t\tlpdmnd,         256, 256 // ! sfx/launchpad_diamond (texture)\n//#define SHOW_TEXTURE\t\tlpdmnd_m,       256, 256 // sfx/launchpad_diamond (map shader)\n//#define SHOW_TEXTURE\t\tbglogo,         512, 512 // sfx/logo512\n//#define SHOW_TEXTURE\t\tmenubnr,        256,  64 // main menu banner (texture)\n//#define SHOW_TEXTURE\t\tmenubnr_m,      256, 256 // main menu banner (menu shader)\n//#define SHOW_TEXTURE\t\tq3bnr,          256,  64 // base_wall/main_q3abanner\n//#define SHOW_TEXTURE\t\tbrdr11b,         64,  32 // base_trim/border11b\n//#define SHOW_TEXTURE\t\tcable,          128, 128 // base_support/cable\n//#define SHOW_TEXTURE\t\tgpntgmlt1k,      64,  64 // gothic_light/pentagram_light1_1k\n//#define SHOW_TEXTURE\t\tlt2,             64,  64 // base_light/lt2_2000\n//#define SHOW_TEXTURE\t\tlight5,          16, 128 // base_light/light5_5k\n//#define SHOW_TEXTURE\t\tblt414k,         64, 256 // ! base_light/baslt4_1_4k\n//#define SHOW_TEXTURE\t\tbmtsprt,        256, 128 // base_trim/basemetalsupport\n//#define SHOW_TEXTURE\t\tgmtlspsld,      256, 256 // gothic_trim/metalsupsolid\n//#define SHOW_TEXTURE\t\tmtlfb3,         256, 256 // ! base_wall/metfloor_block_3\n//#define SHOW_TEXTURE\t\tmtlfw10,        256, 256 // ! base_wall/metalfloor_wall_10\n//#define SHOW_TEXTURE\t\tmtlfw15,        256, 256 // ! base_wall/metalfloor_wall_15\n//#define SHOW_TEXTURE\t\tmtlfw15ow,      256, 256 // ! base_wall/metalfloor_wall_15ow (texture)\n//#define SHOW_TEXTURE\t\tmtlbk03,        256, 256 // base_wall/metalblack03\n//#define SHOW_TEXTURE\t\tmtlt6f,         256, 256 // ! base_wall/metaltech06final\n//#define SHOW_TEXTURE\t\tmtlt12f,        256, 256 // ! base_wall/metaltech12final\n//#define SHOW_TEXTURE\t\tgmtlbg6,        256, 256 // gothic_floor/metalbridge06\n//#define SHOW_TEXTURE\t\tgmtlbg6brk,     256, 256 // gothic_floor/metalbridge06broke\n//#define SHOW_TEXTURE\t\tgxstrtop4,      256,  32 // gothic_floor/xstairtop4\n//#define SHOW_TEXTURE\t\tgxstrtop4bbrn,  256,  32 // gothic_floor/xstairtop4bbrn\n//#define SHOW_TEXTURE\t\tgxstpbrdr3brn,  256,  16 // gothic_floor/xstepborder3brn\n//#define SHOW_TEXTURE\t\tgsltrfc,        256, 256 // ! gothic_wall/slateroofc\n//#define SHOW_TEXTURE\t\tgblks17f2,      256, 256 // gothic_floor/blocks17floor2\n//#define SHOW_TEXTURE\t\tgkarnarcfnl,    256, 576 // ! gothic_door/km_arena1archfinal* (composite)\n//#define SHOW_TEXTURE\t\tgkarnarcfnltp,  256,  64 // ! gothic_door/km_arena1archfinalc_top\n//#define SHOW_TEXTURE\t\tgkarnarcfnlmd,  256, 256 // ! gothic_door/km_arena1archfinald_mid\n//#define SHOW_TEXTURE\t\tgkarnarcfnlbt,  256, 256 // ! gothic_door/km_arena1archfinald_bot\n//#define SHOW_TEXTURE\t\tgkarnclma2r,     64, 512 // ! gothic_door/km_arena1columna2R\n//#define SHOW_TEXTURE\t\tflame,          128, 256 // sfx/flame2\n//#define SHOW_TEXTURE\t\ttimhel,         256, 256 // skies/tim_hell\n//#define SHOW_TEXTURE\t\tlava,           256, 256 // liquids/lavahellflat_400\n//#define SHOW_TEXTURE\t\tbwprtbnr,       128, 256 // base_wall/protobanner\n//#define SHOW_TEXTURE\t\tgsklvtg02b,     256, 256 // gothic_trim/skullsvertgray02b\n//#define SHOW_TEXTURE\t\tgskdr,          384, 384 // ! gothic_door/skull_door_* (composite)\n//#define SHOW_TEXTURE\t\tgskdr_a,         64, 256 // ! gothic_door/skull_door_a (bottom right)\n//#define SHOW_TEXTURE\t\tgskdr_b,        256, 256 // ! gothic_door/skull_door_b (bottom mid)\n//#define SHOW_TEXTURE\t\tgskdr_c,         64, 256 // ! gothic_door/skull_door_c (bottom left)\n//#define SHOW_TEXTURE\t\tgskdr_d,         64, 128 // ! gothic_door/skull_door_d (top right)\n//#define SHOW_TEXTURE\t\tgskdr_e,        256, 128 // ! gothic_door/skull_door_e (top mid)\n//#define SHOW_TEXTURE\t\tgskdr_f,         64, 128 // ! gothic_door/skull_door_f (top left)\n//#define SHOW_TEXTURE\t\tlion,\t        256, 256 // ? models/mapobjects/wallhead/lion.tga\n//#define SHOW_TEXTURE\t\tgr8torch2b,\t     32,  64 // models/mapobjects/gratelamp/gratetorch2b.tga\n//#define SHOW_TEXTURE\t\tflare03,        256, 256 // models/mapobjects/lamps/flare03\n//#define SHOW_TEXTURE\t\tbotflare,       256, 256 // models/mapobjects/lamps/bot_flare\n//#define SHOW_TEXTURE\t\ttlpnrg,          64, 128 // models/mapobjects/teleporter/energy.tga\n//#define SHOW_TEXTURE\t\ttlptrns,        256, 256 // models/mapobjects/teleporter/transparency.tga\n//#define SHOW_TEXTURE\t\tbotwing,        128,  64 // ! models/mapobjects/lamps/bot_wing.tga (texture)\n//#define SHOW_TEXTURE\t\tbotlamp,        256, 256 // ? models/mapobjects/lamps/bot_lamp.tga (texture)\n//#define SHOW_TEXTURE\t\trocketl,        256, 256 // \n//#define SHOW_TEXTURE\t\tplasma_glo,     256, 256 // models/weapons2/plasma/plasma_glo.tga\n//#define SHOW_TEXTURE\t\tarmornrg,       256, 256 // models/powerups/armor/energy_red1.tga\n//#define SHOW_TEXTURE\t\tbotflare2,       32, 128 // models/mapobjects/lamps/bot_flare2.tga\n//#define SHOW_TEXTURE\t\ticon_health,     64,  64 // icons/iconh_yellow.tga\n//#define SHOW_TEXTURE\t\ticon_shard,      64,  64 // icons/iconr_shard.tga\n//#define SHOW_TEXTURE\t\ticon_armor,      64,  64 // icons/iconr_yellow.tga\n//#define SHOW_TEXTURE\t\ticon_machinegun, 64,  64 // icons/iconw_machinegun.tga\n//#define SHOW_TEXTURE\t\ticon_shotgun,    64,  64 // icons/iconw_shotgun.tga\n//#define SHOW_TEXTURE\t\ticon_rocketl,    64,  64 // icons/iconw_rocket.tga\n//#define SHOW_TEXTURE\t\ticon_plasma,     64,  64 // icons/iconw_plasma.tga\n//#define SHOW_TEXTURE\t\ticon_railgun,    64,  64 // icons/iconw_railgun.tga\n//#define SHOW_TEXTURE\t\ticon_quad,       64,  64 // icons/quad.tga\n//#define SHOW_TEXTURE\t\tcrosshaira,\t\t 64,  64 // gfx/2d/crosshaira\n//#define SHOW_TEXTURE\t\tcrosshairb,\t\t 64,  64 // gfx/2d/crosshairb\n//#define SHOW_TEXTURE\t\tcrosshairc,\t\t 64,  64 // gfx/2d/crosshairc\n//#define SHOW_TEXTURE\t\tuiframe,        256, 256 // menu/art/addbotframe.tga\n//#define SHOW_TEXTURE\t\tmapselect,      256, 256 // menu/art/maps_select.tga\n//#define SHOW_TEXTURE\t\tslider2,        256,  32 // menu/art/slider2.tga\n//#define SHOW_TEXTURE\t\tsliderbutt1,     32,  64 // menu/art/sliderbutt_1.tga\n\n////////////////////////////////////////////////////////////////\n/***************************************************************\n\nMany thanks to:\n\n- id Software for the original Quake III artwork\n\n- Beautypi for Shadertoy\n\n- Inigo Quilez for articles and code covering noise, signed distance fields, and more\n  https://iquilezles.org/\n\n- @Dave_Hoskins for the \"Hash without Sine\" functions\n  https://www.shadertoy.com/view/4djSRW\n\n- @Shane for the 'Asymmetric Blocks' function\n  https://www.shadertoy.com/view/Ws3GRs\n\n- Dr Martin Roberts for the R-sequence\n  http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n\n***************************************************************/\n////////////////////////////////////////////////////////////////\n\n#ifndef SHOW_TEXTURE\n#define SHOW_TEXTURE\t\tslideshow, 256, 256\n#endif\n\n#define INITIAL_UV_SCALE\t1./1.\n#define INITIAL_UV_OFFSET\tvec2(0, 0)\n\n////////////////////////////////////////////////////////////////\n\n#undef TEX\n#undef TEXA\n#undef T0\n\nvec4 Time;\nvec4 FCol = vec4(0);\nvec2 UV;\n\nvec3 Light() \t\t\t{ return vec3(1); }\n\n#define TEX(name)\t\tvec3 name(vec2 uv); void name() { FCol = vec4(name(fract(UV)), 1); } vec3 name(vec2 uv)\n#define TEXA(name)\t\tvec4 name(vec2 uv); void name() { FCol = name(fract(UV)); } vec4 name(vec2 uv)\n\n#define NO_COPY_PASTE\t// use as a reminder\n\n////////////////////////////////////////////////////////////////\n\n// base_wall/c_met5_2\nTEX(cmet52) {\n    float\n        b = FBMT(uv, vec2(7), .9, 3., 4),\n        n = FBMT(uv, vec2(9), .9, 3., 4),\n        t = .7 + .6 * b\n    ;\n    return mix(RGB(77, 75, 73), RGB(77, 66, 55), ls(.4, .6, n)) * t;\n}\n\n// base_wall/c_met7_2\nTEX(cmet72) {\n    vec3 c = NO_COPY_PASTE cmet52(uv) NO_COPY_PASTE; // base texture\n\tuv.x = abs(uv.x - .515); // slightly off-center horizontal mirroring\n\tuv.y = abs(uv.y - .5); // vertical mirroring\n\tuv.y = abs(uv.y - .25); // vertical mirroring (again)\n\tfloat d = box(uv - vec2(0, .23), vec2(.5, .21)); // box SDF\n\tc *= 1.\n\t\t+ .3 * tri(.0, .01, -d) // edge highlight\n\t\t- .3 * ls(.0, .01, d) // darker part (grout?)\n\t;\n\treturn c;\n}\n\n// base_wall/steed1gf\nTEX(steed1gf) {\n    float\n        b = FBMT(uv -= .5, vec2(7, 3), .9, 3., 4),\n        n = FBMT(uv, vec2(5, 3), .7, 2., 4),\n        t = .85 + .3 * b,\n        d, m\n    ;\n\n    vec3 c = mix(RGB(88, 90, 72), RGB(60, 64, 50), length(uv) * 2.5 - .5) * t; // base color\n    uv.y *= .5; // correct aspect ratio\n    \n    d = box(uv, vec2(.5, .25)) + .01; // box SDF\n    c = mix(c, RGB(133, 144, 144) * t, tri(.0, .01, d) * n); // edge highlight\n    c *= 1.\n        - .5 * ls(.0, .01, d) // edge shadow\n    ;\n\n\tvec2 p = abs(uv) - vec2(.41, .16); // bolt position (mirrored x & y)\n\tm = ls(.035, .02, d = length(p *= sign(uv - .1))) * (.8 + .8 * b * b); // change p sign based on quadrant and generate bolt mask\n\tc *= 1.\n\t\t- .2 * sqr(tri(.04, .02, d)) // bolt shadow\n\t\t+ 3. * m * ls(-.01, .01, p.y) * ls(.02, -.01, p.x) // very bright top-left reflection\n\t\t+ .3 * m * ls(-.01, .01, -p.y) * ls(-.01, .02, p.x) // bright bottom-right reflection\n\t\t- .9 * m * ls(-.01, .01, p.y) * ls(-.01, .02, p.x) // dark top-right reflection\n\t\t- .3 * m * ls(-.01, .01, -p.y) * ls(.02, -.01, p.x) // dark bottom-left reflection\n\t;\n\n    return c;\n}\n\n// base_floor/diamond2c\nTEX(dmnd2c) {\n    float b = FBMT(uv, vec2(7), .9, 3., 4);\n    uv.x *= -1.5;\n    uv.y += uv.x * .5;\n    uv.x = 1. - uv.x + uv.y;\n    uv = fract(uv * 28.);\n    float f = sat(1. - length(.1 - uv));\n    f *= ls(.6, .2, length(.6 - uv));\n    f *= ls(.6, .8, length(.1 - uv));\n    f *= ls(.2, .6, b) * 2. + 1.;\n    float l = 1. - ls(.2, b + 2., mx(abs(uv - .5)));\n    return vec3((f + 1.) * mix(.21, .29, b * b) * l);\n}\n\n// p = offset from center\n// s = scale\n// k = number of spokes\n// n = noise\nfloat dmnd2cow_spokes(vec2 p, float s, float k, float n) {\n    return\n        ridged(fract(nang(p) * k + n))\n        * ls(.5, .3, length(p) / s + n - .5)\n    ;\n}\n\n// base_floor/diamond2c_ow (texture)\nTEXA(dmnd2cow) {\n\tvec3 c = NO_COPY_PASTE dmnd2c(uv) NO_COPY_PASTE; // base texture\n    float\n        b = FBMT(uv = wavy(uv, 7., .01), vec2(5), .7, 3., 4), // base FBM + slight UV distortion\n        n = FBMT(uv, vec2(7), .5, 2., 4), // smoother FBM\n        r = length(uv -= .5), // distance to center\n        a = nang(uv), // normalized angle\n        d = r + n * .8 - .33, // distorted distance\n        m = ls(.1, .15, d) // floor mask\n\t;\n    c = mix(c, mix(RGB(21, 17, 14), RGB(70, 59, 51), b), ls(.5, .3, r + b*b*b)); // base impact color\n    c *= 1.\n        - .7 * ls(.13, .1, d) // inner shadow\n        + 1.5 * pow(tri(.3, .15, .05, d), 4.) // edge highlight\n        + m * dmnd2cow_spokes(uv - vec2(-.05, .05), .44, 22., n) // top radial marks\n        + m * dmnd2cow_spokes(uv - vec2(.07, -.18), .3, 15., n) // bottom radial marks\n        ;\n\treturn vec4(c, 1. - sqrt(ls(.11, .05, d))); // color + alpha (including shadow)\n}\n\n// base_floor/diamond2c_ow (map shader)\nvoid dmnd2cow_m() {\n    vec4 c = NO_COPY_PASTE dmnd2cow(fract(UV)) NO_COPY_PASTE;\n    float b = FBMT(UV * .5 + Time.x * vec2(9, 5), vec2(7), .6, 2., 4);\n    b *= 1. + .5 * tri(.5, .05, b);\n    FCol = vec4(mix(RGB(66, 111, 155) * (.8 + 2. * b * b), c.xyz * Light(), c.w), 1);\n}\n\nvec2 knob(vec2 uv, float s) {\n    return vec2(1. - length(uv) / s, msk(length(uv) - s));\n}\n\nvec3 add_knob_gizmo(vec3 c, vec2 uv, float b) {\n    vec2 v = knob(uv, .02);\n    float d = length(uv);\n    c = mix(c, RGB(222, 155, 144) * (b * .4 + .3), tri(.03, .01, d)); // knob exterior bevel highlight\n    //c *= 1. - .5 * tri(.04, .03, .0, d) * clamp(u.y / .02, -1., 1.);\n    c *= 1. - .5 * tri(.02, .01, d); // sunken knob exterior\n    c = mix(c, RGB(111, 66, 44) * (v.x * 1.5 + .2), v.y); // knob interior\n    return c;\n}\n\n// infinite pie slice\n// a = normalized angle\n// s = angular extent\nfloat slice(float a, float s) {\n    return abs(fract(a - .5) - .5) - s;\n}\n\n// Basic clamp piece\n// c = background color\n// p = polar coordinates\n// u.x = angular position\n// u.y = angular extent\n// v.x = radial position\n// v.y = radial extent\n// k = clamp color\nvec3 dmnd2cjp_clamp(vec3 c, vec2 p, vec2 u, vec2 v, vec3 k) {\n    p.x = slice(p.x - u.x, u.y);\n    p.y = abs(p.y - v.x) - v.y;\n    c *= 1. - .4 * tri(.0, .004, p.x) * ls(.01, .0, p.y); // side shadow\n    c = mix(c, k, ls(.0, -.002, p.x) * ls(.01, .0, p.y)); // mix clamp color\n    c *= 1. + .3 * tri(-.003, .002, p.x) * ls(.0, -.01, p.y); // side highlights\n    return c;\n}\n\n// Two-piece metallic clamp\nvec3 dmnd2cjp_clamp(vec3 c, vec2 p, float v, vec3 k) {\n    c = dmnd2cjp_clamp(c, p, vec2(v, .015), vec2(.36, .04), k * (.3 + .5 * sqr(ls(.38, .33, p.y)) - .7 * ls(.33, .3, p.y)));\n    c = dmnd2cjp_clamp(c, p, vec2(v, .025), vec2(.43, .02), k * (.3 + .5 * sqr(tri(.43, .025, p.y))));\n    return c;\n}\n\n// c = background color\n// k = light color\n// l = light mask accum\n// p.x = normalized angle\n// p.y = radius\n// u.x = angular position\n// u.y = angular extent\nvec3 dmnd2cjp_led(vec3 c, vec3 k, inout float l, vec2 p, vec2 u, vec2 v) {\n\tp.x = 4. * max(0., slice(p.x - u.x, u.y)); // clamp & scale angle\n\tp.y -= v.x; // shift radius\n\tfloat d = circ(p, v.y); // SDF\n\tl += pow(ls(.1, -.01, d), 4.); // add glow\n\tc = mix(c, c * k, msk(d, .01)); // interior color\n\tc *= 1.\n\t\t- .3 * tri(.0, .01, d) // edge shadow\n\t\t+ .3 * tri(.01, .01, d) // edge highlight\n\t;\n\treturn c;\n}\n\n// sfx/diamond2cjumppad (texture)\nTEXA(dmnd2cjp) {\n\tvec3 c = NO_COPY_PASTE dmnd2c(uv) NO_COPY_PASTE;\n\n\tfloat\n\t\tb = FBMT(uv, vec2(7), .9, 3., 4), // base FBM\n\t\tt = .8 + .8 * b * b, // base texture intensity (remapped FBM)\n\t\ta = nang(uv - .5), // normalized angle\n\t\tr = length(uv - .5), // distance from center\n\t\tm = ls(.46, .45, r), // initial mask\n\t\tl = tri(.43, .01, r) * ls(.07, .0, abs(a - .11) - .03), // initial light mask\n\t\tg = greebles(uv * 3., b, .3).x,\n\t\td;\n\tvec2 p = vec2(a, r);\n\n\t// interior surface\n\tc = mix(c, RGB(199, 199, 166. + 33. * b) * (.1 + .1 * b + g), m); // base color\n\n\t// central knob\n\tc = add_knob_gizmo(c, uv - .5, b);\n\n\t// outer metal ring\n\tm *= ls(.31, .33, r);\n\tc = mix(c, RGB(144, 122, 99) * t, m) // base color\n\t\t+ .44 * tri(.335, .01, r) // small bevel highlight\n\t;\n\tc *= 1.\n\t\t+ .5 * tri(.43, .013, r) // large bevel highlight\n\t\t- .6 * tri(.41, .03, r) // large bevel shadow\n\t\t- .4 * tri(.35, .015, r) // small bevel shadow\n\t\t- sqr(tri(.315, .03, r)) // inner shadow\n\t\t- sqr(tri(.46, .03, r)) // outer shadow\n\t;\n\n\t// ring wires\n\tc = wire_ring(c, uv, .38, .02);\n\n\t// metal clamps\n\tvec3 k = vec3(.9, .9, .8) * t; // base color\n\tc = dmnd2cjp_clamp(c, p, .63, k); // bottom-left\n\tc = dmnd2cjp_clamp(c, p, .37, k); // top-left\n\tc = dmnd2cjp_clamp(c, p, vec2(.0, .1), vec2(.38, .03), k * (.25 + .6 * ls(.4, .33, p.y))); // right\n\tc = dmnd2cjp_clamp(c, p, vec2(.11, .06), vec2(.38, .03), k * (.3 + .5 * ls(.4, .33, p.y))); // top-right\n\tc = dmnd2cjp_clamp(c, p, vec2(.91, .05), vec2(.373, .035), k * (.5 + .4 * ls(.37, .36, p.y) - .7 * ls(.33, .3, p.y))); // bottom-right\n\tc = dmnd2cjp_clamp(c, p, vec2(.948, .003), vec2(.37, .04), k * (.5 + .4 * ls(.36, .35, p.y) - .7 * ls(.33, .3, p.y))); // above b-r\n\tc = dmnd2cjp_clamp(c, p, vec2(.965, .007), vec2(.37, .04), k * (.5 + .4 * ls(.36, .35, p.y) - .7 * ls(.33, .3, p.y))); // above \n\tc = dmnd2cjp_clamp(c, p, vec2(.02, .005), vec2(.36, .015), k * (.5 + .4 * ls(.36, .35, p.y) - .7 * ls(.33, .3, p.y))); // tiny right\n\n\t// lights\n\tk = vec3(1.5, .5, .5) * (g * 4. + .2);\n\tc = dmnd2cjp_led(c, k, l, p, vec2(.125, .02), vec2(.383, .017)); // large top-right\n\tc = dmnd2cjp_led(c, k, l, p, vec2(.075, .001), vec2(.383, .017)); // small top-right\n\tc = dmnd2cjp_led(c, k, l, p, vec2(.02, .001), vec2(.37, .0)); // tiny right\n\tc = dmnd2cjp_led(c, k, l, p, vec2(.63, .007), vec2(.44, .007)); // small bottom-left\n\n\t// inner ring glow (with offsets for the left clamps)\n\tl += tri(.32, .01, r + msk(min(slice(a - .63, .011), slice(a - .37, .011)), .005) * .005);\n\n\t// subtle floor reflection (lower-left)\n\tl += ls(.2, .8, c.x) * tri(.5, .6, .8, r) * sqr(tri(.63, .06, a));\n\n\treturn vec4(c, l);\n}\n\n// sfx/diamond2cjumppad (map shader)\nvoid dmnd2cjp_m() {\n\tvec4 c = NO_COPY_PASTE dmnd2cjp(fract(UV)) NO_COPY_PASTE;\n    vec2 uv = fract(UV) - .5;\n    float\n        r = length(uv),\n        v = fract(Time.x * 1.5),\n        s = mix(.4, 8., v),\n        b = NT(uv/s, vec2(255)),\n        t = .8 + .2 * b\n    ;\n\tFCol = vec4(\n        c.xyz * Light()\n        + RGB(240, 130, 5) * (tri(.1, .05, r / s) * ls(.34, .3, r) * t + .5 * c.w * ridged(v))\n    , 1);\n}\n\n// sfx/pentfloor_diamond2c (texture)\nTEXA(dmnd2pnt) {\n\tvec3 c = dmnd2cjp(uv).xyz;\n\tuv = fract(uv) - .5;\n\tfloat b = FBMT(uv, vec2(3), .9, 3., 4), d = min(abs(length(uv) - .4), pentagram(uv, .35));\n\treturn vec4(c, msk(d - .02 + b * .02, .01));\n}\n\n// sfx/pentfloor_diamond2c (map shader)\nTEXA(dmnd2pnt_m) {\n\tvec4 c = dmnd2pnt(uv);\n    c.xyz += RGB(111, 55, 0) * c.w * (sin(Time.x * PI) * .5 + .5);\n    return c;\n}\n\n// sfx/launchpad_diamond (texture)\nTEXA(lpdmnd) {\n    vec3 c = NO_COPY_PASTE dmnd2c(uv) NO_COPY_PASTE; // base texture\n    float\n        b = FBMT(uv, vec2(5), .9, 3., 4), // base FBM\n        t, o, k, r, h, d;\n    vec2 u;\n    u.x = abs(uv.x - .5);\n    u.y = uv.y;\n\n    // large middle panel underneath\n    c = mix(c, vec3(.2 + .3 * b * b), r = msk(k = box(u - vec2(0, .5), vec2(.33 - uv.y * .1, .15)) - .05, .004)); // base color\n    c *= 1.\n        - .5 * tri(.0, .01, k) // outer edge shadow\n        + .2 * tri(-.01, .01, k) // outer edge highlight\n\t;\n\n    // bottom attachment\n    c = mix(c, vec3(.22 + .22 * b * b), r = msk(k = box(u, vec2(.2)), .004)); // base color\n    c *= 1.\n        + .3 * tri(.0, .01, k) // outer edge highlight\n        + .5 * sqr(tri(.05, .03, uv.y)) * r // crease highlight\n\t;\n\n    // bottom slots\n    u = mirr(u, .11);\n    c *= 1.\n        - .3 * msk(k = box(u - vec2(.07, -.03), vec2(0, .05)) - .015, .004) // darken interior\n        - .3 * tri(.0, .007, k) // darken edges\n\t;\n\n    u.x = abs(uv.x - .5);\n    u.y = min(uv.y, .4);\n    r = length(u - vec2(0, .4)) - (.18 - .06 * ls(.4, 1., uv.y));\n    k = .25\n        - .15 * ls(.9, .96, uv.y)\n        + .03 * sqr(ls(.82, .86, uv.y))\n        + .07 * ls(.8, .2, uv.y)\n        + .07 * sqr(ls(.35, .22, uv.y))\n        - .07 * ls(.22, .0, uv.y)\n\t;\n    o = box(uv - vec2(.5, .5), vec2(k, .46));\n    o = max(o, -box(u, vec2(.15, .03)) + .06);\n    c = mix(c, vec3(.6, .55, .55) - uv.y * .3 + b * .2, msk(o, .004)); // base metal color\n    c *= 1. - .7 * tri(.0, .013, o); // black outer edge\n    c *= 1. - (r / .5 - .1) * msk(o, .004); // darken metal away from center\n    t = max(r, uv.y - .96);\n    o = abs(t - .02) - .03;\n    o = max(o, uv.y - 1. + u.x * .5);\n    o = max(o, uv.y - .96);\n    c = mix(c, vec3(1, 1, .9) - uv.y * .55, tri(-.01, .01, o)); // lane edge highlight\n    c = mix(c, mix(vec3(.2 * b + .1), .07 + greebles(uv * 3., b, .2), .6), msk(t, .01)); // inner lane color\n\n    // lane traces\n    k = .2 - .05 * ls(.8, .5, uv.y) - .15 * ls(.5, .3, uv.y);\n    d = msk(t, .004);\n    r = box(vec2(u.x, uv.y) - vec2(.25, .6), vec2(k, .2));\n    r = min(r, box(uv - vec2(.5, .21), vec2(.02, .05)) - .09);\n    c *= 1.\n        + .3 * d * tri(.01, .01, r) // light interior line\n        - .3 * d * tri(.0, .01, r) // dark interior line\n\t;\n    c *= 1. - .2 * tri(.0, .05, t) * msk(o, .004); // inner lane shadow\n\n    // central knob\n    c = add_knob_gizmo(c, u = uv - vec2(.5, .37), b);\n    \n    // metal clamps\n    d = length(u);\n    u.x = abs(uv.x - .5);\n    u.y = uv.y - .3;\n    u = u.x > .06 ? u * rot(50.) - vec2(.08, -.11) : u + vec2(0, .07);\n    h = sat(u.y / .09 + .5); // vertical clamp coordinate, normalized [0..1]\n    r = box(u, vec2(.04 - .02 * h, .04)) - .01;\n    c = mix(c, vec3(.6, .55, .55) * (1. + .4 * b - .5 * h), msk(r, .007) * ls(.21, .18, d)); // base clamp color\n    c *= 1. - .5 * h * tri(.02, .008, .0, r); // clamp shadow\n\n/*\n    d = length(u = uv - vec2(.5, .4)) - .25;\n    k = box((uv - vec2(.5, -.0)) * rot(45.), vec2(.22));\n    k = smax(-d, k, .05);\n    c *= 1. - .5 * msk(k, .01);\n*/\n\n    return vec4(c, msk(t - .025, .03));\n}\n\n// sfx/launchpad_diamond (map shader)\nTEX(lpdmnd_m) {\n    float b = FBMT(uv, vec2(7), .9, 3., 4);\n\tvec4 c = lpdmnd(uv);\n    uv.x = abs(.5 - uv.x);\n    float\n        t = fract(-Time.x),\n        r = length(uv - vec2(0, .4)),\n    \tl = t * pow(max(0., 1. - r), 4.) * c.w;\n   \tif (t > .75)\n    \tl += ls(.03, .01, abs(fract(uv.y + uv.x * .5 + t * 2.) - .45)) * ls(.1, .08, uv.x);\n    c.xyz += RGB(180, 150, 5) * l;\n    return c.xyz;\n}\n\n// base_wall/metfloor_block_3\nTEX(mtlfb3) {\n    float b = FBMT(uv, vec2(5), .9, 3., 4);\n    vec3 pt = pattern(uv, 8., .31);\n    vec3 c = mix(RGB(66, 58, 55), RGB(118, 107, 105), b);\n    float l = 1. - .5 * ls(.034, .036, pt.x);\n    l = mix(l, 1.4, tri(.033, .004, pt.x));\n\treturn c * l;\n}\n\n// base_support/cable\nTEX(cable) {\n    float\n        b = FBMT(uv, vec2(5), .9, 3., 4),\n        h = fract(uv.y * 10.);\n    vec3 c = mix(RGB(53, 48, 42), RGB(38, 38, 36), b) * (.6 + b * .8);\n    c *= 1.\n        + .5 * sqr(tri(.25, .25, h))\n        + .5 * sqr(tri(.65, .35, h))\n        - .6 * sqr(tri(.5, .5, h))\n\t;\n\treturn c;\n}\n\n// base_trim/border11b\nTEX(brdr11b) {\n\tfloat b = FBMT(uv, vec2(5, 3), .9, 3., 4);\n\tvec3 c = mix(RGB(74, 66, 55), RGB(99, 90, 78), b*b);\n\tuv.x *= 2.;\n\tvec2 p = seg(uv, vec2(.5, .625), vec2(1.5, .625));\n\tfloat\n\t\td = length(p - uv),\n\t\tm = ls(.22, .20, d),\n\t\tl = 1.\n\t\t- .15 * m\n\t\t- .5 * ls(.7, .9, uv.y) * m\n\t\t- .3 * (grad(d).y - .5) * tri(.2, .03, d)\n\t\t- .3 * sqr(tri(.17, .03, d))\n\t\t- .5 * ls(.05, 0., uv.y)\n\t\t- .3 * tri(.33, .05, uv.y)\n\t\t+ .7 * ls(.93, 1., uv.y)\n\t\t+ .7 * tri(.31, .04, uv.y)\n\t\t;\n\treturn c * l;\n}\n\n// base_wall/metalblack03\nTEX(mtlbk03) {\n\tfloat\n\t\tb = FBMT(uv, vec2(5), .9, 3., 4),\n\t\td, l;\n\tuv = wavy(uv, 13., .007);\n\tEVAL_TOP_LIGHT(\n\t\tuv, .004, d, l,\n\t\tsqr(ls(.3 + b * .2, .9, FBMT(p, vec2(23), .5, 2., 4)))\n\t);\n\treturn vec3(.18 * (.7 + b * b) * (1. - .05 * l * d));\n}\n\n// gothic_wall/iron01_e\nTEX(giron01e) {\n\tfloat b = FBMT(uv, vec2(5), .9, 3., 4);\n\tvec3\n        c = mix(RGB(77, 55, 53), RGB(62, 48, 48), NT(uv, vec2(128, 13))) * (.7 + b * b),\n        g;\n\tuv = wavy(uv, 13., .007);\n\tEVAL_GRAD(\n\t\tg, uv,\n\t\tsqr(ls(.4 + b * .4, .95, NT(p[i], vec2(63, 43))))\n\t);\n    c *= ls(1.3, .9, g.z);\n\treturn vec3(c * (1. + g.y * g.z));\n}\n\nfloat fender(vec2 uv, vec2 s) {\n    uv.y = max(uv.y, 0.);\n    return elips(uv, s);\n}\n\nvec3 add_techpipe(vec3 c, vec3 b, vec2 uv, float h, float s) {\n    float\n        y = (uv.y - h) / s,\n        p = 1. - y * y;\n    c *= 1. - tri(-1., 1., y);\n    if (p > 0.)\n        c = b * (p * (.8 + .2 * tri(.5, .25, fract(uv.x / s)))) *\n        \t(.7 + sqr(tri(.2, .7, y)));\n    return c;\n}\n\nvec3 add_all_techpipes(vec3 c, vec2 uv, float b) {\n    vec2 p = uv, q = p;\n    \n    c *= 1.\n        - .5 * tri(.2, .01, uv.y) // shadow above top silver pipe\n        - .9 * tri(.155, .007, uv.y) // shadow above top copper pipe\n    ;\n\n    q.y += tri(.1, .01, mod(q.x, .33)) / 2e2;\n    c = add_techpipe(c, 2. * b * RGB(93, 84, 79), uv, .185, .015); // silver\n    c = add_techpipe(c, 2. * b * RGB(138, 77, 48), uv, .13, .025); // copper (top)\n    c = add_techpipe(c, 2. * b * RGB(112, 71, 51), uv, .09, .015); // copper (mid)\n    c = add_techpipe(c, 2. * b * RGB(138, 77, 48), q, .05, .015); // copper (bottom)\n\n    // rectangular gizmos on top of cables\n    p.x = abs(fract(uv.x * 6. - .5) - .5) / 6.;\n    c *= 1.+ .5 * ls(.04, .03, p.x) * tri(.18, .03, p.y);\n    float r = box1(p - vec2(0, .12), vec2(.03, .01));\n    r = exclude(r, box1(p - vec2(0, .11), vec2(.01)));\n    c *= 1. - sqr(tri(.0, .04, r));\n    c = mix(c, RGB(166, 99, 77) * 2. * b * (.75 + .5 * sqr(tri(.125, .01, uv.y))), msk(r, .004));\n\n    // transformer coils?\n    q = p;\n    q.y -= .07;\n    r = circ(q, .03);\n    c *= 1. - sqr(tri(.0, .07, r)); // outer shadow\n    c = mix(c, RGB(127, 83, 72) * b * 2. * ls(.01, -.005, r), ls(.005, .0, r));\n    q.y -= .004;\n    r = circ(q, .015);\n    c *= sqr(ls(-.01, .01, r)); // inner shadow\n    q.y += .013;\n    r = circ(q, .05);\n\tc += RGB(67, 38, 30) * 4. * sqrt(b) * sqr(tri(-.02, .015, r) * tri(.023, .02, uv.y)); // specular?\n\n    return c;\n}\n\n// gothic_wall/iron01_ntech3\nTEX(giron01nt3) {\n\tuv.x *= .5; // fix aspect ratio (texture is 128 x 256)\n\n\tfloat\n\t\tb = FBMT(uv * vec2(2, 1), vec2(3, 5), .9, 3., 4), // base FBM, tileable\n\t\tn = .75 + b * b, // texture intensity\n\t\tt = uv.y + .2 * min(.4, tri(.5, .33, fract(uv.x * 4.))), // top alternating pattern\n\t\tf1 = fender(uv - vec2(.25, .62), vec2(3, 2) / 32.),\n\t\tf2 = fender(uv - vec2(.25, .55), vec2(3, 2) / 48.),\n\t\tr;\n        \n\tvec3\n\t\tc = mix(RGB(66, 50, 51), RGB(111, 66, 44), sqrt(tri(.31, .01, uv.y))),\n\t\tc2;\n\n\tvec2 p = uv, q;\n\tp.x = fract(p.x * 4.);\n\tif (uv.y > .3)\n\t\tc = add_rivet(c, vec2(4. * abs(p.x - .5) - 1.6, fract(uv.y * 16.) - .5), .07);\n\tr = abs(p.x - .5);\n\t// panel shadow/highlight\n\tc *= 1. - .3 * ls(.31, .32, uv.y) * ls(.87, .86, uv.y) *\n\t\t(ls(.035, .03, .5 - r) + tri(.48, .01, r) - tri(.46, .02, r));\n\n\t// greebles\n\tc = mix(c * n, greebles(uv * 2., b, .1), max(ls(.31, .3, uv.y), msk(f2)));\n\tc *= ls(1.5, .7, uv.y);\n\tif (uv.y < .306)\n\t\tc *= 1. - tri(.3, .05, uv.y) * msk(-f2 + 10., 20.); // panel shadow\n\tc *= 1. - tri(.316, .004, uv.y) * msk(-f2);\n\n    // bottom part - cables?\n    if (uv.y < .1)\n        c *= .0;\n    c = add_all_techpipes(c, uv, b);\n\n\t// fender?\n\tr = exclude(f1, f2);\n\tr = exclude(r, (uv.y - .3) * 3e2);\n\tc *= 1. - .5 * tri(-2., 17., f2) * ls(.26, .3, uv.y); // inner fender shadow\n\n\tc2 = RGB(67, 39, 17) * n;\n\tc2 = mix(c2, vec3(n * .2), tri(0., 4., r) * b); // desaturate edges\n\tc2 *= 1. - .4 * pow(tri(.0, 3., r), 4.); // darken outer edge\n\tc2 += (c2 + .6) * sqrt(b) * sqr(tri(-6., 8., r) * tri(.66, .04, uv.y)) * msk(r); // specular\n\tif (uv.y < .56)\n\t\tc2 = add_rivet(c2, vec2(24. * abs(uv.x - .25) - 1.85, fract(uv.y * 24. + .5) - .5), .15);\n\n    // top part - we also fill in the bottom row to avoid bilinear artifacts\n    // (even if the original texture doesn't)\n    c = mix(c, NO_COPY_PASTE giron01e(uv) NO_COPY_PASTE, ls(.85, .9, t) + step(uv.y, 1./256.));\n\tc *= 1. + tri(.88, .015, t) - sqr(tri(.87, .03, t));\n\n    return mix(c, c2, ls(1., .1, r));\n}\n\nvec3 gmtlbg6_layer(vec3 c, vec3 k, vec2 uv, int w, int h) {\n    float b = FBMT(uv, vec2(w, h), .5, 2., 2);\n    c *= .9 - .3 * ls(.15, .1, abs(b - .5));\n    return mix(c, k, tri(.5, .1, b));\n}\n\n// gothic_floor/metalbridge06\nTEX(gmtlbg6) {\n    uv = wavy(uv, 9., .005);\n    int i = 0, l[] = int[](13, 43, 17, 47, 23, 59, 27, 63);\n\tfloat b = FBMT(uv, vec2(19), .7, 2., 4);\n    vec3 c = mix(RGB(40, 50, 60), RGB(46, 33, 27), b) * (.5 + b);\n    for (/**/; i < 8; i += 2)\n        c = gmtlbg6_layer(c, mix(RGB(145, 140, 137), RGB(132, 123, 116), b), uv, l[i], l[i+1]);\n    return c;\n}\n\n// gothic_floor/metalbridge06broke\nTEX(gmtlbg6brk) {\n    vec3 c = gmtlbg6(uv); // base texture; differs in the actual shader - don't copy/paste!\n    float\n        b = FBMT(uv, vec2(7), .7, 2., 4), // base FBM\n        n = NT(uv, vec2(33)) - .5, // distortion noise\n        d = circ(uv - vec2(.7, .5), .13); // big right disk\n    d = min(d, circ(uv - vec2(.44, .66), .08)); // add smaller center disk\n    d = min(d, circ(uv - vec2(.33, .4), .06)); // add smaller left disk\n\td += .04 * n; // SDF distortion\n    c += b * b * tri(.0, .03, d); // bright edges\n    c *= 1.\n        - b * tri(.03, .02, d) // outer edge shadow\n        - b * tri(-.04, .05, d) * .5 // inner edge shadow\n        - b * ls(.0, .02, -d) // interior shadow\n\t;\n    return c;\n}\n\nvec3 gblks17f2_layer(vec3 c, vec3 k, vec2 uv, int w, int h) {\n    float b = FBMT(uv, vec2(w, h), .5, 2., 2);\n    c *= 1. - .15 * sqr(ls(.15, .1, abs(b - .5)));\n    return mix(c, k, tri(.5, .1, b));\n}\n\n// gothic_floor/blocks17floor2\nTEX(gblks17f2) {\n\tfloat\n        b = FBMT(uv, vec2(13), .9, 3., 4),\n        n = FBMT(uv, vec2(7), .9, 3., 4);\n    vec3\n        c = mix(RGB(111, 66, 55), RGB(80, 55, 52), sqr(ls(.8, .2, n))) * (.8 + .8 * b * b),\n        k = c; // layer color\n    uv = wavy(uv, 13., .01);\n    int i = 0, l[] = int[](13, 43, 17, 47, 23, 59, 27, 63);\n\tb = FBMT(uv, vec2(19), .7, 2., 4);\n    for (/**/; i < 8; i += 2)\n        c = gblks17f2_layer(c, k, uv, l[i], l[i+1]);\n    return c;\n}\n\n\nvec3 gkarnclma2r_layer(vec3 c, vec3 k, vec2 uv, int w, int h) {\n    float b = FBMT(uv, vec2(w, h), .5, 2., 1);\n    c *= .9 - .3 * sqr(ls(.15, .1, abs(b - .5)));\n    return mix(c, k, tri(.5, .1, b));\n}\n\n// gothic_door/km_arena1columna2R\nTEX(gkarnclma2r) {\n\tfloat\n        b = FBMT(uv, vec2(3,29), .9, 2., 4), // base FBM\n        t = .8 + .8 * b * b, // base texture intensity (remapped FBM)\n        d = abs(uv.y - .61), // distance from vertical center of helixy part\n        o = ls(.25, .24, d), // mask for flat part\n        m; // mask for threads\n    vec3\n        c = RGB(140, 127, 127), // base color\n        k = c; // branchy layer color\n    vec2\n        p = uv;\n\n    c *= 1. - .1 * ls(.85, .86, uv.y); // darken top part\n    c = t * mix(c, RGB(110, 55, 50), ls(.33, .32, uv.y)); // vary intensity, colorize bottom\n\n    p.y += p.x * .11 + b * .007; // skew\n    p.y = fract(p.y * 9.) - .5; // repeat vertically\n    m = ls(.0, .1, abs(p.y) - .2); // mask\n\n    // branchy part between the threads\n    int i = 0, l[] = int[](3, 29, 5, 37, 9, 63, 27, 63);\n    for (/**/; i < 6; i += 2)\n        c = mix(c, gkarnclma2r_layer(c, k, uv, l[i], l[i+1]), m * o); // branchy layer\n\n    c *= 1. + t * o * (\n        + .6 * tri(.1, .1, p.y) // helix highlight\n        - .7 * tri(-.25, .3, p.y) // shadow underneath helix\n        - .5 * tri(.2, .1, p.y) // shadow above helix\n\t);\n    c = mix(c, RGB(99, 66, 51) * t, tri(-.15, .1, p.y) * o); // colored reflection\n\n    // bevels at both ends of the helixy part\n    c *= 1.\n        + tri(.36, .005, uv.y) // highlight\n        + tri(.34, .005, uv.y) // highlight\n        + tri(.865, .005, uv.y) // highlight\n        + tri(.89, .01, uv.y) // highlight\n        - .5 * sqr(tri(.245, .01, d)) // shadow\n        - .7 * sqr(tri(.35, .01, uv.y)) // shadow\n        - .5 * sqr(tri(.325, .02, uv.y)) // shadow\n        - .8 * sqr(tri(.875, .02, uv.y)) // shadow\n        - .3 * sqr(tri(.9, .02, uv.y)) // shadow\n        ;\n\n    c *= .3 + sqrt(ridged(uv.x)); // darken left/right sides\n\n    return c;\n}\n\n/*\nHelpers\nvvvvvvv\n*/\n// distance, angle\nvec2 circ2(vec2 p, float r, float t) {\n    return vec2((length(p) - r) / t * .5 + .5, fract(atan(p.y, p.x) / TAU));\n}\n\nvoid xxsnake_seg(inout vec2 old, vec2 uv, inout vec2 c, float r, float t, float angle) {\n    c += sc(angle * TAU).yx * r * 2.;\n    if ((fract(angle) - old.y) * sign(angle) < 0.)\n    \told = circ2(uv - c, r, t);\n    //old = circ2(uv - c, r, t);\n}\n\nfloat cross2d(vec2 a, vec2 b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nvoid snake_seg(inout vec3 s, inout float r, vec2 p, vec2 a, vec2 b, vec2 c) {\n    r = length(b - a) - r;\n    a = normalize(a - b);\n    c = normalize(c - b);\n    p = safe_normalize(p - b);\n    if (cross2d(a, c) > cross2d(p, a)) {\n        s.xy = p;\n        s.z = length(p) - r;\n    }\n}\n\n/*\n^^^^^^^^\n*/\n\nvec3 gkarnarcfnl_layer(vec3 c, vec2 p, float s, float m) {\n    s = voro1(p, vec2(s)).z / s * 1e2;\n    c *= 1.\n        + .5 * m * ls(.9, .2, s)\n        - .5 * m * tri(2.5, .5, .3, s)\n        ;\n    return c;\n}\n\nvec3 gothic_metal(float b) {\n    return RGB(133, 100, 100. - 12. * b) * (.8 + .8 * b * b);\n}\n\n// Used by\n// - gothic_door/km_arena1archfinald_mid\n// - gothic_block/killblockgeomtrn\n// - gothic_block/demon_block15fx\nvec3 gkarnarcfnl_inner_gear(vec3 c, vec2 uv, float shadow_bias) {\n\tfloat\n\t\tb = FBMT(uv, vec2(4, 9), .9, 3., 4), // base FBM\n\t\tt = .8 + .8 * b * b, // base texture intensity (remapped FBM)\n        a, // angle\n\t\td, // distance\n        m, // mask\n        s, // segment\n        k, i, v, r, z; // ugh...\n\tvec3\n        mt = gothic_metal(b); // metal color\n\tvec2\n\t\tp, q;\n\n    p = q = uv;\n    q.x = abs(q.x); // symmetry\n    d = circ(p, .31);\n    v = nang(q); // relative angle; note: uses symmetric coords!\n    m = ls(.01, .0, d);\n    c = mix(c * ls(.0, .05, d + shadow_bias), vec3(.13 * t), m); // background color + outer shadow\n    c = gkarnarcfnl_layer(c, p, 37., ls(.04, .02, abs(d + .07))); // random lines\n    a = v * 22.;\n    i = floor(a); // segment id\n    s = a - i; // segment fraction\n    k = ls(.23, .22, abs(v - .25)) + R1(i) * ls(.0, .1, q.y);\n    d -= r = (d * .3 + .005) * k; // extra thickness for top part\n    m = ls(.0, .1, q.y) * msk(abs(d + .015) - .015);\n    c = mix(c, mt, sat(1.5 * tri(-.015, .0, .01 - .003 * k, d))); // highlight\n    c = mix(c, RGB(130, 75, 44) * t, tri(-.02, .005, d) * ls(.0, .1, q.y)); // colored reflection\n    c *= 1.\n        - .3 * ls(.025, .03, -d) // darken interior\n        - .5 * ls(.4, .5, abs(s - .5)) * m // dark edge between top segments\n        + .2 * tri(.5, .3, abs(s - .5)) * m // top segment edge highlight\n        - .5 * tri(-.015, .007, d) // dark edge\n        - .5 * tri(-.03, .007, d) // dark edge\n        - .5 * tri(-.1, .005, d + r) // dark edge\n        - .5 * tri(-.115, .005, d + r) // dark edge\n        - .5 * tri(-.125, .015, d + r) // dark edge\n        - .5 * tri(-.145, .005, d + r) // dark edge\n        + .9 * tri(-.11, .007, d + r) // highlight\n        + .5 * tri(-.14, .005, d + r) // highlight\n        - b * tri(.225, .005, abs(v - .25)) * msk(abs(d + .015) - .015) // dark edge\n        ;\n    a = v * 72.;\n    i = floor(a); // segment id\n    s = a - i; // segment fraction\n    k = step(.7, H(i)) // 30% of segments\n        * step(q.y, .0) // below horizon\n        * ls(.02, .0, abs(d + .02)) // distance from circle between [-0.4 and 0]\n        ;\n    c = mix(c, vec3(mt * .6), k * ls(.4, .3, abs(s - .5))); // background color\n    c *= 1.\n        - .7 * k * tri(.4, .1, abs(s - .5)) // dark segment edge\n        ;\n\n    return c;\n}\n\n// (256 x 576) Combination of:\n// - gothic_door/km_arena1archfinalc_top (256 x 64)\n// - gothic_door/km_arena1archfinald_mid (256 x 256)\n// - gothic_door/km_arena1archfinald_bot (256 x 256)\nTEX(gkarnarcfnl) {\n\tfloat\n\t\tb = FBMT(uv, vec2(4, 9), .9, 3., 4), // base FBM\n\t\tt = .8 + .8 * b * b, // base texture intensity (remapped FBM)\n        a, // angle\n\t\td, // distance\n        m, // mask\n        s, // segment\n        k, i, v, r, z; // ugh...\n\tvec3\n        mt = gothic_metal(b), // metal color\n\t\tc = vec3(.3 * b); // base color\n\tvec2\n\t\tp, q;\n\n    /* bottom arch */\n    p.x = uv.x - .5;\n\tp.y = max(uv.y - .2, 0.) * 1.89;\n    v = atan(p.y, abs(p.x)) / PI; // relative angle [-1..1]\n\td = circ(p, .48); // arch distance\n    k = ls(.3, .31, v); // mid mask\n    d *= 1. - .2 * ls(.3, .31, v) - .1 * ls(.43, .44, v); // thicken middle parts\n\ta = v * (v > .44 ? 2. : v > .3 ? 63. : 31.); // number of segments\n    c = mix(c, mt, ls(.03, .01, abs(d))); // arch background color\n    m = msk(abs(d - .01) - .02);\n    i = floor(a);\n    s = a - i;\n    if (v > .33 && v < .44)\n        s = fract(s + H(i) * .6 - .3); // non-uniform segments\n    c *= 1.\n        //- .5 * m * tri(.435, .005, v) // dark edge\n        - .5 * m * tri(.307, .01, v) // dark edge\n        - t * m * tri(.5, .1 + k * .2, s) // dark edge between segments\n        + b * m * tri(.52, .2 + k * .2, s) // segment edge highlight\n        ;\n    c *= 1.\n        - .9 * tri(-.015, .015, d) // black inner edge\n        - .5 * tri(.0, .01, d) // dark inner edge\n        - .7 * tri(.03, .02, d) // black outer edge\n        + tri(.01, .015, d) // highlight\n        ;\n\n    /* top gothic arch */\n    q = p;\n    q.y -= .5;\n    q.x = abs(q.x) + .6;\n    d = circ(q, 1.13);\n    m = ls(.03, .02, abs(d)) * ls(.5, .6, q.y);\n    c = mix(c, mt * sat(1. - abs(d - .015) / .03), m); // background color\n    c *= 1.\n        - .5 * m * tri(.005, .01, d)\n        + .5 * m * tri(.017, .005, d)\n        ;\n\n    /* small top gears */\n    q.x = abs(uv.x - .5) - .35;\n    q.y = uv.y * 9./4. - 2.1;\n    d = circ(q, .13) * 10.;\n    a = nang(q) * 49.;\n    i = floor(a);\n    s = a - i;\n    v = ls(.85, .9, H(i));\n    for (int j = 0; j < 2; ++j, d += .3) {\n        c = mix(c, mt * (b * .5 + .2), ls(.09, .03, abs(d)));\n        c *= 1.\n\t\t\t+ .7 * sqr(tri(.01, .05, d))\n            ;\n    }\n\n    /* large outer gear above arch */\n    p.y = (uv.y - .7) * 9./4.;\n    d = circ(p, .43);\n    a = atan(p.y, abs(p.x)) / PI; // relative angle [-1..1]\n    a = max(a, -.48); // remove lower mid space spoke\n    r = a;\n    i = floor(a *= 23.); // segment id\n    s = a - i; // segment fraction\n    k = R1(i) * .2 - .1 * ls(.0, .1, -d);\n    v = ls(.1, .2, abs(s - .5) - k);\n    d += v * .007; // offset spokes\n    r = (1. - v) * sqr(tri(.5, .3, r)) * ls(.25, .05, abs(s - .5)); // top spikes\n    d -= .17 * r;\n    m = tri(.04, .0, -.4, d); // mask\n    c = mix(c, mt * (b * .4 + .4), m); // background color\n    c = gkarnarcfnl_layer(c, p, 31., ls(.1, .05, abs(d + .15)) * v); // random lines between spokes\n    c *= mix(1., 1. - tri(.1, .2, .4, abs(s - .5) - k), m * b); // spoke shadows\n    c *= 1.\n        - .7 * sqr(tri(.03, .03, d)) // black outer edge\n        - .7 * sqr(tri(.03, .03, d + .05)) * v // dark shadow between 1st and 2nd circles\n        - .7 * sqr(tri(.0, .02, d + .05)) * v // dark shadow under 2nd circle\n        - .3 * ls(.04, .06, -d) * v // darken space between spokes\n        + .5 * tri(.02, .0, -.1, d) // smooth highlight\n        + tri(.0, .01 + .07 * r, d) // sharp highlight\n        + tri(.0, .01, d + .03) * v // sharp highlight\n        ;\n\n    /* smaller inner gear above arch */\n    p.y -= .05;\n    c = gkarnarcfnl_inner_gear(c, p, 0.);\n\n    return c;\n}\n\n// gothic_door/km_arena1archfinalc_top\nTEX(gkarnarcfnltp) {\n\tuv.y = (uv.y + 8.) / 9.;\n\treturn gkarnarcfnl(uv);\n}\n\n// gothic_door/km_arena1archfinald_mid\nTEX(gkarnarcfnlmd) {\n\tuv.y = (uv.y * 4. + 4.) / 9.;\n\treturn gkarnarcfnl(uv);\n}\n\n// gothic_door/km_arena1archfinald_bot\nTEX(gkarnarcfnlbt) {\n    // Hack: reduce bilinear artifacts at the top by changing\n    // the bottom row of pixels to match the bottom row in _mid\n    if (uv.y < .01)\n        ++uv.y;\n\tuv.y = uv.y * 4. / 9.;\n\treturn gkarnarcfnl(uv);\n}\n\n// gothic_floor/largerblock3b\nTEX(glrgbk3b) {\n\tuv.y -= 1./32.; // hack to avoid storing UV offsets for this texture in the map...\n\tvec2\n\t\tp = brick(uv.yx, vec2(8)), // brick layout\n\t\tq = fract(p), // position inside brick [0..1]\n\t\tv = wavy(uv, 31., .002), // wavy uv, for bumps\n\t\tid = p - q; // brick id\n\tfloat\n\t\tb = FBMT(wavy(uv, 5., .02), vec2(7), 1., 3., 4), // base FBM\n\t\tt = .8 + .8 * b * b, // base intensity (remapped FBM)\n\t\tn = NT(uv + R2(H(id) * 64.), vec2(23)), // smooth noise, for brick edge size variation\n\t\tm = FBMT(uv, vec2(9), .7, 3., 4), // another FBM, for dark splotches\n\t\td = FBMT(v, vec2(63), .7, 3., 4), // bump FBM\n\t\tr = FBMT(v - vec2(0, .002), vec2(63), .7, 3., 4), // offset bump FBM, for lighting\n\t\tl = d - r, // lighting\n\t\te = brick_edge(q, .03 + .03 * ridged(n)).z, // edge intensity: 1 = on edge, 0 = inside brick\n        h = H(id); // hashed brick id\n\tvec3 c = mix(RGB(91, 61, 42), RGB(70, 30, 15), e * b); // base colors\n\tc = mix(c, RGB(70, 48, 35), ls(.5, .6, m)) // add dark splotches\n        * t // and vary intensity\n        ;\n\tc *= 1.\n\t\t+ l * (.1 + n + tri(.6, .1, m)) * (1. - e) // bump lighting\n\t\t- t * ls(.7, 1., e) * NT(uv, vec2(13)) // dark brick edges\n\t\t+ .5 * b * tri(.3, .3, e) // brick edge highlights\n\t\t;\n    d = FBMT(v, vec2(23), .5, 2., 4); // hole FBM\n    c *= 1.\n        - .2 * ls(.6, .7, d) * h // darken interior\n        + .3 * tri(.6, .05, d) * h * n // highlight edges\n        ;\n\tc *= .9 + .2 * h * (1. - e); // vary intensity per brick\n\tc *= .9 + .4 * pow(FBMT_ridged(uv - H(id / 8.), vec2(5), .6, 2., 4), 4.); // some ridge-like intensity variation\n\treturn c;\n}\n\n// gothic_floor/largerblock3b_ow (texture)\nTEXA(glrgbk3bow) {\n    vec3 c = glrgbk3b(uv * .5); // differs from the actual shader - don't copy!\n    float\n    \tn = NT(uv, vec2(19)),\n        m, r\n\t;\n    vec2\n        p = uv - .5,\n        q = vec2(3, 17) * vec2(nang(p), length(p) + (n - .5) * .03),\n        e\n\t;\n    q.x += floor(q.y) * PHI;\n    q.x *= floor(q.y);\n    r = length(e = fract(q) - .5);\n    m = tri(.5, 1., 4.5, q.y) * n;\n\tc *= 1.\n        - m * sqr(tri(.3, .2, r)) * 5. * e.y // cell bevel\n        - m * ls(.4, .5, r) // dark edge borders\n\t\t;\n    c *= ls(.9, 1.2, q.y);\n\treturn ls(.5, 1.1, q.y) * vec4(c, 1);\n}\n\n// gothic_floor/largerblock3b_ow (map shader)\nvoid glrgbk3bow_m() {\n    vec2 p = UV - H2(Time.x * vec2(3, 5));\n\tfloat b = FBMT(p, vec2(13), .6, 2., 4);\n\tvec4 c = glrgbk3bow(UV); // texture(Texture0, UV);\n\tFCol = vec4(mix(b * b * vec3(3, .4, 0), c.xyz, c.w) * Light(), 1);\n}\n\n// gothic_block/largerblock3blood (texture)\nTEXA(glrgbk3bbld) {\n    vec3 c = glrgbk3b(uv * .5); // differs from the actual shader - don't copy!\n    float\n        b = FBMT(uv, vec2(5), .6, 3., 4),\n        r = length(uv - .5) + b * b,\n        m = ls(.2, .6, r)\n\t;\n    return vec4(mix(b * vec3(.5, .2, .0), c, m), m);\n}\n\n// gothic_block/largerblock3blood (map shader)\nvoid glrgbk3bbld_m() {\n\tvec4 c = glrgbk3bbld(UV); // texture(Texture0, UV);\n    float b = FBMT(wavy(UV - Time.x * vec2(1, 3) / 2e2, Time.x * .4, 4., .03), vec2(7), .6, 3., 4);\n    c.xyz = mix(b * RGB(99, 9, 5) + ls(.78, 1.5, b), c.xyz, c.w);\n\tFCol = vec4((c.xyz/* + (1. - c.w) * env(Ref) * .2*/) * Light() , 1);\n}\n\n// gothic_block/blocks15\nTEX(gblks15) {\n\tfloat\n\t\tb = FBMT(uv, vec2(5), .9, 3., 4), // base FBM\n\t\tt = FBMT_ridged(wavy(uv, 4., .01), vec2(7), .5, 3., 5), // ridged FBM\n\t\tn = NT(wavy(uv, 4., .05), vec2(9)), // smooth noise\n\t\tid, e;\n\tvec3\n\t\tc = RGB(74, 65, 62) * (.8 + .8 * b * b), // base color\n\t\tpt = pattern(uv, 4., .07 + b * .04); // asymmetric block pattern\n\tvec2 d = grad(pt.x);\n\tid = H(fract(pt.yz)); // tile id\n\tc += tri(.6, .3, n) * ls(.3, .9, b * t) * .2; // bright splotches\n\tc *= 1. - tri(.5, .4, n) * ls(.5, .7, t) * .1; // some medium-frequency variation\n\tc = mix(c, RGB(86, 74, 78), tri(.5, .1, b) * tri(.7, .3, id) * .7); // subtle splash of color\n\tc = mix(c, RGB(105, 90, 70), tri(.3, .1, t) * tri(.3, .3, id) * .3); // another subtle splash of color\n\te = tri(.015, .015 * b, pt.x) + tri(.4, .1, n * t) * .4; // edge size\n\tc *= 1. - .2 * t * ls(.015, .017, pt.x); // mortar\n\tc *= 1. + e * b * (d.y - .3); // bevel\n\tc *= .9 + .2 * id; // per-tile brightness variation\n\tc *= .9 + .2 * ridged(NT(uv - pt.yx, vec2(5))); // some medium-frequency variation\n\n\tvec3 g;\n\tEVAL_GRAD(\n\t\tg, uv,\n\t\ttri(.7, .5, NT(p[i], vec2(23))) *\n\t\tsat(tri(.7, .4, NT(p[i], vec2(53))) * 4.);\n\t);\n\tc *= 1.\n\t\t+ g.y * g.z * b * b * (.8 - id) // scratches\n\t\t- pow(ls(.5, .0, b), 3.) // dirt/mold\n\t;\n\n\treturn c;\n}\n\n/*\nTEX(gblks15) {\n\tfloat\n\t\tb = FBMT(uv, vec2(5), .9, 3., 4),\n\t\tt = FBMT_ridged(wavy(uv, 4., .01), vec2(7), .5, 3., 5),\n\t\tn = NT(wavy(uv, 4., .05), vec2(9)),\n\t\tid, e;\n\tvec3\n\t\tpt = pattern(uv, 4., .1 + n * t * .05),\n\t\tc;\n\tvec2 d = grad(pt.x);\n\tid = H(fract(pt.yz));\n\tc = RGB(74, 65, 62) * (.8 + .8 * b * b);\n\tc += tri(.6, .3, n) * ls(.3, .9, b * t) * .2;\n\tc *= 1. - tri(.5, .4, n) * ls(.5, .7, t) * .1;\n\tc = mix(c, RGB(86, 74, 78), tri(.5, .1, b) * tri(.7, .3, id) * .7);\n\tc = mix(c, RGB(105, 90, 70), tri(.3, .1, t) * tri(.3, .3, id) * .3);\n\te = tri(.015, .005 + .015 * n, pt.x) + tri(.4, .1, n * t) * .4;\n\tc *= 1. - b * ls(.015, .05, pt.x) * .7;\n\tc *= 1. + e * b * (d.y - .5) * .7;\n\tc *= .9 + .2 * id;\n\tc *= .9 + .2 * ridged(NT(uv - pt.yx, vec2(5)));\n\tvec3 g;\n\tEVAL_GRAD(\n\t\tg, uv,\n\t\ttri(.5, .2, FBMT(p[i], vec2(23), .5, 2., 2)) *\n\t\ttri(.7, .3, NT(p[i], vec2(13)));\n\t);\n\tc *= 1. + g.y * g.z * b * b;\n\treturn c;\n}\n*/\n\n// gothic_block/killblockgeomtrn\nTEX(gkblkgmtrn) {\n\tvec3 c = gblks15(uv); // differs from actual shader; don't copy/paste!\n    uv -= .5;\n\tc = gkarnarcfnl_inner_gear(c, uv * .9, .02);\n\treturn c;\n}\n\n// Simple skull shape\n// x = light intensity\n// y = SDF\nvec2 skull(vec2 p) {\n\tp.x = abs(p.x); // symmetry\n\tvec2 q = p, v;\n\tq.y -= .5;\n\tfloat\n\t\td = circ(q, .35),\n\t\te, // secondary sdf\n\t\tc; // light intensity\n    v = q / .35;\n\tq.y += .22;\n\tq.x -= .15; // eye offset\n\td = min(d, box(q, vec2(.09, .05)) - .1); // cheekbones\n\te = elips(q, vec2(.15, .1)) / 5e1; // eye socket sdf\n    c = .1\n        + dot(vec2(v.y, sqrt(sat(1. - lsq(v)))), vec2(.3))  // base intensity\n        - .05 * tri(.44, .1, p.y) // slight eyebrow indentation\n        - .1 * smoothstep(.3, .22, length(p - .5)) // darken temples\n\t;\n\tq.y += .2;\n\tq.x = p.x; // recenter\n\tc = max(c, sat(.4 - length(q))); // brigten up bottom\n\tc +=\n        .15 * tri(.0, .1, e) // highlight eye socket edge\n        - .1 * msk(e + .12, .15) // darken eye socket interior\n        ;\n\td = min(d, box(q, vec2(.15 - ls(-.15, .15, q.y) * .07, .03)) - .09); // nose\n    c *= 1. - ls(.05, .25, q.x) * ls(.2, .1, abs(q.y + .12)); // maxilla gradient\n\tq.y -= .06;\n\tc -= .5 * msk(elips(q, vec2(.05 - ls(-.1, .1, q.y) * .03, .06)) / 1e3 + .03, .05); // darken nose\n\t//q.y += .15;\n\t//d = min(d, box(q, vec2(.1 - sqr(ls(.1, -.1, q.y)) * .03, .05)) - .05);\n\treturn vec2(sat(c), d);\n}\n\n// gothic_block/demon_block15fx\nTEX(gdmnblk15fx) {\n\tvec3 c = gblks15(uv); // differs from actual shader; don't copy/paste!\n\n    uv -= vec2(.5, .66);\n    float\n        b = FBMT(uv, vec2(5), .5, 3., 4),\n        t = .8 + .8 * b * b,\n        k = sqr(1. - tri(-.35, .2, uv.y)),\n        r, d, l;\n\n    EVAL_TOP_LIGHT(uv, .02, d, l, min(seg(p, vec2(0), vec2(0, -.44), .12), circ(p, .25)));\n    c = mix(c, mix(RGB(188, 133, 66), RGB(133, 127, 119), ls(.6, .2, -uv.y)) * t, msk(d, .01)); // base metal color\n    c *= 1.\n        + .6 * (l * .6 - .4) * sat(1.5 * tri(.2 + .1 * k, -.1 * k, -.2 * k - .03, d * 10.)) // outer bevel\n        + 1.5 * tri(.0, .08, uv.x) * tri(.02, .01, -d) // lower edge highlight\n\t;\n    //c = mix(c, vec3(.27), tri(.0, .15, uv.x) * tri(.0, .01, d) * sat(-l)); // grey bottom edge reflection; too subtle?\n\n    /* skull */\n    vec2\n        p = uv * 8. + vec2(0, 2.5),\n        q = skull(p);\n    l = (skull(p + vec2(0, .2)).y - q.y) / .2;\n    c *= 1.\n        - (l * .6 + .2) * tri(.05, .1, q.y) // skull bevel\n        - (.5 - 2. * q.x) * msk(q.y, .05) // skull interior\n\t;\n\n    /* crescent under skull */\n    EVAL_TOP_LIGHT(uv, .01, r, l, exclude(circ(p + vec2(0, .26), .09), circ(p, .255)));\n    c *= 1. - (l * .6 + .2) * tri(.0, .01, r) * msk(.1 - q.y, .1);\n\n    c = mix(c, gkarnarcfnl_inner_gear(c, uv * 1.4, .05), msk(.15 - q.y, .05));\n\n    p.x = abs(uv.x);\n    p.y = repeat(uv.y + .37, .06, -1., 1.);\n    c = add_rivet(c, p - vec2(.095, .015), .011, .2, .4); // knobs\n\n\treturn c;\n}\n\n// (384 x 384) Combination of:\n// - gothic_door/skull_door_a ( 64 x 256 - bottom right)\n// - gothic_door/skull_door_b (256 x 256 - bottom mid)\n// - gothic_door/skull_door_c ( 64 x 256 - bottom left)\n// - gothic_door/skull_door_d ( 64 x 128 - top right)\n// - gothic_door/skull_door_e (256 x 128 - top mid)\n// - gothic_door/skull_door_f ( 64 x 128 - top left)\nTEX(gskdr) {\n    uv *= 1.5;\n\n    float\n\t\tb = FBMT(wavy(uv, 7., .02), vec2(9), .7, 3., 2), // base FBM\n\t\tt = b, // base texture intensity (remapped FBM)\n        n = NT(uv, vec2(13)), // smooth noise\n        a, // angle\n        s, // segment fraction [0..1]\n        d; // SDF\n    vec3 c = gblks15(uv);\n    vec2 p;\n\n    p.x = abs(uv.x - .75);\n    p.y = max(uv.y - .58, 0.) * 1.15;\n    a = atan(p.x, p.y) / PI; // angle [-1..1]\n    s = fract(a * 7. + .5); // segments\n    d = circ(p, .45); // base arch\n    d -= .06 * ls(.4, .33, uv.y); // outer buttress\n    d -= .05 * ls(.15, .07, abs(s - .5)) * step(.63, uv.y);\n    d = exclude(d, uv.y - .107); // bilinear filtering hack: exclude bottom pixel row\n    if (uv.y < .6)\n\t\td = exclude(d, abs(p.x - .493) - .113); // bilinear filtering hack\n\td = exclude(d,\n\t\tcirc(p, .6) // carve out interior\n\t\t+ .044 * ls(.48, .43, uv.y) // inner buttress\n\t);\n    c = mix(c, RGB(144, 125, 115) * t, msk(d - .1, .005));\n    c *= 1.\n        - .3 * tri(.12, .11, .1, d) // outer shadow\n        + .5 * tri(.1, .005 + .015 * n * n, d) // highlight\n        ;\n\n    return c;\n}\n\n// gothic_door/skull_door_a ( 64 x 256 - bottom right)\nTEX(gskdr_a) {\n    return gskdr(vec2(5, 0) / 6. + uv * vec2(1, 4) / 6.);\n}\n\n// gothic_door/skull_door_b (256 x 256 - bottom mid)\nTEX(gskdr_b) {\n    return gskdr(vec2(1, 0) / 6. + uv * vec2(4) / 6.);\n}\n\n// gothic_door/skull_door_c ( 64 x 256 - bottom left)\nTEX(gskdr_c) {\n    return gskdr(uv * vec2(1, 4) / 6.);\n}\n\n// gothic_door/skull_door_d ( 64 x 128 - top right)\nTEX(gskdr_d) {\n    return gskdr(vec2(5, 4) / 6. + uv * vec2(1, 2) / 6.);\n}\n\n// gothic_door/skull_door_e (256 x 128 - top mid)\nTEX(gskdr_e) {\n    return gskdr(vec2(1, 4) / 6. + uv * vec2(4, 2) / 6.);\n}\n\n// gothic_door/skull_door_f ( 64 x 128 - top left)\nTEX(gskdr_f) {\n    return gskdr(vec2(0, 4) / 6. + uv * vec2(1, 2) / 6.);\n}\n\n// gothic_block/blocks18c\nTEX(gblks18c) {\n\tfloat b = FBMT(uv, vec2(13, 1), .7, 2., 3); // mostly vertical noise\n\tvec3 c = gblks15(uv) * .7; // base texture, slightly darkened\n\tc *= 1. - sqr(ls(.4, 1., b)); // dark drip stains\n\treturn c;\n}\n\n// s.x = specular size\n// s.y = specular intensity\nvec3 gklblki_base(vec2 uv, vec2 s) {\n\tfloat\n\t\tb = FBMT(uv, vec2(5), .9, 3., 4), // base FBM\n        n = FBMT(uv, vec2(31, 3), .5, 3., 3), // mostly vertical noise (for drip stains)\n        t = .75 + b * b; // base texture intensity (remapped FBM)\n\n    vec2 p = uv;\n    vec3 c = gblks15(uv); // differs from the actual shader; don't copy/paste!\n\n    if (uv.y < .38)\n        c = mix(RGB(92, 43, 15), RGB(66, 44, 33), ls(.1, .05, uv.y)) // base color\n            * t * (.5 + .5 * ls(.0, .35, uv.y)) // intensity\n            ;\n    c +=\n        b * s.y * sqr(tri(.32, s.x * .015, uv.y)) // highlight edge\n        + .3 * b * tri(.34, .05, uv.y) // highlight top\n        ;\n    c *= 1.\n        - tri(.38, .005 + b * b * .03, uv.y) // shadow under blocks\n        + 3. * tri(.15, .2, uv.y) * (n - .5) // dark drip stains\n        ;\n\n    return c;\n}\n\nvec3 gklblki_vent(vec3 c, vec2 uv, float b) {\n\tfloat\n        t = .75 + b * b, // base texture intensity (remapped FBM)\n        d, o, i;\n\n    vec2 p = uv;\n    p.y -= .21;\n\n   \td = circ(vec2(.75 * p.x, elongate(p.y, .1)), .033);\n    o = msk(d, .005); // outer part\n    d = circ(vec2(.75 * p.x, elongate(p.y + .005, .09)), .033);\n    i = msk(d + .015, .004); // inner part\n    c = mix(c, RGB(83, 81, 66) * t, (o - i) * ls(.1, .3, uv.y)); // base metallic color\n    c *= 1. - ls(.17, .25, uv.y) * i; // inner shadow\n    c += sqr(tri(.0, .015, d)) * tri(.32, .03, uv.y); // top specular\n    c *= 1. + 3. * pow(tri(-.01, .03, d), 4.) * tri(.09, .03, uv.y); // bottom specular\n\n    d = circ(vec2(.75 * p.x, elongate(p.y + .03, .1)), .033); // shadow distance\n    c *= 1. - msk(d + .01, .02) * (1. - o); // outer shadow\n\n    if (uv.y > .09 && uv.y < .3)\n    \tc = add_rivet(c, vec2((abs(p.x) - .035) * 36., fract(uv.y * 36.) - .5), .1);\n\n    return c;\n}\n\n// gothic_block/killblock_i\nTEX(gklblki) {\n\tfloat b = FBMT(uv, vec2(5), .9, 3., 4); // base FBM\n    vec3 c = gklblki_base(uv, vec2(1));\n    uv.x = mod(uv.x, 1./7.) - .07; // repeat 7x horizontally\n    return gklblki_vent(c, uv, b);\n}\n\n// gothic_block/killblock_i4\nTEX(gklblki4) {\n\tfloat\n\t\tb = FBMT(uv, vec2(9), .7, 2., 4), // base FBM\n\t\tt = .75 + b * b, // base texture intensity (remapped FBM)\n        l;\n\tvec3 c = gklblki_base(uv, vec2(4, .3));\n\tvec2 p = uv, s;\n\tp.x = mod(p.x, .2); // repeat x5 horizontally\n\tp -= .1;\n\ts = skull(p * 5.); // skull grayscale intensity + SDF\n    l = (skull(p * 5. + vec2(0, .1)) - s).y / .1; // skull light/shadow\n    c = mix(c, mix(vec3(.5, .4, .3), vec3(.95, .8, .55), t) * t * s.x, msk(s.y, .02)); // skulls\n    c *= 1. - (.5 - l * .3) * tri(.03, .07 + .13 * sat(-l), s.y); // skull shadows, larger below\n\treturn c;\n}\n\n// gothic_trim/baseboard09_e\nTEX(gtbsbrd09e) {\n    float\n\t\tb = FBMT(uv, vec2(9, 3), .9, 3., 4), // base FBM\n        n = FBMT(uv, vec2(11, 5), .5, 3., 4), // slightly smoother FBM\n\t\tt = .75 + b * b, // base texture intensity (remapped noisy FBM)\n        l, m;\n    vec3 c = mix(RGB(48, 44, 44), RGB(77, 55, 44), ls(.3, .7, n)) * t;\n    vec2 p, q, s;\n\n    p.x = mod(uv.x + .14, .28) - .22;\n    p.y = uv.y * .4 - .09;\n\n    // top slots\n    q.x = mod(uv.x - .014, .14);\n\tq.y = uv.y;\n    c = mix(c, RGB(133, 122, 122) * t, tri(.9, .91, 1., uv.y) * ls(.03, .033, abs(q.x - .07)));\n    c = mix(c, RGB(88, 73, 70) * t * ls(1., .96, uv.y), ls(.86, .87, uv.y) * ls(.033, .03, abs(q.x - .07)));\n\n    // stadium-shaped vents between skulls\n    c = gklblki_vent(c, p * 1.2, b);\n\n    // cables\n    c *= ls(.2, .3, uv.y);\n    c = add_all_techpipes(c, uv * vec2(1.5, .75), b);\n\n    // skulls\n    t = .8 + .8 * n * n; // smoother base texture intensity\n    p.x += .133;\n    p.y = p.y * 1.1 - .09;\n    m = step(abs(uv.x - .5), .4); // 3 skull limit\n    s = skull(p * 5.); // skull grayscale intensity + SDF\n    l = (skull(p * 5. + vec2(0, .1)) - s).y / .1; // skull light/shadow\n    c = mix(c, 2.5 * mix(RGB(122, 99, 95), RGB(99, 66, 50), b) * t * s.x, msk(s.y, .02) * m); // skulls\n    c *= 1. - (.5 - l * .3) * tri(.02, .07 + .13 * sat(-l), s.y) * m; // skull shadows, larger below\n\n    return c;\n}\n\n// gothic_trim/baseboard09_c3\nTEX(gtbsbrd09c3) {\n    float\n        b = FBMT(uv, vec2(9, 3), .9, 3., 4), // base FBM\n\t\tt = .65 + 1.4 * b * b; // base texture intensity (remapped FBM)\n    vec3\n        c = RGB(60, 50, 44) * t, // base color\n        k; // secondary color\n    vec2 p, q;\n\n    p.x = mod(uv.x + .14, .28) - .22;\n    p.y = uv.y * .4 - .09;\n\n    // panels\n    c *= 1.\n        + b * tri(-.13, .006, p.x) // panel edge highlight\n        - tri(-.135, .004, p.x) // panel edge shadow\n    ;\n    c = add_rivet(c, vec2(abs(p.x + .135) - .02, mod(uv.y * .5 - .02, .07) - .05), .006, .4, .7);\n\n    // vent interior\n    k = RGB(77, 55, 33) * t * (.7 + .3 * ridged(fract(uv.x * 66.)));\n    q.x = p.x;\n    q.y = elongate(p.y - .16, .07);\n    c = mix(c, k, msk(circ(q, .02), .03));\n\n    // top slots\n    q.x = mod(uv.x - .014, .14);\n\tq.y = uv.y;\n    c = mix(c, RGB(122, 99, 88) * t, tri(.9, .91, 1., uv.y) * ls(.03, .033, abs(q.x - .07)));\n    c = mix(c, RGB(88, 77, 66) * t * ls(1., .96, uv.y), ls(.86, .87, uv.y) * ls(.033, .03, abs(q.x - .07)));\n\n    // stadium-shaped vents\n    c = gklblki_vent(c, p * 1.2, b);\n\n    // bottom panel\n    c = mix(c, t * mix(RGB(45, 77, 66), RGB(99, 55, 22), NT(uv.x * 55., 55.)), ls(.25, .23, uv.y)); // base color\n\n    c *= 1.\n        //+ b * tri(.5, .3, fract(uv.x * 99.)) * tri(.23, .025, uv.y) // bottom panel edge ridges\n        + .7 * sqr(tri(.23, .03, uv.y)) // bottom panel edge highlight\n        - .4 * tri(.22, .18, .12, uv.y) // bottom panel edge shadow\n        - .5 * ls(.23, .21, uv.y) // darken bottom panel\n        - .5 * ls(.1, .0, uv.y) // black bottom\n    ;\n\n    return c;\n}\n\n// gothic_trim/baseboard09_o3\nTEX(gtbsbrd09o3) {\n    uv.y *= .5; // correct aspect ratio\n    float\n        b = FBMT(uv, vec2(7), .9, 3., 4),\n        d, m\n    ;\n    vec3 c = vec3(.6 * b);\n    vec2 p, q;\n    p.x = mod(uv.x + .15, .33) - .15;\n    p.y = uv.y - .5;\n    p.x *= 2.;\n    c = mix(c, RGB(111, 99, 77) * b, m = ls(.0, -.01, d = box(p, vec2(.14, .05)) - .05)); // top slots\n\n    c *= 1.\n        + 2. * tri(.46, .033, uv.y) // top specular\n        + tri(.0, .01, d) // slot edge highlight\n        - .9 * sqr(tri(.13, .03, uv.y)) // dark groove\n        - .7 * tri(-.01, .01, d) // inner slot shadow\n        - ridged(fract(p.x * 44.)) * sat(-d * 44.) * b // top pipe ridges\n        //- ls(.08, .0, uv.y - .02 * NT(uv.x * 15., 15.)) // jagged bottom shadow\n        - ls(.1, .0, uv.y) // bottom shadow\n        - ls(.03, .01, abs(uv.y - .33)) // shadow behind top third pipes\n    ;\n\n    vec3 k = mix(RGB(122, 88, 66), RGB(133, 77, 44), b) * (.5 + 1.5 * b * b); // copper-ish color\n    c = mix(c, c * 8. * greebles(uv * 2., b, .3), ls(.35, .3, uv.y)); // greeble up\n/*\n    c *= 1.\n        - (.4 - b) * ls(.4, .2, uv.y) // amplify noise and brighten up a bit\n    ;\n*/\n/*\n    // thin twin middle pipes (90-degree corners)\n    p = mod(uv, .63) - vec2(.21, .3);\n    d = circ(q = min(p, vec2(0)), .02);\n    d = onion(d, .01);\n    d = onion(d, .005);\n    d = max(d, uv.y - .33);\n    d = max(d, p.x - .1);\n    c = mix(c, k, ls(.0, -.005, d));\n    c *= 1.\n        - .7 * tri(-.005, .0, .02, d)\n    ;\n\n    p.x = mod(uv.x, .62) - .3;\n    p.y += .02;\n    c = mix(c, k * .5, ls(.0, -.005, d = box(p, vec2(.04, .02))));\n    c *= 1.\n        - .7 * tri(-.005, .0, .02, d)\n    ;\n*/\n\n    // top third pipes and covers\n    p.x = abs(uv.x - .5); // horizontal symmetry\n    p.y = uv.y - .33;\n    d = abs(p.y) - .03;\n    d = max(d, -box(p - vec2(.16, 0), vec2(.02, 0)) + .01); // inner slots\n    d = max(d, -box(p - vec2(.55, 0), vec2(.01, 0)) + .08);\n    d = max(d, -box(p - vec2(.33, 0), vec2(.01, 0)) + .08);\n    c = mix(c, k, ls(.0, -.005, abs(p.y) - .013)); // top third pipes\n    c *= 1.\n        + .5 * tri(.004, .006, p.y) // bright pipe reflection\n        - .7 * tri(-.004, .006, p.y) // dark pipe reflection\n    ;\n    c *= 1.\n        - .7 * tri(.5, .05, fract(p.x * 11.)) * tri(.0, .02, p.y) // pipe segments\n    ;\n    c = mix(c, k, m = ls(.0, -.005, d));\n    c *= 1.\n        + .5 * tri(-.004, .004, d) // edge highlight\n        - .7 * tri(-.004, .0, .01 + .07 * ls(.02, .2, -p.y), d) * ls(.04, .0, p.y) // outer shadow\n    ;\n\n    c = mix(c, c * k * 2., ls(.05 + .5 * sqr(NT(uv.x * 99., 99.)), -.1, .3 - uv.y) * ls(.35, .28, uv.y)); // grime\n\n    // bottom third pipes\n    p.y = uv.y - .117;\n    c = mix(c, k * .4 * b, ls(.0, -.005, abs(p.y) - .013));\n    c *= 1.\n        + 1.5 * tri(.001, .007, p.y) // bright reflection\n        + 1.5 * tri(.5, .3, fract(uv.x * 77. + .2)) * tri(.0, .01, p.y) // ridges\n    ;\n\n    // vertical pipes (bottom third)\n    //p.x = mod(mod(uv.x, .33) - .02, .1) - .05;\n    p.x = mod(elongate(mod(uv.x, .33), .03), .1) - .05; // slightly uneven repetition\n    p.y = uv.y - .13;\n    c = mix(c, RGB(144, 99, 77) * b, m = ls(.0, -.01, d = box(p, vec2(0, .05)) - .025));\n    c *= 1.\n        - .9 * pow(tri(-.005, .03, d), 4.) // edge shadow\n        + 1.5 * tri(.0, .015, p.x) * tri(.0, .055, p.y) // specular\n    ;\n    p.y += sqr(p.x) * 555. * p.y; // distortion: make ridges appear curved\n    c *= 1.\n        - b * tri(.3, .7, .9, fract(p.y * 55.)) * m // ridges\n        - sqr(tri(.5, .01, uv.y)) // bilinear filtering hack: darken top\n    ;\n\n    // vertical pipe fittings\n    p.y = uv.y - .13;\n    d = abs(d - .005) - .01 * ls(-.05, .05, p.y);\n    c = mix(c, RGB(188, 155, 133) * b * 2. * ls(.06, .01, length(p - vec2(0, .06))), m = ls(.0, -.01, d = max(d, -p.y)));\n\n    c *= 1.\n        - sqr(tri(-.01, .0, .012, d)) // pipe fitting outer shadow\n        //+ .5 * tri(.007, .007, d) // pipe fitting edge highlight\n    ;\n\n    // small rectangular flaps\n    d = box(p - vec2(0, .1), vec2(.025, .007));\n    c *= 1.\n        - .7 * sqr(ls(.02, .005, d)) // shadow\n    ;\n    d = max(d, -box(p - vec2(0, .082), vec2(.015, .02)));\n    c = mix(c, k * b * 1.5, ls(.004, .0, d));\n    c *= 1.\n        + .5 * tri(.0, .004, d) // edge highlight\n    ;\n\n    return c;\n}\n\n// gothic_floor/center2trn (texture)\nTEXA(gcntr2trn) {\n\tfloat\n        b = FBMT(uv -= .5, vec2(5), .9, 3., 4), // base fbm\n        t = .75 + b * b, // base texture intensity (remapped fbm)\n        n = NT(wavy(uv, 7., .02), vec2(17)), // low-frequency variation\n        r = length(uv), // distance from center\n        k = r > .4 ? 38. : r > .32 ? 28. : 16., // number of bricks in circle\n        a = fract(atan(uv.y, uv.x) / TAU), // angle [0..1]\n        i = floor(a * k), // brick number [0..k)\n        r2 = abs(abs(r - .41 - n * .002) * 1e2 - 6.),\n        m = ls(1.5, 1.4, r2), // mask\n\t\trl[] = float[](1., 3., -.145, -1., 2., .166), // 2 rhombus lines: x0, y0, dist0, x1, y1, dist1\n\t\td, ld, s;\n\n    vec2 p = uv;\n    vec3 c = RGB(78, 68, 63); // outer color\n    c *= 1. + .5 * sqr(tri(.49, .005 + .015 * n * n + .015 * b, r)); // highlight outer edge\n\tc = mix(c, RGB(83, 52, 47) * (.6 + .4 * n * n), m) * t;\n\n    c *= 1.\n        - .5 * tri(1.5, .5, r2) // dark outer edge\n        + b * tri(1., .5 + .5 * n, abs(r - .418) * 1e2 - 5.) // edge highlight\n        - b * tri(.5, .08, fract(a * k + .5)) * m // dark edge between bricks in circle\n        + b * tri(.5, .1, fract(a * k + .55)) * m // lit edge between bricks in circle\n        ;\n\n    // inner 3 brick rows\n    m = ls(.34, .33, r); // mask\n    c = mix(c * (1. - .5 * m), RGB(83, 52, 47) * t, n * b * m); // base color\n    c = mix(c, RGB(112, 86, 31) * t, m * sqr(tri(.1, .15, .45, b)));\n    c = mix(c, RGB(77, 66, 77) * t, m * ls(.5, .8, b) * .5);\n    c *= 1. - .7 * tri(.27, .34, .35, r); // soft shadow\n\n    r2 = r + n * .004; // slight distortion\n    m = r > .21 && r < .31 ? 1. : 0.;\n    c *= 1.\n        - tri(.325, .005, r2) // dark edge\n    \t- tri(.31, .005, r2) // dark edge\n        - b * sqr(tri(.29, .005, r2)) // dark edge\n        - b * sqr(tri(.23, .01, r2)) // dark edge\n        - .5 * sqr(tri(.21, .02, r2)) // dark edge\n        + sqr(tri(.3, .01, r2)) * b // highlight\n        + sqr(tri(.22, .01, r2)) * b // highlight\n        - b * tri(.5, .07, fract(a * k + .5)) * m // dark edge between bricks in circle\n        ;\n    // separate ids for each row of bricks\n    if (r < .23) i += 37.;\n    if (r < .31) i += 73.;\n    if (r < .31) i += 91.;\n    c *= mix(1., .9 + .2 * R1(i), m); // vary intensity based on brick id\n\n    // rhombus ring\n    m = ls(.01, .0, abs(r - .411) - .039); // mask\n    i = floor(a * 72.); // base id\n    p *= rot(i * 5.); // polar mod: 360/72 = 5\n    s = 0.;\n    d = 1e6;\n    int j = 0;\n    for (/**/; j < 6; j += 3) { // for each line\n        d = minabs(d, ld = dot(p, normalize(vec2(rl[j], rl[j+1]))) + rl[j+2]); // distance to line\n        s += s + float(ld > 0.); // which side of line 1 we're on\n    }\n    // find rhombus id\n    if (s == 3.)\n        ++i;\n    else\n        i += 66. * s;\n    i = R1(i);\n    c = mix(c, t * RGB(90, 80, 75), m);\n    c = mix(c, t * RGB(127, 111, 88), i * b * m);\n    c *= mix(1., .7 + .6 * H(i), m); // per-tile variation\n    c *= 1.\n        - m * sqr(tri(.0, .006, d)) * b // shadow\n        + m * sqr(tri(.006, .006, abs(d))) * b * .5 // highlight\n        ;\n\n    // inner grill\n    i = floor(a * 4.); // base id\n    p = abs(uv * rot(i * 90. + 45.)); // polar mod + reflection\n    d = 1e6;\n    for (j = 0; j < 2; ++j, p = abs(p * rot(45.)))\n        d = minabs(d, abs(length(p - vec2(0, .12)) - .16));\n    m = ls(.21, .2, r);\n    r2 = onion(onion(d, .012), .001); // grill outline\n    c *= 1.\n        - ls(.21, .2, r) * msk(.012 - d) // dark void under grill\n        + b * m * sqr(tri(.005, .005, d)) // highlight\n        - .5 * m * sqr(msk(r2 - .001, .001)) // darken grill edges\n        ;\n\n    // note: last factor tapers alpha a bit to avoid some ugly aliased corners\n    return vec4(c, (1. - ls(.21, .15, r) * msk(.028 - d, .02)) * ls(.07, .087, r));\n}\n\n// gothic_floor/center2trn (map shader)\nTEXA(gcntr2trn_m) {\n    vec2 p = uv - .5;\n\tfloat b = FBMT(p * rot(Time.x * 333.) * (.8 + .2 * sin(Time.x * 61.)), vec2(53), .7, 2., 4); // 61 ~= TAU * 9.7\n\tvec4\n        c = vec4(1. - b * vec3(0, .3, 1), 1),\n        c2 = gcntr2trn((p * rot(Time.x * 30.) * (.8 + .2 * sin(Time.x * 1.26))) + .5); // 1.26 ~= TAU * .2\n    c.xyz = mix(c.xyz, c2.xyz, c2.w);\n    c2 = gcntr2trn(uv);\n    c.xyz = mix(c.xyz, c2.xyz, c2.w);\n    return c;\n}\n\nfloat scmpblk17_sdf(vec2 p) {\n    p = pmod(p, 8.);\n    float d = circ(p, .41);\n    d = min(d, box((p - vec2(.34, 0)) * rot(45.), vec2(.1)));\n    d = max(d, p.x - .45);\n    return d;\n}\n\n// sfx/computer_blocks17 (texture)\nTEX(scmpblk17) {\n    vec2\n        p = uv - .5,\n        q;\n    float\n\t\tb = FBMT(uv, vec2(9), .7, 3., 4), // base FBM\n\t\tt = .8 + .8 * b * b, // base texture intensity (remapped FBM)\n        r = circ(p, .41), // outer ring SDF\n        d = scmpblk17_sdf(p), // base SDF\n        l = dFdy(d) / .004, // top light\n        m = msk(d + .01, .007), // SDF mask\n        a = nang(p), // normalized angle\n\t\te, n, x, z;\n    vec3\n        c = NO_COPY_PASTE gblks15(uv) NO_COPY_PASTE, // base color (stone blocks)\n        k = RGB(155, 135, 115) * t; // metallic color\n    c *= 1.\n        - (.5 * -l + .5) * ls(.03, .0, d) // outer shadow\n        ;\n    c = mix(c, k, m); // metallic background\n    e = length(p) * 9.;\n    q.x = a * floor(e + 1.) * 3.;\n    q.y = fract(e);\n    n = tri(.5, .2, NT(wavy(uv, 7., .03), vec2(41)));\n    n = FBMT(q, vec2(3, 9), .5, 2., 4) * tri(.5, .5 + .5 * n, q.y); // polar noise\n    c = mix(c, RGB(100, 85, 80) * ridged(n) * b, msk(r + .15, .02)); // inner vortex\n\n    q = p;\n    q.x = abs(p.x);\n    e = max(max(d, half_plane(q, -vec2(.08, .4))), abs(r + .06) - .09); // top clamp\n    z = box(q - vec2(0, .3), vec2(.01, .03));\n    e = exclude(e, z - .02);\n    x = msk(-e, .01); // mask that excludes the top clamp\n\n    /* ring wires */\n    c = mix(c, wire_ring(c, uv, .32, .025), x);\n\n    c *= 1.\n        + l * m * ls(.02, .0, -d) * ls(.01, .0, -r) // outer edge lighting\n        + x * tri(.035, .015, -r) // outer ring highlight\n        + .5 * x * tri(.13, .01, -r) // inner ring highlight\n        + .7 * tri(.08, .007, z) * (1. - x) // top clamp highlight\n        - .7 * x * sqr(tri(.01, .04, -r)) // outer ring outer shadow\n        - .6 * x * sqr(tri(.13, .06, .03, -r)) // outer ring inner shadow\n        - .5 * x * sqr(tri(.12, .02, -r)) * m // inner ring outer shadow\n        - .9 * sqr(tri(.12, .15, .2, -r)) * m // inner ring inner shadow\n        - .5 * sqr(tri(.0, .05, e)) // top clamp outer shadow\n        ;\n\n    c += vec3(.8, .8, 1) * pow(sat(1. - length(uv - vec2(.41, .59)) / .35), 8.); // specular\n\n\n    /* bottom clamp */\n    e = box(p + vec2(0, .33), vec2(.01, .03)) - .03; // SDF\n    l = dFdy(e) / .004; // top light\n    c = mix(c, k * (.4 + .8 * ls(.25, .41, -p.y)), z = msk(e, .01)); // base color\n    c *= 1.\n        + .7 * tri(.005, .01, e) * l // edge lighting\n\t\t- .5 * tri(.0, .01, .05, e) // outer shadow\n        ;\n\n    /* led box */\n    e = box(q = p + vec2(0, .35), vec2(.01, .015)) - .01; // SDF\n    l = dFdy(e) / .004; // top light\n    c *= 1.\n        + .5 * tri(.005, .01, e)\n        - .5 * sqr(tri(.0, .01, e))\n        ;\n    c += vec3(1, .7, .5) * pow(sat(1. - length(q) / .11), 8.); // light glow\n\n    return c;\n}\n\n// sfx/computer_blocks17 (map shader)\nvoid scmpblk17_m() {\n    vec3 c = scmpblk17(fract(UV)); // actual shader applies lightmap here\n\n    vec2\n        uv = fract(UV) - .5,\n        p = uv;\n    float\n        t = mod(Time.x * 2., 7.),\n        i = floor(t),\n        d = 1e6;\n\n    if (i == 0.)\n\t\td = sdf_Q(p * 2.4 + vec2(0, .05));\n\n    if (i == 1.) {\n        p.x = repeat(p.x, .1, -1., 1.); // repeat x3\n        d = box(p, vec2(.02, .15)) * 2.;\n    }\n\n    if (i == 2.) {\n        // A\n        d = min(d, box(mirr(p, .0) + vec2(.13 - ls(-.3, .3, uv.y) * .17, 0), vec2(.02, .15)));\n        d = min(d, box(p + vec2(0, .07), vec2(.07, .02))) * 2.;\n    }\n\n    if (i == 4.)\n\t\td = icon_sdf(p * 1.8, .5);\n\telse\n        d = onion(d, .005);\n\n    FCol = vec4(c + msk(d, .02) * fract(-t) * vec3(.5, .05, .05), 1);\n}\n\n// gothic_wall/slateroofc\nTEX(gsltrfc) {\n    vec2\n        p = brick(uv, vec2(6, 4)),\n        q = fract(p),\n        u = q;\n\tfloat\n        b = FBMT(wavy(uv -= .5, 5., .03), vec2(13), .9, 2., 3), // base fbm\n        n = NT(uv, vec2(73, 7)),\n        t = (.75 + b * b) * (.8 + .4 * SR1(uv.x * 93.)), // base texture intensity (remapped fbm)\n        r\n        ;\n\n    vec3 c = vec3(.25 * t);\n    u.y += u.y * 2. -.01 - .03 * n;\n    r = length(u -= clamp(u, vec2(.49, .5), vec2(.51, 3)));\n    c *= 1.\n        - .7 * b * sqr(ls(.07, .03, abs(r - .5)))\n        + .5 * b * tri(.35, .1, r) * sqr(ls(.2, .1, q.y))\n        - .3 * sqr(ls(.8, 1., q.y))\n        - .3 * (ls(.3, .1, q.y)) * ls(.4, .6, r)\n        + .2 * sqr(ls(.5, .1, q.y)) * ls(.45, .4, r)\n        ;\n    \n    return c;\n}\n\n// gothic_trim/pitted_rust3\nTEX(gtprst3) {\n\tfloat\n        b = FBMT(uv, vec2(13), .9, 3., 4),\n        n = FBMT(uv, vec2(7), .9, 3., 4);\n    vec3\n        c = mix(RGB(60, 50, 50), RGB(87, 47, 37), sqr(ls(.7, .25, n))) * (.7 + .8 * b * b),\n        g;\n    \n    uv = wavy(uv, 31., .003);\n    EVAL_GRAD(\n        g, uv,\n        sqrt(ls(.0, .9, NT(p[i], vec2(93))))\n\t);\n\n    c *= 1. - (g.y + .4) * sqr(b * g.z) * g.z;\n\n    return c;\n}\n\n\n// gothic_trim/skullsvertgray02b\nTEX(gsklvtg02b) {\n\tfloat\n        b = FBMT(uv, vec2(5), .9, 3., 4);\n    vec3\n        c = RGB(67, 64, 63) * (.6 + .5 * b),\n        g;\n\n    uv = wavy(uv, 31., .003);\n    EVAL_GRAD(\n        g, uv,\n        sqrt(NT(p[i], vec2(53, 93)))\n\t);\n\n    c *= 1. - .3 * g.y * g.z * g.z;\n\n    return c;\n}\n\n// skin/chapthroat\nTEXA(skcpthrt) {\n    uv = wavy(uv, 7., .01);\n\tfloat\n        b = FBMT(uv, vec2(9), .7, 2., 4),\n        n = FBMT(uv, vec2(13), .5, 2., 4),\n        m = ls(.6, .9, FBMT(wavy(uv, 5., .03), vec2(11), .6, 2., 4))\n        ;\n\tvec3 c = RGB(127, 70, 55) * (.85 + .3 * b);\n\tc *= 1.\n        - .2 * sqr(ls(.3, .0, b * b))\n        - .2 * m\n        - .3 * ls(.6, .77, n)\n        + .3 * ls(.5, .9, b)\n        ;\n    c += .5 * sqr(ls(.5, 1., FBMT(uv, vec2(17), 1., 2., 3)));\n\treturn vec4(c, 1. - m);\n}\n\n// skin/chapthroatooz\nTEX(skcpthrtooz) {\n    vec4 c = skcpthrt(uv);\n    uv.y -= .2 * Time.x;\n    float b = FBMT(wavy(uv, 7., .02), vec2(5), .9, 2., 4);\n    return mix(RGB(25, 10, 8) * b, c.xyz, c.w);\n}\n\n// skin/chapthroat2\nTEX(skcpthrt2) {\n    vec2 p = uv - .5;\n    p = wavy(p, 17., .007);\n    p.x *= 2. - uv.y * 1.5;\n    float\n\t\tb = FBMT(uv, vec2(9), .7, 2., 4),\n    \tn = NT(uv, vec2(7)),\n        d = length(p),\n        s;\n    vec3 c = skcpthrt(uv).xyz;\n    s = fract(d *= 13.);\n    if (d <= 6.) {\n        c *= 1.\n            - pow(ls(6., .5, d + b * b), 6.) // darken interior\n            ;\n        n = ls(.3, .7, n); // remap noise\n        c *= 1.\n\t\t\t- n * b * tri(.4, .2, s) // darken edges\n\t\t\t+ n * b * tri(.6, .4, s) // highlight edges\n            ;\n    }\n    return c;\n}\n\n// skin/tongue_trans\nTEX(sktongue) {\n    uv = wavy(uv, 13., .003);\n\tfloat\n        b = FBMT(uv, vec2(7), .9, 3., 4), // base FBM\n        n = FBMT(uv, vec2(5), .5, 2., 4), // smoother FBM\n        t = .5 + b // base texture intensity (remapped fbm)\n        ;\n\tvec3\n        c = RGB(80, 38, 34), // base color\n        v = voro(uv, vec2(23));\n    c = mix(c, mix(RGB(180, 125, 118), RGB(165, 78, 51), n), b * tri(.0, .4 + n * .4, v.z)) * t;\n\treturn c;\n}\n\n// skin/surface8\nTEX(gsksurf8) {\n\tfloat\n        b = FBMT(uv, vec2(7), .9, 3., 4), // base FBM\n        t = .8 +.4 * b, // base texture intensity (remapped FBM)\n        i, // cell ID\n        r = .7, // radius\n        l, // light intensity\n        m // mask\n        ;\n\tvec3\n        c, // base color\n        v = voro(uv, vec2(23)); // voronoi diagram\n    vec2\n        p = v.xy / r,\n        q = uv + v.xy / 23.;\n\n    i = H(fract(q) * 3.3);\n    c = mix(RGB(155, 55, 55), RGB(200, 166, 155), ls(.75, .45, q.y)) * t;\n    m = tri(.5, .5, length(p));\n    l = dot(vec2(-p.y, sqrt(sat(1. - lsq(p)))), vec2(.6 + i * .3, .3));\n    c *= 1.\n        - b * .8 * ls(.5, .1, v.z)\n    \t+ b * m * l\n        ;\n    c *= t * t * t * t; // add some noise\n\n\treturn c;\n}\n\n// gothic_wall/skull4\nTEX(gskull4) {\n\tfloat\n\t\tb = FBMT(uv, vec2(13), .9, 3., 4), // base FBM\n\t\tt = .4 + b * b, // base texture intensity (remapped FBM)\n\t\tn = ridged(NT(wavy(uv, 12., .02), vec2(48))),\n\t\ti, r, l, m;\n\tvec3\n\t\tc = RGB(60, 50, 46) * t, // base color\n\t\tv = voro(uv, vec2(17)); // voronoi diagram\n\n\ti = H(fract(uv + v.xy / 17.)); // cell ID\n\tr = .4 + .3 * i; // skull size (varies per cell)\n\tvec2 p = v.xy / r; // normalized offset from skull center\n    m = min(ls(1.1, 1., length(p)), ls(.0, .15, v.z)); // skull region mask\n\tl = dot(vec2(-p.y, sqrt(sat(1. - lsq(p)))), vec2(.1 + i * .2, .3)); // light intensity (varies per cell)\n\tc += b * m * l * n;\n\n\tn = ridged(FBMT(wavy(uv, 13., .01), vec2(23, 43), .5, 2., 3)); // stretched, wavy noise\n    c *= 1. + (1. - m) * tri(.4, .4, n); // light variation between skulls (simulating bones)\n\n    return c;\n}\n\n/*\nTEX(gskull4) {\n\tfloat\n        b = FBMT(uv, vec2(13), .9, 3., 4), // base FBM\n        t = .4 + b * b, // base texture intensity (remapped FBM)\n        n = ridged(NT(wavy(uv, 12., .02), vec2(48))),\n        i, // cell ID\n        r, // skull size (varies per cell)\n        l, // light intensity\n        m // skull mask\n        ;\n\tvec3\n        c = RGB(60, 50, 46) * t, // base color\n        v = voro(uv, vec2(17)); // voronoi diagram\n\n    i = H(fract(uv + v.xy / 17.));\n    r = .4 + .2 * i;\n    vec2 p = v.xy / r;\n    m = min(ls(1.1, 1., length(p)), ls(.0, .5 * i, v.z));\n    l = dot(vec2(-p.y, sqrt(sat(1. - lsq(p)))), vec2(.1 + i * .3, .3));\n    c += b * m * l * n;\n    \n\tn = FBMT(wavy(uv, 13., .01), vec2(23, 43), .5, 2., 3);\n    c *= 1. - (1. - m) * ls(.0, .4, abs(n - .5));\n\n\treturn c;\n}\n*/\n\n// base_trim/basemetalsupport\nTEX(bmtsprt) {\n\tfloat\n\t\tb = FBMT(uv, vec2(7, 3), .9, 3., 4),\n\t\th = uv.y + b * .04;\n\tvec3 c = mix(RGB(50, 40, 34), RGB(93, 92, 88), b * b);\n\tc *= 1.\n\t\t+ .9 * ls(.07, .04, abs(uv.y - .44))\n\t\t- .4 * ls(.08, .05, abs(uv.y - .7))\n\t\t- .5 * tri(.34, .05, uv.y)\n\t\t- .3 * tri(.7, .04, uv.y)\n\t\t+ .7 * tri(.01, .03, uv.y)\n\t\t+ 1.5 * tri(.89, .1, h)\n\t\t+ 1.3 * tri(.5, .04, h)\n\t\t+ .9 * tri(.18, .04, h)\n\t\t;\n\treturn c;\n}\n\n// gothic_trim/metalsupsolid\nTEX(gmtlspsld) {\n\tfloat\n        b = FBMT(uv, vec2(7), .9, 3., 4),\n    \tn = FBMT(uv, vec2(3), .5, 3., 4);\n\tvec3 c = mix(RGB(103, 56, 53), RGB(73, 58, 71), ls(.1, .7, n)) * (.75 + b * b);\n\treturn c;\n}\n\n// gothic_trim/metalsupport4b\nTEX(gmtlsp4b) {\n\tfloat\n        b = FBMT(uv, vec2(13), .9, 3., 4),\n    \tn = NT(wavy(uv, 5., .05), vec2(9)),\n        d = ridged(fract(uv.x * 4.)),\n        m = ls(.1, .15, d) * ls(1., .99, uv.y);\n\tvec3 c = RGB(51, 44, 44);\n    c = mix(c, RGB(73, 55, 52), ls(.2, .2, b) * n * m);\n    c = mix(c, RGB(69, 60, 66), ls(.7, .1, b) * b * m);\n    c = mix(c, RGB(99, 77, 77), ls(.1, .5, n) * n * m * b * b * .3);\n    c *= .6 + .3 * b + .3 * b * b;\n    c *= 1. + .9 * sqr(tri(.21, .02 + .1 * n, d + b * .05)) * m * b;\n    c *= 1. - sqr(ls(.49, .5, abs(uv.y - .5)));\n    c *= 1. - ls(.05, .2, d) * ls(.16, .1, d);\n    c *= 1. + tri(.99, .007, uv.y);\n    return add_rivet(c, vec2(d - .4, fract(uv.y * 8.) - .5), .07);\n}\n\nvec3 gspbdrbb_v(vec2 uv, float s)  {\n\tfloat\n\t\tb = FBMT(uv, vec2(3, 1. + s + s), .7, 2., 4),\n\t\td = ridged(uv.x),\n\t\tm;\n\tuv.y *= 2.;\n\tvec3 c = mix(RGB(71, 60, 58), RGB(110, 88, 77), ls(.1, .05, d)) * (.7 + .6 * b);\n\tc *= 1. - ls(.05, .0, uv.x) * (1. - b * b);\n\tc *= 1. + .5 * tri(.05, .02, uv.x);\n\tvec2 p = vec2(d - .35, fract(uv.y * s) - .5);\n\tvec4 k = rivet(p, .11);\n\tm = msk(k.w);\n\tc *= 1. - .7 * rivet_shadow(p, 1.1) * (1. - m);\n\tc = mix(c,\n\t\t\t(k.y > .0 ? RGB(128, 105, 88) : RGB(200,111,66) * ls(-.2, .7, k.z)) *\n\t\t\t(.4 + 2. * b * pow(sat(sum(k.yz * .7)), 4.)) *\n\t\t\t(1. - .6 * tri(-.1, .4, k.y)),\n\t\t\tm);\n\treturn c;\n}\n\n// gothic_wall/supportborder_blue_b\nTEX(gspbdrbb) {\n\treturn gspbdrbb_v(uv, 4.);\n}\n\n// gothic_trim/km_arena1tower4_a\nTEX(gkarntwr4a) {\n\treturn gspbdrbb(uv.yx);\n}\n\n// gothic_trim/km_arena1tower_short\nTEX(gkarntwrst) {\n\treturn gspbdrbb_v(uv, 1.);\n}\n\n// gothic_floor/xstairtop4\nTEX(gxstrtop4) {\n\tfloat b = FBMT(uv, vec2(40, 5), .9, 3., 4);\n\tvec3 c = RGB(110, 110, 98) * (.8 + .8 * b * b);\n    if (uv.y < 1./4.)\n        c *= .5;\n    c *= 1.\n        - .4 * ls(.4, .0, b)\n        + .5 * ls(.02, .0, uv.y)\n        + .2 * tri(.24, .01, uv.y)\n        ;\n\treturn c;\n}\n\n// gothic_floor/xstairtop4bbrn\nTEX(gxstrtop4bbrn) {\n\tfloat\n        e = step(.25, uv.y),\n        b = FBMT(uv, vec2(40, 5), .7 + .2 * e, 2. + e, 4);\n\tvec3 c = (RGB(96, 64, 44) - e * RGB(8, 4, 4)) * mix(.5, 1.5, b);\n\tc *= 1.\n        + 1.5 * ls(.03, .01, uv.y) // highlight\n        - .7 * sqr(tri(.24, .25, .35, uv.y)) // shadow\n\t;\n\treturn c;\n}\n\n// gothic_floor/xstepborder3brn\nTEX(gxstpbrdr3brn) {\n\tfloat b = FBMT(uv, vec2(40, 5), .7, 2., 4);\n\tvec3 c = RGB(88, 60, 40) * mix(.5, 1.5, b);\n\tc *= 1.\n        + 3. * sqr(ls(.9, .99, uv.y)) // strong top highlight\n        + .2 * tri(.04, .02, uv.y) // subtle bottom highlight\n        - .3 * ls(.03, .0, uv.y) // bottom shadow\n\t;\n\treturn c;\n}\n\n// gothic_ceiling/woodceiling1a\nTEX(gwdclg1a) {\n    vec2 p = uv, q;\n    p.y *= 22.;\n    q = fract(p);\n    float\n        b = FBMT(uv, vec2(3, 23), 1., 2., 6),\n        n = FBMT(uv, vec2(3, 33), .7, 3., 4),\n        id = H(p.y - q.y);\n    vec3 c = RGB(92, 67, 53) * (.8 + .8 * b * b);\n    c *= 1. - sqr(ls(.1, .0, min(q.y, 1. - q.y))) * b;\n    c *= 1. - .2 * smoothstep(.3, .7, n);\n    //c *= 1. - .5 * sqr(tri(.5, .01, fract(p.x + id))) * b;\n    c *= .8 + .3 * b * id;\n    return c;\n}\n\n// gothic_ceiling/woodceiling1b_dark\nTEX(gwdclg1bd) {\n\tfloat\n        b = FBMT(uv, vec2(13), .9, 3., 4),\n        x = uv.x * 16./3.;\n    vec3 c = gwdclg1a(uv) * ls(.15, .21, uv.x);\n    if (x < 1.)\n        c = RGB(59, 48, 49) * (.7 + .6 * b);\n    c *= 1. + .5 * tri(.05, .05, ridged(x));\n    return add_rivet(c, vec2(abs(uv.x - 3./32.) - .07, mod(uv.y, .1) - .05), .004);\n}\n\n// base_light/baslt4_1_4k\nTEXA(blt414k) {\n\tfloat b = FBMT(uv, vec2(1, 5), .4, 3., 4); // base FBM\n\tvec3 c = mix(RGB(56, 49, 43), RGB(142, 136, 136), b); // base color\n\tuv = .5 - abs(uv - .5); // mirror horizontally and vertically\n\tuv.y *= 4.; // aspect ratio correction\n\tfloat\n\t\ta = tri(.0, .1, length(uv - seg(uv, vec2(.41, .5), vec2(.42, 3.5)))), // neon light mask\n\t\td = mn(uv), // edge distance\n\t\tl = 1. - .7 * max(0., 1. - d / .15); // darken edges\n\tl *= 1. - .8 * ls(.24, .31, min(d, uv.y - .1)); // darken inner area around neons\n\tuv.y = mod(uv.y, .875); // repeat vertically\n\tc = add_rivet(c, uv - vec2(.17, .25), .04, .2, .5) // knobs\n\t\t+ RGB(80, 80, 20) * a // yellow neon lights\n\t\t;\n\treturn vec4(c * mix(l, 2.7, a), a);\n}\n\n// base_light/light5_5k\nTEXA(light5) {\n\tfloat b = FBMT(uv, vec2(1, 5), .4, 3., 4);\n\tvec3 c = mix(RGB(56, 49, 43), RGB(142, 136, 136), b);\n\tuv = .5 - abs(uv - .5);\n\tuv.y *= 8.;\n\tfloat\n\t\td = length(uv - seg(uv, vec2(.27, .3), vec2(.27, 7.7))),\n\t\ta = tri(.0, .17, d),\n\t\tl = 1. - .5 * tri(.17, .07, d);\n\tc += RGB(80, 80, 20) * a;\n\treturn vec4(c * mix(l, 2.7, a), a);\n}\n\n// base_light/lt2_2000\n// base_light/lt2_8000\nTEXA(lt2) {\n    float b = FBMT(uv, vec2(1), .4, 3., 4);\n    vec3 c = mix(RGB(56, 49, 43), RGB(142, 136, 136), b);\n    vec2 p = abs(uv - .5);\n    float r = length(p);\n    float a = ls(.37, .33, r) * (.5 + 2. * b);\n    float l = 1. + .0 * ls(.08, .03, abs(r - .41));\n    l = mix(l, 7., ls(.44, .1 * b, r));\n    l *= 1. - .5 * sqr(tri(.46, .04, r));\n    l *= 1. - .4 * sqr(tri(.36, .04, r));\n    return vec4(c * l, a);\n}\n\n// gothic_light/pentagram_light1_1k\nTEXA(gpntgmlt1k) {\n    float\n        b = FBMT(uv, vec2(5), .9, 3., 4),\n        d = smin(pentagram(uv-=.5, .35), abs(circ(uv, .4)), .02),\n        a = pow(msk(d - .02, .15), 8.),\n        o = min(max(box(uv, vec2(.46)), -circ(uv, .51)), abs(circ(uv, .44)));\n    vec3 c = RGB(76, 62, 47) * (.8 + .8 * b * b);\n    c *= 1. + (b + .5) * msk(abs(o) - .01, .01);\n    c *= 1. - ls(.1, .05, d) * msk(circ(uv, .4));\n    return vec4(c + 1.*vec3(1, 1, .3) * a, a);\n}\n\nfloat mtltech(vec2 uv) {\n    float b = NT(uv, vec2(64)), f = 0., d = 1e6;\n    for (/**/; f < 11.; ++f)\n        d = smin(d, abs(length(.5 - abs(uv - R2(f))) - mix(.36, .29, R1(f + .7))) - mix(.015, .03, b), .01);\n    return d * 1e2;\n}\n\nvec3 mtltech_d(vec2 uv) {\n    vec3 s, p;\n    for (int i=0; i<3; ++i) {\n        p = vec3(uv, 0);\n        p[i] += 1e-4;\n        s[i] = mtltech(p.xy);\n    }\n    return vec3(normalize(s.xy - s.z), s.z);\n}\n\n\n// base_wall/metalfloor_wall_10\nTEX(mtlfw10) {\n\tfloat b = FBMT(uv, vec2(5), .9, 3., 4);\n\tvec3 c = mix(RGB(44, 14, 16), RGB(93, 63, 63), b * b);\n\treturn c;\n}\n\n// base_wall/metaltech12final\nTEX(mtlt12f) {\n\tfloat b = FBMT(uv, vec2(5), .9, 3., 4), l;\n\tvec3 c = mix(RGB(51, 46, 43), RGB(165, 147, 143), b * b), d = mtltech_d(uv);\n\tl = 1. - .5 * (d.y - d.x) * tri(.5, 3., d.z) * ls(1., .0, d.z);\n\treturn c * l * .8;\n}\n\n// base_wall/metaltech06final\nTEX(mtlt6f) {\n    float b = FBMT(uv, vec2(3), 1.1, 3., 4), l;\n    vec3 c = mix(RGB(51, 46, 43), RGB(165, 147, 143), b * b);\n    vec3 d = mtltech_d(uv);\n    //d *= 1e1;\n    //d /= 2.;\n    l = 1. - .5 * (d.y - d.x) * tri(.5, 3., d.z) * ls(1., .0, d.z);\n    l -= .5 * tri(-1.5, 1.5, d.z);\n    return c * l;\n    //!return c * (.9 - .3 * (n.y - n.x) * tri(.5, .5, d) - .5 * b * (n.y - n.x));\n\t//return c * (.9 - 3. * (n.y - n.x) * tri(-.5, .5, d) + 2. * b * (n.y - n.x) * tri(1., .5, d));\n/*    l = 1. + tri(.5, 1., d) * max(n.x, 0.) * b;\n    l -= b * b * 8. * tri(-4., 4., d * d * sign(d));\n    return c * l;\n*/\n}\n\n// xy = tile id, z = edge\nvec3 mtlfw15_d(vec2 uv) {\n    float e = 2e-3, a = 0.;\n    vec2 g = vec2(6), r = voro1(uv, g).xy;\n    for (int i=0; i<9; ++i)\n        a += sum(abs(voro1(vec2(i % 3 - 1, i / 3 - 1) * e + uv, g).xy - r));\n    return vec3(uv + r.xy / g, a);\n}\n\n// base_wall/metalfloor_wall_15\nTEX(mtlfw15) {\n    float b = FBMT(uv, vec2(3), .9, 3., 4);\n    vec3 c = mix(RGB(80, 70, 72), RGB(128, 120, 120), b * b);\n    vec3 v = mtlfw15_d(uv);\n    c *= mix(.95, 1.1, NT(v.xy, vec2(6)));\n    c = mix(c, RGB(168, 128, 120), ls(.5, 1., v.z) * b * .7);\n\treturn c;\n}\n\n// base_wall/metalfloor_wall_15ow (texture)\nTEXA(mtlfw15ow) {\n    float b = FBMT(uv, vec2(3), .9, 3., 4);\n    vec3 c = mix(RGB(80, 70, 72), RGB(128, 120, 120), b * b);\n    vec3 v = mtlfw15_d(uv);\n    float m = ls(.5, 1., v.z);\n    float r = ls(.4, .2, length(.5 - fract(v.xy)));\n    c *= mix(.95, 1.1, NT(v.xy, vec2(6))) - 2. * r * b * b;\n    c = mix(c, RGB(168, 128, 120), m * b * .7);\n\treturn vec4(c, m * r);\n}\n\n// Window icon\nTEXA(icon) {\n    uv -= vec2(.48, .5);\n    float\n        d = icon_sdf(uv, 0.),\n        b = length(uv) - .47;\n    vec3 c = 1. - vec3(.5, 1, 1) * msk(max(.007 - d, b + .04));\n    return vec4(c, 1) * msk(b);\n}\n\n// sfx/logo512\nTEX(bglogo) {\n    uv -= .5;\n\n    float\n\t\tx = abs(uv.x),\n\t\tb = FBMT(uv, vec2(31, 5), .7, 2., 3), // base FBM - mostly vertical noise\n\t\tt = .8 + .8 * b * b, // intensity variation (remapped FBM)\n\t\td = icon_sdf(uv, 1.), // logo SDF\n\t\te = icon_sdf(uv + vec2(0, .002), 1.), // offset logo SDF, for lighting\n\t\tl = (e - d) * 5e2 + .5 // lighting\n\t\t;\n\tvec3 c = vec3(.3 * t, 0, 0) * msk(d, .004); // base color\n\tc *= 1.\n\t\t- sqr(ls(.0, .3, x)) // horizontal gradient\n\t\t- .5 * ls(.1, .3, abs(uv.y - .1)) // vertical gradient\n\t\t;\n\tc +=\n\t\t+ t * .2 * tri(.0, .01 - .01 * x, d) * tri(.1, .2, uv.y) * ls(.3, .2, x) * l // top light\n\t\t+ t * .5 * ls(.004, .0, d) * ls(.07, .1, uv.y) * tri(.23, .1, x) * vec3(.9, .9, 1) // back light\n\t\t+ t * .4 * tri(.005, .005, d) * ls(.2, -.1, uv.y) * ls(.3, .2, x) * sat(-l) // bottom light\n\t\t;\n        \n    return c;\n}\n\nfloat banner_fold(vec2 uv, float s, float i, float amp) {\n    i = (uv.y - sqr(abs(uv.x - .5)) * amp) * s - i;\n    return 2. * tri(.5, .4, i) * (fract(i) - .5);\n}\n\n// base_wall/protobanner (texture)\nTEXA(bwprtbnr) {\n\tfloat\n\t\tb = FBMT(uv, vec2(5, 9), .9, 3., 4), // base FBM\n\t\tt = .8 + .8 * b * b, // base texture intensity (remapped FBM)\n        n = FBMT(uv, vec2(5, 9), .9, 3., 2), // noise (for ragged edges)\n        x = abs(uv.x - .5), // distance from center\n        d, // sdf\n        f;\n\tvec3 c = RGB(77, 60, 44) * t; // base color\n    vec2 p = uv * vec2(1, 2) - vec2(.5, .7);\n    c *= 1. - .55 * msk(exclude(circ(p, .3), icon_sdf(rot(45.) * p * .8, 0.) - .01)); // logo\n    c *= 1.\n        + sqr(ls(.6, .9, b)) // noisy highlights\n        + tri(.2, .5, uv.y) * tri(.2, .3, x) * banner_fold(uv, 4., .2, 4.) // bottom fold\n        ;\n    // TODO: eliminate loop\n    for (f = 6.; f < 9.; ++f)\n       \tc *= 1. + tri(.8, .5, uv.y) * tri(.2, .3, x) * banner_fold(uv, 12., f, 1.); // top fold\n    d = uv.y - .81 - sqr(sat(x * 4.)) * .09;\n    c = mix(c, RGB(82, 66, 60) * t, ls(.0, .01, d));\n    c *= 1.\n        - .5 * (tri(.01, .02, d)) // support shadow\n        + .5 * (tri(.02, .01, d)) // support highlight\n        ;\n    d = .15 * (1. - uv.y); // corner rounding amount; it should be 0.3, but the lightmapper doesn't do alpha testing\n    d = box(uv - .5, vec2(.49) - d) + n * .1 * sqrt(1. - uv.y) - d; // box with y-varying raggedness\n    return vec4(c * sqr(msk(d + .01, .05)), msk(d));\n}\n\n// QUAKE III sdf\nfloat quakeiii_sdf(vec2 uv) {\n\tuv *= vec2(256, 64);\n\t// Q\n\tfloat d = circ(uv - vec2(81, 30), 11.);\n\td = max(d, uv.x - 80.);\n\td = max(d, -circ(uv - vec2(84, 26), 9.));\n\td = min(d, box(uv - vec2(73, 37), vec2(4, 9)) - 4.);\n\td = max(d, -box(uv - vec2(73, 37), vec2(0, 7)) + 1.);\n\t// U\n\td = min(d, box(uv - vec2(91.5, 47), vec2(4, 19)) - 4.);\n\td = max(d, -box(uv - vec2(91.5, 47), vec2(0, 17.5)) + 1.);\n\t// A\n\td = min(d, box1(mirr(uv, 111.) - vec2(105. + ls(23., 50., uv.y) * 3., 43), vec2(3.5, 19)));\n\td = min(d, box1(uv - vec2(111, 32), vec2(6, 3)));\n\t// K\n\td = min(d, box1(uv - vec2(126, 37), vec2(3, 13)));\n\td = min(d, box1(uv - vec2(125.5 + ls(23., 50., uv.y) * 10., 44), vec2(3.5, 6)));\n\td = min(d, box1(uv - vec2(136.5 - ls(23., 50., uv.y) * 9., 32), vec2(3.5, 8)));\n\t// E\n\td = min(d, box1(uv - vec2(148.5, 37), vec2(7, 13)));\n\td = max(d, -box1(uv - vec2(155, 33), vec2(6, 3)));\n\td = max(d, -box1(uv - vec2(155, 43), vec2(6, 2)));\n\t// III\n\td = min(d, box1(uv - vec2(168, 37), vec2(3.5, 13)));\n\td = min(d, box1(uv - vec2(178, 37), vec2(3.5, 13)));\n\td = min(d, box1(uv - vec2(188, 37), vec2(3.5, 13)));\n\n\treturn max(d, uv.y - 50.);\n}\n\n// ARENA sdf\n// s = scale\nfloat arena_sdf(vec2 uv, float s) {\n\tuv *= vec2(256. * s, 64);\n\tfloat d = 1e6;\n\t// R\n\tuv.x -= s * 106.;\n\td = min(d, max(-uv.x - 1., onion(box(uv - vec2(-.5, 19.25), vec2(2, .5)) - .75, .5)));\n\td = min(d, box1(uv - vec2(1. + (18. - uv.y) * .5, 16.5), vec2(.5, 1.5)));\n\td = min(d, box1(uv - vec2(-1, 18), vec2(.5, 3)));\n\t// E\n\tuv.x -= s * 24.;\n\td = min(d, box1(uv - vec2(0, 18), vec2(2, 3)));\n\td = max(d, -box1(uv - vec2(1.5, 19.5), vec2(2.5, 1)));\n\td = max(d, -box1(uv - vec2(1.5, 17), vec2(2.5, 1)));\n\t// N\n\tuv.x -= s * 24.;\n\td = min(d, box1(uv - vec2(-2, 18), vec2(.5, 3)));\n\td = min(d, box1(uv - vec2(2, 18), vec2(.5, 3)));\n\td = min(d, box1(uv - vec2((18. - uv.y) * .5, 18), vec2(.7, 3)));\n\t// A\n\tuv.x = mirr(uv.x + s * 68., s * 46.);\n\td = min(d, box1(mirr(uv, 0.) - vec2((uv.y - 21.) * .33, 18), vec2(.5, 3)));\n\td = min(d, box1(uv - vec2(0, 16.5), vec2(1, .25)));\n\treturn d;\n}\n\n// base_wall/main_q3abanner\nTEXA(q3bnr) {\n    return vec4(msk(min(quakeiii_sdf(uv), arena_sdf(uv, 1.)), .8), 0, 0, H(uv * 511.));\n}\n\n// main menu banner (texture)\nTEXA(menubnr) {\n    return vec4(sat(1. - 1.4 * abs(quakeiii_sdf(uv))) * (NT(uv, vec2(256, 64)) * .7 + .3), 0, 0, sat(3. - 6. * arena_sdf(uv, .7)));\n}\n\n// main menu banner (menu shader)\nvoid menubnr_m() {\n    vec2 uv = UV - .5;\n\tuv.y = (uv.y - .16) * 7.;\n    FCol = mx(abs(uv + vec2(0, .23)) / vec2(.55, .2)) > .4 ?\n            vec4(0) :\n            menubnr(uv + .51).w\n        \t* FBMT(uv - vec2(.2 * N(Time.x), Time.x), vec2(7, 3), .7, 2., 4)\n        \t* vec4(2, 1, .3, 0);\n    if (mx(abs(uv - vec2(0, .15)) / vec2(.77, 1)) > .4)\n        return;\n\n    float\n        n = H(uv * 133.7 + Time.x),\n        k = 1./48.,\n        s = pow(1.2, k),\n        i = n * k\n\t;\n    vec2 p;\n    uv /= mix(1., s, n);\n    for (; i < 1.; i += k) {\n\t\tuv.x += (N(.37 * Time.x) - .5) * k / 48.;\n\t\tuv.y += (N(.21 * Time.x) - .5) * k / 32.;\n        p = uv /= s;\n        p.y -= i * .15;\n        p.x *= 1. + p.y * .15;\n        vec4 c = menubnr(p + .5);\n\t\tFCol += c.x * (1. - i) * k * vec4(32, 16, 4, 0);\n\t}\n}\n\n// skies/tim_hell\nvoid timhel() {\n\tvec2 uv = UV;\n\tfloat b = ls(.2, 1., FBMT(uv - Time.x * vec2(.1, .2), vec2(5), .5, 2., 6));\n\tuv.y *= 1.5;\n\tfloat s = ls(.3, 1., FBMT(uv - Time.x * vec2(.1, .18), vec2(5), .6, 2., 6));\n\tFCol = vec4(vec3(b, 0, 0) + RGB(80, 30, 8) * s * s * 2., 1);\n}\n\n// liquids/lavahellflat_400\n// liquids/lavahell_750\nvoid lava() {\n\tvec2 uv = wavy(UV / 8., Time.x * .5, 2., .05);\n\tfloat b = FBMT(uv, vec2(7), .9, 2., 4);\n\tvec3 c = RGB(91, 22, 14) * (.2 + 1.6 * b);\n\tc = mix(c, RGB(144, 44, 0), tri(.6, .2, FBMT(uv, vec2(3), .7, 3., 4)));\n\tc = mix(c, RGB(244, 144, 66) * b * 2., sqr(tri(.55, .25, FBMT(uv, vec2(11), .5, 2., 4))));\n\tFCol = vec4(c * sat(mx(Light())), 1);\n}\n\n// Single-speed flame layer (s = speed)\nfloat simple_flame(vec2 uv, float s) {\n\tvec2 p = uv;\n\tp.y += p.y - Time.x * s;\n\tuv.x += (N(p.y * 5.) - .5) * 1.5 * sqr(uv.y);\n\tfloat\n\t\tn = FBMT(wavy(p, 7., .02), vec2(9), .7, 2., 4),\n\t\th = ls(.9, .03, uv.y),\n\t\tb = box(uv - vec2(.5, .15), vec2(0, .3));\n\treturn sqr(msk(b + n * sqr(1.2 - h) - .13, .15));\n}\n\nvoid complex_flame(float s) {\n\tvec2 uv = fract(UV);\n\tFCol = (simple_flame(uv, s * .6) + simple_flame(uv, s)) * vec4(2.5, 1, .35, 0);\n}\n\nvoid flame() {\n    complex_flame(1.);\n}\n\n// models/mapobjects/lamps/flare03\nvoid flare03() {\n\tFCol = vec4(2, 2, 2, 0) * pow(flare(UV, vec2(.5), 1., .6), 2.);}\n\n// models/mapobjects/lamps/bot_flare\nvoid botflare() {\n    vec2 uv = (UV - .5) * rot(20. * Time.x);\n    float\n        b = NT(uv, vec2(256)),\n        k = 2.2 - length(uv) * 3.;\n\tFCol = vec4(k, k, 2, 0) * pow(flare(uv, vec2(0), 1.5, .4) + b * .01, 2.2);\n}\n\n// models/mapobjects/teleporter/energy.tga\nvoid tlpnrg() {\n    NO_COPY_PASTE\n    vec2 uv = fract(UV) * vec2(2, 3);\n    NO_COPY_PASTE\n\n\tvec2 p = uv;\n    p.x = fract(uv.x - Time.x * 3.);\n    float f =\n        (wrapped_flare(p, vec2(0, .3), 1., .6) + flare(p, vec2(.5, .4), 2., .66))\n    \t* ls(.1, .2, uv.y) * (.5 + abs(fract(Time.x * 5.3) - .5))\n\t;\n\tFCol = f * f * vec4(.9, .77, .77, 0);\n\n    p.x = fract(uv.x * .5 - Time.x * 4.4);\n    p.y = mod(uv.y * .5 - Time.x * 2.6, 3.);\n\tf = wrapped_flare(p, vec2(0, .5), 1.1, .5) + flare(p, vec2(.5, .6), 1., .6);\n\tFCol += f * f * vec4(.9, .77, .77, 0);\n\n    p.x = fract(uv.x * .5 + Time.x * 2.);\n    p.y = mod(uv.y * .5 - Time.x * 2., 3.);\n\tf = wrapped_flare(p, vec2(0, .5), 1.1, .5) + flare(p, vec2(.5, .6), 1., .6);\n\tFCol += f * f * vec4(.9, .77, .77, 0);\n\n    //f += .5 * smoothen(tri(1., 1., .01 * sin(uv.x * TAU) + mod(uv.y - Time.x * 5.2, 4.)));\n    //f += .3 * smoothen(tri(.7, .7, .01 * sin(uv.x * TAU) + mod(uv.y + .2 - Time.x * 2.3, 4.)));\n}\n\n// models/mapobjects/teleporter/transparency.tga\nTEXA(tlptrns) {\n\tfloat b = FBMT(wavy(uv, 5., .03), vec2(7), .5, 3., 2);\n\treturn\n\t\t(b * 1.4 + .3) * vec4(1.2, .54, .06, 0)\n\t\t+ tri(.7, .2, b) * .5 * vec4(1, 1, 1, 0)\n\t;\n}\n\nvoid poly(vec2 uv, inout float d, inout vec2 p, vec2 q, float s) {\n    d = -smin(-d, dot(uv - p, rot(90.) * normalize(p - q)), s);\n    p = q;\n}\n\n// models/mapobjects/lamps/bot_wing.tga (texture)\nTEXA(botwing) {\n\tuv.y *= .5; // correct aspect ratio\n\tfloat\n\t\tb = FBMT(uv, vec2(7), .7, 2., 4),\n\t\tt = .8 + .8 * b * b,\n\t\td = -1e6,\n\t\tm, l, v, k;\n\n\tvec2 p = vec2(.19, .42); // top-left (highest point)\n\tpoly(uv, d, p, vec2(.55, .42), .02);\n\tpoly(uv, d, p, vec2(.74, .34), .03);\n\tpoly(uv, d, p, vec2(.74, .29), .02);\n\tpoly(uv, d, p, vec2(.63, .1), .01);\n\tpoly(uv, d, p, vec2(.31, .04), .06);\n\tpoly(uv, d, p, vec2(.12, .1), .01);\n\tpoly(uv, d, p, vec2(.02, .29), .01);\n\tpoly(uv, d, p, vec2(.19, .42), .03); // close loop\n\n\td = min(d, box(p = rot(22.5) * (uv - vec2(.7, .22)), vec2(.17, .065))); // connecting box\n\td = max(d, -box(p - vec2(.04, .0), vec2(.03, .01))); // cut off box interior\n\td = max(d, -max(d + .07, box(uv - vec2(.4 - uv.y * .5, .23), vec2(.033, .2)))); // left slit\n\td = max(d, -max(d + .07, box(uv - vec2(.52 - uv.y * .5, .23), vec2(.033, .2)))); // middle slit\n\td = max(d, -max(d + .07, box(uv - vec2(.65 - uv.y * .5, .23), vec2(.033, .2)))); // right slit\n\td = min(d, k = circ(uv - vec2(.86, .18), .09)); // disk\n\n\tl = grad(d).y; // lighting [-1..1]\n\n\tvec3 c = RGB(44, 33, 30) * t * t * t; // base color\n\tc *= 1.\n\t\t+ 2.5 * sqr(ls(.1, .0, length(uv - vec2(.18, .4)))) // brighten top-left corner\n\t\t+ 2.5 * sqr(ls(.2, .0, length(uv - vec2(.64, .4)))) // brighten top-right corner\n\t;\n\n\tc *= 1.\n\t\t+ tri(-.01, .007, d) * (l + .5) // bevel lighting\n\t\t+ 6. * pow(ls(.15, .01, length(p = (uv - vec2(.5, .26)) * rot(7.) * vec2(.14, 1))), 6.) * sqr(ls(.04, .02, p.x)) // mid specular\n\t;\n\n\tl = grad(k += .05).y; // inner disk lighting\n\tc *= 1.\n\t\t+ 1.5 * tri(.0, .01, k) * sqr(abs(l + .3)) // edge highlight\n\t\t- .9 * tri(.01, .01, k) * sat(.3 - l) // edge shadow down below\n\t\t+ .7 * tri(-.03, .01, k) * l // axle lighting/shadow\n\t\t+ 2.5 * ls(-.03, -.04, k) // bright axle interior\n\t\t//-.9 * ls(-.002, .01, d) // darken edges\n\t;\n\n\treturn msk(d) * vec4(c, 1);\n}\n\n// models/mapobjects/lamps/bot_lamp.tga (texture)\nTEXA(botlamp) {\n\t//uv.y *= 2.; // correct aspect ratio\n\n\tfloat\n\t\tb = FBMT(uv, vec2(7), .7, 2., 4),\n\t\tt = .7 + 1.2 * b * b,\n\t\td, l\n\t;\n\tuv.x = abs(uv.x - .5); // mirror\n\tvec3 c = RGB(44, 33, 30) * t; // base color\n\tvec2 p = uv - vec2(.17, .37);\n\n\tl = grad(d = length(p * vec2(.85, 1))).y;\n\tc *= 1.\n\t\t+ 4. * pow(ls(.5, .05, length(uv - vec2(0, .6))), 5.) // large specular highlight\n\t\t+ tri(.0, .075, .1, d) * (.2 - l) // eye socket edge\n\t;\n\n\t// pupils\n\tl = grad(d = length(p += vec2(.02, 0))).y;\n\tc *= 1.\n\t\t- .5 * sqr(tri(.03, .02, d)) // darken pupil exterior\n\t\t- .9 * sqr(tri(.04, .09, d)) * tri(.1, .2, p.y) // darken eye socket\n\t\t- ls(.02, .01, d) * (.2 + .7 * ls(.0, .01, p.y)) // darken interior\n\t\t+ tri(.02, .01, d) * (.4 + tri(.0, .015, p.x)) // edge highlight\n\t;\n\n\t// forehead\n\td = box(p = uv - vec2(0, .5), vec2(.08 - .7 * p.y, .05));\n\tc *= 1.\n\t\t+ .5 * tri(.05, .02, d) * ls(.0, .1, p.y) // edge highlight\n\t\t- .9 * tri(.05, .03, -.1, d) * ls(-.1, .05, p.y) // inner shadow\n\t;\n\n\td = box(p = uv - vec2(0, .4), vec2(.02, .03));\n\tc *= 1.\n\t\t+ .7 * tri(.05, .02, d) * ls(.0, .1, p.y) // edge highlight\n\t\t- .7 * tri(.05, .03, -.2, d) * ls(-.1, .05, p.y) // inner shadow\n\t;\n\n\td = box(p = uv - vec2(0, .34), vec2(.025 - .5 * p.y, .007));\n\tc *= 1.\n\t\t+ .7 * tri(.02, .02, d) * ls(-.05, .05, p.y) // edge highlight\n\t\t- .7 * tri(.02, .0, -.1, d) * ls(-.05, .02, p.y) // inner shadow\n\t;\n\n\t// nasal cavity\n\td = length(p = (uv - vec2(0, .22)) * vec2(1.4, 1)) - .1;\n\td = max(d, length(uv - vec2(.1, .25)) - .15);\n\tc *= 1.\n\t\t+ .4 * tri(.0, .03 + p.y * .05, d) // edge highlight\n\t\t- .9 * ls(.0, -.08, d) // darken nasal cavity interior\n\t;\n\n    // ridge\n    d = seg(wavy(uv, 5., .05), vec2(.09, .63), vec2(.3, .9), .0);\n    c *= 1.\n        + ls(.03, .0, d) * (.2 + .3 * tri(.6, .05, uv.y))\n    ;\n\n    //return vec4(c, b);\n    return vec4(c, 1);\n}\n\n// models/weapons2/plasma/plasma_glo.tga\nTEX(plasma_glo) {\n    float\n        b = FBMT(uv, vec2(7), .5, 2., 4),\n        t = .8 + .8 * b * b,\n        n = NT(uv, vec2(2))\n\t;\n    return\n        mix(RGB(5, 77, 55), RGB(8, 122, 188), ls(.5, .1, n))\n        * sqr(1. - n) * t * 2. *\n        (1. + tri(.2, .05, b * b));\n}\n\n// models/weapons2/rocketl/rocketl.tga\nTEX(rocketl) {\n    uv = wavy(uv, 5., .02);\n\tfloat\n\t\tb = FBMT(uv, vec2(6), .8, 2., 4), // base FBM, tileable\n        m = FBMT(uv, vec2(2), .6, 2., 4),\n\t\tt = .8 + .6 * b * b // texture intensity\n\t\t;\n\tvec3 c = mix(RGB(36, 33, 30), RGB(168, 177, 168), .3 + .7 * m) * t;\n    c *= 1.\n        + .2 * ls(.4, .6, m)\n        - .2 * tri(.3, .1, m)\n        ;\n    return c;\n}\n\n// models/powerups/armor/energy_red1.tga\nTEX(armornrg) {\n    const vec3 CLR = vec3(1, 0, 0);\n    return tri(.5 + (FBMT(uv.x + H(Time.x * 133.7), 13., .6, 2., 4) - .5) * .1, .03, uv.y) * CLR;\n}\n\n// models/mapobjects/lamps/bot_flare2.tga\nTEXA(botflare2) {\n    float\n        b = FBMT(uv, vec2(3, 4), .5, 2., 4),\n        d;\n    uv.x = abs(uv.x - .5) * 1.7;\n    d = lsq(uv - vec2(0, 1)) + b * .3;\n    return vec4(.44, .3, .3, 0) / (333. * d * d * d + .1) * ls(.5, .4, d);\n}\n\n// models/mapobjects/gratelamp/gratetorch2b.tga\nTEXA(gr8torch2b) {\n\tuv.y *= 2.;\n\tfloat\n\t\tb = FBMT(uv, vec2(5), .9, 2., 4), // base FBM, tileable\n        k = .5 + b, // remapped b with 1.0 mean\n\t\tt = .8 + b * .4, // texture intensity\n\t\td = uv.y - 1.05; // distance field\n\tvec3 c = RGB(55, 44, 37) * t; // base color\n\tvec2 p = uv;\n\n\td = smin(d, box((uv - vec2(.5, 1.5)) * rot(45.), vec2(.2)) - .1, .3); // smin with rotated rounded square\n    d = max(d, .03 - p.y); // bilinear hack: cut off bottom\n\n\tc = mix(c, add_rivet(c, uv - vec2(.5, 1.5), .1), 8. * b); // large knob on rotated square\n\n\tp.x = min(p.x, 1. - p.x); // mirror around center\n\tif (p.y > .5)\n\t\tp.y -= .5; // repeat once vertically\n\tc = mix(c, add_rivet(c, p - vec2(.22, .31), .04), 2. * t); // smaller knobs\n\n\tc *= 1.\n        + sqr(ls(.5, 1., b)) // ligher dirt\n\t\t+ grad(d).y * tri(.0, .05, d) * (1. + 11. * ls(1.5, 2., uv.y)) * b // edge lighting\n\t\t+ k * tri(.93, .05, uv.y)\n\t\t+ k * tri(.4, .05, uv.y)\n\t\t+ k * tri(.1, .05, uv.y)\n\t\t- .5 * tri(.97, .05, uv.y)\n\t\t- .5 * sqr(tri(.7, .05, uv.y))\n\t\t- .5 * sqr(tri(.2, .05, uv.y))\n\t\t- .5 * tri(.66, .1, uv.y)\n\t\t- .5 * tri(.45, .03, uv.y)\n\t\t- .5 * tri(.15, .1, uv.y)\n\t\t- tri(.01, .03, uv.y)\n\t\t;\n\treturn vec4(c, msk(d, .03));\n}\n\n// models/mapobjects/wallhead/lion.tga\nTEX(lion) {\n\tvec2 p = uv, q;\n\tp.x = abs(p.x - .5); // mirror\n\n\tfloat\n\t\tb = FBMT(uv, vec2(7), .9, 3., 4), // base FBM\n\t\tt = .5 + b, // base texture intensity\n\t\tv = msk(-elips(p - vec2(.1, .57), vec2(.18, .2)), 1.), // hair mask\n\t\td, r, n, i, f, m,\n\t\tj = 0.\n\t;\n\n\tvec3 c = RGB(66, 55, 55) * t; // base color\n\n\t// hair layers\n\tfor (; j < 16.; ++j) {\n\t\tvec2 o = (R2(j) - .5) * vec2(.15, .1); // random offset\n\t\tq = p - o;\n\t\tq.x += .1 * sin(11. * q.y) * sqr(1. - q.y); // hair waviness\n\t\tr = elips(q - vec2(.1, .4), vec2(.22, .3));\n\t\tn = FBMT(wavy(uv + o * .5, .7, .01), vec2(5), .3, 2., 4); // smooth noise\n\t\td = r * .5 + n; // distorted distance\n\t\ti = floor(d); // strand id\n\t\tf = abs(fract(d) - .5); // location within strand\n\t\tm = v * sat(d) * step(H(i + j * PHI) * .9 + .1, .5); // strand mask\n\t\tc *= 1.\n\t\t\t+ .25 * m * ls(.2, .0, f) // highlight\n\t\t\t- .25 * m * tri(.3, .2, f) // shadow\n\t\t;\n\t}\n\n\t// eyes + eyebrows + cheekbones\n\tr = length(q = p - vec2(.13, .595));\n\tq *= rot(11.); // eye/eyebrow angle\n\tq.y = abs(q.y) + .025;\n\tm = ls(.0, -.2, d = elips(q, vec2(.06, .039)) * .07); // eye interior mask\n\tc *= 1.\n\t\t+ .4 * ls(.05, .0, length((p - vec2(.21, .53)) * vec2(.8, 1))) // cheekbone highlight\n\t\t- .4 * ls(.07, .0, length((p - vec2(.19, .42)))) // cheekbone shadow\n\t\t- .5 * tri(3.5, .9, d) * tri(.7, .05, p.y) * tri(.07, .15, p.x) // frown\n\t\t+ .9 * tri(1.9, .9, d) * ls(.15, .0, length(p - vec2(.06, .66))) // eyebrow highlight\n\t\t- .7 * tri(.4, .9, d) * ls(.15, .0, length(p - vec2(.09, .64))) // eyebrow shadow\n\t\t- .9 * tri(.05, .02, length(p - vec2(.05, .64))) * sat(1. - length(p - vec2(0, .6)) * 15.)\n\t\t+ .9 * sqr(ls(.03, .005, r)) * m // brighten eye interior\n\t\t- .4 * sqr(tri(.0, .5, d)) // darken contour\n\t\t- .6 * ls(.0, .05, r) * m // darken interior\n\t\t- 1.5 * ls(.5, .2, r * 50.) // darken pupil\n\t;\n\n\t// nose\n\td = length((p - vec2(0, .51)) * vec2(1.5, 2.5));\n\tr = length((p - vec2(.05, .46)));\n\tc *= 1.\n\t\t+ .6 * ls(.1, .03, d) * ls(.03, .06, r) // nose specular\n\t\t- .9 * ls(.05, .02, r) * ls(.06, .09, length(p - vec2(.08, .41))) // nostrils\n\t\t- .4 * tri(.1, .05, length((p - vec2(.06, .47)) * vec2(1.3, 1.1))) // snout shadow\n\t;\n\n\t// teeth\n\tq = p - vec2(.09, .29);\n\td = seg(q, vec2(0), vec2(0, .07), .02 * ls(.0, .1, q.y));\n\tc *= 1.\n\t\t+ sqr(ls(.02, .0, d)) // upper canines\n\t;\n\n    return c;\n}\n\n////////////////////////////////////////////////////////////////\n// Item icons\n////////////////////////////////////////////////////////////////\n\n// icons/iconh_yellow.tga\nvoid icon_health() {\n\tvec2 uv = pmod(UV - .5, 4.);\n\tFCol = vec4(1, 1, 0, 1) * msk(min(onion(length(uv) - .4, .04), box(uv, vec2(.25, .06))), .01);\n}\n\n// icons/iconr_shard.tga\nvoid icon_shard() {\n\tFCol = vec4(.4, .7, .3, 1) * msk(dot(abs(UV - .5), vec2(4, 3) / 5.) - .2, .01);\n}\n\n// icons/iconr_yellow.tga\nvoid icon_armor() {\n\tvec2 uv = UV - .5;\n\tuv.x = abs(uv.x);\n\tfloat\n\t\tw = .15 * sqrt(ls(-.32, -.29, uv.y))\n\t\t\t+ .05 * ls(-.3, -.12, uv.y)\n\t\t\t+ .1 * sqrt(ls(-.12, .07, uv.y))\n\t\t\t+ .14 * step(.07, uv.y)\n\t\t\t- .1 * sqr(ls(.07, .31, uv.y)),\n\t\td = exclude(box(uv, vec2(w, .3)), circ(uv - vec2(0, .777), .5))\n\t;\n\tFCol = vec4(1, 1, 0, 1) * msk(d - .01, .01);\n}\n\n// icons/iconw_machinegun.tga\nvoid icon_machinegun() {\n\tvec2 uv = UV;\n\tfloat d = box(uv - vec2(.35, .5), vec2(.1, .4));\n\tuv.y = mod(uv.y - .06, .28) - .16;\n\td = min(d, box(uv - vec2(.51, 0), vec2(.34, .04 * ls(.85, .7, uv.x))));\n\td = exclude(d, box(uv - vec2(.65, 0), vec2(.02, 1)));\n\tFCol = vec4(1, 1, 0, 1) * msk(d, .01);\n}\n\n// icons/iconw_shotgun.tga\nvoid icon_shotgun() {\n\tvec2 uv = UV;\n\tuv.x = mod(uv.x, .33) - .16;\n\tfloat d = box(uv - vec2(0, .52), vec2(.1, .4));\n\td = exclude(d, box(uv - vec2(0, .65), vec2(.05, .23)));\n\td = exclude(d, abs(uv.y - .2) - .02);\n\tFCol = vec4(1, .5, 0, 1) * msk(d, .01);\n}\n\n// icons/iconw_rocket.tga\nvoid icon_rocketl() {\n\tvec2\n\t\tuv = (UV - vec2(.55, .45)) * rot(-45.);\n\tfloat\n\t\td = seg(uv, vec2(-.4, 0), vec2(.2, 0), .1);\n\td = max(d, -.3 - uv.x);\n\tuv.y = abs(uv.y);\n\td = min(d, box(uv + vec2(.37, 0), vec2(.05, .005)));\n\td = min(d, box(uv + vec2(uv.y + .1, -.18), vec2(.1, .05)));\n\tFCol = vec4(1, 0, 0, 1) * msk(d, .01);\n}\n\n// icons/iconw_railgun.tga\nvoid icon_railgun() {\n\tvec2 uv = (UV - .5) * rot(45.);\n\tfloat\n\t\td = box(uv, vec2(.6, .03)),\n\t\tp = uv.x * 12.6 + 1.55,\n\t\th = sin(p) * .15,\n\t\tq = ridged(fract(h))\n\t\t;\n\td = min(d, max(onion(uv.y - h, .05 - .1 * q) * (1. + q + q), abs(uv.x) - .6));\n\tFCol = vec4(0, 1, 0, 1) * msk(d, .01);\n}\n\n// icons/iconw_plasma.tga\nvoid icon_plasma() {\n\tvec2 uv = pmod(UV - .5, 5.);\n\tfloat\n\t\td = length(uv) - .18,\n\t\tr = uv.x - .33,\n\t\th = .04 * tri(.0, .3, r);\n\tuv.x -= .33;\n\tuv *= rot(-15.);\n\td = min(d, box(uv, vec2(.04, 2. * h)));\n\td = min(d, box(uv - vec2(0, h * sign(r)), vec2(.14, h)));\n\tFCol = vec4(.77, 0, 1, 1) * msk(d + .01, .01);\n}\n\n// icons/quad.tga\nvoid icon_quad() {\n\tvec2 uv = UV - .5;\n\tfloat d = icon_sdf(uv + vec2(0, .05), 0.) - .01;\n\td = min(d, box(pmod(uv * rot(45.), 4.) - vec2(.45 , .0), vec2(.11, .02)));\n\tFCol = vec4(0, .88, .95, 1) * msk(d, .01);\n}\n\n// gfx/2d/crosshaira\nvoid crosshaira() {\n    float d = length(UV - .5) * 32.;\n\tFCol = vec4(.5 * ls(.5, .0, abs(d - 15.)) + ls(1., .5, d));\n}\n\n// gfx/2d/crosshairb\nvoid crosshairb() {\n    vec2 uv = abs(UV - .5) * 32.;\n\tFCol = vec4(step(mn(uv), 1.) * step(mx(uv), 6.));\n}\n\n// gfx/2d/crosshairc\nvoid crosshairc() {\n    vec2 uv = abs(UV - .5) * 32.;\n\tFCol = vec4(step(mn(uv), 1.) * step(mx(uv), 6.) * step(3., mx(uv)));\n}\n\n// menu/art/addbotframe.tga\nvoid uiframe() {\n    vec2 uv = UV - .5;\n    float\n        n = NT(uv, vec2(7)) * .8 + .6,\n        d = circ(uv, .48),\n        m = msk(d, .005),\n        i = msk(elips(uv, vec2(.42, .47)), .03);\n    vec3 c = RGB(144, 88, 66) * n;\n    m *= 1. - i * .5;\n    c *= 1. - i;\n    c *= 1.\n        - 2. * sqrt(tri(.0, .45, uv.y))\n        + 4. * (uv.y + .5)\n        + .5 * tri(.0, .01, d) * uv.x\n        ;\n    FCol = vec4(c * m, m);\n}\n\n// menu/art/maps_select.tga\nvoid mapselect() {\n\tfloat d = box((UV - .5) * 256., vec2(98));\n\tFCol = vec4(1, 0, 0, 1) * (.3 * ls(24., .0, d) * step(.0, d)  + step(abs(d + 1.), 1.));\n}\n\n// menu/art/slider2.tga\nvoid slider2() {\n\tfloat d = dot(UV, vec2(-.4, .5)) - .1;\n\tFCol = vec4(msk(d, .02) * ls(-.1, .9, UV.x) * step(mx(abs(UV - .5)), .45));\n}\n\n// menu/art/sliderbutt_1.tga\nvoid sliderbutt1() {\n    float d = circ(UV - .5, .45);\n    FCol = vec4(.7 * ls(.1, -.3, d), 0, 0, msk(d, .02))\n        + vec4(1, 1, 1, 0) * ls(.25, -.25, length(UV - vec2(.25, .75))) * tri(-.1, .1, d) // specular\n    ;\n}\n\n////////////////////////////////////////////////////////////////\n// Preview slideshow ///////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n\n#define SLIDES(x)\\\n    x(dmnd2cow_m)\\\n    x(gskull4)\\\n    x(skcpthrt_opaque)\\\n    x(gcntr2trn_m)\\\n    x(bglogo)\\\n    \nconst float NUM_SLIDES =\n    #define COUNT(x) +1.\n    SLIDES(COUNT)\n    #undef COUNT\n    ;\n\n////////////////////////////////////////////////////////////////\n\nvoid giron01nt3_square() {\n    UV.x *= 2.;\n    giron01nt3();\n    UV.x /= 2.;\n}\n\nvoid skcpthrt_opaque() {\n    skcpthrt();\n    FCol.a = 1.;\n}\n\nvoid logo_solo() {\n    bglogo();\n    if (mx(abs(UV - .5)) >= .5)\n        FCol.rgb = vec3(0);\n}\n\n////////////////////////////////////////////////////////////////\n\nfloat slide_alpha(float slide, float t, float current, float next) {\n    if (slide == current) return 1. - t;\n    if (slide == next) return t;\n    return 0.;\n}\n\nvoid slideshow() {\n    float b = FBMT(gl_FragCoord.xy / iResolution.y, vec2(7), .7, 2., 4);\n    float t = dot(gl_FragCoord.xy / iResolution.xy, vec2(1, -.375)) / 8. + .125 + Time.x / 1.5 + b * .125;\n    \n    const bool DUPLICATE_LAST_SLIDE = false;\n    if (DUPLICATE_LAST_SLIDE) {\n        t = mod(t, NUM_SLIDES + 1.);\n        t -= sat(t - NUM_SLIDES + 1.);\n    } else {\n        t = mod(t, NUM_SLIDES);\n    }\n    \n    float current = floor(t);\n    float next = current + 1.;\n    if (next == NUM_SLIDES)\n        next = 0.;\n    t -= current;\n    t = smoothstep(.875, 1., t);\n   \n    vec4 c = vec4(0);\n    float slide_index = 0., alpha = 0.;\n\n    #define DRAW_SLIDE(name)\\\n        alpha = slide_alpha(slide_index++, t, current, next);\\\n        if (alpha > 0.) {\\\n            name();\\\n            c += FCol * alpha;\\\n        }\n    \n    SLIDES(DRAW_SLIDE)\n    \n    #undef DRAW_SLIDE\n    \n    FCol = c;\n}\n\n////////////////////////////////////////////////////////////////\n// Implementation //////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n\n#define ARG0_(a,b,c)\t\ta\n#define ARG1_(a,b,c)\t\tb\n#define ARG2_(a,b,c)\t\tc\n\n#define ARG0(x)\t\t\t\tARG0_(x) // force x macro evaluation\n#define ARG1(x)\t\t\t\tARG1_(x) // force x macro evaluation\n#define ARG2(x)\t\t\t\tARG2_(x) // force x macro evaluation\n\n#define TEXTURE_NAME\t\tARG0(SHOW_TEXTURE)\n#define TEXTURE_SIZE\t\tvec2(ARG1(SHOW_TEXTURE), ARG2(SHOW_TEXTURE))\n#define ASPECT\t\t\t\t(float(ARG2(SHOW_TEXTURE)) / float(ARG1(SHOW_TEXTURE)))\n\n////////////////////////////////////////////////////////////////\n\nvec3 checker() {\n    ivec2 addr = (ivec2(gl_FragCoord.xy) >> 3) & 1;\n    return (addr.x ^ addr.y) == 1 ? vec3(.5) : vec3(.25);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    State state;\n    load(iChannel0, state);\n    \n    Time = vec4(iTime,0,0,0);\n    Time.x += state.time_offset;\n    \n    vec2 coord = fragCoord;\n    vec2 screen_center = iResolution.xy * .5;\n    coord -= screen_center;\n    coord *= state.zoom;\n    if (!state.center)\n    \tcoord += screen_center;\n    \n    vec2 scale_ratio = iResolution.xy / TEXTURE_SIZE;\n    scale_ratio /= mn(scale_ratio);\n    \n    vec2 uv = coord / iResolution.xy + state.offset;\n    uv *= scale_ratio;\n    \n    uv = uv * INITIAL_UV_SCALE + INITIAL_UV_OFFSET;\n    if (state.center)\n    \tuv += .5;\n    UV = uv;\n    \n    TEXTURE_NAME();\n    \n    if (!state.tile && mx(abs(uv - .5)) > .5)\n        FCol = vec4(0);\n\n    switch (state.alpha_mode) {\n\tdefault:\n\tcase VIEW_BASE_COLOR:\n    \tfragColor = FCol;\n       \tbreak;\n\n\tcase VIEW_ALPHA:\n        fragColor = vec4(FCol.aaa, 1);\n        break;\n\n\tcase VIEW_BLACK_MATTE:\n        fragColor = vec4(FCol.rgb * FCol.a, 1);\n        break;\n\n\tcase VIEW_CHECKER:\n        // premultiplied alpha\n        fragColor = vec4(checker() * (1. - FCol.a) + FCol.rgb, 1);\n        break;\n\n\tcase VIEW_CHECKER_TEST:\n        fragColor = vec4(FCol.a < 0.5 ? checker() : FCol.rgb, 1);\n        break;\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "////////////////////////////////////////////////////////////////\n\n#define smoothen(x)\t((x)*(x)*(3.-2.*(x)))\n#define sqr(x)\t\t((x)*(x))\n#define lsq(x)\t\tdot(x, x)\n#define sat(x)\t\tclamp(x, 0., 1.)\n#define RGB(r,g,b)\t(vec3(r,g,b)/255.)\n\n#define ridged(v)\ttri(.5,.5,v)\n\n// $protect ^void[ \\t]+([_a-zA-Z][_a-zA-Z0-9]*)\\(\\)\n// $protect ^TEX[A]?\\(([a-z][_a-z0-9]*)\\)\n#define TEX(name)\tvec3 name(vec2); void name() { FCol = vec4(name(UV), 1); } vec3 name(vec2 uv)\n#define TEXA(name)\tvec4 name(vec2); void name() { FCol = name(UV); } vec4 name(vec2 uv)\n\n#define T0(x)\t\ttexture(Texture0, x)\n\n////////////////////////////////////////////////////////////////\n\n// Hardware derivates are computed at half resolution (pixel quads).\n// To get full-resolution results, we need to evaluate 3 taps.\n// The macro below helps automate that process a bit.\n//\n// Arguments:\n// - res = name of vec3 output variable to receive the results:\n//   .xy = normalized gradient\n//   .z  = function value\n// - uv  = 2d point where function is to be evaluated\n\n#define EVAL_GRAD(res, uv, code)\t\t\t\t\t\t\t\t \t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tvec2 p[3];\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t \tfloat r[3];\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tp[0] = uv;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tp[1] = uv + dFdx(uv);\t\t\t\t\t\t\t\t\t\t\\\n\t\tp[2] = uv + dFdy(uv);\t\t\t\t\t\t\t\t\t\t\\\n\tfor (int i = 0; i < 3; ++i)\t\t\t\t\t\t\t\t\t\t\\\n\t\tr[i] = code;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tres = vec3(safe_normalize(vec2(r[1], r[2]) - r[0]), r[0]);\t\\\n\t}\n\n////////////////////////////////////////////////////////////////\n\n// Computes a SDF and a top light/shadow value\n//\n// Arguments:\n// - uv = 2d point where function is to be evaluated\n// - s  = shadow size\n// - d  = name of float distance output variable\n// - l  = name of float light output variable\n\n#define EVAL_TOP_LIGHT(uv,s,d,l,code)\t\\\n\t{\t\t\t\t\t\t\t\t\t\\\n\t\tvec2 p = uv;\t\t\t\t\t\\\n\t\td = code;\t\t\t\t\t\t\\\n\t\tp.y -= s;\t\t\t\t\t\t\\\n\t\tl = (d - code) / s;\t\t\t\t\\\n\t}\n\n////////////////////////////////////////////////////////////////\n\n#if 0\nuniform sampler2D Texture0, Texture1;\nuniform vec4 Cam, Time, Extra, LightColor, Ambient, LightDir;\n\nin vec3 Pos, Nor, WNor, Ref;\nin vec2 UV, LUV;\nin vec4 Clr;\n\nout vec4 FCol;\n#endif\n\n////////////////////////////////////////////////////////////////\n\nconst float\n\tPI\t\t= 3.1415927,\n\tTAU\t\t= 2. * PI,\n\tPHI\t\t= 1.618034;\n\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\nvec2 R2(float i) {\n\tfloat G = 1.324718;\n\treturn fract(.5 + i / vec2(G, G * G));\n}\n\nfloat R1(float i) {\n\treturn fract(.5 + i * PHI);\n}\n\n// smooth R1\nfloat SR1(float f) {\n\tfloat i = floor(f);\n\treturn mix(R1(i), R1(i+1.), smoothen(f - i));\n}\n\n////////////////////////////////////////////////////////////////\n\nfloat mn(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat mn(vec3 v) {\n\treturn min(v.x, min(v.y, v.z));\n}\n\nfloat mn(vec4 v) {\n\treturn min(min(v.x, v.y), min(v.z, v.w));\n}\n\nfloat mx(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat mx(vec3 v) {\n\treturn max(v.x, max(v.y, v.z));\n}\n\nfloat mx(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat sum(vec2 v) {\n\treturn v.x + v.y;\n}\n\nfloat sum(vec3 v) {\n\treturn v.x + v.y + v.z;\n}\n\nfloat minabs(float a, float b) {\n\treturn abs(a) < abs(b) ? a : b;\n}\n\nfloat onion(float x, float s) {\n\treturn abs(x) - s;\n}\n\nfloat elongate(float x, float s) {\n\treturn sign(x) * max(0., abs(x) - s);\n}\n\n////////////////////////////////////////////////////////////////\n\nvec2 safe_normalize(vec2 v) {\n\tfloat l = dot(v, v);\n\treturn l > 0. ? v/sqrt(l) : v;\n}\n\n////////////////////////////////////////////////////////////////\n\n// tent\nfloat tri(float center, float max_dist, float x) {\n\treturn 1. - sat(abs(x - center) / max_dist);\n}\n\n// antialiased tent funtion\nfloat triaa(float c, float s, float x) {\n\tfloat a = max(fwidth(x) * 2. / s, 1.);\n\treturn tri(c, s * a, x) / a;\n}\n\n// linear step (like smoothstep, but linear)\nfloat ls(float lo, float hi, float x) {\n\treturn sat((x - lo) / (hi - lo));\n}\n\n// asymmetric tent\nfloat tri(float a, float b, float c, float x) {\n\treturn min(ls(a, b, x), ls(c, b, x));\n}\n\n////////////////////////////////////////////////////////////////\n\nvec2 sc(float x) {\n\treturn vec2(sin(x), cos(x));\n}\n\nmat2 rot(float x) {\n\tvec2 v = sc(radians(x));\n\treturn mat2(v.y, v.x, -v.x, v.y);\n}\n\n// Normalized angle [0..1]\nfloat nang(vec2 p) {\n\treturn fract(atan(p.y, p.x) / TAU);\n}\n\n// Polar mod\nvec2 pmod(vec2 p, float n) {\n\treturn p * rot(360. / n * (floor(nang(p) * n + 1.5) - 1.));\n}\n\n// UV distortions //////////////////////////////////////////////\n\n// p = integral number of half periods\n// s = scale\nvec2 wavy(vec2 uv, float p, float s) {\n\treturn uv + sin(uv.yx * PI * p) * s;\n}\n\n// t = time offset\nvec2 wavy(vec2 uv, float t, float p, float s) {\n\treturn uv + sin(uv.yx * PI * p + t) * s;\n}\n\nfloat mirr(float v, float m) {\n\treturn m - abs(v - m);\n}\n\nvec2 mirr(vec2 v, float m) {\n\tv.x = mirr(v.x, m);\n\treturn v;\n}\n\n// x = variable to repeat\n// p = period\n// l = low limit\n// h = high limit\nfloat repeat(float x, float p, float l, float h) {\n\treturn x - p * clamp(floor(x / p + .5), l, h);\n}\n\n// Running bond: s = (rows, columns)\nvec2 brick(vec2 uv, vec2 s) {\n\tuv.x += floor(uv.y * s.y) * (.5 / s.x);\n\treturn fract(uv) * s;\n}\n\n// Inputs:\n//   - uv in [0..1]\n//   - r = radius, in [0..1]\n// Output:\n//   - xy = offset\n//   - z  = edge ratio in [0..1]\nvec3 brick_edge(vec2 uv, float r) {\n\treturn vec3(uv -= clamp(uv, r, 1. - r), length(uv) / r);\n}\n\n// Inputs:\n//   - uv in [0..1]\n//   - s = (rows, columns)\n//   - r = radius, in [0..1]\n// Output:\n//   - xy = offset\n//   - z  = edge ratio in [0..1]\nvec3 brick_edge(vec2 uv, vec2 s, float r) {\n\ts = s.yx / mn(s);\n\tuv *= s;\n\treturn vec3(uv -= clamp(uv, vec2(r), s - r), length(uv) / r);\n}\n\n////////////////////////////////////////////////////////////////\n// Noise ///////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n\n// Dave Hoskins/Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\n\nfloat H(vec2 p) {\n\tvec3 q = fract(p.xyx * .09153);\n\tq += dot(q, q.yzx + 19.19);\n\treturn fract((q.x + q.y) * q.z);\n}\n\nfloat H(float p) {\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\n\nvec3 H3(float p) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx+33.33);\n\treturn fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec2 H2(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx+33.33);\n\treturn fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec4 H4(float p) {\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n\tp4 += dot(p4, p4.wzxy + 33.33);\n\treturn fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nvec4 H4(vec2 p) {\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n\tp4 += dot(p4, p4.wzxy+33.33);\n\treturn fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nfloat HT(float p, float s) {\n\treturn H(mod(p, s));\n}\n\nfloat HT(vec2 p, vec2 s) {\n\treturn H(mod(p, s));\n}\n\n// FIXME: 1D noise should take a normalized value, like its 2D counterpart!\nfloat N(float p) {\n\tfloat i;\n\treturn mix(H(i = floor(p)), H(i + 1.), smoothen(p - i));\n}\n\n// FIXME: 1D noise should take a normalized value, like its 2D counterpart!\nfloat NT(float p, float s) {\n\tfloat i;\n\t// FIXME: linear, not smooth\n\treturn mix(HT(i = floor(p), s), HT(i + 1., s), p - i);\n}\n\nfloat NT(vec2 p, vec2 s) {\n\tp *= s;\n\tvec2 i = floor(p);\n\tp -= i;\n\tp *= p * (3. - 2. * p);\n\tfloat s00 = HT(i + vec2(0, 0), s);\n\tfloat s01 = HT(i + vec2(0, 1), s);\n\tfloat s11 = HT(i + vec2(1, 1), s);\n\tfloat s10 = HT(i + vec2(1, 0), s);\n\treturn mix(mix(s00, s10, p.x), mix(s01, s11, p.x), p.y);\n}\n\nfloat FBMT(vec2 p, vec2 scale, float gain, float lac, int lyrs) {\n\tfloat acc = NT(p, scale), ow = 1., tw = 1.;\n\tfor (int i=0; i<lyrs; ++i) {\n\t\tp = fract(p + PHI);\n\t\tscale *= lac; ow *= gain;\n\t\tacc += NT(p, scale) * ow;\n\t\ttw += ow;\n\t}\n\treturn acc / tw;\n}\n\n// FIXME: 1D noise should take a normalized value, like its 2D counterpart!\nfloat FBMT(float p, float scale, float gain, float lac, int lyrs) {\n\tfloat acc = NT(p * scale, scale), ow = 1., tw = 1.;\n\tfor (int i=0; i<lyrs; ++i) {\n\t\tp = fract(p + PHI);\n\t\tscale *= lac; ow *= gain;\n\t\tacc += NT(p * scale, scale) * ow;\n\t\ttw += ow;\n\t}\n\treturn acc / tw;\n}\n\nfloat FBMT_ridged(vec2 p, vec2 scale, float gain, float lac, int lyrs) {\n\tfloat acc = ridged(NT(p, scale)), ow = 1., tw = 1.;\n\tfor (int i=0; i<lyrs; ++i) {\n\t\tp = fract(p + PHI);\n\t\tscale *= lac; ow *= gain;\n\t\tacc += ridged(NT(p, scale)) * ow;\n\t\ttw += ow;\n\t}\n\treturn acc / tw;\n}\n\n// Env mapping /////////////////////////////////////////////////\n\n// s = detail scale (integral values only)\n// 45.0 is very shiny, 9.0 less so\nfloat env(vec3 p, float s) {\n\tp = normalize(p);\n\tvec3 a = fract(degrees(atan(p, p.yzx)) / 360.);\n\treturn NT(a.x * s, s) * ls(.9, .0, abs(p.z)) + NT(a.y * s, s) * ls(.7, .0, abs(p.x));\n}\n\nfloat env(vec3 p) {\n\treturn env(p, 45.);\n}\n\n////////////////////////////////////////////////////////////////\n\n#if 0\nvec3 Light() {\n\tvec3 d = Cam.xyz - Pos;\n\tfloat\n\t\tb = FBMT(d.xy/256.*rot(Cam.w), vec2(3), .7, 3., 4),\n\t\tl = 1. - ls(14., -6., length(d.xy) - b * 8.) * ls(128., 48., d.z) * step(.1, Nor.z);\n\treturn texture(Texture1, LUV).xyz * 2. * l;\n}\n#endif\n\n////////////////////////////////////////////////////////////////\n\nvec2 seg(vec2 p, vec2 a, vec2 b) {\n\tvec2 ab = b-a, ap = p-a;\n\tfloat t = sat(dot(ap, ab)/dot(ab, ab));\n\treturn ab*t + a;\n}\n\nfloat half_plane(vec2 uv, vec2 d) {\n\treturn dot(uv, rot(90.) * normalize(d));\n}\n\nfloat box(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat box1(vec2 p, vec2 b) {\n\treturn mx(abs(p) - b);\n}\n\nfloat circ(vec2 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat seg(vec2 p, vec2 a, vec2 b, float r) {\n\treturn circ(p - seg(p, a, b), r);\n}\n\nfloat elips(vec2 p, vec2 r) {\n\treturn circ(p/r, 1.) / min(r.x, r.y);\n}\n\nfloat exclude(float a, float b) {\n\treturn max(a, -b);\n}\n\n// polynomial smooth min\n// https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nvec2 grad(float x) {\n\tvec2 d = vec2(dFdx(x), dFdy(x));\n\treturn d / max(length(d), 1e-8);\n}\n\nfloat msk(float s, float d) {\n\treturn sat(1. - s/d);\n}\n\nfloat msk(float s) {\n\treturn sat(1. - s/fwidth(s));\n}\n\n////////////////////////////////////////////////////////////////\n\n// Output: xyz = normal, w = unclamped normalized distance\nvec4 rivet(vec2 uv, float s) {\n\treturn vec4(uv/=s, sqrt(sat(1.-lsq(uv))), length(uv) - 1.);\n}\n\nfloat top_light(vec3 n) {\n\tfloat l = sum(n.yz) * .7;\n\treturn pow(sat(l), 4.) + l;\n}\n\nfloat rivet_shadow(vec2 uv, float s) {\n\tuv /= s;\n\tuv.y += .06;\n\tuv.x *= 2.;\n\treturn ls(.3, .0, length(uv));\n}\n\n// c = base color\n// l = light intensity (default: 0.5)\n// d = shadow intensity (default 0.3)\nvec3 add_rivet(vec3 c, vec2 uv, float s, float l, float d) {\n\tvec4 b = rivet(uv, s);\n\tc *= 1. + top_light(b.xyz) * msk(b.w, s + s) * l;\n\tc *= 1. - sqr(rivet_shadow(uv, 20. * s)) * (1. - msk(b.w, s + s)) * d;\n\treturn c;\n}\n\nvec3 add_rivet(vec3 c, vec2 uv, float s) {\n\treturn add_rivet(c, uv, s, .5, .3);\n}\n\n////////////////////////////////////////////////////////////////\n\n// p = point\n// c = center\n// s = size\n// i = core intensity\nfloat flare(vec2 p, vec2 c, float s, float i) {\n    p -= c;\n    float a = ls(.2, .5, abs(fract(nang(p /= s) * 8. + H(fract(c))) - .5));\n    return ls(.9, i, pow(lsq(p), .0625) - a * a * .006);\n}\n\nfloat wrapped_flare(vec2 p, vec2 c, float s, float i) {\n    float d = flare(p, c, s, i);\n    c.x += p.x < c.x ? -1. : 1.;\n    return d + flare(p, c, s, i);\n}\n\n// uv in [-0.5..0.5]\nfloat pentagram(vec2 uv, float s) {\n\tfloat d = 1e6, i = 0.;\n\tfor (/**/; i < 5.; ++i) {\n\t\tvec2 p = vec2(0, -s) * rot(i * 72.);\n\t\td = min(d, length(uv - seg(uv, p, p * rot(144.))));\n\t}\n\treturn d;\n}\n\n////////////////////////////////////////////////////////////////\n//#pragma section patterns\n////////////////////////////////////////////////////////////////\n\n// Quake 3 logo SDF\n// t = 0.0 : app icon (chunky)\n// t = 1.0 : background logo (slim)\nfloat icon_sdf(vec2 uv, float t) {\n\tuv.x = abs(uv.x);\n\tuv.y -= .07;\n\tfloat d = elips(uv, vec2(.31, .12 - t * .02)) / 50.; // base ellipse\n\td = max(d, -elips(uv - vec2(0, .01 + .01 * t), vec2(.28 + t * .01, .07)) / 75.); // negative inner ellipse\n\td = max(d, -box(uv - vec2(0, .1), vec2(.22 - .02 * t, .12))); // cut off far part\n\td = max(d, -box(uv - vec2(0, .1), vec2(.084 - .012 * t, .31))); // cut off mid part\n\td = min(d, box1(uv - vec2(0, -.09), vec2(tri(-.09, .32, uv.y)*(.04 - .015 * t), .32))); // middle rhombus\n\td = min(d, box1(uv - vec2(.11 - .02 * t, -.21 + .01 * t), vec2(tri(-.07, .3, uv.y)*(.03 - .01 * t), .15))); // outer rhombi\n\treturn d;\n}\n\n// Quake 1 logo SDF\nfloat sdf_Q(vec2 uv) {\n\tfloat d = circ(uv - vec2(0, .17), .32);\n\td = exclude(d, circ(uv - vec2(0, .235), .27));\n\td = exclude(d, circ(uv - vec2(0, .5), .15));\n\n\t// nail\n\tuv.y -= .09;\n\tvec2 s = vec2(.09, .52);\n\tfloat h = sat(-uv.y / s.y);\n\ts *= .5;\n\ts.x *= ls(1.05, .6, h) + sqr(ls(.1, .02, h));\n\tuv.y += s.y;\n\td = min(d, box(uv, s));\n\n\treturn d;\n}\n\n////////////////////////////////////////////////////////////////\n\n// several layers of boxes with faint grid connectors over a noisy background\n// uv = evaluation point [0..1]\n// b = FBM\n// f = fraction of boxes with horizontal/vertical slats (default 0.2)\nvec3 greebles(vec2 uv, float b, float f) {\n\tfloat\n\t\ti = 5., // initial grid size\n\t\tt = b * b * .3 + .05, // background value\n\t\td, m;\n\n\tfor (; i < 9.; i += 3.) {\n\t\tvec2 p = uv * i, q = floor(p); // grid\n\t\tvec4 h = H4(q + i); // 4 random values per cell\n\t\tp -= q; // relative grid position\n\t\tt = mix(t, .2, .2 * ls(.05, .02, mn(abs(p - .5)))); // overlay grid (connectors)\n\t\tq = h.xy * .4 + .15; // box size\n\t\td = box(p -= mix(q, 1.-q, h.zw), q - .05); // box within cell bounds\n\t\tt = mix(t, b * h.z * .2 + .1, m = msk(d, .01)); // add random-intensity box\n\t\tt *= 1.\n\t\t\t+ .7 * tri(.82, .08, abs(p.y / q.y)) * m * h.x * sign(p.y) // top/bottom edge lighting\n            //+ .5 * tri(-.03, .03, d) * h.x // edge highlight\n\t\t\t- .3 * tri(.1, .0, -.05, d) // outer shadow\n\t\t\t- .5 * tri(.05, .05, mod(p.y, .1)) * m * float(h.z < f) // horizontal slats for some objects\n\t\t\t- .5 * tri(.05, .05, mod(p.x, .1)) * m * float(h.z > 1. - f) // vertical slats for some objects\n\t\t;\n\t}\n\n\treturn vec3(t);\n}\n\n////////////////////////////////////////////////////////////////\n\n// \"Asymmetric Blocks\" by Shane\n// https://www.shadertoy.com/view/Ws3GRs\n\nvec3 pattern(vec2 p, float sc, float bv) {\n\tvec3 e = vec3(-1, 0, 1), r = vec3(1e5);\n\tvec2 ip = floor(p*sc), tileID = e.yy;\n\tp -= (ip + .5) / sc;\n\n\tfloat\n\t\th11 = .5 * HT(ip + e.yy, vec2(sc)),\n\t\th10 = .5 * HT(ip + e.xy, vec2(sc)),\n\t\th01 = .5 * HT(ip + e.yz, vec2(sc)),\n\t\th12 = .5 * HT(ip + e.zy, vec2(sc)),\n\t\th21 = .5 * HT(ip + e.yx, vec2(sc)),\n\t\th00 = .5 * HT(ip + e.xz, vec2(sc)),\n\t\th02 = .5 * HT(ip + e.zz, vec2(sc)),\n\t\th22 = .5 * HT(ip + e.zx, vec2(sc)),\n\t\th20 = .5 * HT(ip + e.xx, vec2(sc));\n\n\tvec2[4] ctr, l;\n\tif (mod(ip.x + ip.y, 2.) < .5) {\n\t\tl[0] = 1. + vec2(h21 - h10, h11 - h20);\n\t\tl[1] = 1. + vec2(h12 - h21, h11 - h22);\n\t\tl[2] = 1. + vec2(h01 - h10, h00 - h11);\n\t\tl[3] = 1. + vec2(h12 - h01, h02 - h11);\n\t\tctr[0] = vec2(h21, h11);\n\t\tctr[1] = vec2(h21, h11);\n\t\tctr[2] = vec2(h01, h11);\n\t\tctr[3] = vec2(h01, h11);\n\t} else {\n\t\tl[0] = 1. + vec2(h11 - h20, h10 - h21);\n\t\tl[1] = 1. + vec2(h22 - h11, h12 - h21);\n\t\tl[2] = 1. + vec2(h11 - h00, h01 - h10);\n\t\tl[3] = 1. + vec2(h02 - h11, h01 - h12);\n\t\tctr[0] = vec2(h11, h10);\n\t\tctr[1] = vec2(h11, h12);\n\t\tctr[2] = vec2(h11, h10);\n\t\tctr[3] = vec2(h11, h12);\n\t}\n\n\tfor (int i=0; i<4; i++) {\n\t\tctr[i] += l[i] * (vec2(i&1, i/2) - .5);\n\t\tl[i] /= sc;\n\t\tfloat bx = box1(p - ctr[i]/sc, l[i]/2. - bv/sc);\n\t\tif (bx < r.x)\n\t\t\tr = vec3(bx, ip + ctr[i]);\n\t}\n\n\treturn r;\n}\n\n////////////////////////////////////////////////////////////////\n\n// Voronoi diagram\n// xy = offset; z = edge distance\n#define VORO_FUNC(name, norm)\t\t\t\t\t\t\t\t\t\t\\\n\tvec3 name(vec2 p, vec2 grid) {\t\t\t\t\t\t\t\t\t\\\n\t\tp *= grid;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tvec2 n = floor(p), f = p - n, mr, g, o, r;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfloat md = 8., sd = md, d;\t\t\t\t\t\t\t\t\t\\\n\t\tfor (int i = 0; i < 9; ++i) {\t\t\t\t\t\t\t\t\\\n\t\t\tg = vec2(i % 3 - 1, i / 3 - 1);\t\t\t\t\t\t\t\\\n\t\t\to = H2(mod(n + g, grid));\t\t\t\t\t\t\t\t\\\n\t\t\tr = g + o - f;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\td = norm;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (d < md) {\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tsd = md;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tmd = d;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tmr = r;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t} else if (d < sd) {\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tsd = d;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn vec3(mr, sd - md);\t\t\t\t\t\t\t\t\t\\\n\t}\n\nVORO_FUNC(voro1, sum(abs(r))) // L1 (Manhattan) norm\nVORO_FUNC(voro, length(r)) // L2 norm\n\n////////////////////////////////////////////////////////////////\n\n// Ring of wires\n// c = background color\n// uv = evaluation point\n// p = ring center radius\n// s = radial ring extent\nvec3 wire_ring(vec3 c, vec2 uv, float p, float s) {\n    float\n        n = NT(uv, vec2(13)) - .5, // smooth angular distortion\n        k = NT(uv, vec2(17)) - .5, // smooth radial distortion\n        r = length(uv -= .5), // radius\n        d, m\n    ;\n    vec2 q = fract(vec2(nang(uv) * 22. + k * .1, r * 55. + n * .6)); // scaled/distorted polar coordinates\n    d = mn(abs(q - .5) * vec2(2, .5 + n * .3)); // wire distance\n    m = ls(.01, .0, abs(r - p) - s); // interior mask\n    c *= 1.\n        + .3 * m * tri(.0, .2, d) // wire highlight\n        - .5 * m * tri(.3, .3, d) // wire shadow\n    ;\n    return c;\n}\n\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n\nconst int\n    VIEW_BASE_COLOR\t\t= 0,\n    VIEW_ALPHA\t\t\t= 1,\n    VIEW_BLACK_MATTE\t= 2,\n    VIEW_CHECKER\t\t= 3,\n    VIEW_CHECKER_TEST\t= 4,\n    ALPHA_MODE_COUNT\t= 5\n;\n\nstruct State {\n    float zoom;\n    float time_offset;\n    vec2 offset;\n    vec2 prev_mouse;\n    int alpha_mode;\n    bool tile;\n    bool center;\n};\n\nvoid reset(out State state) {\n    state.zoom = 1.;\n    state.time_offset = 0.;\n    state.offset = vec2(0);\n    state.prev_mouse = vec2(0);\n    state.alpha_mode = VIEW_CHECKER;\n    state.tile = true;\n    state.center = false;\n}\n    \nvoid load(sampler2D tex, out State state) {\n    vec4 v0 = texelFetch(tex, ivec2(0, 0), 0);\n    vec4 v1 = texelFetch(tex, ivec2(1, 0), 0);\n\n    state.zoom = v0.x;\n    state.time_offset = v0.y;\n    state.offset = v0.zw;\n\n    state.prev_mouse = v1.xy;\n    state.alpha_mode = int(v1.z);\n    int flags = int(v1.w);\n    state.tile = (flags & 1) != 0;\n    state.center = (flags & 2) != 0;\n}\n\nvoid store(inout vec4 fragColor, vec2 fragCoord, State state) {\n\t#define ON(x,y) all(equal(ivec2(fragCoord), ivec2(x, y)))\n    \n    if (ON(0, 0))\n        fragColor = vec4(state.zoom, state.time_offset, state.offset);\n    if (ON(1, 0))\n        fragColor = vec4(state.prev_mouse, state.alpha_mode, int(state.tile) | (int(state.center) << 1));\n    \n\t#undef ON\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "const int\n\tKEY_A = 65, KEY_B = 66, KEY_C = 67, KEY_D = 68, KEY_E = 69, KEY_F = 70, KEY_G = 71, KEY_H = 72, KEY_I = 73, KEY_J = 74,\n\tKEY_K = 75, KEY_L = 76, KEY_M = 77, KEY_N = 78, KEY_O = 79, KEY_P = 80, KEY_Q = 81, KEY_R = 82, KEY_S = 83, KEY_T = 84,\n\tKEY_U = 85, KEY_V = 86, KEY_W = 87, KEY_X = 88, KEY_Y = 89, KEY_Z = 90,\n\n    KEY_0 = 48, KEY_1 = 49, KEY_2 = 50, KEY_3 = 51, KEY_4 = 52, KEY_5 = 53, KEY_6 = 54, KEY_7 = 55, KEY_8 = 56, KEY_9 = 57,\n\n\tKEY_PLUS\t\t= 187,\n\tKEY_MINUS\t\t= 189,\n\tKEY_EQUAL\t\t= KEY_PLUS,\n    \n    // firefox...\n    KEY_PLUS_FF\t\t= 61,\n    KEY_MINUS_FF\t= 173, \n\n\tKEY_SHIFT\t\t= 16,\n\tKEY_CTRL\t\t= 17,\n\tKEY_ALT\t\t\t= 18,\n    \n    KEY_ESC\t\t\t= 27,\n\t\n    KEY_BKSP \t\t=  8,\n    KEY_TAB\t\t\t=  9,\n\tKEY_END\t\t\t= 35,\n\tKEY_HOME\t\t= 36,\n\tKEY_INS\t\t\t= 45,\n\tKEY_DEL\t\t\t= 46,\n\tKEY_INSERT\t\t= KEY_INS,\n\tKEY_DELETE\t\t= KEY_DEL,\n\n\tKEY_ENTER\t\t= 13,\n\tKEY_SPACE \t\t= 32,\n\tKEY_PAGE_UP \t= 33,\n\tKEY_PAGE_DOWN \t= 34,\n\tKEY_PGUP \t\t= KEY_PAGE_UP,\n\tKEY_PGDN \t\t= KEY_PAGE_DOWN,\n\n\tKEY_LEFT\t\t= 37,\n\tKEY_UP\t\t\t= 38,\n\tKEY_RIGHT\t\t= 39,\n\tKEY_DOWN\t\t= 40,\n\n    KEY_PAD_PLUS\t= 107,\n    KEY_PAD_MINUS\t= 109,\n    KEY_PAD_SLASH\t= 111,\n    KEY_SLASH\t\t= 191\n;\n\nfloat key_down(int key) { return texelFetch(iChannel1, ivec2(key, 0), 0).x; }\nfloat key_pressed(int key) { return texelFetch(iChannel1, ivec2(key, 1), 0).x; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    ivec2 addr = ivec2(fragCoord);\n\n\tState state;\n    if (iFrame == 0) {\n        reset(state);\n        if (iTime > 5.) { // thumbnail\n            state.time_offset -= 10.;\n        }\n    } else {\n        fragColor = texelFetch(iChannel0, addr, 0);\n        load(iChannel0, state);\n    }\n\n    float alt = key_down(KEY_ALT);\n    float zoom =\n        key_down(KEY_PAD_PLUS) - key_down(KEY_PAD_MINUS) +\n        max(key_down(KEY_PLUS), key_down(KEY_PLUS_FF)) - max(key_down(KEY_MINUS), key_down(KEY_MINUS_FF));\n    zoom = exp2(-zoom * iTimeDelta * 3.);\n\n    state.zoom *= zoom;\n\n    if (max(key_pressed(KEY_PAD_SLASH), key_pressed(KEY_SLASH)) > 0.) {\n        state.zoom = 1.;\n        state.offset = vec2(0);\n    }\n    \n    //if (key_pressed(KEY_HOME) > 0.)\n    //    state.offset = vec2(0);\n\n    for (int i = 1; i < 9; ++i)\n        if (key_pressed(KEY_0 + i) > 0.)\n\t        state.zoom = alt > 0. ? float(i) : 1. / float(i);\n       \n\tif (key_pressed(KEY_M) > 0.)\n        state.alpha_mode = (state.alpha_mode + 1) % ALPHA_MODE_COUNT;\n\t\n\tif (key_pressed(KEY_T) > 0.)\n        state.tile = !state.tile;\n\t\n\tif (key_pressed(KEY_C) > 0.)\n        state.center = !state.center;\n\n    if (iMouse.z > 0. && state.time_offset == 0.) {\n        vec2 moved = iMouse.xy - abs(iMouse.zw);\n        vec2 delta = moved - state.prev_mouse;\n        if (key_down(KEY_CTRL) > 0.)\n            state.zoom *= exp2(-delta.y / iResolution.y * 2.);\n        else if (key_down(KEY_ALT) > 0.)\n        \tstate.time_offset += delta.x / iResolution.x;\n        else\n        \tstate.offset -= delta / iResolution.xy * state.zoom;\n    \tstate.prev_mouse = moved;\n    } else {\n        state.prev_mouse = vec2(0);\n    }\n\n    state.offset.x += (key_down(KEY_RIGHT) - key_down(KEY_LEFT)) * iTimeDelta * state.zoom;\n    state.offset.y += (key_down(KEY_UP) - key_down(KEY_DOWN)) * iTimeDelta * state.zoom;\n\n    store(fragColor, fragCoord, state);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}