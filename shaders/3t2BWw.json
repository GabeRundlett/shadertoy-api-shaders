{
    "Shader": {
        "info": {
            "date": "1599219377",
            "description": "After the album cover \"The Afterlife\" by \"The Comet is Coming\":\nhttps://www.thecometiscoming.co.uk/wp-content/uploads/2019/09/CIC_AL_A-900.png",
            "flags": 0,
            "hasliked": 0,
            "id": "3t2BWw",
            "likes": 9,
            "name": "The Afterlife",
            "published": 3,
            "tags": [
                "noise",
                "sun",
                "abstract",
                "sand",
                "dune",
                "reproduction"
            ],
            "usePreview": 0,
            "username": "DrNoob",
            "viewed": 233
        },
        "renderpass": [
            {
                "code": "// Author: Thomas Stehle\n// Title: The Afterlife\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// After the album cover \"The Afterlife\" by \"The Comet is Coming\":\n// https://www.thecometiscoming.co.uk/wp-content/uploads/2019/09/CIC_AL_A-900.png\n\nconst float PI  = 3.141592653589793;\nconst float TAU = 6.283185307179586;\n\nconst int   NUM_SAMPLES = 3;\nconst int   MAX_STEPS   = 35;\nconst float MAX_DIST    = 20.0;\nconst float SURF_DIST   = 0.0001;\n\nconst vec3 GREEN_HSV = vec3(157.0 / 360.0, 0.35, 0.94);\nconst vec3 RED_HSV   = vec3( 18.0 / 360.0, 0.98, 0.94);\n\nconst float INV_ID  = 0.0;\nconst float CUBE_ID = 1.0;\nconst float DUNE_ID = 2.0;\n\n// 1D hash for 3D input\nfloat hash31(in vec3 p) {\n    vec3 q = fract(p * 0.1031);\n    q += dot(q, q.yzx + 33.33);\n    return fract((q.x + q.y) * q.z);\n}\n\n// 2D hash for 2D input by iq\n// https://www.shadertoy.com/view/XdXGW8\nvec2 hash22(in vec2 p) {\n    const vec2 k = vec2(0.3183099, 0.3678794);\n    p = p*k + k.yx;\n    return fract(16.0 * k*fract(p.x * p.y * (p.x + p.y)));\n}\n\n// 2D wave noise by iq\n// https://www.shadertoy.com/view/tldSRj\nfloat wnoise(in vec2 p, in float k, in float time)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f*f * (3.0 - 2.0*f);\n    float c = cos(0.5 * time);\n    float s = sin(0.25 * time);\n    mat2 rot = mat2(c, s, -s, c);\n    return 0.5 + 0.5 *\n        mix( mix( sin(time + k * dot(p, rot * (-1.0 + 2.0 * hash22(i + vec2(0, 0)))) ),\n                  sin(time + k * dot(p, rot * (-1.0 + 2.0 * hash22(i + vec2(1, 0)))) ), f.x),\n             mix( sin(time + k * dot(p, rot * (-1.0 + 2.0 * hash22(i + vec2(0, 1)))) ),\n                  sin(time + k * dot(p, rot * (-1.0 + 2.0 * hash22(i + vec2(1, 1)))) ), f.x), f.y);\n}\n\n// 2D Fractional Brownian motion based on wave noise by iq\n// https://www.shadertoy.com/view/tldSRj\nfloat wfbm(in vec2 p, in float k, in float time) {\n    mat2 rot = mat2(1.6, 1.2, -1.2, 1.6);\n    float v = 0.0;\n    float a = 0.5;\n    const int numOctaves = 5;\n    for (int i = 0; i < numOctaves; ++i) {\n        v += a * wnoise(p, k, time);\n        p = rot * p;\n        a *= 0.5;\n    }\n    return v;\n}\n\nmat2 rot2(in float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat sdPlane(in vec3 p, in float h) {\n    return p.y - h;\n}\n\nfloat duneBump(in vec3 p) {\n    return 0.1 * wnoise(p.xz, 6.0, 0.05 * iTime);\n}\n\nvec2 scene(in vec3 p) {\n    vec3 boxPos = 0.075 * vec3(sin(1.1 * iTime), sin(iTime), 0.0);\n    float d1 = sdBox(p - boxPos, vec3(0.95));\n    float h = 4.0 + 0.3 * (sin(0.676 * p.x) + sin(1.348 * p.z));\n    h += 0.884 * duneBump(p);\n    float d2 = sdPlane(p, -h);\n    return (d1 < d2) ? vec2(d1, CUBE_ID) : vec2(d2, DUNE_ID);\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd) {\n    float t = 0.1;\n    float id = INV_ID;\n    \n    for (int i = 0; i < MAX_STEPS; ++i) {\n        vec3 p = ro + t * rd;\n        vec2 s = scene(p);\n        id = s.y;\n        if (abs(s.x) < SURF_DIST * t) break;\n        t += s.x;\n        if (t > MAX_DIST) break;\n    }\n    \n    if (t > MAX_DIST) {\n        t = -1.0;\n        id = INV_ID;\n    }\n    \n    return vec2(t, id);\n}\n\nvec3 calcNormal(in vec3 p) {\n    float t = scene(p).x;\n    vec2 e = vec2(0.001, 0);\n    vec3 n = t - vec3(scene(p - e.xyy).x, scene(p - e.yxy).x, scene(p - e.yyx).x);\n    return normalize(n);\n}\n\nvec3 rayDir(in vec2 p, in vec3 origin, in vec3 tgt, in float z) {\n    vec3 f = normalize(tgt - origin);\n    vec3 r = normalize(cross(f, vec3(0, 1 ,0)));\n    vec3 u = cross(r, f);\n    vec3 c = f * z;\n    return normalize(c + p.x*r + p.y*u);\n}\n\n// Smoothstep'ed HSV to RGB conversion by iq\n// https://www.shadertoy.com/view/MsS3Wc\nvec3 smoothHsvToRgb(in vec3 c)\n{\n    vec3 rgb = abs(mod(c.x*6.0 + vec3(0.0,4.0,2.0), 6.0) - 3.0) - 1.0;\n    rgb = clamp(rgb, 0.0, 1.0);\n    rgb = rgb*rgb*(3.0 - 2.0*rgb);    \n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nfloat easeInOutSine(in float x) {\n    return -0.5 * (cos(x * PI) - 1.0);\n}\n\nvec3 gradient(in vec2 p) {\n    mat2 R = rot2(-0.75);\n    float scale = 1.1 + 0.2 * sin(iTime);\n    vec2 q = R * (scale * p) + vec2(0.5);\n    vec3 col = mix(GREEN_HSV, RED_HSV, easeInOutSine(clamp(q.x + 0.15, 0.0, 1.0)));\n    return smoothHsvToRgb(col);\n}\n\n// Inspired by https://www.shadertoy.com/view/lljGDt\nfloat sun(in vec2 p, in vec2 center) {\n    vec2 dir = normalize(vec2(1.0, -0.116));\n    const float seedA = 36.0;\n    const float seedB = 21.0;\n    const float speed = 2.5;\n\n    vec2 q = p - center;\n    float angle = dot(normalize(q), dir);\n    float rays = clamp(\n        (0.2 + 0.15 * sin(angle * seedA + iTime * speed)) +\n        (0.3 + 0.2 * cos(-angle * seedB + iTime * speed)), 0.0, 1.0);\n    \n    const float inten = 0.003;\n    float atten = inten / dot(q, q);\n\n    return rays * atten;\n}\n\nvec3 sampleScene(in vec2 uv) {\n    vec3 col = vec3(0);\n\n    // Gradient and sun\n    col += gradient(uv);\n    col += sun(uv, vec2(0, 0.15));\n\n    // Cast ray\n    float angle = -PI / 4.0;\n    vec3 ro = 15.0 * vec3(sin(angle), 0.35, cos(angle));\n    vec3 tgt = vec3(0.0, -0.25, 0.0);\n    vec3 rd = rayDir(uv, ro, tgt, 2.0);\n    vec2 s = castRay(ro, rd);\n\n    // Shade scene\n    if (s.x > 0.0) {\n        // Hit point and normal\n        vec3 p = ro + s.x * rd;\n        vec3 n = calcNormal(p);\n\n        // Cube\n        if (CUBE_ID == s.y) {\n            // Colors on cube surface\n            const vec3 greenHsv  = vec3(87.0 / 360.0, 0.96, 0.79);\n            const vec3 yellowHsv = vec3(45.0 / 360.0, 0.99, 0.98);\n            const vec3 orangeHsv = vec3(35.0 / 360.0, 0.98, 0.96);\n            const vec3 redRgb    = vec3(153, 10, 6) / 255.0;\n\n            // Left side material\n            vec2 qL = rot2(-0.8) * (0.6 * p.xy) + 0.6;\n            vec3 colL = mix(greenHsv, orangeHsv, easeInOutSine(clamp(qL.x, 0.0, 1.0)));\n            vec3 matL = abs(n.x) * smoothHsvToRgb(colL) * pow(wfbm(1.5 * p.yz, PI, iTime + 20.0), 0.15);\n\n            // Top side material\n            // Bump shading inspired by https://www.shadertoy.com/view/Xl2XWz\n            vec2 qT = rot2(1.008) * p.zx;\n            vec3 colT = mix(greenHsv, yellowHsv, clamp(qT.x, 0.0, 1.0));\n            float n1 = wfbm(1.5 * p.zx, PI, 1.0 * iTime + 10.0);\n            float n2 = wfbm(1.6 * p.zx, PI, 1.01 * iTime + 10.0);\n            float b1 = max(n2 - n1, 0.0) / 0.02 * 0.7071;\n            float b2 = max(n1 - n2, 0.0) / 0.02 * 0.7071;\n            b1 = b1 * b1 * 0.5 + pow(b1, 4.0) * 0.5;\n            b2 = b2 * b2 * 0.5 + pow(b2, 4.0) * 0.5;\n            float bump = clamp(0.5 + n1 * n1 * (b1 * 0.2 + b2 * 0.2 + 0.5), 0.0, 1.0);\n            vec3 matT = abs(n.y) * smoothHsvToRgb(colT) * pow(bump, 0.175);\n\n            // Right side material\n            vec3 matR = abs(n.z) * redRgb * (0.1 + wfbm(0.75 * p.xy, PI, iTime));\n\n            col = matL + matT + matR;\n        }\n        // Dune\n        else if (DUNE_ID == s.y) {\n            // Material\n            vec3 mat = vec3(0.18) + 0.180 * duneBump(p);\n\n            // Lighting\n            vec3 sunDir = normalize(vec3(0.8, 0.4, 0.2));\n            vec3 duneCol = mat * vec3(7.0, 4.5, 3.0) * clamp(dot(n, sunDir), 0.0, 1.0);\n\n            // Gamma correct\n            duneCol = pow(duneCol, vec3(0.4545));\n\n            // Mix with gradient\n            col = mix(col, col * duneCol, 0.35);\n        }\n    }\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize input coordinates\n    vec2 uv = (fragCoord.xy - 0.5*iResolution.xy) / iResolution.y;\n    \n    // Result color\n    vec3 col = vec3(0);\n    \n    // Enforce square format\n    if (abs(uv.x) < 0.5 && abs(uv.y) < 0.5) {\n        // Multi-sample scene\n        vec2 sss = 1.0 / (float(NUM_SAMPLES) * iResolution.xy);\n        for (int sy = 0; sy < NUM_SAMPLES; ++sy) {\n            for (int sx = 0; sx < NUM_SAMPLES; ++sx) {\n                col += sampleScene(uv + vec2(float(sx), float(sy)) * sss);\n            }\n        }\n        col /= float(NUM_SAMPLES) * float(NUM_SAMPLES);\n\n        // Add layer of animated dust over dune section\n        vec2 off = 5.0 * vec2(0.5 + 0.5 * sin(0.2 * iTime), 0);\n        float dust = 0.2 + 0.2 * wnoise(5.0 * uv - off, PI, 0.2 * iTime);\n        col = mix(col, vec3(dust), smoothstep(-0.1, -0.75, uv.y));\n    \n        // Add layer of animated white noise\n        col += 0.05 * vec3(hash31(vec3(fragCoord.xy, fract(0.001 * iTime))));\n\n        // Vignetting\n        float vig = length(uv) * 0.5;\n        vig = vig * vig + 1.0;\n        col *= 1.0 / (vig * vig);\n    }\n    \n    // Final result\n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}