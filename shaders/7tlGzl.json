{
    "Shader": {
        "info": {
            "date": "1622659943",
            "description": "This is inspired by this video : watch?v=X-iSQQgOd1A\n\nI think I'm gonna move on to a custom software as the method I use for indexing particles creates some artifacts (I just copy pasted this principle : https://www.shadertoy.com/view/3ty3Dy )",
            "flags": 32,
            "hasliked": 0,
            "id": "7tlGzl",
            "likes": 21,
            "name": "Fungants",
            "published": 3,
            "tags": [
                "fungus"
            ],
            "usePreview": 0,
            "username": "WaifuFarmer",
            "viewed": 686
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    //fragColor = vec4(pow(vec3(col.r * sin(iTime*0.28) + col.g * cos(iTime*0.27),col.g * sin(iTime*0.26) + col.b * cos(iTime*0.25),col.g * sin(iTime*0.24) + col.r * cos(iTime*0.23)), vec3(0.454545)), 1.0);\n    fragColor = vec4(col, 0.3);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define ASPECT_RATIO iResolution.x / iResolution.y\n#define PI 3.14159265359\n#define TAU 6.28318530718\n#define RESET 0.00\n\n#define FRAGCOORD_HASH hash(uint(fragCoord.x * 10000. + fragCoord.y))\n#define FRAGCOORD_HASH_AND(RHS) hash(uint(mod(fragCoord.x * 10000., 4.) + mod(fragCoord.y, 4.)) + hash(uint(iFrame / 6))) & RHS\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nuint hash(uint n)\n{\n    n ^= 2747636419u;\n    n *= 2654435769u;\n    n ^= n >> 16;\n    n *= 2654435769u;\n    n ^= n >> 16;\n    n *= 2654435769u;\n    return (n);\n}\n\n/*\n    Cell(42bits -> 0x3ffffffffff) : {\n        position_x (14bits -> 0x3fff),\n        position_y (13bits -> 0x1fff),\n        direction  ( 9bits -> 0x01ff),\n        velocity   ( 6bits -> 0x003f)\n    }\n*/\n\nvoid vec4tocell3(vec4 data, out vec4 cell0, out vec4 cell1, out vec4 cell2)\n{\n    uint r = floatBitsToUint(data.r);\n    uint g = floatBitsToUint(data.g);\n    uint b = floatBitsToUint(data.b);\n    uint a = floatBitsToUint(data.a);\n    \n    float cell0_x = float(a & 0x3fffu) / float(0x3fff);\n    a >>= 14;\n    float cell0_y = float(a & 0x1fffu) / float(0x1fff);\n    a >>= 13;\n    float cell0_d = TAU * float((a & 0x001fu) + ((b & 0x000fu) << 5)) / float(0x01ff);\n    b >>= 4;\n    float cell0_v = float(b & 0x003fu) / float(0x003f);\n    b >>= 6;\n    float cell1_x = float(b & 0x3fffu) / float(0x3fff);\n    b >>= 14;\n    float cell1_y = float((b & 0x0fffu) + ((g & 0x0001u) << 12)) / float(0x1fff);\n    g >>= 1;\n    float cell1_d = TAU * float(b & 0x01ffu) / float(0x01ff);\n    g >>= 9;\n    float cell1_v = float(g & 0x003fu) / float(0x003f);\n    g >>= 6;\n    float cell2_x = float(g & 0x3fffu) / float(0x3fff);\n    g >>= 14;\n    float cell2_y = float((g & 0x0003u) + ((r & 0x007ffu) << 2)) / float(0x1fff);\n    r >>= 11;\n    float cell2_d = TAU * float(r & 0x01ffu) / float(0x01ff);\n    r >>= 9;\n    float cell2_v = float(r & 0x003fu) / float(0x003f);\n    \n    cell0 = vec4(cell0_x, cell0_y, cell0_d, cell0_v);\n    cell1 = vec4(cell1_x, cell1_y, cell1_d, cell1_v);\n    cell2 = vec4(cell2_x, cell2_y, cell2_d, cell2_v);\n}\n\n\n#define N 1. // use only 1/N % of the max Rx*Ry particles (for readability)\n\n// Buff B (1) store Voronoï tracking acceleration structure;\n//            xyzw: ids of 4 closest partics to buffer location\n// Buff A (0) stores particles: \n//            xy: position zw: velocity\n\n// --- translate particle id (in [1,Rx*Ry] ) to buffer pixel \n#define A(n) T0( vec2( (int(n)-1) % iR.x,      \\\n                       (int(n)-1) / iR.x ) +.5 )  // +.5 useless\n\n// --- utils\n                           \n#define R     iResolution.xy\n#define iR    ivec2(iResolution)\n#define T0(U) texelFetch( iChannel0, ivec2(U)   , 0 )\n#define T1(U) texelFetch( iChannel1, ivec2(U)%iR, 0 )\n#define T2(U) texelFetch( iChannel2, ivec2(U)   , 0 )\n\n#define l2(x) dot(x,x)\n\n                           \n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n                           \n// --- keyboard\n#define key(k,mode) ( texelFetch( iChannel3, ivec2(k,mode), 0 ).x > .5 )\n#define keyDown(k) key(k,0)\n#define  keyHit(k) key(k,1)\n#define keyFlip(k) key(k,2)\n\n\n// --- random numbers\n\nint IHash(int a){\n\ta = (a ^ 61) ^ (a >> 16);\n\ta = a + (a << 3);\n\ta = a ^ (a >> 4);\n\ta = a * 0x27d4eb2d;\n\ta = a ^ (a >> 15);\n\treturn a;\n}\n\n#define Hash(a) ( float(IHash(a)) / float(0x7FFFFFFF) ) // Uniform in [0,1]\n\nvec4 rand4(int seed){\n    return vec4(Hash(seed^0x34F85A93),\n                Hash(seed^0x85FB93D5),\n                Hash(seed^0x6253DF84),\n                Hash(seed^0x25FC3625));\n}\n\n// --- normal law random generator\nvec2 randn(vec2 r){ // r: randuniform\n    r.x = sqrt( -2.* log(1e-9+abs(r.x)));\n    r.y *= TAU;\n    return r.x * vec2(cos(r.y),sin(r.y));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define MAGIC 3000\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint index = uint(fragCoord.y) * uint(iResolution.x) + uint(fragCoord.x);\n    vec2 uv = (fragCoord - 0.5) / iResolution.xy;\n    \n    //if (uint(mod(float(FRAGCOORD_HASH_AND(uint(MAGIC))), float(MAGIC))) == 0u)\n    \n    //if (iFrame <= 10 || iMouse.z > 0.5 || uint(mod(float(FRAGCOORD_HASH_AND(uint(MAGIC))), float(MAGIC))) == 0u)\n    //{\n    if (iFrame <= 10 || iMouse.z > 0.5)\n    {\n        uint size = uint(iResolution.x) * uint(iResolution.y);\n        //size = 342120u;\n        \n        uint hash_r = hash(0u * size + index + uint(iDate.w)) & 0xffffu;\n        uint hash_g = hash(1u * size + index + uint(iDate.w)) & 0xffffu;\n        float qqq = mod(fragCoord.x, iResolution.x / 3.) / (iResolution.x / 3.);\n        if (qqq < 0.2)\n        {\n            hash_r = 32768u;\n            hash_g = 32768u;\n        }\n        else if (qqq < 0.4)\n        {\n            hash_r = 16384u;\n            hash_g = 16384u;\n        }\n        else if (qqq < 0.6)\n        {\n            hash_r = 32768u+16384u;\n            hash_g = 16384u;\n        }\n        else if (qqq < 0.8)\n        {\n            hash_r = 16384u;\n            hash_g = 32768u+16384u;\n        }\n        else\n        {\n            hash_r = 32768u+16384u;\n            hash_g = 32768u+16384u;\n        }\n        uint hash_b = hash(10u * size + index + uint(iDate.w)) & 0xffffu;\n        uint hash_a = hash(3u * size + index + uint(iDate.w)) & 0xffffu;\n        //fragColor = vec4(uintBitsToFloat(hash_r), uintBitsToFloat(hash_g), uintBitsToFloat(hash_b), uintBitsToFloat(hash_a));\n        fragColor = vec4(float(hash_r) / 65536. * iResolution.x, float(hash_g) / 65536. * iResolution.y, TAU * float(hash_b) / 65536., 0.2 + 0.8 * rand(iTime + float(index * 10000u)));\n        //fragColor = vec4(fragCoord.xy, TAU * float(hash_b) / 65536., float(hash_a) / 65536. / 100.);\n        //fragColor = vec4(fragCoord.xyxy);\n        return;\n    }    \n    //vec4 data = texture(iChannel0, uv);\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    float x = data.r / iResolution.y; // 0->256\n    float y = data.g / iResolution.y; // 0->256\n    float d = data.b; // 0->TAU\n    float a = data.a; // 0->1\n    float v = 0.00025 + a * 0.0005 + RESET;\n    float lookup_distance = mod(iDate.w, 70.) < 50. ? 300. : 10.;\n    lookup_distance = mod(iDate.w, 60.) < 20. ? 100. : lookup_distance;\n    float vv = v * lookup_distance * (sin(iTime / 5.)*.5+.6);\n    \n    \n    vec2 aaa = vec2(cos(d) * vv, sin(d) * vv);\n    vec2 b = vec2(cos(d + PI / 6.) * vv, sin(d + PI / 6.) * vv);\n    vec2 c = vec2(cos(d - PI / 6.) * vv, sin(d - PI / 6.) * vv);\n    \n    vec3 aa = vec3(0.);\n    vec3 bb = vec3(0.);\n    vec3 cc = vec3(0.);\n    for (float i = 2.; i < 5.; i++)\n    {\n        ivec2 tmp = ivec2(mod((vec2(x, y) + aaa * i), vec2(ASPECT_RATIO, 1.)) * iResolution.yy);\n        aa += texelFetch(iChannel1, tmp, 0).rgb;\n        tmp = ivec2(mod((vec2(x, y) + b * i), vec2(ASPECT_RATIO, 1.)) * iResolution.yy);\n        bb += texelFetch(iChannel1, tmp, 0).rgb;\n        tmp = ivec2(mod((vec2(x, y) + c * i), vec2(ASPECT_RATIO, 1.)) * iResolution.yy);\n        cc += texelFetch(iChannel1, tmp, 0).rgb;\n    \n    }\n    \n    float fact = (0.8*(sin(iTime / 3.)*.5+.5)+.2);\n    float turn_speed = 0.0675 * (0.7 + 0.3 * (1.-fact));\n    if (fragCoord.x < iResolution.x / 3.)\n    {\n        if (bb.r > cc.r)\n        {\n            d += PI / 1. * turn_speed;\n        }\n        if (cc.r > bb.r)\n        {\n            d -= PI / 1. * turn_speed;\n        }\n        d += (rand(iTime+float(index)/10.)) * 0.03;\n    }\n    else if (fragCoord.x < 2. * iResolution.x / 3.)\n    {\n        if (bb.g > cc.g)\n        {\n            d += PI / 1. * turn_speed;\n        }\n        if (cc.g > bb.g)\n        {\n            d -= PI / 1. * turn_speed;\n        }\n    }\n    else\n    {\n        if (bb.b > cc.b)\n        {\n            d += PI / 1. * turn_speed;\n        }\n        if (cc.b > bb.b)\n        {\n            d -= PI / 1. * turn_speed;\n        }\n        \n        d -= (rand(iTime+float(index)/10.)) * 0.03;\n    }\n    \n    float fa = ((sin(iTime / 11.) + 1.));\n    float fb = ((1. - sin(iTime / 11.)));\n    \n    if (abs(fa) < 0.7 || abs(fb) < 0.7)\n    {\n        fa = 1.;\n        fb = 1.;\n    }\n    else\n    {\n        fa *= 1./0.7;\n        fa -= sign(fa) * 1.;\n        fb *= 1./0.7;\n        fb -= sign(fa) * 1.;\n    }\n    fa -= 1.;\n    fb -= 1.;\n    d += PI * turn_speed * bb.g * 2. * fa;\n    d -= PI * turn_speed * cc.g * 2. * fb;\n\n    \n    //d = bb;\n    d += fact * 0.2 * (rand(iTime + floor(float(index) / 30000.))-0.5);\n    //d += 0.05 * (smoothstep(0.95, 1., 2.*(sin(iTime * 10.)*.5+.5)*rand(float(index * 100u))) - 0.5);\n    fact -= 0.2;\n    x += cos(d) * (v + v * fact * 1.8);// * (aa.b + 0.5);\n    y += sin(d) * (v + v * fact * 1.8);// * (aa.b + 0.5);\n    //a += (rand(iTime + float(index * 10000u))-0.5) * 0.01;\n    x = mod(x, ASPECT_RATIO);\n    y = mod(y, 1.);\n    //x+=0.4;\n    \n    fragColor = vec4(vec2(x, y) * iResolution.y, mod(d, TAU), a);\n    //fragColor = vec4(data.xy, d, v);\n    //fragColor = data;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// === Voronoï buffer: manage tracking of particles Ids\n\n// --- insert (i,d) and maintain the 4 closest (i_,d_) \nvoid list_insert(inout vec4 i, inout vec4 d, float i_, float d_){\t\n    if(i_ == 0.) return;           // not a particle : exit\n    if(any(equal(vec4(i_),i))) return; // already in top4 : exit\n    if     (d_ < d[0])             // closer to closest: insert here\n        i = vec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             // closer to 2nd closest: insert here\n        i = vec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])             // closer to 3rd closest: insert here\n        i = vec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])             // closer to 4th closest: insert here\n        i = vec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    vec4  i = vec4(0),\n         i0 = T1( I ),             // 4 closests particles here and around\n         ia = T1( I + vec2( 1, 0) ),  // NB: could use an array.\n         ib = T1( I + vec2( 0, 1) ),\n         ic = T1( I + vec2(-1, 0) ),\n         id = T1( I + vec2( 0,-1) );\n\n//#define dist(i) length( A(i).xy - I )\n//#define dist(i) length( mod( A(i).xy-I + R/2., R) - R/2. )  \nvec2 D;\n#define dist(i) ( D = mod( A(i).xy-I + R/2., R) - R/2., dot(D,D) )\n\n    vec4  d = vec4(1e9); \n    for(int k = 0; k < 4; k++){    // sorts all these\n        list_insert( i, d, i0[k], dist(i0[k]) );\n        list_insert( i, d, ia[k], dist(ia[k]) );\n        list_insert( i, d, ib[k], dist(ib[k]) );\n        list_insert( i, d, ic[k], dist(ic[k]) );\n        list_insert( i, d, id[k], dist(id[k]) );\n    }\n#if 1 // also checking diagonal (to test possibly axis bias)\n    ia = T1( I + vec2( 1, 1) ),\n    ib = T1( I + vec2(-1, 1) ),\n    ic = T1( I + vec2( 1,-1) ),\n    id = T1( I + vec2(-1,-1) );\n    for(int k = 0; k < 4; k++){    // sorts all these\n        list_insert( i, d, ia[k], dist(ia[k]) );\n        list_insert( i, d, ib[k], dist(ib[k]) );\n        list_insert( i, d, ic[k], dist(ic[k]) );\n        list_insert( i, d, id[k], dist(id[k]) );\n    }\n#endif\n    \n    for(int k = 0; k < 4; k++){    // try to re-insert some random particle (possibly escaped from tracking)\n      //int r = IHash( int(I.x) + int(I.y)*2048 + iFrame*2048*2048 +k*11131); //deterministic\n        int r = IHash( int(I.x) + int(I.y)*2141 + iFrame*2141*2141 +k*11131); //without 2048 bias\n      //int r = IHash( int(I.x) + int(I.y)*2048 + (int(iTime*2048.)+iFrame)*2048 +k*11131);\n        int i_ =  1 + r % ( int(R.x*R.y)/int(N) ); // [ why /10? ]\n        list_insert(i, d, float(i_), dist(i_) );\n    }\n    O = vec4(i.wzyx);                   // stores 4 closest\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 a = T1(fragCoord);         // 4 particule id (supposed to be particles closest to I)\n    vec4 P;\n    \n    \n    //vec2 uv = ((fragCoord - 0.5) / iResolution.y) - 1.;\n    //vec3 data = texture(iChannel0, uv).rgb;\n    vec3 data = texelFetch(iChannel2, ivec2(fragCoord), 0).rgb;\n\n/*\n    float blue = 0.;\n    if (fragCoord.x > 10. && fragCoord.x < 1000. && fragCoord.y > 10. && fragCoord.y < 710.)\n    {\n        for (float i = -2.; i < 2.5; i++)\n        {\n            for (float j = -2.; j < 2.5; j++)\n            {\n                blue += texelFetch(iChannel2, ivec2(fragCoord + vec2(i, j)), 0).b;\n            }\n        }\n    }\n    */\n\n    //blue /= 18.;\n    //blue = 0.;\n    //data.b += blue;\n    //data.b /= 3.;\n    float scale = 0.13;// - 0.04 * (10. - min(iTime, 10.));\n    data.r -= scale *  0.048 + RESET;\n    if (data.r < 0.)\n        data.r = 0.;\n    data.g -= scale *  0.032 + RESET;\n    if (data.g < 0.)\n        data.g = 0.;\n    data.b -= scale * 0.032 + RESET;\n    if (data.b < 0.)\n        data.b = 0.;\n\n    //vec2 pos = texture(iChannel1, vec2(i, j) / iResolution.xy).xy;\n    //vec2 pos = texelFetch(iChannel1, ivec2(i, j), 0).xy;\n    for(int i = 0; i < 4; i++) // draw Gaussian blobs\n    {\n        P = A(a[i]);\n        if (distance(P.xy, fragCoord.xy) < 0.6)\n        {\n            data += 0.14 * vec3(abs(P.z-PI), 1., (1. * P.w + 0.5)) * pow(1. - data, vec3(4.));\n            break;\n        }\n    }\n    /*\n    if (data.b > 1.)\n        data.b = 1.;\n    if (data.r > 1.)\n        data.r = 1.;\n    if (data.g > 1.)\n        data.g = 1.;*/\n    fragColor = vec4(data, 1.0);\n    if (iFrame <= 10 || iMouse.z > 0.5)\n    {\n        fragColor = vec4(vec3(0.), 1.);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}