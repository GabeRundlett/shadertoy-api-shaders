{
    "Shader": {
        "info": {
            "date": "1637598774",
            "description": "A tunnel ",
            "flags": 32,
            "hasliked": 0,
            "id": "stG3W1",
            "likes": 70,
            "name": "Tunnel Experiment #2",
            "published": 3,
            "tags": [
                "tunnel"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 4436
        },
        "renderpass": [
            {
                "code": "\n#define T(uv) texture(iChannel0,uv)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n\n    //some sort of adhoch antialiasing based on\n    //an anisotrpic effect by:ulianlumia\n    //unstable universe - https://www.shadertoy.com/view/wtlfz8\n    //fragColor = texelFetch(iChannel0, ivec2(fragCoord),0);\n    fragColor = vec4(0.);\n    float f = length(uv  - 0.6);\n    float SHIFT = sin(iTime)*0.002;\n    fragColor.x += T(uv + f*SHIFT).x;\n    fragColor.y += T(uv -f*SHIFT/2.).y;\n    fragColor.z += T(uv-f*SHIFT).z;\n    fragColor.xyz *= 1.5;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define eps 0.001\n#define S smoothstep\n#define T iTime\n#define TX texture\n#define C clamp\n\n#define MAX_STEPS 100\n#define MAX_DIST 50.\n#define pi 3.14159265\n\nfloat ROUNDING_FACTOR = 0.;\nfloat ROTATION_FACTOR = 10.;\n\nfloat TUBE_RIB_REP_FACTOR = 10.;\nfloat TUBE_RIB_AMP_FACTOR = .0;\nfloat TUNNEL_RADIUS_FACTOR = 1.5;\nfloat SIDE_NUM = 3.;\n\nfloat TEETH_FLOAT = 2.;\nfloat TEETH_REACH = 1.5;\nfloat TEETH_SHAPE_X = 0.5;\nfloat TEETH_SHAPE_Y = 0.15;\nfloat TEETH_SHAPE_POW_Z = 0.2;\nfloat CAMERA_Z_POS = 0.;\nfloat CAMERA_ROTATE_XZ = 0.;\nfloat GAMMA = 0.8;\nfloat BRIGHTNESS = 1.;\nvec3 FAR_LIGHT_POS = vec3(0.,0.,1.4);\nvec3 CLOSE_LIGHT_POS = vec3(0.,-0.,-1.4);\nvec3 backgroundColor = vec3(1.);\nfloat PATH_AMPLITUDE = 0.;\n\n\n//uncomment for more movement\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (a - b) / k, 0.0, 1.0 );\n    return mix( b, a, h ) + k * h * (1.0 - h);\n}\n\nmat2 rot(float a){\n    float c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}\n    \nfloat sdBox(vec3 p, vec3 d){\n    p = abs(p)-d;\n    return length(max(p,0.)) + \n    min(max(p.x,max(p.y,p.z)), 0.)-ROUNDING_FACTOR;\n}\nfloat sdBox2D(vec3 p, vec3 d){\n    p = abs(p)-d;\n    //return length(max(p,0.)) + \n    return max(p.x,p.z);\n}\nvec2 modPolar(vec2 p, float n){\n\n    float a0 = float(n) / radians(360.); \n    float a = round( atan(p.y, p.x) * a0 ) / a0;\n    \n    p -= vec2(cos(a), sin(a));\n    \n    p *= rot(-a);\n    \n    return p;\n}\n\nvec3 path(vec3 p){\n    // #if PATH_ON == 1.\n     p.x += sin(p.z/4.)*PATH_AMPLITUDE;\n     p.y += sin(p.z/4.+3.)*PATH_AMPLITUDE;\n   //  #endif\n     return p;\n}\n\nfloat globalID = -1.;\nfloat glow;\n\nfloat map(vec3 p){\n    \n    p = path(p);\n    p.xy*=rot(p.z/(ROTATION_FACTOR));//+(0.5+0.5*sin(mod(iTime/5.,2.)))*2.)   );\n    float radius = TUNNEL_RADIUS_FACTOR;//0.8\n    float num = SIDE_NUM; //5 to 8\n    float z = sin(floor(p.z/4.))/4.;\n    float d = 1000.;\n    float tunnel = length(p.xy) - 3.4 \n                                - abs(sin(p.z*TUBE_RIB_REP_FACTOR))\n                                *TUBE_RIB_AMP_FACTOR;\n    d = min(d,tunnel);\n    //p.xy -= vec2(z);\n    \n    //magic!\n    vec3 st = vec3(modPolar(p.xy, num), mod(p.z, 4.)-2. );\n    \n    float wall = sdBox( st-vec3(radius,0.,0.), vec3(0.1,2.,2.) );\n    d = min(-d,wall);\n    //d = min(d, length(st-vec3(radius,0.,0.))-0.3);\n    \n    //d = min(d, sdBox( st-vec3(radius,0.,0.), vec3(0.6,.3, pow(length(p.xy)-1., 2.7) ) ));\n    \n    //door layer one thick\n    float layer1 = sdBox( st-vec3(radius,0.,0.), vec3(0.5,4.,.1) );\n    //door layer two thinner\n    float layer2 = sdBox( st-vec3(radius,0.,0.), vec3(0.8,3.,.08) );\n    //door layer three really thin edge thing\n    float layer3 = sdBox( st-vec3(radius,0.,0.), vec3(0.84,3.7,.01) );\n    \n    d = min(d,min(layer1,min(layer2,layer3)));\n    //\n    vec3 st3 = vec3(modPolar(p.xy, num), mod(p.z, .2)-.1);\n    float lines = sdBox( st3-vec3(radius*1.0,0.,0.), vec3(0.1, 1.85,.02) );\n    //float lines = sdBox( st3-vec3(radius,0.,0.), vec3(0.15,1.,.03) );\n    d = min(d,lines);\n    vec3 st2 = vec3(modPolar(p.xy, num), mod(p.z, 2.)-1.);\n    //panel thing\n    float panel = sdBox( st2-vec3(radius,0.,0.), vec3(0.4,1.1,.9));\n    d = min(d,panel);\n    \n    //panel-indent thing\n    //first version has artifacts\n    //float indent = sdBox( st2-vec3(radius*0.74,0.,0.), vec3(0.15,.58,.8) );\n    float indent = sdBox( st2-vec3(radius*0.74,0.,0.), vec3(0.15,.8,.75) );\n    d = smax(d, -indent,0.003);\n    float outdent = sdBox( st2-vec3(radius,0.,0.), vec3(0.15,.5,.78) );\n    d = min(d, outdent);\n    \n    //ramp thing\n    float ramp = sdBox( vec3(st.x,mod(st.y*TEETH_FLOAT,1.)-.5,st.z*TEETH_REACH)-vec3(radius,0.,0.), vec3(TEETH_SHAPE_X,TEETH_SHAPE_Y, pow(length(st.x/9.)/9., TEETH_SHAPE_POW_Z) ));\n    \n    /*\n    //basic ramp no teeth\n    ramp = sdBox(st-vec3(radius,0.,0.), vec3(0.8,.2, pow(length(st.x/4.), 1.9) ));\n    \n    //basic side teeth\n    ramp = sdBox( vec3(st.x,mod(st.y*4.,1.)-.5,st.z)-vec3(radius,0.,0.), vec3(0.8,.2, pow(length(st.x/4.), 1.9) ));\n\n    //full teeth\n    ramp = sdBox( vec3(st.x,mod(st.y*4.,1.)-.5,st.z)-vec3(radius,0.,0.), vec3(0.85,.3, pow(length(st.x/4.), 1.9) ));\n\n    //thin cover\n    ramp = sdBox( vec3(st.x,mod(st.y*4.,1.)-.5,st.z)-vec3(radius,0.,0.), vec3(1.5,.3, pow(length(st.x/7.), 1.) ));\n\n    //cover\n    ramp = sdBox( vec3(st.x,mod(st.y*4.,1.)-.5,st.z)-vec3(radius,0.,0.), vec3(1.,.3, pow(length(st.x/1.), 1.) ));\n    //exposed\n    ramp = sdBox( vec3(st.x,mod(st.y*4.,1.)-.5,st.z)-vec3(radius,0.,0.), vec3(.8,.3, pow(length(st.x/1.), 1.) ));\n    */  \n    \n    \n    //ramp = max(ramp, -sdBox( st-vec3(radius,0.,-.3), vec3(0.5,.05, 0.2 ) ));\n    d = smin(d,ramp,0.01);\n    \n    vec3 st4 = vec3(p.x,p.y,mod(p.z,2.)-1.);\n    float bridge = sdBox( st4-vec3(0.,-1.1,0.), vec3(0.6,.04, .8 ));\n    //d = min(d,bridge);\n    //globalID = 5.;\n    \n    float minVal = min(min(\n                        min(\n                            min(layer3,lines),\n                            min(panel,bridge)),\n                        min(\n                            min(wall, outdent),\n                            min(layer1,layer2))), min(indent,ramp));\n                            \n    minVal = min(minVal,-tunnel);\n    if(minVal == wall)globalID = 32.;\n    \n    else if(minVal == layer1)globalID = 2.;\n    else if(minVal == layer2)globalID = 3.;\n    else if(minVal == layer3)globalID = 4.;\n    else if(minVal == outdent)globalID = 5.;\n    else if(minVal == lines)globalID = 6.;\n    else if(minVal == bridge)globalID = 7.;\n    else if(minVal == panel)globalID = 5.;\n    else if(minVal == ramp)globalID = 5.;\n    else if(minVal == -tunnel)globalID = 33.;\n    //else globalID = 9.;\n    \n    //else if(minVal == tunnel)globalID = 80.;\n    \n    if(minVal == layer3){\n        glow += smoothstep(0.2,1.,0.015/pow(layer3,.9))*3.;\n    }\n    if(minVal == lines){ \n       glow += abs(max(0.01,(0.0001/(0.03*pow(lines, 1.)))));\n    }\n    \n    \n    return d;\n}\n\nfloat trace(vec3 ro, vec3 rd){\n    \n    float t, d= 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n        d = map(ro + rd*t);\n        if(abs(d) < 0.001 || t > MAX_DIST) break;\n        t += d*0.75;\n    }\n    \n    return t;\n}\n\nfloat rtrace(vec3 ro, vec3 rd){\n    \n    float t, d= 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n        d = map(ro + rd*t);\n        if(abs(d) < 0.001 || t > MAX_DIST) break;\n        t += d*0.85;\n    }\n    \n    return t;\n}\nvec3 normal(vec3 p){\n    \n    float d = map(p);\n    vec2 e = vec2(eps,0.);\n    \n    vec3 n = d - vec3(\n            map(p-e.xyy),\n            map(p-e.yxy),\n            map(p-e.yyx));\n            \n    return normalize(n);\n}\nvec3 camRay(vec2 uv, vec3 o, vec3 target, float zoom){\n    \n    vec3 fwd = normalize(target - o);\n    vec3 uu = vec3(0.,1.,0.);\n    vec3 right = normalize(cross(uu, fwd));\n    //order matters\n    vec3 up = cross(fwd,right);\n    vec3 rd = right*uv.x + up*uv.y + fwd*zoom;\n    return normalize(rd);\n\n}\n\n//from shane\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .002;    \n    float end = max(length(rd), .001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, .2), \n        // clamp(h, .02, stepDist*2.), etc.\n        dist += clamp(h, .02, .25);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist>end) break; \n        //if (h<.001 || dist > end) break; // If you're prepared to put up with more artifacts.\n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me.\n    return min(max(shade, 0.) + .25, 1.); \n}\nfloat getGrey(vec3 p)\n{\n    return p.x*0.299 + p.y*0.587 + p.z*0.114;\n       }\n\n//from shane, and he got it from an nvidia tutorial you can google\nvec3 triPlanar(sampler2D tex, vec3 p, vec3 n)\n{\n\n vec3 norm = max(abs(n), 0.0001);\t//I'll keep it simple with just this\n float sum = norm.x+norm.y+norm.z;\n norm = norm/sum;\n    return vec3(texture(tex, p.yz)*norm.x + \n                texture(tex, p.xz)*norm.y +\n                texture(tex, p.xy)*norm.z) ;\n    \n}\n\nvec3 bumpMap(sampler2D tex, in vec3 p, in vec3 n, float bumpfactor)\n{\n\n    const vec3 eps3 = vec3(0.001, 0., 0.);//I use swizzling here, x is eps\n    float ref = getGrey(triPlanar(tex, p, n));//reference value \n    vec3 grad = vec3(getGrey(triPlanar(tex, p - eps3, n)) - ref,\n                     //eps.yxz means 0.,0.001, 0. \"swizzling\n                     getGrey(triPlanar(tex, p - eps3.yxz, n)) - ref,\n                     getGrey(triPlanar(tex, p - eps3.yzx, n)) - ref)/eps3.xxx;\n    \n    grad -= n*dot(grad, n);\n\n    return normalize(n + grad*bumpfactor);\n}\n\nfloat calcAo(vec3 p, vec3 n)\n{\n \nconst float ao_samples = 5.;\n    float r = 0.0, w = 1.0, d;\n    for(float i = 0.01 ; i<ao_samples ; i+=1.1)\n    {\n    d = i/ao_samples;//1/5, 2/5, 3/5, 4/5, 1\n    r += w*(d - map(p + n*d));\n    w*=0.5;\n    }\n\n    return 1.0 - clamp(r,0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n   // vec2 m = iMouse.xy/iResolution.xy;\n   // fragColor = vec4(0.);\n    vec3 ro = vec3(0., 0., -3.+iTime*3. + CAMERA_Z_POS);\n    ro = vec3(-path(ro).xy,ro.z);\n    //ro.yz *= rot(-m.y*pi+1.);\n    //ro.xz *= rot(-m.x*pi*2.);\n    \n    //I was getting some artifacts when I had y at 0.4 or -0.4\n    //for these lights. Glow related artifacts, which was weird.\n    //So I am just letting the x and y be guided by ro.\n    vec3 farLight = ro + FAR_LIGHT_POS;\n    vec3 closeLight = ro + CLOSE_LIGHT_POS;\n    vec3 rd = camRay(uv, ro, ro + vec3(0.,0.,1.), 0.8);\n    rd.xz *= rot(CAMERA_ROTATE_XZ);\n    \n    float t = min(MAX_DIST,trace(ro, rd));\n    \n    \n    // Time varying pixel color\n    vec3 col = vec3(0.0);//TX(iChannel0, rd).rgb;\n    vec3 rcol = vec3(0.);\n    if(t < MAX_DIST){\n    \n        vec3 p = ro + rd*t;\n        vec3 n = normal(p);\n        \n        //col = n*0.5+0.5;//0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n        //col = abs(fract(vec3(atan(p.y,p.x)*pi,p.z,p.z))-0.5);\n        //col= n*0.5+0.5;\n        \n        vec3 seedColor= vec3(3.,2.,5.)/2.;\n        seedColor.xy *= rot(.7);\n        vec3 alb = 1.*vec3((0.5+0.5*cos(seedColor*8. + globalID*6. + 30.).x)*1.2>0.);\n        alb = 0.5+0.5*cos(seedColor*8. + globalID*19. + 34.);\n        //alb.xz *= rot(1.3);\n        alb = alb.zzz-0.1;\n        \n        //alb = 0.5+0.5*cos(vec3(1.,2.,4.)/1. + globalID*54.+1.);\n        \n        if(globalID < 2.) {\n            alb *= triPlanar(iChannel0,p/4.,n).xxx;\n            #ifdef BUMP_MAP_ON\n                n = bumpMap(iChannel0, p/4., n, 0.01);\n            #endif\n        }\n        \n        else if(globalID == 6.){ alb = pow(\n            triPlanar(iChannel1,p/4.,n).xxx,vec3(1.))*3.;\n            #ifdef BUMP_MAP_ON\n                n = bumpMap(iChannel1, p/4., n, 0.01);\n            #endif\n            }\n        \n        else if(\n            globalID < 8.){ alb *= triPlanar(iChannel2,p/4.,n).xxx;\n            #ifdef BUMP_MAP_ON\n                n = bumpMap(iChannel2, p/4., n, 0.01);\n            #endif\n        }\n        \n        //alb = pow(alb,vec3(.3));\n\n        if(globalID == 32.){ alb = backgroundColor*vec3(1.,0.3,0.);}\n        if(globalID == 33.){ alb = backgroundColor*vec3(0.,0.3,0.8);}\n\n        //light 1\n        float ldist = length(farLight-p);\n        vec3 ldir = (farLight-p)/ldist;\n        float diff = max(dot(ldir,n),0.);\n        float spec = pow(max(dot(reflect(-ldir,n),-rd),0.),200.)*1.;\n        col = alb*0.9*diff + spec*vec3(0.5,0.8,0.9);\n        \n        float sha = softShadow(p,farLight,12.);\n        float ao = calcAo(p,n);\n        col *= ao;\n        col *= sha;\n        \n        //light 2\n        ldist = length(closeLight-p);\n        ldir = (closeLight-p)/ldist;\n        diff = max(dot(ldir,n),0.);\n        spec = pow(max(dot(reflect(-ldir,n),-rd),0.),100.)*1.;\n        col += alb*0.3*diff*vec3(1.,0.7,0.7);\n        col/=2.;\n        \n        \n        col += vec3(0.5+0.5*cos(iTime + seedColor + sin(p)/2.))*clamp(glow,0.,1.);//*pow(t/MAX_DIST,.7);\n\n    }\n    \n    col = mix(col,vec3(0.), pow(t/MAX_DIST,1.9));\n    \n    // Output to screen\n    col *= BRIGHTNESS;\n    col = pow(col, vec3(GAMMA));\n    fragColor = vec4(col,1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*#define ROUNDING_FACTOR 0.\n#define ROTATION_FACTOR 10.\n\n#define TUBE_RIB_REP_FACTOR 10.\n#define TUBE_RIB_AMP_FACTOR .01\n#define TUNNEL_RADIUS_FACTOR 1.5\n#define SIDE_NUM 3.\n\n#define TEETH_FLOAT 2.\n#define TEETH_REACH 1.5\n#define TEETH_SHAPE_X 0.5\n#define TEETH_SHAPE_Y 0.15\n#define TEETH_SHAPE_POW_Z 0.2\n\n#define CAMERA_Z_POS 0.\n#define CAMERA_ROTATE_XZ 0.\n#define GAMMA 0.8\n#define BRIGHTNESS 1.\n#define FAR_LIGHT_POS vec3(0.,0.,1.4)\n#define CLOSE_LIGHT_POS vec3(0.,-0.,-1.4)\n\n\n#define backgroundColor vec3(1.)\n#define PATH_AMPLITUDE 0.\n\n//#define PATH_ON 0.\n//#define BUMP_MAP_ON 0.\n\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}