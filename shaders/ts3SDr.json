{
    "Shader": {
        "info": {
            "date": "1571769870",
            "description": "modified version of my first 3D KIFS attempt ( https://www.shadertoy.com/view/3dcXWr ).\n",
            "flags": 0,
            "hasliked": 0,
            "id": "ts3SDr",
            "likes": 5,
            "name": "even weireder KIFS",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "kifs"
            ],
            "usePreview": 0,
            "username": "SSHantaram",
            "viewed": 327
        },
        "renderpass": [
            {
                "code": "const int MAX_MARCHING_STEPS = 127;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 50.0;\nconst float EPSILON = 0.005;\n\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nvec4 sceneSDF(vec3 p, vec2 uv) {\n    // by varying the elapsed time for each pixel the animation is at a different\n    // point for each pixel, resulting in mor organic and less symmetric geometry\n    // this is basically a 3D version of the rolling shutter effect\n    float time = iTime + uv.y*20.0 - uv.x*12.0;\n    \n    // angles for rotation\n    float alpha = -3.2 + 0.1*sin(time*0.11);\n    float beta = 1.02 + 0.1*cos(time*0.2);\n    \n    // rotation matrices\n    mat3 rot1 = mat3(1.0, 0.0, 0.0, 0.0, cos(alpha), -sin(alpha), 0.0, sin(alpha), cos(alpha));\n    mat3 rot2 = mat3(cos(beta), -sin(beta), 0.0, sin(beta), cos(beta), 0.0, 0.0, 0.0, 1.0);\n    \n    // normals for reflection\n    vec3 n1 = normalize(vec3(-0.8, 1.2 - 0.2*sin(time*0.1), -0.8));\n    vec3 n2 = normalize(vec3(0.4 + 0.15*cos(time*0.112), 0.4, -0.1 + 0.05*cos(time*0.133)));\n    \n    // repeat several times\n    for (int i = 0; i < 20; i++)\n    {\n        p-=2.0 * min(0.0, dot(p, n1)) * n1;\t\t// first reflection\n        p += vec3(0.1, -0.1, 0.1);\t\t\t\t// translate\n        p *= rot1;\t\t\t\t\t\t\t\t// rotate\n        p-=2.0 * min(0.0, dot(p, n2)) * n2;\t\t// second reflection\n    \tp += vec3(-0.1, 0.1, 0.0);\t\t\t\t// translate\n        p *= rot2;\t\t\t\t\t\t\t\t// rotate\n    }\n    return vec4(length(p) - 0.5, p);\t// return distance to sphere and p for coloring\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nvec4 shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end, int max_steps, vec2 uv) {\n    float depth = start;\n    vec4 result;\n    for (int i = 0; i < max_steps; i++) {\n        result = sceneSDF(eye + depth * marchingDirection, uv);\t// get distance + transformed point\n        float dist = result.x;\n        if (dist < EPSILON) {\n\t\t\treturn vec4(depth, result.xzw);\t\t// return distance + transformed point\n        }\n        depth += dist;\n        if (depth >= end) {\n            return vec4(end, result.xzw);\t\t// return distance + transformed point\n        }\n    }\n    return vec4(end, result.xzw);\t\t\t\t// return distance + transformed point\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p, vec2 uv) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z), uv).x - sceneSDF(vec3(p.x - EPSILON, p.y, p.z), uv).x,\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z), uv).x - sceneSDF(vec3(p.x, p.y - EPSILON, p.z), uv).x,\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON), uv).x - sceneSDF(vec3(p.x, p.y, p.z - EPSILON), uv).x\n    ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera setup\n    vec3 viewDir = rayDirection(40.0, iResolution.xy, fragCoord);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 eye = vec3(30.0*sin(iTime*0.3), -30.0*cos(iTime*0.3), 5.0);  \n   \tvec3 up = vec3(0.0, 0.0, 1.0);\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, lookAt, up); \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    // raymarch scene\n    vec4 result = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST, MAX_MARCHING_STEPS, uv);\n    float dist = result.x;\n    \n    if (dist > MAX_DIST - EPSILON) {\t\t\t// Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    \n    vec3 p = eye + dist * worldDir;\t// The closest point on the surface to the eyepoint along the view ray\n    vec3 n = estimateNormal(p, uv);\t\t// surface normal\n    \n    vec3 diffuse = texture(iChannel0, abs(0.4*result.yz + 0.005*iTime)).rgb;\t// color from texture based on transformed point\n    \n    // first light\n    vec3 lightPos = vec3(2.0, 3.0, 25.0);\n    vec3 lightRay = vec3(lightPos - p);\n    vec3 lightDir = normalize(lightRay);\n\t\n    vec3 col = vec3(0);\n    col += diffuse*vec3(1.0, 0.9, 0.8)*max(0.1, dot(n, lightDir))/length(lightRay)*36.0;\n    \n    // second light\n    vec3 lightPos2 = vec3(15.0, 15.0, -15.0);\n    vec3 lightRay2 = vec3(lightPos2 - p);\n    vec3 lightDir2 = normalize(lightRay2);\n\n    col += diffuse*vec3(0.4, 0.8, 1.0)*max(0.1, dot(n, lightDir2))/length(lightRay2)*19.0;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}