{
    "Shader": {
        "info": {
            "date": "1695286611",
            "description": "A translucent noisy blob, but maybe the lighting is a bit off and don't know why.",
            "flags": 0,
            "hasliked": 0,
            "id": "cs3czf",
            "likes": 14,
            "name": "Translucent Noisy Blob",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "alphardex",
            "viewed": 505
        },
        "renderpass": [
            {
                "code": "const float PI=3.14159265359;\n\nconst float TWO_PI=6.28318530718;\n\nmat2 rotation2d(float angle){\n    float s=sin(angle);\n    float c=cos(angle);\n    \n    return mat2(\n        c,-s,\n        s,c\n    );\n}\n\nmat4 rotation3d(vec3 axis,float angle){\n    axis=normalize(axis);\n    float s=sin(angle);\n    float c=cos(angle);\n    float oc=1.-c;\n    \n    return mat4(\n        oc*axis.x*axis.x+c,oc*axis.x*axis.y-axis.z*s,oc*axis.z*axis.x+axis.y*s,0.,\n        oc*axis.x*axis.y+axis.z*s,oc*axis.y*axis.y+c,oc*axis.y*axis.z-axis.x*s,0.,\n        oc*axis.z*axis.x-axis.y*s,oc*axis.y*axis.z+axis.x*s,oc*axis.z*axis.z+c,0.,\n        0.,0.,0.,1.\n    );\n}\n\nvec2 rotate(vec2 v,float angle){\n    return rotation2d(angle)*v;\n}\n\nvec3 rotate(vec3 v,vec3 axis,float angle){\n    return(rotation3d(axis,angle)*vec4(v,1.)).xyz;\n}\n\n//\n// GLSL textureless classic 3D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n    return x-floor(x*(1./289.))*289.;\n}\n\nvec4 mod289(vec4 x)\n{\n    return x-floor(x*(1./289.))*289.;\n}\n\nvec4 permute(vec4 x)\n{\n    return mod289(((x*34.)+1.)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159-.85373472095314*r;\n}\n\nvec3 fade(vec3 t){\n    return t*t*t*(t*(t*6.-15.)+10.);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n    vec3 Pi0=floor(P);// Integer part for indexing\n    vec3 Pi1=Pi0+vec3(1.);// Integer part + 1\n    Pi0=mod289(Pi0);\n    Pi1=mod289(Pi1);\n    vec3 Pf0=fract(P);// Fractional part for interpolation\n    vec3 Pf1=Pf0-vec3(1.);// Fractional part - 1.0\n    vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);\n    vec4 iy=vec4(Pi0.yy,Pi1.yy);\n    vec4 iz0=Pi0.zzzz;\n    vec4 iz1=Pi1.zzzz;\n    \n    vec4 ixy=permute(permute(ix)+iy);\n    vec4 ixy0=permute(ixy+iz0);\n    vec4 ixy1=permute(ixy+iz1);\n    \n    vec4 gx0=ixy0*(1./7.);\n    vec4 gy0=fract(floor(gx0)*(1./7.))-.5;\n    gx0=fract(gx0);\n    vec4 gz0=vec4(.5)-abs(gx0)-abs(gy0);\n    vec4 sz0=step(gz0,vec4(0.));\n    gx0-=sz0*(step(0.,gx0)-.5);\n    gy0-=sz0*(step(0.,gy0)-.5);\n    \n    vec4 gx1=ixy1*(1./7.);\n    vec4 gy1=fract(floor(gx1)*(1./7.))-.5;\n    gx1=fract(gx1);\n    vec4 gz1=vec4(.5)-abs(gx1)-abs(gy1);\n    vec4 sz1=step(gz1,vec4(0.));\n    gx1-=sz1*(step(0.,gx1)-.5);\n    gy1-=sz1*(step(0.,gy1)-.5);\n    \n    vec3 g000=vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100=vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010=vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110=vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001=vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101=vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011=vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111=vec3(gx1.w,gy1.w,gz1.w);\n    \n    vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));\n    g000*=norm0.x;\n    g010*=norm0.y;\n    g100*=norm0.z;\n    g110*=norm0.w;\n    vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));\n    g001*=norm1.x;\n    g011*=norm1.y;\n    g101*=norm1.z;\n    g111*=norm1.w;\n    \n    float n000=dot(g000,Pf0);\n    float n100=dot(g100,vec3(Pf1.x,Pf0.yz));\n    float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));\n    float n110=dot(g110,vec3(Pf1.xy,Pf0.z));\n    float n001=dot(g001,vec3(Pf0.xy,Pf1.z));\n    float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));\n    float n011=dot(g011,vec3(Pf0.x,Pf1.yz));\n    float n111=dot(g111,Pf1);\n    \n    vec3 fade_xyz=fade(Pf0);\n    vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);\n    vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);\n    float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);\n    return 2.2*n_xyz;\n}\n\nfloat pow5(const in float v){\n    float v2=v*v;\n    return v2*v2*v;\n}\n\nvec3 schlick(const in vec3 f0,const in float f90,const in float VoH){\n    float f=pow5(1.-VoH);\n    return f+f0*(f90-f);\n}\n\nvec3 fresnel(vec3 f0,vec3 normal,vec3 view){\n    return schlick(f0,1.,dot(view,normal));\n}\n\nfloat sdSphere(vec3 p,float r)\n{\n    return length(p)-r;\n}\n\nfloat opUnion(float d1,float d2)\n{\n    return min(d1,d2);\n}\n\nvec2 opUnion(vec2 d1,vec2 d2)\n{\n    return(d1.x<d2.x)?d1:d2;\n}\n\nvec3 distort(vec3 p){\n    float frequency=1.7;\n    float offset=cnoise(p/frequency+iTime*.5);\n    float t=(p.y+offset)*PI*12.;\n    float noise=(sin(t)*p.x+cos(t)*p.z)*2.;\n    p+=noise*.01;\n    return p;\n}\n\nvec2 map(vec3 p){\n    p-=vec3(0.,0.,-2.);\n    \n    // orbit\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    p.yz=rotate(p.yz,-mouse.y*PI+1.);\n    p.xz=rotate(p.xz,-mouse.x*TWO_PI);\n    \n    p=distort(p);\n    \n    vec2 d=vec2(1e10,0.);\n    float d1=sdSphere(p,1.5);\n    d=opUnion(d,vec2(d1,2.));\n    return d*.5;\n}\n\nvec3 calcNormal(in vec3 p)\n{\n    const float h=.0001;\n    const vec2 k=vec2(1,-1);\n    return normalize(k.xyy*map(p+k.xyy*h).x+\n    k.yyx*map(p+k.yyx*h).x+\n    k.yxy*map(p+k.yxy*h).x+\n    k.xxx*map(p+k.xxx*h).x);\n}\n\nvec3 render(vec2 uv){\n    vec3 col=vec3(0.);\n    \n    uv=(uv-.5)*2.;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 ro=vec3(0.,0.,1.);\n    vec3 rd=normalize(vec3(uv,0.)-ro);\n    \n    float depth=0.;\n    for(int i=0;i<64;i++){\n        vec3 p=ro+rd*depth;\n        vec2 t=map(p);\n        float d=t.x;\n        float m=t.y;\n        depth+=d;\n        \n        if(d<.01){\n            // col=vec3(1.);\n            vec3 normal=calcNormal(p);\n            // col=normal;\n            \n            // fresnel\n            vec3 viewDir=normalize(ro-p);\n            col=fresnel(vec3(0.),normal,viewDir);\n            \n            break;\n        }\n    }\n    \n    return col;\n}\n\nvec3 getSceneColor(vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n    vec3 col=render(uv);\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec3 tot=vec3(0.);\n    \n    float AA_size=2.;\n    float count=0.;\n    for(float aaY=0.;aaY<AA_size;aaY++)\n    {\n        for(float aaX=0.;aaX<AA_size;aaX++)\n        {\n            tot+=getSceneColor(fragCoord+vec2(aaX,aaY)/AA_size);\n            count+=1.;\n        }\n    }\n    tot/=count;\n    \n    fragColor=vec4(tot,1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}