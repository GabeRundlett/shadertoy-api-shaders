{
    "Shader": {
        "info": {
            "date": "1666467923",
            "description": "My submission for the JFIG 2022 Shadertoy contest.\nScene reference: https://passion-aquitaine.ouest-france.fr/wp-content/uploads/2019/10/Canel%C3%A9s-de-Bordeaux.jpg",
            "flags": 32,
            "hasliked": 0,
            "id": "sldyRH",
            "likes": 9,
            "name": "[ConcoursJFIG2022] Cannelés",
            "published": 3,
            "tags": [
                "jfig2022"
            ],
            "usePreview": 1,
            "username": "PlathC",
            "viewed": 404
        },
        "renderpass": [
            {
                "code": "// From Bokeh Venice \n// by Dave_Hoskins\n// Reference: https://www.shadertoy.com/view/ldG3W3\nvec3 Bokeh(vec4 base, sampler2D tex, vec2 uv, float radius, float zed)\n{\n// The Golden Angle is (3.-sqrt(5.0))*PI radians.\n#define GOLDEN_ANGLE 2.39996323\n#define ITERATIONS 30\n\n    mat2 rot = mat2(cos(GOLDEN_ANGLE), sin(GOLDEN_ANGLE), -sin(GOLDEN_ANGLE), cos(GOLDEN_ANGLE));\n\n    radius*= .6;\n\tvec3 acc = vec3(0.0), div = acc;\n    vec2 pixel = vec2(.002 *iResolution.y / iResolution.x, .002);\n    float r = 1.0;\n    vec2 vangle = vec2(0.0,radius); // Start angle\n\tfor (int j = 0; j < ITERATIONS; j++)\n    {  \n        r += 1. / r;\n\t    vangle *= rot;\n        vec4 col = texture(tex, uv + pixel * (r-1.) * vangle);\n        \n        \n        float dim = smoothstep(200.0, -1., zed-col.w);\n\t\tvec3 bokeh = (pow(col.xyz, vec3(9.0)) * 20.+1.) * dim;//..Varies depending on intensity needed..\n\t\tacc += col.xyz * bokeh;\n\t\tdiv += bokeh;\n\t}\n\treturn vec3(clamp(acc / div, 0., 1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec4 v = texture(iChannel0, uv);\n    float z = min(max(v.w - 4.2, 0.01), 5.);\n\tfragColor = vec4(Bokeh(v, iChannel0, uv, z, z).rgb, 1.);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float Pi = 3.14159;\nconst float OneOutOfPi = 1. / Pi;\nconst float MaxFloat = uintBitsToFloat(0x7F800000u);\n\nconst vec3 SunPos = vec3(-1., 0.75, -.75) * 20.;\n\nconst float CanneleId = 1.;\nconst float CanneleTwoId = 2.;\nconst float ThinBranchesId = 3.;\nconst float LargeLeavesId = 4.;\nconst float BushId = 5.;\nconst float SpoonId = 6.;\nconst float PlateId = 7.;\nconst float PlaneId = 8.;\n\nstruct Material\n{\n    vec3 color;\n    float roughness;\n    float metalness;\n    float cc;\n    float ccRougness;\n    bool sss;\n};\n\nfloat dot2(vec3 v) {return dot(v,v);} \nfloat dot2(vec2 v) {return dot(v,v);} \n\nvec3 orthogonal(vec3 normal) \n{\n\tvec3 ref = vec3(1., 0., 0.);\n\tif (abs(dot(normal, ref)) > 1e-4)\n\t\tref = vec3(0., 1., 0.);\n    return cross(normal, ref);\n}\n\nvec2 sphericalMapping(vec3 v)\n{\n    return vec2(\n        0.5 + atan(v.x, v.z) / (2. * Pi),\n        0.5 + asin(v.y) / Pi        \n    );\n}\n\nvec2 opU(vec2 a, vec2 b)\n{\n    return a.x > b.x ? b : a;\n}\n\n// Quaternion utilities from GLM source\n// License: MIT\n// Reference: https://github.com/g-truc/glm\nvec4 quat(float angle, vec3 axis) \n{\n\tfloat halfAngle = angle / 2.;\n\treturn vec4(\n\t\taxis.x * sin(halfAngle),\n\t\taxis.y * sin(halfAngle),\n\t\taxis.z * sin(halfAngle),\n\t\tcos(halfAngle)\n\t);\n}\n\n// GLM quat - vector multiplication\n// Reference: https://github.com/g-truc/glm/blob/master/glm/detail/type_quat.inl#L346\nvec3 mul(vec4 quat, vec3 point)\n{\n\tvec3 uv = cross(quat.xyz, point);\n\tvec3 uuv = cross(quat.xyz, uv);\n\treturn point + ((uv * quat.w) + uuv) * 2.;\n}\n\n// Original jFIG 2020 by haqreu, modified for 2022 edition\n// Reference: https://www.shadertoy.com/view/wsXyD8 \n#define JFIGW 32u\n#define JFIGH 12u\nconst uint[] jfigBitfield = uint[]( 0xf97800u, 0x90900u, 0xc91800u, 0x890900u, 0xf90900u, 0x180u, 0x0u, 0x38e30e0u, 0x4104900u, 0x79e49e0u, 0x824820u, 0x79e31e0u);\nbool jfig(in uint x, in uint y) {\n    uint id = x + (JFIGH-1u-y)*JFIGW;\n    if (id>=JFIGW*JFIGH) return false;\n    return 0u != (jfigBitfield[id/32u] & (1u << (id&31u)));\n}\n\n// UDN blending\n// Reference: https://google.github.io/filament/Filament.md.html#lighting/normalmapping/udnblending\nvec3 blendNormal(vec3 n, vec3 d)\n{\n    return normalize(vec3(n.xy + d.xy, n.z));\n}\n\n// SDF primitives and utilities \n// by Inigo Quilez\n// License: MIT\n// Reference: https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n  \n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                          abs(length(q)-r) ) - t;\n}\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    \n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    \n    return sign(d)*sqrt(abs(d))/baba;\n}\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// SDF utils from HG_SDF: A glsl library for building signed distance functions\n// by Korndörfer, Johann and Keinert, Benjamin and Ganse, Urs and Sänger, Michael and Ley, Simon and Burkhardt, Konstanze and Spuler, Mario and Heusipp, Jörn\n// License: MIT\n// Reference: https://mercury.sexy/hg_sdf/\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*Pi/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Hash utility from Quality hashes collection\n// by nimitz 2018 (twitter: @stormoid)\n// License: MIT\n// Modified from: iq's \"Integer Hash - III\" (https://www.shadertoy.com/view/4tXyWN)\n// Reference: https://www.shadertoy.com/view/Xt3cDn\nuint baseHash(uvec3 p)\n{\n    p = 1103515245U*((p.xyz >> 1U)^(p.yzx));\n    uint h32 = 1103515245U*((p.x^p.z)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\nuint baseHash(uint p)\n{\n    p = 1103515245U*((p >> 1U)^(p));\n    uint h32 = 1103515245U*((p)^(p>>3U));\n    return h32^(h32 >> 16);\n}\nfloat hash13(uvec3 x)\n{\n    uint n = baseHash(x);\n    return float(n)*(1.0/float(0xffffffffU));\n}\nvec3 hash33(uvec3 x)\n{\n    uint n = baseHash(x);\n    uvec3 rz = uvec3(n, n*16807U, n*48271U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec3((rz >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash31(uint x)\n{\n    uint n = baseHash(x);\n    uvec3 rz = uvec3(n, n*16807U, n*48271U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec3((rz >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n// BRDF utils\n// Main references : \n//    - Crash Course in BRDF Implementation, Jakub Boksansky\n//      Reference: https://github.com/boksajak/brdf/blob/master/brdf.h\n//    - Physically Based Rendering in Filament, Romain Guy and Mathias Agopian\n//      Reference: https://google.github.io/filament/Filament.md.html\nvec3 schlickFresnel(float cosTheta, vec3 f0)\n{\n    return f0 + (vec3(1.) - f0) * pow(1. - cosTheta, 5.);\n}\n\n// Height correlated version - optimized by substituing G_Lambda for G_Lambda_GGX and dividing by (4 * NdotL * NdotV) to cancel out \n// the terms in specular BRDF denominator\n// Source: \"Moving Frostbite to Physically Based Rendering\" by Lagarde & de Rousiers\n// Note that returned value is G2 / (4 * NdotL * NdotV) and therefore includes division by specular BRDF denominator\nfloat smithG2(float alpha2, float nl, float nv) {\n\tfloat a = nv * sqrt(alpha2 + nl * (nl - alpha2 * nl));\n\tfloat b = nl * sqrt(alpha2 + nv * (nv - alpha2 * nv));\n\treturn 0.5f / (a + b);\n}\n\nfloat ggxD(float alpha2, float nh) {\n\tfloat b = ((alpha2 - 1.) * nh * nh + 1.);\n\treturn alpha2 / (Pi * b * b);\n}\n\n// A Microfacet Based Coupled Specular-Matte BRDF Model with Importance Sampling, Csaba Kelemen\nfloat kelemenV(float cosTheta) {\n    return 0.25 / (cosTheta * cosTheta);\n}\n\n// Noise utilities\n// by Inigo Quilez\n// License: MIT\n// Reference: https://www.shadertoy.com/view/XsXfRH\nfloat shash(vec3 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\n    return -1.0+2.0*fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// return value noise (in x) and its derivatives (in yzw)\nvec4 noised( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n    \n#if 1\n    // quintic interpolation\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n#endif    \n    \n    \n    float a = shash(i+vec3(0.0,0.0,0.0));\n    float b = shash(i+vec3(1.0,0.0,0.0));\n    float c = shash(i+vec3(0.0,1.0,0.0));\n    float d = shash(i+vec3(1.0,1.0,0.0));\n    float e = shash(i+vec3(0.0,0.0,1.0));\n\tfloat f = shash(i+vec3(1.0,0.0,1.0));\n    float g = shash(i+vec3(0.0,1.0,1.0));\n    float h = shash(i+vec3(1.0,1.0,1.0));\n\t\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\n// Ref: https://www.shadertoy.com/view/llXyWr\nvec3 Tonemap_ACES(vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec2 sdCannele(vec3 p)\n{\n    // Body\n    float d = sdCappedCone(p - vec3(0., 0.35, 0.), 0.4, 0.4, 0.35) - 0.09;\n    \n    // Top cap cavity\n    d = opSmoothSubtraction( length(p - vec3(0., 0.85, 0.)) - 0.15, d, 0.1 );\n\n    // Contours\n    vec3 q = p;\n    pModPolar(q.xz, 12.);\n    vec3 a = vec3(0.35, 0.8, 0.);\n    vec3 b = a - vec3(-0.13, 0.8, 0.);\n    d = opSmoothUnion(sdCapsule(q, a, b, 0.08), d, 0.1);\n    \n    // Stars texture as displacement taken from Hamneggs's shader \n    // Reference: https://www.shadertoy.com/view/ls2GDw\n    vec2 uv = sphericalMapping(p);\n    d += float(length(p.xz) > 0.15) * .008 * texture(iChannel0, uv).r;\n\n    return vec2(d, CanneleId); \n}\n\nfloat sdThinBranch(vec3 p, vec3 start, vec3 end)\n{\n    const float width = 0.005;\n    float t = sdCapsule( p, start, end, width );\n    vec3  d = end - start;\n    float l = length(d);\n    d /= l;\n    \n    vec3 v = normalize(orthogonal(d) + d);\n    \n    // Random density from p\n    float s = 1. - hash13(floatBitsToUint(start + floor(p + fract(p) * 100.) + end));\n    v = mod(floor(s * 10.), 2.) == 1. ? v : reflect(-v, d);\n\n    vec3 send = start + d * s * l + v * l * smoothstep(1.5, -2.5, s) * .5;\n    t = min(t, length(send - p) - 0.1);\n    \n    return t;\n}\n\nvec2 sdThinBranches(vec3 p)\n{\n    float d =  sdThinBranch(p, vec3(1.95, -0.1, 1.95), vec3(-.4,  -0., 1.3));\n    d = min(d, sdThinBranch(p, vec3(2.05, -0.1, 1.95), vec3(-.2,   0., 1.1)));\n    d = min(d, sdThinBranch(p, vec3(2.05,  0.,  1.95), vec3(-.6,   0., 0.9)));\n    return vec2(d, ThinBranchesId);\n}\n\nvec2 sdLargerBranches(vec3 p)\n{\n    float d = sdThinBranch( p, vec3(2.7, 0., 1.05), vec3(1.,  0.01,  -0.6));\n    d = min(d, sdThinBranch( p, vec3(2.1, 0., 0.9), vec3(.8,  0.05,  -0.7) ));\n    return vec2(d, ThinBranchesId);\n}\n\nvec2 sdLargeLeaves(vec3 p)\n{\n    vec3 c = vec3(2.5, .3, 1.45);\n    vec3 r = vec3(1.5, .9, 2.2);\n    \n    // Bounding shape \n    float d = sdEllipsoid(p - c, r);\n    if(d < 0.01)\n    {\n        // Random density from p\n        vec3 s = hash33(uvec3(floor(p + fract(p) * 25.))) * 2. - 1.;\n        vec3 pp = c + s * r;\n        d = length(pp - p) - 1.4;\n    }\n        \n    return vec2(d, LargeLeavesId);\n}\n\nvec2 sdBush(vec3 p)\n{ \n    vec3 c = vec3(2.3,  0.,  -1.35);\n    vec3 r = vec3(0.95, 1.5, 2.);\n    \n    // Bounding shape \n    float d = sdEllipsoid(p - c, r);\n    if(d < 0.01)\n    {\n        // Random density from p\n        vec3 s = hash33(floatBitsToUint(floor(p + fract(p) * 25.))) * 2. - 1.;\n        vec3 pp = c + s * r;\n        d = length(pp - p) - 1.3;\n    }\n    \n    return vec2(d, BushId);\n}\n\nvec2 sdSpoon(vec3 p)\n{\n    vec3 spoonCup = vec3(0., 0.3, -1.14);\n    float d = sdCutHollowSphere(p - spoonCup, 0.35, -0.2, 0.008);\n    \n    vec3 spoonStart = vec3(0.2, 0.1, -0.94);\n    vec3 spoonDir = (spoonStart - spoonCup) * vec3(1., .25, 1.);\n    return vec2(min(d, sdCapsule(p, spoonStart- vec3(0., .05, 0.), spoonStart + spoonDir * 4., 0.025)), SpoonId);\n}\n\nvec2 sdPlate(vec3 p)\n{\n    vec3 plateCenter = vec3(0.1, -0.25, 0.);\n    vec3 q = p;\n    float d = sdCylinder(q, plateCenter, plateCenter + vec3(0., 1., 0.) * .15, 1.3);\n    return vec2(d, PlateId);\n}\n\nfloat sdJfig(vec3 p)\n{\n    const float side = .08;\n    const float radius = 2.;\n\n    float d = sdBox(p, vec3(side, float(JFIGH) * side, float(JFIGW) * side * .5));\n    if(d < 0.1)\n    {\n        vec2 gridCoordinates = floor((p.yz / side)) + vec2(0., float(JFIGW) * .5);\n\n        // Test neighborhood of the point. Since we already know\n        // it's in the bounding shape, we can assert a minimum\n        // distance to the bitfield\n        d = side * radius;\n        \n        for(float i = -radius; i <= radius; i++)\n        {\n            for(float j = -radius; j <= radius; j++)\n            {\n                float x = i + gridCoordinates.y;\n                float y = j + gridCoordinates.x;\n\n                if(!jfig(uint(x), uint(y))) continue;\n                \n                float db = sdBox(p - vec3(0., y, x - float(JFIGW) * .5) * side, vec3(side) * .5);\n                \n                // Makes the letters more cake alike\n                db -= .04;\n                \n                d = min(d, db);\n            }\n        }\n    }\n    \n    return d;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 d = opU(sdCannele(p), vec2(sdCannele(p + vec3(-0.6, 0., -0.8)).x, CanneleTwoId));\n    \n    // Morphing animation \n    float t = smoothstep(.6, .8, clamp((sin(iTime * .5) + 1.) * .5, 0., 1.));\n    \n    // Align canneles and logo\n    vec3 q = p - vec3(.2, .0, .2);\n    pR(q.xz, -Pi * .08);\n\n    // The morphing between JFIG logo and both canneles\n    // This idea comes from the \"Morphing\" shader by iapafoto \n    // Reference: https://www.shadertoy.com/view/MslSDN\n    d.x = mix(d.x, sdJfig(q), t);\n\n    // Static parts of the scene\n    d = opU(d, sdSpoon(p));\n    d = opU(d, sdPlate(p));\n    d = opU(d, vec2(sdPlane(p + vec3(0., 0.35, 0.), vec3(0., 1., 0.), 0. ), PlaneId));\n    \n    d = opU(d, sdThinBranches(p));\n    \n    q = p - vec3(.2, 0., -.4);\n    pR(q.xz, Pi * .05);\n    d = opU(d, sdLargeLeaves(q));\n    d = opU(d, sdLargerBranches(p));\n    \n    q = p - vec3(.2, 0., .2);\n    pR(q.xz, -Pi * .2);\n    d = opU(d, sdBush(q));\n    \n    return d;\n}\n\n// Map normal estimation\n// by Inigo Quilez\n// Reference: https://iquilezles.org/articles/normalsSDF\nvec3 norm(vec3 pos)\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ).x );\n}\n\n// Softshadow approximation \n// by Inigo Quilez and Sebastian Aaltonen\n// Reference: https://iquilezles.org/articles/rmshadows/\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<1e-3 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += max(abs(h), 1e-4);\n    }\n    return res;\n}\n\n// Fast Approximations for lighting of Fast Approximations for lighting of Dynamic Scene, - Page 44, \n// By Alex Evans\n// Reference: http://amd-dev.wpengine.netdna-cdn.com/wordpress/media/2012/10/Evans-Fast_Approximations_for_Lighting_of_Dynamic_Scenes-print.pdf\n// The Cornell Box, by h3r3\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Reference: https://www.shadertoy.com/view/4ssGzS\nfloat ao(in vec3 ro, in vec3 n)\n{\n    float a = 0.;\n    const float stepCount = 2.;\n    for(float i = 0.; i < stepCount; i++)\n    {\n        float d = shash(ro + fract(ro) * i) * .5 + 1.;\n        a += max(0., (d - map(ro + n * d).x) / d);\n    }\n    return clamp(1. - a / stepCount, 0., 1.);\n}\n\n// GDC 2011 – Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look\n// by Colin Barré-Brisebois\n// Reference: https://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/\n// Other references: \n//     - Everyday004 - MysteryPyramid by Makio64: https://www.shadertoy.com/view/Mdt3zs\n//     - LocalThickness by ZigguratVertigo      : https://www.shadertoy.com/view/ldGGzR\nfloat thickness(in vec3 ro, in vec3 n)\n{\n    float a = 0.;\n    const float stepCount = 1.;\n    for(float i = 0.; i < stepCount; i++)\n    {\n        float d = (shash(ro + fract(ro) * i) * .5 + 1.) * .5;\n        a += max(0., (d + map(ro - n * d).x) / d);\n    }\n    return clamp(1. - a / stepCount, 0., 1.);\n}\nvec3 sss(vec3 p, vec3 n, Material material)\n{\n    float localThickness = thickness(p, n);\n    return material.color * localThickness;\n}\n\nMaterial getMaterial(float id, vec3 p, inout vec3 n)\n{\n    if(id == CanneleId || id == CanneleTwoId)\n    {\n        if(id == CanneleTwoId)\n            p += vec3(-0.6, 0., -0.8);\n    \n        vec2 uv = sphericalMapping(normalize(p));\n        \n        float rnd = noised( p * 5.).x;\n\n        // Strips\n        float stripVariations = rnd;\n        float a = mod(acos(dot(normalize(p.xz), vec2(1., 0.))), Pi / 6.);\n        \n        float strip = smoothstep(\n            0., 2., \n            (abs(a * 10. - 2.5) * .4 // The actual strip\n            + smoothstep(0., 1., abs(p.y - .55) * 1.2)) // Emphasize middle part of the cake\n            * abs(shash(vec3(floor(uv), floor(uv.x) * floor(uv.y)))) // Variations\n        );\n\n        // Center hole\n        float center = clamp(mix(1., 0., length(p.xz) * 3.), 0., 1.);\n        \n        strip += smoothstep(-.3, .7, center);\n        strip = clamp(strip*strip, 0., 1.);\n        vec3 color = mix(vec3(0.098,0.024,0.004), vec3(0.396,0.102,0.004), vec3(strip));\n        \n        // Highlight center hole\n        vec3 lighter = vec3(0.341,0.157,0.000);\n        color = mix(color, lighter, smoothstep(.6, .8, center) );\n        \n        // Increase small scale details \n        n = blendNormal(n, .1 * noised( p * 200. ).yzw);\n        \n        return Material(color, .1 + 0.2 * strip, 0., 1., 0.1, true);\n    }\n    else if(id == ThinBranchesId)\n    {\n        return Material(vec3(0.447,0.216,0.216), 1., 0., 0., 0., false);\n    }\n    else if(id == LargeLeavesId)\n    {\n        return Material(vec3(0.867,0.235,0.455), 1., 0., 0., 0., false);\n    }\n    else if(id == BushId)\n    {\n        return Material(vec3(0.000,0.600,0.169),1., 0., 0., 0., false);\n    }\n    else if(id == SpoonId)\n    {\n        // Add small scale details with the rusty texture\n        vec2 uv = sphericalMapping(n);\n        vec3 rust = texture(iChannel3, uv).rgb;\n        vec3 color = mix(vec3(0.910,0.592,0.231), rust, .55);\n        \n        return Material(color, 0.5, 1., 0., 0., false);\n    }\n    else if(id == PlateId)\n    {\n        const vec3 side = vec3(1.000,0.945,0.898);\n        const vec3 inside = vec3(0.957,0.761,0.604);\n\n        // Inner pattern as a circular sine\n        float d = length(p.xz);\n        vec3 insidePattern = mix(inside, inside - .4, vec3(abs(sin(d * 20.)) / 19.));\n        \n        // intensity variations\n        insidePattern += .08 * shash(p * 15.) * sin(length(p.xz) * 100.); \n\n        vec3 color = mix(insidePattern, side, vec3(d > 1.1));\n        return Material(color, 1., 0., 0., 0., false);\n    }\n    \n    return Material(vec3(1. - .3*noised( p * vec3(150., 1., 15.)).x), .1, 0., 0., 0., false);\n}\n\nvec3 shade(vec3 p, vec3 v, vec3 n, vec3 l, Material material)\n{\n    vec3 h = normalize(v + l);\n\n    float alpha = max(material.roughness * material.roughness, 1e-2);\n    float alpha2 = alpha * alpha;\n\n    float lh = clamp(dot(l, h), 0.,   1.);\n    float nh = clamp(dot(n, h), 0.,   1.);\n    float nl = clamp(dot(n, l), 1e-2, 1.);\n    float nv = abs(dot(n, v));\n    \n    vec3 diffuseColor = material.color * (1. - material.metalness);\n    vec3 f0 = mix(vec3(0.04), material.color, material.metalness);\n    vec3 f = schlickFresnel(lh, f0);\n    \n    vec3 diffuse = diffuseColor * OneOutOfPi * nl;\n    \n    float g = smithG2(alpha2, nl, nv);\n    float d = ggxD(alpha2, nh);\n    vec3 specular = g * d * nl * f;\n\n    material.ccRougness = clamp(material.ccRougness, 0.089, 1.0);\n    float ccAlpha = material.ccRougness * material.ccRougness;\n\n    // Clearcoat as achieved in Filament\n    // Reference: https://google.github.io/filament/Filament.md.html#materialsystem/clearcoatmodel/clearcoatspecularbrdf\n    float dc = ggxD(ccAlpha, nh);\n    float vc = kelemenV(lh);\n    vec3 fc = f * material.cc;\n    vec3 frc = dc * vc * fc;\n\n    vec3 obj = (diffuse + specular * (1.0 - fc)) * (1.0 - fc) + frc;\n\n    // Roughness reflection inspired by \n    // [ConcoursJFIG2021] IBL by xavierchermain\n    // Reference: https://www.shadertoy.com/view/ftt3RH\n    // and\n    // Physically based rendering by TDM\n    // Reference: https://www.shadertoy.com/view/XsfXWX\n    vec3 r = reflect(-v, n);\n    vec3 specularReflection = texture(iChannel1, r, material.roughness * 6.).rgb;\n    obj = mix(obj, f * specularReflection, 0.05 + 0.1 * material.metalness);\n    \n    return obj;\n}\n\nvec3 tonemap(vec3 v)\n{\n    return pow(Tonemap_ACES(v.rgb), 1. / vec3(2.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord+.5-iResolution.xy*0.5)/iResolution.y;\n    uv.y = -uv.y;\n    \n    vec3 ro      = vec3(iMouse.z > 1e-4f ? iMouse.y * 1e-2 : -3.8, (iMouse.z > 1e-4f ? 0. : cos(iTime) * .5) +  2.85, 0.);\n    vec3 forward = normalize(vec3(0., 0.5, 0.) - ro);\n    vec3 right   = normalize(cross(forward, vec3(0., 1., 0.)));\n    vec3 up      = normalize(cross(forward, right));\n    vec3 rd      = mat3( right, up, forward ) * normalize(vec3(uv, tan(Pi * .75 / 2.)));\n    \n    float xStep = iMouse.z > 1e-4f ? (iMouse.x / iResolution.x) * 2. * Pi : sin(iTime) * Pi * .08;\n    vec4 q = quat(xStep, vec3(0., 1., 0.)); ro = mul(q, ro), rd = mul(q, rd);\n\n    float t = 0.;\n    vec3 p;\n    vec2 hitInfo = vec2(MaxFloat);\n    bool hit = false;\n    \n    const float tMax = 7.5;\n    for(int i = 0; !hit && i < 75 && t < tMax; i++)\n    {\n        hitInfo = map(p = ro + rd * t);\n        t += max(abs(hitInfo.x), 1e-3);\n        hit = hitInfo.x <= 5e-3; \n    }\n    \n    fragColor.rgb = texture(iChannel1, rd).rgb;\n    if(hit)\n    {        \n        vec3 n = norm(p);\n        n = sign(dot(n, -rd)) * n;\n        \n        vec3 lSun = normalize(SunPos - p);\n        vec3 lIndirect = normalize(vec3(-1.5, .5, 1.5) * 20. - p);\n        \n        vec3 v = -rd;\n        \n        Material material = getMaterial(hitInfo.y, p, n);\n        vec3 obj = shade(p, v, n, lSun, material);\n        obj     += shade(p, v, n, lIndirect, material);\n        \n        // Lightning combination as described in Outdoors lighting\n        // by Inigo Quilez\n        // Reference: https://iquilezles.org/articles/outdoorslighting/\n        vec3 occlusion = vec3(max(.4, ao(p, n)));\n        vec3 shadow = pow(vec3(softshadow(p, lSun, 1e-1, .8, 4.)), vec3(1.0, 1.3, 1.6));\n        \n        float nlSun = clamp(dot(n, lSun), 0., 1.);\n        vec3 sun = nlSun * (vec3(1.000,0.969,0.941) * 5. ) * shadow;\n        float nlIndirect = clamp(dot( n, lIndirect ), 0.0, 1.0);\n        vec3 ind = nlIndirect * (vec3(0.859,1.000,0.996) * 3. ) * occlusion;\n\n        vec3 diffuse = material.color * OneOutOfPi * (nlSun + nlIndirect);\n        if(material.sss)\n        {\n            vec3 subsurface = sss(p, n, material);\n            obj += diffuse * subsurface * (sun + ind) * 2.;\n        }\n        \n        fragColor.rgb = obj * (sun  + ind);\n    }\n    \n    fragColor.rgb = clamp(tonemap(fragColor.rgb), 1e-3, 1.);\n    fragColor.w = t;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void load( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    \n    // Contribution from last frame to lower spatial instability\n    fragColor = mix(fragColor, texture(iChannel1, fragCoord / iResolution.xy), float(iFrame > 0 ) * .5);\n}\n\n// Anti-aliasing By Fabrice Neyret\n// === easy adaptive sampling. === https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n//                           more: https://www.shadertoy.com/results?query=easy+adaptive+sampling\nvoid mainImage(out vec4 O, vec2 U) {\n    load(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { load(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n      //O.r++;                        // uncomment to see where the oversampling occurs\n    }\n    O = vec4(O);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}