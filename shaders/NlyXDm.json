{
    "Shader": {
        "info": {
            "date": "1671494673",
            "description": "A basic firework",
            "flags": 0,
            "hasliked": 0,
            "id": "NlyXDm",
            "likes": 8,
            "name": "Firework 2022",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "storyxx",
            "viewed": 298
        },
        "renderpass": [
            {
                "code": "#define ITER 100\n#define MAX_DIST 1000.0\n#define MIN_DIST 0.01\n#define UP vec3(0,1,0)\n#define PI 3.1415926\n#define GOLDEN 2.3999632\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat atan2(in float y, in float x) {\n    bool s = (abs(x) > abs(y));\n    return mix(PI/2.0 - atan(x,y), atan(y,x), s);\n}\n\nfloat grow(float x) {\n    return (cos(exp(-20.0*x)*PI)*0.5 + 0.5) * 100.0;\n}\n\nfloat falloff(float x) {\n    return pow(x, 512.0);\n}\n\nfloat DE(vec3 pos, vec3 dir, float index) {\n    float rVal = rand(index);\n    float block = max(4.0, abs(rVal)*10.0);\n    float subTime = fract(iTime/block);\n    float timeBlock = floor(iTime/block);\n    \n    vec3 offset = vec3((rand(timeBlock)*2.0-1.0) * 300.0, \n                       (rand(timeBlock+1.0)*2.0-1.0) * 100.0 - subTime*subTime*20.0, \n                       (rand(timeBlock+2.0)*2.0-1.0) * 300.0);\n    float boubleRadius = grow(subTime);\n    \n    vec3 newPos = normalize(pos-offset);\n    \n    float theta = atan2(newPos.x, newPos.z);\n    float y = newPos.y;\n    \n    float samples = 200.0+rand(timeBlock)*10.0; // has to be at least 29\n\n    \n    ////\n    vec2 q = vec2(y, theta);\n    \n    vec2 f1 = vec2(1.0-(2.0*8.0)/(samples-1.0), mod(8.0 * GOLDEN, 2.0 * PI));\n    vec2 f2 = vec2(1.0-(2.0*21.0)/(samples-1.0), mod(21.0 * GOLDEN, 2.0 * PI));\n    vec2 f3 = vec2(1.0-(2.0*29.0)/(samples-1.0), mod(29.0 * GOLDEN, 2.0 * PI));\n    \n    vec2 d1 = f2-f1;\n    vec2 d2 = f3-f1;\n    \n    mat2 m = mat2(d1.x, d1.y, d2.x, d2.y);\n    mat2 m_inv = inverse(m);\n    \n    vec2 p1 = floor(q*m_inv)*m;\n    vec2 p2 = q * m_inv;\n    p2.x = floor(p2.x);\n    p2.y = ceil(p2.y);\n    p2 = p2*m;\n    vec2 p3 = q*m_inv;\n    p3.x = ceil(p3.x);\n    p3.y = floor(p3.y);\n    p3 = p3*m;\n    vec2 p4 = ceil(q*m_inv)*m;\n    \n    float l1 = dot(p1-q, p1-q) + 1000.0 * float(abs(p1.x) > 1.0);\n    float l2 = dot(p2-q, p2-q) + 1000.0 * float(abs(p2.x) > 1.0);\n    float l3 = dot(p3-q, p3-q) + 1000.0 * float(abs(p3.x) > 1.0);\n    float l4 = dot(p4-q, p4-q) + 1000.0 * float(abs(p4.x) > 1.0);\n    \n    float minl = min(l1, min(l2, min(l3, l4)));\n    \n    vec2 res = float(minl==l1)*p1 + \n               float(minl==l2)*p2 + \n               float(minl==l3)*p3 + \n               float(minl==l4)*p4;\n    ////\n    \n    float resultY = res.x;\n    float resultTheta = res.y;\n    \n    \n    float radius = sqrt(1.0 - resultY*resultY);\n    \n    newPos.x = sin(resultTheta)*radius;\n    newPos.y = resultY;\n    newPos.z = cos(resultTheta)*radius;\n    \n    newPos *= boubleRadius + rand(res) * 10.0;\n    \n    return max(0.0, min(length(newPos+offset-pos)-1.0, length(pos-offset)));\n}\n\nvec3 march(vec3 pos, vec3 dir, vec3 clr, float index) {\n    float rVal = rand(index);\n    float block = max(4.0, abs(rVal)*10.0);\n    float subTime = fract(iTime/block);\n    float timeBlock = floor(iTime/block);\n\n    float totalDist;\n    float minDist = MAX_DIST;\n    \n    float maxDist = 0.0;\n    vec3 result = clr;\n    \n    for(int i=0; i<ITER; i++) {\n        float dist = DE(pos, dir, index);\n        totalDist += dist;\n        minDist = min(minDist, dist);\n        maxDist = max(maxDist, dist);\n        if(dist < MIN_DIST) {\n            //return vec3(float(i)/float(10.0));\n            result = clr;\n            break;\n        } else if(totalDist > MAX_DIST) {\n            result = clr * falloff(1.0-minDist/MAX_DIST);\n            break;\n        }\n        pos += dir*dist;\n    }\n    result = clr * falloff(1.0-minDist/MAX_DIST);\n    \n    return mix(result, vec3(0), subTime);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 centered = fragCoord-iResolution.xy/2.0;\n    \n    vec3 eye = vec3(sin(iTime*0.1)*510.0,0.0,cos(iTime*0.1)*510.0);\n    vec3 center = vec3(sin(iTime*0.1)*500.0,0.0,cos(iTime*0.1)*500.0);\n    \n    vec3 dir = normalize(center-eye);\n    \n    vec3 right = cross(dir, UP);\n    \n    vec3 color = march(right*centered.x + UP*centered.y + eye, dir, vec3(1,0.9,0.4), 1.0);\n    color += march(right*centered.x + UP*centered.y + eye, dir, vec3(1,0.2,0), 2.0);\n    color += march(right*centered.x + UP*centered.y + eye, dir, vec3(0.2,1.0,0.0), 3.0);\n    color += march(right*centered.x + UP*centered.y + eye, dir, vec3(0.2,0.3,1.0), 4.0);\n    color += march(right*centered.x + UP*centered.y + eye, dir, vec3(1,0.9,0.4), 5.0);\n    color += march(right*centered.x + UP*centered.y + eye, dir, vec3(1,0.2,0), 6.0);\n    color += march(right*centered.x + UP*centered.y + eye, dir, vec3(0.2,1.0,0.0), 7.0);\n    color += march(right*centered.x + UP*centered.y + eye, dir, vec3(1,0.2,0), 8.0);\n    color += march(right*centered.x + UP*centered.y + eye, dir, vec3(0.2,1.0,0.0), 9.0);\n    color += march(right*centered.x + UP*centered.y + eye, dir, vec3(0.2,0.3,1.0), 10.0);\n    color += march(right*centered.x + UP*centered.y + eye, dir, vec3(1,0.9,0.4), 11.0);\n    color += march(right*centered.x + UP*centered.y + eye, dir, vec3(1,0.2,0), 12.0);\n    color += march(right*centered.x + UP*centered.y + eye, dir, vec3(0.2,1.0,0.0), 13.0);\n    \n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}