{
    "Shader": {
        "info": {
            "date": "1618242327",
            "description": "Physical flag, virtual clock",
            "flags": 32,
            "hasliked": 0,
            "id": "NsfSR8",
            "likes": 13,
            "name": "Flagtime",
            "published": 3,
            "tags": [
                "clock",
                "flag",
                "physics",
                "wind",
                "cloth"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 410
        },
        "renderpass": [
            {
                "code": "// \"Flagtime\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Physical flag, virtual clock (bits from \"Stonewashed Flag\", \"Tempus Fugit\", etc.)\n\n  Flag is a smooth flexible sheet interpolating across a square mesh of small \n  spheres that interact through springs and other forces (bending, excluded\n  volume, wind pressure, gravity, damping). Wind speed and direction vary \n  randomly with time. The equations of motion of the spheres are solved\n  numerically.\n  \n  Rendering the sheet requires finding the closest intersection of a ray (if it \n  enters a bounding box) with the set of (nonplanar) quads based on the sphere \n  coordinates; this done by (emulated) recursive interpolation of the texture \n  containing the coordinates (down to visual accuracy, and backtracking when a hit \n  occurs or when intersection is impossible). Quad edges are removed by \n  (effectively) smoothing the surface normals.\n*/\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec4 Loadv4 (vec2 vId);\n\n#define LBIG   0  // (= 0/1) common to all shaders\n\n#if LBIG\nconst int nBallE = 65;\n#else\nconst int nBallE = 33;\n#endif\n\nconst int nsMax = 3000;\n\nvec3 sunDir;\nvec2 qgHit;\nfloat dstFar, tCur, todCur, spLen, szFac;\nconst float pi = 3.14159;\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nfloat SheetRay (vec3 ro, vec3 rd)\n{\n  vec3 r, q;\n  vec2 g;\n  float d, dMin, sz, szMax, szMin, grLen;\n  bvec2 ilt;\n  bool bkTrak;\n  grLen = 0.92 * spLen;\n  dMin = dstFar / (grLen * szFac);\n  ro /= szFac;\n  rd /= grLen;\n  szMax = float (nBallE - 1);\n  szMin = 1./32.;\n  sz = szMax;\n  g = vec2 (0.);\n  bkTrak = false;\n  for (int ns = VAR_ZERO; ns < nsMax; ns ++) {\n    if (sz == szMin) {\n      r = GetR (g) - ro;\n      q = cross (r, rd);\n      if (dot (q, q) < sz * sz) {\n        d = dot (r, rd);\n        if (d < dMin) {\n          dMin = d;\n          qgHit = g;\n        }\n      }\n      bkTrak = true;\n    }\n    q = cross (GetR (g + 0.5 * sz) - ro, rd);\n    bkTrak = bkTrak || (dot (q, q) > sz * sz);\n    if (bkTrak) {\n      bkTrak = false;\n      ilt = lessThan (fract (g / (2. * sz)), vec2 (0.5));\n      g.x += ilt.x ? sz : - sz;\n      if (! ilt.x) {\n        g.y += ilt.y ? sz : - sz;\n        if (! ilt.y) {\n          sz *= 2.;\n          if (sz == szMax) break;\n          bkTrak = true;\n        }\n      }\n    } else if (sz > szMin) sz *= 0.5;\n  }\n  return dMin * grLen * szFac;\n}\n\nvec3 GetRC (vec2 v)\n{\n  return GetR (clamp (v, vec2 (0.), vec2 (nBallE - 1)));\n}\n\nvec3 SheetNf () \n{\n  vec3 c;\n  vec2 e = vec2 (1., 0.);\n  c = GetRC (qgHit);\n  return normalize (cross (GetRC (qgHit + e.yx) - c, GetRC (qgHit + e) - c));\n}\n\nfloat SheetSilHit (vec3 ro, vec3 rd)\n{\n  vec3 blkSize, pMin, pMax, v, tm, tp;\n  float dn, df;\n  pMin = Loadv4 (vec2 (1, nBallE)).xyz;\n  pMax = Loadv4 (vec2 (2, nBallE)).xyz;\n  ro /= szFac;\n  ro -= 0.5 * (pMin + pMax);\n  blkSize = 0.5 * (pMax - pMin) + 0.5;\n  v = ro  / rd;\n  tp = blkSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  return (df > 0. && dn < df) ? szFac * dn : dstFar;\n}\n\nvec4 CylHit (vec3 ro, vec3 rd, float cylRad, float cylLen)\n{\n  vec3 s, vn;\n  float dMin, d, a, b, w, srdy;\n  dMin = dstFar;\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - cylRad * cylRad);\n  if (w > 0.) {\n    srdy = sign (rd.y);\n    if (a > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0.) {\n        d /= a;\n        s = ro + d * rd;\n      } else s.y = cylLen;\n    } else s.y = cylLen;\n    if (abs (s.y) < cylLen) {\n      dMin = d;\n      vn = vec3 (s.xz / cylRad, 0.).xzy;\n    } else if (srdy * ro.y < - cylLen) {\n      d = - (srdy * ro.y + cylLen) / abs (rd.y);\n      if (d > 0.) {\n        s = ro + d * rd;\n        if (length (s.xz) < cylRad) {\n          dMin = d;\n          vn = vec3 (0., 0., - srdy).xzy;\n        }\n      }\n    }\n  }\n  return vec4 (dMin, vn);\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  rd.y = abs (rd.y);\n  ro.xz -= 1.5 * tCur;\n  return mix (vec3 (0.1, 0.2, 0.4), vec3 (0.8), clamp (0.2 + Fbm2 (0.1 *\n     (ro.xz + rd.xz * (100. - ro.y) / max (rd.y, 0.001))) * rd.y, 0., 1.));\n}\n\nvec3 SheetCol (float s)\n{\n  vec3 col;\n  vec2 b, g, c;\n  float rad, a, f, gRot;\n  col = vec3 (0.9, 0.9, 1.);\n  c = vec2 (1., 0.4);\n  rad = 0.5 * float (nBallE - 1);\n  b = 1.1 * (qgHit / rad - 1.);\n  b = vec2 (- b.y, b.x);\n  if (s > 0.) b.y *= -1.;\n  a = atan (b.y, - b.x) / pi;\n  if (abs (mod (6. * (a + 1.) + 0.5, 1.) - 0.5) < 0.03 && abs (length (b) - 0.95) < 0.05 ||\n     abs (6. * a) < 0.03 && abs (length (b) - 0.9) < 0.1) col = c.yyx;\n  col = mix (c.yyx, col, 0.8 + 0.2 * SmoothBump (0.15, 0.85, 0.02, mod (rad * length (b), 1.)));\n  col = mix (col, c.yyx, smoothstep (0.96, 0.97, length (b)));\n  gRot = todCur / (12. * 3600.);\n  g = Rot2D (b, 2. * pi * gRot - pi);\n  g.x -= 0.25;\n  f = length (max (abs (g) - vec2 (0.3, 0.027 * (0.6 - 0.4 * g.x / 0.3)), 0.));\n  col = mix (col, c.xxy * (1. - 0.4 * step (0.01, f)), step (f, 0.02));\n  gRot *= 12.;\n  g = Rot2D (b, 2. * pi * gRot - pi);\n  g.x -= 0.35;\n  f = length (max (abs (g) - vec2 (0.4, 0.013 * (0.6 - 0.4 * g.x / 0.4)), 0.));\n  col = mix (col, c.yxy * (1. - 0.4 * step (0.01, f)), step (f, 0.02));\n  gRot *= 60.;\n  g = Rot2D (b, 2. * pi * (floor (60. * gRot) + smoothstep (0.8, 1., mod (60. * gRot, 1.))) / 60. - pi);\n  g.x -= 0.4;\n  f = length (max (abs (g) - vec2 (0.46, 0.007 * (0.6 - 0.4 * g.x / 0.46)), 0.));\n  col = mix (col, c.xyy * (1. - 0.4 * step (0.01, f)), step (f, 0.02));\n  col = mix (vec3 (0.1, 0.1, 0.2), col, smoothstep (0.007, 0.013, length (b)));\n  col = mix (col, vec3 (1., 0., 0.), step (1.95 * rad, qgHit.y));\n  col = mix (col, vec3 (0., 1., 0.), step (-0.05 * rad, - qgHit.y));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, dc4;\n  vec3 col, vn, q;\n  float dstObj, dstSheet, s, flSize;\n  szFac = 4. / float (nBallE - 1);\n  flSize = szFac * 0.5 * float (nBallE + 1);\n  q = ro;\n  q.y -= - flSize;\n  dc4 = CylHit (q, rd, 0.06, 2. * flSize + 0.2);\n  dstObj = dc4.x;\n  q = ro;\n  q.x -= flSize + ((LBIG == 0) ? 0.06 : 0.12);\n  dstSheet = (SheetSilHit (q, rd) < dstFar) ? SheetRay (q, rd) : dstFar;\n  if (min (dstSheet, dstObj) < dstFar) {\n    if (dstSheet < dstObj) {\n      vn = SheetNf ();\n      s = sign (dot (rd, vn));\n      if (s > 0.) vn = - vn;\n      col4 = vec4 (SheetCol (s), 0.);\n    } else {\n      ro += dstObj * rd;\n      vn = dc4.yzw;\n      col4 = vec4 (0.9, 0.9, 0.95, 0.2);\n      if (ro.y > - flSize - 0.1) col4 *= (0.5 + 0.5 * smoothstep (0.05, 0.1,\n         abs (mod (4. * (ro.y + 0.02) / flSize + 0.5, 1.) - 0.5)));\n    }\n    col = col4.rgb * (0.2 + 0.1 * max (0., vn.y) + 0.2 * max (- dot (vn, sunDir), 0.) +\n       0.8 * max (dot (vn, sunDir), 0.)) + col4.a * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n  } else col = BgCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, stDat;\n  vec3 ro, rd;\n  vec2 canvas, uv;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.3 * pi * mPtr.y;\n  }\n  el = clamp (el, 0.05 * pi, 0.2 * pi);\n  vuMat = StdVuMat (el, az);\n  zmFac = 5.5;\n  ro = vuMat * vec3 (2., -0.5, -20.);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  stDat = Loadv4 (vec2 (0, nBallE));\n  spLen = stDat.x;\n  dstFar = 160.;\n  sunDir = vuMat * normalize (vec3 (-0.5, 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Flagtime\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Fbm1 (float p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\n#define LBIG   0  // (= 0/1) common to all shaders\n\n#if LBIG\nconst int nBallE = 65;\n#else\nconst int nBallE = 33;\n#endif\n\nvec3 pMin, pMax;\nivec2 idNeb[4], idNebD[4];\nfloat tCur, spLen, nStep;\nconst float pi = 3.14159;\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nvec3 GetV (vec2 v)\n{\n  return Loadv4 (vec2 (v.x + float (nBallE), v.y)).xyz;\n}\n\nvec3 SpringForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 dr, f;\n  ivec2 ivn;\n  float spLenD, fSpring, fSpringD, fDamp;\n  fSpring = 200.;\n  fDamp = 1.;\n  f = vec3 (0.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNeb[n];\n    if (ivn.y >= 0 && ivn.y < nBallE && ivn.x >= 0 && ivn.x < nBallE) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpring * (spLen - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  fSpringD = 3. * fSpring;\n  spLenD = spLen * sqrt(2.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNebD[n];\n    if (ivn.y >= 0 && ivn.y < nBallE && ivn.x >= 0 && ivn.x < nBallE) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpringD * (spLenD - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  return f;\n}\n\nvec3 BendForce (ivec2 iv, vec3 r)\n{\n  vec3 dr1, dr2, rt, f;\n  ivec2 ivd, ivp, ivm;\n  float s, c11, c22, c12, cd;\n  bool doInt;\n  f = vec3 (0.);\n  for (int nd = 0; nd < 2; nd ++) {\n    ivd = (nd == 0) ? ivec2 (1, 0) : ivec2 (0, 1);\n    for (int k = 0; k < 3; k ++) {\n      doInt = false;\n      if (nd == 0) {\n        if (k == 0 && iv.x > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.x < nBallE - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.x > 0 && iv.x < nBallE - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      } else {\n        if (k == 0 && iv.y > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.y < nBallE - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.y > 0 && iv.y < nBallE - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      }\n      if (doInt) {\n        if (k == 0) {\n          rt = GetR (vec2 (ivp));\n          dr1 = rt - GetR (vec2 (ivm));\n          dr2 = r - rt;\n          s = -1.;\n        } else if (k == 2) {\n          rt = GetR (vec2 (ivm));\n          dr1 = rt - r;\n          dr2 = GetR (vec2 (ivp)) - rt;\n          s = -1.;\n        } else {\n          dr1 = r - GetR (vec2 (ivm));\n          dr2 = GetR (vec2 (ivp)) - r;\n          s = 1.;\n        }\n        c11 = 1. / dot (dr1, dr1);\n        c12 = dot (dr1, dr2);\n        c22 = 1. / dot (dr2, dr2);\n        cd = sqrt (c11 * c22);\n        s *= cd * (c12 * cd - 1.);\n        if (k <= 1) f += s * (dr1 - c12 * c22 * dr2);\n        if (k >= 1) f += s * (c12 * c11 * dr1 - dr2);\n      }\n    }\n  }\n  return f;\n}\n\nvec3 PairForce (vec3 r)\n{\n  vec3 dr, f;\n  float rSep;\n  int nx, ny;\n  f = vec3 (0.);\n  nx = 0;\n  ny = 0;\n  for (int n = 0; n < nBallE * nBallE; n ++) {\n    dr = r - GetR (vec2 (nx, ny));\n    rSep = length (dr);\n    if (rSep > 0.01 && rSep < 1.) f += (1. / rSep - 1.) * dr;\n    if (++ nx == nBallE) {\n      nx = 0;\n      ++ ny;\n    }  \n  }\n  return f;\n}\n\nvec3 NormForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 f, n;\n  ivec2 e = ivec2 (1, 0);\n  f = vec3 (0.);\n  if (iv.y > 0 && iv.y < nBallE - 1 && iv.x > 0 && iv.x < nBallE - 1) {\n    n = normalize (cross (GetR (vec2 (iv + e.yx)) - GetR (vec2 (iv - e.yx)),\n       GetR (vec2 (iv + e)) - GetR (vec2 (iv - e))));\n    f = - dot (v, n) * n;\n  }\n  return f;\n}\n\nvoid IdNebs ()\n{\n  idNeb[0] = ivec2 (1, 0);\n  idNeb[1] = - idNeb[0];\n  idNeb[2] = ivec2 (0, 1);\n  idNeb[3] = - idNeb[2];\n  idNebD[0] = ivec2 (1, 1);\n  idNebD[1] = - idNebD[0];\n  idNebD[2] = ivec2 (1, -1);\n  idNebD[3] = - idNebD[2];\n}\n\nvoid Step (ivec2 iv, out vec3 r, out vec3 v)\n{\n  vec3 dr, f, wDir;\n  vec2 s;\n  float fOvlap, fBend, fGrav, fDamp, dt;\n  IdNebs ();\n  fOvlap = 1000.;\n  fBend = 50.;\n  fGrav = 1.;\n  fDamp = 0.5;\n  wDir = vec3 (Rot2D (vec2 (-1., 0.), 0.7 * pi * (2. * Fbm1 (1.5 * tCur) - 1.)), 0.).xzy;\n  r = GetR (vec2 (iv));\n  v = GetV (vec2 (iv));\n  f = fOvlap * PairForce (r) + SpringForce (iv, r, v) + fBend * BendForce (iv, r) +\n     (1. + 10. * Fbm1 (tCur)) * NormForce (iv, r, wDir);\n  f -= fDamp * v;\n  f.y -= fGrav;\n  dt = 0.02;\n  if (iv.x != 0 || mod (float (iv.y), float ((nBallE - 1) / 8)) != 0. && iv.y != nBallE - 2) {\n    v += dt * f;\n    r += dt * v;\n  }\n}\n\nvoid Init (ivec2 iv, out vec3 r, out vec3 v)\n{\n  float fn;\n  for (int iy = 0; iy < nBallE; iy ++) {\n    for (int ix = 0; ix < nBallE; ix ++) {\n      if (iv.x == ix && iv.y == iy) {\n        r = vec3 (ix, iy, 0.);\n        r.xy -= 0.5 * (vec2 (nBallE, nBallE) - 1.);\n        r *= 0.97 * spLen;\n      }\n    }\n  }\n  fn = float (iv.y * nBallE + iv.x);\n  v = 1. * normalize (vec3 (Hashff (fn), Hashff (fn + 0.3), Hashff (fn + 0.6)) - 0.5);\n}\n\nvoid SheetLims ()\n{\n  vec3 p;\n  pMin = vec3 (1e6);\n  pMax = - pMin;\n  for (int iy = 0; iy < nBallE; iy ++) {\n    for (int ix = 0; ix < nBallE; ix ++) {\n      p = GetR (vec2 (ix, iy));\n      pMin = min (pMin, p);\n      pMax = max (pMax, p);\n    }\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 r, v;\n  ivec2 pxIv, iv;\n  int mId, pxId, nb;\n  tCur = iTime;\n  pxIv = ivec2 (fragCoord);\n  pxId = pxIv.x + 2 * nBallE * pxIv.y;\n  nb = nBallE * nBallE;\n  if (pxIv.x >= 2 * nBallE || pxId >= 2 * nb + 3) discard;\n  stDat = Loadv4 (vec2 (2, nBallE));\n  iv = pxIv;\n  if (iv.x >= nBallE) iv.x -= nBallE;\n  mId = iv.y * nBallE + iv.x;\n  if (iFrame <= 5) {\n    spLen = 1.1;\n    nStep = 0.;\n    if (mId < nb) Init (iv, r, v);\n  } else {\n    stDat = Loadv4 (vec2 (0, nBallE));\n    spLen = stDat.x;\n    nStep = stDat.y;\n    stDat = Loadv4 (vec2 (3, nBallE));\n    ++ nStep;\n    if (mId < nb) Step (iv, r, v);\n  }\n  if (pxId == 2 * nb + 1 || pxId == 2 * nb + 2) SheetLims ();\n  if (pxId < 2 * nb) stDat = vec4 (((pxIv.x >= nBallE) ? v : r), 0.);\n  else {\n    if (pxId == 2 * nb + 0) stDat = stDat = vec4 (spLen, nStep, 0., 0.);\n    else if (pxId == 2 * nb + 1) stDat = vec4 (pMin, 0.);\n    else if (pxId == 2 * nb + 2) stDat = vec4 (pMax, 0.);\n  }\n  Savev4 (vec2 (pxIv), stDat, fragColor, fragCoord);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"Flagtime\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Fbm1 (float p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\n#define LBIG   0  // (= 0/1) common to all shaders\n\n#if LBIG\nconst int nBallE = 65;\n#else\nconst int nBallE = 33;\n#endif\n\nvec3 pMin, pMax;\nivec2 idNeb[4], idNebD[4];\nfloat tCur, spLen, nStep;\nconst float pi = 3.14159;\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nvec3 GetV (vec2 v)\n{\n  return Loadv4 (vec2 (v.x + float (nBallE), v.y)).xyz;\n}\n\nvec3 SpringForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 dr, f;\n  ivec2 ivn;\n  float spLenD, fSpring, fSpringD, fDamp;\n  fSpring = 200.;\n  fDamp = 1.;\n  f = vec3 (0.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNeb[n];\n    if (ivn.y >= 0 && ivn.y < nBallE && ivn.x >= 0 && ivn.x < nBallE) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpring * (spLen - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  fSpringD = 3. * fSpring;\n  spLenD = spLen * sqrt(2.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNebD[n];\n    if (ivn.y >= 0 && ivn.y < nBallE && ivn.x >= 0 && ivn.x < nBallE) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpringD * (spLenD - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  return f;\n}\n\nvec3 BendForce (ivec2 iv, vec3 r)\n{\n  vec3 dr1, dr2, rt, f;\n  ivec2 ivd, ivp, ivm;\n  float s, c11, c22, c12, cd;\n  bool doInt;\n  f = vec3 (0.);\n  for (int nd = 0; nd < 2; nd ++) {\n    ivd = (nd == 0) ? ivec2 (1, 0) : ivec2 (0, 1);\n    for (int k = 0; k < 3; k ++) {\n      doInt = false;\n      if (nd == 0) {\n        if (k == 0 && iv.x > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.x < nBallE - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.x > 0 && iv.x < nBallE - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      } else {\n        if (k == 0 && iv.y > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.y < nBallE - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.y > 0 && iv.y < nBallE - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      }\n      if (doInt) {\n        if (k == 0) {\n          rt = GetR (vec2 (ivp));\n          dr1 = rt - GetR (vec2 (ivm));\n          dr2 = r - rt;\n          s = -1.;\n        } else if (k == 2) {\n          rt = GetR (vec2 (ivm));\n          dr1 = rt - r;\n          dr2 = GetR (vec2 (ivp)) - rt;\n          s = -1.;\n        } else {\n          dr1 = r - GetR (vec2 (ivm));\n          dr2 = GetR (vec2 (ivp)) - r;\n          s = 1.;\n        }\n        c11 = 1. / dot (dr1, dr1);\n        c12 = dot (dr1, dr2);\n        c22 = 1. / dot (dr2, dr2);\n        cd = sqrt (c11 * c22);\n        s *= cd * (c12 * cd - 1.);\n        if (k <= 1) f += s * (dr1 - c12 * c22 * dr2);\n        if (k >= 1) f += s * (c12 * c11 * dr1 - dr2);\n      }\n    }\n  }\n  return f;\n}\n\nvec3 PairForce (vec3 r)\n{\n  vec3 dr, f;\n  float rSep;\n  int nx, ny;\n  f = vec3 (0.);\n  nx = 0;\n  ny = 0;\n  for (int n = 0; n < nBallE * nBallE; n ++) {\n    dr = r - GetR (vec2 (nx, ny));\n    rSep = length (dr);\n    if (rSep > 0.01 && rSep < 1.) f += (1. / rSep - 1.) * dr;\n    if (++ nx == nBallE) {\n      nx = 0;\n      ++ ny;\n    }  \n  }\n  return f;\n}\n\nvec3 NormForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 f, n;\n  ivec2 e = ivec2 (1, 0);\n  f = vec3 (0.);\n  if (iv.y > 0 && iv.y < nBallE - 1 && iv.x > 0 && iv.x < nBallE - 1) {\n    n = normalize (cross (GetR (vec2 (iv + e.yx)) - GetR (vec2 (iv - e.yx)),\n       GetR (vec2 (iv + e)) - GetR (vec2 (iv - e))));\n    f = - dot (v, n) * n;\n  }\n  return f;\n}\n\nvoid IdNebs ()\n{\n  idNeb[0] = ivec2 (1, 0);\n  idNeb[1] = - idNeb[0];\n  idNeb[2] = ivec2 (0, 1);\n  idNeb[3] = - idNeb[2];\n  idNebD[0] = ivec2 (1, 1);\n  idNebD[1] = - idNebD[0];\n  idNebD[2] = ivec2 (1, -1);\n  idNebD[3] = - idNebD[2];\n}\n\nvoid Step (ivec2 iv, out vec3 r, out vec3 v)\n{\n  vec3 dr, f, wDir;\n  vec2 s;\n  float fOvlap, fBend, fGrav, fDamp, dt;\n  IdNebs ();\n  fOvlap = 1000.;\n  fBend = 50.;\n  fGrav = 1.;\n  fDamp = 0.5;\n  wDir = vec3 (Rot2D (vec2 (-1., 0.), 0.7 * pi * (2. * Fbm1 (1.5 * tCur) - 1.)), 0.).xzy;\n  r = GetR (vec2 (iv));\n  v = GetV (vec2 (iv));\n  f = fOvlap * PairForce (r) + SpringForce (iv, r, v) + fBend * BendForce (iv, r) +\n     (1. + 10. * Fbm1 (tCur)) * NormForce (iv, r, wDir);\n  f -= fDamp * v;\n  f.y -= fGrav;\n  dt = 0.02;\n  if (iv.x != 0 || mod (float (iv.y), float ((nBallE - 1) / 8)) != 0. && iv.y != nBallE - 2) {\n    v += dt * f;\n    r += dt * v;\n  }\n}\n\nvoid Init (ivec2 iv, out vec3 r, out vec3 v)\n{\n  float fn;\n  for (int iy = 0; iy < nBallE; iy ++) {\n    for (int ix = 0; ix < nBallE; ix ++) {\n      if (iv.x == ix && iv.y == iy) {\n        r = vec3 (ix, iy, 0.);\n        r.xy -= 0.5 * (vec2 (nBallE, nBallE) - 1.);\n        r *= 0.97 * spLen;\n      }\n    }\n  }\n  fn = float (iv.y * nBallE + iv.x);\n  v = 1. * normalize (vec3 (Hashff (fn), Hashff (fn + 0.3), Hashff (fn + 0.6)) - 0.5);\n}\n\nvoid SheetLims ()\n{\n  vec3 p;\n  pMin = vec3 (1e6);\n  pMax = - pMin;\n  for (int iy = 0; iy < nBallE; iy ++) {\n    for (int ix = 0; ix < nBallE; ix ++) {\n      p = GetR (vec2 (ix, iy));\n      pMin = min (pMin, p);\n      pMax = max (pMax, p);\n    }\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 r, v;\n  ivec2 pxIv, iv;\n  int mId, pxId, nb;\n  tCur = iTime;\n  pxIv = ivec2 (fragCoord);\n  pxId = pxIv.x + 2 * nBallE * pxIv.y;\n  nb = nBallE * nBallE;\n  if (pxIv.x >= 2 * nBallE || pxId >= 2 * nb + 3) discard;\n  stDat = Loadv4 (vec2 (2, nBallE));\n  iv = pxIv;\n  if (iv.x >= nBallE) iv.x -= nBallE;\n  mId = iv.y * nBallE + iv.x;\n  if (iFrame <= 5) {\n    spLen = 1.1;\n    nStep = 0.;\n    if (mId < nb) Init (iv, r, v);\n  } else {\n    stDat = Loadv4 (vec2 (0, nBallE));\n    spLen = stDat.x;\n    nStep = stDat.y;\n    stDat = Loadv4 (vec2 (3, nBallE));\n    ++ nStep;\n    if (mId < nb) Step (iv, r, v);\n  }\n  if (pxId == 2 * nb + 1 || pxId == 2 * nb + 2) SheetLims ();\n  if (pxId < 2 * nb) stDat = vec4 (((pxIv.x >= nBallE) ? v : r), 0.);\n  else {\n    if (pxId == 2 * nb + 0) stDat = stDat = vec4 (spLen, nStep, 0., 0.);\n    else if (pxId == 2 * nb + 1) stDat = vec4 (pMin, 0.);\n    else if (pxId == 2 * nb + 2) stDat = vec4 (pMax, 0.);\n  }\n  Savev4 (vec2 (pxIv), stDat, fragColor, fragCoord);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"Flagtime\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Fbm1 (float p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\n#define LBIG   0  // (= 0/1) common to all shaders\n\n#if LBIG\nconst int nBallE = 65;\n#else\nconst int nBallE = 33;\n#endif\n\nvec3 pMin, pMax;\nivec2 idNeb[4], idNebD[4];\nfloat tCur, spLen, nStep;\nconst float pi = 3.14159;\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nvec3 GetV (vec2 v)\n{\n  return Loadv4 (vec2 (v.x + float (nBallE), v.y)).xyz;\n}\n\nvec3 SpringForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 dr, f;\n  ivec2 ivn;\n  float spLenD, fSpring, fSpringD, fDamp;\n  fSpring = 200.;\n  fDamp = 1.;\n  f = vec3 (0.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNeb[n];\n    if (ivn.y >= 0 && ivn.y < nBallE && ivn.x >= 0 && ivn.x < nBallE) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpring * (spLen - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  fSpringD = 3. * fSpring;\n  spLenD = spLen * sqrt(2.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNebD[n];\n    if (ivn.y >= 0 && ivn.y < nBallE && ivn.x >= 0 && ivn.x < nBallE) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpringD * (spLenD - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  return f;\n}\n\nvec3 BendForce (ivec2 iv, vec3 r)\n{\n  vec3 dr1, dr2, rt, f;\n  ivec2 ivd, ivp, ivm;\n  float s, c11, c22, c12, cd;\n  bool doInt;\n  f = vec3 (0.);\n  for (int nd = 0; nd < 2; nd ++) {\n    ivd = (nd == 0) ? ivec2 (1, 0) : ivec2 (0, 1);\n    for (int k = 0; k < 3; k ++) {\n      doInt = false;\n      if (nd == 0) {\n        if (k == 0 && iv.x > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.x < nBallE - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.x > 0 && iv.x < nBallE - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      } else {\n        if (k == 0 && iv.y > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.y < nBallE - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.y > 0 && iv.y < nBallE - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      }\n      if (doInt) {\n        if (k == 0) {\n          rt = GetR (vec2 (ivp));\n          dr1 = rt - GetR (vec2 (ivm));\n          dr2 = r - rt;\n          s = -1.;\n        } else if (k == 2) {\n          rt = GetR (vec2 (ivm));\n          dr1 = rt - r;\n          dr2 = GetR (vec2 (ivp)) - rt;\n          s = -1.;\n        } else {\n          dr1 = r - GetR (vec2 (ivm));\n          dr2 = GetR (vec2 (ivp)) - r;\n          s = 1.;\n        }\n        c11 = 1. / dot (dr1, dr1);\n        c12 = dot (dr1, dr2);\n        c22 = 1. / dot (dr2, dr2);\n        cd = sqrt (c11 * c22);\n        s *= cd * (c12 * cd - 1.);\n        if (k <= 1) f += s * (dr1 - c12 * c22 * dr2);\n        if (k >= 1) f += s * (c12 * c11 * dr1 - dr2);\n      }\n    }\n  }\n  return f;\n}\n\nvec3 PairForce (vec3 r)\n{\n  vec3 dr, f;\n  float rSep;\n  int nx, ny;\n  f = vec3 (0.);\n  nx = 0;\n  ny = 0;\n  for (int n = 0; n < nBallE * nBallE; n ++) {\n    dr = r - GetR (vec2 (nx, ny));\n    rSep = length (dr);\n    if (rSep > 0.01 && rSep < 1.) f += (1. / rSep - 1.) * dr;\n    if (++ nx == nBallE) {\n      nx = 0;\n      ++ ny;\n    }  \n  }\n  return f;\n}\n\nvec3 NormForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 f, n;\n  ivec2 e = ivec2 (1, 0);\n  f = vec3 (0.);\n  if (iv.y > 0 && iv.y < nBallE - 1 && iv.x > 0 && iv.x < nBallE - 1) {\n    n = normalize (cross (GetR (vec2 (iv + e.yx)) - GetR (vec2 (iv - e.yx)),\n       GetR (vec2 (iv + e)) - GetR (vec2 (iv - e))));\n    f = - dot (v, n) * n;\n  }\n  return f;\n}\n\nvoid IdNebs ()\n{\n  idNeb[0] = ivec2 (1, 0);\n  idNeb[1] = - idNeb[0];\n  idNeb[2] = ivec2 (0, 1);\n  idNeb[3] = - idNeb[2];\n  idNebD[0] = ivec2 (1, 1);\n  idNebD[1] = - idNebD[0];\n  idNebD[2] = ivec2 (1, -1);\n  idNebD[3] = - idNebD[2];\n}\n\nvoid Step (ivec2 iv, out vec3 r, out vec3 v)\n{\n  vec3 dr, f, wDir;\n  vec2 s;\n  float fOvlap, fBend, fGrav, fDamp, dt;\n  IdNebs ();\n  fOvlap = 1000.;\n  fBend = 50.;\n  fGrav = 1.;\n  fDamp = 0.5;\n  wDir = vec3 (Rot2D (vec2 (-1., 0.), 0.7 * pi * (2. * Fbm1 (1.5 * tCur) - 1.)), 0.).xzy;\n  r = GetR (vec2 (iv));\n  v = GetV (vec2 (iv));\n  f = fOvlap * PairForce (r) + SpringForce (iv, r, v) + fBend * BendForce (iv, r) +\n     (1. + 10. * Fbm1 (tCur)) * NormForce (iv, r, wDir);\n  f -= fDamp * v;\n  f.y -= fGrav;\n  dt = 0.02;\n  if (iv.x != 0 || mod (float (iv.y), float ((nBallE - 1) / 8)) != 0. && iv.y != nBallE - 2) {\n    v += dt * f;\n    r += dt * v;\n  }\n}\n\nvoid Init (ivec2 iv, out vec3 r, out vec3 v)\n{\n  float fn;\n  for (int iy = 0; iy < nBallE; iy ++) {\n    for (int ix = 0; ix < nBallE; ix ++) {\n      if (iv.x == ix && iv.y == iy) {\n        r = vec3 (ix, iy, 0.);\n        r.xy -= 0.5 * (vec2 (nBallE, nBallE) - 1.);\n        r *= 0.97 * spLen;\n      }\n    }\n  }\n  fn = float (iv.y * nBallE + iv.x);\n  v = 1. * normalize (vec3 (Hashff (fn), Hashff (fn + 0.3), Hashff (fn + 0.6)) - 0.5);\n}\n\nvoid SheetLims ()\n{\n  vec3 p;\n  pMin = vec3 (1e6);\n  pMax = - pMin;\n  for (int iy = 0; iy < nBallE; iy ++) {\n    for (int ix = 0; ix < nBallE; ix ++) {\n      p = GetR (vec2 (ix, iy));\n      pMin = min (pMin, p);\n      pMax = max (pMax, p);\n    }\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 r, v;\n  ivec2 pxIv, iv;\n  int mId, pxId, nb;\n  tCur = iTime;\n  pxIv = ivec2 (fragCoord);\n  pxId = pxIv.x + 2 * nBallE * pxIv.y;\n  nb = nBallE * nBallE;\n  if (pxIv.x >= 2 * nBallE || pxId >= 2 * nb + 3) discard;\n  stDat = Loadv4 (vec2 (2, nBallE));\n  iv = pxIv;\n  if (iv.x >= nBallE) iv.x -= nBallE;\n  mId = iv.y * nBallE + iv.x;\n  if (iFrame <= 5) {\n    spLen = 1.1;\n    nStep = 0.;\n    if (mId < nb) Init (iv, r, v);\n  } else {\n    stDat = Loadv4 (vec2 (0, nBallE));\n    spLen = stDat.x;\n    nStep = stDat.y;\n    stDat = Loadv4 (vec2 (3, nBallE));\n    ++ nStep;\n    if (mId < nb) Step (iv, r, v);\n  }\n  if (pxId == 2 * nb + 1 || pxId == 2 * nb + 2) SheetLims ();\n  if (pxId < 2 * nb) stDat = vec4 (((pxIv.x >= nBallE) ? v : r), 0.);\n  else {\n    if (pxId == 2 * nb + 0) stDat = stDat = vec4 (spLen, nStep, 0., 0.);\n    else if (pxId == 2 * nb + 1) stDat = vec4 (pMin, 0.);\n    else if (pxId == 2 * nb + 2) stDat = vec4 (pMax, 0.);\n  }\n  Savev4 (vec2 (pxIv), stDat, fragColor, fragCoord);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}