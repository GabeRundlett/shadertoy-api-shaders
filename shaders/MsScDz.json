{
    "Shader": {
        "info": {
            "date": "1491585828",
            "description": "left mouse button == mouselook , just pause time.\n\nhttps://www.shadertoy.com/view/4djczw \nis closer to its source that worked on linux.\nwhile this one solves for windows?",
            "flags": 0,
            "hasliked": 0,
            "id": "MsScDz",
            "likes": 6,
            "name": " Books and Stairs patched?",
            "published": 3,
            "tags": [
                "raymarch",
                "library",
                "babel"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 737
        },
        "renderpass": [
            {
                "code": "//this is pretty much a duplicate backup of \n//https://www.shadertoy.com/view/4djczw\n//that i made out of pride for fixing one incompatibility with non-linux systems\n//most likely caused by mod(a,b) for b<=0;\n//you can undo my fix by replacing all \"max(0.5,szGr.y)\" with \"szGr.y\"\n//and you will get some strange overstepping, but not on linux.\n//this patch is lousy and may be insufficient or inefficient.\n//such is patching someone elses code.\n\n\n//https://www.shadertoy.com/view/4djczw \n//worked well on linux, but not well on windows.\n//https://www.shadertoy.com/view/MsScDz ==.this\n//seems to work well for windows, but not on linux.\n\n//this dichoonomy makes debugging hard.\n\n//to be a true \"library of babel\"\n//\n//this needs klickable books filled with content that equals any book's position, \n//if you encode position and content to binary in a unique non-hash address.\n//\n//a single 16 bit float is insufficient to place a camera in it \n//(and to address all books in it)\n//so this needs a buffer that stores an xyz camera position, bitwise, ina rgba array\n//of at least 1024x1024 pixels.\n//i did calculations for all that, but never finished a 3d model for it as it exists here.\n\n//this needs a freely movable camera\n//\n//this needs more \"pony\" \n//to match the story to the youtube fanfiction video \n//\"library of discord\"\n\n//increased how far you can look down\n//and found more error cases when increasing how far i could look up:\n//\n//all that lookUp sets is how far i can rotate the camera up:\n//and setting this value >.3 causes the same damn overstepping errors again!\nconst float lookUp=.3;\n//all while lookDown is just fine being >.4, allowing you to look down into the abyss:\nconst float lookDown=.4;\n//\n//danit i am onto something new in regards to a bug in this code.\n\n\n// \"Books and Stairs\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrRCylDf (vec3 p, float r, float rt, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nvec2 HexCellId (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\n\nconst float pi = 3.14159;\nconst float sqrt3 = 1.73205;\n\nvec3 inCell;\nvec2 szGr, bsa[4];\nfloat dstFar, tCur, rdRm, htRm, wlThk, rdHol, spShf, htShf, hRot;\nint idObj;\nbool isHole;\nconst int idRm = 1, idCol = 2, idRal = 3, idChr = 4, idBks = 5, idShlf = 6,\n   idStp = 7, idLt = 8;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float d, dMin, r, a, da, dy, ah6, a6h, wdDor, wdShf, db, rm, stDir, fns;\n  const int ns = 16;\n  dMin = dstFar;\n  wdDor = 0.15 * szGr.x;\n  wdShf = 0.06 * rdRm;\n  q = p;\n  inCell.xy = HexCellId (q.xz / szGr.x);\n  inCell.z = floor (q.y / (2. * szGr.y) + 0.5);\n  isHole = (all (equal (mod (inCell.xy, 2.), vec2 (0.))));\n  q.xz -= vec2 (2. * inCell.x + inCell.y, sqrt3 * inCell.y) * szGr.x;\n  r = length (q.xz);\n  a = (r > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n  ah6 = 2. * pi * floor (6. * a + 0.5) / 6.;\n  a6h = 2. * pi * (floor (6. * a) + 0.5) / 6.;\n  rm = 1.5 - abs (r - 0.5 * (rdHol + rdRm - wlThk));\n    \n  if (isHole) {\n    qq = q;\n    fns = float (ns);\n    stDir = 1. - 2. * step (1., mod (floor (6. * a), 2.));\n    qq.xz = Rot2D (qq.xz, 2. * pi * ((floor (3. * a) - stDir * 0.5 + 0.5) / 3. +\n       stDir * (0.5 * fns / (fns + 1.) + 0.8/12.) / 12.));\n    qq.y = mod (qq.y + max(0.5,szGr.y), 2. *max(0.5,szGr.y)) - max(0.5,szGr.y);\n    qq.y -= - htRm + 0.2;\n    da = stDir * 2. * pi / (2. * 6. * fns);\n    dy = (2. * max(0.5,szGr.y) - 0.5) / fns;\n    d = dMin;\n    for (int j = 0; j < ns; j ++) {\n      d = min (d, - min (min (rm, 0.3 - abs (qq.y)), 0.15 - abs (qq.z)));\n      qq.xz = Rot2D (qq.xz, da);\n      qq.y -= dy;\n    }\n    if (d < dMin) { dMin = d;  idObj = idStp; }\n  }\n  q.y = mod (q.y + szGr.y, 2. * szGr.y) - szGr.y;\n  qq = q;\n  qq.xz = Rot2D (qq.xz, ah6);\n  d = min (max (abs (r - rdRm) - wlThk, wdDor - abs (qq.z)),\n     htRm - abs (qq.y));\n  if (isHole) {\n    d = max (d, rdHol - (0.05 + r));\n    qq.z = abs (qq.z);\n    db = min (rm, dot (qq.xz, bsa[2]));\n    d = min (max (db, d), max (db, - min (min (rm + 0.2, 0.1 -\n       abs (qq.y + htRm - 0.1)), dot (qq.xz, bsa[3]))));\n  }\n  if (d < dMin) {dMin = d;  idObj = idRm; }\n  if (isHole) {\n    d = length (max (abs (vec2 (r - rdHol, abs (abs (q.y + 0.625 * htRm) -\n       0.15 * htRm) - 0.075 * htRm)) - vec2 (0.06, 0.04), 0.)) - 0.005;\n    qq = q;  qq.y -= - htRm + 0.3 * htRm;\n    qq.xz = Rot2D (qq.xz, 2. * pi * ((floor (18. * a) + 0.5) / 18.));\n    qq.x += rdHol;\n    d = min (d, PrCylDf (qq.xzy, 0.05, 0.3 * htRm));\n    if (d < dMin) { dMin = d;  idObj = idRal; }\n  } else { \n    qq = q;  qq.y -= 0.7 - htRm;\n    d = PrRCylDf (qq.xzy, 2.5, 0.1, 0.7);\n    if (d < dMin) { dMin = d;  idObj = idChr; }\n    qq = q;\n    qq.xz = Rot2D (qq.xz, a6h);\n    qq.z = abs (qq.z);\n    d = max (abs (r - rdRm + wlThk + 1. * wdShf) - 0.5 * wdShf, dot (qq.xz, bsa[1]));\n    d = max (d, abs (qq.y) - htRm + spShf);\n    if (d < dMin) {dMin = d;  idObj = idBks; }\n    d = max (abs (r - rdRm + wlThk + wdShf) - wdShf, dot (qq.xz, bsa[0]));\n    d = max (d, min (abs (mod (qq.y + 0.5 * spShf, spShf) - 0.5 * spShf) - htShf,\n       - dot (qq.xz, bsa[1])));\n    d = max (d, abs (qq.y) - htRm + spShf);\n    if (d < dMin) {dMin = d;  idObj = idShlf; }\n    qq.x -= - 0.85 * rdRm;\n    qq.z -= 0.29 * rdRm;\n    d = PrCylDf (qq.xzy, 0.25, htRm);\n    if (d < dMin) {dMin = d;  idObj = idCol; }\n  }\n  qq = q;\n  qq.xz = Rot2D (qq.xz, ((! isHole) ? a6h : ah6));\n  qq.xy -= vec2 (- 0.5 * (rdHol + rdRm - wlThk), htRm - 0.04);\n  if (! isHole) qq.z = abs (qq.z) - 1.7;\n  d = PrCylDf (qq.xzy, 0.3, 0.03);\n  if (d < dMin) {dMin = d;  idObj = idLt; }\n  if (! isHole) {\n    qq = q;\n    qq.y -= htRm + 1.7;\n    d = max (PrSphDf (qq, 2.), q.y - htRm);\n    if (d < dMin) {dMin = d;  idObj = idLt; }\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 200; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.0001, -0.0001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = 0; j < 8; j ++) {\n    d = 0.1 + float (j) / 16.;\n    ao += max (0., d - 3. * ObjDf (ro + rd * d));\n  }\n  return 0.5 + 0.5 * clamp (1. - 0.2 * ao, 0., 1.);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = 0; j < 20; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.2;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 WoodCol (vec3 p, vec3 n)\n{\n  float f;\n  p *= 4.;\n  f = dot (vec3 (Fbm2 (p.zy * vec2 (1., 0.1)),\n     Fbm2 (p.zx * vec2 (1., 0.1)), Fbm2 (p.xy * vec2 (1., 0.1))), abs (n));\n  return 0.8 * mix (vec3 (0.9, 0.5, 0.3), vec3 (0.55, 0.35, 0.1), f);\n}\n\nvec3 FloorCol (vec2 p)\n{\n  return mix (vec3 (0.8, 0.4, 0.2), vec3 (0.5, 0.25, 0.1),\n     Fbm2 (20. * vec2 (1., 0.1) * p.xy)) *\n     (0.5 + 0.5 * SmoothBump (0.03, 0.97, 0.01, mod (3. * p.x, 1.)));\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return 0.5 * sqrt3 * ((1. - p.x)  + 0.5 * min (p.x - sqrt3 * p.y, 0.));\n}\n\nvec3 HexGrdCol (vec2 p)\n{\n  p.y *= 2./sqrt3;\n  p.x += 0.5 * mod (floor (p.y), 2.);\n  p = abs (fract (p) - 0.5);\n  return mix (vec3 (0.3, 0.3, 0.25), vec3 (0.4, 0.5, 0.2),\n     smoothstep (0.05, 0.15, abs (p.x + max (p.x, 1.5 * p.y) - 1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 roo, ltVec, col, vn, q, ld, bgCol;\n  vec2 gbRm, gbBk, g, bt;\n  float dstObj, r, a, bh, s, cRm, fr, spec, ao, sh, atten;\n  bool isLit;\n  wlThk = 0.04 * szGr.x;\n  rdRm = szGr.x - 0.7 * wlThk;\n  rdHol = 0.5 * rdRm;\n  htRm = 0.93 * szGr.y;\n  spShf = htRm / 3.;\n  htShf = 0.05 * spShf;\n  float cbc[4];\n  cbc[0] = 1.1;  cbc[1] = 1.06;  cbc[2] = 1.;  cbc[3] = 0.92;\n  for (int k = 0; k < 4; k ++) \n     bsa[k] = vec2 (sin (cbc[k] * 2. * pi / 24.), cos (cbc[k] * 2. * pi / 24.));\n  roo = ro;\n  dstObj = ObjRay (ro, rd);\n  isLit = true;\n  bgCol = (abs (rd.y) < 0.5) ? 0.5 * vec3 (0.7, 0.5, 0.) : ((rd.y > 0.) ?\n     vec3 (0.5, 0.5, 0.55) : vec3 (0., 0., 0.2));\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    q = ro;\n    q.xz -= vec2 (2. * inCell.x + inCell.y, sqrt3 * inCell.y) * szGr.x;\n    q.y = mod (q.y + szGr.y, 2. * szGr.y) - szGr.y;\n    r = length (q.xz);\n    a = (r > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n    gbRm = inCell.xy + inCell.z;\n    cRm = Noisefv2 (gbRm * vec2 (17., 11.));\n    vn = ObjNf (ro);\n    spec = 0.1;\n    if (idObj == idRm) {\n      col = vec3 (0.8, 0.6, 0.5);\n      if (vn.y < -0.99) {\n        isLit = false;\n        if (r < 0.99 * rdRm) {\n          if (isHole) col = vec3 (0.8, 0.8, 0.6) * (1. - 0.3 * smoothstep (0.4, 3.,\n             length (vec2 (15. * (0.5 - mod (6. * a + 0.5, 1.)),\n             r - 0.5 * (rdHol + rdRm - wlThk)))));\n          else col = mix (vec3 (0.2, 0.2, 0.5), vec3 (0.4, 0.4, 0.7),\n             smoothstep (0.1, 0.8, r / rdRm)) *\n             (1. - 0.05 * SmoothBump (0.3, 0.6, 0.1, mod (10. * r / rdRm, 1.)));\n        } else col = vec3 (0.4, 0.4, 0.7);\n      } else if (abs (vn.y) < 0.01) {\n        if (r > rdRm - 0.9 * wlThk) {\n          col = vec3 (0.4, 0.4, 0.8) * (0.6 + 0.3 * q.y / htRm);\n          isLit = false;\n        } else if (isHole) {\n          if (q.y > - htRm + 0.001 && r > rdRm - wlThk - 0.01) {\n            q.xy = vec2 (10. * (mod (6. * a, 1.) - 0.5), 0.5 * q.y);\n            col = HexGrdCol (6. * q.xy);\n            if (abs (q.x) < 0.5 && abs (q.y) < 0.15) {\n              if (ShowInt (vec2 (q.x - 0.5, q.y + 0.12),\n                 vec2 (1., 0.25), 4., mod (4242. + inCell.z, 10000.)) != 0.) {\n                col = vec3 (0.7, 0.7, 0.);\n                isLit = false;\n              }\n            }\n          } else if (q.y < - htRm && r > rdHol + 0.01) {\n            col = vec3 (0.2, 0.2, 1.);\n            isLit = false;\n          } else if (r < rdHol + 0.01) {\n            col = vec3 (0.5, 0.7, 0.3) * (1. - 0.1 * SmoothBump (0.45, 0.55, 0.01,\n               mod (120. * a, 1.)));\n          }\n        } else col = 1.1 * WoodCol (vec3 (120. * a, ro.y, r), vn);\n      } else if (vn.y > 0.99 && q.y < - htRm + 0.001 &&\n         (! isHole || r > rdHol + 0.05)) {\n        col = FloorCol (vec2 (32. * a, r));\n        if (! isHole) col *= (1. + smoothstep (0.5, 0.9, r / rdRm) *\n           0.5 * smoothstep (0.1, 0.3, abs (0.5 - mod (6. * a - 0.5, 1.))));\n        col = mix (vec3 (1., 0.7, 0.), col, step (0.01, HexEdgeDist (q.xz / szGr.x)));\n      }\n    } else if (idObj == idRal) {\n      col = vec3 (0.7, 0.7, 0.5);\n      spec = 0.1;\n    } else if (idObj == idChr) {\n      if (r < 0.8) {\n        col = vec3 (0.4, 0.4, 0.7);\n        q.xz = Rot2D (q.xz, tCur);\n        q.xz = 1.2 * (q.xz - vec2 (0.4, -0.1));\n        if (ShowInt (q.xz,\n           vec2 (1., 0.25), 4., dot (mod (vec2 (42., 24.) + inCell.xy, 100.),\n           vec2 (100., 1.))) != 0.) {\n          col = vec3 (1., 1., 0.);\n          isLit = false;\n        }\n      } else col = vec3 (0.7, 0.5, 0.) * (0.5 +\n         0.5 * SmoothBump (0.3, 0.7, 0.02, mod (6. * a, 1.)));\n    } else if (idObj == idBks) {\n      bt = vec2 (5000. * a, 200. * q.y);\n      a = 80. * mod (6. * a + 0.5, 1.);\n      gbBk = floor (vec2 (q.y / spShf, a));\n      bh = (0.7 + 0.3 * Fbm2 ((gbRm + gbBk) * vec2 (19., 31.))) * spShf;\n      q.y = mod (q.y, spShf);\n      if (q.y < bh) {\n        q.xy = vec2 (2. * mod (a, 1.) - 1., q.y / bh - 0.5);\n        col = vec3 (HsvToRgb (vec3 (mod (cRm +\n           0.2 * (Fbm2 (gbBk * vec2 (17., 11.)) - 0.5), 1.), 1.,\n           0.7 * SmoothBump (0.08, 0.92, 0.01, 0.55 + 0.45 * q.x))));\n        if (abs (q.x) < 0.3 && abs (q.y) < 0.2 &&\n           Noisefv2 ((gbRm + gbBk) * vec2 (19., 31.) + floor (bt)) > 0.7) {\n          col *= 4.;\n        } else {\n          spec = 0.3;\n          vn.xz = Rot2D (vn.xz, q.x);\n        }\n      } else {\n        col = vec3 (0.02);\n        isLit = false;\n      }\n    } else if (idObj == idShlf) {\n      col = WoodCol (vec3 (5. * (mod (6. * a, 1.) - 0.5), ro.y, r), vn);\n    } else if (idObj == idCol) {\n      col = vec3 (0.8, 0.7, 0.6) * (1. - 0.1 * SmoothBump (0.45, 0.55, 0.02,\n         mod (4. * q.y, 1.)));\n    } else if (idObj == idStp) {\n      if (abs (r - 0.5 * (rdHol + rdRm - wlThk)) < 1.1) {\n        if (vn.y > 0.99) col = FloorCol (vec2 (64. * a, r));\n        else col = vec3 (0.7, 0.4, 0.2);\n      } else col = vec3 (0.6, 0.6, 0.9);\n    } else if (idObj == idLt) {\n      col = vec3 (1., 1., 0.7) * (0.5 - 0.5 * vn.y);\n      if (! isHole && r < 1.5) col *= 0.95 + 0.05 * sin (12. * 2. * pi * a);\n      isLit = false;\n    }\n    ltVec = roo + vec3 (0., 2., 0.) - ro;\n    atten = 1. / (1. + 0.0001 * dot (ltVec, ltVec));\n    if (isLit) {\n      ltVec = normalize (ltVec);\n      ao = ObjAO (ro, vn);\n      sh = ObjSShadow (ro, ltVec);\n      col = col * ao * (0.2 + 0.8 * atten * sh * max (0., max (dot (vn, ltVec), 0.)) +\n         atten * spec * sh * pow (max (0., dot (ltVec, reflect (rd, vn))), 16.));\n    } else col *= atten;\n  } else col = bgCol;\n  col = mix (col, bgCol, smoothstep (0.6, 1., min (dstObj / dstFar, 1.)));\n  col = clamp (col, 0., 1.);\n  return col;\n}\n\nvec3 TrackPath (float t)\n{\n  vec3 p;\n  vec2 tp[7], td[6];\n  float dir, tm, tc;\n  tm = mod (t, 15.);\n  tc = floor (t / 15.);\n  p.y = 0.1 + 2. * tc;\n  td[0] = vec2 (1., 0.);\n  tp[0] = vec2 (-0.5 + 2. * tc, -0.5 * sqrt3);\n  dir = 1. - 2. * step (15., mod (t, 30.));\n  if (tm < 14.) {\n    hRot = 0.;\n    if (tm < 12.) {\n      dir *= -1. + 2. * step (6., tm);\n      tm = mod (tm, 6.);\n      td[1] = vec2 (0.5, 0.5 * sqrt3 * dir);\n      td[2] = vec2 (-0.5, 0.5 * sqrt3 * dir);\n      td[3] = - td[0];\n      td[4] = - td[1];\n      td[5] = - td[2];\n      for (int k = 0; k < 6; k ++) tp[k + 1] = tp[k] + td[k];\n      if (tm < 1.)      p.xz = tp[0] + td[0] * tm;\n      else if (tm < 2.) p.xz = tp[1] + td[1] * (tm - 1.); \n      else if (tm < 3.) p.xz = tp[2] + td[2] * (tm - 2.); \n      else if (tm < 4.) p.xz = tp[3] + td[3] * (tm - 3.); \n      else if (tm < 5.) p.xz = tp[4] + td[4] * (tm - 4.); \n      else if (tm < 6.) p.xz = tp[5] + td[5] * (tm - 5.); \n    } else {\n      p.xz = tp[0] + td[0] * (tm - 12.);\n    }\n  } else {\n    p.xz = tp[0] + 2. * td[0];\n    p.y += 2. * (tm - 14.);\n    hRot = 2. * pi * dir * (tm - 14.);\n  }\n  p.xz *= 4. * szGr.x;\n  p.y *= szGr.y;\n  return p;\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, fpF, fpB, vd;\n  vec2 uv, ori, ca, sa;\n  float el, az, spd;\n  uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az = az + 2. * pi * mPtr.x;\n    el = clamp (el + 0.8 * pi * mPtr.y, -lookDown * pi, lookUp * pi);\n  }\n  szGr = vec2 (15., 3.3);\n  spd = 0.12;\n  fpF = TrackPath (spd * tCur + 0.1);\n  az += hRot;\n  fpB = TrackPath (spd * tCur - 0.1);\n  ro = 0.5 * (fpF + fpB);\n  vd = fpF - fpB;\n  ori = vec2 (el, az + ((length (vd.xz) > 0.) ? atan (vd.x, vd.z) : 0.5 * pi));\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 2.5));\n  dstFar = 500.;\n  fragColor = vec4 (ShowScene (ro, rd), 2.);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrRCylDf (vec3 p, float r, float rt, float h)\n{\n  vec2 dc;\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  dc = vec2 (dxy, dz) + rt;\n  return min (min (max (dc.x, dz), max (dc.y, dxy)), length (dc) - rt);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nvec2 HexCellId (vec2 p)\n{\n  vec3 c, r, dr;\n  p.y *= (1./sqrt3);\n  c.xz = vec2 (0.5 * (p.x - p.y), p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (2., step (dr.yzx, dr) + step (dr.zxy, dr)) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nfloat DigSeg (vec2 q)\n{\n  return step (abs (q.x), 0.12) * step (abs (q.y), 0.6);\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.5, 2.2);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log (val) / log (10.), 0.)) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (sgn < 0.) {\n      if (idChar == mxChar - nDig - 1.) s = ShowDig (q, -1);\n      else ++ v;\n    }\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}