{
    "Shader": {
        "info": {
            "date": "1503323516",
            "description": "Return distance to 2 circles and a 3rd circle that is a \"rounded tangent\".\n\ncleaned up version of  https://www.shadertoy.com/view/4lsyzr\n",
            "flags": 0,
            "hasliked": 0,
            "id": "4lXyRH",
            "likes": 7,
            "name": "Moss Egg Branchless",
            "published": 3,
            "tags": [
                "arrow",
                "egg",
                "tangent",
                "moss",
                "bisymmetry",
                "earvagegg",
                "earvagegg",
                "tangentcapsule",
                "superpimm",
                "pointer",
                "appolonean"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1234
        },
        "renderpass": [
            {
                "code": "//https://www.shadertoy.com/view/4lsyzr\n\n/*\nsketch showing underlying trigonometry:\nhttp://imgur.com/a/WjcwM\n\nThis is a dirty first draft, inefficient and with no clear context, \nbecause i got too tired of this for today to optimize oand clean it contextually.\nIt lacks user friendly oconstrains, like, flickering if m.y is too high or too low\nbecause i have not decided on ui constrains beyond basic functionality:\n\nmouse.xy sets upper and lower radii (blue and red), \nthe larger radius will alway be red.\na r3d/largest radius rounds the middle part (green)\nits radius is set by \n*/\n//#define  rac mix(.5,3.,sin(iTime)*.5+.5)\n//.5== circle;  5.= pretty straight red segment;  +inf=straight red segment.\n/*\nthe 3rd/larger circle contains the 2 smaller circles and touches them at 1 point.\nThis results in a very precise egg-shaped distance field:\n\nA rounder \"tangential capsule\" has the middle part not as straight line, \nbut a 3rd large circle with a radius \nthat contains the other 2 circles and touches them once.\n\nif (3rd circle has infinite radius) this would be [tangentCapsule superprim].\n\nthe whole shapes implicit curve is constrained to 0<=y<=1 due to the input setup.\n\n*/\n\n\n\n/*\ntiny framework 2017-08\nI use \"bisymmetry\" as shorthand for \"gradient from symmetry to assymmetry\"\n*/\n\n/* end__.Head\n   start.Parameters\n*/\n\n//set size of 3rd circle==inverseRoundness of the \"tangent\" between the 2 smaller circles.\n#define rac mix(.5,3.,sin(iTime)*.5+.5)\n//.5== circle;  5.= pretty straight red segment;  +inf=straight red segment.\n\n//show segment cases\n#define showCases\n\n//apply:  c=abs(c)-.05; making the distance field an outline of itself.\n//#define toisoline\n\n//zoom of view Frame\n#define ViewZoom 1.5\n#define fra(u) (u-.5*iResolution.xy)*ViewZoom/iResolution.y\n\n/* end__.Parameters\n   start.Static\n*/\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n/* end__.Static\n   start.Implicit\n*/\n//return circle-circle-intersection.x; r.x=circle.left.radius;r.y=circle.right.radius;r.z=circles-centers.distance\nv0 cci(vec3 r){v0 d=r.z*2.;r*=r;return(r.x-r.y+r.z)/d;}\n//does not check for non-intersecticn cases! intersection.y is not important here.   \n\n//smart way <- NEVER give input values that result in undefined axiomes <- arbituarity.\n//slow  way <- make all unsave inputs WorkSafe <- more if(),symmetrySolds,BVH\n#define GoedelTarski\n//return distance to 2 circles with a rounded tangent between them. http://imgur.com/a/WjcwM\n//m.xy set radius of upper and lower small circle\n//m.z sets radius of a large circle, which rounds the tangent\nv2 moss(v1 u,v2 m){u.x=abs(u.x);//make bilateral              \n #ifdef GoedelTarski\n //catch division by 0 cases before they can occur:\n m.xy=mod(abs(m.xy),.5);m.z=max(m.z,.5);//catch sqrt(<0); too small 3rd circle radius (make 3rd circle minimum size)\n if(m.z==.5)return vec3(length(u-v1(0,.5))-.5);//catch 3rd circle border case. (shape is a circle)\n #endif               \n //m.z=.5;//test border case, expect pseudo-arbitiary flickering\n v0 c=cci(v2(m.zz-m.yx,m.y+m.x-1.)),//calculate circle circle intersection.y\n l=m.z-m.y;//other length for pytagorean theorem below, to get intersection.x\n v1 d=v1(0,m.y),//smaller upper circle center\n e=v1(0,1.-m.x),  //smaller lower circle center\n i=v1(-sqrt(l*l-c*c),m.y-c);//3rd circle center.y\n v1 h=v1(sign(dot(u-d,v1(           -c,d.x-i.x))),\n         sign(dot(u-e,v1(-1.+m.x+m.y-c,d.x-i.x))))+1.;//2 branching \"lines\"\n v1 j=d+.5*(i-d)*h.x;l*=h.x;\n vec3 r=vec3(length(u-j-.5*(e-j)*h.y) -m.y +.5*(h.y*(.5*l+m.y-m.x)-l));\n #ifdef showCases\n  r.xy*=h.xy-1.;\n #endif\n return r;}\n//https://www.shadertoy.com/view/4lXyRH\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n v1 u=fra(U);\n v2 c=v2(0);\n vec4 m=vec4(fra(iMouse.xy),fra(iMouse.zw));\n u.y+=.5;m.y+=.5;//optional frame shift\n  if(iMouse.z<=0.)m.xy=vec2(cos(iTime),sin(iTime*.61))*.4;///assive mouse\n /*main*/\n \n m.z=rac;//.5== circle;  5.= pretty straight red segment;  +inf=straight red segment.\n c=moss(u,vec3(m.xy,m.z));\n\n /*O*/\n #ifdef toisoline\n  c.b=abs(c.r)-.03;\n #endif\n v0 fsaa=1./min(iResolution.x,iResolution.y);\n c=mix(fract(c*4.),smoothstep(fsaa,-fsaa,c),.6);\n return c*.3+c.yzx*.7;}\n \n \nvoid mainImage(out vec4 O,vec2 U){O=vec4(c(U),1);}\n// #define mainImage(O,U)O=vec4(c(U),1);  //no longer functional\n\n/* end__.Main\n   start.Tail\n*/\n\n\n/*\nthe BISYMETRY PRINCIPLE: v3\n- In a quest to increase symmetry for performance and modular shaders. (in contextual biases)\n- - utilize  https://en.wikipedia.org/wiki/List_of_planar_symmetry_groups\n- - utilize linear-algebra-deformed mirror borders that define branches.\n- - Only write atomic special cases and transformations, \n- - ...to construct general functions from.\n- - Instead of writing a general function, \n- - ...to be fed with a lot of parameters set to 0 or 1 to turn them into \"special cases\"\n- - this way general functions can be made into special \"shortcut\" functions more easily.\n- - this way special functions can more easily be extended, generalized.\n...\n- it appears the \"ideal bisymmetrically optimized function looks something like this:\nfloat demo(vec2 u,vec4 m){//u= uv fragment position; m=iMouse.xyzw both likely transformed\n u.x=abs(u.x-1.); u.y=-u.y*.5; //symmetry modifiers are likely \"outsourced\"\n float a=sign(m.x-1.)+1.;\n float b=sign(m.y+1.)+u.x;\n float c=sign(m.z+m.x)-m.y;\n float c=-sign(m.z-u.x);\n //above are all sign-factors, below is the final binomial, both rarely are shared subroutines.\n return u.x*(a+b)*(c+2.)*d*0.5-u.y//the *.5 and -u-y can likely be \"outsourced\"\n}\n- how you transform binomials and branches depends on the bias from your context.\n- in general, it makes sense to delay sqrt() or length() as much as possible.\n- ... while also keeping brnches that are shortcuts \n- ... eg: usually abs(length()) begs to be a shortcut.\n...\n- this whole PRINCIPLE screams FRACTAL and SUPERPRIM ! \n- - https://www.shadertoy.com/results?query=superprim\n- this PRINCIPLE more easily delays sqrt() or length() till the end of a function, \"outsource\"able\n\nHOW TO\n- rearrange your branches so that sqrt() or length() is delayed as much as possible.\n- abs(length()) can not be delayed, therefore it may as well be treated as a shortcut.\n- ... meaning, if(your shape contains abs(length())) that branch stays as if() branch!\n- all other brahcnes usually end up being equally omplex trees of equally complex branches.\n- in that case, an openCL coders eyes open to reveal how to make long pipelines:\n- Substitute functions with identities to reveal their underlying bisymmetries.\n- - substitute max() to if()then() to mix(step)) to mix(sign()) to sums of sign()\n- - - for details on identities see - https://www.shadertoy.com/view/ldBfzc\n- - because there is often a lot of symmetry performance \"lost\" in if-branches, or max()=-min(-)\n- End up precalculating the specifics of a function, \n- Get a sum that you can easily modify \n- transform the sum into binominals of precalculated variabls, that make sense in the context.\n- - this is \"ultimate code golf\", as the best soluion depends on the functions context.\n- Modify underliing partial simple bisymmetries of the functions \"specifics\"\n- Bisymmetry turns out to be mostly about (mutually exclusive matrices of) Binimials.\n...\n- Using only fullRotation*N/24 , makes it more likely that terms cancel each other out.\n- if (symmetry) 2 symmetric subroutine-values tend to cancel factors out, \n- ... down to sign(a)*sign(a)=1.\n- Your function(s) turns into a \"family of bisymmetrical functions\" \n- ... that are more easily generalized or specialized.\n- ... that are more easily made work-save against undefineds like: \n- ... a=atan(0.,0.)*tan(acos(.0))*log2(0.)*pow(0,0)*a/0.\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}