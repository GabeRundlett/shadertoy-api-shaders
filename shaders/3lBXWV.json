{
    "Shader": {
        "info": {
            "date": "1567063746",
            "description": "Fast snakes that leap, tumble and collide with obstacles; watch for entanglement (each run is different, mouseable).",
            "flags": 32,
            "hasliked": 0,
            "id": "3lBXWV",
            "likes": 8,
            "name": "Leaping Snakes 2",
            "published": 3,
            "tags": [
                "fractal",
                "collision",
                "terrain",
                "dynamics",
                "physics"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 530
        },
        "renderpass": [
            {
                "code": "// \"Leaping Snakes 2\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Chains of balls (shown as flexible tubes) linked by springs, with\n  torques that reduce bending; balls roll across the fractal landscape\n  subject to obstacles, gravity and friction, and the ball at the\n  front of each chain is pulled forward (each run is different,\n  mouseable).\n  If something goes wrong(!), simply restart.\n  Based on \"Leaping Snakes\", with added obstacles (from \"Jamming\n  Polymers\") and other tweaks.\n*/\n\nfloat PrCapsDf (vec3 p, float r, float h);\nmat3 DirToRMatT (vec3 vd, vec3 vu);\nmat3 QtToRMat (vec4 q);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvec2 Rot2D (vec2 q, float a);\nfloat Minv3 (vec3 p);\nfloat SmoothMax (float a, float b, float r);\nvec3 HsvToRgb (vec3 c);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\nconst int nChain = 6, lenChain = 40, nBall = nChain * lenChain;\nvec3 vnObj, sunDir, obsPos;\nvec2 gId;\nfloat tCur, dstFar, hgSize, obsRad, obsGap;\nint idBall, idChain;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\n#define TUBE  1    // = 0/1, show polymer balls/tubes\n\nfloat GrndHt (vec2 p)\n{\n  p *= 0.023;\n  return 16. * Fbm2 (p) + 2. * SmoothMax (Fbm2 (8. * Rot2D (p, 0.25 * pi)) - 0.5, 0., 0.1);\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 120; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, 0.5 * h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy), GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\n#if TUBE\n\nfloat CapsHit (vec3 ro, vec3 rd, float rad, float len)\n{\n  vec3 s;\n  float dMin, d, a, b, w;\n  dMin = dstFar;\n  a = dot (rd.xy, rd.xy);\n  b = dot (rd.xy, ro.xy);\n  w = b * b - a * (dot (ro.xy, ro.xy) - rad * rad);\n  if (w > 0. && a > 0.) {\n    d = - b - sqrt (w);\n    d /= a;\n    s = ro + d * rd;\n    if (d > 0. && abs (s.z) < len) {\n      dMin = d;\n      vnObj = vec3 (s.xy, 0.);\n    } else {\n      ro.z -= len * sign (s.z);\n      b = dot (rd, ro);\n      w = b * b - (dot (ro, ro) - rad * rad);\n      if (w > 0.) {\n        d = - b - sqrt (w);\n        if (d > 0.) {\n          dMin = d;\n          vnObj = ro + d * rd;\n        }\n      }\n    }\n  }\n  return dMin;\n}\n\nfloat PolyHit (vec3 ro, vec3 rd)\n{\n  mat3 rMat, rMatS;\n  vec3 r, rp, vnObjS;\n  float dMin, d, sz;\n  sz = 0.45;\n  dMin = dstFar;\n  idChain = -1;\n  for (int n = 0; n < nBall; n ++) {\n    if (mod (float (n), float (lenChain)) == 0.) r = Loadv4 (4 * n).xyz;\n    else {\n      rp = r;\n      r = Loadv4 (4 * n).xyz;\n      rMat = DirToRMatT (normalize (r - rp), vec3 (0., 0., 1.));\n      d = CapsHit ((ro - 0.5 * (r + rp)) * rMat, rd * rMat, sz, 0.5 * length (r - rp));\n      if (d < dMin) {\n        dMin = d;\n        rMatS = rMat;\n        vnObjS = vnObj;\n        idChain = n / lenChain;\n        idBall = n;\n      }\n    }\n  }\n  if (idChain >= 0) vnObj = rMatS * normalize (vnObjS);\n  return dMin;\n}\n\nfloat LineDist (vec2 q, vec2 u)\n{\n  float s;\n  s = length (u);\n  u /= s;\n  return length (q - clamp (dot (q, u), 0., s) * u);\n}\n\nfloat PolyLineDist (vec2 p)\n{\n  vec3 r, rp;\n  float dMin, d;\n  dMin = dstFar;\n  for (int n = 0; n < nBall; n ++) {\n    if (mod (float (n), float (lenChain)) == 0.) r = Loadv4 (4 * n).xyz;\n    else {\n      rp = r;\n      r = Loadv4 (4 * n).xyz;\n      d = LineDist (p - rp.xz, r.xz - rp.xz);\n      dMin = min (dMin, d);\n    }\n  }\n  return dMin;\n}\n\nfloat PolyHitSh (vec3 ro)\n{\n  return 0.7 + 0.3 * smoothstep (0.4, 0.6, PolyLineDist (ro.xz));\n}\n\n#else\n\nfloat BallHit (vec3 ro, vec3 rd)\n{\n  vec4 p;\n  vec3 u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = 0; n < nBall; n ++) {\n    p = Loadv4 (4 * n);\n    u = ro - p.xyz;\n    rad = 0.45 * p.w;\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w >= 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) {\n        dMin = d;\n        vnObj = (u + d * rd) / rad;\n        idBall = n;\n      }\n    }\n  }\n  return dMin;\n}\n\nfloat BallHitSh (vec3 ro, vec3 rd, float rng)\n{\n  vec4 p;\n  vec3 rs, u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = 0; n < nBall; n ++) {\n    p = Loadv4 (4 * n);\n    u = ro - p.xyz;\n    rad = 0.45 * p.w;\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w >= 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) dMin = d;\n    }\n  }\n  return smoothstep (0., rng, dMin);\n}\n\nfloat BallChqr (int idBall, vec3 vnBall)\n{\n  vec3 u;\n  vec2 a;\n  u = vnBall * QtToRMat (Loadv4 (4 * idBall + 2));\n  a = mod (floor (8. * vec2 (atan (u.x, u.y), asin (u.z)) / pi), 2.) - 0.5;\n  return 0.5 + 0.5 * step (0., sign (a.x) * sign (a.y));\n}\n\n#endif\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  rd.y = abs (rd.y);\n  ro.xz += 2. * tCur;\n  col = vec3 (0., 0.1, 0.3) + 0.1 * (1. - max (rd.y, 0.)) +\n     0.1 * pow (max (dot (rd, sunDir), 0.), 16.);\n  col = mix (col, vec3 (0.7), clamp (0.2 + Fbm2 (0.01 *\n     (ro.xz + rd.xz * (100. - ro.y) / max (rd.y, 0.001))) * rd.y, 0., 1.));\n  return col;\n}\n\nfloat ObjDf (vec3 p)\n{\n  return PrCapsDf ((p - obsPos).xzy, obsRad - 0.05, 2.);\n}\n\nvoid SetGrObjConf ()\n{\n  vec2 s;\n  s = HexToPix (gId * hgSize);\n  obsPos = vec3 (s, GrndHt (s)).xzy;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd, float dstLim)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  eps = 0.001;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  gIdP = vec2 (-99.);\n  dHit = 0.;\n  for (int j = 0; j < 80; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = Minv3 (hv);\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetGrObjConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < eps || dHit > dstLim) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  gIdP = vec2 (-99.);\n  for (int j = 0; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetGrObjConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, bgCol;\n  float dstObj, dstObjC, dstGrnd, sh, ao, f, c;\n  bgCol = BgCol (ro, rd);\n  dstGrnd = GrndRay (ro, rd);\n#if TUBE\n  dstObj = PolyHit (ro, rd);\n#else\n  dstObj = BallHit (ro, rd);\n#endif\n  dstObjC = ObjRay (ro, rd, min (dstGrnd, dstFar));\n  sh = 1.;\n  ao = 1.;\n  if (min (min (dstObj, dstObjC), dstGrnd) < dstFar) {\n    if (min (dstObj, dstObjC) < dstGrnd) {\n      if (dstObj < dstObjC) {\n        ro += dstObj * rd;\n        vn = vnObj;\n#if TUBE\n        c = float (idChain) / float (nChain);\n        if (mod (float (idBall), float (lenChain)) < 2.) c = mod (c + 0.5, 1.);\n        col4 = vec4 (HsvToRgb (vec3 (c, 0.8, 0.8 + 0.2 * cos (6. * pi * float (idBall) /\n           float (lenChain)))), 0.2);\n#else\n        c = mod (float (idBall / lenChain) / float (nChain), 1.);\n        if (mod (float (idBall), float (lenChain)) == 0.) c = mod (c + 0.5, 1.);\n        col4 = vec4 (HsvToRgb (vec3 (c, 0.8, BallChqr (idBall, vnObj))), 0.2);\n#endif\n      } else {\n        dstObj = dstObjC;\n        ro += dstObj * rd;\n        vn = ObjNf (ro);\n        col4 = vec4 (vec3 (0.6, 0.6, 0.65) * (0.9 + 0.1 * sin (8. * pi * (ro.y - obsPos.y))), 0.1);\n      }\n    } else {\n      ro += dstGrnd * rd;\n      vn = GrndNf (ro);\n      f = 1. - clamp (0.5 * pow (vn.y, 4.) + Fbm2 (0.5 * ro.xz) - 0.5, 0., 1.);\n      vn = VaryNf (4. * ro, vn, 16. * f * f * (1. - smoothstep (0.2, 0.7, dstGrnd / dstFar)));\n      col4 = vec4 (mix (vec3 (0.6, 0.7, 0.2), vec3 (0.3, 0.4, 0.4), f) *\n         (1. - 0.2 * Noisefv2 (32. * ro.xz)), 0.05);\n      col4.rgb *= 0.9 + 0.4 * smoothstep (5., 8., ro.y);\n      gId = PixToHex (ro.xz / hgSize);\n      SetGrObjConf ();\n      ao = 0.5 + 0.5 * smoothstep (0., 0.2, length (ro.xz - obsPos.xz) - obsRad);\n    }\n#if TUBE\n    sh = min (sh, PolyHitSh (ro));\n#else\n    sh = min (sh, min (sh, 0.7 + 0.3 * BallHitSh (ro + 0.01 * sunDir, sunDir, 20.)));\n#endif\n    sh = min (min (sh, ObjSShadow (ro, sunDir)), ao);\n    col = col4.rgb * (0.2 + 0.1 * max (- dot (vn.xz, normalize (sunDir.xz)), 0.) + \n       0.1 * max (vn.y, 0.) + 0.8 * sh * max (dot (vn, sunDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    col = mix (col, bgCol, clamp (4. * min (dstObj, dstGrnd) / dstFar - 3., 0., 1.));\n  } else col = bgCol;\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, stDat;\n  vec3 col, rd, ro, vd, pVu;\n  vec2 canvas, uv;\n  float az, el;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  stDat = Loadv4 (4 * nBall + 1);\n  obsRad = stDat.x;\n  obsGap = stDat.y;\n  hgSize = obsGap;\n  az = 0.03 * pi * tCur;\n  el = pi * (0.1 + 0.1 * sin (0.021 * pi * tCur));\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  }\n  el = clamp (el, 0.03 * pi, 0.4 * pi);\n  pVu = 0.5 * (Loadv4 (4 * nBall).xyz + Loadv4 ((nChain / 2) * 4 * lenChain).xyz);\n  ro = pVu + 50. * vec3 (cos (el) * vec2 (cos (az), sin (az)), sin (el)).xzy;\n  ro.y = max (ro.y, GrndHt (ro.xz) + 10.);\n  vd = normalize (pVu - ro);\n  vuMat = mat3 (vec3 (vd.z, 0., - vd.x) / sqrt (1. - vd.y * vd.y),\n     vec3 (- vd.y * vd.x, 1. - vd.y * vd.y, - vd.y * vd.z) / sqrt (1. - vd.y * vd.y), vd);\n  rd = vuMat * normalize (vec3 (uv, 3.));\n  dstFar = 120.;\n  sunDir = normalize (vec3 (1., 2., -1.));\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\n#if TUBE\n\nmat3 DirToRMatT (vec3 vd, vec3 vu)\n{\n  vec3 vc;\n  vc = normalize (cross (vu, vd));\n  return mat3 (vc, cross (vd, vc), vd);\n}\n\n#else\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\n#endif\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 - 0.5 * (b - a) / r, 0., 1.);\n  return r * h * (1. - h) - mix (b, a, h);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Leaping Snakes 2\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RMatToQt (mat3 m);\nmat3 LpStepMat (vec3 a);\nfloat SmoothMax (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Fbm2 (vec2 p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nChain = 6, lenChain = 40, nBall = nChain * lenChain;\nvec3 rLead;\nfloat todCur, obsRad, obsGap;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\nconst float txRow = 128.;\n\nfloat GrndHt (vec2 p)\n{\n  p *= 0.023;\n  return 16. * Fbm2 (p) + 2. * SmoothMax (Fbm2 (8. * Rot2D (p, 0.25 * pi)) - 0.5, 0., 0.1);\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy), GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float sz)\n{\n  vec4 p;\n  vec3 rmN, rmN1, rmN2, vmN, wmN, dr, dr1, dr2, dv, drw, am, wam;\n  float fOvlap, fBend, fricN, fricT, fricS, fricSW, fDamp, fAttr, grav, rSep, szN, szAv,\n     fc, ft, ms, drv, dt, fnh, c11, c22, c12, cd, c;\n  int inChain, ic, k1, k2;\n  fOvlap = 1000.;\n  fBend = 5000.;\n  fricN = 10.;\n  fricS = 0.1;\n  fricSW = 1.;\n  fricT = 0.5;\n  fAttr = 5.;\n  fDamp = 0.1;\n  grav = 2.;\n  p = Loadv4 (4 * mId);\n  rm = p.xyz;\n  sz = p.w;\n  vm = Loadv4 (4 * mId + 1).xyz;\n  qm = Loadv4 (4 * mId + 2);\n  wm = Loadv4 (4 * mId + 3).xyz;\n  ms = sz * sz * sz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  inChain =  mId / lenChain;\n  for (int n = 0; n < nBall; n ++) {\n    p = Loadv4 (4 * n);\n    rmN = p.xyz;\n    szN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    szAv = 0.5 * (sz + szN);\n    if (n != mId && rSep < szAv) {\n      fc = fOvlap * (szAv / rSep - 1.);\n      vmN = Loadv4 (4 * n + 1).xyz;\n      wmN = Loadv4 (4 * n + 3).xyz;\n      dv = vm - vmN;\n      drv = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * drv, 0.);\n      am += fc * dr;\n      dv -= drv * dr + cross ((sz * wm + szN * wmN) / (sz + szN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n    if ((n == mId + 1 || n == mId - 1) && n / lenChain == inChain) am -= 20. * fAttr * dr;\n  }\n  ic = mId - inChain * lenChain;\n  for (int m = 0; m < 4; m ++) {\n    if (m == 0 && ic <= 1 || (m == 1 || m == 2) && (ic == 0 || ic == lenChain - 1) ||\n       m == 3 && ic >= lenChain - 2) continue;\n    k1 = mId;\n    k2 = mId;\n    if (m == 0) {\n      k1 -= 1;\n      k2 -= 2;\n    } else if (m == 1 || m == 2) {\n      k1 -= 1;\n      k2 += 1;\n    } else if (m == 3) {\n      k1 += 1;\n      k2 += 2;\n    }\n    rmN1 = Loadv4 (4 * k1).xyz;\n    rmN2 = Loadv4 (4 * k2).xyz;\n    if (m == 0) {\n      dr1 = rmN1 - rmN2;\n      dr2 = rm - rmN1;\n    } else if (m == 1 || m == 2) {\n      dr1 = rm - rmN1;\n      dr2 = rmN2 - rm;\n    } else if (m == 3) {\n      dr1 = rmN1 - rm;\n      dr2 = rmN2 - rmN1;\n    }\n    c11 = dot (dr1, dr1);\n    c12 = dot (dr1, dr2);\n    c22 = dot (dr2, dr2);\n    cd = sqrt (c11 * c22);\n    c = c12 / cd - 1.;\n    if (m == 0 || m == 3) c = - c;\n    am += fBend * (c / cd) * ((m <= 1) ? dr1 - (c12 / c22) * dr2 : (c12 / c11) * dr1 - dr2);\n  }  \n  szAv = 0.5 * (sz + 1.);\n  dr.xz = -0.5 * GrndNf (rm).xz;\n  dr.y = rm.y + 0.5 - GrndHt (rm.xz - dr.xz);\n  rSep = length (dr);\n  if (rSep < szAv) {\n    fc = fOvlap * (szAv / rSep - 1.);\n    dv = vm;\n    drv = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * drv, 0.);\n    am += fc * dr;\n    dv -= drv * dr + sz * cross (wm, dr);\n    ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  dr.xz = rm.xz - HexToPix (PixToHex (rm.xz / obsGap) * obsGap);\n  dr.y = 0.;\n  rSep = length (dr);\n  if (rSep < obsRad + 0.5) {\n    dr.xz /= rSep;\n    am.xz += (0.5 * fOvlap * (obsRad + 0.5 - rSep) - fricN * dot (vm.xz, dr.xz)) * dr.xz;\n  }\n  if (ic == 0) am += fAttr * (rLead - rm);\n  am.y -= grav * ms;\n  am -= fDamp * vec3 (1., 5., 1.) * vm;\n  dt = 0.01;\n  vm += dt * am / ms;\n  rm += dt * vm;\n  wm += dt * wam / (0.1 * ms * sz);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float sz)\n{\n  float s;\n  s = float (mId / lenChain);\n  rm.xz = vec2 (0.9 * (float (mId) - s * float (lenChain)) + 256. * Hashff (todCur),\n     1.5 * obsGap * (s - 0.5 * float (nChain) + 0.5));\n  rm.y = GrndHt (rm.xz) + 1.;\n  vm = vec3 (0., -0.1, 0.);\n  qm = vec4 (0., 0., 0., 1.);\n  wm = vec3 (0.);\n  sz = 1.;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, qm;\n  vec3 rm, vm, wm, rLeadS;\n  vec2 iFrag;\n  float sz, nStep;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 2) discard;\n  todCur = iDate.w;\n  if (iFrame <= 5) {\n    doInit = true;\n  } else {\n    doInit = false;\n    stDat = Loadv4 (4 * nBall);\n    nStep = stDat.w;\n    if (nStep >= 200000.) doInit = true;\n  }\n  if (doInit) {\n    nStep = 0.;\n    obsRad = 1.;\n    obsGap = 6.;\n    if (pxId == 4 * nBall) rLeadS = vec3 (256. * Hashff (todCur), 2., 0.);\n  } else {\n    ++ nStep;\n    rLeadS = stDat.xyz;\n    rLeadS.x -= 0.04;\n    stDat = Loadv4 (4 * nBall + 1);\n    obsRad = stDat.x;\n    obsGap = stDat.y;\n  }\n  if (pxId < 4 * nBall) {\n    mId = pxId / 4;\n    if (doInit) {\n      Init (mId, rm, vm, qm, wm, sz);\n    } else {\n      rLead = rLeadS;\n      rLead.z += 1.5 * obsGap * (0.6 + 0.4 * cos (0.00015 * 2. * pi * nStep)) *\n         (float (mId / lenChain) - 0.5 * float (nChain) + 0.5) +\n         0.5 * obsGap * sin (0.0002 * 2. * pi * nStep);\n      rLead.y += GrndHt (rLead.xz);\n      Step (mId, rm, vm, qm, wm, sz);\n    }\n  }\n  if (pxId < 4 * nBall) {\n    kp = 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, sz);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n   } else {\n    kp = 4 * nBall;\n    if      (pxId == kp + 0) stDat = vec4 (rLeadS, nStep);\n    else if (pxId == kp + 1) stDat = vec4 (obsRad, obsGap, 0., 0.);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 - 0.5 * (b - a) / r, 0., 1.);\n  return r * h * (1. - h) - mix (b, a, h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"Leaping Snakes 2\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RMatToQt (mat3 m);\nmat3 LpStepMat (vec3 a);\nfloat SmoothMax (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Fbm2 (vec2 p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nChain = 6, lenChain = 40, nBall = nChain * lenChain;\nvec3 rLead;\nfloat todCur, obsRad, obsGap;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\nconst float txRow = 128.;\n\nfloat GrndHt (vec2 p)\n{\n  p *= 0.023;\n  return 16. * Fbm2 (p) + 2. * SmoothMax (Fbm2 (8. * Rot2D (p, 0.25 * pi)) - 0.5, 0., 0.1);\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy), GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float sz)\n{\n  vec4 p;\n  vec3 rmN, rmN1, rmN2, vmN, wmN, dr, dr1, dr2, dv, drw, am, wam;\n  float fOvlap, fBend, fricN, fricT, fricS, fricSW, fDamp, fAttr, grav, rSep, szN, szAv,\n     fc, ft, ms, drv, dt, fnh, c11, c22, c12, cd, c;\n  int inChain, ic, k1, k2;\n  fOvlap = 1000.;\n  fBend = 5000.;\n  fricN = 10.;\n  fricS = 0.1;\n  fricSW = 1.;\n  fricT = 0.5;\n  fAttr = 5.;\n  fDamp = 0.1;\n  grav = 2.;\n  p = Loadv4 (4 * mId);\n  rm = p.xyz;\n  sz = p.w;\n  vm = Loadv4 (4 * mId + 1).xyz;\n  qm = Loadv4 (4 * mId + 2);\n  wm = Loadv4 (4 * mId + 3).xyz;\n  ms = sz * sz * sz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  inChain =  mId / lenChain;\n  for (int n = 0; n < nBall; n ++) {\n    p = Loadv4 (4 * n);\n    rmN = p.xyz;\n    szN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    szAv = 0.5 * (sz + szN);\n    if (n != mId && rSep < szAv) {\n      fc = fOvlap * (szAv / rSep - 1.);\n      vmN = Loadv4 (4 * n + 1).xyz;\n      wmN = Loadv4 (4 * n + 3).xyz;\n      dv = vm - vmN;\n      drv = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * drv, 0.);\n      am += fc * dr;\n      dv -= drv * dr + cross ((sz * wm + szN * wmN) / (sz + szN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n    if ((n == mId + 1 || n == mId - 1) && n / lenChain == inChain) am -= 20. * fAttr * dr;\n  }\n  ic = mId - inChain * lenChain;\n  for (int m = 0; m < 4; m ++) {\n    if (m == 0 && ic <= 1 || (m == 1 || m == 2) && (ic == 0 || ic == lenChain - 1) ||\n       m == 3 && ic >= lenChain - 2) continue;\n    k1 = mId;\n    k2 = mId;\n    if (m == 0) {\n      k1 -= 1;\n      k2 -= 2;\n    } else if (m == 1 || m == 2) {\n      k1 -= 1;\n      k2 += 1;\n    } else if (m == 3) {\n      k1 += 1;\n      k2 += 2;\n    }\n    rmN1 = Loadv4 (4 * k1).xyz;\n    rmN2 = Loadv4 (4 * k2).xyz;\n    if (m == 0) {\n      dr1 = rmN1 - rmN2;\n      dr2 = rm - rmN1;\n    } else if (m == 1 || m == 2) {\n      dr1 = rm - rmN1;\n      dr2 = rmN2 - rm;\n    } else if (m == 3) {\n      dr1 = rmN1 - rm;\n      dr2 = rmN2 - rmN1;\n    }\n    c11 = dot (dr1, dr1);\n    c12 = dot (dr1, dr2);\n    c22 = dot (dr2, dr2);\n    cd = sqrt (c11 * c22);\n    c = c12 / cd - 1.;\n    if (m == 0 || m == 3) c = - c;\n    am += fBend * (c / cd) * ((m <= 1) ? dr1 - (c12 / c22) * dr2 : (c12 / c11) * dr1 - dr2);\n  }  \n  szAv = 0.5 * (sz + 1.);\n  dr.xz = -0.5 * GrndNf (rm).xz;\n  dr.y = rm.y + 0.5 - GrndHt (rm.xz - dr.xz);\n  rSep = length (dr);\n  if (rSep < szAv) {\n    fc = fOvlap * (szAv / rSep - 1.);\n    dv = vm;\n    drv = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * drv, 0.);\n    am += fc * dr;\n    dv -= drv * dr + sz * cross (wm, dr);\n    ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  dr.xz = rm.xz - HexToPix (PixToHex (rm.xz / obsGap) * obsGap);\n  dr.y = 0.;\n  rSep = length (dr);\n  if (rSep < obsRad + 0.5) {\n    dr.xz /= rSep;\n    am.xz += (0.5 * fOvlap * (obsRad + 0.5 - rSep) - fricN * dot (vm.xz, dr.xz)) * dr.xz;\n  }\n  if (ic == 0) am += fAttr * (rLead - rm);\n  am.y -= grav * ms;\n  am -= fDamp * vec3 (1., 5., 1.) * vm;\n  dt = 0.01;\n  vm += dt * am / ms;\n  rm += dt * vm;\n  wm += dt * wam / (0.1 * ms * sz);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float sz)\n{\n  float s;\n  s = float (mId / lenChain);\n  rm.xz = vec2 (0.9 * (float (mId) - s * float (lenChain)) + 256. * Hashff (todCur),\n     1.5 * obsGap * (s - 0.5 * float (nChain) + 0.5));\n  rm.y = GrndHt (rm.xz) + 1.;\n  vm = vec3 (0., -0.1, 0.);\n  qm = vec4 (0., 0., 0., 1.);\n  wm = vec3 (0.);\n  sz = 1.;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, qm;\n  vec3 rm, vm, wm, rLeadS;\n  vec2 iFrag;\n  float sz, nStep;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 2) discard;\n  todCur = iDate.w;\n  if (iFrame <= 5) {\n    doInit = true;\n  } else {\n    doInit = false;\n    stDat = Loadv4 (4 * nBall);\n    nStep = stDat.w;\n    if (nStep >= 200000.) doInit = true;\n  }\n  if (doInit) {\n    nStep = 0.;\n    obsRad = 1.;\n    obsGap = 6.;\n    if (pxId == 4 * nBall) rLeadS = vec3 (256. * Hashff (todCur), 2., 0.);\n  } else {\n    ++ nStep;\n    rLeadS = stDat.xyz;\n    rLeadS.x -= 0.04;\n    stDat = Loadv4 (4 * nBall + 1);\n    obsRad = stDat.x;\n    obsGap = stDat.y;\n  }\n  if (pxId < 4 * nBall) {\n    mId = pxId / 4;\n    if (doInit) {\n      Init (mId, rm, vm, qm, wm, sz);\n    } else {\n      rLead = rLeadS;\n      rLead.z += 1.5 * obsGap * (0.6 + 0.4 * cos (0.00015 * 2. * pi * nStep)) *\n         (float (mId / lenChain) - 0.5 * float (nChain) + 0.5) +\n         0.5 * obsGap * sin (0.0002 * 2. * pi * nStep);\n      rLead.y += GrndHt (rLead.xz);\n      Step (mId, rm, vm, qm, wm, sz);\n    }\n  }\n  if (pxId < 4 * nBall) {\n    kp = 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, sz);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n   } else {\n    kp = 4 * nBall;\n    if      (pxId == kp + 0) stDat = vec4 (rLeadS, nStep);\n    else if (pxId == kp + 1) stDat = vec4 (obsRad, obsGap, 0., 0.);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 - 0.5 * (b - a) / r, 0., 1.);\n  return r * h * (1. - h) - mix (b, a, h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"Leaping Snakes 2\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RMatToQt (mat3 m);\nmat3 LpStepMat (vec3 a);\nfloat SmoothMax (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Fbm2 (vec2 p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nChain = 6, lenChain = 40, nBall = nChain * lenChain;\nvec3 rLead;\nfloat todCur, obsRad, obsGap;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\nconst float txRow = 128.;\n\nfloat GrndHt (vec2 p)\n{\n  p *= 0.023;\n  return 16. * Fbm2 (p) + 2. * SmoothMax (Fbm2 (8. * Rot2D (p, 0.25 * pi)) - 0.5, 0., 0.1);\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy), GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float sz)\n{\n  vec4 p;\n  vec3 rmN, rmN1, rmN2, vmN, wmN, dr, dr1, dr2, dv, drw, am, wam;\n  float fOvlap, fBend, fricN, fricT, fricS, fricSW, fDamp, fAttr, grav, rSep, szN, szAv,\n     fc, ft, ms, drv, dt, fnh, c11, c22, c12, cd, c;\n  int inChain, ic, k1, k2;\n  fOvlap = 1000.;\n  fBend = 5000.;\n  fricN = 10.;\n  fricS = 0.1;\n  fricSW = 1.;\n  fricT = 0.5;\n  fAttr = 5.;\n  fDamp = 0.1;\n  grav = 2.;\n  p = Loadv4 (4 * mId);\n  rm = p.xyz;\n  sz = p.w;\n  vm = Loadv4 (4 * mId + 1).xyz;\n  qm = Loadv4 (4 * mId + 2);\n  wm = Loadv4 (4 * mId + 3).xyz;\n  ms = sz * sz * sz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  inChain =  mId / lenChain;\n  for (int n = 0; n < nBall; n ++) {\n    p = Loadv4 (4 * n);\n    rmN = p.xyz;\n    szN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    szAv = 0.5 * (sz + szN);\n    if (n != mId && rSep < szAv) {\n      fc = fOvlap * (szAv / rSep - 1.);\n      vmN = Loadv4 (4 * n + 1).xyz;\n      wmN = Loadv4 (4 * n + 3).xyz;\n      dv = vm - vmN;\n      drv = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * drv, 0.);\n      am += fc * dr;\n      dv -= drv * dr + cross ((sz * wm + szN * wmN) / (sz + szN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n    if ((n == mId + 1 || n == mId - 1) && n / lenChain == inChain) am -= 20. * fAttr * dr;\n  }\n  ic = mId - inChain * lenChain;\n  for (int m = 0; m < 4; m ++) {\n    if (m == 0 && ic <= 1 || (m == 1 || m == 2) && (ic == 0 || ic == lenChain - 1) ||\n       m == 3 && ic >= lenChain - 2) continue;\n    k1 = mId;\n    k2 = mId;\n    if (m == 0) {\n      k1 -= 1;\n      k2 -= 2;\n    } else if (m == 1 || m == 2) {\n      k1 -= 1;\n      k2 += 1;\n    } else if (m == 3) {\n      k1 += 1;\n      k2 += 2;\n    }\n    rmN1 = Loadv4 (4 * k1).xyz;\n    rmN2 = Loadv4 (4 * k2).xyz;\n    if (m == 0) {\n      dr1 = rmN1 - rmN2;\n      dr2 = rm - rmN1;\n    } else if (m == 1 || m == 2) {\n      dr1 = rm - rmN1;\n      dr2 = rmN2 - rm;\n    } else if (m == 3) {\n      dr1 = rmN1 - rm;\n      dr2 = rmN2 - rmN1;\n    }\n    c11 = dot (dr1, dr1);\n    c12 = dot (dr1, dr2);\n    c22 = dot (dr2, dr2);\n    cd = sqrt (c11 * c22);\n    c = c12 / cd - 1.;\n    if (m == 0 || m == 3) c = - c;\n    am += fBend * (c / cd) * ((m <= 1) ? dr1 - (c12 / c22) * dr2 : (c12 / c11) * dr1 - dr2);\n  }  \n  szAv = 0.5 * (sz + 1.);\n  dr.xz = -0.5 * GrndNf (rm).xz;\n  dr.y = rm.y + 0.5 - GrndHt (rm.xz - dr.xz);\n  rSep = length (dr);\n  if (rSep < szAv) {\n    fc = fOvlap * (szAv / rSep - 1.);\n    dv = vm;\n    drv = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * drv, 0.);\n    am += fc * dr;\n    dv -= drv * dr + sz * cross (wm, dr);\n    ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  dr.xz = rm.xz - HexToPix (PixToHex (rm.xz / obsGap) * obsGap);\n  dr.y = 0.;\n  rSep = length (dr);\n  if (rSep < obsRad + 0.5) {\n    dr.xz /= rSep;\n    am.xz += (0.5 * fOvlap * (obsRad + 0.5 - rSep) - fricN * dot (vm.xz, dr.xz)) * dr.xz;\n  }\n  if (ic == 0) am += fAttr * (rLead - rm);\n  am.y -= grav * ms;\n  am -= fDamp * vec3 (1., 5., 1.) * vm;\n  dt = 0.01;\n  vm += dt * am / ms;\n  rm += dt * vm;\n  wm += dt * wam / (0.1 * ms * sz);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float sz)\n{\n  float s;\n  s = float (mId / lenChain);\n  rm.xz = vec2 (0.9 * (float (mId) - s * float (lenChain)) + 256. * Hashff (todCur),\n     1.5 * obsGap * (s - 0.5 * float (nChain) + 0.5));\n  rm.y = GrndHt (rm.xz) + 1.;\n  vm = vec3 (0., -0.1, 0.);\n  qm = vec4 (0., 0., 0., 1.);\n  wm = vec3 (0.);\n  sz = 1.;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, qm;\n  vec3 rm, vm, wm, rLeadS;\n  vec2 iFrag;\n  float sz, nStep;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 2) discard;\n  todCur = iDate.w;\n  if (iFrame <= 5) {\n    doInit = true;\n  } else {\n    doInit = false;\n    stDat = Loadv4 (4 * nBall);\n    nStep = stDat.w;\n    if (nStep >= 200000.) doInit = true;\n  }\n  if (doInit) {\n    nStep = 0.;\n    obsRad = 1.;\n    obsGap = 6.;\n    if (pxId == 4 * nBall) rLeadS = vec3 (256. * Hashff (todCur), 2., 0.);\n  } else {\n    ++ nStep;\n    rLeadS = stDat.xyz;\n    rLeadS.x -= 0.04;\n    stDat = Loadv4 (4 * nBall + 1);\n    obsRad = stDat.x;\n    obsGap = stDat.y;\n  }\n  if (pxId < 4 * nBall) {\n    mId = pxId / 4;\n    if (doInit) {\n      Init (mId, rm, vm, qm, wm, sz);\n    } else {\n      rLead = rLeadS;\n      rLead.z += 1.5 * obsGap * (0.6 + 0.4 * cos (0.00015 * 2. * pi * nStep)) *\n         (float (mId / lenChain) - 0.5 * float (nChain) + 0.5) +\n         0.5 * obsGap * sin (0.0002 * 2. * pi * nStep);\n      rLead.y += GrndHt (rLead.xz);\n      Step (mId, rm, vm, qm, wm, sz);\n    }\n  }\n  if (pxId < 4 * nBall) {\n    kp = 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, sz);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n   } else {\n    kp = 4 * nBall;\n    if      (pxId == kp + 0) stDat = vec4 (rLeadS, nStep);\n    else if (pxId == kp + 1) stDat = vec4 (obsRad, obsGap, 0., 0.);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 - 0.5 * (b - a) / r, 0., 1.);\n  return r * h * (1. - h) - mix (b, a, h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"Leaping Snakes 2\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RMatToQt (mat3 m);\nmat3 LpStepMat (vec3 a);\nfloat SmoothMax (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Fbm2 (vec2 p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nChain = 6, lenChain = 40, nBall = nChain * lenChain;\nvec3 rLead;\nfloat todCur, obsRad, obsGap;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\nconst float txRow = 128.;\n\nfloat GrndHt (vec2 p)\n{\n  p *= 0.023;\n  return 16. * Fbm2 (p) + 2. * SmoothMax (Fbm2 (8. * Rot2D (p, 0.25 * pi)) - 0.5, 0., 0.1);\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy), GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float sz)\n{\n  vec4 p;\n  vec3 rmN, rmN1, rmN2, vmN, wmN, dr, dr1, dr2, dv, drw, am, wam;\n  float fOvlap, fBend, fricN, fricT, fricS, fricSW, fDamp, fAttr, grav, rSep, szN, szAv,\n     fc, ft, ms, drv, dt, fnh, c11, c22, c12, cd, c;\n  int inChain, ic, k1, k2;\n  fOvlap = 1000.;\n  fBend = 5000.;\n  fricN = 10.;\n  fricS = 0.1;\n  fricSW = 1.;\n  fricT = 0.5;\n  fAttr = 5.;\n  fDamp = 0.1;\n  grav = 2.;\n  p = Loadv4 (4 * mId);\n  rm = p.xyz;\n  sz = p.w;\n  vm = Loadv4 (4 * mId + 1).xyz;\n  qm = Loadv4 (4 * mId + 2);\n  wm = Loadv4 (4 * mId + 3).xyz;\n  ms = sz * sz * sz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  inChain =  mId / lenChain;\n  for (int n = 0; n < nBall; n ++) {\n    p = Loadv4 (4 * n);\n    rmN = p.xyz;\n    szN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    szAv = 0.5 * (sz + szN);\n    if (n != mId && rSep < szAv) {\n      fc = fOvlap * (szAv / rSep - 1.);\n      vmN = Loadv4 (4 * n + 1).xyz;\n      wmN = Loadv4 (4 * n + 3).xyz;\n      dv = vm - vmN;\n      drv = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * drv, 0.);\n      am += fc * dr;\n      dv -= drv * dr + cross ((sz * wm + szN * wmN) / (sz + szN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n    if ((n == mId + 1 || n == mId - 1) && n / lenChain == inChain) am -= 20. * fAttr * dr;\n  }\n  ic = mId - inChain * lenChain;\n  for (int m = 0; m < 4; m ++) {\n    if (m == 0 && ic <= 1 || (m == 1 || m == 2) && (ic == 0 || ic == lenChain - 1) ||\n       m == 3 && ic >= lenChain - 2) continue;\n    k1 = mId;\n    k2 = mId;\n    if (m == 0) {\n      k1 -= 1;\n      k2 -= 2;\n    } else if (m == 1 || m == 2) {\n      k1 -= 1;\n      k2 += 1;\n    } else if (m == 3) {\n      k1 += 1;\n      k2 += 2;\n    }\n    rmN1 = Loadv4 (4 * k1).xyz;\n    rmN2 = Loadv4 (4 * k2).xyz;\n    if (m == 0) {\n      dr1 = rmN1 - rmN2;\n      dr2 = rm - rmN1;\n    } else if (m == 1 || m == 2) {\n      dr1 = rm - rmN1;\n      dr2 = rmN2 - rm;\n    } else if (m == 3) {\n      dr1 = rmN1 - rm;\n      dr2 = rmN2 - rmN1;\n    }\n    c11 = dot (dr1, dr1);\n    c12 = dot (dr1, dr2);\n    c22 = dot (dr2, dr2);\n    cd = sqrt (c11 * c22);\n    c = c12 / cd - 1.;\n    if (m == 0 || m == 3) c = - c;\n    am += fBend * (c / cd) * ((m <= 1) ? dr1 - (c12 / c22) * dr2 : (c12 / c11) * dr1 - dr2);\n  }  \n  szAv = 0.5 * (sz + 1.);\n  dr.xz = -0.5 * GrndNf (rm).xz;\n  dr.y = rm.y + 0.5 - GrndHt (rm.xz - dr.xz);\n  rSep = length (dr);\n  if (rSep < szAv) {\n    fc = fOvlap * (szAv / rSep - 1.);\n    dv = vm;\n    drv = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * drv, 0.);\n    am += fc * dr;\n    dv -= drv * dr + sz * cross (wm, dr);\n    ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  dr.xz = rm.xz - HexToPix (PixToHex (rm.xz / obsGap) * obsGap);\n  dr.y = 0.;\n  rSep = length (dr);\n  if (rSep < obsRad + 0.5) {\n    dr.xz /= rSep;\n    am.xz += (0.5 * fOvlap * (obsRad + 0.5 - rSep) - fricN * dot (vm.xz, dr.xz)) * dr.xz;\n  }\n  if (ic == 0) am += fAttr * (rLead - rm);\n  am.y -= grav * ms;\n  am -= fDamp * vec3 (1., 5., 1.) * vm;\n  dt = 0.01;\n  vm += dt * am / ms;\n  rm += dt * vm;\n  wm += dt * wam / (0.1 * ms * sz);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float sz)\n{\n  float s;\n  s = float (mId / lenChain);\n  rm.xz = vec2 (0.9 * (float (mId) - s * float (lenChain)) + 256. * Hashff (todCur),\n     1.5 * obsGap * (s - 0.5 * float (nChain) + 0.5));\n  rm.y = GrndHt (rm.xz) + 1.;\n  vm = vec3 (0., -0.1, 0.);\n  qm = vec4 (0., 0., 0., 1.);\n  wm = vec3 (0.);\n  sz = 1.;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, qm;\n  vec3 rm, vm, wm, rLeadS;\n  vec2 iFrag;\n  float sz, nStep;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 2) discard;\n  todCur = iDate.w;\n  if (iFrame <= 5) {\n    doInit = true;\n  } else {\n    doInit = false;\n    stDat = Loadv4 (4 * nBall);\n    nStep = stDat.w;\n    if (nStep >= 200000.) doInit = true;\n  }\n  if (doInit) {\n    nStep = 0.;\n    obsRad = 1.;\n    obsGap = 6.;\n    if (pxId == 4 * nBall) rLeadS = vec3 (256. * Hashff (todCur), 2., 0.);\n  } else {\n    ++ nStep;\n    rLeadS = stDat.xyz;\n    rLeadS.x -= 0.04;\n    stDat = Loadv4 (4 * nBall + 1);\n    obsRad = stDat.x;\n    obsGap = stDat.y;\n  }\n  if (pxId < 4 * nBall) {\n    mId = pxId / 4;\n    if (doInit) {\n      Init (mId, rm, vm, qm, wm, sz);\n    } else {\n      rLead = rLeadS;\n      rLead.z += 1.5 * obsGap * (0.6 + 0.4 * cos (0.00015 * 2. * pi * nStep)) *\n         (float (mId / lenChain) - 0.5 * float (nChain) + 0.5) +\n         0.5 * obsGap * sin (0.0002 * 2. * pi * nStep);\n      rLead.y += GrndHt (rLead.xz);\n      Step (mId, rm, vm, qm, wm, sz);\n    }\n  }\n  if (pxId < 4 * nBall) {\n    kp = 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, sz);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n   } else {\n    kp = 4 * nBall;\n    if      (pxId == kp + 0) stDat = vec4 (rLeadS, nStep);\n    else if (pxId == kp + 1) stDat = vec4 (obsRad, obsGap, 0., 0.);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 - 0.5 * (b - a) / r, 0., 1.);\n  return r * h * (1. - h) - mix (b, a, h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}