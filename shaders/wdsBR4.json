{
    "Shader": {
        "info": {
            "date": "1588000501",
            "description": "What's inside the magic mirror?",
            "flags": 64,
            "hasliked": 0,
            "id": "wdsBR4",
            "likes": 9,
            "name": "The magic mirror",
            "published": 3,
            "tags": [
                "raymarching",
                "metaballs",
                "mirror",
                "mondrian"
            ],
            "usePreview": 0,
            "username": "friol",
            "viewed": 401
        },
        "renderpass": [
            {
                "code": "\n//\n// friol 2o2o\n// music KV by Bloc https://soundcloud.com/kvmusicprod/bloc\n// (watch this with music, please. be sure music is in sync)\n// sdf functions by iq\n// blob taken from mercury and modified\n// da rest is by P.Mondrian\n// 06.05.2020: reduced compilation time as for suggestions by iq\n//\n\nconst int iterationAmount=256;\nconst float patternLength=14.5;\nconst float numPatterns=4.0;\n\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nvec3 rotx(in vec3 p, float a) \n{\n\treturn vec3(p.x,\n                cos(a) * p.y + sin(a) * p.z,\n                cos(a) * p.z - sin(a) * p.y);\n}\n\nvec3 roty(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.z,\n                p.y,\n                cos(a) * p.z - sin(a) * p.x);\n}\n\nvec3 rotz(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.y,\n                cos(a) * p.y - sin(a) * p.x,\n                p.z);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat fBlob(vec3 p) \n{\n    float fft = texture( iChannel0, vec2(0.0,0.0) ).x;\n    p*=(1.5+(fft*0.4));\n    p=roty(p,iTime);\n    p=rotx(p,iTime);\n\n    float PHI=(sqrt(5.0)*0.5 + 0.5);\n\tp = abs(p);\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tif (p.x < min(p.y, p.z)) p = p.yzx;\n\tfloat b = max(max(min(\n\t\tdot(p, normalize(vec3(.3, 1., 1.))),\n\t\tdot(p.xz, normalize(vec2(PHI+1., 1.)))),\n\t\tdot(p.yx, normalize(vec2(1, PHI)))),\n\t\tdot(p.xz, normalize(vec2(1, PHI))));\n\tfloat l = length(p)/(1.0+.01*abs(sin(iTime)));\n\treturn l - 1.5 - 0.2 * (1.5 / 2.0)* .4*sin(min(sqrt(1.01 - b / l)*(3.141592 / 0.25), 3.141592));\n}\n\nvec2 SDF(vec3 r)\n{\n    vec3 rOrig=r;\n    float mat=0.0;\n\n    float plane0=sdPlane(r\t\t\t\t\t,vec4(0.0,1.0,0.0,1.0));\n    float plane1=sdPlane(r-vec3(0.0,0.1,0.0),vec4(0.0,-1.0,0.0,1.0));\n    \n    float domainRep=10.0;\n    vec3 c=vec3(domainRep);\n    r = mod(r+0.5*c,c)-0.5*c;\n    \n    float b0=sdBox(r,vec3(1.0,1.1,1.0));\n    float b1=sdBox(r,vec3(2.0,.9,.8));\n    float b2=sdBox(r-vec3(0.0,0.,0.0),vec3(0.8,0.9,2.0));\n    \n    float b3=sdBox(r-vec3(0.0,-0.9,-0.9),vec3(10.0,0.1,0.1));\n    float b4=sdBox(r-vec3(0.9,-0.9,0.0),vec3(0.1,0.1,10.0));\n    float b5=sdBox(r-vec3(-0.9,-0.9,0.0),vec3(0.1,0.1,10.0));\n    float b6=sdBox(r-vec3(0.0,-0.9,0.9),vec3(10.0,0.1,0.1));\n    float t1=opSubtraction(b1,b0);\n    float t0=opSubtraction(b2,t1);\n    t0=min(t0,b3);\n    t0=min(t0,b4);\n    t0=min(t0,b5);\n    t0=min(t0,b6);\n    \n    float s0=sdSphere(r-vec3(.6*sin(iTime),0.2*cos(iTime),.5*sin(iTime)),0.3);\n    float s1=sdSphere(r-vec3(.5*cos(iTime),-0.2*sin(iTime),0.0),0.2);\n    float s2=sdSphere(r-vec3(.7*cos(iTime),-0.5*cos(iTime),-.2*sin(iTime)),0.2);\n    \n    //vec2 uv = ((normal.xy + 1.0) * 0.5)*4.0;\n\t//float h = texture(iChannel0, uv).x/32.0;  \n\n    float h0=0.,h1=0.,h2=0.;\n    float unionCoeff=0.2;\n    float spheres=opSmoothUnion(opSmoothUnion(s0-h0,s1-h1,unionCoeff),s2-h2,unionCoeff);\n    \n    float pyr0=sdOctahedron((((r)-vec3(2.0,-2.0,0.0))),1.5);\n    float pyr1=sdOctahedron((((r)-vec3(-2.0,-2.0,0.0))),1.5);\n\n    float roamingSphere;\n    float sphTime=iTime*(patternLength/10.615);\n    \n    float modTime=mod(iTime,patternLength*numPatterns);    \n    if (modTime<patternLength)\n    {\n    \troamingSphere=sdSphere(r-vec3(0.0,-10.6,1.5+abs(5.0*sin(sphTime))),0.4);\n    }\n    else\n    {\n    \troamingSphere=sdSphere(r-vec3(0.0,-.6,1.5+abs(5.0*sin(sphTime))),0.4);\n    }\n    \n    vec3 rr=rotz(r,3.141592/2.0);\n    float roamingSphere2=sdTorus(rr-vec3(-.5,0.0,-1.5-abs(5.0*cos(sphTime))),vec2(0.35,0.2));\n\n    float mirror=sdBox(r-vec3(0.0,0.0,5.0),vec3(.8,1.1,.1));\n\n    \n    float t=min(min(min(min(min(min(min(min(t0,plane0),plane1),spheres),pyr0),pyr1),roamingSphere),mirror),roamingSphere2);\n    if (t==plane0) mat=1.0;\n    if (t==plane1) mat=1.0;\n    if (t==spheres) mat=2.0;\n    if (t==pyr0) mat=3.0;\n    if (t==pyr1) mat=4.0;\n\tif (t==roamingSphere) mat=6.0;                                 \n\tif (t==roamingSphere2) mat=7.0;                                 \n    if (t==mirror) mat=5.0;\n\n    if (modTime>=patternLength*3.0)        \n    {\n        float centeredBlob=fBlob(rOrig-vec3(5.0,0.0,1.0+iTime));\n        if (centeredBlob<t)\n        {\n            return vec2(centeredBlob,8.0);\n        }\n    }\n    \n    return vec2(t,mat);   \n}\n\nvec3 calcNormal(vec3 pos)\n{\n    float c = SDF(pos)[0];\n    vec2 eps_zero = vec2(0.01, 0.0);\n    return normalize(vec3( SDF(pos + eps_zero.xyy)[0], SDF(pos + eps_zero.yxy)[0], SDF(pos + eps_zero.yyx)[0] ) - c);\n}\n\nvec2 castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    float t = 0.0;\n     \n    for (int i = 0; i < iterationAmount; i++)\n    {\n        vec2 res = SDF(rayOrigin + rayDir * t);\n        if (res[0] < (0.0001*t))\n        {\n            return vec2(t,res[1]);\n        }\n        t += res[0];\n    }\n     \n    return vec2(-1.0,-1.0);\n}\n\nvec3 bounceRender(vec3 rayOrigin, vec3 rayDir, vec2 uv)\n{\n    vec3 col;\n    vec3 L=normalize(vec3(1.0,0.2,-2.0));\n\n    vec2 rayHit = castRay(rayOrigin, rayDir);\n    float t=rayHit[0];\n    \n    if (t!=-1.0)\n    {\n    \tvec3 pHit=rayOrigin + rayDir * t;\n        vec3 N=calcNormal(pHit);\n        float NoL = max(dot(N, L), 0.0);\n        float mat=rayHit[1];\n        if (mat==0.0)\n        {\n            col=vec3(NoL);\n        }\n        else if (mat==1.0) // plane\n        {\n            float lDist=distance(pHit,L+rayOrigin);\n        \tvec2 a = vec2(1.)*smoothstep(-0.05, 0.05, mod(pHit.x, 1.))*smoothstep(-0.05, 0.05, mod(pHit.z, 1.));\n        \tcol = vec3(1.0-a.x,1.0-a.y,1.0-a.x);\n            \n            //col+=vec3(pow(clamp(1.0-lDist/6.0,0.0,1.0),1.0));\n        }\n        \n        else if (mat==2.0) // spheres\n        {\n            NoL+=pow(NoL,32.0);\n            col+=vec3(.2,.3,.5)*vec3(NoL);\n        }\n        else if (mat==3.0)\n        {\n            NoL+=pow(NoL,32.0);\n            col+=vec3(1.0,0.0,0.0)*vec3(NoL);\n        }\n        else if (mat==4.0)\n        {\n            NoL+=pow(NoL,32.0);\n            col+=vec3(1.0,1.0,0.0)*vec3(NoL);\n        }\n\n        col/=distance(pHit-rayOrigin,vec3(0.))*.3;\n    }\n\n    col=pow(col,vec3(0.58));\n    return col;\n}\n\nvec4 render(vec3 rayOrigin, vec3 rayDir, vec2 uv)\n{\n    vec3 col=vec3(0.);\n    vec3 L=normalize(vec3(1.0,0.2,-2.0));\n\n    vec2 rayHit = castRay(rayOrigin, rayDir);\n    float t=rayHit[0];\n\n    if (t!=-1.0)\n    {\n    \tvec3 pHit=rayOrigin + rayDir * t;\n        float mat=rayHit[1];\n        vec3 N=calcNormal(rayOrigin + rayDir * t);\n        float NoL = max(dot(N, L), 0.0);\n      \n        if (mat==0.0)\n        {\n            col=vec3(NoL);\n        }\n        else if (mat==1.0) // plane\n        {\n            float lDist=distance(pHit,L+rayOrigin);\n        \tvec2 a = vec2(1.)*smoothstep(-0.05, 0.05, mod(pHit.x, 1.))*smoothstep(-0.05, 0.05, mod(pHit.z, 1.));\n        \tcol = vec3(1.0-a.x,1.0-a.y,1.0-a.x);\n            \n            col+=vec3(pow(clamp(1.0-lDist/6.0,0.0,1.0),2.2));\n        }\n        else if ((mat==2.0)||(mat==6.0)||(mat==7.0)) // meatballs/roaming spheres\n        {\n            float modTime=mod(iTime,30.0);    \n    \t\tif ((modTime<10.0)&&(mat==6.0))\n            {\n                return vec4(0.,0.,0.,0.);\n            }\n            \n            NoL=pow(NoL,32.0);\n            NoL=clamp(NoL,0.0,1.0);\n            vec3 colReflect=bounceRender(pHit,N,uv);\n            if (mat==2.0) col=vec3(1.0,1.0,1.0)*vec3(NoL);\n            else if (mat==7.0) col=vec3(1.,1.,1.)*vec3(NoL);\n            else col=vec3(.2,.2,.85)*vec3(NoL);\n            //col=vec3(0.5,0.5,0.5)*vec3(NoL);\n            col=mix(col,colReflect,0.2);\n        }\n        else if (mat==3.0) // pyr1\n        {\n            NoL+=pow(NoL,32.0);\n            col+=vec3(1.0,0.0,0.0)*vec3(NoL);\n        }\n        else if (mat==4.0) // pyr2\n        {\n            NoL+=pow(NoL,32.0);\n            col+=vec3(1.0,1.0,0.0)*vec3(NoL);\n        }\n        else if (mat==5.0) // magic mirror\n        {\n            vec3 N=vec3(0.0,0.0,-1.0);\n            vec3 colReflect=bounceRender(pHit,N,uv);\n            col=colReflect*0.5;\n        }\n        else if (mat==8.0) // mysterious blob\n        {\n            vec3 centerVec=vec3(5.0,0.0,1.0+iTime);\n            vec3 edgeVec=pHit-centerVec;\n            \n            edgeVec=normalize(edgeVec);\n            float edge=1.0-dot(edgeVec,vec3(0.,0.,-1.0));\n            edge=pow(edge,3.0);\n            \n            vec3 color1 = vec3(0.0,0.0,0.0);\n            vec3 color2 = vec3(0.726,0.726,0.726);\n            col = mix(color1,color2,edge);\n           \tcol+=edge*pow(distance(pHit,centerVec)*.4,2.0)*vec3(0.38,0.38,0.64);\n            //col=mix(col,color3,min(0.,edge-0.6)*2.0);\n        }\n\n    \tfloat modTime=mod(iTime,patternLength*numPatterns);    \n        if (modTime>=patternLength*3.0)        \n        {\n            if (mat!=8.0)\n            {\n                vec3 nrd=normalize(rayDir);\n                float fft = texture( iChannel0, vec2(0.0,0.0) ).x;\n                float myTime=iTime/8.0;\n                vec2 b=abs(fract(vec2(1.)*nrd.z+myTime)-.5)*abs(fract(vec2(1.)*nrd.z+myTime)-.5);\n                col+=vec3(\n                    (.01*pow(b.x+.8,20.)+b.y/dot(nrd.xy,nrd.xy)*exp(.24-1./4.))*fft,\n                    (.01*pow(b.x+.2,20.)+b.y/dot(nrd.xy,nrd.xy)*exp(.1-1./4.))*fft,\n                    (.01*pow(b.x+.1,20.)+b.y/dot(nrd.xy,nrd.xy)*exp(.32-1./2.))*fft)/3.0;\n            }\n        }\n        \n        col/=distance(pHit-rayOrigin,vec3(0.))*.6;\n    }\n\n    col=pow(col,vec3(0.58));\n    return vec4(col,1.0);\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 upz=vec3(0.,1.,0.);\n    vec3 camRight = normalize(cross(upz, camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n     \n    float fPersp = 2.0;\n    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n \n    return vDir;\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    vec2 result = 2.0 * (screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float myTime=iTime/8.0;\n\tvec2 uv = normalizeScreenCoords(fragCoord);\n\n    vec3 camPos,camTarget;\n\n    float modTime=mod(iTime,patternLength*numPatterns);\n    \n    if (modTime<patternLength) // magic mirror\n    {\n        modTime/=8.0;\n        camPos = vec3(0.0,0.,-3.0+7.5-modTime);\n        camTarget = vec3(.0, 0.,0.0+7.5-modTime);\n    }\n    else if ((modTime>=patternLength)&&(modTime<(patternLength*2.0))) // roaming camera\n    {\n        if (iTime>(patternLength*4.0))\n        {\n            camPos = vec3(cos(myTime)*4.0,0.,-3.0+iTime);\n            camTarget = vec3(.0, 0.,0.0+iTime);\n        }\n        else\n        {\n            camPos = vec3(sin(myTime)*4.0,0.,-3.0+iTime);\n            camTarget = vec3(.0, 0.,0.0+iTime);\n        }\n    }\n    else if ((modTime>=patternLength*2.0)&&(modTime<(patternLength*3.0))) // fisheye\n    {\n    \tuv*=(asin(length(uv)*0.75));\n        camPos = vec3(sin(myTime)*5.0,0.6*cos(myTime),-3.0+iTime);\n        camTarget = vec3(.0, 0.,0.0+iTime);\n    }\n    else // glowsphere\n    {\n        camPos = vec3(5.0,0.0,-3.0+iTime);\n        camTarget = vec3(5.0, 0.,0.0+iTime);\n    }\n\n    \n    \n    \n    vec3 rayDir = getCameraRayDir(uv, camPos, camTarget);   \n\n    float fft = texture( iChannel0, vec2(0.0,0.0) ).x;\n    \n    vec4 finalCol = vec4(render(camPos, rayDir,uv).xyz*(1.2+fft*2.0),1.0);\n\n    vec4 distCol=finalCol;\n    float pixx=mod(abs(uv.x*64.0),1.0);\n    if (pixx<0.33) distCol.x/=2.0;\n    if ((pixx>=0.33)&&(pixx<0.66)) distCol.y/=2.0;\n    if (pixx>0.66) distCol.z/=2.0;\n\n    if ((modTime>=patternLength*2.0)&&(modTime<(patternLength*3.0)))\n    {\n        float mult=4.0;\n        distCol+=sin(uv.x*mult)*cos(uv.y*mult);\n    }\n    \n   \tfinalCol=mix(distCol,finalCol,0.5);\n    \n    if (iTime>(patternLength*4.0))\n    {\n        vec3 value = finalCol.rgb;\n        vec3 oldcolor = value + (value * texture(iChannel1, (mod(fragCoord, 8.0) / 8.0)).rrr);\n        finalCol = vec4(floor(oldcolor),1.0);    \n    }\n  \n    fragColor=finalCol;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 22341,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/kvmusicprod/bloc"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}