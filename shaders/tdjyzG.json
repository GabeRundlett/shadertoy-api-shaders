{
    "Shader": {
        "info": {
            "date": "1586890251",
            "description": "potato",
            "flags": 8,
            "hasliked": 0,
            "id": "tdjyzG",
            "likes": 9,
            "name": "Day 117",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 457
        },
        "renderpass": [
            {
                "code": "#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define dmin(a,b) a.x < b.x ? a : b\n\n#define pmod(p,j) mod(p,j) - 0.5*j\n\n\nvec3 glow = vec3(0);\n\n\nfloat getF(vec2 j){\n    float d = 0.;\n    \n    j *= 0.5;\n    \n    \n    \n    j *= 8.;\n    \n    vec3 p = vec3(j,1.);\n    \n    \n\tp.xy = pmod(p.xy, 7.5);\n    \n    p /= dot(p.xy,p.xy);\n    \n    vec2 b = vec2(1.7,0.85 + smoothstep(0.,1.,j.y*0.1));\n    \n    \n    for(int i = 0; i < 4; i++){\n        p.xy = abs(p.xy);\n        p.xy *= rot(0.125*pi);\n        p.x -= 0.0;\n    \t\n        //p.xy *= rot(0.125*pi);\n        \n    }\n    \n    for(int i = 0; i < 4; i++){\n        \n        float dpp = dot(p.xy,p.xy);\n        \n        dpp = clamp(dpp, 0.4,1.5);\n        \n        p /= dpp;\n    \tp.xy = abs(mod(p.xy - 0.5*b,b)) - 0.5*b;\n    \t\n        \n        p.xy *= rot(0.5*pi);\n        \n    }\n\t//p.xy = pmod(p.xy, 1.5);\n    \n    \n    d = length(p.x)/p.z - 0.01;\n    \n    //d = max(d,0.);\n    \n    //d = pow(d*1.1, 1.);\n    return d;\n\n}\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e7);\n\t\n    //p.xy *= rot(p.z*0.2*smoothstep(0.,1.,(p.z - 7.)*0.1' + iTime*0.1);\n    \n    p.xy *= rot(sin(p.x*20. + p.z*4.)*0.0);\n    \n    float W = 0.5;\n\n    float dF = -p.y + W;\n    \n    dF = min(dF, p.y + W);\n    \n    d = dmin(d, vec2(dF,1.));\n    \n    \n    d -= getF(p.xz)*0.2;\n    \n    \n    \n    \n    d.x *= 0.2;\n    \n    \n    d = abs(d) + 0.002;\n    \n    glow += 0.003/(0.001 + d.x*d.x*200.);\n\t\n    vec3 bp = p + vec3(0,0,-iTime);\n    \n    float bd = length(bp) - 0.1;\n    d = min(d, bd);\n    \n    float env =smoothstep(0.,1.,(iTime)*0.1);\n    float gb = 0.003/max((0.5 - env*0.5 + bd*bd*(1. - env*0.994 ) + abs(sin(iTime*200.))*0.1*pow(env, 4.)), 0.);\n    \n        \n    glow += gb;\n    \n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd,inout vec3 p,inout float t,inout bool hit){\n\tvec2 d = vec2(10e6);\n\n    p = ro; hit = false; t = 0.;\n    for(int i = 0; i < 90; i++){\n    \td = map(p);\n        \n        if(d.x < 0.001){\n            hit = true;\n        \t//break;\n        }\n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n\treturn d;    \n}\n\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0),dir));\n\tvec3 up = normalize(cross(dir, right));\n    return normalize(dir + (right*uv.x - up*uv.y)*0.6);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\t\n    uv *= 1. - dot(uv,uv)*1.;\n    \n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0.00);\n    ro.z += iTime - 4.;\n    \n    //ro.x += iTime*0.5;\n    \n    vec3 lookAt = ro + vec3(-0.,-0.,1.);\n    //vec3 lookAt = ro + vec3(0.,0.5,1.);\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    vec3 p; float t; bool hit;\n\t\n    vec2 d = march(ro, rd, p, t, hit);\n    \n    \n    if(hit){\n    \n    \n    }\n\t    \n    \n    \n    col += glow*0.009;\n    \n    col.r *= 1.05 ;\n    \n    col *= 2.;\n    col = smoothstep(0.,1.,col);\n    col = smoothstep(0.,1.,col);\n    //col -= float(st);\n    col = max(col, 0.);\n    \n    col = pow(col, vec3(0.454545));\n    col = 1. - col;\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define T true\n#define F false\n\n#define init vec2 s = vec2(0)\n#define ret return s\n\n\n\n#define TT (tau*t)\n#define tt (tau*t)\n\n#define S vec2 s = vec2(0);\n#define E return s;\n\n#define OFFS (msr*1.)*0.\n\n\nconst float scale = -4.;\n\nfloat[] probK = float[16](0.9,0.1,0.1,0.2,0.,0.1,0.1,0.2,0.9,0.2,0.4,0.2,0.2,0.9,0.4,0.5);\nbool[] pattK = bool[16](F,F,F,T,F,T,T,F,T,F,F,T,F,T,T,F);\nbool[] pattL = bool[16](T,F,T,F,T,F,T,F,T,F,F,T,F,T,T,F);\nconst vec4 cmin9 = vec4(0.,3.,10.,14.) + scale;\n\nconst vec4 cmin510 = vec4(0.,7.,10.,12.) + scale;\nconst vec4 cmin7 = vec4(0.,3.,7.,10.) + scale;\nconst vec4 cmin73 = vec4(0.,7.,10.,3.) + scale;\nconst vec4 cmin11 = vec4(0.,10.,14.,17.) + scale;\nconst vec4 cmaj9 = vec4(0.,4.,7.,14.) + scale;\nconst vec4 cmaj7 = vec4(0.,4.,7.,11.) + scale;\nconst vec4 cmaj14 = vec4(0.,4.,11.,12. + 7.) + scale;\nconst vec4 cmaj7f15 = vec4(0.,4.,6.,11.) + scale;\nconst vec4 cmaj7d = vec4(0.,4.,7.,10.) + scale;\nconst vec4 cmin7maj = vec4(0.,3.,7.,11.) + scale;\n\nconst int chordCnt = 8;\n\n\n\n\nvec4[] chords = vec4[chordCnt](\n    cmin510,\n    cmin73 + 1.,\n    cmaj9 - 1.,\n    cmaj14 - 3.,\n    cmin11,\n    cmaj14 + 1. - 7.,\n    cmaj7 - 1.,\n    cmaj7 - 5.\n);\n\n\n\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\n\nfloat gT;\nfloat sc;\n\nfloat note(float note, float octave){ \n\treturn 27.5*exp2(((octave*12. ) + note )/12.);//pow(2., );\n}\n\n\n\nvec2 hash22(vec2 p)   \n{\n    p  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\nvec2 hash22a(vec2 p){\n    p *= 2000.;\n\treturn texture(iChannel0, vec2((p + 1./floor(p/256.)))/256.).xz;\n}\nvec2 noise(float t)\n{\n    return hash22(vec2(t, t * 1.423)) * 2.0 - 1.0;\n}\n\nvec2 lpnoise(float t, float fq)\n{\n    t *= fq;\n\n    float ft = fract(t);\n    float tn = t - ft;\n    ft = smoothstep(0.0, 1.0, ft);\n\n    vec2 n0 = noise(floor(tn + 0.0) / fq);\n    vec2 n1 = noise(floor(tn + 1.0) / fq);\n\n    return mix(n0, n1, ft);\n}\n\nvec2[8] N;\n\n\nvec2 leadb(float t){\n\tinit;\n\t\n    float to;\n    vec2 nn = N[0];\n    \n    \n    vec2 id;\n    float r = bar;\n    t = mod(t, r*float(chordCnt));\n    \n    id.x = floor(t/r);\n    \n    float att = float(pattL[int( mod(floor(t/(bar/(32./8.))), 8.) )]);\n    t = mod(t,bar);\n    float reps = 16./4.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \t\n\n    //sampleratereduction(t, (1.2*1./iSampleRate));\n    \n    float amt = 0.1;\n    float env = exp(-t*0.2);\n    \n    \n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    \n    float oct = 2.5;\n    s += sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    s += sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 + nn*amt)*env;\n    s -= sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    \n    \n    \n    //bitreduction(s, 0.7);\n    s *= 1. - att;\n    s = smoothify(s, 0.9);\n    s = smoothify(s, 0.9);\n    s = smoothify(s, 1.9);\n    s *= 8.;\n    \n    s *= 0.05;\n    ret;\n}\n\n\n\n\nvec2 chord(float t, float mode){\n\tinit;\n    \n    \n    float r = bar*2.;\n    t = mod(t, r*float(chordCnt));\n    int id = int(floor(t/r));\n    \n    //sampleratereduction(t, (1./iSampleRate));\n    sampleratereduction(t, 0.00001 + t*0.);\n    \n    float env = exp(-mod(t,r));\n    float envb = smoothstep(0.,1.,mod(t,r));\n    \n    \n    vec2 nn = N[1];\n    nn += N[2]*0.9;\n    nn += N[7]*0.45;\n    \n    nn *= 0.03*sin(t);\n    float m = 1.;\n    float width = 15.;\n    s += sin( note(chords[id][0], 1.) *tt + nn.x*1.)*0.5;\n    s += sin( note(chords[id][0], 1.) *tt + nn.x*1.)*0.5;\n    float oct = 1.;\n    if(mode == 1.)\n        oct+= 0.;\n    for(float i = 0.; i < 8.; i++){\n        float a = (1. + i/5.);\n    \t//s += sin( note(chords[id].x, 3.) *tt + nn.x)*m;\n    \ts.x += sin( note(chords[id].x, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].y, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].z, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].w, oct) *tt*a + nn.x)*m;\n    \ts.y += sin( note(chords[id].x, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].y, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].z, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].w, oct) *tt*a + nn.y + width)*m;\n    \tm *= 0.5;\n    }\n    \n    \n    s *= env*envb;\n    //bitreduction(s, 0.05);\n    \n    s *= 0.03;\n    s = sin(s*10.);\n    s = clampify(s, 1.);\n    //s /= 2.;\n    //s = sin(s);\n\tret;\n}\n\n\nvec2 cReverb(float t){\n\tinit;\n    \n    //sampleratereduction(t, (8.2*1./iSampleRate));\n    \n    \n    float iters = 100.;\n    float size = 6050.;\n    \n    \n    for(float i = 0.; i < iters + min(iSampleRate,0.); i++ ){\n        float att = smoothstep(1.,0.8,i/iters);\n    \t//s += lead(t - size*i/iSampleRate + 10000.2*N[int(mod(i,7.))].x/iSampleRate )*(pow(sc,0.9))*att;\n        //float m = size*i/iSampleRate + noise(i ).x*200000./iSampleRate;\n        float m = size*i/iSampleRate + 0.*N[4].x*1.4/iSampleRate;\n        //s += chord(t + m )*(0.8 + pow(sc,0.9)*0.2)*att*0.05;\n        s += chord(t + m, 0. )*(0.8)*att*0.05;\n        //s += lead(t + m/8.)*0.003*att;\n        s += leadb(t + m/4.)*0.007*att*(0.8 + pow(sc,0.9)*0.4);\n        //s += hats(t + m)*(0.2 + pow(sc,1.4))*0.001;\n    }\n    s /= iters;\n    s *= 1.;\n    s *= 200.;\n    \n    s = clampify(s, 1.);\n    \n    //bitreduction(s, 0.0001);\n    \n    ret;\n}\n\n\n\n\n\n\n\n\nvec2 crash(float t){\n\tinit;\n\t\n    t = mod(t + 0., beat);\n    \n    vec2 nn = N[1];\n    \n    float amt = 10.;\n    float env = exp(-t*0.01);\n    float f =  sin(\n        (2000. )*tt)*exp(-t*0.4)*0.215 \n        +sin((4000. )*tt)*exp(-t*2.)*0.5 \n        + ( 1250. + exp(-t*60.)*100.)*tt +lpnoise(t, 200500.).x*1.;\n    s += sin( f )*env;\n    s += amt*sin( f + nn )*env;\n    s -= amt*sin( f )*env;\n    \n    \n    s *= 0.9;\n    bitreduction(s, 0.9);\n    \n    s *= 0.3;\n    ret;\n}\n\nvoid initNoise(float t){\n\t\t\n    N[0] = lpnoise(t, 400.);\n    N[1] = lpnoise(t, 500.);\n    N[2] = lpnoise(t, 700.);\n    N[3] = lpnoise(t, 1000.);\n    N[4] = lpnoise(t, 1400.);\n    N[5] = lpnoise(t, 1900.);\n    N[6] = lpnoise(t, 2500.);\n    N[7] = lpnoise(t, 5500.); \n    \n}\n\n\nvec2 lowKick(float t){\n    init;\n\tt = mod(t, beat*2.5);\n    float env = exp(-t*20.);\n    \n    s += sin(tt*40. + sin(tt*70.)*exp(-t*1.))*env;\n    //bitreduction(s, 0.0);\n\n    s = clamp(s,-1., 1.);\n\n    \n    //s = clampify(s, 20. + sin(gT)*0.3);\n    //s = powify(s, 0.4);\n    s = clampify(s, 2.);\n    \n    //smoothify(s, 1.);\n    \n    ret;\n}\n\nvec2 mainSound( in int samp, float t )\n{\n    vec2 s= vec2(0);\n    initNoise(t);\n    \n    /*\n    t += scoffs;\n    float amp = smoothstep(0.,1.,t);\n    gT = t;\n    //t += msr*4.;\n    \n    initKickPatt(t);\n    initNoise(t);\n\n    \n    vec2 k = kick(t,sc)*1.;\n    vec2 sn = snare(t);\n    \n    vec2 ha = hats(t)*(0.2 + pow(sc,1.4))*0.11;\n    vec2 hb = hatsb(t)*0.7;\n    \n    vec2 bass = bass(t)*(pow(sc,1.5))*0.3;\n    //vec2 cguit = cguit(t)*(pow(sc,1.))*0.5;\n    \n    vec2 revb = cReverbB(t);\n    //vec2 lb = leadb(t)*(pow(sc,0.9))*1.5;\n\t\n    */\n    \n    \n    vec2 lk = lowKick(t);\n    vec2 rev = cReverb(t);\n    vec2 cr = crash(t);\n    \n    \n    cr *= smoothstep(0.,1.,(t - 4.)/46.);\n    \n    s += rev;\n    //s += lk;\n    \n    s += cr*0.02;\n    \n    \n    s = clampify(s, 1.);\n    \n    \n    s = bitreduction(s, smoothstep(0.,1.,(t + -4.)/16./16.) + 0.0001);\n    \n    \n    return s;\n}\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "#define bpm (90.)\n\n#define tick (60./bpm)\n\n#define beat (tick)\n#define bar  (beat*4.)\n#define hbar  (bar/2.)\n#define msr  bar*4.\n#define hbeat tick/2.\n#define qbeat tick/4.\n\nfloat[] ts = float[11](16.,25.,32.,34.,msr*6.,msr*7.,msr*7.5, msr*8.25, msr*9.5, msr*10., msr*11.);\n#define scoffs ts[9]*1.\n\n#define PI acos(-1.)\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n\n#define bitreduction(s,amt) s = sign(s) * floor(abs(s)/(amt))*(amt)\n#define sampleratereduction(t, amt) t = floor(t/(amt))*(amt)\n#define smoothify(s, amt) mix(s,sign(s)*smoothstep(0.0,1.,abs(s)), amt)\n#define clampify(s, amt) clamp(s*amt,-1.,1.)\n#define powify(s, amt) pow(abs(s), vec2(amt))*sign(s)\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}