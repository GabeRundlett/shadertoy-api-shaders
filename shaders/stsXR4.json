{
    "Shader": {
        "info": {
            "date": "1625268244",
            "description": "Tried to use Voronoi particle tracking in 3D for the first time. The obvious choice was to try something simple like the Lorentz attractor.",
            "flags": 32,
            "hasliked": 0,
            "id": "stsXR4",
            "likes": 17,
            "name": "Aizawa attractor ",
            "published": 3,
            "tags": [
                "3d",
                "voronoi",
                "particles",
                "chaos",
                "lorentz"
            ],
            "usePreview": 0,
            "username": "michael0884",
            "viewed": 455
        },
        "renderpass": [
            {
                "code": "// Fork of \"Volumetric shader template\" by michael0884. https://shadertoy.com/view/tlc3Wf\n// 2019-12-30 20:57:24\n\n//#define VOLUMETRIC\n#define FULL_UNION\n#define sphere_rad 0.5\n\nfloat SDF_particle(vec3 p0, vec3 p)\n{\n    vec4 point = voxel(ch0, p0);\n    return length(point.xyz - p) - sphere_rad;\n}\n\n//distance estimator to the voronoi particle field\nfloat DE(vec3 p)\n{\n\tfloat de = 1e5;\n   \n   \tvec3 p0 =  round(clamp(p, vec3(0), size3d));\n    if(length(p - size3d*0.5) > 0.6*length(size3d)) \n        de = length(p - size3d*0.5);\n    else\n    {\t\n        de = min(de, SDF_particle(p0, p));\n        de = min(de, SDF_particle(p0+vec3(1,0,0), p));\n        de = min(de, SDF_particle(p0+vec3(-1,0,0), p));\n        de = min(de, SDF_particle(p0+vec3(0,1,0), p));\n        de = min(de, SDF_particle(p0+vec3(0,-1,0), p));\n        de = min(de, SDF_particle(p0+vec3(0,0,1), p));\n        de = min(de, SDF_particle(p0+vec3(0,0,-1), p));\n    }\n    \n    if(de < sphere_rad*2.)\n    {\n\t\tde = min(de, SDF_particle(p0+vec3(1,1,0), p));\n        de = min(de, SDF_particle(p0+vec3(-1,-1,0), p));\n        de = min(de, SDF_particle(p0+vec3(0,1,1), p));\n        de = min(de, SDF_particle(p0+vec3(0,-1,-1), p));\n        de = min(de, SDF_particle(p0+vec3(1,0,1), p));\n        de = min(de, SDF_particle(p0+vec3(-1,0,-1), p));\n        //reduces the number of artifacts even further, since it is using all neighboring voxels in a 3*3*3 cube\n        #ifdef FULL_UNION\n            de = min(de, SDF_particle(p0+vec3(1,-1,0), p));\n            de = min(de, SDF_particle(p0+vec3(-1,1,0), p));\n            de = min(de, SDF_particle(p0+vec3(0,-1,1), p));\n            de = min(de, SDF_particle(p0+vec3(0,1,-1), p));\n            de = min(de, SDF_particle(p0+vec3(-1,0,1), p));\n            de = min(de, SDF_particle(p0+vec3(1,0,-1), p));\n            de = min(de, SDF_particle(p0+vec3(1,-1,0), p));\n            de = min(de, SDF_particle(p0+vec3(-1,1,0), p));\n            de = min(de, SDF_particle(p0+vec3(0,1,-1), p));\n            de = min(de, SDF_particle(p0+vec3(0,-1,1), p));\n            de = min(de, SDF_particle(p0+vec3(1,0,-1), p));\n            de = min(de, SDF_particle(p0+vec3(-1,0,1), p));\n            de = min(de, SDF_particle(p0+vec3(1,1,1), p));\n            de = min(de, SDF_particle(p0+vec3(1,1,-1), p));\n            de = min(de, SDF_particle(p0+vec3(1,-1,1), p));\n            de = min(de, SDF_particle(p0+vec3(1,-1,-1), p));\n            de = min(de, SDF_particle(p0+vec3(-1,1,1), p));\n            de = min(de, SDF_particle(p0+vec3(-1,1,-1), p));\n            de = min(de, SDF_particle(p0+vec3(-1,-1,-1), p));\n        #endif\n    }\n    \n    return de;\n}\n\nvec3 COL(vec3 p)\n{\n    if(inside(p))\n    {\n        vec4 point = trilinear(ch0, p);\n            \n        return jet_range(point.w, -0.1, 1.2)*exp(-0.25*pow(max(DE(p),0.),2.));\n    }\n    else return vec3(0.);\n}\n\n#define MAX_MARCHES 130\n#define DX 1.5\n#define OPACITY 0.2\nvec4 ray_march_vol(vec3 p, vec3 r)\n{\n    vec4 color = vec4(0., 0., 0., 0.);\n    vec4 background = vec4(0.1);\n    for(int i = 0; i < MAX_MARCHES; i++)\n    {\n        vec3 tcolor = COL(p);\n        float density = length(tcolor);\n        float noise  =(1.+0.25*sin(1754.*length(p)+p.x));\n        float d = DX*exp(-2.*min(density,2.))*noise;\n        float opacity = 1.-exp(-OPACITY*density*d);\n        float newa = max(color.w + (1. - color.w)*opacity,0.0001);\n        color.xyz = (color.xyz*color.w + (1.-color.w)*opacity*tcolor)/newa;\n        color.w = newa;\n        if(1. - newa < 0.01) break;\n        p += r*d;\n    }\n    return background + color;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdLineBox(vec3 p, vec3 b, float r)\n{\n    p = abs(p);\n    float cx = sdBox(p - vec3(b.x*0.5,b.y,b.z), vec3(b.x*0.5+r,r,r));\n    float cy = sdBox(p - vec3(b.x,b.y*0.5,b.z), vec3(r,b.y*0.5+r,r));\n    float cz = sdBox(p - vec3(b.x,b.y,b.z*0.5), vec3(r,r,b.z*0.5+r));\n    return min(min(cx, cy),cz);\n}\n\nvec3 sdcolor(vec3 p)\n{\n    vec3 c = vec3(0.);\n    if(inside(p))\n    {\n        vec4 point = trilinear(ch0, p);\n            \n        c = jet_range(point.w, -0.1, 1.2);\n    }\n    else c = vec3(0.1);\n    if(sdLineBox(p - size3d*0.5, size3d*0.5, 0.5) < 5. || p.z < 3.) c = vec3(1.);\n    return c;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat map(vec3 p)\n{\n    float de_partic = DE(p); \n    de_partic = min(de_partic, sdPlane(p, vec4(0,0,1,0)));\n    return min(de_partic, sdLineBox(p - size3d*0.5, size3d*0.5, 0.5));\n}\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 k = vec3(1,-1,0);\n\treturn   (k.xyyx*map(p + k.xyy*dx) +\n\t\t\t k.yyxx*map(p + k.yyx*dx) +\n\t\t\t k.yxyx*map(p + k.yxy*dx) +\n\t\t\t k.xxxx*map(p + k.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n//usual ray marching stuff\nfloat rayfov;\nvec3 light;\n\n#define shadow_steps 256\n#define MIN_DIST 0.001\n#define MAX_DIST 1000.\nfloat shadow_march(vec4 pos, vec4 dir, float distance2light, float light_angle)\n{\n\tfloat light_visibility = 1.;\n\tfloat ph = 1e5;\n\tfloat dDEdt = 0.;\n\tpos.w = map(pos.xyz);\n\tint i = 0;\n\tfor (; i < shadow_steps; i++) {\n\t\n\t\tdir.w += pos.w;\n\t\tpos.xyz += pos.w*dir.xyz;\n        float noise  =(1.+0.1*sin(1754.*length(pos)+pos.x));\n\t\tpos.w = noise*map(pos.xyz);\n\t\t\n\t\tfloat y = pos.w*pos.w/(2.0*ph);\n        float d = (pos.w+ph)*0.5*(1.-dDEdt);\n\t\tfloat angle = d/(max(MIN_DIST,dir.w-y)*light_angle);\n\t\t\n        light_visibility = min(light_visibility, angle);\n\t\t\n\t\t//minimizing banding even further\n\t\tdDEdt = dDEdt*0.75 + 0.25*(pos.w-ph)/ph;\n\t\t\n\t\tph = pos.w;\n\t\t\n        if(dir.w >= distance2light)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(dir.w > MAX_DIST || pos.w < max(0.5*rayfov*dir.w, MIN_DIST))\n\t\t{\n\t\t\treturn 0.;\n\t\t}\n\t}\n\t\n\tif(i >= shadow_steps)\n\t{\n\t\tlight_visibility=0.;\n\t}\n\t//return light_visibility; //bad\n\tlight_visibility = clamp(2.*light_visibility - 1.,-1.,1.);\n\treturn  0.5 + (light_visibility*sqrt(1.-light_visibility*light_visibility) + asin(light_visibility))/3.14159265; //looks better and is more physically accurate(for a circular light source)\n}\n\nfloat ambient_occlusion(in vec4 pos, in vec4 norm)\n{\t\n\tvec3 pos0 = pos.xyz;\n\t\n\tfloat occlusion_angle = 0.;\n\tvec3 direction = normalize(norm.xyz);\n\t//step out\n\tpos.xyz += 0.1*norm.w*direction;\n\t//march in the direction of the normal\n\tfor(int i = 0; i < 2; i++)\n\t{\n\t\tpos.xyz += pos.w*direction;\n\t\tpos.w = map(pos.xyz);\n\t\t\n\t\tnorm.w = length(pos0 - pos.xyz);\n\t\tocclusion_angle += clamp(pos.w/norm.w,0.,1.);\n\t}\n\t\n\tocclusion_angle /= 2.; // average weighted by importance\n\treturn (0.5-cos(3.14159265*occlusion_angle)*0.5);\n}\n\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float td = 0.;\n    int i;\n    for(i = 0; i < 100; i++)\n    {\n    \tfloat de = map(p);\n        if(de < rayfov*td || td > MAX_DIST)\n        {\n            break;\n        }\n        p += de*r;\n        td += de;\n    }\n    vec3 col =sdcolor(p);\n    vec4 norm = calcNormal(p,MIN_DIST);\n    p += r*(norm.w-rayfov*td);\n    float ao = ambient_occlusion(vec4(p,0.), vec4(norm.xyz, td));\n    float shad = shadow_march(vec4(p+norm.xyz*0.05,0.), vec4(light,0.), 400.,0.03);\n    float ill = max(dot(norm.xyz, light)*(shad  + 0.35*ao*(1. - shad)), 0.0);\n    return vec4(col*ill,1.);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rayfov = FOV/iResolution.x;\n     SCALE = floor(ar*pow(iResolution.x*iResolution.y,0.1666666));\n    size3d = vec3(floor(iResolution.xy/SCALE), SCALE.x*SCALE.y);\n   \n    vec2 uv = (fragCoord - 0.5*size)/max(size.x, size.y);\n\n    vec2 angles = vec2(2.*PI, PI)*(iMouse.xy/iResolution.xy - 0.5);\n\n    if(iMouse.z <= 0.)\n    {\n        angles = vec2(0.2*iTime, 0.3*sin(0.2*iTime)+0.2);\n    }\n    vec3 ray = getRay(angles, uv);\n    vec3 cray = getRay(angles, vec2(0.));\n    light = vec3(0.3,0.8,0.9);\n    light.z = max(light.z, 0.9);\n    light = normalize(light);\n    float d = sqrt(dot(vec3(size3d), vec3(size3d)))*0.55;\n    vec3 pos = vec3(size3d)*0.5 - cray*d;\n\n    // Output to screen\n    vec4 t = texel(ch0, fragCoord);\n    vec3 p = dim3from2(fragCoord);\n    #ifdef VOLUMETRIC\n   \t fragColor = 2.*ray_march_vol(pos, ray);\n    #else\n     fragColor = 1.5*ray_march(pos, ray);\n\t#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//definitions\n#define size iResolution.xy\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define pixel(a, p, s) texture(a, p/vec2(s))\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define dt 0.2\n\n#define ar vec2(1.35,0.8)\nvec2 SCALE;\nvec3 size3d;\n\nvec2 dim2from3(vec3 p3d)\n{\n    float ny = floor(p3d.z/SCALE.x);\n    float nx = floor(p3d.z) - ny*SCALE.x;\n    return vec2(nx, ny)*vec2(size3d.xy) + p3d.xy;\n}\n\nvec3 dim3from2(vec2 p2d)\n{\n    return vec3(p2d - size3d.xy*floor(p2d/size3d.xy),(floor(p2d.x/size3d.x) + SCALE.x*floor(p2d.y/size3d.y)));\n}\n\nvec4 voxel(sampler2D ch, vec3 p3d)\n{\n    return pixel(ch, dim2from3(p3d), textureSize(ch, 0));\n}\n\n//trilinear interpolation = linear interp between layers\nvec4 trilinear(sampler2D ch, vec3 p3d)\n{\n    return mix(voxel(ch, vec3(p3d.xy, floor(p3d.z))),voxel(ch, vec3(p3d.xy, ceil(p3d.z))), fract(p3d.z));\n}\n\nbool inside(vec3 p)\n{\n    if(p.x > 1. && p.y > 1. && p.z > 1. && p.x < float(size3d.x)-1. && p.y < float(size3d.y)-1. && p.z < float(size3d.z)-1.)\n    {\n        return true;\n    }\n    else return false;\n}\n\n#define FOV 2.5\nmat3 getCamera(vec2 angles)\n{\n   mat3 theta_rot = mat3(1,   0,              0,\n                          0,   cos(angles.y),  sin(angles.y),\n                          0,  -sin(angles.y),  cos(angles.y)); \n        \n   mat3 phi_rot = mat3(cos(angles.x),   sin(angles.x), 0.,\n        \t\t       -sin(angles.x),   cos(angles.x), 0.,\n        \t\t        0.,              0.,            1.); \n        \n   return theta_rot*phi_rot;\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getCamera(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, 1., FOV*pos.y));\n}\n\nfloat minv(vec3 a)\n{\n    return min(min(a.x, a.y),a.z);\n}\n\nfloat distance2border(vec3 p)\n{\n    vec3 a = vec3(size3d) - p;\n    return min(minv(p),minv(a));\n}\n    \n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//3d voronoi particle tracking\n\nvoid Check(inout vec4 U, vec3 pos, vec3 dx)\n{\n    vec4 Unb = voxel(ch0, pos+dx);\n    //check if the stored neighbouring particle is closer to this position \n    if(length(Unb.xyz - pos) < length(U.xyz - pos))\n    {\n        U = Unb; //copy the particle info\n    }\n}\n\nvoid CheckRadius(inout vec4 U, vec3 p, int r)\n{\n    Check(U, p, vec3(-r, 0, 0));\n    Check(U, p, vec3(r, 0, 0));\n    Check(U, p, vec3(0, -r, 0));\n    Check(U, p, vec3(0, r, 0));\n    Check(U, p, vec3(0, 0, -r));\n    Check(U, p, vec3(0, 0, r));\n}\n\n#define sigma 10.\n#define beta 8./3.\n#define rho 28.\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    SCALE = floor(ar*pow(iResolution.x*iResolution.y,0.1666666));\n    size3d = vec3(floor(iResolution.xy/SCALE), SCALE.x*SCALE.y);\n    //voxel\n    vec3 p = dim3from2(pos);\n    \n    //this voxel value\n    U = voxel(ch0, p);\n    \n    //check neighbours \n    CheckRadius(U, p, 1);\n    CheckRadius(U, p, 2);\n    CheckRadius(U, p, 3);\n    CheckRadius(U, p, 4);\n \n    //U.xyz += 0.2*dt*vec3(p);\n    float scaling =8.0/length(size3d);\n    vec3 ppos = scaling*(U.xyz - size3d*vec3(0.5,0.5,0.5)); \n    \n    float a = 0.95, b = 0.7, c = 0.6, d = 3.5, e = 0.25, f = 0.1;\n    \n    vec3 val = ppos;\n    \n    float x1 = (val.z-b)*val.x - d*val.y;\n\n    float y1 = d * val.x + (val.z - b) * val.y;;\n\n    float z1 = c + a*val.z - (pow(val.z, 3.)/3.) - \n\n        (pow(val.x, 2.f) + pow(val.y, 2.f)) *\n\n        (1.0 + e * val.z) + f * val.z * ( pow(val.x, 3.f)); \n    \n   // vec3 dx = vec3(sigma*(ppos.y - ppos.x), ppos.x*(rho - ppos.z) - ppos.y, ppos.x*ppos.y - beta*ppos.z);\n    vec3 dx = vec3(x1, y1, z1);\n    U.xyz += dt*dx;\n    U.w = length(dx)*0.25;\n    \n    float bdist = distance2border(U.xyz);\n    \n    if(iFrame < 1)\n    {\n        ppos = vec3(4.*round(p/4.));\n        U = vec4(ppos, 0.);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//3d voronoi particle tracking\n\nvoid Check(inout vec4 U, vec3 pos, vec3 dx)\n{\n    vec4 Unb = voxel(ch0, pos+dx);\n    //check if the stored neighbouring particle is closer to this position \n    if(length(Unb.xyz - pos) < length(U.xyz - pos))\n    {\n        U = Unb; //copy the particle info\n    }\n}\n\nvoid CheckRadius(inout vec4 U, vec3 p, int r)\n{\n    Check(U, p, vec3(-r, 0, 0));\n    Check(U, p, vec3(r, 0, 0));\n    Check(U, p, vec3(0, -r, 0));\n    Check(U, p, vec3(0, r, 0));\n    Check(U, p, vec3(0, 0, -r));\n    Check(U, p, vec3(0, 0, r));\n}\n\n#define sigma 10.\n#define beta 8./3.\n#define rho 28.\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    SCALE = floor(ar*pow(iResolution.x*iResolution.y,0.1666666));\n    size3d = vec3(floor(iResolution.xy/SCALE), SCALE.x*SCALE.y);\n    //voxel\n    vec3 p = dim3from2(pos);\n    \n    //this voxel value\n    U = voxel(ch0, p);\n    \n    //check neighbours \n    CheckRadius(U, p, 1);\n    CheckRadius(U, p, 2);\n    CheckRadius(U, p, 3);\n    CheckRadius(U, p, 4);\n \n    U.xyz += 0.002*dt*vec3(p);\n    float scaling =8.0/length(size3d);\n    vec3 ppos = scaling*(U.xyz - size3d*vec3(0.5,0.5,0.5)); \n    \n    float a = 0.95, b = 0.7, c = 0.6, d = 3.5, e = 0.25, f = 0.1;\n    \n    vec3 val = ppos;\n    \n    float x1 = (val.z-b)*val.x - d*val.y;\n\n    float y1 = d * val.x + (val.z - b) * val.y;;\n\n    float z1 = c + a*val.z - (pow(val.z, 3.)/3.) - \n\n        (pow(val.x, 2.f) + pow(val.y, 2.f)) *\n\n        (1.0 + e * val.z) + f * val.z * ( pow(val.x, 3.f)); \n    \n   // vec3 dx = vec3(sigma*(ppos.y - ppos.x), ppos.x*(rho - ppos.z) - ppos.y, ppos.x*ppos.y - beta*ppos.z);\n    vec3 dx = vec3(x1, y1, z1);\n    U.xyz += dt*dx;\n    \n    float bdist = distance2border(U.xyz);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}