{
    "Shader": {
        "info": {
            "date": "1613685230",
            "description": "An invertible, area-preserving mapping to the unit disk from its enclosing square.\nThe idea is to first map the square to a 2d gaussian via the inversion method.\nThe result is then remapped to a solid disk by applying a radially symmetric transfer func.",
            "flags": 0,
            "hasliked": 0,
            "id": "wtcfWl",
            "likes": 15,
            "name": "Area-Preserving Square <-> Disk",
            "published": 3,
            "tags": [
                "map",
                "sampling",
                "mapping",
                "disk",
                "unitdisk"
            ],
            "usePreview": 0,
            "username": "TinyTexel",
            "viewed": 582
        },
        "renderpass": [
            {
                "code": "// CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n// To the extent possible under law, Mirko Salm has waived all copyrights and related or neighboring rights to this work.\n\n// https://twitter.com/Mirko_Salm\n\n/*\n\nAn invertible, area-preserving mapping to the unit disk from its enclosing square.\nThe idea is to first map the square to a 2d gaussian via the inversion method.\nThe result is then remapped to a solid disk by applying a radially symmetric transfer function.\n\nThe left half of the image illustrates the distortions caused by the square->disk mapping (implemented via the inverse mapping).\nThe right half shows a couple of random points evenly distributed on the unit disk by using the square->disk mapping.\n\n// p: [-1,1]² | return u: [-1,1]²\nvec2 DiskFromSquare(vec2 p)\n{\n    // map the square to a 2d gaussian via the inversion method:\n    vec2 v = vec2(ErfI(p.x), \n                  ErfI(p.y));// the inverse error function is the inverse cummulative distribution function (iCDF) of the one-sided normal distribution\n                   \n        // v is now a point distributed according to a 2d gauss\n\n        // since a 2d gauss is already a radially symmetrical distribution all that is left to do is to remap the distance of the point v from the origin vec2(0)\n\n        // for that we apply a transfer function tf(r) in the following way: vec2 u = normalize(v) * tf(length(v));// u is our final result\n\n        // how does tf(r) look like?\n\n        // to figure this out we need to know how length(v) is distributed\n\n        // since we are no longer interested in the normalize(v) part (as it is already correctly distributed) we radially marginalize our 2d gaussian\n\n        // for a radially symmetrical distribution in 2d, like our gauss, this marginalization boils down to a multiplication with r (distance to origin) + normalization\n\n        // therefore length(v) is distributed according to pdf_mgauss(r) = 2*r*exp(-r²) // mgauss stands for \"marginalized gauss\"\n\n        // and to get a disk we need it to be distributed according to pdf_mdisk(r) = 2*r\n\n        // so the remapping is build like this tf(r) = iCDF_mdisk(CDF_mgauss(r)) // applying the inverse inversion method for mgauss followed by the inversion mapping for mdisk\n\n        // with CDF_mgauss(r) = 1-exp(-r²)\n\n        // and  iCDF_mdisk(r) = sqrt(r) \n           \n    // therefore we get:\n    vec2 dir = normalize(v);\n    float r  = length(v);\n           \n    return dir * sqrt(1.0-exp(-r*r)); \n    \n        // inverting this mapping is rather straightforward: split the point into dir+r, apply the inverse of tf(r) to r, and apply Erf(x) to the x and y components of dir+inv_tf(r)\n        \n        // we can also save a few intructions (in particular a sqrt()) by performing some optimizations (using versions of Erf and ErfI that take squared input/return squared outputs)\n}\n\nThe mapping is area-preserving when the determinant of its Jacobian matrix is constant.\nThe following Mathematica code performs the necessary computations to verify this:\n\nnorm[x_] := Sqrt[x.x]\nmap0[x_, y_] := {InverseErf[x], InverseErf[y]}\ntf[x_] := Sqrt[1 - Exp[-x x]]\nmap[x_, y_] := map0[x, y]/norm[map0[x, y]] tf[norm[map0[x, y]]]\ndet[x_, y_] = \n FullSimplify[\n  Det[{{D[map[x, y][[1]], x], D[map[x, y][[2]], x]}, \n       {D[map[x, y][[1]], y], D[map[x, y][[2]], y]}}]]\n     \nThis code evaluates to π/4.     \n\n*/\n\n\n// https://en.wikipedia.org/wiki/Error_function#Approximation_with_elementary_functions\n// error function approximation by Sergei Winitzki (maximum relative error ~0.00013)\nfloat Erf(float x)\n{\n\tbool neg = x < 0.0;\n    \n    const float a = 0.147;\n    const float b = 1.27324;//4.0/Pi\n    \n    float xx = x*x;\n    float xxa = xx*a;\n    float y = sqrt(1.0 - exp(-xx * (xxa + b) / (xxa + 1.0)));\n    \n    return neg ? -y : y;\n}\n\n// ..takes the squared argument \nfloat Erf1(float xx)\n{\n    const float a = 0.147;\n    const float b = 1.27324;//4.0/Pi\n    \n    float xxa = xx*a;\n    float y = sqrt(1.0 - exp(-xx * (xxa + b) / (xxa + 1.0)));\n    \n    return y;\n}\n\n// inverse error function approximation by Sergei Winitzki\nfloat ErfI(float x)\n{\n\tbool neg = x < 0.0;\n\n    const float a = 6.802721;// 1.0/0.147\n    const float b = 4.330747;// 2.0 / Pi * a\n    \n    float u = log(max(1e-36, 1.0 - x*x));\n    float c = u * 0.5 + b;\n    \n    float y = sqrt(max(0.0, sqrt(max(0.0, c*c - u*a)) - c));\n\n    return neg ? -y : y;\n}\n\n// ..outputs the square of the result\nfloat ErfI1(float x)\n{\n    const float a = 6.802721;// 1.0/0.147\n    const float b = 4.330747;// 2.0 / Pi * a\n    \n    float u = log(max(1e-36, 1.0 - x*x));\n    float c = u * 0.5 + b;\n    \n    return sqrt(max(0.0, c*c - u*a)) - c;\n}\n\n\n// p: [-1,1]² | return u: [-1,1]²\nvec2 DiskFromSquare(vec2 p)\n{\n    vec2 sgn = vec2(p.x < 0.0 ? -1.0 : 1.0, \n                    p.y < 0.0 ? -1.0 : 1.0);    \n    \n    vec2 vv = vec2(ErfI1(p.x), \n                   ErfI1(p.y));\n    \n    float w = vv.x+vv.y;\n    \n    vec2 uu = vv * ((1.0-exp(-w)) / w);\n    \n    vec2 u = sqrt(uu) * sgn;\n    \n    return u;\n}\n\n// u: [-1,1]² | return p: [-1,1]²\nvec2 SquareFromDisk(vec2 u)\n{\n    vec2 sgn = vec2(u.x < 0.0 ? -1.0 : 1.0, \n                    u.y < 0.0 ? -1.0 : 1.0);\n\n    vec2 uu = u*u;\n    \n    float m = uu.x+uu.y;\n    \n    vec2 vv = uu * (-log(max(1e-36, 1.0-m)) / m);\n    \n    vec2 p = vec2(Erf1(vv.x), \n                  Erf1(vv.y)) * sgn;\n                \n    return p;                \n}\n\n//http://psgraphics.blogspot.com/2011/01/improved-code-for-concentric-map.html\nvec2 DiskFromSquareConcentric(vec2 p)\n{\n    float pi = 3.141592;\n\n    float phi,r;\n    float a = p.x;\n    float b = p.y;\n    if (a*a> b*b) \n    {\n        r = a;\n        phi = (pi/4.0)*(b/a);\n    } \n    else \n    {\n        r = b;\n        phi = (pi/2.0)-(pi/4.0)*(a/b);\n    }\n    return vec2(cos(phi), sin(phi)) * r;\n}\n\n\nvoid mainImage(out vec4 col, in vec2 uv0)\n{\n    vec2 uv = uv0 - 0.5;\n    vec2 tc = uv0/iResolution.xy;\n\n    col = vec4(0.0);\n    \n    float l = iResolution.x*0.5;\n    \n    uv0.y -= max(0.0, (iResolution.y-l)*0.5);\n    \n    if(uv0.x < l)// LEFT\n    {\n        // distorted checkerboard pattern via square->disk map\n        vec2 tc = uv0 / l;\n        \n        vec2 u = tc * 2.0 - 1.0;\n        \n        if(abs(u.x) > 1.01 || abs(u.y) > 1.01) return;\n        \n        vec2 p = SquareFromDisk(clamp11(u));\n        \n        vec2 v = cos(p*(Pi*8.0));\n        \n        float n = v.x*v.y;        \n        \n        n = rescale(n)*0.5+0.5;\n        n = clamp01(n);\n        n = n*n*(3.0-2.0*n);\n        n = n*n*(3.0-2.0*n);\n        \n        col.rgb = vec3(n);\n        \n        col *= clamp01(rescale(1.0-dot(u,u)))*0.9;\n    }\n    else if(uv0.x-l < l)// RIGHT\n    {\n        // evenly distributed points on disk via square->disk map\n        vec2 tc = (uv0-vec2(l,0.0)) / l;\n        \n        vec2 p0 = tc * 2.0 - 1.0;\n        \n        if(abs(p0.x) > 1.01 || abs(p0.y) > 1.01) return;\n        \n        uint count = 64u;\n\n        float c = 0.0;\n        for(uint i = 0u; i < count; ++i)\n        {\n            uint j = i + uint(iFrame)*(count/8u);\n            \n            // 2d Roberts LDS\n            vec2 p = vec2(j * uvec2(2447445413u, 3242174889u)) * (1.0/4294967296.0);\n            \n           #if 0\n            {\n                // jitter point\n                float ang = float(WellonsHash(j))*(Pi*2.0/4294967296.0);\n\n                p = fract(p + vec2(cos(ang), sin(ang)) * 0.02);\n            }\n           #endif\n           \n            vec2 u = DiskFromSquare(p*2.0-1.0);\n            \n            vec2 vec = (p0 - u)*64.0;\n            \n            float pt = 1.0-dot(vec, vec);\n\n            pt = clamp01(rescale(pt));\n            \n            c += pt*0.5;\n        }\n        \n        c += clamp01(rescale(1.0-dot(p0,p0)))*0.01;\n        \n        col.rg = tc;\n        col.rgb = vec3(c);\n    }\n    \n    col.rgb = GammaEncode(clamp(col.rgb, 0.0, 1.0));\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define clamp11(x) clamp(x,-1.0, 1.0)\n#define rsqrt inversesqrt\n\nconst float Pi = 3.14159265359;\nconst float Pi2 = Pi * 2.0;\nconst float Pi05 = Pi * 0.5;\nconst float Pi025 = Pi * 0.25;\nconst float Phi    = 1.61803399;\nconst float PhiRcp = 0.61803399;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\nfloat ddxyRcpLen(float v) { return rsqrt( Pow2(dFdx(v)) + Pow2(dFdy(v)) ); }\n\n\nfloat rescale(float v) { return v * ddxyRcpLen(v); }\n\n// low bias version https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}