{
    "Shader": {
        "info": {
            "date": "1575074032",
            "description": "Copy pasted very poorly from my first ray marcher in an opengl project. ",
            "flags": 0,
            "hasliked": 0,
            "id": "tsGSRK",
            "likes": 4,
            "name": "Lava Lamp Like",
            "published": 3,
            "tags": [
                "raymarching",
                "ray",
                "march"
            ],
            "usePreview": 0,
            "username": "aethelwhat",
            "viewed": 449
        },
        "renderpass": [
            {
                "code": "/* \n * I'm aware half this code isn't even used, \n * its a playground from my first raymarcher\n * \n */\n\nconst int MAX_MARCHES = 255;\nconst float MIN_DIST = 0.05f;\nconst float EPSILON = 0.001f;\nconst vec3 temp_albedo = vec3(0.4f,0.3f,0.8f);\nconst vec3 sunlight = vec3(1.0f,1.0f,1.0f);\n\n#define pi 3.14159265358979\n\nstruct Ray {\n    vec3 o;     // origin\n    vec3 d;     // direction - always set with normalized vector\n};\n\nfloat percentOfMarches(float marches){\n\treturn (marches / float(MAX_MARCHES));\n}\n\nRay createRay(vec3 o, vec3 d)\n{\n    Ray r;\n    r.o = o;\n    r.d = d;\n    return r;\n}\n\nstruct Camera\n{\n    vec3 origin;\n    vec3 lowerLeftCorner;\n    vec3 horizontal;\n    vec3 vertical;\n    vec3 u, v, w;\n    float lensRadius;\n};\n\nCamera createCamera(\n    vec3 lookFrom,\n    vec3 lookAt,\n    vec3 worldUp,\n    float fovy,\n    float aspect)\n{\n    float theta = fovy * pi / 180.0;\n    float halfHeight = tan(theta * 0.5);\n    float halfWidth = aspect * halfHeight;\n\n    Camera cam;\n    cam.origin = lookFrom;\n    cam.w = normalize(lookFrom - lookAt);\n    cam.u = normalize(cross(worldUp, cam.w));\n    cam.v = cross(cam.w, cam.u);\n    \n    cam.lowerLeftCorner = cam.origin - halfWidth * cam.u - halfHeight * cam.v - cam.w;\n    //cam.lowerLeftCorner = cam.origin - halfWidth  - halfHeight;\n    cam.horizontal = 2.0 * halfWidth * cam.u;\n    cam.vertical = 2.0 * halfHeight * cam.v;\n    return cam;\n}\n\nRay getRay(Camera cam, vec2 uv)\n{\n    return createRay(\n        cam.origin,\n        normalize(cam.lowerLeftCorner + uv.x * cam.horizontal + uv.y * cam.vertical - cam.origin));\n}\n\nvec3 modPoint(vec3 pt, vec3 c){\n\treturn mod(pt+0.5*c,c)-0.5*c;\n}\n\nfloat sphereSdf(vec3 pt, vec3 circleOrigin, float circleRadius){\n\treturn length(pt - circleOrigin) - circleRadius;\n}\n\nvec2 opSmoothUnion( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// map\nfloat distanceEstimator(vec3 pt){\n\tfloat speed = 3.0;\n\tfloat period = 3.0;\n\tfloat movement = (fract(iTime/speed)- .5)*period;\n\tvec2 c1 = vec2(sphereSdf(modPoint(pt,vec3(period)),vec3(0.),.4) , 23.0);\n\tvec3 moving = vec3(0.,(fract(iTime/speed) - .5)*period ,0.); // range of y -period to period\n\tvec2 c2 = vec2(sphereSdf(modPoint(pt-moving,vec3(period)),vec3(0.),.5) , 43.0);\n\n\treturn opSmoothUnion(c1,c2,0.5).x;\n\t//return opSmoothUnion(c1,c2,0.5).x;\n\t\n}\n\nconst float minRadius2 = 1.0;\nconst float fixedRadius2 = 2.0;\nconst float foldingLimit = 2.0;\n\nfloat dist_field(vec3 p) {\n    p.x += cos(0.1 * p.y ) + cos(0.07 * p.z);\n    p.y += cos(0.1 * p.z );\n    p.z += 3.0*cos(0.1 * p.x);\n\tp = max(cos(abs(p)), -0.8);\n    return length(p) - 0.2;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        distanceEstimator(vec3(p.x + EPSILON, p.y, p.z)) - distanceEstimator(vec3(p.x - EPSILON, p.y, p.z)),\n        distanceEstimator(vec3(p.x, p.y + EPSILON, p.z)) - distanceEstimator(vec3(p.x, p.y - EPSILON, p.z)),\n        distanceEstimator(vec3(p.x, p.y, p.z  + EPSILON)) - distanceEstimator(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 estimateNormalDistField(vec3 p) {\n    return normalize(vec3(\n        dist_field(vec3(p.x + EPSILON, p.y, p.z)) - dist_field(vec3(p.x - EPSILON, p.y, p.z)),\n        dist_field(vec3(p.x, p.y + EPSILON, p.z)) - dist_field(vec3(p.x, p.y - EPSILON, p.z)),\n        dist_field(vec3(p.x, p.y, p.z  + EPSILON)) - dist_field(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec4 rayMarch(vec3 ro, vec3 rd, vec3 cam_position){\n\t\n\tvec3 point = ro + rd * MIN_DIST;\n\tint i = 0;\n\tfor(i = 0; i < MAX_MARCHES; ++i){\n\n\t\tfloat dist = distanceEstimator(point);\n\t\t//float dist = dist_field(point);\n\n\t\tif(dist < EPSILON && length(point - cam_position ) > 1.0){\n\n\t\t\tbreak;\n\t\t}\n\t\tpoint += rd * dist;\n\t}\n\treturn vec4(point, float(i));\n}\n\nvec4 getColor2(vec3 point, float marches, vec3 rd){\n\n\tvec4 color = vec4(0.0);\n\tvec3 normal = estimateNormal(point);\n\t//vec3 normal = estimateNormalDistField(point);\n\tvec3 albedo = rd;\n\tvec3 surface = albedo * dot(normal,sunlight);\n\tvec3 absnormal = abs(normal);\n\tcolor = vec4(absnormal.rgb,1.0f);\n\tcolor = vec4(surface.rgb,1.0f);\n\t//color = mix(vec4(vec3(marchColor(marches)),1.0f),color,0.2);\n\t\n\treturn color;\n}\n\nvec4 getColor(vec3 point, float marches){\n\n\tvec4 color = vec4(1.0);\n\tvec3 normal = estimateNormal(point);\n\t//color = texture(skybox,normal);\n\tvec4 albedo = vec4(normalize(point),1.0);\n\tcolor = mix(albedo,color,0.6);\n    color = mix(vec4(normal,1.0), color, 0.9);\n    //vec4 fog = albedo;\n    //color = mix(color, fog, percentOfMarches(marches));\n\treturn color;\n}\n\nvec3 reflection(vec3 dir, vec3 normal){\n\treturn dir - 2. * dot(dir, normal) * normal;\n}\n\nvec4 bounceRay(vec3 pt, vec3 rd, vec3 cam_position){\n\tvec4 result = rayMarch(pt, rd, cam_position);\n\tvec4 color = getColor(result.xyz, result.w);\n\n\t// bounce once\n\t//vec4 result2 = rayMarch(result.xyz,estimateNormal(result.xyz));\n\t//vec4 color2 = getColor(result2.xyz,result2.w);\n\t//return mix(color,color2,0.9);\n\n\t// bounce many times\n\tvec4 result2 = result; // to start\n\tfor(int i = 0; i < 0; ++i){\n\t\tvec3 normal =  estimateNormal(result2.xyz);\n\t\trd = reflection(rd, normal);\n\t\tresult2 = rayMarch(result2.xyz, rd, cam_position);\n\t\tvec4 color2 = getColor(result2.xyz,result2.w);\n\t\tcolor = mix(color,color2,0.6);\n\t}\n\treturn color;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 mouse = iMouse.xy;\n\n    //vec3 camPos = vec3(mouse.x * 10.0, mouse.y * 5.0, 8.0);\n    vec3 camPos = vec3(1.5, 6.0, 11.0);\n    \n    vec3 camTarget = vec3(0.0, 12.0, -10.0);\n    float fovy = 80.0;\n    Camera cam = createCamera(\n        camPos,\n        camTarget,\n        vec3(0.0, 1.0, 0.0),    // world up vector\n        fovy,\n        iResolution.x / iResolution.y);\n    \n\tvec3 rayDir3 = getRay(cam, uv).d;\n\n\t//vec3 rayDir3 = normalize(ray_dir.xyz);\n\t\n    //vec3 point = camera_position;\n    vec3 point = camPos;\n    \n\tvec4 color = bounceRay(point,rayDir3,camPos);\n\t//vec4 color = getColor(result.xyz, result.w);\n\n\t\n\tfragColor = color;\n\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}