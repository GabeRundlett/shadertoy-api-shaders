{
    "Shader": {
        "info": {
            "date": "1662074702",
            "description": "rounds an sdf\n*note that there is no cast shadow",
            "flags": 0,
            "hasliked": 0,
            "id": "flByzy",
            "likes": 0,
            "name": "round sdf",
            "published": 3,
            "tags": [
                "sdf"
            ],
            "usePreview": 0,
            "username": "ArmandB",
            "viewed": 256
        },
        "renderpass": [
            {
                "code": "const vec3 light = vec3(-0.3,-0.6,-0.3);\nconst vec3 lightCol = vec3(1,1,0.9);\n\n//a sdf circle\nfloat sdCircle(vec2 uv, float r){\n    return length(uv)-r;\n}\n \n//returns the normal of a sdf circle\nvec3 sdCircleNormal(vec2 uv){\n    vec2 base = normalize(uv)*sqrt(6.0)/3.0;\n    return vec3(base.x,sqrt(3.0)/3.0,base.y);\n}\n\n//a sdf line\nfloat sdLine(vec2 a, vec2 b, float r, vec2 p){\n    vec2 ab = b - a;\n    float t = dot(p - a, ab) / dot(ab, ab);\n    vec2 p2 = a + clamp(t,0.0,1.0) * ab;\n    return length(p - p2) - r;\n}\n\n//returns the normal of a sdf line\nvec3 sdLineNormal(vec2 a, vec2 b, vec2 p){\n    vec2 ab = b - a;\n    float t = dot(p - a, ab) / dot(ab, ab);\n    vec2 p2 = a + clamp(t,0.0,1.0) * ab;\n    vec2 base = normalize(p-p2)*sqrt(6.0)/3.0;\n    return vec3(base.x,sqrt(3.0)/3.0,base.y);\n}\n\n//given a radius and distance value, warps the distance to be circular\nfloat roundSdf(float r, float d){\n    if (d < -r) return -r;\n    float b = d*d + 2.0*d*r;\n    return sign(b)*sqrt(abs(b));\n}\n\n//given a radius, distance, and normal, bends the normal to add a circular bevel\nvec3 roundNormal(float r, float d, vec3 normal){\n    if (d < -r) return vec3(0,1,0);\n    float b = d*d + 2.0*d*r;\n    float m = (d+r)/sqrt(abs(b));\n    float l = sqrt(d*d*(m*m + 1.0));\n    vec2 v = sign(d)*vec2(-m*d,d)/l;\n    vec2 a = normalize(normal.xz)*v.x;\n    vec3 x = vec3(-a.y,v.y,-a.x);\n    return x/length(x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy/2.0)/iResolution.y;\n    \n    float circleDist = sdCircle(uv, 0.2);\n    float lineDist = sdLine(vec2(-0.2,0.3),vec2(0.2,0.3),0.03,uv);\n    float dist = 0.0;\n    vec3 normal = vec3(0,1,0);\n    if (lineDist < circleDist){\n        dist = lineDist;\n        //get normal of line and bend it\n        normal = sdLineNormal(vec2(-0.2,0.3),vec2(0.2,0.3),uv);\n        normal = roundNormal(0.03, dist, normal);\n    } else {\n        dist = circleDist;\n        //get normal of circle and bend it\n        normal = sdCircleNormal(uv);\n        normal = roundNormal(0.2, dist, normal);\n    }\n    //base color\n    vec3 col = dist < 0.0 ? vec3(0.3,0.4,0.8) : vec3(0.8,0.4,0.2);\n    //lighting\n    float diffuse = clamp(dot(normal,normalize(-light)),0.0,1.0);\n    vec3 specularAngle = reflect(vec3(0,-1,0),normal);\n    float specular = max(dot(specularAngle,normalize(-light)),0.0);\n    float ambient = 0.2;\n    col = col*diffuse + col*ambient + lightCol*pow(specular,10.0)*0.5;\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}