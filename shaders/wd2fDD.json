{
    "Shader": {
        "info": {
            "date": "1612687144",
            "description": "I tried to make a bloom using a Guassian blur. Old experiment thats been sitting in my list for a while.",
            "flags": 32,
            "hasliked": 0,
            "id": "wd2fDD",
            "likes": 17,
            "name": "April, March, Bloom",
            "published": 3,
            "tags": [
                "3d",
                "bloom"
            ],
            "usePreview": 0,
            "username": "Plento",
            "viewed": 425
        },
        "renderpass": [
            {
                "code": "// Image\n\n\n/* \n    The blur is seperated in buffer B and image where B blurs in the X direction \n    and image tab takes that and blurs down the y direction. Its faster seperated  \n    like this becuase otherwise you'd need a nested for loop. 2x vs x^2. Im sure theres\n    better ways yet, but thats why I'm here!\n*/\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = u/R;\n    vec2 uv2 = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    vec3 blur = texture(iChannel1, uv).xyz;\n    vec3 sum = vec3(0);\n    \n    vec2 scl = 1./R;\n    \n    for(float i = 0.; i < iter; i++){\n        float g = gauss(i, nd);\n        \n        vec3 l = texture(iChannel1, uv+vec2(0., i*scl.y)).xyz;\n        vec3 r = texture(iChannel1, uv-vec2(0., i*scl.y)).xyz;\n        \n        sum += l*g;\n        sum += r*g;\n    }\n    \n    col += sum*2.;\n    \n    col *= 1.-step(0.48, abs(uv2.y));\n    f = vec4(sqrt(clamp(col, .0, 1.)), 1.);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Buffer A\n\n\n\n// Raymarch!\n\n\n\n\nfloat box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n\nfloat map(vec3 rp){\n    vec3 p = rp - vec3(0.0, -3., 6.0);\n    p.xy *= rot(p.z*.08);\n    \n    vec3 b = vec3(6.4, .1, 6.8);\n    p = mod(p, b)-b*0.5;\n    \n    float h = .5+.5*cos(p.y*3.)*0.4;\n    return box(p, vec3(h, 22., h));\n}\n\n\nvec3 normal( in vec3 pos ){\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\n\nvec3 color(vec3 p, vec3 rd, vec3 n, vec2 u, float t){\n    float fres = smoothstep(-.7, .7, dot(rd, n));\n    vec3 col = fres*0.7*vec3(0.3,0.7,0.9);\n    \n    vec3 sky = mix(vec3(0.6, 0.75, 0.9), vec3(0.9, 0.2, 0.1), length(rd.xy*1.3));\n    col = mix(sky, col, exp(-t*t*t*0.00001));\n    \n\treturn col;   \n}\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    vec3 rd = normalize(vec3(uv, 1. - dot(uv, uv) * -0.5));\n    rd.xy*=rot(iTime*-0.1);\n    \n    vec3 ro = vec3(0., -2., iTime*2.4);\n    \n    float t = 0., d = 0., ns = 0.0;   \n    for(int i = 0; i < 100; i++){\n    \td = map(ro + rd*t); \t   \n        \n        if(abs(d) < .0025 || t > 60.)\n            break;\n        \n        t += d * .8;\n        ns++;\n    }\n    \n    vec3 n = normal(ro + rd*t);\n    vec3 col = color(ro + rd*t, rd, n, u, t);\n    \n    col*=1.23;\n    col = col*col;\n    \n    col = 1.-exp(-col);\n    \n    f = vec4(col, 1.);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Buffer B\n\n// Half of the blur, in the x direction. \n\n  \n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = u / R;\n    \n    vec3 sum = vec3(0);\n    \n    vec2 scl = 1./R;\n    \n    for(float i = 0.; i < iter; i++){\n        float g = gauss(i, nd);\n        \n        vec3 l = texture(iChannel0, uv+vec2(i*scl.x, 0)).xyz;\n        vec3 r = texture(iChannel0, uv-vec2(i*scl.x, 0)).xyz;  \n        \n        l *= l;\n        r *= r;\n        \n        sum += l*g;\n        sum += r*g;\n    }\n    \n    f = vec4(sum, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n\nconst float iter = 27.; // Blur iterations\nconst float nd = iter*.5;\n\n\nfloat gauss(float i, float nd){\n     return exp(-(i*i)/(2.*nd*nd))/sqrt(2.*3.14159*nd*nd);  \n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}