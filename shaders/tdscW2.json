{
    "Shader": {
        "info": {
            "date": "1585669420",
            "description": "yet another mandelbulb - you may have seen this a while ago I just forgot to make it public\n\nuse the mouse to change the point of view",
            "flags": 32,
            "hasliked": 0,
            "id": "tdscW2",
            "likes": 34,
            "name": "Sci-fi mandelbulb",
            "published": 3,
            "tags": [
                "fractal",
                "volume",
                "mandelbulb",
                "volumetric",
                "bloom",
                "scattering",
                "pathtracing",
                "tonemapping"
            ],
            "usePreview": 0,
            "username": "loicvdb",
            "viewed": 1133
        },
        "renderpass": [
            {
                "code": "vec3 ACESFilm(vec3 x) {\n    \n    // ACES system tone scale (RTT+ODT)\n    const float a = .0245786;\n    const float b = -.000090537;\n    const float c = .983729;\n    const float d = .4329510;\n    const float e = .238081;\n    x = (x*(x+a)+b) / (x*(x*c+d)+e);\n    \n    return x;\n}\n\nvec3 bloom(float scale, float threshold, vec2 fragCoord){\n    float logScale = log2(scale)+1.0;\n    \n    vec3 bloom = vec3(0);\n    for(int y = -1; y <= 1; y++)\n        for(int x = -1; x <= 1; x++)\n            bloom += textureLod(iChannel0, (fragCoord+vec2(x, y) * scale)/iResolution.xy, logScale).rgb;\n    \n    return max(bloom/9.0 - vec3(threshold), vec3(0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    \n    vec3 bloomSum = bloom(.15 * iResolution.y, .0, fragCoord)*.3\n        \t\t  + bloom(.05 * iResolution.y, .0, fragCoord)*.2;\n    \n    fragColor = vec4(ACESFilm(col + bloomSum), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define Pi 3.14159265359\n\n#define VolumePrecision .35\n#define SceneRadius 1.5\n#define StepsSkipShadow 4\n#define MaxSteps 500\n#define MaxAbso .7\n#define MaxShadowAbso .7\n\n#define HASH( seed ) fract(cos(seed)*43758.5453)\n#define RANDOM HASH(seed++)\n#define RANDOM2D vec2(RANDOM, RANDOM)\n\nvec3 CamPos = vec3(.0, 0, -15.0);\nvec3 CamRot = vec3(.5, -.5, 0.);\nfloat CamFocalLength = 7.;\nfloat CamFocalDistance = 14.2;\nfloat CamAperture = .3;\n\nvec3 LightColor = vec3(3.);\nvec3 LightDir = normalize(vec3(-1, -.2, 0));\n\nfloat Power = 8.0;\n\nfloat Density = 500.0;\n\nfloat StepSize;\n\nfloat seed;\n\nmat3 rotationMatrix(vec3 rotEuler){\n    float c = cos(rotEuler.x), s = sin(rotEuler.x);\n    mat3 rx = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    c = cos(rotEuler.y), s = sin(rotEuler.y);\n    mat3 ry = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    c = cos(rotEuler.z), s = sin(rotEuler.z);\n    mat3 rz = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    \n    return rz * rx * ry;\n}\n\nfloat maxV(vec3 v){\n    return v.x > v.y ? v.x > v.z ? v.x : v.z : v.y > v.z ? v.y : v.z;\n}\n\nvec3 randomDir(){\n    return vec3(1, 0, 0) * rotationMatrix(vec3(RANDOM2D*2.0*Pi, 0).xzy);\n}\n\nvec3 backgroundColor(vec3 dir){\n    return vec3(0.);\n}\n\nfloat distanceEstimation(vec3 pos, out vec3 volumeColor, out vec3 emissionColor) {\n    \n    vec3 basePos = vec3(0., .0, .0);\n    float scale = 1.;\n    \n    pos /= scale;\n    pos += basePos;\n    \n    volumeColor = vec3(.0);\n    emissionColor = vec3(0.);\n    \n    pos.yz = vec2(pos.z, pos.y);\n    \n    \n    float r = length(pos);\n    vec3 z = pos;\n    vec3 c = pos;\n\tfloat dr = 1.0, theta, phi;\n    vec3 orbitTrap = vec3(1.);\n\tfor (int i = 0; i < 8; i++) {\n\t\tr = length(z);\n\t\tif (r>SceneRadius) break;\n        orbitTrap = min(abs(z)*1.2, orbitTrap);\n\t\ttheta = acos(z.y/r);\n\t\tphi = atan(z.z,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\ttheta *= Power;\n\t\tphi *= Power;\n\t\tz = pow(r,Power)*vec3(sin(theta)*cos(phi), cos(theta), sin(phi)*sin(theta)) + c;\n\t}\n    \n    float dist = 0.5*log(r)*r/dr*scale;\n    \n    volumeColor = (1.-orbitTrap)*.98;\n    emissionColor = vec3(orbitTrap.z < .0001 ? 20. : 0.);\n    \n\treturn dist;\n}\n\nvec3 directLight(vec3 pos){\n    \n    vec3 absorption = vec3(1.0);\n    vec3 volumeColor, emissionColor;\n    \n    for(int i = 0; i < MaxSteps; i++){\n        float dist = distanceEstimation(pos, volumeColor, emissionColor);\n        pos -= LightDir * max(dist, StepSize);\n        if(dist < StepSize) {\n            float abStep = StepSize * RANDOM;\n            pos -= LightDir * (abStep-StepSize);\n            if(dist < 0.0){\n                float absorbance = exp(-Density*abStep);\n                absorption *= absorbance;\n                if(maxV(absorption) < 1.0-MaxShadowAbso) break;\n            }\n        }\n        \n        if(length(pos) > SceneRadius) break;\n    }\n    return LightColor * max((absorption+MaxShadowAbso-1.0) / MaxShadowAbso, vec3(0));\n}\n\nvec3 pathTrace(vec3 rayPos, vec3 rayDir){\n    \n   \trayPos += rayDir * max(length(rayPos)-SceneRadius, 0.0);\n    \n    vec3 outColor = vec3(0.0);\n    vec3 absorption = vec3(1.0);\n    \n    vec3 volumeColor, emissionColor;\n    \n    for(int i = 0; i < MaxSteps; i++){\n        float dist = distanceEstimation(rayPos, volumeColor, emissionColor);\n        rayPos += rayDir * max(dist, StepSize);\n        if(dist < StepSize && length(rayPos) < SceneRadius) {\n            float abStep = StepSize * RANDOM;\n            rayPos += rayDir * (abStep-StepSize);\n            if(dist < 0.0){\n                \n                float absorbance = exp(-Density*abStep);\n                float transmittance = 1.0-absorbance;\n                \n                if(mod(float(i), float(StepsSkipShadow)) == 0.) emissionColor += float(StepsSkipShadow) * volumeColor * directLight(rayPos);\n                \n                outColor += absorption * transmittance * emissionColor;\n                \n                if(maxV(absorption) < 1.0-MaxAbso) break;\n                if(RANDOM > absorbance) {\n                    rayDir = randomDir();\n                    absorption *= volumeColor;\n                }\n            }\n        }\n        \n        if(length(rayPos) > SceneRadius && dot(rayDir, rayPos) > 0.0)\n            return outColor + backgroundColor(rayDir) * absorption;\n    }\n    \n    return outColor;\n}\n\n// n-blade aperture\nvec2 sampleAperture(int nbBlades, float rotation) {\n    \n    float side = sin(Pi / float(nbBlades));\n    vec2 tri = RANDOM2D;\n    if(tri.x-tri.y > 0.0) tri = vec2(tri.x-1.0, 1.0-tri.y);\n    tri *= vec2(side, -sqrt(1.0-side*side));\n    float angle = rotation + 2.*Pi*floor(RANDOM * float(nbBlades))/float(nbBlades);\n    return vec2(tri.x * cos(angle) + tri.y * sin(angle),\n                tri.y * cos(angle) - tri.x * sin(angle));\n}\n\n//used to store values in the unused alpha channel of the buffer\nvoid setVector(int index, vec4 v, vec2 fragCoord, inout vec4 fragColor){\n    fragCoord -= vec2(.5);\n    if(fragCoord.y == float(index)){\n        if(fragCoord.x == 0.0) fragColor.a = v.x;\n        if(fragCoord.x == 1.0) fragColor.a = v.y;\n        if(fragCoord.x == 2.0) fragColor.a = v.z;\n        if(fragCoord.x == 3.0) fragColor.a = v.a;\n    }\n}\n\nvec4 getVector(int index){\n    return vec4(texelFetch(iChannel0, ivec2(0, index), 0).a,\n                texelFetch(iChannel0, ivec2(1, index), 0).a,\n                texelFetch(iChannel0, ivec2(2, index), 0).a,\n                texelFetch(iChannel0, ivec2(3, index), 0).a\n               );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    StepSize = min(1.0/(VolumePrecision*Density), SceneRadius/2.0);\n    \n    seed = sin(iTime) + cos(fragCoord.x) + sin(fragCoord.y);\n    \n    vec2 uv = (fragCoord+RANDOM2D-iResolution.xy/2.0) / iResolution.y;\n    \n    float samples = texelFetch(iChannel0, ivec2(0, 0), 0).a;\n    if(iFrame > 0) CamRot = getVector(1).xyz;\n    vec4 prevMouse = getVector(2);\n    \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    bool mouseDragged = iMouse.z >= 0.0 && prevMouse.z >= 0.0 && iMouse != prevMouse;\n    \n    if(mouseDragged) CamRot.yx += (prevMouse.xy-iMouse.xy)/iResolution.y * 2.0;\n    \n    if(iFrame == 0 || mouseDragged){\n        fragColor = vec4(0.0);\n        samples = 0.0;\n    }\n    \n    setVector(1, vec4(CamRot, 0), fragCoord, fragColor);\n    setVector(2, iMouse, fragCoord, fragColor);\n    if(fragCoord-vec2(.5) == vec2(0)) fragColor.a = samples+1.0;\n    \n    vec3 focalPoint = vec3(uv * CamFocalDistance / CamFocalLength, CamFocalDistance);\n    vec3 aperture = CamAperture * vec3(sampleAperture(5, 0.0), 0.0);\n    vec3 rayDir = normalize(focalPoint-aperture);\n    \n    mat3 CamMatrix = rotationMatrix(CamRot);\n    CamPos *= CamMatrix;\n    rayDir *= CamMatrix;\n    aperture *= CamMatrix;\n    \n    fragColor.rgb = mix(fragColor.rgb,pathTrace(vec3(.0, .0, .0) + CamPos+aperture,rayDir),1.0/(samples+1.0));\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}