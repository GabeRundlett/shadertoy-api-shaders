{
    "Shader": {
        "info": {
            "date": "1645272050",
            "description": "An infinite spiraling flower.\n\nThis runs into problems when petals are >3 stripes in length, but since it works fine in 1080p I don't think it's worth fixing.",
            "flags": 0,
            "hasliked": 0,
            "id": "NdfBDS",
            "likes": 2,
            "name": "Infinite Flower",
            "published": 3,
            "tags": [
                "flower"
            ],
            "usePreview": 0,
            "username": "BryceStansfield",
            "viewed": 161
        },
        "renderpass": [
            {
                "code": "#define PI     3.14159265\n// This code all desperately needs to be cleaned, but this is just a quick sketch\n\nfloat magnitude(in vec2 v){\n    return sqrt(pow(v.x, 2.) + pow(v.y, 2.));\n}\n\nfloat ring_offset(in float time){\n    return time;\n}\n\nfloat ring_num_float(in vec2 v, in float ringSize, in float time){\n    return (magnitude(v) + ring_offset(time)*ringSize)/ringSize;\n}\n\nint ring_num(in vec2 v, in float ringSize, in float time){\n    return int(floor(ring_num_float(v, ringSize, time)));\n}\n\nbool should_print_circle_line(in vec2 v, in float ringSize, in float time, in float lineSize){\n    float ringNum = mod(ring_num_float(v, ringSize, time), 1.0);\n    return ringNum < (lineSize/2.0) || ringNum > (1.0 - lineSize/2.0);\n}\n\nvec4 background_colour(in vec2 v, in float ringSize, in float lineSize, in float time){\n    // Params\n    vec4 colours[6] = vec4[6](\n        vec4(255.0, 128.0, 0.0, 255.0)/255.0,    // Orange\n        vec4(0.0, 0.0, 204.0, 255.0)/255.0,      // Dark Blue\n        vec4(0.0, 204.0, 0.0, 255.0)/255.0,      // Green\n        vec4(102.0, 0.0, 204.0, 255.0)/255.0,    // Purple\n        vec4(255.0, 51.0, 255.0, 255.0)/255.0,   // Pink\n        vec4(102.0, 178.0, 255.0, 255.0)/255.0); // Light Blue\n    int coloursLength = 6;\n    \n    return should_print_circle_line(v, ringSize, time, lineSize) ?\n           vec4(0.0, 0.0, 0.0, 1.0) : colours[ring_num(v, ringSize, time) % coloursLength];\n}\n\nvec4 colour_fallthrough(in vec4 colourOne, in vec4 colourTwo){\n    // Calculates how colourTwo should show through colourOne\n    // Assumes colourTwo.w == 1.0\n    return vec4(colourOne.w * colourOne.xyz + (1.0-colourOne.w) * colourTwo.xyz, 1.0);\n}\n\nfloat angle_distance(in float a1, in float a2){\n    // I desperately need to make this function nicer\n    a1 = mod(a1 + PI, 2.0*PI) - PI;\n    a2 = mod(a2 + PI, 2.0*PI) - PI;\n    return min(min(abs(a2-a1), a2 + 2.0*PI - a1), a1 + 2.0*PI - a2);\n}\n\nbool is_stem(in int numPetals, in float stemRefAngle, in float stemRefAngleTip, in float pointAngle, in float ringNumber, in float tolerance){\n    bool isStem = false;\n    float piDiv = (2.0*PI)/float(numPetals);\n    bool tipEnabled = mod(ringNumber, 1.0) <= 0.5;\n    \n    for(int i = 0; i < numPetals; i++){\n        float refAngle = stemRefAngle + float(i) * piDiv;\n        float refAngleTip = stemRefAngleTip + float(i) * piDiv;\n        isStem = isStem || angle_distance(refAngle, pointAngle) < tolerance;\n        isStem = isStem || (tipEnabled && angle_distance(refAngleTip, pointAngle) < tolerance);\n    }\n    return isStem;\n}\n\nbool is_in_ball(in int numPetals, in vec2 coords, in int ringNumberInt, in float time, in float ringSize, in float stemRefAngleTip, in float angleToMatch){\n    bool isInBall = false;\n    \n    float piDiv = (2.0*PI)/float(numPetals);\n    \n    float ballMidRing = float(ringNumberInt)+0.5 - ring_offset(time);\n    float ballRadius = tan(angleToMatch)*ballMidRing*ringSize;\n    \n    for(int i = 0; i < numPetals; i++){\n        float refAngleTip = stemRefAngleTip + float(i) * piDiv;\n        vec2 ballCentre = vec2(cos(refAngleTip)*ballMidRing*ringSize, sin(refAngleTip)*ballMidRing*ringSize);\n        isInBall = isInBall || magnitude(coords-ballCentre) <= ballRadius;\n    }\n    \n    return isInBall;\n}\nvec4 petals(in vec2 coords, in float ringSize, in float time){\n    // Params\n    int numPetals = 3;\n\n    // Setting up the petal mask\n    float ringNumber = ring_num_float(coords, ringSize, time);\n    int ringNumberInt = int(floor(ringNumber));\n    \n    vec4 petalMask = vec4(1.0, 1.0, 1.0, 1.0);\n    petalMask = petalMask * float(ringNumber >= 1.0);\n    \n    // Is this part of a petal stem?\n    float pointAngle = atan(coords.y, coords.x);\n    float stemRefAngle = PI/3.0 - (float(ringNumberInt)-1.0) * 0.2 + iTime * (0.1 + 0.03 * (float(ringNumberInt) - ring_offset(time)));\n    float stemRefAngleTip = PI/3.0 - (float(ringNumberInt)-2.0) * 0.2 + iTime * (0.1 + 0.03 * (float(ringNumberInt-1) - ring_offset(time)));\n    float stemRefAngleOverhangTip = PI/3.0 - (float(ringNumberInt)-3.0) * 0.2 + iTime * (0.1 + 0.03 * (float(ringNumberInt-2) - ring_offset(time)));\n    \n    bool tipEnabled = mod(ringNumber, 1.0) <= 0.5;\n    float twoPiOnThree = (2.0 * PI)/3.0;\n    \n    bool isStem = is_stem(numPetals, stemRefAngle, stemRefAngleTip, pointAngle, ringNumber, 0.05);\n    petalMask = isStem ? petalMask : vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // What about the petal stems line?\n     \n    bool isStemLine = is_stem(numPetals, stemRefAngle, stemRefAngleTip, pointAngle, ringNumber, 0.06);\n    petalMask = !isStem && isStemLine ? vec4(0.0, 0.0, 0.0, 1.0) : petalMask;\n    \n    // Finally, what about the ball_ends of the petals    \n    bool isInBall = is_in_ball(numPetals, coords, ringNumberInt, time, ringSize, stemRefAngleTip, 0.05);\n    petalMask = isInBall ? vec4(1.0, 1.0, 1.0, 1.0) : petalMask;\n    \n    bool isInBallLine = is_in_ball(numPetals, coords, ringNumberInt, time, ringSize, stemRefAngleTip, 0.06);\n    petalMask = isInBallLine && !isInBall && !isStem ? vec4(0.0, 0.0, 0.0, 1.0) : petalMask;\n    \n    // And what is the ball is too large for 1 stripe, but can fit in two?\n    bool isInBall2 = is_in_ball(numPetals, coords, ringNumberInt-1, time, ringSize, stemRefAngleOverhangTip, 0.05);\n    petalMask = isInBall2 ? vec4(1.0, 1.0, 1.0, 1.0) : petalMask;\n    \n    bool isInBallLine2 = is_in_ball(numPetals, coords, ringNumberInt-1, time, ringSize, stemRefAngleOverhangTip, 0.06);\n    petalMask = isInBallLine2 && !isInBall && !isInBall2 && !isStem ? vec4(0.0, 0.0, 0.0, 1.0) : petalMask;\n    \n    return petalMask;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Params\n    float ringSize = 50.0;\n    float lineSize = 0.05;\n    \n    \n    vec2 centre = iResolution.xy/2.0;\n    \n    \n    // Adjusted coordinates\n    vec2 centreAdjustedCoords = fragCoord - centre;\n    float time = iTime * 0.1 + 1.0;\n    \n\n    // Output to screen\n    fragColor = colour_fallthrough(petals(centreAdjustedCoords, ringSize, time),\n    background_colour(centreAdjustedCoords, ringSize, lineSize, time));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}