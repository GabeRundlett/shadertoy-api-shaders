{
    "Shader": {
        "info": {
            "date": "1585685340",
            "description": "banana ",
            "flags": 40,
            "hasliked": 0,
            "id": "3dXcWf",
            "likes": 8,
            "name": "[sound] Aphrosilia",
            "published": 3,
            "tags": [
                "sound",
                "music",
                "audio"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 594
        },
        "renderpass": [
            {
                "code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n\tfragColor = vec4(0);\n    // Radial blur\n    float steps = 16.;\n    float scale = 0.00 + pow(dot(uvn,uvn),2.1)*0.4;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),1.)*2.2;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1.4/iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor += radial;\n    \n    \n    fragColor.r *= 0.97 + dot(uvn,uvn)*0.6;\n    \n    fragColor.t *= 1.  - smoothstep(0.,1.,dot(uvn,uvn))*0.;\n    \n    \n    fragColor = pow(fragColor, vec4(0.4545));\n    \n\n    fragColor = max(fragColor, 0.);\n    fragColor *= 1. - dot(uvn,uvn)*1.   ;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI acos(-1.)\n\n#define T true\n#define F false\n\n#define init vec2 s = vec2(0)\n#define ret return s\n#define bpm (135./2.)\n\n#define tick (60./bpm)\n\n#define beat (tick)\n#define bar  (beat*4.)\n#define hbar  (bar/2.)\n#define msr  bar*4.\n#define hbeat tick/2.\n#define qbeat tick/4.\n\n\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define TT (tau*t)\n#define tt (tau*t)\n\n#define S vec2 s = vec2(0);\n#define E return s;\n\n#define OFFS (msr*1.)*0.\n\n//float[] probK = float[16](0.1,0.9,0.1,0.9,0.4,0.9,0.1,0.3,0.9,0.4,0.9,0.,0.9,0.1,0.4,0.5);\nfloat[] probK = float[16](0.9,0.1,0.1,0.2,0.,0.1,0.1,0.2,0.9,0.2,0.4,0.2,0.2,0.9,0.4,0.5);\nbool[] pattK = bool[16](F,F,F,T,F,T,T,F,T,F,F,T,F,T,T,F);\nbool[] pattL = bool[16](F,T,F,F,T,F,T,F,T,F,F,T,F,T,T,F);\nbool[] pattS = bool[8](F,T,F,T,F,T,F,T);\nbool[] pattG = bool[8](F,T,F,F,T,F,T,T);\n\n\nfloat[] offsH = float[8](0.02,0.1,0.1,0.02,0.29,0.1,0.0,0.02); \n\n\nfloat[] notesLB = float[8](2.,1.,0.,2.,0.,2.,0.,3.);\nint[] notesB = int[8](0,1,2,3,0,1,2,3);\n\nconst float scale = -4.;\n\nconst vec4 cmin9 = vec4(0.,3.,10.,14.) + scale;\n\nconst vec4 cmin510 = vec4(0.,7.,10.,12.) + scale;\nconst vec4 cmin7 = vec4(0.,3.,7.,10.) + scale;\nconst vec4 cmin73 = vec4(0.,7.,10.,3.) + scale;\nconst vec4 cmin11 = vec4(0.,10.,14.,17.) + scale;\nconst vec4 cmaj9 = vec4(0.,4.,7.,14.) + scale;\nconst vec4 cmaj7 = vec4(0.,4.,7.,11.) + scale;\nconst vec4 cmaj14 = vec4(0.,4.,11.,12. + 7.) + scale;\nconst vec4 cmaj7f15 = vec4(0.,4.,6.,11.) + scale;\nconst vec4 cmaj7d = vec4(0.,4.,7.,10.) + scale;\nconst vec4 cmin7maj = vec4(0.,3.,7.,11.) + scale;\n\nconst int chordCnt = 8;\n\n\nvec4[] chords = vec4[chordCnt](\n    cmin7,\n    cmin73 + 3.,\n    cmaj14 + 1.,\n    cmaj7 - 4.,\n    cmin11,\n    cmaj14 + 1. - 7.,\n    cmaj7 - 1.,\n    cmaj7 + 1.\n);\n\nvec4[] chordsbb = vec4[chordCnt](\n    cmin11,\n    cmaj14 + 2. - 7.,\n    cmin7 - 2.,\n    cmaj7 + 1.,\n    cmaj14 - 3.,\n    cmaj7f15 + 3.,\n    cmin9 + 2. - 4.,\n    cmaj7f15 - 4.\n);\n\nvec4[] chordsb = vec4[chordCnt](\n    cmin9,\n    cmaj7 + 1.,\n    cmaj7f15 - 2.,\n    cmaj7 - 3.,\n    cmaj14 - 2.,\n    cmaj7f15 + 3.,\n    cmaj9 - 1.,\n    cmaj7f15 - 4.\n);\nvec4[] chordsa = vec4[chordCnt](\n    cmin9,\n    cmaj7f15 - 2.,\n    cmaj9 - 3.,\n    cmin7maj - 5.,\n    cmaj14 - 2.,\n    cmaj7f15 + 3.,\n    cmaj9 - 1.,\n    cmaj7f15 - 2.\n);\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// thanks to wyatt for teaching me how to do buffer feedback stuff thru his tutorials\n// if you would like to do something similar, i recommend checking them out\n// the code here is rather messy\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    col = max(col, 0.);\n    #define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d)+ (e)))\n    \n    vec2 puv = vec2(atan(uv.y,uv.x)/6.28, length(uv));\n    \n    puv.y += sin(puv.x*6.28*(7.) + uv.x*20. + iTime  + sin(uv.y*20. + iTime)*6. )*0.004;\n    \n    col += smoothstep(0.,0.01,-puv.y + 0.1);\n    \n    col *= pal(0.,1.5,vec3(0.1,.4,0.7), 1.5, 2. + iTime*2. + puv.y*200.);\n    \n    vec2 nc = fragCoord/iResolution.xy - 100.*(0. + length(puv.y)*2.)*normalize(uv)/iResolution.xy*iTimeDelta;\n\t    \n\tvec2 st = 1./iResolution.xy;\n    \n    vec2 lc = nc;\n    vec4 u = texture(iChannel1, lc + vec2(0,st.y) );\n    vec4 d = texture(iChannel1, lc + vec2(0,-st.y) );\n    vec4 l = texture(iChannel1, lc + vec2(-st.x,0) );\n    vec4 r = texture(iChannel1, lc + vec2(st.x,0) );\n    \n    vec2 ddb = (vec2( r.b - l.b, u.b - d.b));\n    vec2 dd = normalize(vec2( r.r - l.r, u.r - d.r));\n    #define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n    \n    dd *= rot(3.14/2.);\n    ddb *= rot(3.14/2. - 3. - sin(iTime)*0.5 - 0.1);\n    \n    nc += dd*st*0.1;\n    nc -= ddb*st*0.2;\n    \n    if(iFrame > 0)\n    \tcol = mix(col, texture(iChannel1, nc, 0.99).xyz, 0.996);\n    \n    fragColor = vec4(col,1.0);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "float gT;\n    float sc;\nfloat note(float note, float octave){ \n\treturn 27.5*exp2(((octave*12. ) + note )/12.);//pow(2., );\n}\n\nvec4 r11(float x){return texture(iChannel0,vec2(x)/256.);}\nvec2 hash22(vec2 p)   \n{\n    p  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\nvec2 hash22a(vec2 p){\n    p *= 2000.;\n\treturn texture(iChannel0, vec2((p + 1./floor(p/256.)))/256.).xz;\n}\n\nvec2 noise(float t)\n{\n    return hash22(vec2(t, t * 1.423)) * 2.0 - 1.0;\n}\n\nvec2 lpnoise(float t, float fq)\n{\n    t *= fq;\n\n    float ft = fract(t);\n    float tn = t - ft;\n    ft = smoothstep(0.0, 1.0, ft);\n\n    vec2 n0 = noise(floor(tn + 0.0) / fq);\n    vec2 n1 = noise(floor(tn + 1.0) / fq);\n\n    return mix(n0, n1, ft);\n}\n\n#define bitreduction(s,amt) s = sign(s) * floor(abs(s)/amt)*amt\n#define sampleratereduction(t, amt) t = floor(t/(amt))*(amt)\n#define smoothify(s, amt) mix(s,sign(s)*smoothstep(0.0,1.,abs(s)), amt)\n\nvec2[8] N;\n\n\n\nvec2 kick(float t, inout float sc){\n\tinit;\n\t\n    sampleratereduction(t, 0.000006);\n    \n    float md = beat/4.;\n    float pl = 16.;\n    t = mod(t, md*pl);\n    float idx = floor(t/md);\n    t = mod(t, md);\n    \n    float env = exp(-t*40.7);\n    s += sin((exp2(-t*80.1)*340. + 60.)*tt )*env;\n    \n    s = mix(s,sin(s*2.)*1., 0.5);\n    \n    \n    //bitreduction(s, 0.001);\n    \n    //s = sign(s)*smoothstep(0.,1.,abs(s));\n    \n    \n    s = clamp(s,-1., 1.);\n    \n    \n    float att = float(pattK[int(idx)]);\n    s *= att;\n    sc = 1. - pow(env, 0.15)*att;\n    sc = smoothstep(0.,1.,sc);\n    ret;\n}\n\nvec2 snare(float t){\n\tinit;\n    \n    \n    float md = beat;\n    float pl = 8.;\n    t = mod(t, md*pl);\n    float idx = floor(t/md);\n    t = mod(t, md);\n    \n    float env = exp2(-t*70.);\n    \n    vec2 n =lpnoise(t,10000.5);\n    vec2 nb =lpnoise(t,20000.5);\n    float f = 300.+ 500.*exp2(-t*80.)+ n.x*6.5 ;\n    \n    \n    s += sin(f*tt + n.x*0.25 + nb.x*0.5*exp(-t*20.))*env;\n    s += sin(f*tt*4. + n.x*0.25 + nb.x*4.2*exp(-t*10.))*pow(env, 0.8)*0.03;\n    \n    s += (n + nb)*0.05*exp(-t*12.);\n    \n    \n    s *= float(pattS[int(idx)]);\n    ret;\n}\n\nvec2 lead(float t){\n\tinit;\n\t\n    float to;\n    vec2 nn = N[0];\n    nn += N[1]*0.9;\n    nn += N[5]*0.45;\n    nn += N[7]*0.1;\n    \n    \n    vec2 id;\n    float r = bar;\n    \n    t = mod(t, r*float(chordCnt));\n    \n    id.x = floor(t/r);\n    \n    t = mod(t,bar);\n    float reps = 32./8.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \t\n\n    \n    if (gT > msr*2.)\n    \tsampleratereduction(t, (1.2*1./iSampleRate));\n    \n    float amt = 0.9;\n    float env = exp(-t*0.2);\n    \n    \n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    \n    float oct = 6.;\n    s += sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    s += sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 + nn*amt)*env;\n    s -= sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    \n    \n    \n    if (gT > msr*2.)\n    \tbitreduction(s, 0.7);\n    s *= float(pattL[int(id.y)]);\n    \n    \n    s *= 1.;\n    ret;\n}\n\n\nvec2 leadb(float t){\n\tinit;\n\t\n    float to;\n    vec2 nn = N[0];\n    \n    \n    vec2 id;\n    float r = bar;\n    t = mod(t, r*float(chordCnt));\n    \n    id.x = floor(t/r);\n    \n    float att = float(pattL[int( mod(floor(t/(bar/(32./8.))), 8.) )]);\n    t = mod(t,bar);\n    float reps = 32./2.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \t\n\n    if (gT > msr*2.)\n    \tsampleratereduction(t, (1.2*1./iSampleRate));\n    \n    float amt = 0.1;\n    float env = exp(-t*0.2);\n    \n    \n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    \n    float oct = 5.;\n    s += sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    s += sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 + nn*amt)*env;\n    s -= sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    \n    \n    \n    if (gT > msr*2.)\n    \tbitreduction(s, 0.7);\n    s *= 1. - att;\n    \n    \n    s *= 0.05;\n    ret;\n}\n\nvec2 leadc(float t){\n\tinit;\n\t\n    float to;\n    vec2 nn = N[0];\n    \n    \n    vec2 id;\n    float r = bar;\n    t = mod(t, r*float(chordCnt));\n    \n    id.x = floor(t/r);\n    \n    float att = float(pattL[int( mod(floor(t/(bar/(32./8.))), 8.) )]);\n    t = mod(t,bar);\n    float reps = 32./2.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \t\n\n    if (gT > msr*2.)\n    \tsampleratereduction(t, (1.2*1./iSampleRate));\n    \n    float amt = 0.1;\n    float env = exp(-t*0.2);\n    \n    \n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    \n    float oct = 4.;\n    s += sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    s += sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 + nn*amt)*env;\n    s -= sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    \n    \n    \n    if (gT > msr*2.)\n    \tbitreduction(s, 0.7);\n    s *= 1. - att;\n    \n    \n    s *= 0.1;\n    ret;\n}\n\n\n\n\n\n\nvec2 tri(float t,float f){\n    return vec2(abs(fract(f*t) - 0.5));\n}\n\nvec2 bass(float t){\n\tinit;\n\t\n    float to;\n    \n    \t\n    vec2 id;\n    float r = bar;\n    t = mod(t, r*4.);\n    \n    id.x = floor(t/r);\n    \n    t = mod(t,r);\n    float reps = 1.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \n    \n    if(gT < msr*6.){\n    \tsampleratereduction(t, (10./iSampleRate)*2.1);\n    \tsampleratereduction(t, (20./iSampleRate)*0.1);\n    } else if(gT < msr*8.){\n    \tsampleratereduction(t, (10./iSampleRate)*(2.1 + sin(t)));\n    \tsampleratereduction(t, (20./iSampleRate)*0.1);\n    }\n    \n    float env = exp(-t*0.04);\n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    //n += floor(id.y/4.)*12.;\n    \n    s += sin( note(n, 1.) *tt \n             +sin(note(n, 4.) *tt + \n             \t+sin(note(n, 2.) *tt)*exp(-t*0.2)*0.1 \n                 \n                 )*exp(-t*0.5)*0.4\n             +sin(note(n, 1.) *tt + \n             \t+sin(note(n, 10.) *tt)*exp(-t*0.2)*0.\n                 )*exp(-t*0.5)*0.4\n            )*env;\n    \n    \n    s *= 1.;\n    \n    vec2 oS = s;\n    \n    if(gT < msr*4.){\n    \tbitreduction(s, (0.25));\n    }\n    \n    s = mix(oS, s, 0.8);\n    \n    \n    s = sin(s*2.5);\n    \n    s *= 0.7*0.6; // what is maths\n    ret;\n}\n\n\n\nvec2 chord(float t){\n\tinit;\n    \n    \n    float r = bar;\n    t = mod(t, r*float(chordCnt));\n    int id = int(floor(t/r));\n    \n    //sampleratereduction(t, (1./iSampleRate));\n    sampleratereduction(t, 0.00003);\n    \n    vec2 nn = N[1];\n    nn += N[2]*0.9;\n    nn += N[7]*0.45;\n    \n    nn *= 0.01*sin(t);\n    float m = 1.;\n    float width = 15.;\n    s += sin( note(chords[id][1], 4.) *tt + nn.x*1.)*0.5;\n    s += sin( note(chords[id][1], 4.) *tt + nn.x*1.)*0.5;\n    float oct = 3.;\n    for(float i = 0.; i < 4. + min(iSampleRate, 0.); i++){\n        float a = (1. + i/2.);\n    \t//s += sin( note(chords[id].x, 3.) *tt + nn.x)*m;\n    \ts.x += sin( note(chords[id].x, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].y, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].z, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].w, oct) *tt*a + nn.x)*m;\n    \ts.y += sin( note(chords[id].x, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].y, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].z, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].w, oct) *tt*a + nn.y + width)*m;\n    \tm *= 0.5;\n    }\n    \n    //bitreduction(s, 0.01);\n    \n    s *= 0.03;\n    s = sin(s*3.);\n    //s /= 2.;\n    //s = sin(s);\n\tret;\n}\n\n\n\n\nvec2 cguit(float t){\n\tinit;\n    \n    \n    float r = bar;\n    t = mod(t, r*float(chordCnt));\n    int id = int(floor(t/r));\n    \n    \n    float rb = bar/8.;\n    float env = exp(-mod(t, rb)*2.)*float(pattG[int(mod(floor(t/rb*2.), r*4.))]);\n    \n    //sampleratereduction(t, (1./iSampleRate));\n    //sampleratereduction(t, (2./iSampleRate));\n    if(gT < msr*6.)\n    \tsampleratereduction(t, 0.0005);\n    \n    vec2 nn = N[0];\n    nn += N[1]*0.9;\n    nn += N[3]*0.45;\n    \n    nn *= 0.01*sin(t);\n    float m = 1.;\n    float width = 15.;\n    s += sin( note(chords[id][1], 3.) *tt + nn.x*1.);\n    s += sin( note(chords[id][1], 3.) *tt + nn.x*1.);\n    float oct = 3.;  \n    for(float i = 0.; i < 5. + min(iSampleRate, 0.); i++){\n        float a = (1. + i/1.);\n    \t//s += sin( note(chords[id].x, 3.) *tt + nn.x)*m;\n    \ts.x += sin( note(chords[id].x, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].y, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].z, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].w, oct) *tt*a + nn.x)*m;\n    \ts.y += sin( note(chords[id].x, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].y, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].z, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].w, oct) *tt*a + nn.y + width)*m;\n    \tm *= 0.75;\n    }\n    s *= env;\n    if(gT < msr*4.)\n    \tbitreduction(s, 0.4);\n    \n    s *= 0.04;\n    //s = sin(s*3.);\n    //s /= 2.;\n    //s = sin(s);\n\tret;\n}\n\n\nvec2 hats(float t){\n\tinit;\n\t\n    float r = hbeat;\n    t = mod(t + 0., r);\n    \n    float o = offsH[int(mod(floor(t/hbeat), 7.))]*r;\n    t -= o;\n    \n    \n    sampleratereduction(t, 0.0002);\n    vec2 nn = N[0] + N[1]  + N[2] + N[3]  ;\n    \n    float amt = 0.02;\n    float env = exp(-t*7.4);\n    //float f =  sin((12000. )*tt)*exp(-t*0.4)*0.215 +sin((3000. )*tt)*exp(-t*2.)*0.5 + ( 2000. + exp(-t*60.)*100.)*tt +lpnoise(t, 200500.).x*1.;\n    float f =  sin((12000. )*tt)*exp(-t*0.4)*0.215 +sin((3000. )*tt)*exp(-t*2.)*0.5 + ( 3000. + exp(-t*60.)*100.)*tt +lpnoise(t, 2500.).x*1.;\n    s += sin( f )*env;\n    s += amt*sin( f + nn )*env;\n    s -= amt*sin( f )*env;\n    \n    bitreduction(s, 0.5);\n    s *= 1.;\n    s *= min(floor(t) + 1., 1.);\n    ret;\n}\nvec2 hatsb (float t){\n\tinit;\n\t\n    t = mod(t + 0., beat);\n    \n\n    vec2 nn = N[0] + N[1]*0.87  + N[2]*0.6 + N[3]*0.5  ;\n    \n    float amt = 0.5;\n    float env = exp(-t*1.4);\n    float f =  sin(\n        (2000. )*tt)*exp(-t*0.4)*0.215 \n        +sin((4000. )*tt)*exp(-t*2.)*0.5 \n        + ( 1250. + exp(-t*60.)*100.)*tt +N[6].x*1.;\n    s += sin( f )*env;\n    s += amt*sin( f + nn )*env;\n    s -= amt*sin( f )*env;\n    \n    float bitreduction = 0.75;\n    s = sign(s) * floor(abs(s)/bitreduction)*bitreduction;\n    \n    s *= 0.4;\n    ret;\n}\n\nvec2 crash(float t){\n\tinit;\n\t\n    t = mod(t + 0., msr/2.);\n    \n    vec2 nn = N[1];\n    \n    float amt = 2.;\n    float env = exp(-t*0.1);\n    float f =  sin(\n        (2000. )*tt)*exp(-t*0.4)*0.215 \n        +sin((4000. )*tt)*exp(-t*2.)*0.5 \n        + ( 1250. + exp(-t*60.)*100.)*tt +lpnoise(t, 200500.).x*1.;\n    s += sin( f )*env;\n    s += amt*sin( f + nn )*env;\n    s -= amt*sin( f )*env;\n    \n    \n    s *= 0.9;\n    bitreduction(s, 0.9);\n    \n    s *= 0.04;\n    ret;\n}\n\nvec2 cReverb(float t){\n\tinit;\n    \n    if (gT > msr*2.)\n    \tsampleratereduction(t, (8.2*1./iSampleRate));\n    \n    \n    float iters = 100.;\n    float size = 150.;\n    \n    if(gT > msr *8.)\n        iters *= 4.;\n    \n    for(float i = 0.; i < iters + min(iSampleRate, 0.); i++ ){\n        float att = smoothstep(1.,0.9,i/iters);\n    \t//s += lead(t - size*i/iSampleRate + 10000.2*N[int(mod(i,7.))].x/iSampleRate )*(pow(sc,0.9))*att;\n        float m = size*i/iSampleRate + noise(i).x*100./iSampleRate;\n        s += lead(t + m )*(pow(sc,0.9))*att*0.1;\n    \tif (gT > msr*2.)\n\t\t\ts += cguit(t + m);\n        s += leadb(t + m);\n    \tif (gT > msr*2.)\n        \ts += hats(t + m)*(0.2 + pow(sc,1.4))*0.001;\n    }\n    s /= iters;\n    s *= 3.;\n    \n    if (gT > msr*2.)\n    \ts = mix(s,s * (pow(sc,0.9)), 0.5);\n    //bitreduction(s, 0.0001);\n    \n    ret;\n}\n\n\nvoid initKickPatt(float t){\n\t\n    float r = beat/4.;\n    \n    float id = floor(t/r);\n    \n    \n    for(int i = 0; i < 16 + min(int(iSampleRate),0); i++){\n        \n        vec4 r = r11(id + float(i));\n        \n    \tpattK[i] = r.x < probK[i];\n        \n    }\n}\n\n\nvoid initNoise(float t){\n\t\t\n    N[0] = lpnoise(t, 400.);\n    N[1] = lpnoise(t, 500.);\n    N[2] = lpnoise(t, 700.);\n    N[3] = lpnoise(t, 1000.);\n    N[4] = lpnoise(t, 1400.);\n    N[5] = lpnoise(t, 1900.);\n    N[6] = lpnoise(t, 2500.);\n    N[7] = lpnoise(t, 5500.); \n    \n}\nvec2 mainSound( in int samp, float t )\n{\n    t += OFFS;\n    gT = t;\n    //t += msr*4.;\n    vec2 s= vec2(0);\n    \n    initKickPatt(t);\n    initNoise(t);\n\n    \n    vec2 k = kick(t,sc)*1.;\n    vec2 sn = snare(t);\n    \n    vec2 ha = hats(t)*(0.2 + pow(sc,1.4))*0.01;\n    vec2 hb = hatsb(t);\n    \n    vec2 drums = k + sn*1. + ha*3. ;\n    //drums *= 0.5;\n    drums = sin(drums*1.2);\n    //drums = smoothify(drums, 0.2);\n    //vec2 hb= hatsb(t)*(pow(sc,4.4))*0.1;\n    vec2 bass = bass(t)*(pow(sc,2.4))*0.3;\n    vec2 c = chord(t)*(pow(sc,1.))*0.4;\n    vec2 cguit = cguit(t)*(pow(sc,1.))*0.5;\n    vec2 l = lead(t)*(pow(sc,0.9))*0.4;\n    vec2 lb = leadb(t)*(pow(sc,0.9))*0.4;\n    vec2 lc = leadc(t)*(pow(sc,0.9))*0.4;\n\tvec2 cr = crash(t);\n    \n    vec2 rev = cReverb(t);\n    //vec2 lb = leadb(t)*(pow(sc,0.9))*0.1;\n    //vec2 cr = crash(t)*(pow(sc,0.9))*0.1;\n    \n    \n    if(t < msr*2.){\n        if (t < beat){\n        \ts += cr*0.2;\n        }\n        \n        //s += cguit;\n        //s += bass;\n        //s += k;\n        s += lb*0.1;\n        //s += ha*2.;\n        //s += hb*0.1;\n\n        s += rev;\n\n        s += lb;\n    \n        if (t > msr*1.){\n            s += lb;\n            s += cguit*0.4;\n        \t//s += ha*2.;\n            \n        }\n        if (t > msr*1.75){\n        \ts += k;\n        }\n        \n    }else if (t < msr*4.){\n        s += c;\n        s += rev;\n        if (t > msr*4. - msr){\n        \ts += bass;\n            s += cr;\n        \ts += cguit;\n        }\n    } else {\n        s += bass;\n        s += drums;\n        s += rev;\n        s += cguit;\n        s += lc;\n    }\n    \n    s *= 0.2;\n    \n    s = mix(s,sign(s)*smoothstep(0.0,1.,abs(s)), (0.1 + sin(t)*0.)*1.);\n    s = clamp(s,-1.,1.);\n    \n    return s;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}