{
    "Shader": {
        "info": {
            "date": "1634276098",
            "description": "a Sailor Moon-inspired scene",
            "flags": 32,
            "hasliked": 0,
            "id": "fdyXzz",
            "likes": 18,
            "name": "90s Anime Background",
            "published": 3,
            "tags": [
                "sdf",
                "night",
                "city",
                "90s",
                "anime",
                "skyline"
            ],
            "usePreview": 0,
            "username": "Xibanya",
            "viewed": 1182
        },
        "renderpass": [
            {
                "code": "// This shader is inspired by the backgrounds in Sailor Moon\n// this is the first really substantial shader I've written in GLSL.\n// Learned a lot doing this!\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    vec2 duv = texel * vec2(-1., 1.);\n    vec3 col1 = texture(iChannel0, uv + duv).rgb;\n    vec3 col2 = texture(iChannel0, uv - duv).rgb;\n    vec3 col = vec3((col1.r + col2.r) * 0.5, col1.g, col2.b) * 1.3;\n    col = pow(col, vec3(1.5));\n    \n    //noise\n    float n = fract(cos(\n        (sin(uv.x / texel.x) * uv.y / texel.y + iTime * 0.01)\n        * 89.) * 343.4);\n\tcol = mix(col, max(col, n), 0.1);\n    \n    // vignette\n    float vignette = saturate(\n        pow(length(uv * 2. - 1.), 3.) * 0.25);\n    col = mix(col, col * OUTLINE_COLOR, vignette);\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#ifdef GL_OES_standard_derivatives\n    #extension GL_OES_standard_derivatives : enable\n#endif\n#define saturate(x) clamp(x, 0., 1.)\n#define Hash(x) fract(cos(x) * 34214.0)\n\n#define BGUPPER vec3(0.08627451, 0.6509804, 0.7254902)\n#define BGLOWER vec3(0.07058824, 0.427451, 0.5411765)\n#define OVERLAY_COLOR vec3(1.113726, 0.6196079, 0.7529412)\n#define STAR_COLOR vec3(0.28, 0.28, 0.4)\n#define MOON_COLOR vec3(0.7098039, 0.7490196, 0.3058824)\n#define OUTLINE_COLOR vec3(0.0627451, 0.2509804, 0.3098039)\n\nconst vec3 BUILDING_COLOR_0 = vec3(0.06, 0.27, 0.47);\nconst vec3 BUILDING_COLOR_1 = vec3(0.07, 0.27, 0.43);\nconst vec3 BUILDING_COLOR_2 = vec3(0.07, 0.34, 0.48);\nconst vec3 BUILDING_COLOR_3 = vec3(0.07, 0.32, 0.49);\nconst vec3 BUILDING_COLOR_4 = vec3(0.07, 0.33, 0.52);\n\n#define WINDOW_COLOR_0 vec3(0.07058824, 0.3882353, 0.4941177)\n#define WINDOW_COLOR_1 vec3(0.2039216, 1.192157, 0.9960784)\n#define WINDOW_COLOR_2 vec3(0.1960784, 1.262745, 0.9647059)\n#define WINDOW_COLOR_3 vec3(1.283019, 1.207728, 0.3086507)\n\n#define OUTLINE_OFFSET 0.\n#define OUTLINE_THICKNESS 0.009\n#define OUTLINE_THRESHOLD 0.7\n\nstruct Building\n{\n    // xy scale, zw translate\n    vec2 scale;\n    vec2 pos;\n    vec3 color;\n    vec2 wScale;\n    vec2 wPos;\n    vec2 offset;\n    // building grid dimentions\n    // x columns, y rows\n    vec2 dim;\n};\n// Antialiased step\n// https://github.com/glslify/glsl-aastep\nfloat aastep(float threshold, float value) \n{\n    float afwidth = length(\n        vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;\n    return smoothstep(\n        threshold - afwidth, threshold+afwidth, value); \n}\n\nvoid Rotate2D(inout vec2 original, float angle)\n{\n    mat2 r2D = mat2(cos(angle), -sin(angle), \n        sin(angle), cos(angle));\n    original = r2D * original;\n}\nvoid LerpWhiteTo(inout float a, float b, float c)\n{\n    a = mix(a, b, c);\n}\nvoid LerpWhiteTo(inout vec2 a, vec2 b, float c)\n{\n    a = mix(a, b, c);\n}\nvoid LerpWhiteTo(inout vec3 a, vec3 b, float c)\n{\n    a = mix(a, b, c);\n}\nvoid LerpWhiteTo(inout vec3 a, vec3 b, vec3 c)\n{\n    a = mix(a, b, c);\n}\nvoid LerpWhiteTo(inout vec4 a, vec4 b, float c)\n{\n    a = mix(a, b, c);\n}\n// SDF functions from iq\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCircle(vec2 p, float r)\n{\n    return length(p) - r;\n}\nfloat sdBox(in vec2 p, in vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n/////////////////////////////////////////////////////\n///// Skyline functions\n////////////////////////////////////////////////////\n// create moon shape by drawing a circle then \n// taking a bite out of it with a smaller circle\nfloat Moon(vec2 uv)\n{\n   vec2 moonPos = uv + vec2(0.2);\n   float moon = sdCircle(moonPos, 0.15);\n   float crescent = sdCircle(moonPos + vec2(0.05, -0.04), 0.1);\n   return max(-crescent, moon);\n}\n/// put an outline around a SDF rectangle\nvec3 DoOutline(float d, vec3 color)\n{\n    float o = d + OUTLINE_OFFSET;\n    if (o < 0.)\n    {\n        float t = -o / OUTLINE_THICKNESS;\n        t = t * t;\n        color = mix(OUTLINE_COLOR, color, step(OUTLINE_THRESHOLD, t));\n    }\n    return color;\n}\n// rgb is combined color\n// a channel is the distance\nvec4 OutlineBox2D(vec2 uv, vec4 st, vec3 color)\n{\n    float d = sdBox(uv + st.zw, st.xy);\n    color = DoOutline(d, color);\n    return vec4(color, d);\n}\n// draw rows and columns of specified rectangles\n// relative to the uv coords passed in\nfloat DrawWindow(vec2 uv, vec4 st, vec4 windowOffset)\n{\n    float window;\n    float rows = windowOffset.w;\n    float cols = windowOffset.z;\n\n    for (float i = 0.; i < rows; i++)\n    {\n        for (float n = 0.; n < cols; n++)\n        {\n            vec2 offset = vec2(\n                windowOffset.x * n, windowOffset.y * i) + st.zw;\n            float wD = sdBox(uv + offset, st.xy);\n            if (n == 0. && i == 0.) window = wD;\n            else window = min(window, wD);\n        }\n    }\n    return window;\n}\nvoid ApplyWindow(float scene, vec2 uv, Building b,\n    vec3 windowColor, inout vec3 color)\n{\n    uv = uv * b.scale + b.pos;\n    vec4 windowOffset = vec4(b.offset, b.dim);\n    float window = DrawWindow(uv, \n        vec4(b.wScale, b.wPos), windowOffset);\n    window = max(window, scene);\n    float diff = max(scene, -window);\n    color = diff < window? color : windowColor;\n    color = DoOutline(scene, color);\n}\n// draw building w/ windows \nfloat Build(vec2 uv, Building b, vec3 windowColor,\n    inout vec3 color)\n{\n    float scene = sdBox(uv + b.pos, b.scale);\n    color = DoOutline(scene, b.color);\n    ApplyWindow(scene, uv, b, windowColor, color);\n    return scene;\n}\n// draws tiling bubbles\nfloat Bubble(vec2 uv, vec2 offset, float margin)\n{\n    float wrap = step(\n        mod(floor(uv.y / margin + 0.5) + offset.y, 2.0), 0.);\n\tuv.x += margin * wrap; \n\tuv = mod(uv + 0.5 * margin + offset, margin) - 0.5 * margin;\n\n\tfloat circle = sdCircle(uv, 0.005);\n\tcircle =  1. - saturate(circle);\n    // want to invert the circle so it is brighter on the edges\n    // but also don't want to invert the entire scene or everything\n    // except the bubble would get covered\n    // so mask the inverted bubble\n    float mask = aastep(0.01, circle);\n    return max(0., (1. - circle) * mask);\n}\n\n/////////////////////////////////////////////////////////\n// star functions adapted from \n// https://www.shadertoy.com/view/ssK3Dt by Scintoth\nfloat noiseFloat(vec2 p)\n{\n    p = fract(p * vec2(1000. * 0.21353, 1000. * 0.97019));\n    p = p + dot(p, p + 1000. * 0.54823);\n    return fract(p.x * p.y);\n}\nvec2 noiseVector(vec2 p)\n{\n    float n = noiseFloat(p);\n    return vec2(n, noiseFloat(p + n));\n}\nvec2 GetPos(vec2 id, vec2 offsets, float time)\n{\n    vec2 n = noiseVector(id + offsets) * 500. * \n        ((8000. + time) / (1000. * 50.));\n    return (sin(n) * 0.9) + offsets;\n}\nfloat Stars(vec2 uv, float time, float gain)\n{\n    uv -= 1.;\n    float m = 0.;\n    uv = uv * 10.;\n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    vec2 p[9];\n    int n = 0;\n    for (float y = -1.; y <= 1.; y++)\n    {\n        for (float x = -1.; x <= 1.; x++)\n        {\n            p[n++] = GetPos(id, vec2(x, y), time);\n        }\n    }\n    for (int i=0; i < 9; i++)\n    {\n        vec2 j = (p[i] - gv) * 2.0;\n        float sparkle = 0.1/dot(j, j) * (gain / (8000.0 + time));\n        m = m + sparkle * (sin(((8000.0 + time)+p[i].x)* 0.5)*0.5 + 0.9);\n    }\n    return m;\n}\n//////////////////////////\nfloat Voronoi(vec2 uv)\n{\n\tvec2 i = floor(uv);\n\tvec2 f = fract(uv);\n\n\tfloat d = 64.;\n\tfor(float y = -1.; y <= 1.; ++y)\n\t{\n\t\tfor (int x = -1; x <= 1; ++x)\n\t\t{\n\t\t\tvec2 b = vec2(x, y);\n            float vNoise = fract(sin(\n                dot(i + b, vec2(101.9364, 96.45418))\n                ) * 100000.0);\n\t\t\tvec2 c = b + vNoise - f;\n\t\t\td = min(d, dot(c, c));\n\t\t}\n\t}\n\treturn sqrt(d);\n}\n\n/////////// FBM ///////////////\n// see: https://thebookofshaders.com/13/\nfloat FBMRandom(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) *\n                    43758.5453123);\n}\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat FBMNoise(in vec2 st)\n{\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = FBMRandom(i);\n    float b = FBMRandom(i + vec2(1.0, 0.0));\n    float c = FBMRandom(i + vec2(0.0, 1.0));\n    float d = FBMRandom(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n           (c - a) * u.y * (1.0 - u.x) +\n           (d - b) * u.x * u.y;\n}\nfloat FBM(vec2 st, float octaves)\n{\n    float value = 0.;\n    float amplitude = 0.5;\n    float frequency = 0.;\n    for (float i = 0.; i < octaves; i++)\n    {\n        value += amplitude * FBMNoise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n///////////////////////////////////////////\n// Perlin \n// see: https://thebookofshaders.com/11/\nfloat SmoothCos(float a, float b, float x)\n{\n    float f = (1. - cos(x * 3.1415927)) * 0.5;\n    return a * (1. - f) + b * f;\n}\n// params.x = precision, params.y = octaves\nfloat Perlin(vec2 uv, vec2 params)\n{\n    float p = 0.;\n    float t = params.x;\n    for (float i = 0.; i < params.y; i++)\n    {\n        float a = FBMRandom(vec2(floor(t * uv.x) / t, floor(t * uv.y) / t));\t   \n        float b = FBMRandom(vec2(ceil (t * uv.x) / t, floor(t * uv.y) / t));\t\t\n        float c = FBMRandom(vec2(floor(t * uv.x) / t, ceil (t * uv.y) / t));\t\t\n        float d = FBMRandom(vec2(ceil (t * uv.x) / t, ceil (t * uv.y) / t));\n        if ((ceil(t * uv.x) / t) == 1.)\n        {\n            b = FBMRandom(vec2(0., floor(t * uv.y) / t));\n            d = FBMRandom(vec2(0., ceil(t * uv.y) / t));\n        }\n        float coef1 = fract(t * uv.x);\n        float coef2 = fract(t * uv.y);\n        p += SmoothCos(\n                SmoothCos(a, b, coef1),\n                SmoothCos(c, d, coef1),\n                coef2\n                ) * (1. / pow(2., (i + 0.6)));\n        t *= 2.;\n    }\n    return p;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec3 WindowFBM(vec2 uv)\n{\n    vec2 st = uv * 2.;\n    float time = iTime * 0.2;\n    vec2 q = vec2(FBM(st + time, 8.), FBM(st + 1., 8.));\n    vec2 r = vec2(\n        FBM(st + q + vec2(1.7, 9.2) + 0.15 * time, 8.),\n        FBM(st + q + vec2(8.3, 2.8) + 0.126 * time, 8.)\n    );\n    float f = FBM(st + r, 8.);\n    float next = saturate((f * f) * 4.);\n    vec3 color = mix(WINDOW_COLOR_0, WINDOW_COLOR_1, next);\n    next =  saturate(length(q));\n    LerpWhiteTo(color, WINDOW_COLOR_2, next);\n    next = saturate(length(r.x));\n    LerpWhiteTo(color, WINDOW_COLOR_3, next);\n\n    float finalFactor = (f * f * f + 0.6 * f * f + 0.5 * f);\n    return mix(WINDOW_COLOR_0, color, saturate(finalFactor));\n}\n\nfloat Buildings(vec2 uv, out vec3 color)\n{\n    Building[5] buildings = Building[5]\n    (\n        // long thin windows\n        Building(\n            vec2(0.25, 0.85), vec2(0.406, 0.5),\n            BUILDING_COLOR_0,\n            vec2(0.00275, 0.08), vec2(-0.358, -0.65),\n            vec2(0.0105, 0.18), vec2(11, 9)\n        ),\n        // many small windows with small gap\n        Building(\n            vec2(0.25, 0.94), vec2(-0.56, 1.1),\n            BUILDING_COLOR_1,\n            vec2(0.006, 0.04), vec2(0.37, -0.835),\n            vec2(0.014, 0.12), vec2(8, 9)\n        ),\n        // square windows\n        Building(\n            vec2(0.27, 0.94), vec2(-0.09, 0.87),\n            BUILDING_COLOR_2,\n            vec2(0.01, 0.04), vec2(0.025, -0.8351),\n            vec2(0.03, 0.12), vec2(6, 9)\n        ),\n        // lerger wide windows, small gap\n        Building(\n            vec2(0.27, 0.73), vec2(.78, 0.71),\n            BUILDING_COLOR_3,\n            vec2(0.02, 0.025), vec2(-0.66, -0.66),\n            vec2(0.045, 0.07), vec2(4, 11)\n        ),\n        // vertically thin horizontally wide windows\n        Building(\n            vec2(0.38, 0.5), vec2(-1., 0.5),\n            BUILDING_COLOR_4,\n            vec2(0.02, 0.01), vec2(0.52, -0.45),\n            vec2(0.05, 0.05), vec2(5, 11)\n        )\n    );\n    // cache the window color so I don't\n    // have to recalculate it for every building\n    vec3 windowColor = WindowFBM(uv);\n    uv = uv * vec2(1.5, 2) + vec2(1.5, 0.8);\n    float scene = Build(uv, buildings[0], windowColor, color);\n    \n    for (int i = 1; i < 5; i++)\n    {\n        vec3 bColor;\n        float b = max(\n            Build(uv, buildings[i], windowColor, bColor), \n            -scene); \n        color = scene < b ? color : bColor;\n        scene = min(scene, b);\n    }\n    \n    // repeating some buildings to fill in the gaps!\n    vec3 bColor;\n    float b = max(Build(uv + vec2(-1.9, 0.5), \n        buildings[0], windowColor, bColor), -scene); \n    LerpWhiteTo(bColor, OUTLINE_COLOR, 0.5);\n    color = scene < b ? color : bColor;\n    scene = min(scene, b);\n    \n    b = max(Build(uv + vec2(1.7, 0.1), buildings[1], \n        windowColor, bColor), -scene); \n    LerpWhiteTo(bColor, OUTLINE_COLOR, 0.5);\n    color = scene < b ? color : bColor;\n    scene = min(scene, b);\n    return scene;\n}\n\nvec4 Bubbles(vec2 uv)\n{\n    uv = uv * vec2(5.);\n    vec2 wUV = uv * vec2(2., 2.) + iMouse.xy * 0.25;\n    // it's just a bunch of tiling circles but I \n    // rotate the UVs and space the repetition \n    // out so that it seems more random\n    Rotate2D(wUV, -25.);\n    \n    // using this to make the bubble edges wobble\n    vec2 perlin = vec2(Perlin(uv, vec2(1., 8.)));\n    \n    wUV += perlin * 0.2;\n    float wc = Bubble(\n        wUV, \n        vec2(-1., 2.) + iTime * 0.25, 8.);\n    vec4 wcColor = vec4(2.6, 1.2, 1.7, 1.) * 0.35 * wc;\n\n    wUV = uv * vec2(4.) - iMouse.xy * 0.1;\n    Rotate2D(wUV, 151.);\n    wUV -= perlin;\n    wc = Bubble(wUV, vec2(-16., 3.) + iTime * 0.5, 16.);\n    LerpWhiteTo(wcColor, vec4(3.9, 2.9, 1.2, 1) * 0.35, wc);  \n    \n    wUV = uv * vec2(2.5) + iMouse.xy * 0.15;\n    Rotate2D(wUV, - 0.36);\n    wUV += perlin * vec2(.75, -.75);\n    wc = Bubble(wUV, vec2(-4.5, 2.) - iTime * 0.25, 30.5);\n    LerpWhiteTo(wcColor, vec4(3.9, 2.6, 1.2, 1) * 0.3, wc);\n    \n    wUV = uv * vec2(1.5) + iMouse.xy * 0.1;\n    Rotate2D(wUV, 24.2);\n    wUV += perlin * 0.1;\n    wc = Bubble(wUV, vec2(1.6, 6.) + iTime * 0.25, 12.);\n    LerpWhiteTo(wcColor, vec4(1.9, 1.1, 2.6, 1) * 0.25, wc);\n    \n    return wcColor;\n}\nfloat Water(vec2 uv, out vec3 color)\n{\n    color = vec3(0.086, 0.651, 0.725) * \n        smoothstep(0.15, -0.05, saturate(uv.y));\n    uv *= 2.;\n    // the reflection highlight is just one of the bubbles\n    // really stretched out\n    vec2 perlin = vec2(Perlin(uv + vec2(0.05) * iTime, vec2(5., 8.)));\n    vec3 highlight = MOON_COLOR * 1.2;\n    float circle = sdCircle(\n        uv * vec2(.4, 6.) + vec2(1.3, 11.5) - perlin, \n        0.00005);\n\tcircle =  1. - saturate(circle);\n    float mask = aastep(0.01, circle);\n    circle = max(0., (1. - circle) * mask);\n    LerpWhiteTo(color, highlight, circle * 0.25);\n    \n    float x = uv.x * 1.0 + Hash(floor(uv.y * 30.)) * iTime * 0.01;\n    float stars = Stars(uv * vec2(2., 2.5) + \n        vec2(iTime * -0.1, 0.), iTime * 0.2, 1000.0);\n    stars *= aastep(0.5, Hash(floor(x * 30.)) * \n        aastep(0.8, fract(x * 30.)));\n    LerpWhiteTo(color, STAR_COLOR * 5., saturate(stars));\n    float scene = sdBox(uv + vec2(0., 1.9), vec2(4., 0.1));\n    color = DoOutline(scene, color);\n  \n    return scene;\n}\n\nvec3 DrawScene(vec2 fragCoord)\n{\n    float y = dot(fragCoord.y / iResolution.y, 1.);\n    vec2 uv = (fragCoord - 1. * iResolution.xy) / iResolution.y;\n    float bgBlend = smoothstep(0.4, 0.8, y);\n    vec2 bgUV = uv * vec2(3.9, 1.15) + vec2(0.5, 0) * iTime * 0.25;\n    bgBlend *= Voronoi(bgUV);\n    vec3 col = mix(BGLOWER, BGUPPER, saturate(bgBlend));\n    \n    float stars = Stars(uv, iTime, 75.0);\n    LerpWhiteTo(col, STAR_COLOR * 6., saturate(stars));\n    \n    float moon = Moon(uv);\n    moon = 1. - aastep(0.001, moon);\n    LerpWhiteTo(col, MOON_COLOR, moon);\n    \n    vec3 bColor;\n    float bd = Buildings(uv, bColor);\n    LerpWhiteTo(col, bColor, saturate(1. - sign(bd)));\n    \n    float overlay = smoothstep(.6, -0.1, y);\n    LerpWhiteTo(col, OVERLAY_COLOR, overlay);\n    \n    vec3 wColor;\n    float waterDist = Water(uv, wColor);\n    LerpWhiteTo(col, wColor, saturate(1. - sign(waterDist)));\n    \n    vec4 bubbles = Bubbles(uv);\n    LerpWhiteTo(col, bubbles.rgb * 4., saturate(bubbles.a));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = DrawScene(fragCoord.xy);\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}