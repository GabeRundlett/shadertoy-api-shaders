{
    "Shader": {
        "info": {
            "date": "1487689957",
            "description": "Nothing complicated here.\nNewer version: https://www.shadertoy.com/view/ldfyzl",
            "flags": 0,
            "hasliked": 0,
            "id": "XslcWn",
            "likes": 24,
            "name": "Rainy mood",
            "published": 3,
            "tags": [
                "2d",
                "rain",
                "ripple",
                "hash"
            ],
            "usePreview": 1,
            "username": "Zavie",
            "viewed": 2383
        },
        "renderpass": [
            {
                "code": "/*\n\nJust a quick experiment with rain drop ripples.\n\nThis shader uses partial derivatives (dFdx and dFdy) to evaluate\nthe normal. This is already a limited approximation, but it gets\nworse as WebGL only has coarse derivatives. This is what causes\nthe pixelated appearance.\nIn OpenGL using dFdxFine and dFdyFine should give slightly better\nresults.\n\nA better version of this shader that doesn't use partial derivatives\nis available here:\nhttps://www.shadertoy.com/view/ldfyzl\n\n-- \nZavie\n\n*/\n\n// Maximum number of cells a ripple can cross.\n#define MAX_RADIUS 2\n\n// Set to 1 to hash twice. Slower, but less patterns.\n#define DOUBLE_HASH 0\n\n// Hash functions shamefully stolen from:\n// https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float resolution = 10. * exp2(-3.*iMouse.x/iResolution.x);\n\tvec2 uv = fragCoord.xy / iResolution.y * resolution;\n    vec2 p0 = floor(uv);\n\n    float circles = 0.;\n    for (int j = -MAX_RADIUS; j <= MAX_RADIUS; ++j)\n    {\n        for (int i = -MAX_RADIUS; i <= MAX_RADIUS; ++i)\n        {\n\t\t\tvec2 pi = p0 + vec2(i, j);\n            #if DOUBLE_HASH\n            vec2 h = hash22(pi);\n            #else\n            vec2 h = pi;\n            #endif\n            vec2 p = pi + hash22(h);\n\n            float t = fract(0.3*iTime + hash12(h));\n            float d = length(p - uv) - (float(MAX_RADIUS) + 1.)*t;\n\n            circles += (1. - t) * (1. - t)\n                * mix(sin(31.*d) * 0.5 + 0.5, 1., 0.1)\n                * smoothstep(-0.6, -0.3, d)\n                * smoothstep(0., -0.3, d);\n        }\n    }\n\n    float intensity = mix(0.01, 0.15, smoothstep(0.1, 0.6, abs(fract(0.05*iTime + 0.5)*2.-1.)));\n    vec3 n = vec3(dFdx(circles), dFdy(circles), 0.);\n    n.z = sqrt(1. - dot(n.xy, n.xy));\n    vec3 color = texture(iChannel0, uv/resolution - intensity*n.xy).rgb + 5.*pow(clamp(dot(n, normalize(vec3(1., 0.7, 0.5))), 0., 1.), 6.);\n\tfragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}