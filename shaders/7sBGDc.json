{
    "Shader": {
        "info": {
            "date": "1618069790",
            "description": "potate",
            "flags": 0,
            "hasliked": 0,
            "id": "7sBGDc",
            "likes": 32,
            "name": "Day 478",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 539
        },
        "renderpass": [
            {
                "code": "\nvec2 map(vec3 p){\n    vec2 d = vec2(10e5);\n    \n    p.yz *= rot(1.*pow(max(sin(iTime*0.25),0.),4.));\n\n    float n = noise(p*14. + vec3(0,iTime*2.1,0));\n    \n    for(float i = 0.; i < 18.; i++){\n        vec3 q = p;\n        q.z += sin(i*5.)*0.2;\n        float dsp = sin(q.y*10. + iTime + i + sin(i*6. + iTime))*0.06 + cos(q.y*6. + iTime*1.5 + i*17.)*0.07 + sin(i*4.)*0.5;\n        q.x -= dsp;\n        float da = length(q.xz) - 0.01 - abs(sin(i +iTime*0.2))*0.02;\n        vec2 cd = vec2(da,1.);\n        cd = dminb(cd,vec2(da - n*0.04 -0.01 ,2.));\n        cd.x = fOpDifferenceRound (cd.x, -p.y + 2.*sin(iTime + 13.*i + sin(i*46. + iTime) )*0.2 + 0.3, 0.15);\n        \n        d = dmin(d,cd,q);\n    }\n    return d;  \n}\n\nvec3 pal(float m){\n    vec3 c = 0.5+0.5*sin(m + vec3(1.5,0.,-0.5));\n    c = pow(c, vec3( .5));\n    \n    return c;\n}\n\nfloat r11(float a){return fract(sin(a*142.5)*16.5);}\nfloat r21(vec2 a) {return fract(r11(a.x) + 3.*r11(a.y*1.2 - a.x + 2.));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    float pxsz = fwidth(uv.x);\n\n    vec3 col = vec3(0.95);\n    vec3 ocol = col;\n    \n    {\n        vec2 p = uv;\n        p.y += iTime*0.1 + sin(iTime)*0.05;\n        float md = 0.1;\n        vec2 id = floor(p/md);\n        p = pmod(p,md);\n        float d = abs(p.y);\n        d = min(d,abs(p.x));\n        float m = sin(id.y + iTime + cos(id.x*20. +sin(id.y + iTime*0.5)*13.))*0.04;\n        d -= m*0.03;\n        d = max(d,-abs(length(p) - 0.01 -m) + 0.04);\n        col = mix(col,vec3(0.1,0.4,0.5)*1.4,smoothstep(pxsz,0.,d));\n        //col = mix(col,vec3(0.6,0.7,0.4)*2.*col,col*smoothstep(pxsz,0.,uv.y + 0.3 + 0.04*7.*noise(vec3(uv*4.,1. + iTime))));\n        \n    }\n    \n    {\n    \n    }\n            vec2 p = uv;\n            \n            p.y += iTime*0.1;\n            float md = 0.02;\n            float mdb = 8.*md;\n            \n            vec2 ida = floor(p/md);\n            vec2 idb = floor(p/mdb);\n            \n            //p = pmod(p,md);\n            col = mix(col,pal(r21(idb)*5. + iTime) + 0.4,smoothstep(0.9,1.,\n                smoothstep(0.8,0.85,\n                    abs(ida.x*md + sin(ida.x)*.2))\n                    *sin(r21(ida)*20. + iTime*5. + cos(ida.y*20.)*6.))\n                    *sin( r21(idb)*20. + 1.*iTime)\n                    );\n            \n         \n    {\n    \n        vec3 ro = vec3(0,0,-1.);\n        vec3 rd = normalize(vec3(uv,1));\n        vec3 p = ro;\n        float t = 0.;\n        bool hit = false;\n        vec2 d;\n        for(int i = 0; i < 60; i++){\n            d = map(p);\n            if(d.x < 0.001){\n                hit = true;\n                break;\n            }\n            p = ro + rd*(t+=d.x*0.6);\n        }\n        \n        \n        if(hit){\n            vec3 ca = mix(ocol,vec3(0.1,0.4,0.5)*0.5,smoothstep(-0.1,0.6,P.x)*2.);\n            if(d.y == 1.){\n                col = ca;\n            } else if(d.y == 2.){\n               \n               //col += smoothstep(-0.1,0.6,P.x)*pal(P.y*5.);\n                \n                \n                col = mix(ca,pal(P.y*5.),smoothstep(0.01,0.16,length(P.xz)));\n            }\n            \n        }\n    }\n    \n    {\n        vec2 p = uv;\n        float md = 0.05;\n        \n        p.x -= 0.7 + md*1.;\n        p.y -= md*0.5+0.2;\n        vec2 id = floor(p/md);\n        p = pmod(p,md);\n        float d = (length(p ) - 0.02);\n        \n        float cnd = float(abs(id.x) == 0. && abs(id.y) < 4.);\n        \n        vec3 c = pal(id.y*1.5 + iTime + d*4.);\n        \n        d = 0.;\n        col = mix(col,col*0.7*c,cnd*smoothstep(0.03,-0.1,d));\n        //col *= 0. + cnd*mix(col*0.1,col,smoothstep(-0.1,0.04,d))+ (1.-cnd)*1.;\n        \n        col = mix(col,c+ 0.3,cnd*smoothstep(pxsz,0.,d));\n        \n        float db = 10e5;\n        for(float i = 0.; i <3.; i++ ){\n            float w = (sin(iTime/3.14*2.+ i ));\n            w = pow(max(w,0.),0.5);\n            db = xor(db,abs(length(uv + vec2(sin(i+iTime + sin(iTime + i)),0.)*0.4 ) - 0.2*w + 0.01)- 0.01);\n        \n        }\n        col = mix(col,6.*(1.-col + 0.1)*mix(pal(uv.x*4. + iTime + sin(iTime)),vec3(1),0.5),smoothstep(pxsz,0.,db) );\n        \n        \n        //col = mix(col,pal(uv.x*2.)*vec3(0.6,0.7,0.4)*2.*col,col*smoothstep(pxsz,0.,uv.y + 0.6 + 0.04*7.*noise(vec3(uv*9.,1. + iTime))));\n        \n        \n    }\n    \n    {\n        vec2 p = uv;\n        vec2 md = vec2(0.08,0.05);\n        \n        p.x += 0.67 + md.x*1.;\n        p.y += md.y*0.5+0.2;\n        \n        vec3 c = vec3(0.3,0.35,0.46)*col*2. + (0.4-col*0.5)*1.4;\n        c = c*2.*(1.-col);\n        c = max(c,0.6);\n        \n        vec3 oc = c*4.*(1.-col + 0.3);\n        c =  (pal(uv.y*11. + iTime*1.) + 0.5)*c*1.5*(col*1.);\n        \n        {\n            vec2 id = floor(p/md);\n            vec2 q = pmod(p,md);\n            float d = sdBox(q, vec2(0.1,0.002));\n            \n            d = xor(d,sdBox(q + vec2(+ sin(4.*id.y + iTime*3. + sin(id.y + iTime))*0.04,0.), vec2(0.02 ,0.01)));\n            \n            d = xor(d,0.0+sdBox(p - 0.01 , vec2(0.01 ,0.6)));\n            \n            \n            float cnd = float(abs(id.x) == 0. && abs(id.y) < 4.);\n            \n            col = mix(col,c,cnd*smoothstep(pxsz,0.,d));\n        \n            float od = d;\n            \n            d = sdBox(p - vec2(-0.022,0) , vec2(0.01 ,0.2));\n            \n            d = min(d,xor(d,sdBox(p - vec2(-0.022,0) , vec2(0.001 ,0.5))));\n            d = min(d,xor(d,sdBox(p - vec2(-0.06,0) , vec2(0.001 ,0.3))));\n            d = min(d,xor(d,sdBox(p - vec2(-0.05,0) , vec2(0.046 ,0.3))));\n            //d = min(d,xor(d,sdBox(p - vec2(-0.1,0.3) , vec2(0.02 ,0.1))));\n            //d = abs(d) - 0.001;\n            \n            \n            col = mix(col,c,smoothstep(pxsz,0.,d));\n        \n            float db = sdBox(uv + vec2(0.01,0.401) , vec2(0.6 ,0.015));\n            col = mix(col,oc,smoothstep(pxsz,0.,db));\n            \n        }\n        \n        //d = min(d, sdBox(uv + vec2(0.1), vec2(0.0,0.04)));\n        \n    }\n    \n    if(iMouse.z > 0. ){\n        col = max(6.*(1.-col + 0.1)*mix(pal(uv.x*4. + iTime + sin(iTime)),vec3(1),0.5),0.4);\n    \n    }\n    col =abs(col);\n    \n    //col = 1.-exp(-col*1.4);\n    //col = smoothstep(0.,1.,col);\n    //col = smoothstep(0.,1.,col);\n    col = pow(col,vec3(0.5545));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec3 P;\n\n#define iTime (iTime - 4.)\n#define dminb(a,b) a.x < b.x ? a : b\n\n#define xor(a,b) min(max(a,-(b)),max(b,-(a) +0.02))\n\nvec2 dmin(vec2 a, vec2 b,vec3 q){\n    vec2 d = a.x < b.x ? a : b;\n    if(d.x == a.x){\n    \n    } else {\n        P = q;\n    }\n    return d;\n}\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,a) mod(p,a) - 0.5*a\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\n\nfloat sdBox(vec2 p, vec2 s){p = abs(p) -s; return max(p.y,p.x);}\n\nfloat noise(vec3 p){\n    float n = 0.;\n    float amp = 1.;\n    for(int i = 0; i < 2; i++){\n        p.xy *= rot(0.5);\n        p.yz *= rot(0.5);\n        \n        n += dot(sin(p),cos(p))*amp;\n        p *= 1.5;\n        amp *= 0.6;\n    }\n    return n;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}