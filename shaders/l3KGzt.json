{
    "Shader": {
        "info": {
            "date": "1718103999",
            "description": "/*\nADMINS PLS view mail.. very need\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "l3KGzt",
            "likes": 4,
            "name": "eye with  light",
            "published": 3,
            "tags": [
                "fractal",
                "eye",
                "magic",
                "cindeshader"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 128
        },
        "renderpass": [
            {
                "code": "\n/*sourses /*originals source https://glslsandbox.com/e#108261.0 https://www.shadertoy.com/view/4tyfWy and other\ncombination from many sources I’m just learning myself\n\njust like 2*2=4, everyone here didn’t become evil, they didn’t cut off their legs,\nthey didn’t drink blood. At least someone gets income, \nlet my income multiply. At the same time, let not the good of \nothers be taken away when my good multiplies.\nAnd they thank the Lord, but not me = D I receive all the good things\n\n*/\n\n#define speed          ( 3./8. )               // generell speed\n#define speedRotation  ( 0./1. )               // speed of rotation, you can use zero\n#define maxDist        ( 9./1. )               // the maximum distance of the sorrounding circles to the center one\n#define useGlow          1                     // 0 or 1 -> for smooth tail/glow effect          \n#define antiAliasing\t 2\n\t\t\t\t\t\t\t// ..every speed option normalized to 1 second.\n// stuff\nprecision highp float;\n\n#define time iTime*speedRotation\n#define AA antiAliasing\n\n\n#define resolution iResolution.xy\n\n#define rot( a )\tmat2( cos(a), -sin(a), sin(a), cos(a) )\n\n#define tau             6.28318530718\n#define ncos( a )       ( cos( a*tau )*.5 + .5 )\n#define nsin( a )       ( sin( a*tau )*.5 + .5 )\n#define phi             1.6180339\nfloat c = 0.0;           // the color variable\n\nfloat circle( vec2 p, float r )  { return step( length( p ), r); }\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 332442342234234244.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n#define PI 3.14159265\n\n#define MOD3 vec3(443.8975, 397.2973, 491.1871) // uv range\nfloat hash11(float p) {\n\tvec3 p3  = fract(vec3(p) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.191);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat sHash11(float a) {\n    return\n        mix(\n            hash11(floor(a)),\n            hash11(floor(a)+1.),\n            smoothstep(0., 1., fract(a))\n        );\n}\n\n//\tClassic Perlin 2D Noise \n//\tby Stefan Gustavson\n//\n//  repetition of x added - stb\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec2 P, float rep){\n    P.x = mod(P.x, rep); // x rep 1/2\n  \n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    \n    Pi.z = mod(Pi.z, rep); // x rep 2/2\n  \n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n\n\nfloat Eye(vec2 p, float pupil, vec2 lpos) {\n\tpupil += .1*(1.-length(lpos))-.1;\n\t\n\t\n\t//lpos.x = sin(time);\n\t\n\t// radial coords\n\tvec2 pr = vec2(atan(p.x, p.y) / PI / 2., clamp((length(p)-1.)/pupil+.8, 0., 1.));\n\t\n\t// smooth curve from pupil to outer iris\n\tpr.y = smoothstep(0., 1., pr.y);\n\t\n\t// noise frequency for radial coords\n\tvec2 freq = vec2(30., 1.5);\n\t\n\t// radial noise\n\tfloat f = pow((cnoise(pr*freq, freq.x)+1.)/4., .5);\n\t\n\t// more radial noise\n\tf -= 1.*pow((cnoise(pr*freq*vec2(2., 3.)+9., 2.*freq.x)+1.)/2.-.5, 2.);\n\t\n\t//vec2 lpos = vec2(.5, .75);\n\t\n\t// general shading\n\tfloat shade = dot(p, lpos);\n\t\n\t// lightening of iris\n\tf -= .7 * shade;\n\t\n\t// darker inner iris & pupil\n\tf *= pow(smoothstep(0., .5, pr.y), .15);\n\t\n\t// darker ring around iris\n\tf = mix(f, .25, smoothstep(0.5, 1., pr.y+.2));\n\t\n\t// mix in sclera\n\tf = mix(f, 1.-.2*dot(p, p)+.75*shade, smoothstep(0.7, .85, pr.y));\n\t\n\t// highlight\n\tf = mix(1., f, clamp((length(p-lpos/1.)-.15)/.025, 0., 1.));\n\t\n\t// eyelids\n\tf = mix(f, 0., clamp((length(vec2(p.x, abs(p.y))+vec2(0., 1.3))-2.15)/.04, 0., 1.));\n\t\n\treturn f;\n}\nfloat happy_angry_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // zoom \n    float zoom = 0.7;\nvec2 res = iResolution.xy;\n    float cc = 0.0;\n\t\n      for( int m = 0; m < AA; m++ )\n          for( int n = 0; n < AA; n++ )\n          {\n\t       vec2 o = vec2( float( m ), float( n ) )/float( AA ) - .5;\n\t       vec2 p = zoom*2.*( 2.*( gl_FragCoord.xy + o ) - res )/min( res.x, res.y );\n            p /= dot( p, p );\n               // rotation\n               p *= rot( iTime );\n\n               \n               float dist = maxDist;\n\t       dist *= .1 /6.;\n\t       dist = clamp( dist, 0.0, 1.0 );\n               // draw the first circle\t\n               c += circle( p, 1. );\n               p -= vec2( -dist/2., sqrt(3.)*dist/2. );\n \n               // draw the sourrounding circle\n               #define leaves 6.0   // does not really work yet for other than 6.\n               for ( float i = 0.; i < leaves; i++ )\n               {\n    \t           c += circle( p, 1. );\n\t           p.x -= dist;\n\t           p *= rot( tau/leaves );\n               } \n               cc += pow( c, 1.2 );\n          }\n          cc /= float( AA*AA*AA*AA )*3.0;\n\n\n\nvec2 p0 = gl_FragCoord.xy/resolution.xy;\nvec2 p1 = gl_FragCoord.xy/resolution.xy;\n\tfloat col = 0.0;\n p0*=2.1;\n\t\n p0.y-=1.1;\n p0.x-=1.1;\n\t\tcol = 1. - 2.*col;               // final color\n               vec3 color = col*vec3( 1. );\n               color.r *= ( 1./3. )+cc;   // red\n               color.g *= ( 1./2. );   // green\n               color.b *= ( 1./1. );   // blue \n\t       color *= hsv2rgb( vec3(.5, 0.6, 1.0) );\n\t\n\t//color = 1. - exp( -color );\n\tfragColor = vec4( color*cc, 1.0 );\n     \n     float t = 1.+.05*sHash11(1.5*time);\n\tvec2 p = 3. * (gl_FragCoord.xy-res/2.) / res.y;\n\nvec2 c2 =vec2(0.7*cos(iTime), 0.7*sin(iTime));\n\tfragColor*= vec4( vec3(Eye(p0 , t, vec2(0.7*cos(iTime), 0.7*sin(iTime))))*vec3(0.2,0.5,1.), 1.0 );\n  \n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    fragColor*= vec4(happy_angry_star(p0, anim) * vec3(0.65,0.2,1.15), 1.0);\n     fragColor+= vec4(happy_angry_star(p0-c2, anim) * vec3(0.25,0.2,0.25)*0.1, 1.0);\n}\n\n\n      ",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}