{
    "Shader": {
        "info": {
            "date": "1601243757",
            "description": "Inktober, but with shaders.\n\nThe last Shadetober of 2019, wanted to get it done before October 2020 is upon us :P\n\nTrying out some techniques I haven't used before, like SSAO and ortho projection.",
            "flags": 32,
            "hasliked": 0,
            "id": "td3XWf",
            "likes": 7,
            "name": "shadetober #31 (ripe)",
            "published": 3,
            "tags": [
                "orthographic",
                "ssao",
                "inktober",
                "shadertober",
                "shadetober",
                "inktober2019"
            ],
            "usePreview": 0,
            "username": "percentcer",
            "viewed": 397
        },
        "renderpass": [
            {
                "code": "float ssao( in vec2 frag ) {\n    vec2 uv = frag.xy / iResolution.xy;\n    float base = texture(iChannel1, uv).a;\n    float aspect = iResolution.x/iResolution.y;\n    #if 0\n    // original attempt, uniform sampling\n    // using numpad directions\n    // 7 8 9\n    // 4 5 6\n    // 1 2 3\n    float ep = 32. / iResolution.x;\n    float d6 = texture(iChannel1, uv + vec2(ep, 0.)).a;\n    float d9 = texture(iChannel1, uv + vec2(ep) * .7).a;\n    float d8 = texture(iChannel1, uv + vec2(0., ep)).a;\n    float d7 = texture(iChannel1, uv + vec2(-ep, ep) * .7).a;\n    float d4 = texture(iChannel1, uv + vec2(-ep, 0.)).a;\n    float d1 = texture(iChannel1, uv + vec2(-ep) * .7).a;\n    float d2 = texture(iChannel1, uv + vec2(0., -ep)).a;\n    float d3 = texture(iChannel1, uv + vec2(ep, -ep) * .7).a;\n    float result = (8.*base - (d1 + d2 + d3 + d4 + d6 + d7 + d8 + d9)) / 8.;\n\treturn 1. - result / FAR;\n    #else\n    // ref: https://www.shadertoy.com/view/Ms23Wm\n    const float n = 32.;\n    float acc = 0.;\n    for (float i = 0.; i < n; i++) {\n        vec2 smplOffset = texture(iChannel2, (frag.xy + i * 31.57)/iResolution.xy * vec2(aspect, 1.)).xy * 2. - 1.;\n        smplOffset *= 16.;\n        acc += clamp((base - texture(iChannel1, (frag.xy + smplOffset)/iResolution.xy).a), 0., 1.);\n    }\n    return 1. - acc / n;\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel0, uv).rgba * ssao(fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n// https://iquilezles.org/articles/distfunctions\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp(0.5 - 0.5 * ( d2 + d1 ) / k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k * h * (1.0 - h); \n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb) {\n  float rba = rb - ra;\n  float baba = dot(b - a, b - a);\n  float papa = dot(p - a, p - a);\n  float paba = dot(p - a, b - a) / baba;\n  float x = sqrt(papa - paba * paba * baba);\n  float cax = max(0.0, x - ((paba < 0.5) ? ra : rb));\n  float cay = abs(paba - 0.5) - 0.5;\n  float k = rba * rba + baba;\n  float f = clamp((rba * (x - ra) + paba * baba) / k, 0.0, 1.0);\n  float cbx = x - ra - f * rba;\n  float cby = paba - f;\n  float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n  return s *\n         sqrt(min(cax * cax + cay * cay * baba, cbx * cbx + cby * cby * baba));\n}\n\nfloat sdBlueberry(vec3 p) {\n    vec3 bp = p;\n    bp.z *= 1.2;\n    float base = length(bp) - 1. + n3D(p.xyy*2.)*.1;\n    \n    vec3 sp = p;\n    sp.xy *= (2.5 + sin(atan(sp.y,sp.x)*5.6)*.3);\n    float starcap = sdCappedCone(sp, vec3(0.,0.,.6), vec3(0.,0.,1.0), .7, .1);\n    \n    vec3 tp = p;\n    tp.z += .8;\n    float butt = length(tp) - .05;\n    \n    float pass1 = opSmoothSubtraction(starcap, base, .1);\n    return opSmoothSubtraction(butt, pass1, .05);\n}\n\nvec2 map(vec3 p) {\n\tvec3 pLocal = opRep(p, vec3(REPETITION_PERIOD, REPETITION_PERIOD, ZSEP));\n    vec3 c = cell(p);\n    float rnd = n3D(c);\n    pLocal = rotx(rnd * TAU + sin(iTime*rnd*3.) * .2) * roty(rnd * TAU + cos(iTime*rnd) * .5) * pLocal;\n    // todo, I'd like to stagger the position of the berries a bit more but I'm not sure how,\n    // would love some suggestions. Rotation within their local cell works pretty well, but\n    // translation offsets only work in very small increments before the shape has moved outside\n    // the boundary of its cell\n    // wondering if something like this would apply? (https://www.shadertoy.com/view/3styzn)\n    return vec2(sdBlueberry(pLocal), 1.);\n}\n\nvec3 norm(vec3 p) {\n    vec2 eps = vec2(.001, .0);\n    return normalize(map(p).x - vec3(map(p - eps.xyy).x,\n                                   map(p - eps.yxy).x,\n                                   map(p - eps.yyx).x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0., 0., 0.);\n    \n    vec2 normalizedMouse = iMouse.xy/iResolution.xy;\n    vec3 rd = viewDirection(normalizedMouse, uv);\n    vec3 ro = origin(normalizedMouse, uv);\n    \n    float t;\n    for (t = 1.; t < FAR;) {\n        vec3 p = ro + rd * t;\n        vec2 dmat = map(p);\n        if (dmat.x < .01) { col = norm(p); break;}\n        // doing a little hybrid walk here (sphere-step until close, then fixed-step),\n        // not sure if there's a more common convention for this\n        if (dmat.x < .1) { t += .01; }\n        else { t+=dmat.x*.5; }\n        \n    }\n    fragColor = vec4(col, t);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec3 bluebColor(vec3 p) {\n    vec3 base = vec3(20.,45.,246.)/255.;\n    vec3 mottling = (2.+vec3(n3D(p*6.)));\n    return base * mottling * pow(length(p), 10.);\n}\n\nvec3 color(vec3 p, vec3 rd, vec3 norm) {\n    vec3 pLocal = opRep(p, vec3(REPETITION_PERIOD, REPETITION_PERIOD, ZSEP));\n    \n    vec3 diff = bluebColor(pLocal);\n    \n    vec3 lp = vec3(1.,1.,4.);\n    \n    vec3 p2l = normalize(lp - p);\n    \n    vec3 diffLit = diff * max(0., dot(norm, p2l));\n    vec3 spec = vec3( pow(max(0.,dot(reflect(-rd, norm), -p2l)), 100.) );\n    \n    return max(mat3(.6,.2,.2,2.,.6,.2,.2,.2,.6)*diff*.1, diffLit + spec);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ruv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec2 normalizedMouse = iMouse.xy/iResolution.xy;\n    vec3 rd = viewDirection(normalizedMouse, ruv);\n    vec3 ro = origin(normalizedMouse, ruv);\n    \n   \tvec4 meta = texture(iChannel0, uv);\n    vec3 norm = meta.rgb;\n    float t = meta.w;\n    \n    vec3 col = color(ro + rd * t, rd, norm);\n    col = pow(col, vec3(.4545));\n    \n    // --- dbg, show depth ---\n    // col = texture(iChannel0, uv).www / 30.;\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define REPETITION_PERIOD 2.3\n#define HALF_PERIOD REPETITION_PERIOD * .5\n#define ZSEP 7.\n#define FAR 50.\n#define TAU 6.283\n\nvec3 cell(vec3 p) { return floor((p + vec3(HALF_PERIOD)) / REPETITION_PERIOD); }\n\n\nmat3 roty(float a)\n{\n    return mat3(cos(a), 0., sin(a), 0., 1., 0., -sin(a), 0., cos(a));\n}\n\nmat3 rotx(float a)\n{\n    return mat3(1., 0., 0., 0., cos(a), sin(a), 0., -sin(a), cos(a));\n}\n\n\n// https://iquilezles.org/articles/distfunctions\nvec3 opRep(in vec3 p, in vec3 c)\n{\n    vec3 cell = cell(p);\n    vec3 localpos = mod(p + c / 2., c) - c / 2.;\n    //localpos += .5 * (mod(cell.z, 2.));\n    \n    //localpos *= roty(sin(/*iTime*/ 0.)*5. * p.y);\n    //vec3 noise = texture(iChannel0, vec2(cell.x, cell.y * cell.z) * .1).rgb;\n    //vec3 offs = noise - .5;\n    \n    return localpos;//*rotx(sin(iTime*noise.x)*noise.y) + offs*2.;\n}\n\n// shane's compact version of iq's 3d noise\nfloat n3D(vec3 p){\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// #define MOUSE_VIEW\n#define ORTHO\n\nmat3 mouserot(vec2 mouse) {\n    #ifdef MOUSE_VIEW\n    vec2 mouserot = 4.* (mouse * 2. - 1.);\n    return (roty(mouserot.x) * rotx(mouserot.y));\n    #else\n    // return mat3(1.,0.,0., 0.,1.,0., 0.,0.,1.);\n    return roty(.08) * rotx(-.1);\n    #endif\n}\n    \n\nvec3 origin(vec2 mouse, vec2 uv) {\n    #ifdef ORTHO\n    uv *= 10.;\n    vec3 origin = vec3(uv.x, uv.y, 5.);\n    #else\n    vec3 origin = vec3(0., 0., 5.);\n    #endif\n    return mouserot(mouse) * origin;\n}\n\nvec3 viewDirection(vec2 mouse, vec2 uv) { \n    #ifdef ORTHO\n    uv = vec2(0., 0.);\n    vec3 dir = normalize(vec3(uv, -2.));\n    #else\n    vec3 dir = normalize(vec3(uv, -2.));\n    #endif\n    return mouserot(mouse) * dir;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}