{
    "Shader": {
        "info": {
            "date": "1576886851",
            "description": "Just experimenting with different kinds of glitching effects, plus a cool old school CRT screen effect. ",
            "flags": 0,
            "hasliked": 0,
            "id": "wld3WN",
            "likes": 52,
            "name": "Glitchy Glitch",
            "published": 3,
            "tags": [
                "noise",
                "crt",
                "rgb",
                "postprocess",
                "glitch",
                "analog",
                "digital",
                "hash"
            ],
            "usePreview": 0,
            "username": "piyushslayer",
            "viewed": 4221
        },
        "renderpass": [
            {
                "code": "/**\n Just messing around with different types of glitching effects.\n*/\n\n// try commenting/uncommenting these to isolate/combine different glitch effects.\n#define ANALOG\n#define DIGITAL\n#define CRT\n\n// amount of seconds for which the glitch loop occurs\n#define DURATION 5.\n// percentage of the duration for which the glitch is triggered\n#define AMT .5 \n\n#define SS(a, b, x) (smoothstep(a, b, x) * smoothstep(b, a, x))\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1. / float(0xffffffffU))\n\n// Hash by David_Hoskins\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn -1. + 2. * vec3(q) * UIF;\n}\n\n// Gradient noise by iq\nfloat gnoise(vec3 x)\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w * w * w * (w * (w * 6. - 15.) + 10.);\n    \n    // gradients\n    vec3 ga = hash33(p + vec3(0., 0., 0.));\n    vec3 gb = hash33(p + vec3(1., 0., 0.));\n    vec3 gc = hash33(p + vec3(0., 1., 0.));\n    vec3 gd = hash33(p + vec3(1., 1., 0.));\n    vec3 ge = hash33(p + vec3(0., 0., 1.));\n    vec3 gf = hash33(p + vec3(1., 0., 1.));\n    vec3 gg = hash33(p + vec3(0., 1., 1.));\n    vec3 gh = hash33(p + vec3(1., 1., 1.));\n    \n    // projections\n    float va = dot(ga, w - vec3(0., 0., 0.));\n    float vb = dot(gb, w - vec3(1., 0., 0.));\n    float vc = dot(gc, w - vec3(0., 1., 0.));\n    float vd = dot(gd, w - vec3(1., 1., 0.));\n    float ve = dot(ge, w - vec3(0., 0., 1.));\n    float vf = dot(gf, w - vec3(1., 0., 1.));\n    float vg = dot(gg, w - vec3(0., 1., 1.));\n    float vh = dot(gh, w - vec3(1., 1., 1.));\n\t\n    // interpolation\n    float gNoise = va + u.x * (vb - va) + \n           \t\tu.y * (vc - va) + \n           \t\tu.z * (ve - va) + \n           \t\tu.x * u.y * (va - vb - vc + vd) + \n           \t\tu.y * u.z * (va - vc - ve + vg) + \n           \t\tu.z * u.x * (va - vb - ve + vf) + \n           \t\tu.x * u.y * u.z * (-va + vb + vc - vd + ve - vf - vg + vh);\n    \n    return 2. * gNoise;\n}\n\n// gradient noise in range [0, 1]\nfloat gnoise01(vec3 x)\n{\n\treturn .5 + .5 * gnoise(x);   \n}\n\n// warp uvs for the crt effect\nvec2 crt(vec2 uv)\n{\n    float tht  = atan(uv.y, uv.x);\n    float r = length(uv);\n    // curve without distorting the center\n    r /= (1. - .1 * r * r);\n    uv.x = r * cos(tht);\n    uv.y = r * sin(tht);\n    return .5 * (uv + 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float t = iTime;\n    \n    // smoothed interval for which the glitch gets triggered\n    float glitchAmount = SS(DURATION * .001, DURATION * AMT, mod(t, DURATION));  \n\tfloat displayNoise = 0.;\n    vec3 col = vec3(0.);\n    vec2 eps = vec2(5. / iResolution.x, 0.);\n    vec2 st = vec2(0.);\n#ifdef CRT\n\tuv = crt(uv * 2. - 1.); // warped uvs\n    ++displayNoise;\n#endif\n    // analog distortion\n    float y = uv.y * iResolution.y;\n    float distortion = gnoise(vec3(0., y * .01, t * 500.)) * (glitchAmount * 4. + .1);\n    distortion *= gnoise(vec3(0., y * .02, t * 250.)) * (glitchAmount * 2. + .025);\n#ifdef ANALOG\n    ++displayNoise;\n    distortion += smoothstep(.999, 1., sin((uv.y + t * 1.6) * 2.)) * .02;\n    distortion -= smoothstep(.999, 1., sin((uv.y + t) * 2.)) * .02;\n    st = uv + vec2(distortion, 0.);\n    // chromatic aberration\n    col.r += textureLod(iChannel0, st + eps + distortion, 0.).r;\n    col.g += textureLod(iChannel0, st, 0.).g;\n    col.b += textureLod(iChannel0, st - eps - distortion, 0.).b;\n#else\n    col += texture(iChannel0, uv, 0.).xyz;\n#endif\n    \n#ifdef DIGITAL\n    // blocky distortion\n    float bt = floor(t * 30.) * 300.;\n    float blockGlitch = .2 + .9 * glitchAmount;\n    float blockNoiseX = step(gnoise01(vec3(0., uv.x * 3., bt)), blockGlitch);\n    float blockNoiseX2 = step(gnoise01(vec3(0., uv.x * 1.5, bt * 1.2)), blockGlitch);\n    float blockNoiseY = step(gnoise01(vec3(0., uv.y * 4., bt)), blockGlitch);\n    float blockNoiseY2 = step(gnoise01(vec3(0., uv.y * 6., bt * 1.2)), blockGlitch);\n    float block = blockNoiseX2 * blockNoiseY2 + blockNoiseX * blockNoiseY;\n    st = vec2(uv.x + sin(bt) * hash33(vec3(uv, .5)).x, uv.y);\n    col *= 1. - block;\n    block *= 1.15;\n    col.r += textureLod(iChannel0, st + eps, 0.).r * block;\n    col.g += textureLod(iChannel0, st, 0.).g * block;\n    col.b += textureLod(iChannel0, st - eps, 0.).b * block;\n#endif\n    // white noise + scanlines\n    displayNoise = clamp(displayNoise, 0., 1.);\n    col += (.15 + .65 * glitchAmount) * (hash33(vec3(fragCoord, mod(float(iFrame),\n\t\t\t\t\t1000.))).r) * displayNoise;\n    col -= (.25 + .75 * glitchAmount) * (sin(4. * t + uv.y * iResolution.y * 1.75))\n\t\t\t\t\t* displayNoise;\n#ifdef CRT\n    //crt vignette (from https://www.shadertoy.com/view/Ms23DR)\n    float vig = 8.0 * uv.x * uv.y * (1.-uv.x) * (1.-uv.y);\n\tcol *= vec3(pow(vig, .25)) * 1.5;\n    if(uv.x < 0. || uv.x > 1.) col *= 0.;\n#endif\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 11,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}