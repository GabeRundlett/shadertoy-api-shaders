{
    "Shader": {
        "info": {
            "date": "1719007443",
            "description": "Basic raymarching but I think it looks kind of neat.\n\nStill conflicted on these colours.\n\nThe shader name is basically gibberish, I'm not sure what a stucture like this would be called geometrically.",
            "flags": 0,
            "hasliked": 0,
            "id": "4XcSW8",
            "likes": 1,
            "name": "Endless Electric Trip",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "electric"
            ],
            "usePreview": 0,
            "username": "JPW03",
            "viewed": 91
        },
        "renderpass": [
            {
                "code": "//\n// Just a basic raymarching scene I made from messing around.\n// Heavily based on kishimisu's raymarching video ( https://youtu.be/khblXafu7iA )\n// Author: JPW03 https://www.github.com/JPW03\n//\n\n\n//// SIGNED DISTANCE FUNCTIONS\n\n\n// Functions taken from Inigo Quilez's article on SDFs ( https://iquilezles.org/articles/distfunctions/ )\n\nfloat sdSphere(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n\n//// OPERATORS ON SHAPES\n\n\nfloat opSubtraction(float d1, float d2) { return max(-d1, d2); }\n\nfloat smoothmin(float a, float b, float k) {\n    float h = max(k - abs(a-b), 0.0) / k;\n    return min(a, b) - h*h*h*k*(1.0/6.0);\n}\nfloat opSmoothUnion(float d1, float d2, float k) { return smoothmin(d1, d2, k); }\n\nmat2 rot2D(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nvec3 spaceRepetition(vec3 p, vec3 s) { return mod(p, s) - s/2.0; }\n\n\n//// OTHER FUNCTIONS\n\n\n// Generated using http://dev.thi.ng/gradients/\nvec3 palette(float t) {\n    vec3 a = vec3(0.5);\n    vec3 b = vec3(0.36);\n    vec3 c = vec3(0.8, 0.8, 0.5);\n    vec3 d = vec3(-1.472 -1.272 -0.972);\n    \n    return a + b*cos(6.28318*(c*t + d));\n}\n\n\n//// RAYMARCHING ALGORITHM\n\n\n// Returns the distance to the closest object in the scene\nfloat map(vec3 p)\n{\n    p.y += iTime * 0.3;\n    \n    // Swiss octahedron repetition\n    vec3 q = spaceRepetition(p, vec3(1.0, 0.8, 1.0));\n    float holeyOctah = opSubtraction(\n        sdSphere(q, 0.13),\n        sdOctahedron(q, 0.2)\n    );\n    \n    // Swiss sphere repetition\n    q = spaceRepetition(p - vec3(0.0, 0.4, 0.0), vec3(1.0, 0.8, 1.0));\n    float holeySphere = opSubtraction(\n        sdOctahedron(q, 0.265),\n        sdSphere(q, 0.2)\n    );\n\n    return opSmoothUnion(\n        holeyOctah, \n        holeySphere, \n        0.1\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (0,0 centre, -1 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n\n    //// INITIALISATION STAGE\n    \n    float fov = 1.0;  // field of view (as a multiplier on ray direction)\n    \n    vec3 ro = vec3(0.0, 0.0, -3.0); // ray origin (position of camera in 3D space)\n    \n    vec3 rd = normalize(vec3(uv * fov, 1.0)); // ray direction\n    \n    vec3 col = vec3(0.0); // ray colour\n\n    float t = 0.0; // ray travel distance\n    \n    // Camera rotation\n    mat2 rotX = rot2D(-0.7);\n    mat2 rotY = rot2D(-1.35);\n    ro.yz *= rotX;\n    rd.yz *= rotX;\n    ro.xz *= rotY;\n    rd.xz *= rotY;\n   \n    //// RAYMARCHING STAGE\n    \n    int i;\n    for (i = 0; i < 80; i++) {\n        vec3 p = ro + rd * t; // ray position\n        \n        // Distortions on p\n        p.xz *= rot2D(p.y * 0.1);\n        \n        float d = map(p);     // distance to nearest object\n        t += d;               // \"march\" the ray forward\n        \n        // break the loop if \n        //  - the ray intersects an object (march increment too small)\n        //  - the ray has travelled too far\n        if (d < 0.001 || t > 100.0) break;\n    }\n    \n    //// COLOURING STAGE\n    \n    col = palette(0.04*t + float(i)*0.01);\n\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}