{
    "Shader": {
        "info": {
            "date": "1532088281",
            "description": "a voronoi of 3 different distances,, within tiled voronoi.\nit always mixes 2 of 3 different distances, the mix parameter loops and changes over screenspace.x\n//there is a disabled line that adds iMouse.xy control to the screenspace mixing parameter.",
            "flags": 0,
            "hasliked": 0,
            "id": "MltcR7",
            "likes": 6,
            "name": "voronoi metric mixing",
            "published": 3,
            "tags": [
                "voronoi",
                "mix",
                "triangle",
                "water",
                "taxicap"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 929
        },
        "renderpass": [
            {
                "code": "\n//self: https://www.shadertoy.com/view/MltcR7\n\n//sign 2d voronoi different distance metrics\n//parent https://www.shadertoy.com/view/MdSGRc\n\n// Created by inigo quilez-iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat hash1(float n){ return fract(sin(n)*43758.5453);}\nvec2  hash2(vec2  p){ p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));return fract(sin(p)*43758.5453);}\n\n\n\nvec4 voronoi(vec2 x,float mode\n){vec2 n=floor(x)\n ;vec2 f=fract(x)\n ;vec3 m=vec3(8.)\n ;float m2=8.\n ;for(int j=-2;j<=2;j++)for(int i=-2;i<=2;i++\n ){vec2 g=vec2(float(i),float(j))\n  ;vec2 o=hash2(n+g)\n  ;// animate\n  //;o=0.5 + 0.5*sin(iTime + 6.2831*o);\n  ;o=.5+.5*sin(iTime+x.x*2.+x.y*1.61+6.2831*o)\n  ;vec2 r=g-f+o\n  ;vec2 d0=vec2(sqrt(dot(r,r)),1.0)//euclidean (sqrt() is theoretically most complex here, but can be approximated very quickly)\n  ;vec2 d1=vec2(0.71*(abs(r.x)+ abs(r.y)),1.0)// manhattam \n  ;//vec2 d1=vec2(0.71*abs(r.x-r.y),1.0)//manhattan no diagonals\n  ;vec2 d2=vec2(0)// triangular (placeholder)\n  ;vec2 d=d0\n  //below code ALWAYS mixes 2 of 3:\n  ;if(mode<3.0)d=mix(d1,d0,fract(mode))\n  ;if(mode<2.0\n  ){d2=vec2(max(abs(r.x)*0.866025+r.y*0.5,-r.y),step(0.0,0.5*abs(r.x)+0.866025*r.y)*(1.0+step(0.0,r.x)))// triangular\n   ;d=mix(d2,d1,fract(mode))\n   ;if(mode<1.0)d=mix(d0,d2,fract(mode));}//loop around\n  ;if(d.x<m.x){m2=m.x;m.x=d.x;m.y=hash1(dot(n+g,vec2(7,113)));m.z=d.y\n ;}else if(d.x<m2)m2=d.x;}return vec4(m,m2-m.x);}\n\nvoid mainImage(out vec4 fragColor,vec2 u\n){\n ;float d=length(u-iMouse.xy)*3.\n ;d=u.x*3.\n //;d=0.\n ;d/=iResolution.x\n ;float mode=mod(d-iTime*.1,3.)\n ;mode=floor(mode)+smoothstep(0.8,1.0,fract(mode))\n ;vec2 p=u.xy/iResolution.xx\n ;vec4 c=voronoi(8.0*p,mode)\n ;vec3 col=0.5 + 0.5*sin(c.y*2.5 + vec3(1.0,1.0,1.9))\n ;col*=sqrt(clamp(1.0-c.x,0.0,1.0))\n ;col*=clamp(0.5 +(1.0-c.z/2.0)*0.5,0.0,1.0)\n ;col*=0.4 + 0.6*sqrt(clamp(4.0*c.w,0.0,1.0))\n ;fragColor=vec4(col,1.0);}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}