{
    "Shader": {
        "info": {
            "date": "1528307007",
            "description": "A modification of [url]https://www.shadertoy.com/view/4dtGD2[/url], that uses simpler code and arithmetics.",
            "flags": 0,
            "hasliked": 0,
            "id": "4s3fzl",
            "likes": 28,
            "name": "Simple Bitmap Text - integers",
            "published": 3,
            "tags": [
                "text",
                "bitmap",
                "font",
                "rendering",
                "integers"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 1478
        },
        "renderpass": [
            {
                "code": "// I modified Hamneggs shader to use\n// integer arithmetic, arrays and\n// branches when appropiate - iq\n\n\n// Simple Bitmap Text by Gerard Geer\n// \n// Essentially a \"hmm, how does that work?\" educational rewrite of P_Malin's text renderer:\n// https://www.shadertoy.com/view/4sBSWW\n// Each character is a 4x5 bitmap encoded into a float, where each hex digit convieniently\n// represents one row.\n// License: Creative Commons CC0 1.0 Universal (CC-0) \n\nconst int font[] = int[](\n 0x69f99, 0x79797, 0xe111e, 0x79997, 0xf171f, 0xf1711, 0xe1d96, 0x99f99, \n 0xf444f, 0x88996, 0x95159, 0x1111f, 0x9f999, 0x9bd99, 0x69996, 0x79971,\n 0x69b5a, 0x79759, 0xe1687, 0xf4444, 0x99996, 0x999a4, 0x999f9, 0x99699,\n 0x99e8e, 0xf843f, 0x6bd96, 0x46444, 0x6942f, 0x69496, 0x99f88, 0xf1687,\n 0x61796, 0xf8421, 0x69696, 0x69e84, 0x66400, 0x0faa9, 0x0000f, 0x00600,\n 0x0a500, 0x02720, 0x0f0f0, 0x08421, 0x33303, 0x69404, 0x00032, 0x00002,\n 0x55000, 0x00000, 0x00202, 0x42224, 0x24442);\n\n#define CH_A 0\n#define CH_B 1\n#define CH_C 2\n#define CH_D 3\n#define CH_E 4\n#define CH_F 5\n#define CH_G 6\n#define CH_H 7\n#define CH_I 8\n#define CH_J 9\n#define CH_K 10\n#define CH_L 11\n#define CH_M 12\n#define CH_N 13\n#define CH_O 14\n#define CH_P 15\n#define CH_Q 16\n#define CH_R 17\n#define CH_S 18\n#define CH_T 19\n#define CH_U 20\n#define CH_V 21\n#define CH_W 22\n#define CH_X 23\n#define CH_Y 24\n#define CH_Z 25\n#define CH_0 26\n#define CH_1 27\n#define CH_2 28\n#define CH_3 29\n#define CH_4 30\n#define CH_5 31\n#define CH_6 32\n#define CH_7 33\n#define CH_8 34\n#define CH_9 35\n#define CH_APST 36\n#define CH_PI   37\n#define CH_UNDS 38\n#define CH_HYPH 39\n#define CH_TILD 40\n#define CH_PLUS 41\n#define CH_EQUL 42\n#define CH_SLSH 43\n#define CH_EXCL 44\n#define CH_QUES 45\n#define CH_COMM 46\n#define CH_FSTP 47\n#define CH_QUOT 48 \n#define CH_BLNK 49\n#define CH_COLN 50\n#define CH_LPAR 51\n#define CH_RPAR 52\n\nconst ivec2 MAP_SIZE = ivec2(4,5);\n\n\n\n/*\n\tDraws a character, given its encoded value, a position, size and\n\tcurrent [0..1] uv coordinate.\n*/\nint drawChar( in int char, in vec2 pos, in vec2 size, in vec2 uv )\n{\n    \n    // Subtract our position from the current uv so that we can\n    // know if we're inside the bounding box or not.\n    uv-=pos;\n    \n    // Divide the screen space by the size, so our bounding box is 1x1.\n    uv /= size;    \n    \n    // Multiply the UV by the bitmap size so we can work in\n    // bitmap space coordinates.\n    uv *= vec2(MAP_SIZE);\n\n    // Compute bitmap texel coordinates\n    ivec2 iuv = ivec2(round(uv));\n    \n\t// Bounding box check. With branches, so we avoid the maths and lookups    \n    if( iuv.x<0 || iuv.x>MAP_SIZE.x-1 ||\n        iuv.y<0 || iuv.y>MAP_SIZE.y-1 ) return 0;\n\n    // Compute bit index\n    int index = MAP_SIZE.x*iuv.y + iuv.x;\n    \n    // Get the appropriate bit and return it.\n    return (font[char]>>index)&1;\n\n}\n\n/*\n\tPrints a float as an int. Be very careful about overflow.\n\tThis as a side effect will modify the character position,\n\tso that multiple calls to this can be made without worrying\n\tmuch about kerning.\n*/\nint drawIntCarriage( in int val, inout vec2 pos, in vec2 size, in vec2 uv, in int places )\n{\n    // Create a place to store the current values.\n    int res = 0;\n    // Surely it won't be more than 10 chars long, will it?\n    // (MAX_INT is 10 characters)\n    for( int i = 0; i < 10; ++i )\n    {\n        // If we've run out of film, cut!\n        if(val == 0 && i >= places) break;\n        // The current lsd is the difference between the current\n        // value and the value rounded down one place.\n        int digit = val % 10;\n        // Draw the character. Since there are no overlaps, we don't\n        // need max().\n        res |= drawChar(CH_0+digit,pos,size,uv);\n        // Move the carriage.\n        pos.x -= size.x*1.2;\n        // Truncate away this most recent digit.\n        val /= 10;\n    }\n    return res;\n}\n\n/*\n\tDraws an integer to the screen. No side-effects, but be ever vigilant\n\tso that your cup not overfloweth.\n*/\nint drawInt( in int val, in vec2 pos, in vec2 size, in vec2 uv )\n{\n    vec2 p = vec2(pos);\n    float s = sign(float(val));\n    val *= int(s);\n    \n    int c = drawIntCarriage(val,p,size,uv,1);\n    if( s<0.0 ) c |= drawChar(CH_HYPH,p,size,uv);\n    return c;\n}\n\n/*\n\tPrints a fixed point fractional value. Be even more careful about overflowing.\n*/\nint drawFixed( in float val, in int places, in vec2 pos, in vec2 size, in vec2 uv )\n{\n    float fval, ival;\n    fval = modf(val, ival);\n    \n    vec2 p = vec2(pos);\n    \n    // Draw the floating point part.\n    int res = drawIntCarriage( int( fval*pow(10.0,float(places)) ), p, size, uv, places );\n    // The decimal is tiny, so we back things up a bit before drawing it.\n    p.x += size.x*.4;\n    res |= drawChar(CH_FSTP,p,size,uv); p.x-=size.x*1.2;\n    // And after as well.\n    p.x += size.x *.1;\n    // Draw the integer part.\n    res |= drawIntCarriage(int(ival),p,size,uv,1);\n\treturn res;\n}\n\nint text( in vec2 uv, const float size )\n{\n    vec2 charSize = vec2( size*vec2(MAP_SIZE)/iResolution.y );\n    float spaceSize = float( size*float(MAP_SIZE.x+1)/iResolution.y );\n        \n    // and a starting position.\n    vec2 charPos = vec2(0.05, 0.90);\n    // Draw some text!\n    int chr = 0;\n    // Bitmap text rendering!\n    chr += drawChar( CH_B, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_I, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_T, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_M, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_A, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_P, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_BLNK, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_T, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_E, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_X, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_T, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_BLNK, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_R, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_E, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_N, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_D, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_E, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_R, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_I, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_N, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_G, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_EXCL, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_EXCL, charPos, charSize, uv); charPos.x += spaceSize;\n    \n    // Today's Date: {date}\n    charPos = vec2(0.05, .75);\n    chr += drawChar( CH_T, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_O, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_D, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_A, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_Y, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_APST, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_S, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_BLNK, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_D, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_A, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_T, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_E, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_BLNK, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_LPAR, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_M, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_M, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_HYPH, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_D, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_D, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_HYPH, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_Y, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_Y, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_Y, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_Y, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_RPAR, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_COLN, charPos, charSize, uv); charPos.x += .1;\n    // The date itself.\n    charPos.x += .3;\n    chr += drawIntCarriage( int(iDate.x), charPos, charSize, uv, 4);\n    chr += drawChar( CH_HYPH, charPos, charSize, uv); charPos.x-=spaceSize;\n    chr += drawIntCarriage( int(iDate.z)+1, charPos, charSize, uv, 2);\n    chr += drawChar( CH_HYPH, charPos, charSize, uv); charPos.x-=spaceSize;\n    chr += drawIntCarriage( int(iDate.y)+1, charPos, charSize, uv, 2);\n    \n    // Shader uptime:\n    charPos = vec2(0.05, .6);\n    chr += drawChar( CH_I, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_G, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_L, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_O, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_B, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_A, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_L, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_T, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_I, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_M, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_E, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_COLN, charPos, charSize, uv); charPos.x += spaceSize;\n    // The uptime itself.\n    charPos.x += .3;\n    chr += drawFixed( iTime, 2, charPos, charSize, uv);\n    return chr;\n}\n\n/*\n\tShadertoy's fancy entry function.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get Y-normalized UV coords.\n\tvec2 uv = fragCoord / iResolution.y;\n    \n    // Draw some text!\n    float txt = float( text(uv, 3.5) );\n    \n\tfragColor = vec4(txt,txt,txt,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}