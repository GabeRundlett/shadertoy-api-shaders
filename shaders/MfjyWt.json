{
    "Shader": {
        "info": {
            "date": "1723184337",
            "description": "combination of https://www.shadertoy.com/view/4scGWj https://www.shadertoy.com/view/lcBcDw  https://www.shadertoy.com/view/4tyfWy",
            "flags": 0,
            "hasliked": 0,
            "id": "MfjyWt",
            "likes": 2,
            "name": "Electro flash ",
            "published": 3,
            "tags": [
                "star",
                "flash",
                "electic"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 95
        },
        "renderpass": [
            {
                "code": "vec3 _Color=vec3(0.2,0.5,1.);\nvec3 _horizonColor=vec3(0.2,0.5,1.);\nvec3 _haloColor=vec3(0.5,0.1,2.5);\nfloat _flowSpeed=0.0101;\nfloat _flowDensity=2.;\nfloat _flowIntensity=0.5;\n\nfloat _gridSpeed=0.3;\nfloat _gridScale=0.1;\nfloat _gridLineWidth=1.02;\nfloat _gridRingRadius=0.08;\nfloat _gridRingHoleRate=0.8;\nfloat _girdIntensity=0.1;\n\n\nfloat _squareSpeed=0.1;\nfloat _squareScale=1.4;\nfloat _squareIntensity=0.3;\n\nfloat _sparkerForwardSpeed=0.0;\nfloat _sparkerForwardScale=0.;\nfloat _sparkerForwardIntensity=0.0;\n\nfloat _sparkRiseSpeed=0.05;\nfloat _sparkRiseScale=10.;\nfloat _sparkRiseIntensity=0.2;\n\nfloat _BGcircleScale=0.22;\nfloat _haloBGIntensity=21.0;\nfloat _horizontalHight=0.0;\nfloat _horizonBGIntensity=0.3;\n\nfloat remap01(float a,float b,float t)\n{\n    return clamp((t-a)/(b-a),0.,1.);\n}\n\nfloat remap(float a,float b,float c,float d,float t)\n{\n    return remap01(a,b,t)*(d-c)+c;\n}\n\nfloat remapF01(float a,float b,float t)\n{\n    return t*(b-a)+a;\n}\n\nfloat N21(vec2 p)\n{\n    p=fract(p*vec2(233.34,851.73 ));\n    p+=dot(p,p+237.45);\n    return fract(p.x*p.y);\n}\n\nvec2 N22(vec2 p)\n{\n    float n=N21(p);\n    return vec2(n,N21(p+n));\n}\n\n\n\n\n\nvec2 PerspectiveUV(vec2 uv)\n{\n    float z = 1./abs(uv.y);\n    return vec2(uv.x*z,z);\n}\n\nvec2 GetPos(vec2 id)\n{\n    vec2 n=N22(id)*iTime*.0;\n    return sin(n)*.4;\n\n}\nfloat Circle(vec2 uv,vec2 p,float r,float blur)\n{\n    float d=length(uv-p);\n    float c=smoothstep(r,r-blur,d);\n    return c;\n}\nfloat Band(float t,float start,float end,float blur)\n{\n    float step1=smoothstep(start-blur,start+blur,t);\n    float step2=smoothstep(end+blur,end-blur,t);\n    return step1*step2;\n}\nfloat Rectangle(vec2 uv,float left,float right,float bottom,float top,float blur)\n{\n    float band1=Band(uv.x,left,right,blur);\n    float band2=Band(uv.y,bottom,top,blur);\n    return band1*band2;\n}\nfloat GridLine(vec2 uv,vec2 ouv,float density ,float width)\n{\n    float gridLine=0.0;\n    float masky=abs(ouv.y-0.5);\n    ouv=1.-abs(ouv-0.5);\n    uv*=density;\n \n    uv-=0.5;\n    uv=abs(uv);\n    float maskx=uv.x;\n\n    uv.x=smoothstep(width,0.0,uv.x);\n    uv.y=smoothstep(ouv.y*ouv.y*width*5.0,0.0,uv.y);//待解决y轴的粗细\n    gridLine=max(uv.y,uv.x);\n\n    maskx=smoothstep(0.1,0.0,maskx);\n    masky=smoothstep(0.1,0.3,masky);\n    masky=clamp((masky-maskx),0.,1.);\n    return gridLine*(maskx+masky);\n    \n\n}\nvec2 GridRing(vec2 uv,float density,float radius,float Blur,float holeRadiusRatio)\n{\n\n    float circle;\n    float ring;\n\n    uv*=density;\n    uv=fract(uv);\n    uv-=0.5;\n    uv=abs(uv);\n\n\n    circle=Circle(uv,vec2(0.,0.),radius,Blur);\n\n    ring=circle-Circle(uv,vec2(0.,0.),radius*holeRadiusRatio,Blur);\n\n    return vec2(circle,ring);\n}\nfloat GridRingLine(vec2 uv,vec2 ouv,float density,float width,float radius,float Blur,float holeRadiusRatio)\n{\n     float grid=GridLine(uv,ouv,density,width);\n     vec2 ring=GridRing(uv,density,radius,Blur,holeRadiusRatio);\n\n     grid*=1.-ring.x;\n     grid+=ring.y;\n\n     return grid;\n}\nfloat RandomSquares(vec2 uv,float density )\n{\n    uv*=density;\n    vec2 id=floor(uv);\n    uv=fract(uv);\n    uv-=0.5;\n    vec2 p=N22(id);\n    p=vec2(remapF01(-0.5,0.5,p.x),remapF01(-0.5,0.5,p.y));\n\n\n    float s=remapF01(0.02,0.3,N21(id));\n\n    float f=N21(id+365.22);\n\n    float rect=Rectangle(uv,p.x-s,p.x+s,p.y-s,p.y+s,0.02)*f*(sin(iTime*0.+N21(id+765.1)*6.28)+1.)*0.5;\n\n    return rect;\n}\nfloat RandomSparkers(vec2 uv,float density,float i)\n{\n    float dots;\n    uv*=density;\n    vec2 id=floor(uv);\n    uv=fract(uv);\n    uv-=0.5;\n\n    float maxR=0.1;\n    vec2 p=N22(id+i);\n\n    p=vec2(remapF01(-0.5+maxR,0.5-maxR,p.x),remapF01(-0.5+maxR,0.4-maxR,p.y));\n\n\n    vec2 j=(p-uv)*70.;\n    dots=1./dot(j,j);\n    dots*=sin(iTime*0.+p.x*10.)*.5+.5;\n    return dots;\n}\nfloat RandomSparkersForward(vec2 uv,float speed,float scale)\n{\n    float sparkerForward=0.;\n\n    for(float k=0.;k<1.;k+=1./4.)\n    {\n       float z=k;\n       float size=mix(scale,.5,z);\n       float fade=smoothstep(0.,0.5,z)*smoothstep(1.,.8,z);\n       sparkerForward+=RandomSparkers(uv,size,k)*fade;\n    }\n\n    return sparkerForward;\n}\n float RandomSparkersRise(vec2 uv,float density)\n{\n    float dots;\n    uv*=density;\n    vec2 id=floor(uv);\n    uv=fract(uv);\n    uv-=0.5;\n\n\n    vec2 p=GetPos(id);\n\n    \n\n\n    vec2 j=(p-uv)*70.;\n    dots=1./dot(j,j);\n    dots*=sin(iTime*0.+p.x*10.)*.5+.9;\n    return dots;\n}\nfloat FlowLines(vec2 uv, float resolutionX, float resolutionY)\n{\n\n    uv.x-=0.5;\n    uv.x=abs(uv.x)*2.0;\n    float hx=uv.x;\n    uv.x=2.-uv.x;\n    uv.x*=_flowDensity;\n\n    uv.y=1.-uv.y;\n    uv.y+=uv.x;\n\n\n    float a=fract(cos(resolutionX)*70.);\n\n \n    \n\n    float b=a*1.*(uv.y)/(mod(a*iResolution.y*(iTime+0.)*_flowSpeed,iResolution.x)-resolutionY)*uv.y;\n\n    return b;\n\n}\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise(vec3 m) {\n    return   0.5333333*simplex3d(m)\n\t\t\t+0.2666667*simplex3d(2.0*m)\n\t\t\t+0.1333333*simplex3d(4.0*m)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\n\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n\n    vec2 ouv=fragCoord/iResolution.xy;\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y; \n     uv.y+=0.35;\n \n    vec2 uv2 = (fragCoord-.5*iResolution.xy)/iResolution.y; \n    vec2 ouv2=uv;\n\n   uv2.y-=tan(iTime);\n\n    float inversFade=clamp(remap(0.,0.3,0.0,0.7,uv.y-(-0.10)),0.,1.);\n\n    float circleFade=smoothstep(-1.6+_BGcircleScale,0.2+_BGcircleScale,1.-length((ouv-0.5)*2.0));\n\n    vec2 puv = PerspectiveUV(uv);\n\n    float gridRingLine=GridRingLine(vec2(puv.x,puv.y+=iTime*_gridSpeed),ouv2,_gridScale,_gridLineWidth,_gridRingRadius,0.02,_gridRingHoleRate);\n\n    float squares=RandomSquares(vec2(puv.x,puv.y+=iTime*_squareSpeed),_squareScale);\n\n    float sparkerRise=RandomSparkersRise(vec2(uv.x,uv.y-iTime*_sparkRiseSpeed),_sparkRiseScale);\n\n    float sparkerForward=RandomSparkersForward(uv,_sparkerForwardSpeed,_sparkerForwardScale);\n\n    float flowLine=FlowLines(ouv,fragCoord.x,fragCoord.y);\n\nvec2 uv3 = fragCoord.xy / iResolution.xy;    \nuv3.y-=tan(iTime);\n  uv3 = uv3 * 2. -1.;  \n   \n  vec2 p = fragCoord.xy/iResolution.xy;\n \n  vec3 p3 = vec3(p, iTime*0.5);    \n    \n  float intensity = noise(vec3(p3*12.0+12.0));\n                          \n  float t = clamp((uv3.x * -uv3.x * 0.16) + 0.15, 0., 1.);                         \n  float y = abs(intensity * -t + uv3.y);\n    \n  float g = pow(y, 0.2);\n                          \n  vec3 col3 = vec3(1.70, 1.48, 1.78);\n  col3 = col3 * -g + col3;                    \n  col3 = col3 * col3;\n  col3 = col3 * col3;\n                          \n       vec4 O =fragColor;           \n vec2 C =fragCoord;  \n \n  O=vec4(0);\n    vec3 p5,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(1),H(g*.1),.8)*1./e/8e3\n    )\n    {\n        p5=g*d;\n        p5.zx*=mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime) );\n      \n        a=30.;\n        p5=mod(p5-a,a*2.)-a;\n        s=3.;\n        p5.yz*=mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime) );\n        for(int i=0;i++<8;){\n            p5=.3-abs(p5);\n            \n            p5.x<p5.z?p5=p5.zyx:p5;\n            p5.z<p5.y?p5=p5.xzy:p5;\n            s*=e=1.4+sin(iTime*.1)*.1;\n            p5=abs(p5)*e-\n                vec3(\n                    5.+sin(iTime*.3+.5*sin(iTime*.3))*3.,\n                    120,\n                    8.+cos(iTime*.5)*5.\n                 );\n         }\n         g+=e=length(p5.yx)/s;\n    }\n \n\n    float maskup=(clamp(sparkerRise*_sparkRiseIntensity,0.,1.)+clamp(flowLine*_flowIntensity,0.,1.))*inversFade;\n\n    float mask=(maskup);\n\n    vec3 col =_Color;\n    vec3 horizonCol =_horizonColor;\n    vec3 haloCol =_haloColor;\n\n    float horizonBG=length(uv*vec2(0.1,50.)-vec2(0.,-5.));\n    horizonBG=(1./pow(dot(horizonBG,horizonBG),0.5))*_horizonBGIntensity;\n\n    float haloBG=length(uv*vec2(1.,10.)-vec2(0.,-1.));\n    haloBG=(8./pow(dot(haloBG,haloBG),1.2))*_haloBGIntensity;\n\n\n    horizonCol*=horizonBG;\n    haloCol*=haloBG;\n    col*=mask*haloCol*O.xyz;\n    \n\n    \n    \n  \n  \n    uv2 *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    fragColor+= vec4(happy_star(uv2, anim) * vec3(0.35,0.2,0.55), 1.0);\n     fragColor.rgb= col3*1.;\n     fragColor*=vec4((col+horizonCol)*circleFade+vec3(0.15),1.0);\n      fragColor*= vec4(happy_star(uv2, anim) * vec3(0.35,0.2,0.55)*3., 1.0);\n       fragColor+=vec4((col+horizonCol)*circleFade+vec3(0.15),1.0);\n    \n    }\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}