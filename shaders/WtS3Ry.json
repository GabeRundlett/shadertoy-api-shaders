{
    "Shader": {
        "info": {
            "date": "1559995614",
            "description": "Pathtraced ifs fractal. Click and drag to rotate camera",
            "flags": 32,
            "hasliked": 0,
            "id": "WtS3Ry",
            "likes": 14,
            "name": "Pathtraced fractal",
            "published": 3,
            "tags": [
                "fractal",
                "ifs",
                "pathtraced"
            ],
            "usePreview": 0,
            "username": "karltechno",
            "viewed": 912
        },
        "renderpass": [
            {
                "code": "#define DO_FILTER 0\n\n\nvec3 Tonemap(vec3 x)\n{\n    return 1. - exp2(-x);\n}\n\nvec3 Sample(in ivec2 coord)\n{\n    vec4 col = texelFetch(iChannel1, coord, 0);\n    return col.xyz/col.w;\n}\n\nvec4 FindMedian(vec4 samples[9])\n{\n    // bubble sort to unroll\n    for(int j=8;j>0;--j)\n    {\n        for(int i=0;i<j;++i)\n        {\n            vec4 a = samples[i];\n            vec4 b = samples[i+1];\n            if(a.w > b.w)\n            {\n\t\t\t\tsamples[i] = b;\n\t\t\t\tsamples[i+1] = a;\n            }\n        }\n    }\n        \n    return samples[4];\n}\n                      \nvec3 FilterMedian(in ivec2 coord)\n{\n#define DO_SAMPLE(x,y) samples[x+1+(y+1)*3] \n    vec3 lumaD = vec3(0.2126, 0.7152, 0.0722);\n    vec4 samples[9];\n \n    for(int y=-1;y<=1;++y)\n    {  \n        for(int x=-1;x<=1;++x)\n        {\n            vec3 c = Sample(coord + ivec2(x,y));\n            float l = dot(lumaD, c);\n            DO_SAMPLE(x, y) = vec4(c, l);\n        }\n    }\n\n    return FindMedian(samples).xyz;  \n\n#undef DO_SAMPLE\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if DO_FILTER\n    vec3 col = FilterMedian(ivec2(fragCoord));\n#else\n    vec3 col = Sample(ivec2(fragCoord));\n#endif\n    fragColor.xyz = Tonemap(3.75*col.xyz);\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    fragColor.xyz *= (1.-smoothstep(0.3, 1.0, length(uv-vec2(.5))));\n    fragColor.w = 1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const int TRACE_STEPS = 64;\nconst int SHADOW_STEPS = 32;\n\nconst float TRACE_EPS = 0.001;\nconst float NORM_EPS = 0.01;\n\nconst float kPi = 3.14159265359;\nconst float k2Pi = kPi*2.;\n\n#define USE_CUBEMAP 1\n#define NO_INDIRECT 0\n\nfloat SEED;\n\nmat2 rot2(float t)\n{\n    float s = sin(t);\n    float c = cos(t);\n    return\n        mat2\n        (\n            c, s,\n            -s, c\n        );\n}\n\nmat3 rotZ(float t)\n{\n    float s = sin(t);\n    float c = cos(t);\n    return \n        mat3\n        (\n            c, \ts, \t0.,\n           -s, \tc, \t0.,\n            0., 0., 1.\n         );\n}\n\nmat3 rotX(float t)\n{\n    float s = sin(t);\n    float c = cos(t);\n    return \n        mat3\n        (\n            1., 0., 0.,\n           \t0.,\tc, \ts,\n            0., -s, c\n         );\n}\n\nmat3 rotY(float t)\n{\n    float s = sin(t);\n    float c = cos(t);\n    return \n        mat3\n        (\n            c, 0., -s,\n            0.,\t1., 0,\n            s, 0, c\n         );\n}\n\nvec3 hue_to_rgb(float h)\n{\n    float R = abs(h * 6. - 3.) - 1.;\n    float G = 2. - abs(h * 6. - 2.);\n    float B = 2. - abs(h * 6. - 4.);\n    return min(vec3(1.), max(vec3(0.), vec3(R,G,B)));\n}\n\nvec3 hsv_to_rgb(vec3 HSV)\n{\n    vec3 RGB = hue_to_rgb(HSV.x);\n    return ((RGB - 1.) * HSV.y + 1.) * HSV.z;\n}\n\n\n// NOISE\n\n// https://www.shadertoy.com/view/4djSRW\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 19.19;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n// value noise\n\nfloat noise11(float x) {\n\tfloat i = floor(x);\n\tfloat f = fract(x);\n\tfloat u = f * f * (3.0 - 2.0 * f);\n\treturn mix(hash11(i), hash11(i + 1.0), u);\n}\n\n\nfloat noise12 (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = hash12(i);\n    float b = hash12(i + vec2(1.0, 0.0));\n    float c = hash12(i + vec2(0.0, 1.0));\n    float d = hash12(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\n\n// https://www.shadertoy.com/view/MdX3Rr\nfloat fbm2( in vec2 p ){\n    const mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\n    float f = 0.0;\n    f += 0.5000*noise12( p ); p = m2*p*2.02;\n    f += 0.2500*noise12( p ); p = m2*p*2.03;\n    f += 0.1250*noise12( p ); p = m2*p*2.01;\n    f += 0.0625*noise12( p );\n\n    return f/0.9375;\n}\n\n\nstruct Ray\n{\n    vec3 ro;\n    vec3 rd;\n};\n    \nstruct Intersection\n{\n    vec3 pos;\n    float rayT;\n};\n    \n\nmat3 Cam_MakeMtx(vec3 f, vec3 u)\n{\n    vec3 r = normalize(cross(f, u));\n    vec3 u2 = normalize(cross(r, f));\n    return mat3(r, u2, f);\n}\n\nvec4 Scene_Map(vec3 p);\n\nvec4 Scene_Trace(in Ray r, out Intersection intersect)\n{\n    float t = 0.;\n    float minDist = 3e10;\n    int i = 0;\n\n    for(; i < TRACE_STEPS; ++i)\n    {\n        vec3 p = r.ro + r.rd*t;\n               \n        vec4 dist = Scene_Map(p);\n        minDist = min(minDist, dist.x);\n        float eps = max(TRACE_EPS, TRACE_EPS * t);\n        if(abs(dist.x) < eps)\n        {\n            intersect.pos = p;\n            intersect.rayT = t;\n            return vec4(dist.x, minDist, float(i), dist.w);\n        }\n        \n        t += dist.x;\n    }\n    return vec4(-1.0, minDist, float(i), 0.);\n}\n\nvec3 Scene_Norm(vec3 p)\n{\n    vec2 e0 = vec2(NORM_EPS, 0.);\n    return normalize(vec3(\n        Scene_Map(p + e0.xyy).x - Scene_Map(p - e0.xyy).x,\n        Scene_Map(p + e0.yxy).x - Scene_Map(p - e0.yxy).x,\n        Scene_Map(p + e0.yyx).x - Scene_Map(p - e0.yyx).x\n    ));\n}\n\n\nconst float IFS_SCALE = 1.15;\nconst vec3 IFS_OFFSET = vec3(-0.6, -1.85, -0.6);\nconst int IFS_ITER = 16;\n\nmat3 scene_mtx;\n\nvec3 Rep(vec3 p, vec3 c)\n{\n    return mod(p, c)-.5*c;\n}\n\n#define MAT_FRACTAL 0.\n#define MAT_LIGHT 1.\n#define MAT_REFL 2.\n\n#define LIGHT_REP 1.75\n\nvec4 Scene_Map(vec3 p)\n{  \n    // Fractal\n    float scaleAccum = 1.;\n    vec3 fracP = p;\n     \n    for(int i = 0; i < IFS_ITER; ++i)\n    {\n        fracP = abs(fracP);\n        fracP *= IFS_SCALE;\n        scaleAccum *= IFS_SCALE;\n        fracP += IFS_OFFSET;\n        fracP = scene_mtx * fracP;\n        \n    }\n    vec4 fractalMap = vec4(length(fracP) / scaleAccum - 0.15, 0., 0., 0.);\n\n    vec3 sphPos = vec3(0., 0., 8.5);\n    vec3 sphDiff = vec3(1.5, 0., 0.75);\n    float sphRad = 0.15;\n    \n    float reflSph = length(sphPos-p)-sphRad*5.;\n   \n    vec3 modc = vec3(LIGHT_REP);\n    vec3 floorrnd = floor(p/modc);\n    \n    vec3 gridOffs = vec3(hash13(floorrnd), hash13(floorrnd.yzx), hash13(floorrnd.zyx));\n   \n    \n    gridOffs-=vec3(.5);\n    gridOffs*=1.5;\n    \n\tfloat minSph = length(Rep(p+gridOffs, modc))-sphRad;\n    minSph = max(minSph, length(p)-11.5);\n    \n    vec4 sphMap = vec4(min(minSph, reflSph), 0., 0., mix(MAT_LIGHT, MAT_REFL, step(reflSph, minSph)));\n    \n    \n    return sphMap.x < fractalMap.x ? sphMap : fractalMap;\n}\n\n\nfloat Rand()\n{\n    float r = hash11(SEED);\n   \tSEED += 1.2312; \n    return r;\n}\n\nvec3 SampleHemiCosineWeighted(vec3 n, vec2 u)\n{\n    float a = k2Pi * u.y;\n    u.x = 2.0*u.x - 1.0;\n    return normalize( n + vec3(sqrt(1.0-u.x*u.x) * vec2(cos(a), sin(a)), u.x) );\n}\n\nvec2 SampleDiscUniform()\n{\n    float a = Rand()*k2Pi;\n    float r = sqrt(Rand());\n    return vec2(cos(a), sin(a)) * r;\n}\n\n\nvec3 TraceCol(Ray r)\n{\n    vec3 diffuse = vec3(1.);\n    vec3 radiance = vec3(0.);\n    const int BOUNCES = 3;\n    Ray ray = r;\n    for(int i = 0; i < BOUNCES; ++i)\n    {\n        Intersection intersect;\n    \tvec4 trace = Scene_Trace(r, intersect);\n\n    \tif(trace.x > -1.)\n    \t{\n        \tvec3 norm = Scene_Norm(intersect.pos); \n            vec3 hemiDir = SampleHemiCosineWeighted(norm, vec2(Rand(), Rand()));\n\n            if(trace.w == MAT_LIGHT)\n            {\n                // light\n                float colT = hash13(floor(intersect.pos/vec3(LIGHT_REP)));\n                vec3 light = hsv_to_rgb(vec3(colT, 0.9, 0.8));\n                radiance += light*4.2*diffuse;\n                r.rd = hemiDir;\n            }\n            else if(trace.w == MAT_FRACTAL)\n            {\n                // Note, no 1/pi or cos term for lambert since cosine pdf.\n                // Random diffuse based on position\n                vec3 diff = vec3(fbm2(intersect.pos.xy), fbm2(intersect.pos.yx), fbm2(intersect.pos.yz));\n                diff*=0.5;\n                diff+=vec3(0.5);\n                diffuse *= diff;\n                r.rd = hemiDir;\n            }\n            else\n            {\n                // reflection\n                r.rd = reflect(r.rd, norm);\n            }\n            \n            r.ro = intersect.pos + r.rd * 0.01;\n    \t}\n    \telse\n    \t{ \n        #if !NO_INDIRECT\n        #if USE_CUBEMAP\n        \tradiance += texture(iChannel0, r.rd).xyz * diffuse*0.6;\n        #else\n            vec3 skyColB = vec3(0.65, 0.9, 0.9);\n            vec3 skyColA = vec3(0.95, 0.85, 0.6);\n    \t\tradiance += mix(skyColA, skyColB, smoothstep(-0.25, 0.3, r.rd.y))*diffuse*0.5;\n        #endif\n        #endif\n            break;\n        }\n    }\n\n    return radiance;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n \n    SEED = hash12(fragCoord + hash11(float(iFrame)));\n\n    scene_mtx = rotY(0.9*k2Pi) * rotZ(0.15*k2Pi);\n\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 st = uv;\n  \tst *= 2.0;\n    st -= vec2(1.0, 1.0);\n    st.x *= iResolution.x/iResolution.y;\n    \n    vec2 aa = (vec2(Rand(), Rand())-vec2(.5)) / iResolution.xy;\n    \n    st += aa;\n    \n\tvec2 mouse = texelFetch(iChannel2, ivec2(0), 0).zw;\n    vec3 ro = rotY(0.3 + mouse.x) * rotX(-mouse.y) * vec3(0., 0., 20.);\n  \t\n    vec3 camf = normalize(-ro);\n    mat3 camMtx = Cam_MakeMtx(camf, vec3(0., 1., 0.));\n    \n    const float FOCAL_DIST = 12.;\n    const float APERTURE = 0.35;\n    const float FOV_DEG = 35.;\n    \n    float fov = tan(FOV_DEG*kPi/360.);\n    \n    vec3 pointOnFilm = vec3(st*fov*FOCAL_DIST, FOCAL_DIST);  \n    vec3 apertureOffs = vec3(SampleDiscUniform(),0.)*APERTURE;\n       \n    Ray r;\n    r.ro = ro + camMtx*apertureOffs;\n    r.rd = camMtx*normalize(pointOnFilm-apertureOffs);\n \n\n    vec3 col = TraceCol(r);\n    vec4 oldCol;\n\tif(iFrame == 0 || iMouse.z > 0.)\n    {\n        oldCol = vec4(0.);\n    }\n    else\n    {\n        oldCol = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    }\n    \n    //fragColor = vec4(oldCol + (col - oldCol)/float(iFrame), 1.);\n\tfragColor = oldCol + vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame == 0)\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n\n    vec4 oldMouse = texelFetch(iChannel0, ivec2(0, 0), 0);\n    float oldDown = texelFetch(iChannel0, ivec2(4, 0), 0).x;\n    \n    vec2 diff = vec2(0.);\n    \n    if(iMouse.z > 0.)\n    {       \n        if(oldDown > 0.)\n        {\n            diff = iMouse.xy - oldMouse.xy;\n        }\n    }\n    \n    if(ivec2(fragCoord) == ivec2(0, 0))\n    {\n        fragColor.xy = iMouse.xy;\n        fragColor.zw = oldMouse.zw + diff / iResolution.xy;\n        fragColor.w = clamp(fragColor.w, -0.5, 0.5); \n    }\n\n    if(ivec2(fragCoord) == ivec2(4, 0))\n    {\n        fragColor.x = step(0.0, iMouse.z);\n        fragColor.yzw = vec3(0.);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}