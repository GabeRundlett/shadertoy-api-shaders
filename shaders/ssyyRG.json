{
    "Shader": {
        "info": {
            "date": "1656691723",
            "description": "Fork of [url]https://www.shadertoy.com/view/7dyyWm[\\url] demonstrating the symmetry axes and path of iterated reflections of a point. Go to base version for further info.\nUse your mouse to move the starting point.",
            "flags": 0,
            "hasliked": 0,
            "id": "ssyyRG",
            "likes": 3,
            "name": "kaleidoscope reflections",
            "published": 3,
            "tags": [
                "reflection",
                "interactive",
                "folding",
                "kaleidoscope",
                "tiling",
                "symmetry"
            ],
            "usePreview": 0,
            "username": "hnh",
            "viewed": 269
        },
        "renderpass": [
            {
                "code": "\n// Fork of 'kaleidoscope variations', https://www.shadertoy.com/view/7dyyWm \n// to visualize the fold() algorithm. A point in the plane is repeatedly reflected \n// about the symmetry axes until reaching the base triangle at the center.\n// Drawing info is directly obtained from fold() which certainly is not the most efficient way.\n// Pause shader to keep zoom fixed. More info at the base version mentioned above.\n// Note: lines marked by '//o' are comment-switchable (optional).\n\n// visual mode - 1: gray level = num. reflections, 2: RGB = trilinear coordinates\n#define M 1\n\n#define PI 3.14159265\n#define R iResolution\n#define SM(x) smoothstep(1.,0.,(x)*R.y/(sc*2.))  // antialiasing\n\n// The angles are defined by divisors of PI in each row (reflection mode).\n// In the Euclidean plane their inverses must sum to one.\nconst mat3 D = mat3(\n    3,3,3,\n    2,4,4,\n    2,3,6);\n\nfloat seg(vec2 p, vec2 a, vec2 b){  // line segment SDF - by iq\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n    return length(pa - ba*h);\n}\n\n// slightly modified version to draw reflection info of a point given in V\nvec4 fold(vec2 p, float sc, vec3 ang, vec2 V) {\n    vec3 c = cos(ang), s = sin(ang);\n    mat3 N = mat3(  // normals\n        1, 0, 0,\n        -c.x, s.x, 0,\n        -c.z, -(c.y+c.x*c.z)/s.x, 1);\n\n    sc *= s.z;  // set longest edge to unit length\n    vec3 q = vec3(p,sc), qq;\n    vec4 u, v = vec4(9e9);\n    int nf = 0;  // fold counter\n    \n    for(int i=0; i<9999; i++) {\n        for(int j=0; j<3; j++) {\n            qq = q;\n            u[j] = dot(q, N[j]);\n            if(u[j] < 0.) {q -= 2.*u[j]*N[j]*vec3(1,1,0); nf++;}\n\t\t\t\n\t\t\tif(V.x<9e9) {  // return drawing SDFs instead of trilinear coordinates\n                if(i==0) v.x = min(v.x, \n                    abs  //o symmetry axes (otherwise: base triangle)\n                    (dot(vec3(V, sc), N[j])));\n                v.y = min(v.y, length(qq.xy - V));  // reflected point\n                float s = seg(V,q.xy,qq.xy);  // reflection path\n                if(s < v.z+.001){ v.z = s; v.w = float(nf); }\n            }\n        }\n        if(i>=nf) break;  // base triangle is reached\n    }\n    v.w /= float(nf);\n    return V.x<9e9 ? v : u;\n}\n\n\nvoid mainImage(out vec4 O, vec2 U) {\n    float t = iTime*.1;\n    \n    int m = 0;  //p reflection mode (0,1,2)\n    m = int(t)%3;  //o cycle modes\n            \n    float sc = 10., a = 2., b = R.y*.075;  //p scale, bounce interval\n    sc = sqrt(b*a)*pow(b/a, .5*cos(2.*PI*t));  //o bouncing zoom\n    \n\tU = sc*(U*2.-R.xy)/R.y;\n\n    vec2 p = iMouse.z<=0. ? vec2(-.7,-.8)*sc : sc*(iMouse.xy*2.-R.xy)/R.y;\n        \n    vec4 u = fold(U, 1., PI/D[m], vec2(9e9));\n    vec4 v = fold(p, 1., PI/D[m], U);\n\n#if M==1\n    O = vec4(0);  // monochrome background\n    mat4 c = mat4( // line colors\n        0,0,.5,1,\n        0,.6,.3,1,\n        vec4(1.-v.w*.9),  // darken with number of reflections\n        1,1,0,1);\n#else\n    O = u;\n    mat4 c; c += 1.-c;  // white lines, except...\n    c[0] -= 1.;\n#endif\n    \n    O = mix(O,c[0],SM(min(u.x,min(u.y,u.z))-.01));  //o grid\n    O = mix(O,c[1],SM(abs(v.x)-.01));  //o symmetry axes/base triangle\n    O = mix(O,c[2],SM(v.z-.015));  //o reflection path\n    O = mix(O,c[3],SM(v.y-.05));  //o reflected point\n    \n    O.a= 1.;  // who knows...\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}