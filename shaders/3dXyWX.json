{
    "Shader": {
        "info": {
            "date": "1585671719",
            "description": "controls: WASDQE + dragging mouse left button\n\nthe wormhole is flipped in the WX direction (right and 4th D). the Y (up) and Z (backwards) get mirrored. ",
            "flags": 48,
            "hasliked": 0,
            "id": "3dXyWX",
            "likes": 2,
            "name": "[jmmut] wormhole flyer",
            "published": 3,
            "tags": [
                "raymarching",
                "wormhole"
            ],
            "usePreview": 0,
            "username": "jmmut",
            "viewed": 329
        },
        "renderpass": [
            {
                "code": "//jmmut: except for code coming from other people (which I noted and might have modified here), the license is http://www.wtfpl.net/\n\n\n// keyboard taken from: https://www.shadertoy.com/view/XdS3RV\n// Hazel Quantock 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// keys are javascript keycode: https://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes\nconst int Key_A = 65; const int Key_B = 66; const int Key_C = 67; const int Key_D = 68; const int Key_E = 69;\nconst int Key_F = 70; const int Key_G = 71; const int Key_H = 72; const int Key_I = 73; const int Key_J = 74;\nconst int Key_K = 75; const int Key_L = 76; const int Key_M = 77; const int Key_N = 78; const int Key_O = 79;\nconst int Key_P = 80; const int Key_Q = 81; const int Key_R = 82; const int Key_S = 83; const int Key_T = 84;\nconst int Key_U = 85; const int Key_V = 86; const int Key_W = 87; const int Key_X = 88; const int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48; const int Key_1 = 49; const int Key_2 = 50; const int Key_3 = 51; const int Key_4 = 52;\nconst int Key_5 = 53; const int Key_6 = 54; const int Key_7 = 55; const int Key_8 = 56; const int Key_9 = 57;\n\nvec4 ReadKey(int key, bool toggle) {\n\t//bool toggle = false;\n\tvec4 keyVal = textureLod( iChannel1, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 );\n\t//return (keyVal>.5)?true:false;\n    return keyVal;\n}\n\n// save/load code from IQ's shader (multipass): https://www.shadertoy.com/view/MddGzf\nvec4 _loadValue( in ivec2 re ) {\n    return texelFetch( iChannel0, re, 0 );\n    //return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\n//ugly hack here. couldn't make the float span the whole vec4\n\n//highp vec4 encode32(highp float f) {\n//    return vec4(f, 0., 0., 0.);\n//}\n//highp float decode32(highp vec4 rgba) {\n//    return rgba.x;\n//}\n\nvec4 _encode32(float f) {\n    return vec4(f, 0., 0., 0.);\n}\nfloat _decode32(vec4 rgba) {\n    return rgba.x;\n}\nfloat _loadDecoded(in int x, in int y) { return _decode32(_loadValue(ivec2(x, y))); }\n\n// --------- from rally simulator https://www.shadertoy.com/view/XdcGWS\nvec4 LoadVec4( in ivec2 vAddr )\n{\n    return texelFetch( iChannel0, vAddr, 0 );\n}\n\nvec3 LoadVec3( in ivec2 vAddr )\n{\n    return LoadVec4( vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, ivec2 c ) { return all( equal( floor(p), vec2(c) ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n// --------- from rally simulator\n\n\n// ----- start my load/store functions\nvec4 load(ivec2 address) {\n    return texelFetch(iChannel0, address, 0);\n}\n\nvoid store(out vec4 fragColor, vec4 value) {\n    fragColor = value;\n}\n\n// ----- end my load/store functions\n\n// based on\n// \"ShaderToy Tutorial - Ray Marching for Dummies!\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nstruct Intersection { float _distance; vec3 color; };\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nIntersection unionOp(Intersection a, Intersection b) {\n    if (a._distance < b._distance) {\n        return a;\n    } else {\n        return b;\n    }\n}\nIntersection substractionOp(Intersection a, Intersection b) {\n    if (a._distance > -b._distance) {\n        return Intersection(a._distance, a.color);\n    } else {\n        return Intersection(-b._distance, a.color);\n    }\n}\nIntersection intersectionOp(Intersection a, Intersection b ) {\n    return Intersection(max(a._distance, b._distance), a.color);\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 H33(vec3 p) {\n    return texture(iChannel2, (p/40.).zy + vec2(0.5, 0.3), 0.).xyz;\n}\n\nvec3 getLightPos() {\n    vec3 lightPos = vec3(0, 10, -2);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*3.;\n    return lightPos;\n}\n\nIntersection RayMarch(vec3, vec3, float);\n\nvec3 getSphereNormal(vec3 p, vec3 center) {\n    return normalize(p - center);\n}\n\n// colors\nvec3 orange = vec3(0.8, 0.4, 0.1);\nvec3 yellow = vec3(0.8, 0.7, 0.4);\nvec3 blue = vec3(0.1, 0.2, 0.9);\nvec3 green = vec3(0.1, 0.6, 0.2);\nvec3 purple = vec3(0.6, 0.2, 0.8);\nvec3 cyan = vec3(0.1, 0.6, 0.8);\nvec3 red = vec3(0.8, 0.1, 0.1);\nvec3 lightBlue = vec3(0.5, 0.5, 0.9);\nIntersection GetDist(vec3 p) {\n\tvec4 s1 = vec4(3, 5, -2, 1);\n\tvec4 s2 = vec4(-2, 5, -2, 1);\n    \n    Intersection sphere1Dist = Intersection(length(p-s1.xyz)-s1.w, orange);\n    Intersection sphere2Dist = Intersection(length(p-s2.xyz)-s2.w, orange);\n    \n    vec3 lightBulbPos = getLightPos() + vec3(0., .0, 0.);\n    Intersection lightBulbDist = Intersection(length(p - lightBulbPos)-0.4, yellow);\n    float hDistanceToPlaneBorder = max(p.x, p.z) - 20.;\n    Intersection planeDist = Intersection(hDistanceToPlaneBorder > 0. ?\n                                          sqrt(hDistanceToPlaneBorder*hDistanceToPlaneBorder + p.y*p.y)\n                                          : p.y, blue);\n    Intersection boxDist = Intersection(sdBox(p - vec3(3, 5, 2), vec3(1.)), green);\n    Intersection boxDist2 = Intersection(sdBox(p - vec3(-7, 5, -2), vec3(1.)), red);\n    Intersection lightBulbRemoval = Intersection(sdBox(p - lightBulbPos, vec3(.3, .1, .3)),yellow);\n    \n    Intersection d = Intersection(1e10, vec3(0));\n    d = unionOp(d, planeDist);\n    d = unionOp(d, Intersection(p.z + 20., purple));\n    d = unionOp(d, Intersection(p.x + 20., cyan));\n    d = unionOp(d, Intersection(20. - p.x, H33(p)));\n    d = unionOp(d, Intersection(20. - p.z, lightBlue));\n    d = unionOp(d, Intersection(40. - p.y, vec3(.1)));\n    d = unionOp(d, sphere1Dist);\n    d = unionOp(d, sphere2Dist);\n    d = unionOp(d, boxDist);\n    d = unionOp(d, boxDist2);\n    //d = unionOp(d, lightBulbDist);\n    //d = unionOp(d, lightBulbRemoval);\n    Intersection lightBulb = substractionOp(lightBulbRemoval, lightBulbDist);\n    d = unionOp(d, Intersection(1.*lightBulb._distance, lightBulb.color));\n    return d;\n}\n\nIntersection wormwholeX(vec3 p, vec3 rd, vec4 s1, vec4 s2) {\n    vec3 s1tos2 = s2.xyz - s1.xyz;\n    float mirrorDistance1 = 2.*(p.x - s1.x);\n    s1tos2.x -= mirrorDistance1;\n    vec3 n1 = getSphereNormal(p, s1.xyz);\n    vec3 newRD1 = abs(dot(n1, rd)) * 2. * n1 + rd;\n    newRD1.x *= -1.; // the wormhole is folded in dimensions xw\n    vec3 mirroredPoint1 = p + s1tos2 + newRD1*SURF_DIST*2.;\n    Intersection s1color = RayMarch(mirroredPoint1, newRD1, MAX_DIST); // note the color is a ray in the other sphere\n    Intersection sphere1Dist = Intersection(length(p-s1.xyz)-s1.w, s1color.color);\n    return sphere1Dist;\n}\n    \nIntersection GetDistRecursive(vec3 p, vec3 rd) {\n\tvec4 s1 = vec4(3, 5, -2, 1);\n\tvec4 s2 = vec4(-2, 5, -2, 1);\n    \n    Intersection sphere1Dist = wormwholeX(p, rd, s1, s2);\n    Intersection sphere2Dist = wormwholeX(p, rd, s2, s1);\n    vec3 lightBulbPos = getLightPos() + vec3(0., .0, 0.);\n    Intersection lightBulbDist = Intersection(length(p - lightBulbPos)-0.4, yellow);\n    \n    float hDistanceToPlaneBorder = max(p.x, p.z) - 20.;\n    Intersection planeDist = Intersection(hDistanceToPlaneBorder > 0. ?\n                                          sqrt(hDistanceToPlaneBorder*hDistanceToPlaneBorder + p.y*p.y) \n                                          : p.y, blue);\n    Intersection boxDist = Intersection(sdBox(p - vec3(3, 5, 2), vec3(1.)), green);\n    Intersection boxDist2 = Intersection(sdBox(p - vec3(-7, 5, -2), vec3(1.)), red);\n    Intersection lightBulbRemoval = Intersection(sdBox(p - lightBulbPos, vec3(.3, .1, .3)),yellow);\n    \n    Intersection d = Intersection(1e10, vec3(0));\n    d = unionOp(d, planeDist);\n    d = unionOp(d, Intersection(p.z + 20., purple));\n    d = unionOp(d, Intersection(p.x + 20., cyan));\n    d = unionOp(d, Intersection(20. - p.x, H33(p)));\n    d = unionOp(d, Intersection(20. - p.z, lightBlue));\n    d = unionOp(d, Intersection(40. - p.y, vec3(.1)));\n    d = unionOp(d, sphere1Dist);\n    d = unionOp(d, sphere2Dist);\n    d = unionOp(d, boxDist);\n    d = unionOp(d, boxDist2);\n    //d = unionOp(d, lightBulbDist);\n    //d = unionOp(d, lightBulbRemoval);\n    d = unionOp(d, substractionOp(lightBulbRemoval, lightBulbDist));\n    return d;\n}\n\nIntersection RayMarch(vec3 ro, vec3 rd, float maxDistance) {\n\tfloat dO=0.;\n    Intersection intersection;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        intersection = GetDist(p);\n        float dS = intersection._distance;\n        dO += dS;\n        if(dO>maxDistance || dS<SURF_DIST) break;\n    }\n    \n    return Intersection(dO, intersection.color);\n}\n\nIntersection RayMarchRecursive(vec3 ro, vec3 rd, float maxDistance) {\n\tfloat dO=0.;\n    Intersection intersection;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tp = ro + rd*dO;\n        intersection = GetDist(p);\n        float dS = intersection._distance;\n        dO += dS;\n        if(dO>maxDistance || dS<SURF_DIST) break;\n    }\n    intersection = GetDistRecursive(p, rd);\n    \n    return Intersection(dO, intersection.color);\n}\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p)._distance;\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy)._distance,\n        GetDist(p-e.yxy)._distance,\n        GetDist(p-e.yyx)._distance);\n    \n    return normalize(n);\n}\n\n    \nIntersection GetLight(vec3 p) {\n    vec3 lightPos = getLightPos();\n    vec3 lightRay = normalize(lightPos-p);\n    float distanceToLight = length(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    // surfaces perpendicular to the light are more illuminated\n    // clamp to round negative values up to 0. \n    float diffuse = clamp(dot(n, lightRay), 0., 1.);\n    \n    // if there's some object between our point and the light, reduce the diffuse light\n    // the extra SURF_DIST is to not stop where we start and allow the ray to go out\n    //Intersection i = RayMarch(p+n*SURF_DIST*2., lightRay, distanceToLight + SURF_DIST*50.);\n    Intersection i = RayMarch(p+n*SURF_DIST*2., lightRay, min(MAX_DIST, distanceToLight + SURF_DIST*3.));\n    if(i._distance < distanceToLight) {\n        float transparency = .1; // 1==invisible, 0==opaque \n        diffuse *= transparency;\n    } else {\n        float transparency = .8; // 1==invisible, 0==opaque \n        diffuse *= transparency;\n    }\n    return Intersection(diffuse, i.color*diffuse);\n}\n\n\nmat4 loadMatrix() {\n    return mat4(load(ivec2(1,1)),\n                load(ivec2(2,1)),\n                load(ivec2(3,1)),\n                load(ivec2(4,1))\n                );\n}\n \nconst ivec2 mouseAddress = ivec2(9, 1);\nconst ivec2 positionAddress = ivec2(6, 1);\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy/iResolution.xy - .5)* 4.;\n    \n    vec4 cameraPosition = load(positionAddress);\n    vec4 originalRo = vec4(0., 5.1, 10., 1.);\n    vec3 ro = (cameraPosition + originalRo).xyz;\n    \n    \n    mat4 rotationMatrix = loadMatrix();\n    mat4 transposedRotationMatrix = transpose(rotationMatrix);\n    vec3 zAxisOfRotationMatrix = vec3(rotationMatrix[2][0], rotationMatrix[2][1], rotationMatrix[2][2]);\n    vec3 rd = normalize((vec4(uv.x, uv.y, -1, 1) * rotationMatrix).xyz);\n    \n    vec4 viewMode = ReadKey(Key_V, true);\n    if (viewMode.x == 0.) {\n        Intersection i = RayMarchRecursive(ro, rd, MAX_DIST);\n        \n        vec3 p = ro + rd * i._distance;\n        \n        if (true) {\n        \tIntersection diffuse = GetLight(p);\n            fragColor = vec4(mix(diffuse.color, i.color, 0.5), 1.0);\n        //fragColor = vec4(vec3(diffuse._distance), 1.0);\n        } else {\n        \tfragColor = vec4(i.color, 1.0);\n        }\n    } else {\n        vec2 grid = 7.*fragCoord/iResolution.y-1.;\n        ivec2 coord = ivec2(floor(grid));\n        \n        if (coord.x >= 0 && coord.x <= 3 && coord.y >= 0 && coord.y <=3) {\n            fragColor = vec4(rotationMatrix[coord.x][3 - coord.y], 0., 0., 0.)/3.;\n            fragColor.y = -fragColor.x;\n            //fragColor = vec4(fract(grid.x), fract(grid.y), 0.5, 1.);\n            //fragColor = vec4(float(coord.x)*0.5, float(coord.y)*0.125, 0.5, 1.);\n        } else if (coord == mouseAddress) {\n            vec4 mouse = load(coord);\n            if (fract(grid.x) < 0.25) {\n                fragColor = vec4(mouse.x, -mouse.x, 0., 0.);\n            } else if (fract(grid.x) < 0.5) {\n                fragColor = vec4(mouse.y, -mouse.y, 0., 0.);\n            } else if (fract(grid.x) < 0.75) {\n                fragColor = vec4(mouse.z, -mouse.z, 0., 0.);\n            } else {\n                vec4 v_key = ReadKey(Key_V, true);\n                fragColor = v_key;\n            }\n        } else if (coord.x == 5 && coord.y >= 1 && coord.y <= 3) {\n            vec4 cameraPosition = load(positionAddress);\n            fragColor = vec4(cameraPosition[3-coord.y], -cameraPosition[3-coord.y], 0., 0.)/3.;\n        } else if (coord.x == 7 && coord.y >= 1 && coord.y <= 3) {\n            fragColor = vec4(originalRo[3-coord.y], -originalRo[3-coord.y], 0., 0.)/3.;\n        } else if (coord.x == 8 && coord.y >= 1 && coord.y <= 3) {\n            fragColor = vec4(ro[3-coord.y], -ro[3-coord.y], 0., 0.)/3.;\n        } else {\n            fragColor = vec4(0.1, 0.2, 0.8, 1.);\n        }\n    }\n}\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//jmmut: except for code coming from other people (which I noted and might have modified here), the license is http://www.wtfpl.net/\n\n\nconst ivec2 mouseAddress = ivec2(9, 1);\nconst ivec2 positionAddress = ivec2(6, 1);\n\n// keys are javascript keycode: https://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes\nconst int Key_A = 65; const int Key_B = 66; const int Key_C = 67; const int Key_D = 68; const int Key_E = 69;\nconst int Key_F = 70; const int Key_G = 71; const int Key_H = 72; const int Key_I = 73; const int Key_J = 74;\nconst int Key_K = 75; const int Key_L = 76; const int Key_M = 77; const int Key_N = 78; const int Key_O = 79;\nconst int Key_P = 80; const int Key_Q = 81; const int Key_R = 82; const int Key_S = 83; const int Key_T = 84;\nconst int Key_U = 85; const int Key_V = 86; const int Key_W = 87; const int Key_X = 88; const int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48; const int Key_1 = 49; const int Key_2 = 50; const int Key_3 = 51; const int Key_4 = 52;\nconst int Key_5 = 53; const int Key_6 = 54; const int Key_7 = 55; const int Key_8 = 56; const int Key_9 = 57;\n\nbool ReadKey( int key )//, bool toggle )\n{\n\tbool toggle = false;\n\tfloat keyVal = textureLod( iChannel1, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\n// save/load code from IQ's shader: https://www.shadertoy.com/view/MddGzf\n\nfloat isInside( vec2 p, vec2 c ) {\n    vec2 d = abs(p-0.5-c) - 0.5;\n    return -max(d.x,d.y);\n}\nfloat isInside( vec2 p, vec4 c ) {\n    vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5;\n    return -max(d.x,d.y);\n}\n\n\nvec4 _loadValue( in vec2 re )\n{\n    \n    return texelFetch( iChannel0, ivec2(re), 0 );\n    //return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\nvec4 _loadValue( in int x, in int y ) { return _loadValue(vec2(x, y)); }\n\n\n//ugly hack here. couldn't make the float span the whole vec4\nhighp vec4 _encode32(highp float f) {\n    return vec4(f, 0., 0., 0.);\n}\nhighp float _decode32(highp vec4 rgba) {\n    return rgba.x;\n}\nfloat _loadDecoded(in int x, in int y) { return _decode32(_loadValue(x, y)); }\nfloat _loadDecoded(in ivec2 re) { return _decode32(_loadValue(vec2(re))); }\n\nvoid _storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nvoid _storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\n\n\n\n\n// --------- from rally simulator https://www.shadertoy.com/view/XdcGWS\nvec4 LoadVec4( in ivec2 vAddr )\n{\n    return texelFetch( iChannel0, vAddr, 0 );\n}\n\nvec3 LoadVec3( in ivec2 vAddr )\n{\n    return LoadVec4( vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, ivec2 c ) { return all( equal( floor(p), vec2(c) ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n// --------- from rally simulator\n\n// ----- start my load/store functions\nvec4 load(ivec2 address) {\n    return texelFetch(iChannel0, address, 0);\n}\n\nvoid store(out vec4 fragColor, vec4 value) {\n    fragColor = value;\n}\n\n// ----- end my load/store functions\n\nmat4 loadMatrix() {\n    return mat4(load(ivec2(1,1)),\n                load(ivec2(2,1)),\n                load(ivec2(3,1)),\n                load(ivec2(4,1))\n                );\n}\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nmat4 RotY(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat4(c,  0, -s,  0,\t// matrices are transposed: this line is the first matrix column\n                0,  1,  0,  0,\n                s,  0,  c,  0,\n                0,  0,  0,  1\n               );\n}\nmat4 RotX(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat4(1,  0,  0,  0,\n                0,  c,  s,  0,\n                0, -s,  c,  0,\n                0,  0,  0,  1\n               );\n}\nmat4 RotZ(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat4(c,  s,  0,  0,\n               -s,  c,  0,  0,\n                0,  0,  1,  0,\n                0,  0,  0,  1\n               );\n}\n\n\nvoid reset(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 thisPixelAddress = ivec2(fragCoord);\n    if (thisPixelAddress.y == 1) {\n        // we will only write state to addresses y==1 to simplify\n        mat4 identity = mat4  (1, 0, 0, 0,\n                               0, 1, 0, 0,\n                               0, 0, 1, 0,\n                               0, 0, 0, 1\n                               );\n    \n        if (thisPixelAddress.x >= 1 && thisPixelAddress.x <= 4 && thisPixelAddress.y == 1) {\n            store(fragColor, identity[thisPixelAddress.x-1]);\n        } else if (thisPixelAddress == mouseAddress) {\n            store(fragColor, vec4(0., 0., 0., 0.));\n        }\n    }\n}\nvoid updateRotationMatrix(out vec4 fragColor, vec2 mouse, mat4 rotationMatrix, ivec2 thisPixelAddress) {\n    float mouseSpeed = 0.75;\n    vec4 previousMouse = load(mouseAddress);\n    if (previousMouse.z > 0.) { // avoid jumping when clicking\n        vec2 mouseDiff = vec2(mouse - previousMouse.xy);\n        rotationMatrix = rotationMatrix * RotY(-mouseDiff.x * mouseSpeed); // yaw, external rotation\n        rotationMatrix = RotX(mouseDiff.y * mouseSpeed) * rotationMatrix; // pitch\n    }\n    vec4 column = rotationMatrix[thisPixelAddress.x-1];\n    store(fragColor, column);\n}\n\nvoid composeTransformations(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 thisPixelAddress = ivec2(fragCoord);\n    if (thisPixelAddress.y == 1) {\n        // we will only write state to addresses y==1 to simplify\n        \n        float movement = 0.;\n        mat4 rotationMatrix = loadMatrix();\n        \n        vec2 mouse = (iMouse.xy /iResolution.xy - .5) * 2.;\t// range [-1, 1]\n        \n        if (thisPixelAddress == mouseAddress) {\n            store(fragColor, vec4(mouse.x, mouse.y, iMouse.z, 0.));\n        } else if (thisPixelAddress == positionAddress) {\n            vec4 position = load(positionAddress);\n            float speed = 0.2;\n            float up      = ReadKey(Key_W)? speed : 0.;\n            float down    = ReadKey(Key_S)? speed : 0.;\n            float right   = ReadKey(Key_D)? speed : 0.;\n            float left    = ReadKey(Key_A)? speed : 0.;\n            float forward = ReadKey(Key_E)? speed : 0.;\n            float back    = ReadKey(Key_Q)? speed : 0.;\n            vec4 movement = vec4(right - left, up - down, back - forward, 1.);\n            store(fragColor, movement * rotationMatrix + position);\n        } else if (thisPixelAddress.x >= 1 && thisPixelAddress.x <= 4) {\n            updateRotationMatrix(fragColor, mouse, rotationMatrix, thisPixelAddress);\n        }\n        \n        // I will go crazy if I keep trying to remove this redundant code\n        else if (thisPixelAddress.x == 4) {\n            updateRotationMatrix(fragColor, mouse, rotationMatrix, thisPixelAddress);\n        }\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0) {\n        reset(fragColor, fragCoord);\n    } else {\n        composeTransformations(fragColor, fragCoord);\n        //reset(fragColor, fragCoord);\n    }\n}\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n\nconst ivec2 mouseAddress = ivec2(9, 1);\nconst ivec2 positionAddress = ivec2(6, 1);\n//const ivec2 directionAddress = ivec2(7, 1);\n\nvec4 initialCameraPosition = vec4(0., 5., 10., 0.); //vec3 pos, bool didIJustTeleport?\n\n// wormhole positions and sizes\nconst vec4 wh1 = vec4(3, 5, -2, 1); // vec3 pos, float size\nconst vec4 wh2 = vec4(-2, 5, -2, 1);\n\nvec3 getSphereNormal(vec3 p, vec3 center) {\n    return normalize(p - center);\n}\n\nvec3 mirrorDirection(vec3 direction, vec3 p, vec3 s1, vec3 s2) {\n    vec3 n1 = getSphereNormal(p, s1.xyz);\n    vec3 newDirection = -dot(n1, direction) * 2. * n1 + direction;\n    newDirection.x *= -1.; // the wormhole is folded in dimensions xw\n    return newDirection;\n}\n\nvec3 mirrorPoint(vec3 p, vec3 s1, vec3 s2) {\n    vec3 s1toP = p - s1;\n    vec3 s1toS2 = s2 - s1;\n    vec3 normalizedS1toS2 = normalize(s1toS2);\n    vec3 proyection = normalizedS1toS2 * dot(s1toP, normalizedS1toS2);\n    return p + s1toS2 - 2.*proyection;\n}*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}