{
    "Shader": {
        "info": {
            "date": "1572548993",
            "description": "Eyes, probably watching you.",
            "flags": 0,
            "hasliked": 0,
            "id": "Wd3SRl",
            "likes": 1,
            "name": "Blink",
            "published": 3,
            "tags": [
                "eyes",
                "eye",
                "blink",
                "blinking",
                "watching"
            ],
            "usePreview": 0,
            "username": "flypig",
            "viewed": 492
        },
        "renderpass": [
            {
                "code": "// David Llewellyn-Jones david@flypig.co.uk, 31/10/2019\n// Based on \"Bokeh Paralax\" by Krzysztof Narkowicz @knarkowicz\n// License: public domain\n// See https://www.shadertoy.com/view/4s2yW1\n\nprecision highp float;\n\n#define M_PI 3.1415926535897932384626433832795\nvec2 fragCoord;\nuniform float iGlobalTime;\nuniform vec2 iScroll;\n\nvoid rotate(inout vec2 p, float a)  {\n\tp = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\nfloat circle(vec2 p, float r) {\n\treturn (length( p / r) - 1.0) * r;\n}\n\nfloat rand(vec2 c) {\n\treturn fract(sin(dot(c.xy, vec2( 12.9898, 78.233))) * 43758.5453);\n}\n\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\n\nvoid bokehlayer(inout vec3 color, vec2 p, vec3 c, float scale) {\n\tfloat wrap = 550.0;    \n\tif (mod(floor(p.y / wrap + 0.5 ), 2.0) == 0.0) {\n\t\tp.x += wrap * 0.5;\n\t}\n\n\tvec2 p2 = mod(p + 0.5 * wrap, wrap) - 0.5 * wrap;\n\tvec2 cell = floor(p / wrap + 0.5);\n\tfloat cellR = rand(cell);\n\n\tc *= fract(scale * 3.33 + 3.33);    \n\tfloat radius = mix(30.0, 70.0, fract( scale * 7.77 + 7.77));\n\tp2.x *= mix(0.9, 1.1, fract( scale * 11.13 + 11.13));\n\tp2.y *= mix(0.9, 1.1, fract( scale * 17.17 + 17.17));\n    p2 *= 1.5;\n\n    vec2 p3 = p2 * 1.5;\n\n\tfloat time = iTime / (2.0 + cellR);\n    \n    p2.y /= (1.0 - max(20.0 * (sin(time) - 0.95), 0.0)) * 1.0;\n   \n\tfloat outer_distance = circle(p2, radius);\n\tfloat outer = 1.0 - smoothstep(0.0, 1.0, outer_distance * 0.04);\n\n\tfloat inner_distance = circle(p3, radius / 10.0);\n\tfloat inner = 1.0 - smoothstep(0.0, 1.0, inner_distance * 0.04);\n    \n\tcolor += c * max(outer - inner, 0.0);\n\n    if ((inner > 0.0) && (outer > 0.0)) {\n        color *= 0.0;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.x * 1000.0;\n\tvec2 shifted;\n\n\tvec2 shift;\n\tshift.x = 0.0;\n\tshift.y = iScroll.y * iResolution.y;\n\n\t// background\n\t//vec3 color = mix(vec3( 0.1, 0.0, 0.1), vec3(0.1, 0.2, 0.5), dot(uv, vec2( 0.2, 0.7)));\n\tvec3 color = vec3( 0.0, 0.0, 0.0 );\n\n\tshifted = p + 0.2 * shift;\n\trotate(shifted, 0.2);\n\tbokehlayer(color, shifted + vec2( 0.0, 00.0  ), 3.0 * vec3( 1.0, 1.0, 1.0), 0.5);\n\n\tshifted = p + 1.0 * shift;\n\trotate(shifted, 0.5);\n\tbokehlayer(color, shifted + vec2( 100.0, 70.0  ), 3.0 * vec3( 1.0, 1.0, 1.0), 10.0);\n    \n\tshifted = p + 0.9 * shift;\n\trotate(shifted, 1.8);\n\tbokehlayer(color, shifted + vec2( 20.0, 120.0  ), 3.0 * vec3( 1.0, 1.0, 1.0), 20.0);\n    \n\tshifted = p + 0.0 * shift;\n\trotate(shifted, 1.1);\n\tbokehlayer(color, shifted + vec2( 40.0, 30.0  ), 3.0 * vec3( 1.0, 1.0, 1.0), 15.0);\n    \n\tfragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}