{
    "Shader": {
        "info": {
            "date": "1656853447",
            "description": "practice on volumetric cloud rendering",
            "flags": 32,
            "hasliked": 0,
            "id": "sdtBz2",
            "likes": 0,
            "name": "practice on volumetric cloud",
            "published": 3,
            "tags": [
                "noise",
                "cloud",
                "perlin",
                "volumetric",
                "worley"
            ],
            "usePreview": 0,
            "username": "jcyuan",
            "viewed": 99
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = vec3(texelFetch(iChannel0, ivec2(fragCoord), 0));\n    col *= smoothstep(.0, .2, uv.y);\n    fragColor = vec4(col, 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.141592653589793\n#define sat(v) clamp(v, 0., 1.)\n\n// 0 - 1\n#define GLOBAL_PROB .22\n// 0 - x\n#define GLOBAL_DENSITY .1\n// 0 - 1\n#define GLOBAL_ANVIL_AMOUNT .0\n\n// -----------------------------------------\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1. / float(0xffffffffU))\n\nfloat hash13(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq *= UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn -1. + 2. * (vec3(q) * UIF);\n}\n\nfloat worleyNoise(in vec3 p, in float f, in bool t)\n{\n    vec3 id = floor(p);\n    vec3 fr = fract(p);\n    \n    float dist = 10000.;\n    for(float x = -1.; x <= 1.; x++)\n    {\n        for(float y = -1.; y <= 1.; y++)\n        {\n            for(float z = -1.; z <= 1.; z++)\n            {\n                vec3 c = vec3(x, y, z);\n                vec3 r = id + c;\n                r = t ? hash33(mod(r, f)) : hash33(r);\n                r = (r * .4 + .3) + c;\n                vec3 sd = fr - r;\n                dist = min(dist, dot(sd, sd));\n            }\n        }\n    }\n    \n    return 1.0 - dist;\n}\n\nfloat worleys(in vec3 p, in float freq, in bool repeat)\n{\n    return max(0., dot(\n        vec3(\n            worleyNoise(p * freq, freq, repeat),\n            worleyNoise(p * freq * 2., freq * 2., repeat),\n            worleyNoise(p * freq * 4., freq * 4., repeat)\n        ),\n        vec3(.625, .25, .125)\n    ) * 1.1 - .1);\n}\n\n/*\nfloat perlinNoise(in vec3 p, in float freq)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\t\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\n    return mix( mix( mix( dot( hash33(mod(i + vec3(0.0,0.0,0.0), freq)) * 2. - 1., f - vec3(0.0,0.0,0.0) ), \n                          dot( hash33(mod(i + vec3(1.0,0.0,0.0), freq)) * 2. - 1., f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash33(mod(i + vec3(0.0,1.0,0.0), freq)) * 2. - 1., f - vec3(0.0,1.0,0.0) ), \n                          dot( hash33(mod(i + vec3(1.0,1.0,0.0), freq)) * 2. - 1., f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash33(mod(i + vec3(0.0,0.0,1.0), freq)) * 2. - 1., f - vec3(0.0,0.0,1.0) ), \n                          dot( hash33(mod(i + vec3(1.0,0.0,1.0), freq)) * 2. - 1., f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash33(mod(i + vec3(0.0,1.0,1.0), freq)) * 2. - 1., f - vec3(0.0,1.0,1.0) ), \n                          dot( hash33(mod(i + vec3(1.0,1.0,1.0), freq)) * 2. - 1., f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n*/\n\nfloat perlinNoise(in vec3 x, in float freq)\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    \n    f = f * f * (3. - 2. * f);\n\t\n    return mix(mix(mix(hash13(mod(i + vec3(0, 0, 0), freq)),  \n                       hash13(mod(i + vec3(1, 0, 0), freq)), f.x),\n                   mix(hash13(mod(i + vec3(0, 1, 0), freq)),  \n                       hash13(mod(i + vec3(1, 1, 0), freq)), f.x), f.y),\n               mix(mix(hash13(mod(i + vec3(0, 0, 1), freq)),  \n                       hash13(mod(i + vec3(1, 0, 1), freq)), f.x),\n                   mix(hash13(mod(i + vec3(0, 1, 1), freq)),  \n                       hash13(mod(i + vec3(1, 1, 1), freq)), f.x), f.y), f.z);\n}\n\nfloat perlins(in vec3 p, in float freq, in int oct)\n{\n    const float G = exp2(-.85);\n    float amp = 1.;\n    float noise = 0.;\n    for (int i = 0; i < oct; ++i)\n    {\n        noise += amp * perlinNoise(p * freq, freq);\n        freq *= 2.;\n        amp *= G;\n    }\n    return noise;\n}\n\nfloat remap(float x, float a, float b, float c, float d)\n{\n    return (((x - a) / (b - a)) * (d - c)) + c;\n}\n\nvec3 calcShape(in vec4 data, in float h)\n{\n    float prob = max(data.x, sat(GLOBAL_PROB - .5) * data.y * 2.);\n    float height = sat(data.z + .12);\n    \n    float sbottom = sat(remap(h, .0, .07, .0, 1.));\n    float stop = sat(remap(h, height * 0.2, height, 1., .1));\n    float shape = sbottom * stop;\n    shape = pow(shape, sat(remap(h, .65, .95, 1., (1. - GLOBAL_ANVIL_AMOUNT * GLOBAL_PROB))));\n\n    float dbottom = h * sat(remap(h, .0, .15, .0, 1.));\n    float dtop = sat(remap(h, .9, 1., 1., .2));\n    float density = GLOBAL_DENSITY * dbottom * dtop * data.w * 2.;\n    density = density\n               * mix(1., sat(remap(pow(h, .5), .4, .95, 1., .2)), GLOBAL_ANVIL_AMOUNT)\n               * sat(remap(h, .9, 1., 1., 0.));\n    \n    return vec3(prob, shape, density);\n}\n\nstruct Ray {\n    vec3 orig;\n    vec3 dir;\n};\n\n// with sphere, or maybe other shapes\nfloat intersects(Ray ray, float r)\n{\n \tfloat b = 2. * dot(ray.orig, ray.dir);\n    float c = dot(ray.orig, ray.orig) - r * r;\n    float d = sqrt(b * b - 4. * c);\n    return (-b + d) * .5;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame > 0)\n    {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n    else\n    {\n        vec2 uv = fragCoord / iResolution.xy;\n        vec3 p = vec3(uv, .5);\n\n        float w1 = worleys(p, 4., true);\n        float w2 = worleys(p, 8., true);\n        float w3 = worleys(p, 16., true);\n        float pf = abs((perlins(vec3(uv, .2), 4., 15) * .5) * 2. - 1.); // billowy\n        float w0 = remap(pf, 0., 1., w1, 1.);\n        \n        w1 = dot(vec3(w1, w2, w3), vec3(.625, .25, .125)) - 1.;\n\n        fragColor = vec4(w0, w1, 0, 0);\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame > 0)\n    {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n    else\n    {\n        vec2 uv = fragCoord / iResolution.xy;\n        \n        vec4 col = texture(iChannel1, uv);\n        float r = sat(pow(1. - col.g + col.b, 1.));\n        float g = perlins(vec3(uv, .4), 4., 7) * 2. - 1.;\n        // g = sat(1. - pow(g * 2., 1000.));\n        const float b = 1.;\n        const float a = .5;\n\n        fragColor = vec4(r, g, b, a);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define D_STEPS 40\n\n#define MOVE_DIR vec3(-.4, .1, 1.)\n#define MOVE_SPEED 700.\n\n#define RANGE_R 6371000.\n#define RANGE_T 10000.\n#define RANGE_B 2100.\n#define RNG(l) (l - RANGE_R - RANGE_B) / (RANGE_T - RANGE_B)\n\n#define SUN_COLOR vec3(1.2, 1., .6)\n#define AMBIENT_TOP vec3(0.5, 0.8, 1.2)\n#define AMBIENT_BOTTOM vec3(0.15, 0.45, 1.1)\n\n// random pos on unit sphere\nconst vec3 ConeSamplingKernel[6u] = vec3[] \n(\n\tvec3( .38051305,  .92453449, -.02111345),\n\tvec3(-.50625799, -.03590792, -.86163418),\n\tvec3(-.32509218, -.94557439,  .01428793),\n\tvec3( .09026238, -.27376545,  .95755165),\n\tvec3( .28128598,  .42443639, -.86065785),\n\tvec3(-.16852403,  .14748697,  .97460106)\n);\n\nfloat cloudShape(in vec4 data, in vec3 p, in float h, in bool detail)\n{\n    vec4 noise = textureLod(iChannel0, (p.xz - (MOVE_DIR.xz * iTime * MOVE_SPEED)) * (1. / RANGE_R) * 200., 0.);\n    vec3 c = calcShape(data, h);  // prob, shape, density\n\n    float prob = 1. - GLOBAL_PROB * c.x;\n    float shape = remap(noise.r, noise.g, 1., 0., 1.) * c.y;\n    float covered = sat(remap(shape, prob, 1., 0., 1.));\n    \n    if (detail && covered > 0. && covered < .3)\n    {\n        p -= MOVE_DIR * 3. * iTime * MOVE_SPEED;\n        float d = dot(vec3(worleys(p, .0018, false),\n                   worleys(p, .0036, false),\n                   worleys(p, .0072, false)),\n                   vec3(.625, .25, .125));\n        float m = .35 * exp(-GLOBAL_PROB * .75) * mix(d, 1. - d, sat(h * 5.));\n        \n        return sat(remap(covered, m, 1., 0., 1.)) * c.z;\n    }\n    \n    return covered * c.z;\n}\n\nfloat henyeyGreenstein(float sunDot, float g)\n{\n\tfloat g2 = g * g;\n\treturn (.25 / PI) * ((1. - g2) / pow(1. + g2 - 2. * g * sunDot, 1.5));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 data = texelFetch(iChannel3, ivec2(fragCoord), 0);\n    vec2 mouse = (2. * iMouse.xy - iResolution.xy) / iResolution.y;\n    \n    vec3 eye = vec3(0);\n    vec3 target = vec3(0, .3, -1);\n    const vec3 UP = vec3(0, 1, 0);\n    vec3 lookDir = normalize(target - eye);\n    vec3 r = normalize(cross(lookDir, UP));\n    vec3 t = cross(r, lookDir);\n    vec2 camUv = ((2. * fragCoord - iResolution.xy) / iResolution.y) * (75. / 360.) * PI;\n    vec3 dir = normalize(mat3(r, t, -lookDir) * vec3(camUv, -2.));\n    \n    Ray ray = Ray(eye, dir);\n    \n    Ray sun = Ray(vec3(-.2, .3, .6), vec3(0.));\n    sun.dir = normalize(vec3(sun.orig.xz, -1.));\n\n    ray.orig.y = RANGE_R;\n    float rs = intersects(ray, RANGE_R + RANGE_B);\n    float re = intersects(ray, RANGE_R + RANGE_T);\n    float st = (re - rs) / float(D_STEPS);\n    float jitter = st * texelFetch(iChannel2, (ivec2(fragCoord) + iFrame * ivec2(113, 127)) & 1023, 0).r;\n    float curDist = rs + jitter;\n    \n    float VdotL = max(0., dot(ray.dir, sun.dir));\n    float hgPhase = mix(henyeyGreenstein(VdotL, .4), henyeyGreenstein(VdotL, -.1), .5);\n    \n    const vec3 skyColor = vec3(.4);  // todo: atmosphere scattering\n    \n    float sunHeight = smoothstep(.01, .1, sun.orig.z + .025);\n    \n    hgPhase = max(hgPhase, 1.6 * henyeyGreenstein(sqrt(VdotL),\n\t\t\t\t\t\t\tsat(.8 - sunHeight)));\n                            \n    hgPhase = mix(pow(VdotL, .25), hgPhase, sunHeight);\n    \n    float sunScatterHeight = smoothstep(.15, .4, sun.orig.z);\n    \n    vec4 scatter = vec4(vec3(0.), 1.);  // in\n    for (int i = 0; i < D_STEPS; i++)\n    {\n        vec3 p = ray.orig + ray.dir * curDist;\n        float hr = RNG(length(p));\n        float density = cloudShape(data, p, hr, true);\n        if (density > 0.)\n        {\n            const float lst = 11.;\n            vec3 sDir = sun.dir * lst;\n            vec3 sDist = sDir * .5;  // todo: twist this\n            float coneR = length(sDir);\n            float density2 = 0.;\n            for(int j = 0; j < 6; j++)\n            {\n                vec3 cp = p + sDist + float(j) * coneR * ConeSamplingKernel[j];\n                if (hr > .99 || density2 > .99) break;\n                density2 += cloudShape(data, cp, hr, false) * lst;\n                sDist += sDir;\n            }\n            float precipitation = mix(3.6,\n\t\t\t\t1.8, sunScatterHeight);\n                \n            float shadow = 32. * exp(-density2 * precipitation) * (1. - exp(-density2 * 2.));\n            \n            // integrate along the current step segment: https://www.shadertoy.com/view/XlBSRz\n            \n            vec3 ambient = mix(AMBIENT_BOTTOM, AMBIENT_TOP, \n                                  \thr);\n\t\t\t\t\t\n                    // cloud illumination\n                    vec3 lum = (ambient * sat(pow(sun.orig.z + .04, 1.4))\n\t\t\t\t\t\t+ skyColor * .125 + (sunHeight * skyColor + vec3(.0075, .015, .03))\n\t\t\t\t\t\t* SUN_COLOR * hgPhase\n\t\t\t\t\t\t* shadow) * density;\n\n\n            /*\n            vec3 lum = (\n                mix(AMBIENT_BOTTOM, AMBIENT_TOP, hr)\n                + (skyColor + vec3(.0075, .015, .03)) * SUN_COLOR * hgPhase * shadow\n            ) * density;*/\n            \n            float transmittance = exp(-density * st);\n            vec3 integrate = (lum - lum * transmittance) * (1. / density);\n            \n            scatter.rgb += scatter.a * integrate;\n            scatter.a *= transmittance;\n        }\n        \n        if (scatter.a < .01)\n            break;\n            \n        curDist += st;\n    }\n    \n    float hzMix = 1. - exp(-smoothstep(.08, 0., ray.dir.y) * 2.);\n    scatter = mix(scatter, vec4(0.), hzMix);\n    \n    fragColor = scatter;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const ivec2 offsets[8u] = ivec2[]\n(\n    ivec2(-1, -1), ivec2(-1, 1),\n\tivec2(1, -1), ivec2(1, 1),\n\tivec2(1, 0), ivec2(0, -1),\n\tivec2(0, 1), ivec2(-1, 0)\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 currentBuffer = textureLod(iChannel0, uv, 0.);\n    vec4 historyBuffer = textureLod(iChannel1, uv, 0.);\n\n    vec4 colorAvg = currentBuffer;\n    vec4 colorVar = currentBuffer * currentBuffer;\n    \n    // Marco Salvi's Implementation (by Chris Wyman)\n    for(int i = 0; i < 8; i++)\n    {\n        vec4 neighborTexel = texelFetch(iChannel0, ivec2(fragCoord.xy) + offsets[i], 0);\n        colorAvg += neighborTexel;\n        colorVar += neighborTexel * neighborTexel;\n    }\n    colorAvg /= 9.;\n    colorVar /= 9.;\n    \n    float gColorBoxSigma = .75;\n\tvec4 sigma = sqrt(max(vec4(0.), colorVar - colorAvg * colorAvg));\n\tvec4 colorMin = colorAvg - gColorBoxSigma * sigma;\n\tvec4 colorMax = colorAvg + gColorBoxSigma * sigma;\n    \n    historyBuffer = clamp(historyBuffer, colorMin, colorMax);\n\n\tfragColor = mix(currentBuffer, historyBuffer, .95);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}