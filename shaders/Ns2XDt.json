{
    "Shader": {
        "info": {
            "date": "1621313416",
            "description": "Zavie's smallpt Port but with Improvements. Original: https://www.shadertoy.com/view/4sfGDB",
            "flags": 32,
            "hasliked": 0,
            "id": "Ns2XDt",
            "likes": 10,
            "name": "glsl smallpt++",
            "published": 3,
            "tags": [
                "pathtrace",
                "pathtracing",
                "pathtracer",
                "rt",
                "pt",
                "progressive",
                "smallpt",
                "pathtraced"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 578
        },
        "renderpass": [
            {
                "code": "// ####### glsl smallpt++ #######\n// Forked from \"GLSL smallpt\" Made by Zavie:\n// https://www.shadertoy.com/view/4sfGDB\n\n// Fork made by Zi7ar21\n// Fork Made on May 17th, 2021\n// Fork Last Updated: May 17th, 2021 at 19:50 Mountain Standard Time\n\n// If you found this anywhere except Shadertoy, the original (and possibly updated) fork can be found at:\n// https://www.shadertoy.com/view/Ns2XDt\n\n/*\n\nNotable Changes:\n- Progressive Rendering\nSamples now accumulate over time, giving a converged render. Also, bugged samples\n(e.g. NaN's, Infinities, and Negatives) are discared and do not contribute to the final image.\n\n- Replace Trash RNG with PCG Random\nPCG Random (https://www.pcg-random.org/) is a family of Random Number Generators,\nmade to perform better than other Random Number Generators in various ways.\n\n- Refactoring (Work in Progress)\nThe original shader is kinda messy, so it has been refactored to be more clear\n\n*/\n\n// Image Preview\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get the Final Image\n    vec3 color = texel0.rgb;\n\n    // HDR Tonemapping\n    color = clamp(pow(color/(color+1.0), vec3(1.0/gamma)), 0.0, 1.0);\n\n    // Output the Image Preview\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ##### smallpt #####\n// Original Shader: https://www.shadertoy.com/view/4sfGDB\n\n/*\n\nThis shader is an attempt at porting smallpt to GLSL.\n\nSee what it's all about here:\nhttp://www.kevinbeason.com/smallpt/\n\nThe code is based in particular on the slides by David Cline.\n\nSome differences:\n\n- For optimization purposes, the code considers there is\n  only one light source (see the commented loop)\n- Russian roulette and tent filter are not implemented\n\nI spent quite some time pulling my hair over inconsistent\nbehavior between Chrome and Firefox, Angle and native. I\nexpect many GLSL related bugs to be lurking, on top of\nimplementation errors. Please Let me know if you find any.\n\n--\nZavie\n\n*/\n\n// Ray Datatype\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\n\n// Sphere Datatype\nstruct sphere {\n\tfloat radius;\n\tvec3 pos, emission, col;\n\tint refl;\n};\n\n#define NUM_SPHERES 9\n\nsphere lightSourceVolume = sphere(20.0, vec3(50.0, 81.6, 81.6), vec3(12.0), vec3(0.0), DIFF);\nsphere spheres[NUM_SPHERES];\nvoid initSpheres() {\n    spheres[0] = sphere(1.0e5, vec3(-1e5+1.0, 40.8    , 81.6     ), vec3(0.0 ), vec3(0.75, 0.25, 0.25), DIFF);\n    spheres[1] = sphere(1.0e5, vec3(1e5+99.0, 40.8    , 81.6     ), vec3(0.0 ), vec3(0.25, 0.25, 0.75), DIFF);\n    spheres[2] = sphere(1.0e5, vec3(50.0    , 40.8    ,-1e5      ), vec3(0.0 ), vec3(0.75            ), DIFF);\n    spheres[3] = sphere(1.0e5, vec3(50.0    , 40.8    , 1e5+170.0), vec3(0.0 ), vec3(0.00            ), DIFF);\n    spheres[4] = sphere(1.0e5, vec3(50.0    ,-1.0e5   , 81.6     ), vec3(0.0 ), vec3(0.75            ), DIFF);\n    spheres[5] = sphere(1.0e5, vec3(50.0    , 1e5+81.6, 81.6     ), vec3(0.0 ), vec3(0.75            ), DIFF);\n    spheres[6] = sphere(16.50, vec3(27.0    , 16.5    , 47.0     ), vec3(0.0 ), vec3(1.00            ), SPEC);\n    spheres[7] = sphere(16.50, vec3(73.0    , 16.5    , 78.0     ), vec3(0.0 ), vec3(0.70, 1.00, 0.90), REFR);\n    spheres[8] = sphere(600.0, vec3(50.0    , 681.33  , 81.6     ), vec3(12.0), vec3(0.00            ), DIFF);\n}\n\n//\nfloat intersect(sphere s, ray r)\n{\n    vec3 op = s.pos-r.o;\n    float t;\n    float epsilon = 1e-3;\n    float b = dot(op, r.d);\n    float det = b*b-dot(op, op)+s.radius*s.radius;\n    if(det < 0.0){return 0.0;}\n    else{det = sqrt(det);}\n    return (t = b-det) > epsilon ? t : ((t = b+det) > epsilon ? t : 0.0);\n}\n\n//\nint intersect(ray r, out float t, out sphere s, int avoid)\n{\n    int id = -1;\n    t = 1e5;\n    s = spheres[0];\n    for(int i = 0; i < NUM_SPHERES; i++)\n    {\n        sphere S = spheres[i];\n        float d = intersect(S, r);\n        if(i != avoid && d != 0.0 && d < t)\n        {\n            t = d;\n            id = i;\n            s = S;}\n    }\n\n    return id;\n}\n\n//\nvec3 jitter(vec3 d, float phi, float sina, float cosa)\n{\n    vec3 w = normalize(d);\n    vec3 u = normalize(cross(w.yzx, w));\n    vec3 v = cross(w, u);\n    return (u*cos(phi)+v*sin(phi))*sina+w*cosa;\n}\n\n//\nvec3 radiance(ray r)\n{\n    vec3 acc = vec3(0.0);\n    vec3 mask = vec3(1.0);\n    int id = -1;\n    for(uint depth = 0U; depth < MAXDEPTH; depth++)\n    {\n        float t;\n        sphere obj;\n        if((id = intersect(r, t, obj, id)) < 0){break;}\n        vec3 x = t*r.d+r.o;\n        vec3 n = normalize(x-obj.pos);\n        vec3 nl = n*sign(-dot(n, r.d));\n\n        //vec3 f = obj.c;\n        //float p = dot(f, vec3(1.2126, 0.7152, 0.0722));\n        //if(depth > DEPTH_RUSSIAN || p == 0.0) if(rand() < p) f /= p; else{acc += mask*obj.e*E; break;}\n\n        if(obj.refl == DIFF)\n        {\n            float r2 = rand();\n            vec3 d = jitter(nl, twopi*rand(), sqrt(r2), sqrt(1.0-r2));\n            vec3 e = vec3(0.0);\n            #ifdef ENABLE_NEXT_EVENT_PREDICTION\n            //for(int i = 0; i < NUM_SPHERES; i++)\n            {\n                // Sphere s = sphere(i);\n                // if (dot(s.e, vec3(1.0)) == 0.0) continue;\n\n                // Normally we would loop over the light sources and\n                // cast rays toward them, but since there is only one\n                // light source, that is mostly occluded, here goes\n                // the ad hoc optimization:\n                sphere s = lightSourceVolume;\n                int i = 8;\n\n                vec3 l0 = s.pos-x;\n                float cos_a_max = sqrt(1.0-clamp(s.radius*s.radius/dot(l0, l0), 0.0, 1.0));\n                float cosa = mix(cos_a_max, 1.0, rand());\n                vec3 l = jitter(l0, twopi*rand(), sqrt(1.0-cosa*cosa), cosa);\n\n                if(intersect(ray(x, l), t, s, id) == i)\n                {\n                    float omega = twopi*(1.0-cos_a_max);\n                    e += (s.emission*clamp(dot(l, n), 0.0, 1.0)*omega)/pi;\n                }\n            }\n            #endif\n\t\t\tfloat E = 1.0;//float(depth==0);\n\t\t\tacc += mask*obj.emission*E+mask*obj.col*e;\n\t\t\tmask *= obj.col;\n\t\t\tr = ray(x, d);\n\t\t}\n\n        else if(obj.refl == SPEC)\n        {\n\t\t\tacc += mask*obj.emission;\n\t\t\tmask *= obj.col;\n\t\t\tr = ray(x, reflect(r.d, n));\n\t\t}\n\n        else\n        {\n            float a = dot(n, r.d);\n            float ddn = abs(a);\n            float nc = 1.0;\n            float nt = 1.5;\n            float nnt = mix(nc/nt, nt/nc, float(a > 0.0));\n            float cos2t = 1.0-nnt*nnt*(1.0-ddn*ddn);\n            r = ray(x, reflect(r.d, n));\n\n            if(cos2t > 0.0)\n            {\n                vec3 tdir = normalize(r.d*nnt+sign(a)*n*(ddn*nnt+sqrt(cos2t)));\n                float R0 = (nt-nc)*(nt-nc)/((nt+nc)*(nt+nc));\n                float c = 1.0-mix(ddn, dot(tdir, n), float(a > 0.0));\n                float Re = R0+(1.0-R0)*c*c*c*c*c;\n                float P = 0.25+0.5*Re;\n                float RP = Re/P;\n                float TP = (1.0-Re)/(1.0-P);\n                if(rand() < P){mask *= RP;}\n                else\n                {\n                    mask *= obj.col*TP;\n                    r = ray(x, tdir);\n                }\n            }\n        }\n    }\n\n    return acc;\n}\n\n// Render and Output the Frame\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Initialize Random Number Generator\n    INIT_RNG;\n\n    // Screen UV Coordinates\n\tvec2 uv = 4.0*(nrand2(0.5, gl_FragCoord.xy)-(0.5*resolution.xy))/max(resolution.x, resolution.y);\n\n    // Set-Up Variables\n\tinitSpheres();\n\n\t//vec3 camPos = vec3((2.0*(iMouse.xy==vec2(0.0) ? 0.5*iResolution.xy : iMouse.xy)/iResolution.xy-1.0)*vec2(48.0, 40.0)+vec2(50.0, 40.8), 169.0);\n    //const vec3 camPos = vec3(20.0, 40.0, 169.0);\n    const vec3 camPos = vec3(50.0, 35.0, 169.0);\n\n\t//vec3 cz = normalize(vec3(50.0, 40.0, 81.60)-camPos);\n    vec3 cz = normalize(vec3(50.0, 35.0, 0.0)-camPos);\n\tvec3 cx = vec3(1.0, 0.0, 0.0);\n\tvec3 cy = normalize(cross(cx, cz)); cx = cross(cz, cy);\n\n\tvec3 color = vec3(0.0);\n\n    // Render the Frame\n\tfor(uint i = 0U; i < NSAMPLES; i++)\n    {\n        #ifdef DEBUG\n        vec3 test = radiance(Ray(camPos, normalize(0.53135*(uv.x*cx+uv.y*cy)+cz)));\n        if(dot(test, test) > 0.0){color += vec3(1.0);}\n        else{color += vec3(0.5, 0.0, 0.1);}\n        #else\n\t\tcolor += radiance(ray(camPos, normalize(0.53135*(uv.x*cx+uv.y*cy)+cz)));\n        #endif\n    }\n\n    // Output the Rendered Frame\n\tfragColor = any(lessThan(color, vec3(0.0))) || any(isinf(color)) || any(isnan(color)) ? vec4(0.0) : vec4(color/float(NSAMPLES), 1.0);\n    //fragColor = any(isinf(color)) || any(isnan(color)) ? vec4(0.0) : vec4(color/float(NSAMPLES), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ##### PROGRESSIVE RENDERING #####\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get the Progressive Rendering Buffer\n    fragColor = frame != 0 ? texel1 : vec4(0.0);\n\n    // Add New Data from the Rendering Buffer\n    fragColor += vec4(texel0.rgb, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ##### IMAGE EXPORT #####\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get the Progressive Rendering Buffer\n    vec4 texel = texel0;\n\n    // Output the Final Image\n    fragColor = vec4(texel.a != 0.0 ? texel.rgb/texel.a : texel.rgb, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ##### PARAMETERS #####\n\n// Too few samples takes longer to converge because of the math done at the start of every frame\n// Too many samples takes longer to converge and may time out because of early-finishing threads\n#define NSAMPLES 4U\n\n// Too few bounces produce a low-quality and unrealistic result\n// Too many bounces adds no visible benifit and slows rendering\n#define MAXDEPTH 8U\n// 32 is the most you would ever want to use\n\n// Increase Convergence\n#define ENABLE_NEXT_EVENT_PREDICTION\n\n// Uncomment to see how many Samples never reach a Light Source\n//#define DEBUG\n\n// Russian Roulette Sampling (unused for now)\n//#define DEPTH_RUSSIAN 2\n\n// Image Gamma (Preview Only, does not effect Exported Image)\n#define gamma 2.2\n\n// Material ID's\n#define DIFF 0\n#define SPEC 1\n#define REFR 2\n\n// Traditional Input Names\n#define resolution iResolution\n#define frame iFrame\n\n// Sample Buffer\n#define texel0 texelFetch(iChannel0, ivec2(gl_FragCoord.xy), 0)\n#define texel1 texelFetch(iChannel1, ivec2(gl_FragCoord.xy), 0)\n#define texel2 texelFetch(iChannel2, ivec2(gl_FragCoord.xy), 0)\n#define texel3 texelFetch(iChannel3, ivec2(gl_FragCoord.xy), 0)\n\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\n#define pi 3.1415926535897932384626433832795028841971693993751058209749445923078164\n#define twopi pi*2.0\n\n// ##### RNG #####\n// Taken from michael0884's Usage of PCG Random\n// (He has since improved these, I like the old ones though... yeet!)\n// https://www.shadertoy.com/view/wltcRS\n// https://www.shadertoy.com/view/WttyWX\n// https://www.pcg-random.org/\n\nuint ns;\n#define INIT_RNG ns = uint(frame)*uint(resolution.x*resolution.y)+uint(gl_FragCoord.x+gl_FragCoord.y*resolution.x)\n\n// PCG Random Number Generator\nvoid pcg()\n{\n    uint state = ns*747796405U+2891336453U;\n    uint word  = ((state >> ((state >> 28U) + 4U)) ^ state)*277803737U;\n    ns = (word >> 22U) ^ word;\n}\n\n// Random Floating-Point Scalars/Vectors\nfloat rand(){pcg(); return float(ns)/float(0xffffffffU);}\nvec2 rand2(){return vec2(rand(), rand());}\nvec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Normalized Random Vectors\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x   ))*vec2(cos(twopi*Z.y), sin(twopi*Z.y));}\nvec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy ))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}\nvec4 nrand4(float sigma, vec4 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxyy))*vec4(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w), sin(twopi*Z.w));}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}