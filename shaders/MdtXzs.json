{
    "Shader": {
        "info": {
            "date": "1461037676",
            "description": "Just a reference for anyone that wants it.\nCommented and labelled.",
            "flags": 0,
            "hasliked": 0,
            "id": "MdtXzs",
            "likes": 8,
            "name": "Simple Sphere help",
            "published": 3,
            "tags": [
                "reflection",
                "simple",
                "tutorial",
                "lighting",
                "sphere"
            ],
            "usePreview": 0,
            "username": "ddddddddd",
            "viewed": 1562
        },
        "renderpass": [
            {
                "code": "/*\n\n\"Simple Sphere\"\nby Dean Alex 2016, dean[at]neuroid co uk\n\nA ball with a reflection and some lighting.\nNot supposed to be anything fancy. Just a starting point for people to use to make other things.\n\n\nTo anyone who hates math, the only formulas needed are both from highschool -\n\n- Pythagorus... a2 + b2 = c2 ...applied in three dimensions to define the surface of a sphere.\n- Trigonometry... tan( theta ) = opposite / adjacent ...used to unwrap the angle into a uv.\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    // shape and size of sphere,  this could be in a seperate function with position and radius as inputs, if you wanted multiple spheres\n    float radius = 0.75;\n    vec2 R = iResolution.xy;\n    vec2 uv = (2. * fragCoord.xy -R ) / R.y / radius;\n    \n\t\n    // discard fragments outside the radius\n    float mag = dot(uv,uv);\n    if( mag > 1.0 ){ // 'discard' might go here in a normal fragment shader\n    \tfragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n        return;\n    }\n    \n    \n    // surface normal,   x2+y2+z2 = 1 ... therefore easy to get z\n    vec3 norm = vec3( uv, sqrt( 1.0 - mag ));\n    \n    \n    // uv texture of sphere,   tan(theta) = o/a ... basic trig to calculate the angle then wrap it to range 0-1)\n    float s = atan( norm.z, norm.x ) / 6.283185307179586;\n    float t = asin( norm.y ) / 3.14159265358979;\n    fragColor = texture( iChannel0, vec2( s + iTime * 0.4, t + iTime * 0.03 ));\n    \n    \n    \n    // directional light\n    vec3 lightDir = normalize( vec3( -1.6, -0.3, 1.0 )); // direction vector\n    float mflight = max(dot( norm, lightDir), 0.0);\n    fragColor.rgb *= mflight;\n    \n\n    // point light\n    vec3 light1pos = vec3( 0.6, 0.5, 0.6 ); // position\n    vec3 light1col = vec3( 1.0, 2.0, 3.0 ); // color. over blown\n\n    float dis = 1.0 - length( norm - light1pos ) / 2.0;\n    fragColor.rgb += light1col * pow( dis, 8.0); // specularity is given by index in power function - change this function to whetever you like. million ways of doing lighting.\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}