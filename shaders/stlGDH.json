{
    "Shader": {
        "info": {
            "date": "1622041582",
            "description": "Just experimenting, check out https://www.shadertoy.com/view/fll3D8",
            "flags": 0,
            "hasliked": 0,
            "id": "stlGDH",
            "likes": 6,
            "name": "Colorful Mandelbulb",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "ray",
                "raymarch",
                "raymarched",
                "mandelbulb",
                "colorful",
                "color",
                "shadows",
                "raymarcher",
                "softshadows",
                "soft"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 329
        },
        "renderpass": [
            {
                "code": "// ####### Colorful Mandelbulb #######\n// Made by Zi7ar21 on May 26th, 2021\n// Last Updated: May 26th, 2021 at 11:35 Mountain Standard Time\n\n// If you found this anywhere except Shadertoy, the original and possibly updated version can be found at:\n// https://www.shadertoy.com/view/stlGDH\n\n// Check out my friends!\n// michael0884\n// https://www.shadertoy.com/user/michael0884\n// loicvdb\n// https://www.shadertoy.com/user/loicvdb\n// Dumb Psycho\n// https://www.shadertoy.com/user/Dumb_Psycho\n\n// Inspired by \"Raymarched Mandelbulb\" by Dumb Psycho:\n// https://www.shadertoy.com/view/fll3D8\n\n// ##### PARAMETERS #####\n\n#define gamma   2.2\n#define camfov  1.0\n#define hitDist 1E-3\n#define maxDist 8.00\n#define maxStep 128\n\n#define iterations 6\n\n// ##### CONSTANTS #####\n\n// Traditional Input Names\n#define resolution iResolution\n#define time iTime\n\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\n#define pi 3.1415926535897932384626433832795028841971693993751058209749445923078164\n\n// ##### RENDERING #####\n\n// Material Datatype\nstruct material {\n    vec3 albedo;\n    vec3 normal;\n};\n\n// Rotate a 3-Component Vector\nvec3 rotate(vec3 vec, vec3 rot)\n{\n    vec3 s = sin(rot), c = cos(rot);\n\n    mat3 rotx = mat3(\n    1.0, 0.0, 0.0,\n    0.0, c.x,-s.x,\n    0.0, s.x, c.x);\n    mat3 roty = mat3(\n    c.y, 0.0,-s.y,\n    0.0, 1.0, 0.0,\n    s.y, 0.0, c.y);\n    mat3 rotz = mat3(\n    c.z,-s.z, 0.0,\n    s.z, c.z, 0.0,\n    0.0, 0.0, 1.0);\n\n    mat3 rotmat = rotx*roty*rotz;\n\n    /*\n    rotmat[0] = normalize(rotmat[0]);\n    rotmat[1] = normalize(rotmat[1]);\n    rotmat[2] = normalize(rotmat[2]);\n    */\n\n    return (vec.x*rotmat[0])+(vec.y*rotmat[1])+(vec.z*rotmat[2]);\n}\n\n// Scene Distance Estimator\nfloat DE(in vec3 pos, out vec3 orbitTrap)\n{\n    // Performance Increase\n    if(dot(pos, pos) > 8.0)\n    {\n        return length(pos)-1.3;\n    }\n\n    pos = rotate(pos, pi*vec3(time*0.125*0.125, time*0.125, 0.0));\n\n    //const float power = 8.0;\n    float power = (sin(0.125*0.5*pi*time)*2.0)+8.0;\n\n    vec3 z = pos;\n    float dr = 1.0;\n    float r = 0.0;\n\n    orbitTrap = vec3(1.0);\n\n    for(int i = 0; i < iterations; i++)\n    {\n        r = length(z);\n\n        if(r > 4.0)\n        {\n            break;\n        }\n\n        // Convert to Polar Coordinates\n        float theta = acos(z.z/r)*power;\n        float phi = atan(z.y, z.x)*power;\n        dr = pow(r, power-1.0)*power*dr+1.0;\n\n        // Scale and Rotate the Point\n        float zr = pow(r, power);\n\n        // Convert back to Cartesian Coordinates\n        z = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\n        // Compute Orbit Trap Color\n        orbitTrap = min(orbitTrap, abs(z));\n\n        z += pos;\n    }\n\n    // Return the Distance to the Fractal\n    return 0.5*log(r)*r/dr;\n}\n\n// Distance Estimator Tetrahedron Numerical Normals\nvec3 getNormal(vec3 pos)\n{\n    const vec2 k = vec2(-1.0, 1.0);\n\n    vec3 n;\n\n    return normalize(\n    k.xxx*DE(pos+k.xxx*hitDist, n)+\n    k.xyy*DE(pos+k.xyy*hitDist, n)+\n    k.yxy*DE(pos+k.yxy*hitDist, n)+\n    k.yyx*DE(pos+k.yyx*hitDist, n));\n}\n\n// Distance Estimator Ray-Marching\nfloat intersectDE(in vec3 ro, in vec3 rd, out material materialProperties)\n{\n    // Set-Up Variables\n    float t = 0.0;\n\n    for(int i = 0; i < maxStep; i++)\n    {\n        if(t > maxDist)\n        {\n            break;\n        }\n\n        float td = DE(ro+rd*t, materialProperties.albedo);\n\n        if(td < hitDist)\n        {\n            materialProperties.normal = getNormal(ro+rd*t);\n            return t;\n        }\n\n        t += td;\n    }\n\n    // No Intersection\n    return -1.0;\n}\n\n// Intersection Function\nfloat intersect(in vec3 ro, in vec3 rd, out material materialProperties)\n{\n    // Compute the Intersection\n    float t = intersectDE(ro, rd, materialProperties);\n\n    // Return the Intersection\n    return t;\n}\n\n// Distance Estimator Soft Shadows\nfloat softShadow(vec3 ro, vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.0;\n    float ph = 1E4;\n    vec3 n;\n    for(int i = 0; i < maxStep; i++)\n    {\n        float h = DE(ro+rd*t, n);\n        float y = i == 0 ? 0.0 : h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n\n        res = min(res, 10.0*d/max(0.0, t-y));\n\n        t += h;\n\n        if(res < hitDist || t > maxDist){break;}\n    }\n\n    res = clamp(res, 0.0, 1.0);\n\n    return res*res*(3.0-2.0*res);\n}\n\n// Rendering\nvec3 radiance(vec3 ro, vec3 rd)\n{\n    // Set-Up Variables\n    material materialProperties;\n\n    // Compute the Intersection\n    float t = intersect(ro, rd, materialProperties);\n\n    // If there was no Intersection\n    if(t < 0.0)\n    {\n        // Return Background Color\n        return (max(vec3(0.4, 0.8, 1.0)*dot(rd, vec3(0.0, 1.0, 0.0)), 0.0)*0.9)+0.1;\n    }\n\n    //vec3 lightPosition = vec3(sin(pi*time)*2.0, 4.0, (cos(pi*time)*2.0)-4.0);\n    const vec3 lightPosition = vec3(4.0, 4.0, -4.0);\n\n    // Direction of the Light\n    vec3 lightDirection = normalize(lightPosition-(ro+rd*t));\n\n    // Compute Lighting\n    float lighting0 = max(dot(materialProperties.normal, lightDirection), 0.0);\n    float lighting1 = max(dot(materialProperties.normal,-lightDirection), 0.0)*0.1;\n    float lighting = lighting0+lighting1+0.2;\n    lighting = mix(softShadow(ro+(rd*t)+(materialProperties.normal*hitDist), lightDirection)*lighting, lighting, 0.4);\n\n    // Return Final Result\n    return materialProperties.albedo*lighting;\n}\n\n// Render and Output the Frame\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Screen UV Coordinates\n    vec2 uv = 2.0*(gl_FragCoord.xy-0.5*resolution.xy)/max(resolution.x, resolution.y);\n\n    // Set-Up Variables\n    const vec3 ro = vec3(2.0, -1.0, -2.0);\n\n    /*\n    const mat3 rotmat = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    //rotmat[0] = normalize(rotmat[0]);\n    //rotmat[1] = normalize(rotmat[1]);\n    //rotmat[2] = normalize(rotmat[2]);\n    */\n\n    const vec3 camtarget = vec3(0.0);\n\n    // Calculate the Direction of the Ray\n    vec3 targetdir = normalize(camtarget-ro);\n    vec3 left = cross(targetdir, vec3(0.0, 1.0, 0.0));\n    vec3 up = cross(left, targetdir);\n    mat3 rotmat = mat3(left, up, targetdir);\n    vec3 rd = normalize(camfov*(uv.x*rotmat[0]+uv.y*rotmat[1])+rotmat[2]);\n\n    // Render the Frame\n    vec3 color = radiance(ro, rd);\n\n    // HDR Tonemapping\n    color = clamp(pow(color/(color+1.0), vec3(1.0/gamma)), 0.0, 1.0);\n\n    // Output the Rendered Frame\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}