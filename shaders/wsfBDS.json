{
    "Shader": {
        "info": {
            "date": "1590081422",
            "description": "mechanizm",
            "flags": 32,
            "hasliked": 0,
            "id": "wsfBDS",
            "likes": 6,
            "name": "mechanizm_yurka",
            "published": 3,
            "tags": [
                "mechanizm"
            ],
            "usePreview": 0,
            "username": "yurka",
            "viewed": 172
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    \n    InitObjects();\n    CalcForTime(iTime);\n    \n    vec3 col = vec3(0.0, 0.0, 0.0);\n    float distfactor = 10000.0;\n    for (int oi = 0; oi < objects_count; oi++)\n    {\n        float glow = 0.0;\n        if (objects[oi].points_count > 1)\n        {\n            for (int i = 0; i < objects[oi].points_count-1; i++)\n                for (int j = i+1; j < objects[oi].points_count; j++)\n                {\n                    vec2 pp = uv - objects[oi].points[i];\n                    vec2 pv = objects[oi].points[j] - objects[oi].points[i];\n\n                    float scalar = dot(pv, pp);\n                    float l2 = len2(pv);\n                    scalar /= l2;\n                    if (scalar < 0.0) scalar = 0.0;\n                    if (scalar > 1.0) scalar = 1.;\n                    float dst2 = len2(pv*scalar - pp);\n\n                    dst2 *= distfactor;\n                    if (dst2 > 1e-3)\n                        glow += 1.0 / dst2;\n                    else\n                        glow += 1000.0;\n                }\n        }\n        else if (objects[oi].points_count == 1)\n        {\n            float dst2 = len2(uv - objects[oi].points[0]);\n\n            dst2 *= distfactor;\n            if (dst2 > 1e-3)\n                glow += 1.0 / dst2;\n            else\n                glow += 1000.0;\n        }\n\n        col += glow*objects[oi].color;\n    }\n    /*\n    // stats >>\n    vec2 statbegin = vec2(0, -0.3);\n    vec3 statcol = vec3(1.0, 0.0, 0.0);\n    vec2 statvec = vec2(0.0, 0.02);\n    vec2 statend = statbegin + statvec * float(calcs);\n    \n    vec2 pp = uv - statbegin;\n    vec2 pv = statend - statbegin;\n\n    float glow = 0.0;\n    float scalar = dot(pv, pp);\n    float l2 = len2(pv);\n    scalar /= l2;\n    if (scalar < 0.0) scalar = 0.0;\n    if (scalar > 1.0) scalar = 1.;\n    float dst2 = len2(pv*scalar - pp);\n\n    dst2 *= distfactor;\n    if (dst2 > 1e-3)\n        glow += 1.0 / dst2;\n    else\n        glow += 1000.0;\n    glow *= 1.0 - fract(scalar * float(calcs));\n    col += glow*statcol;\n    // <<\n    */\n    //vec3 col = vec3(cos(uv.x*3.14*5.0 + iTime) * sin(uv.y*3.14*5.0 + iTime));\n\n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    fragColor = data + vec4(col, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MAX_OBJ 10\n#define MAX_POINTS 4\n#define EPS 1e-20\n#define MPI 3.14159265359\nstruct obj\n{\n    int Fcnt;\n    int axis;\n    vec2 points[MAX_POINTS];\n    int point_obj[MAX_POINTS];\n    int point_point[MAX_POINTS];\n    bool point_dom[MAX_POINTS];\n    bool point_track[MAX_POINTS];\n    int points_count; \n    vec3 color;\n};\n\nobj objects[MAX_OBJ];\nint objects_count = 0;\nint calcs = 0;\n\nfloat len2(vec2 v)\n{\n    return v.x*v.x + v.y*v.y;\n}\n\nbool intersectlineancircle(float rp2, float a, float b, float c, out vec2 p1, out vec2 p2)\n{\n    float aapbb = a*a+b*b;\n\tfloat x0 = -a*c/aapbb,  y0 = -b*c/aapbb;\n    if (c*c > rp2*aapbb+EPS)\n        return false;\n    else if (abs (c*c - rp2*aapbb) < EPS) {\n        p1.x = x0;\n        p1.y = y0;\n        p2 = p1;\n    }\n    else {\n        float d = rp2 - c*c/aapbb;\n        float mult = sqrt (d / aapbb);\n        float ax,ay,bx,by;\n        ax = x0 + b * mult;\n        bx = x0 - b * mult;\n        ay = y0 - a * mult;\n        by = y0 + a * mult;\n        p1.x = ax;\n        p1.y = ay;\n        p2.x = bx;\n        p2.y = by;\n    }\n    return true;\n}\n\nbool intersect2circles(float r1p2, vec2 c1, float r2p2, vec2 c2, out vec2 p1, out vec2 p2)\n{\n    vec2 sc = c2 - c1;\n    float a = -2.0*sc.x;\n    float b = -2.0*sc.y;\n    float c = sc.x*sc.x + sc.y*sc.y + r1p2 - r2p2;\n    \n    if (intersectlineancircle(r1p2, a, b, c, p1, p2))\n    {\n        p1 += c1;\n        p2 += c1;\n        return true;\n    }\n    else\n        return false;\n}\n\nvec2 GetPerpendicularVector(vec2 Vector)\n{\n    return vec2(-Vector.y, Vector.x);\n}\n\nfloat Determinant2x2(\n                float a, float b,\n                float d, float e\n                )\n{\n    return a * e - b * d;\n}\n\nvec2 GetPosInVectorCoordinates(vec2 vx, vec2 vy, vec2 p)\n{\n    // i*x1 + j*x2 + k*x3 = x\n    // i*y1 + j*y2 + k*y3 = y\n    // i*z1 + j*z2 + k*z3 = z\n    float det = Determinant2x2(vx.x, vy.x, vx.y, vy.y);\n    \n    vec2 res = vec2(\n            \t\tDeterminant2x2(p.x, vy.x, p.y, vy.y) / det,\n    \t\t\t\tDeterminant2x2(vx.x, p.x, vx.y, p.y) / det\n        \t\t\t);\n    return res;\n}\n\nvoid CalculateDependencies()\n{\n    // calculation of dependences >>\n    bool broken = false;\n    int counttofix = 1;\n    while (counttofix > 0 && !broken)\n    {\n        counttofix = 0;\n        for (int oi = 0; oi < objects_count; oi++)\n        {\n            for (int pi = 0; pi < objects[oi].points_count; pi++)\n            {\n                int no;\n                int np;\n                calcs++;\n                if ((no = objects[oi].point_obj[pi]) >= 0 && (np = objects[oi].point_point[pi]) >= 0)\n                {\n                    counttofix++;\n                    if (objects[no].point_point[np] < -1)\n                    {\n                        vec2 shift = objects[no].points[np] - objects[oi].points[pi];\n                        for (int pi2 = 0; pi2 < objects[oi].points_count; pi2++)\n                        {\n                            objects[oi].points[pi2] += shift;\n                        }\n                        objects[oi].point_obj[pi] = -2;\n                        objects[oi].point_point[pi] = -2;\n                        objects[oi].Fcnt++;\n                        objects[oi].axis = pi;\n                        counttofix--;\n                    }\n                    else\n                    {\n                        if (objects[oi].Fcnt == 1 && objects[no].Fcnt == 1)\n                        {\n                            //objects[oi].points[pi] = vec2(0, 0);\n                            vec2 p1, p2;\n                            vec2 c1 = objects[oi].points[objects[oi].axis];\n                            vec2 c2 = objects[no].points[objects[no].axis];\n                            float r1p2 = len2(objects[oi].points[pi] - c1);\n                            float r2p2 = len2(objects[no].points[np] - c2);\n\n                            if (intersect2circles(r1p2, c1, r2p2, c2, p1, p2))\n                            {\n                                vec2 intP = p1;\n                                if (!objects[oi].point_dom[pi])\n                                    intP = p2;\n\n                                vec2 vecf1 = objects[oi].points[pi] - c1;\n                                vec2 vecf1p = GetPerpendicularVector(vecf1);\n                                vec2 vect1 = intP - c1;\n                                vec2 vect1p = GetPerpendicularVector(vect1);                                \n                                \n                                for (int pi2 = 0; pi2 < objects[oi].points_count; pi2++)\n                                    if (objects[oi].point_obj[pi2] >= -1)\n                                    {\n                                        vec2 psf1 = GetPosInVectorCoordinates(vecf1, vecf1p, objects[oi].points[pi2] - c1);\n                                        objects[oi].points[pi2] = psf1.x*vect1 + psf1.y*vect1p + c1;\n                                        objects[oi].point_obj[pi2] = -2;\n                                        objects[oi].point_point[pi2] = -2;\n                                        objects[oi].Fcnt++;\n                                        counttofix--;\n                                    }\n\n                                vec2 vecf2 = objects[no].points[np] - c2;\n                                vec2 vecf2p = GetPerpendicularVector(vecf2);\n                                vec2 vect2 = intP - c2;\n                                vec2 vect2p = GetPerpendicularVector(vect2);                                \n                                \n                                for (int pi2 = 0; pi2 < objects[no].points_count; pi2++)\n                                    if (objects[no].point_obj[pi2] >= -1)\n                                    {\n                                        vec2 psf2 = GetPosInVectorCoordinates(vecf2, vecf2p, objects[no].points[pi2] - c2);\n                                        objects[no].points[pi2] = psf2.x*vect2 + psf2.y*vect2p + c2;\n                                        objects[no].point_obj[pi2] = -2;\n                                        objects[no].point_point[pi2] = -2;\n                                        objects[no].Fcnt++;\n                                        counttofix--;\n                                    }\n                            }\n                            else\n                            {\n                                broken = true;\n                            }\n                        }\n                    }\n                }\n                else\n                    if (no == -1)\n                    \tcounttofix++;\n            }\n        }\n    }\n    // <<\n}\n\nvoid CalcForTime(float aTime)\n{\n    // movement >>\n    vec2 shift = vec2(-0.5, 0.20);\n    float rad1 = 0.085;\n    vec2 cen1 = vec2(0.09, 0.17);\n    objects[0].points[0] = shift + cen1 + vec2(sin(fract(aTime) * MPI * 2.0) * rad1, cos(fract(aTime) * MPI * 2.0) * rad1);\n    objects[1].points[0] = shift;\n    // <<\n    \n    CalculateDependencies();\n}\n\nvoid InitObjects()\n{\n    // initialazing objects >>\n    int oc = objects_count = 0;\n    int pc = 0;\n    \n    // o #0\n    objects[oc].points_count = 0;\n    pc = objects[oc].points_count;\n    objects[oc].points[pc] = vec2(0.2, 0.2);\n    objects[oc].point_obj[pc] = -2;\n    objects[oc].point_point[pc] = -2;\n    objects[oc].point_dom[pc] = false;\n    objects[oc].point_track[pc] = true;\n    pc = ++objects[oc].points_count;\n    objects[oc].color = vec3(0.0, 0.0, 0.3);\n    objects[oc].Fcnt = 1;\n    objects[oc].axis = 0;\n    oc = ++objects_count;\n    \n    // o #1\n    objects[oc].points_count = 0;\n    pc = objects[oc].points_count;\n    objects[oc].points[pc] = vec2(0.0, 0.0);\n    objects[oc].point_obj[pc] = -2;\n    objects[oc].point_point[pc] = -2;\n    objects[oc].point_dom[pc] = false;\n    objects[oc].point_track[pc] = false;\n    pc = ++objects[oc].points_count;\n    objects[oc].color = vec3(1.0, 0.0, 0.0);\n    objects[oc].Fcnt = 1;\n    objects[oc].axis = 0;\n    oc = ++objects_count;\n    \n    // o #2\n    objects[oc].points_count = 0;\n    pc = objects[oc].points_count;\n    objects[oc].points[pc] = vec2(0.0, 0);\n    objects[oc].point_obj[pc] = 6;\n    objects[oc].point_point[pc] = 0;\n    objects[oc].point_dom[pc] = false;\n    objects[oc].point_track[pc] = false;\n    pc = ++objects[oc].points_count;\n    objects[oc].points[pc] = vec2(0.1, 0.1);\n    objects[oc].point_obj[pc] = 1;\n    objects[oc].point_point[pc] = 0;\n    objects[oc].point_dom[pc] = false;\n    objects[oc].point_track[pc] = false;\n    pc = ++objects[oc].points_count;\n    objects[oc].points[pc] = vec2(0, 0.2);\n    objects[oc].point_obj[pc] = 3;\n    objects[oc].point_point[pc] = 1;\n    objects[oc].point_dom[pc] = true;\n    objects[oc].point_track[pc] = false;\n    pc = ++objects[oc].points_count;\n    objects[oc].color = vec3(0.5, 0.2, 1.0);\n    objects[oc].Fcnt = 0;\n    objects[oc].axis = -1;\n    oc = ++objects_count;\n    \n    // o #3\n    objects[oc].points_count = 0;\n    pc = objects[oc].points_count;\n    objects[oc].points[pc] = vec2(0.1, 0.2);\n    objects[oc].point_obj[pc] = 0;\n    objects[oc].point_point[pc] = 0;\n    objects[oc].point_dom[pc] = false;\n    objects[oc].point_track[pc] = false;\n    pc = ++objects[oc].points_count;\n    objects[oc].points[pc] = vec2(0.1, 0.0);\n    objects[oc].point_obj[pc] = 2;\n    objects[oc].point_point[pc] = 2;\n    objects[oc].point_dom[pc] = false;\n    objects[oc].point_track[pc] = false;\n    pc = ++objects[oc].points_count;\n    objects[oc].color = vec3(0.5, 1.0, 0.1);\n    objects[oc].Fcnt = 0;\n    objects[oc].axis = -1;\n    oc = ++objects_count;\n    \n    // o #4\n    objects[oc].points_count = 0;\n    pc = objects[oc].points_count;\n    objects[oc].points[pc] = vec2(0.0, 0.0);\n    objects[oc].point_obj[pc] = 0;\n    objects[oc].point_point[pc] = 0;\n    objects[oc].point_dom[pc] = false;\n    objects[oc].point_track[pc] = false;\n    pc = ++objects[oc].points_count;\n    objects[oc].points[pc] = vec2(0.0, 0.22);\n    objects[oc].point_obj[pc] = 5;\n    objects[oc].point_point[pc] = 1;\n    objects[oc].point_dom[pc] = true;\n    objects[oc].point_track[pc] = false;\n    pc = ++objects[oc].points_count;\n    objects[oc].color = vec3(0.1, 0.1, 1.0);\n    objects[oc].Fcnt = 0;\n    objects[oc].axis = -1;\n    oc = ++objects_count;\n    // <<\n        \n    // o #5\n    objects[oc].points_count = 0;\n    pc = objects[oc].points_count;\n    objects[oc].points[pc] = vec2(0.0, 0.0);\n    objects[oc].point_obj[pc] = 1;\n    objects[oc].point_point[pc] = 0;\n    objects[oc].point_dom[pc] = false;\n    objects[oc].point_track[pc] = false;\n    pc = ++objects[oc].points_count;\n    objects[oc].points[pc] = vec2(0.14, 0.0);\n    objects[oc].point_obj[pc] = 4;\n    objects[oc].point_point[pc] = 1;\n    objects[oc].point_dom[pc] = false;\n    objects[oc].point_track[pc] = false;\n    pc = ++objects[oc].points_count;\n    objects[oc].color = vec3(1.1, 0.1, 0.0);\n    objects[oc].Fcnt = 0;\n    objects[oc].axis = -1;\n    oc = ++objects_count;\n    // <<\n    \n    // o #6\n    objects[oc].points_count = 0;\n    pc = objects[oc].points_count;\n    objects[oc].points[pc] = vec2(0.0, 0.0);\n    objects[oc].point_obj[pc] = 2;\n    objects[oc].point_point[pc] = 0;\n    objects[oc].point_dom[pc] = false;\n    objects[oc].point_track[pc] = false;\n    pc = ++objects[oc].points_count;\n    objects[oc].points[pc] = vec2(0.17, 0.0);\n    objects[oc].point_obj[pc] = 7;\n    objects[oc].point_point[pc] = 1;\n    objects[oc].point_dom[pc] = false;\n    objects[oc].point_track[pc] = true;\n    pc = ++objects[oc].points_count;\n    objects[oc].color = vec3(0.2, 0.2, 0.2);\n    objects[oc].Fcnt = 0;\n    objects[oc].axis = -1;\n    oc = ++objects_count;\n    // <<\n    \n    // o #7\n    objects[oc].points_count = 0;\n    pc = objects[oc].points_count;\n    objects[oc].points[pc] = vec2(0.17, 0.0);\n    objects[oc].point_obj[pc] = 5;\n    objects[oc].point_point[pc] = 1;\n    objects[oc].point_dom[pc] = false;\n    objects[oc].point_track[pc] = false;\n    pc = ++objects[oc].points_count;\n    objects[oc].points[pc] = vec2(0.0, 0.0);\n    objects[oc].point_obj[pc] = 6;\n    objects[oc].point_point[pc] = 1;\n    objects[oc].point_dom[pc] = true;\n    objects[oc].point_track[pc] = false;\n    pc = ++objects[oc].points_count;\n    objects[oc].points[pc] = vec2(-0.2, -0.2);\n    objects[oc].point_obj[pc] = -1;\n    objects[oc].point_point[pc] = -1;\n    objects[oc].point_dom[pc] = true;\n    objects[oc].point_track[pc] = true;\n    pc = ++objects[oc].points_count;\n    objects[oc].color = vec3(0.3, 0.2, 0.0);\n    objects[oc].Fcnt = 0;\n    objects[oc].axis = -1;\n    oc = ++objects_count;\n    // <<\n    \n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    \n    InitObjects();\n    CalcForTime(iTime);\n    \n    vec3 col = vec3(0.0, 0.0, 0.0);\n    float distfactor = 10000.0;\n    // show track >>\n    for (int oi = 0; oi < objects_count; oi++)\n    {\n        float glow = 0.0;\n        for (int pi = 0; pi < objects[oi].points_count; pi++)\n            if (objects[oi].point_track[pi])\n            {\n\n                float dst2 = len2(uv - objects[oi].points[pi]);\n\n                dst2 *= distfactor;\n                if (dst2 > 1e-3)\n                    glow += 1.0 / dst2;\n                else\n                    glow += 1000.0;\n            }\n        col += glow*objects[oi].color;\n    }\n    // <<\n\t\n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    fragColor = 0.95*data + vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}