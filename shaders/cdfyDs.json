{
    "Shader": {
        "info": {
            "date": "1687291248",
            "description": "keys 1 .. 7 toggle stuff.\nonion-skinning it (key 7) doesn't look right, i need to re-do the ray-handling.",
            "flags": 16,
            "hasliked": 0,
            "id": "cdfyDs",
            "likes": 28,
            "name": "glass mug",
            "published": 3,
            "tags": [
                "coffee",
                "refraction",
                "glass",
                "optics"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 400
        },
        "renderpass": [
            {
                "code": "//---------------------------------------------------------------------\n// keyboard stuff\n\nbool        kPipOn      =   false;      // heat map.       1\nbool        kPixelate   =   false;      // chunky pixels.  2\nbool        kShadows    =   true;       // shadows.        3\nbool        kFullRays   =   true;       // quality.        4\nbool        kMtl1       =   false;      // material        5\nbool        kCut        =   false;      // cutting plane   6\nbool        kHollow     =   false;      // hollow geometry 7\n\nvoid readKeyboard() {\n    const int ZRO = 48;\n    kPipOn    =  KEY_TOGGLED(ZRO + 1, iChannel2);\n    kPixelate =  KEY_TOGGLED(ZRO + 2, iChannel2);\n    kShadows  = !KEY_TOGGLED(ZRO + 3, iChannel2);\n    kFullRays = !KEY_TOGGLED(ZRO + 4, iChannel2);\n    kMtl1     =  KEY_TOGGLED(ZRO + 5, iChannel2);\n    kCut      =  KEY_TOGGLED(ZRO + 6, iChannel2);\n    kHollow   =  KEY_TOGGLED(ZRO + 7, iChannel2);\n}\n\n//---------------------------------------------------------------------\n// materials\n\nconst uint mtl_0                 =  0u;\nconst uint mtl_floor             =  1u;\nconst uint mtl_green_glass       =  2u;\nconst uint mtl_other_glass       =  3u;\nconst uint mtl_cup_glass         =  3u;\nconst uint mtl_debug             =  5u;\nconst uint mtl_count             =  6u;\n\nconst mtl_t materials[mtl_count] = mtl_t[](\n    //    ior   trn   alb                  transmissance\n    mtl_t(1.0 , 0.0 , v1                 , v41),                         // sky\n    mtl_t(2.0 , 0.0 , v1                 , v41),                         // floor\n    mtl_t(1.5 , 1.0 , v0                 , vec4(0.1, 0.7, 0.2 ,  1.3)), // glass chartreuse\n    mtl_t(1.8 , 1.0 , v0                 , vec4(0.3, 0.9, 0.4 ,  2.0)),  // other glass\n    mtl_t(1.8 , 1.0 , v0                 , vec4(0.3, 0.9, 0.4 ,  2.0)),  // cup glass\n    mtl_t(2.0 , 0.0 , vec3(0.8, 0.6, 0.6), v41)                          // debug\n);\n\n\n//---------------------------------------------------------------------\n// viewport stuff\n\nconst float cPipScale   =   0.4;        // heatmap size\nconst float cPixelation =   8.0;\n      float gVPZoom     =   0.8;\n      float gVPEps      =   1e9;        // viewport epsilon\n      float gVPLW       =   1e9;        // viewport linewidth\n      float gT          =   0.0;\n      float gFOVFac     =   0.5;        // smaller = zoomier\n      float gCamDist    =  30.0;\n      float gMapCount   =   0.0;\n      vec3  gRGB;\n      \n// raymarch stuff\nconst uint  cMaxMarchSteps = 900u;      // crazy high for internal reflection\nconst uint  cHeatMapSteps  = 150u;      // march steps used in heatmap visualization\nconst float cWSEps         =   0.0001;\nconst float gUnderStepFac  =   0.98;\nconst float cSurfEps       =   cWSEps * 3.0;\nconst float cMinRayAmt     =   0.4 / 256.0;\nconst uint  cMaxRays       = 2010u;\n      uint  gRayCount;\nconst uint  cHeatMapRays   =   20u;\n      uint  gMaxRays       =   cMaxRays; // toggled at runtime\n      uint  gMtl           =   mtl_green_glass;\n      \n//---------------------------------------------------------------------\n// scene stuff\n\nfloat gCutPlaneOffset = 1e8; // set at runtime\n\nvoid configScene() {\n    gCutPlaneOffset = kCut  ? 0.0 : -1e8;\n    gMtl            = kMtl1 ? mtl_debug : mtl_green_glass;\n}\n\n\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\nMST map(in vec3 p) {\n    gMapCount += 1.0;\n\n    MST   ret = MST(1e9, mtl_0);\n    \n    float d = ret.dist;\n    vec3  q;\n    vec4  w;\n    \n    // centimeters\n    const float outRad          = 11.0;\n    const float height          = 18.0;\n    const float mainThickness   =  0.8;\n    const float hover           =  0.001;\n    const float wallThick       =  0.1;\n    const float handleClearance =  2.0;\n    \n    const float handleRad        = 3.3;\n    const float handleHeight     = height / 2.0 + mainThickness - 3.5;\n    const float handleVertOffset = 1.0;\n    const float handleWidth      = 0.8;\n    const float handleDepth      = 5.0;\n    const float handleThickness  = 0.4;\n    \n    const float cylRad = outRad - mainThickness;\n    \n    // bottom is a cylinder\n    q = p;\n    q.y -= mainThickness + wallThick + hover;\n    d = min(d, sdCappedCylinder(q, mainThickness, cylRad));\n    \n    // walls are a space-expanded torus\n    q = p;\n    q.y -= mainThickness + wallThick + height / 2.0 + hover;\n    w = opElongate(q, vec3(0.0, height / 2.0, 0.0));\n    \n    d = min(d, w.w + sdTorus(w.xyz, vec2(cylRad, mainThickness)));\n    \n    d = kHollow ? abs(d) : d;\n    d -=wallThick;\n    \n    // handle\n    q = p;\n    q.y -= mainThickness + wallThick + height / 2.0 + hover + handleVertOffset;\n    q.z -= outRad;\n    w = opElongate(q, vec3(handleWidth, handleHeight - handleRad, handleDepth - handleRad));\n    float hd = w.w + sdTorus(w.yxz, vec2(handleRad, handleThickness));\n    opMinus(hd, p.z - outRad);\n    \n    d = smin(d, hd, 0.3);\n    \n    d = max(d, p.x + gCutPlaneOffset);\n\n    ret.dist = d;\n    ret.mtl = gMtl;\n\n\n    return ret;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 mapNormal(vec3 p){\n    vec3 n = vec3(0.0);\n    for(int i = ZERO; i < 4; i++){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*cWSEps).dist;\n    }\n    return normalize(n);\n}\n\n\nvoid rayVsScene(in ray_t r, inout hit_t h, in uint maxSteps) {\n    // tack on a plane via analytic intersection.\n    rayVsPlane (r, vY, 0.0, mtl_floor, h);\n\n    float t = 0.0;\n    \n    for (uint n = 0u; n < maxSteps && t < 1e3; ++n) {\n        vec3 p = r.ro + r.rd * t;\n        MST ms = map(p);\n        float absDist = abs(ms.dist);\n        if (t < h.t && (absDist < cWSEps)) {\n            h.hit      = true;\n            h.t        = t;\n            h.pnt      = p;\n            h.nrm      = mapNormal(p);\n            h.mtl      = ms.mtl;\n            \n            if (h.mtl == gMtl) {\n                // bumps\n                const float bumpSize = 0.01;\n                h.nrm.y += sin(p.y * 7.12 + sin(p.y * 1.0) * 3.0 ) * (1.0 + 0.7 * sin(p.x * 2.0)) * bumpSize;\n                h.nrm    = normalize(h.nrm);\n            }\n            \n            return;\n        }\n\n\n        t += absDist * gUnderStepFac;\n    }\n}\n\n#define Q_TYPE        ray_t\n#define Q_MAX_ENTRIES 15u\nQ_IMPLEMENTATION\n\nvec3 gSunDir = normalize(vec3(-1.0, 1.0, -1.0));\nvec3 toneSky(in ray_t r) {\n    return v1;\n    return r.rd * 0.5 + 0.5;\n}\n\nvec3 toneFloor(in vec2 p) {\n    if (abs(p.y) < 2.2) {\n        p.x += gT;\n    }\n    p = fract(p * 0.2 - 0.5);\n    float f = length(p * 2.0 - 1.0);\n    return 0.5 + 0.2 * smoothstep(0.9, 0.88, f) * v1;\n}\n\nvec3 tone(in ray_t r, in hit_t h) {\n    switch (h.mtl) {\n        case mtl_0:\n            return toneSky(r);\n        case mtl_floor:\n            return toneFloor(h.pnt.xz);\n        default:\n            return materials[h.mtl].color;\n    }\n}\n\n\nvoid runRays() {\n\n    // accumulates in gRGB.\n    \n    gRayCount = 0u;\n    gMaxRays = kFullRays ? cMaxRays : 8u;\n    \n    while (!QIsEmpty()) {\n        gRayCount += 1u;\n        ray_t r = QDequeue();\n        \n        \n        hit_t h = hit_t(false, 1e9, v0, vX, mtl_0);\n        h.mtl = mtl_0;\n        rayVsScene(r, h, cMaxMarchSteps);\n        \n        if (!h.hit) {\n            // no hit - escapes to the sky\n            gRGB += r.amt * toneSky(r);\n        }\n        else {\n            // a hit!\n            // \"nrm\" here is the hit-facing normal,\n            // while h.nrm is the \"outward\" facing normal.\n            \n            mtl_t m = materials[h.mtl];\n                        \n            vec3  nrm     = h.nrm * r.side;\n            float R0      = schlickR0(m.ior, ior_air);\n            vec3  reflAmt = v1 * schlick  (R0, dot(r.rd, -nrm));            \n            vec3  trnsAmt = m.diffVsTrns * (1.0 - reflAmt);\n            vec3  diffAmt = (1.0 - m.diffVsTrns) * (1.0 - reflAmt);\n\n            if (r.side < 0.0) {\n                // just traveled through media, attenuate !\n                r.amt *= exp(-m.absorption.w * h.t * (1.0 - m.absorption.rgb));\n            }\n\n            reflAmt *= r.amt;\n            trnsAmt *= r.amt;\n            diffAmt *= r.amt;\n            \n            if (gRayCount >= gMaxRays) {\n                continue;\n            }\n            \n            // diffuse\n\n            if (QSpaceLeft() < 1u) {\n                continue;\n            }\n                        \n            if (dot(diffAmt, diffAmt) > cMinRayAmt * cMinRayAmt) {\n                // diffuse lighting at surfaces.\n                \n                float sunDot      = dot(gSunDir, h.nrm);\n                if (sunDot > 0.0) {\n\n                    // cast a diffuse lighting ray.\n                    ray_t dlrRay;\n                    dlrRay.ro         = h.pnt + h.nrm * cSurfEps;\n                    dlrRay.rd         = gSunDir;\n                    dlrRay.amt        = diffAmt * sunDot * tone(r, h);\n                    dlrRay.side       = 1.0;\n                    dlrRay.ior        = 1.0;\n                    dlrRay.DLR        = true;\n                    \n                    if (dot(dlrRay.amt, dlrRay.amt) > cMinRayAmt * cMinRayAmt) {\n                        if (!kShadows) {\n                            // if no shadows, advance the ray to the sky\n                            dlrRay.ro += dlrRay.rd * 1e4;\n                        }\n                        QEnqueue(dlrRay);\n                    }\n                }\n            }\n\n\n            // transmission\n            \n            if (QSpaceLeft() < 1u) {\n                continue;\n            }\n            \n            if (dot(trnsAmt, trnsAmt) > cMinRayAmt * cMinRayAmt) {\n                if (!r.DLR) {\n                    float eta = r.ior / m.ior;\n                    if (r.side < 0.0) {\n                     //   eta = 1.0 / eta;\n                    }\n                    vec3 trnRayDir = refract(r.rd, nrm, eta);\n                    if (dot(trnRayDir, trnRayDir) < 0.001) {\n                        // total internal reflection.\n                        reflAmt += trnsAmt;\n                    }\n                    else {\n                        // the treatment of \"side\" here is not accounting for\n                        // the possibility of both sides being inside.\n                        // but it looks good !\n                        ray_t trnRay;\n                        trnRay.ro   = h.pnt - nrm * cSurfEps;\n                        trnRay.rd   = trnRayDir;\n                        trnRay.side = -r.side;\n                        trnRay.amt  = trnsAmt;\n                        trnRay.DLR  = false;\n                        trnRay.ior  = m.ior;\n\n                        QEnqueue(trnRay);\n                    }\n                }\n                else {\n                    // is DLR ray: diffuse lighting ray not refracted, reflected, etc.\n                    ray_t trnRay;\n                    trnRay.ro   = h.pnt - nrm * cSurfEps;\n                    trnRay.rd   = r.rd;\n                    trnRay.side = -r.side;\n                    trnRay.amt  = trnsAmt;\n                    trnRay.DLR  = true;\n                    trnRay.ior  = 1.0;\n\n                    QEnqueue(trnRay);\n                }\n            }\n\n            // reflection\n            if (QSpaceLeft() < 1u) {\n                continue;\n            }\n            if (!r.DLR && dot(reflAmt, reflAmt) > cMinRayAmt * cMinRayAmt) {\n                ray_t rflRay;\n                rflRay.ro   = h.pnt + nrm * cSurfEps;\n                rflRay.rd   = reflect(r.rd, nrm);\n                rflRay.side = r.side;\n                rflRay.amt  = reflAmt;\n                rflRay.DLR  = false;\n                rflRay.ior  = r.ior;\n\n                QEnqueue(rflRay);\n            }\n        }\n    }\n}\n\n\nfloat viewportFromScreen(in float D) {\n    return D * 2.0 / MINRES / gVPZoom;\n}\n\nvec2 viewportFromScreen(in vec2 XY) {\n    return vec2(viewportFromScreen(XY.x - RES.x / 2.0),\n                viewportFromScreen(XY.y - RES.y / 2.0));\n}\n\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    readKeyboard();\n    \n    // modify XY for pixelation station\n    if (kPixelate) {\n        XY = XY - (fract(XY / cPixelation ) - 0.5) * cPixelation;\n    }\n\n    // modify XY for picture-in-picture\n    bool isPip = kPipOn && (XY.x < RES.x * cPipScale && XY.y < RES.y * cPipScale);\n    if (isPip) {\n        XY /= cPipScale;\n    }\n    \n    vec2 xy = viewportFromScreen(XY);\n    gVPEps  = viewportFromScreen(2.0);\n    gVPLW   = viewportFromScreen(2.0);\n    gT      = iTime * pi * 2.0 / 7.0;\n    vec2 ms = iMouse.xy / iResolution.xy;\n    vec2 mss;\n    if (length(iMouse.xy) < 20.0) {\n        mss.x = gT * 0.1 - ms.x * 6.0 - pi/2.0;\n        mss.y = sin(gT * 0.131 + 10.5) * 0.2 + 0.5;\n    }\n    else {\n        mss.x = -ms.x * pi * 2.3;\n        mss.y =  ms.y;\n    }\n    \n    vec2  camYMinMax = vec2(0.01, 2.0);\n    float theta      = mss.x;\n    float camY       = mix(camYMinMax[1], camYMinMax[0], smoothstep(0.0, 1.0, sqrt(mss.y)));\n    vec3  lookFrom   = vec3(sin(theta), camY, cos(theta)) * gCamDist;\n    vec3  lookTo     = vY * 10.0;\n    \n    vec3  camFw      = normalize(lookTo - lookFrom);\n    vec3  camRt      = normalize(cross(camFw, vY));\n    vec3  camUp      = cross(camRt, camFw);\n    \n    configScene();\n    \n    ray_t r;\n    r.ro    = lookFrom;\n    r.rd    = normalize(camFw + (camRt * xy.x + camUp * xy.y) * gFOVFac);\n    r.amt   = v1;\n    MST mst = map(r.ro);\n    r.side  = sign(mst.dist);\n    r.ior   = mst.dist < cWSEps ? materials[mst.mtl].ior : 1.0;\n    r.DLR   = false;\n    QEnqueue(r);\n    \n    gRGB = v0;\n    runRays();\n    \n    gRGB = pow(gRGB, vec3(1.0/2.2));\n    \n    if (isPip) {\n        const vec3 cCool = vec3(0.0, 0.0, 0.2);\n        const vec3 cHot  = vec3(1.0, 0.9, 0.2);\n        float temp = gMapCount / float(cHeatMapSteps * cHeatMapRays);\n        gRGB = mix(cCool, cHot, pow(temp, 0.6));\n    }\n\n    RGBA = vec4(gRGB, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n#define ZERO   (0)\n\nconst float pi  = 3.14159265359;\nconst vec3  v1  = vec3(1.0);\nconst vec3  v0  = vec3(0.0);\nconst vec3  vX  = vec3(1.0, 0.0, 0.0);\nconst vec3  vY  = vec3(0.0, 1.0, 0.0);\nconst vec3  vZ  = vec3(0.0, 0.0, 1.0);\nconst vec4  v41 = vec4(1.0);\n\n//--------------------------------------------------------------------------\n// keyboard conveniences\n//\n#define KEY_IS_DOWN(key, chan) (texelFetch(chan, ivec2(key, 0), 0).r > 0.0)\n#define KEY_TOGGLED(key, chan) (texelFetch(chan, ivec2(key, 2), 0).r > 0.0)\n\n\n//--------------------------------------------------------------------------\n// ray stuff\n//\nstruct ray_t {\n    vec3  ro;\n    vec3  rd;\n    vec3  amt;   // [0, 1] amount of light left in the ray\n    float side;  // -1 = inside, 1 = outside.\n    bool  DLR;   // Diffuse Lighting Ray.\n    float ior;   // index of refraction at ro.\n};\n\nstruct hit_t {\n    bool  hit;\n    float t;\n    vec3  pnt;\n    vec3  nrm;\n    uint  mtl;\n};\n\nstruct mapSample_t {\n    float dist;\n    uint  mtl;\n};\n#define MST mapSample_t\n\nstruct mtl_t {\n    float ior;\n    float diffVsTrns;\n    vec3  color;\n    vec4  absorption;  // transmissive color, density.  eg (0.8, 0.7, 0.1, 30.0)\n};\n\n\n//--------------------------------------------------------------------------\n\n// https://en.wikipedia.org/wiki/Schlick%27s_approximation\nfloat schlickR0(in float n1, in float n2) {\n    // same if n1 and n2 are swapped.\n    float q  = (n1 - n2) / (n1 + n2);\n    float q2 = q * q;\n    return q2;\n}\n\nfloat schlick(in float R0, in float cosTheta) {\n    float q  = 1.0 - cosTheta;\n    float q5 = q * q * q * q * q;\n    return R0 + ((1.0 - R0) * q5);\n}\n\n//--------------------------------------------------------------------------------\n// famous indices\nconst float ior_air                =  1.0003;\nconst float ior_aerogel            =  1.03;\nconst float ior_ice                =  1.309;\nconst float ior_water              =  1.333;\nconst float ior_quartz             =  1.46;\nconst float ior_borosilicate_glass =  1.5168;\nconst float ior_diamond            =  2.42;\nconst float ior_shiny1             =  4.0;    // ad hoc\nconst float ior_mrr                =  1e2;    // ad hoc\n\n//--------------------------------------------------------------------------\n\n// fifo queue.\n// This is a basic ringbuffer.\n// NO ERROR CHECKING\n//\n// usage:\n// #define Q_TYPE and Q_MAX_ENTRIES,\n// then put Q_IMPLEMENTATION.\n// (Q_MAX_ENTRIES is a uint)\n//\n// for example:\n// #define Q_TYPE        ray_t\n// #define Q_MAX_ENTRIES 16u\n// Q_IMPLEMENTATION\n//\n// orion elenzil 2022.\n#define Q_IMPLEMENTATION                           \\\nconst uint gQCapacity = Q_MAX_ENTRIES;             \\\nconst uint gQNumSlots = gQCapacity + 1u;           \\\nQ_TYPE gQ[gQNumSlots];                             \\\nuint gQHead = 0u;                                  \\\nuint gQTail = 0u;                                  \\\n                                                   \\\nuint QCount() {                                    \\\n    if (gQHead >= gQTail) {                        \\\n        return gQHead - gQTail;                    \\\n    }                                              \\\n    else {                                         \\\n        return gQNumSlots - (gQTail - gQHead);     \\\n    }                                              \\\n}                                                  \\\n                                                   \\\nuint QSpaceLeft() {                                \\\n    return gQCapacity - QCount();                  \\\n}                                                  \\\n                                                   \\\nbool QIsFull() {                                   \\\n    return QSpaceLeft() == 0u;                     \\\n}                                                  \\\n                                                   \\\nbool QIsEmpty() {                                  \\\n    return QCount() == 0u;                         \\\n}                                                  \\\n                                                   \\\nuint _QEnqueueIndex() {                            \\\n    gQHead = (gQHead + 1u) % gQNumSlots;           \\\n    return gQHead;                                 \\\n}                                                  \\\n                                                   \\\nuint _QDequeueIndex() {                            \\\n    gQTail = (gQTail + 1u) % gQNumSlots;           \\\n    return gQTail;                                 \\\n}                                                  \\\n                                                   \\\nvoid QEnqueue(Q_TYPE item) {                       \\\n    gQ[_QEnqueueIndex()] = item;                   \\\n}                                                  \\\n                                                   \\\nQ_TYPE QDequeue() {                                \\\n    return gQ[_QDequeueIndex()];                   \\\n}\n\n//--------------------------------------------------------------------------\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBoxFrame(in vec3 p, in vec3 b, in float e ) {\n  p = abs(p)-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\n//--------------------------------------------------------------------------\n\nmat2 rot2(in float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\n//--------------------------------------------------------------------------\n\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvoid rayVsPlane(in ray_t ray, in vec3 n, in float d, uint mtl, inout hit_t hit) {\n    float t = -(dot(ray.ro, n) + d) / (dot(ray.rd, n));\n    if (t > 0.0 && t < hit.t) {\n        hit.hit = true;\n        hit.t   = t;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = n;\n    }\n}\n\n//--------------------------------------------------------------------------\n\nvoid opUnion(inout mapSample_t cur, mapSample_t new) {\n    if (new.dist < cur.dist) {\n        cur.dist = new.dist;\n        cur.mtl  = new.mtl;\n    }\n}\n\nvoid opMinus(inout float cur, in float new) {\n    cur = -min(new, -cur);\n}\n\nvoid opMinus(inout mapSample_t cur, mapSample_t new) {\n    if (-new.dist > cur.dist) {\n        cur.dist = -new.dist;\n        cur.mtl  = new.mtl;\n    }\n}\n\nvoid opInter(inout float cur, in float new) {\n    cur = max(cur, new);\n}\n\nvoid opInter(inout mapSample_t cur, mapSample_t new) {\n    if (new.dist > cur.dist) {\n        cur.dist = new.dist;\n        cur.mtl  = new.mtl;\n    }\n}\n\nvoid opUnion(inout float cur, float new) {\n    cur = min(cur, new);\n}\n\n// https://iquilezles.org/articles/smin\n// polynomial smooth min\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}