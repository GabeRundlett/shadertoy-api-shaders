{
    "Shader": {
        "info": {
            "date": "1644797671",
            "description": "More fun synthwave stuff.\nIncrease FSAA if your GPU can handle it. If you're experiencing low framerate, set FSAA to 1 and decrease MAX_ITER.\nSet JUMP to true for more fun.",
            "flags": 0,
            "hasliked": 0,
            "id": "NsScWt",
            "likes": 7,
            "name": "Synthwave grid landscape",
            "published": 3,
            "tags": [
                "retro",
                "synthwave"
            ],
            "usePreview": 0,
            "username": "nyri0",
            "viewed": 597
        },
        "renderpass": [
            {
                "code": "const vec3 BG = vec3(0, 0, 0);\nconst float EPS = 0.001;\nconst float FOVH = 70.0;\nconst float D = 0.1;\nconst float MAX_DIST = 30.0;\nconst int MAX_ITER = 400;\nconst float AMBIENT = 0.1;\nconst int FSAA = 2;\nconst float GRID_DIM = 1.0;\nconst bool JUMP = false;\n\nfloat jTime;\n\n\nfloat sq(float x) {\n    return x*x;\n}\n\n// From https://www.shadertoy.com/view/Msf3WH\nvec2 hashv( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hashv(i+0.0)), dot(b,hashv(i+o)), dot(c,hashv(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\n// From https://www.shadertoy.com/view/WttXWX\nuint hash(uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat hash(vec2 vf) {\n    uint offset = vf.x < 0.0 ? 13u : 0u;\n    uvec2 vi = uvec2(abs(vf));\n    return float(hash(vi.x + (vi.y<<16) + offset)) / float( 0xffffffffU );\n}\n\nfloat vertex_height(vec2 vf) {\n    float offset = - 2.0 + 2.0*smoothstep(5., 8., abs(vf.x));\n    float amplitude = mix(0.5, 2., smoothstep(7., 12., abs(vf.x)));\n    return amplitude * hash(vf) + offset + (JUMP ? 0.2*abs(sin(4.*iTime)) : 0.);\n}\n\n// Adapted from https://www.shadertoy.com/view/tsScRK\nfloat height_and_color_map(vec2 proj){\n    proj /= GRID_DIM;\n    proj.x -= 0.5;\n    vec2 d = fract(proj);\n    proj -= d;\n    bool gd = dot(d,vec2(1))<1.;\n    vec2 pt = proj + (gd ? 0. : 1.);\n    float n2 = vertex_height(proj+vec2(1,0));\n    float n3 = vertex_height(proj+vec2(0,1));\n    float nt = vertex_height(pt);\n    float nmid = mix(n2,n3,d.y);\n    float nv, dx;\n    if(gd) {\n        nv = mix(nt,n3,d.y);\n        dx = d.x/(1.-d.y);\n\t} else {\n        nv = mix(n2,nt,d.y);\n        dx = (1.-d.x)/(d.y);\n\t}\n    return mix(nv,nmid,dx);\n}\n\n\n// Signed distance function that defines the scene.\nfloat sdf(in vec3 pos ) {    \n    return pos.y - height_and_color_map(pos.xz);\n}\n\n// Ray marching engine.\nvoid rayMarcher(in vec3 cameraPos, in vec3 lookDir, in vec2 screenDim, in vec2 uv,\n                inout vec3 col) {\n    vec3 up = vec3(0, 1, 0);\n    vec3 lookPerH = normalize(cross(lookDir, up));\n    vec3 lookPerV = normalize(cross(-lookDir, lookPerH));\n    vec3 screenCenter = cameraPos + lookDir;\n    vec3 screenPos = screenCenter + 0.5 * screenDim.x * uv.x * lookPerH\n                     + 0.5 * screenDim.y * uv.y * lookPerV;\n    \n    vec3 rayDir = normalize(screenPos - cameraPos);\n    \n    float t = 0.0;\n    float dist;\n    vec3 pos;\n    int iter;\n    do {\n        pos = cameraPos + t * rayDir;\n        dist = sdf(pos);\n        t += 0.5*dist;\n        iter++;\n    } while(iter < MAX_ITER && dist < MAX_DIST && dist > EPS);\n    \n    if(dist <= EPS) {\n        vec3 new_col = vec3(0, 0, 0);\n        \n        vec3 nml = normalize(vec3(\n            dist - sdf(pos - vec3(EPS, 0, 0)),\n            dist - sdf(pos - vec3(0, EPS, 0)),\n            dist - sdf(pos - vec3(0, 0, EPS))\n        ));\n    \n        float dx = mod(pos.x-GRID_DIM/2.0, GRID_DIM);\n        dx = min(dx, GRID_DIM-dx);\n        float dz = mod(pos.z, GRID_DIM);\n        dz = min(dz, GRID_DIM-dz);\n        float col_t = smoothstep(4., 7., abs(pos.x));\n        vec3 col_dark = mix(vec3(0.3, 0, 0.3), vec3(0.1, 0.2, 0.3), col_t);\n        vec3 col_bright = mix(vec3(1., 0.9, 1.), vec3(0.9, 1., 1.), col_t);\n        vec3 lightDir = vec3(0.0, -0.5, 1);\n        new_col = mix(new_col, col_dark, clamp(dot(-lightDir, nml), 0.0, 1.0));\n        new_col = mix(col_bright, new_col, smoothstep(0.02, 0.04, min(dx, dz)));\n        \n        //new_col = mix(new_col, vec3(0,0,0), smoothstep(15., 30., cameraPos.z - pos.z));\n        col = mix(new_col, col, smoothstep(28., 30., cameraPos.z - pos.z));\n    }\n}\n\nvec4 sampleColor(in vec2 sampleCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    float screenWidth = 2.0 * D * atan(0.5 * FOVH);\n\n    vec3 cameraPos = vec3(0, 0, -2.*iTime);\n    vec3 lookDir = vec3(0, 0, -D);\n    vec2 screenDim = vec2(screenWidth, screenWidth / aspectRatio);\n\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = 2.0 * sampleCoord / iResolution.xy - 1.0;\n    \n    // Pixel coordinates fixed with correct aspect ratio\n    vec2 uvf = 2.0* (sampleCoord - iResolution.xy / 2.0) / iResolution.y;\n    \n    vec3 col = BG;\n    \n    // Stars\n    float noiseVal = noise(60.0 * uvf);\n    float whiteIntensity = smoothstep(0.6, 1.0, noiseVal);\n    col = mix(col, vec3(1,1,1), whiteIntensity);\n    \n    // Sun\n    const vec2 sun_c = vec2(0, 0.25);\n    const float sun_r = 0.4;\n    if(length(uvf-sun_c) < sun_r) {\n        vec3 sun_col = mix(vec3(1, .4, .8), vec3(1, 1, .3), (uv.y-sun_c.y+sun_r)/(2.*sun_r));\n        const float BAND_HEIGHT = 0.02;\n        float dy = mod(uvf.y, BAND_HEIGHT) / BAND_HEIGHT;\n        col = mix(sun_col, vec3(0,0,0), smoothstep(0.25, 0.35, abs(dy-0.5)));\n    }\n    \n    // Grid\n    rayMarcher(cameraPos, lookDir, screenDim, uv, col);\n\n    // Output to screen\n    return vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 colSum = vec4(0);\n    for(int i = 0; i < FSAA; i++) {\n        for(int j = 0; j < FSAA; j++) {\n            colSum += sampleColor(fragCoord + vec2(float(i) / float(FSAA), float(j) / float(FSAA)));\n        }\n    }\n    fragColor = colSum / colSum.w;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}