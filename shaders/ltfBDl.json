{
    "Shader": {
        "info": {
            "date": "1513983522",
            "description": "A spiritual successor to my old infinite city, but based on a fractal pattern.\nHere's a map of the city: https://twitter.com/TekF/status/943940594254139393",
            "flags": 0,
            "hasliked": 0,
            "id": "ltfBDl",
            "likes": 23,
            "name": "City Fractal",
            "published": 3,
            "tags": [
                "fractalcityraymarch"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 1090
        },
        "renderpass": [
            {
                "code": "// City Fractal\n// By Hazel Quantock\n\n// disable this if running at high resolution\n#define ANTIALIASING 1\n\n// enable this to smooth out the frame rate (this seems to work better in Chrome than Firefox)\n//#define FPS30 1\n\n// ray march distance multiplier, use range 1-10\n#define DRAWDIST 10\n\n#define WIDESCREEN 1\n#define POSTPROCESS 1\n\n\nuint Hash( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uint k = n * n * n * 48271U;\n    return k & 0xffffffffU;\n}\n\n\nconst float roadRad = .2;\n\n// buildings: x = horizontal distance, y = vertical distance\nvec2 Buildings( vec2 uv )\n{\n//    uv -= .05; // make thick & thin roads\n    uv -= .5; // less repetetive buildings! (nice)\n    \n    uvec2 iuv = uvec2(abs(uv));\n    \n    // DAMMIT! They're all the same building!\n    // can skip the wrap in the last stage, but it's only 1.68 smaller than the next wrap\n    // so we get 2x2 blocks of buildings, of 2 (maybe 4) different heights\n    uint seed = Hash(iuv.x+(iuv.y<<8U));\n    float h = float(seed&0xffffffU)/float(0xffffffU);\n    \n    // => most buildings have a mirror running through them, so I need a mirror that syncs seeds for straddling buildings\n/* e.g: 3D \"buildings\" pattern, reflection = 90 degree rotation...\n=> won't get same angle both sides => will slice through buildings into the ground\nWhich will break the SDFs (creating flat spots and shallower gradients - fairly safe but annoying)\n*/    \n/*\nIt would be easy if we were spawning (not just pickig) tiles\neach tile could check its already picked neighbours so would never create invalid transition\nthough obviously wouldn't be deterministic\n*/\n/*\nI wonder if there's something we can do by colouring in an intermediate buffer...\n*/\n    \n    vec2 d = abs(fract(uv)-.5)-(.5-roadRad);\n    float f = max(d.x,d.y);\n    if ( f > .0 ) f = length(max(d,0.));\n    \n    return vec2(f,h);\n}\n\n// tiled reflection - repeat [0,1] on x & y\nvec2 Wrap( vec2 uv )\n{\n    // 0,1,0,1,0,1,0,1 triangle wave\n//    return abs(mod(uv-.5,2.)-1.)-.5;\n    // allow precession whilst also partly wrapping\n    //0,1,2,1,2,3,2,3,4,3,4,5 - 1:1 gradient so scale isn't affected\n    vec2 fl = floor(uv/3.);\n    vec2 fr = uv-3.*fl;\n    return fl + min(fr,4.-fr);\n}\n\nvec2 Rot( vec2 uv, float a )\n{\n    return uv*cos(a) + uv.yx*vec2(1,-1)*sin(a);\n}\n\n\nvec2 Map( vec2 uv )\n{\n    int n = 4; // lower = cheaper\n    float a = 1.275;\n    float s = 4.1;\n    \n    // adjust our view\n    //uv *= exp(-sin(iTime/3.)+1.);\n    //uv += vec2(.618,.382)*.1*iTime;\n    float scale = 3.;\n\tuv /= scale * pow(s,float(n)); // mul by all the scales we'll accumulate in the loop\n    uv = Rot(uv,.5-a);\n    \n\tfor ( int i=0; i < n; i++ )\n    {\n        //uv += -.07;\n        uv *= s;\n\t    uv = Rot(uv,a);\n        uv = Wrap(uv);\n    }\n    \n    vec2 d = Buildings( uv ); // .5/.0 look okay, other values mess up roads (but .05 gives thick & thin roads\n    d.x *= scale;\n    return d;\n}\n\n\nfloat SDF( vec3 pos )\n{\n    vec2 d = Map(pos.xz);\n    \n    const float minH = .3;\n    const float houseH = 2. - minH;\n    const float scraperH = 6. - houseH;\n    const float maxH = minH+houseH+scraperH;\n    float h = d.y*houseH + pow(d.y,20.)*scraperH + minH;\n    if ( d.y < .1 ) h = 0.; // parks\n    \n    // need to constrain the gradient - because we don't know how tall adjacent buildings are\n    // but this confuses the ambient occlusion, making roofs a bit darker\n    float roof = min( pos.y-h, roadRad*2. );\n    \n    float sdf = max( d.x, roof );\n    \n    // floor\n    sdf = min( sdf, pos.y );\n    \n    sdf = max( sdf, pos.y-maxH ); // max h, let it ramp up above roadRad so the sky looks good\n    \n    return sdf;\n}\n\n\nvec3 mainImage2( vec2 fragCoord )\n{\n    vec3 colour;\n    \n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.x;\n\n#if defined(WIDESCREEN)\n    float sh = iResolution.x/2.4;\n#else\n    float sh = iResolution.y;\n#endif\n\tvec3 ray = normalize(vec3((fragCoord-iResolution.xy*.5)/sh,2.+smoothstep(.1,.4,sin(iTime/8.))));\n    \n    vec2 a = vec2(.29,iTime/50.);\n    ray.zy = ray.zy*cos(a.x)+ray.yz*sin(a.x)*vec2(1,-1);\n    ray.xz = ray.xz*cos(a.y)+ray.zx*sin(a.y)*vec2(1,-1);\n    \n    vec3 pos = vec3(iTime*3.,15,sin(iTime/20.)*100.)+vec3(-20,0,-70);\n/*\tvec3 ray = normalize(vec3((fragCoord-iResolution.xy*.5)/iResolution.y,5.));\n    \n    vec2 a = vec2(.16+.02*sin(iTime*.5),.3+.05*sin(iTime*.2));\n    ray.zy = ray.zy*cos(a.x)+ray.yz*sin(a.x)*vec2(1,-1);\n    ray.xz = ray.xz*cos(a.y)+ray.zx*sin(a.y)*vec2(1,-1);\n    \n    vec3 pos = vec3(iTime*5.,12.+sin(iTime*.3),sin(iTime*.21)*5.);*/\n\n    \n    float t = 0.;\n    float h = 1.;\n    for ( int i=0; i < 50*DRAWDIST; i++ ) // this increases the quality of the horizon\n    {\n        h = SDF(pos+t*ray);\n        t += h;\n        if ( h < .001 ) break;\n    }\n    \n   \tpos += t*ray;\n\n    if ( h < .1 )\n    {\n        vec2 d = vec2(-1,1)*.02;\n        vec3 grad = SDF(pos+d.xxx)/d.xxx+\n                    SDF(pos+d.xyy)/d.xyy+\n                    SDF(pos+d.yxy)/d.yxy+\n                    SDF(pos+d.yyx)/d.yyx;\n        vec3 n = normalize(grad);\n\n        float ao = //smoothstep(-1.,1.,max(pos.y,Map(pos.xz).x))\n                   1.-.7*clamp( pow( max(.0,1.-mix( SDF(pos+n*1.5)/1.5, SDF(pos+n*.4)/.4, .2 )), 2. ), .0, 1. );\n        vec3 ambient = vec3(.2,.3,.5) * ao;\n            \t\t\n        vec3 sunDir = normalize(vec3(-3,1,-2));\n        vec3 sun = vec3(2,1.8,1.6)*max(.0,dot(n,sunDir));\n\n        float ts = .013 *.01/(SDF(pos+sunDir*.01)); // correct by actual gradient!)\n        float hs = 1.;\n        for ( int i=0; i < 10*DRAWDIST; i++ ) // keep this number as low as I can get away with\n        {\n            hs = SDF(pos+ts*sunDir);\n            ts += hs;\n            if ( hs < .01 ) break;\n        }\n        // sun shadow\n        if ( hs < .01 ) sun *= 0.;\n\n        vec2 map = Map(pos.xz);\n        \n        // building colour\n        vec3 paint = fract(map.y*161.8f*vec3(1.,7.,49.)); // pseudo random\n        vec3 albedo = mix( pow(paint*vec3(1,1,.9),vec3(8.)), vec3(.2), .8 ); // tone it down\n        \n        // road colour\n        vec3 road = mix( vec3(.25), vec3(.1), smoothstep(.23,.24,map.x) );\n        road = mix( paint*.1+vec3(.1,.2,.0), road, smoothstep(-.3,.0,map.x) );\n        //road = mix( road, vec3(.8), smoothstep(.015,.005,abs(map.x-.58)) ); // these are nice but they make the buildings look worse by comparison\n        //road = mix( road, vec3(1,.9,0), smoothstep(.015,.005,abs(map.x-.27)) );\n        albedo = mix( road, albedo, smoothstep(.0,.01,pos.y) );\n        \n        colour.rgb = albedo*(ambient+sun);\n    }\n    else\n    {\n        colour.rgb = vec3(.1);\n    }\n    \n\t// atmosphere\n    colour.rgb = mix(vec3(.5,.75,1.),colour.rgb,exp2(-t*vec3(.1,.3,1.)/500.));\n    \n    return colour;\n}\n\n\nvoid mainImage( out vec4 colour, in vec2 fragCoord )\n{\n#if defined( WIDESCREEN )\n    if ( abs(fragCoord.y-iResolution.y*.5) > .5*iResolution.x/2.4 )\n    {\n        colour = vec4(0);\n        return;\n    }\n#endif\n    \n#if defined( FPS30 )\n    if ( (iFrame&1) != 0 ) discard; // run at 30fps - use this if frame rate is bad\n#endif\n    \n#if defined( ANTIALIASING ) // better quality, good for video capture\n    // rotated grid AA - really breaks up the straight lines\n    colour.rgb = (\n\t\tmainImage2(fragCoord+vec2(-3,-1)/8.) +\n\t\tmainImage2(fragCoord+vec2(-1, 3)/8.) +\n\t\tmainImage2(fragCoord+vec2( 1,-3)/8.) +\n\t\tmainImage2(fragCoord+vec2( 3, 1)/8.)\n        )/4.;\n#else\n    colour.rgb = mainImage2(fragCoord);\n#endif\n    \n#if defined(POSTPROCESS)\n#if defined(WIDESCREEN)\n    float sh = iResolution.x/2.4;\n#else\n    float sh = iResolution.y;\n#endif\n\n\t// vignette\n\tcolour.rgb *= smoothstep(1.6,.4,length((fragCoord-iResolution.xy*.5)/sh));\n\t\n\t// contrast\n\tcolour.rgb *= 1.5;\n\tfloat grey = dot(colour.rgb,vec3(.2126,.7152,.0722));\n\tfloat bottom = .03;\n\tcolour.rgb *= (sqrt(grey*grey+bottom*bottom)-bottom)/grey; // squash dark tones together to increase contrast\n#endif\n    \n    colour.rgb = pow(colour.rgb,vec3(.4545));\n    \n    colour.a = 1.;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}