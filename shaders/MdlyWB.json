{
    "Shader": {
        "info": {
            "date": "1489797032",
            "description": "Porting JTippets's Accidental Noise Library (ANL) to GLSL\nStart this shader and start listening to your music. Notice how Audio Mixing can interfere with the way you perceive music!\nBest experienced with Headphones.",
            "flags": 8,
            "hasliked": 0,
            "id": "MdlyWB",
            "likes": 3,
            "name": "Hypnosis (ANL)",
            "published": 3,
            "tags": [
                "noise"
            ],
            "usePreview": 0,
            "username": "petersvp",
            "viewed": 647
        },
        "renderpass": [
            {
                "code": "// ANL Config & porting shortcuts & forwards\n#define ANLFloatType float\nfloat base_noisegen(vec3 xyz, ivec3 ixyz, int seed, int noisefunc);\nconst ANLFloatType F2=0.36602540378443864676372317075294;\nconst ANLFloatType G2=0.21132486540518711774542560974902;\nconst ANLFloatType F3=1.0/3.0;\nconst ANLFloatType G3=1.0/6.0;\n\n// ANL Utils\n#define FNV_32_PRIME (uint(16777619))\n#define FNV_32_INIT (uint(2116136261))\n#define FNV_MASK_8 ((uint(uint(1)<<uint(8))-uint(1)))\nfloat lerp(float s, float v1, float v2){return v1+s*(v2-v1);}\nint fast_floor(float t) { return (t>0.0 ? int(t) : int(t) - 1); }\nuint fnv_32_a_combine(uint hash, uint val) { hash^=val;\thash*=FNV_32_PRIME;\treturn hash; }\nuint xor_fold_hash(uint hash){\n    return (uint((hash>>uint(8)) ^ (hash & FNV_MASK_8))) % uint(256);\n}\nuint hash_coords(ivec3 xyz, uint seed)\n{\n\tuint hash=FNV_32_INIT;\n\thash=fnv_32_a_combine(hash,uint(xyz.x));\n\thash=fnv_32_a_combine(hash,uint(xyz.y));\n\thash=fnv_32_a_combine(hash,uint(xyz.z));\n\thash=fnv_32_a_combine(hash,seed);\n\treturn xor_fold_hash(hash);\n}\nuint compute_hash_float(vec3 xyz, uint seed)\n{\n    uint hash=FNV_32_INIT;\n    hash=fnv_32_a_combine(hash,uint(xyz.x*1000000.));\n\thash=fnv_32_a_combine(hash,uint(xyz.y*1000000.));\n\thash=fnv_32_a_combine(hash,uint(xyz.z*1000000.));\n    hash=fnv_32_a_combine(hash, seed);\n    return xor_fold_hash(hash);\n}\nfloat array_dot3(vec3 arr, vec3 abc)\n{\n    return abc.x*arr[0]+abc.y*arr[1]+abc.z*arr[2];\n}\nfloat rand(float v){ return fract(sin(dot(v ,12.9898)) * 43758.5453);}\n// ANL Interp\n#define NONE 0\n#define LINEAR 2\n#define CUBIC 3\n#define QUINTIC 4\nfloat interpNONE(float t) {return 0.0;}\nfloat interpLINEAR(float t) {return t;}\nfloat interpCUBIC(float t) {return (t*t*(3.0-2.0*t));} \nfloat interpQUINTIC(float t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nfloat interp(float v, int t)\n{\n    if(t==NONE)    return interpNONE(v);\n    if(t==LINEAR)  return interpLINEAR(v);\n    if(t==CUBIC)   return interpCUBIC(v);\n    if(t==QUINTIC) return interpQUINTIC(v);\n    return -1.0;\n}\nfloat interp_X_3(vec3 xyz, float xs, int x0, int x1, int iy, int iz, int seed, int noisefunc) \n{\n    float v1=base_noisegen(xyz,ivec3(x0,iy,iz),seed,noisefunc);\n    float v2=base_noisegen(xyz,ivec3(x1,iy,iz),seed,noisefunc);\n    return lerp(xs,v1,v2);\n}\nfloat interp_XY_3(vec3 xyz, vec2 xys, ivec2 xyi0, ivec2 xyi1, int iz, int seed, int noisefunc)\n{\n    float v1=interp_X_3(xyz,xys.x,xyi0.x,xyi1.x,xyi0.y,iz,seed,noisefunc);\n    float v2=interp_X_3(xyz,xys.x,xyi0.x,xyi1.x,xyi1.y,iz,seed,noisefunc);\n    return lerp(xys.y,v1,v2);\n}\nfloat interp_XYZ_3(vec3 xyz, vec3 xyzs, ivec3 xyzi0, ivec3 xyzi1, int seed, int noisefunc)\n{\n    float v1=interp_XY_3(xyz, vec2(xyzs.x,xyzs.y), ivec2(xyzi0.x,xyzi0.y), ivec2(xyzi1.x,xyzi1.y), xyzi0.z,seed,noisefunc);\n    float v2=interp_XY_3(xyz, vec2(xyzs.x,xyzs.y), ivec2(xyzi0.x,xyzi0.y), ivec2(xyzi1.x,xyzi1.y), xyzi1.z,seed,noisefunc);\n    return lerp(xyzs.z,v1,v2);\n}\n\n\n// ANL Basis\n#define VALUE 0\n#define GRADIENT 1\n#define GRADVAL 2\n#define SIMPLEX 3\n#define WHITE 4\nfloat value_noise(vec3 xyz, ivec3 ixyz, uint seed)\n{\n    uint n = hash_coords(ixyz,seed);\n    float noise= float(n) /255.0;\n    return noise;\n}\nvec3 gradient(ivec3 ixyz, uint seed)\n{\n    float hashX = (float(hash_coords(ixyz,seed-1u))-128.) / 256.0;\n    float hashY = (float(hash_coords(ixyz,seed+0u))-128.) / 256.0;\n    float hashZ = (float(hash_coords(ixyz,seed+1u))-128.) / 256.0;\n    return normalize(vec3(hashX,hashY,hashZ));\n}\n\nfloat grad_noise(vec3 xyz, ivec3 ixyz, uint seed)\n{\n    vec3 grad = gradient(ixyz,seed);\n    vec3 d = xyz - vec3(ixyz);\n    return (d.x*grad.x + d.y*grad.y + d.z*grad.z);\n}\nfloat white_noise(vec3 xyz, ivec3 ixyz, uint seed)\n{\n\treturn float(compute_hash_float(xyz,seed)) / 255.0;\n}\nfloat simplex_noise(vec3 xyz, ivec3 ixyz, uint seed)\n{\n\tvec4 n;\n    float s=(xyz.x+xyz.y+xyz.z)*F3;\n    int i=fast_floor(xyz.x+s);\n    int j=fast_floor(xyz.y+s);\n    int k=fast_floor(xyz.z+s);\n    float t=float(i+j+k)*G3;\n    vec3 XYZ0 = vec3(ivec3(i,j,k))-vec3(t);\n    vec3 xyz0 = xyz - XYZ0;\n    ivec3 ijk1, ijk2;\n    if(xyz0.x>=xyz0.y)\n    {\n        if(xyz0.y>=xyz0.z)\n        {\n            ijk1 = ivec3(1,0,0); ijk2 = ivec3(1,1,0);\n        }\n        else if(xyz0.x>=xyz0.z)\n        {\n            ijk1 = ivec3(1,0,0); ijk2 = ivec3(1,0,1);\n        }\n        else\n        {\n            ijk1 = ivec3(0,0,1); ijk2 = ivec3(1,0,1);\n        }\n    }\n    else\n    {\n        if(xyz0.y<xyz0.z)\n        {\n            ijk1 = ivec3(0,0,1); ijk2 = ivec3(0,1,1);\n        }\n        else if(xyz0.x<xyz0.z)\n        {\n            ijk1 = ivec3(0,1,0); ijk2 = ivec3(0,1,1);\n        }\n        else\n        {\n            ijk1 = ivec3(0,1,0); ijk2 = ivec3(1,1,0);\n        }\n    }\n    vec3 xyz1 = xyz0 - vec3(ijk1) + G3;\n    vec3 xyz2 = xyz0 - vec3(ijk2) + 2.0*G3;\n    vec3 xyz3 = xyz0 - 1.0 + 3.0*G3;\n\t\n    vec3 g0 = gradient(ivec3(i,j,k),seed);\n    vec3 g1 = gradient(ivec3(i+ijk1.x,j+ijk1.y,k+ijk1.z),seed);\n    vec3 g2 = gradient(ivec3(i+ijk2.x, j+ijk2.y,k+ ijk2.z),seed);\n    vec3 g3 = gradient(ivec3(i+1,j+1,k+1),seed);\n    \n    float t0 = 0.6 - xyz0.x*xyz0.x - xyz0.y*xyz0.y - xyz0.z*xyz0.z;\n    if(t0<0.0) n[0]=0.0;\n    else {\n        t0 *= t0;\n        n[0] = t0*t0*array_dot3(g0,xyz0);\n    }\n    float t1 = 0.6 - xyz1.x*xyz1.x - xyz1.y*xyz1.y - xyz1.z*xyz1.z;\n    if(t1<0.0) n[1]=0.0;\n    else {\n        t1 *= t1;\n        n[1] = t1*t1*array_dot3(g1,xyz1);\n    }\n    float t2 = 0.6 - xyz2.x*xyz2.x - xyz2.y*xyz2.y - xyz2.z*xyz2.z;\n    if(t2<0.0) n[2]=0.0;\n    else\n    {\n        t2 *= t2;\n        n[2] = t2*t2*array_dot3(g2,xyz2);\n    }\n    float t3 = 0.6 - xyz3.x*xyz3.x - xyz3.y*xyz3.y - xyz3.z*xyz3.z;\n    if(t3<0.0) n[3]=0.0;\n    else\n    {\n        t3*=t3;\n        n[3]=t3*t3*array_dot3(g3,xyz3);\n    }\n    \n\treturn ((32.0*(n[0]+n[1]+n[2]+n[3]))*1.25086885 + 0.0003194984) /2.0 +0.5;\n}\nfloat base_noisegen(vec3 xyz, ivec3 ixyz, int seed, int noisefunc)\n{\n    if(noisefunc == VALUE) return value_noise(xyz, ixyz, uint(seed));\n    if(noisefunc == GRADIENT) return grad_noise(xyz, ixyz, uint(seed));\n    if(noisefunc == GRADVAL) return value_noise(xyz, ixyz, uint(seed)) + grad_noise(xyz, ixyz, uint(seed));\n    if(noisefunc == SIMPLEX) return simplex_noise(xyz, ixyz, uint(seed));\n    if(noisefunc == WHITE) return white_noise(xyz, ixyz, uint(seed));\n    return 0.0;\n}\nfloat basis_noise3D(vec3 xyz, int seed, int interpType, int basisType)\n{\n    int x0=fast_floor(xyz.x);\n    int y0=fast_floor(xyz.y);\n    int z0=fast_floor(xyz.z);\n    int x1=x0+1;\n    int y1=y0+1;\n    int z1=z0+1;\n    float xs=interp((xyz.x-float(x0)), interpType);\n    float ys=interp((xyz.y-float(y0)), interpType);\n    float zs=interp((xyz.z-float(z0)), interpType);\n    return interp_XYZ_3(xyz, vec3(xs,ys,zs), ivec3(x0,y0,z0), ivec3(x1,y1,z1),seed,basisType);\n}\nfloat Basis(vec3 pos, int seed, int basis, int interp)\n{\n    float nx,ny,nz;\n    return basis_noise3D(pos, seed, interp, basis);\n}\nfloat White(vec3 xyz, uint seed)\n{\n    return Basis(xyz, int(seed), WHITE, NONE);\n}\n\n// ANL Fractals\n#define FBM 0\n#define RIDGEDMULTI 1\n#define BILLOW 2\n#define MULTI 3\n#define HYBRIDMULTI 4\n#define DECARPENTIERSWISS 5\nfloat Fractal(vec3 pos, int type, int octaves, float frequency, float lacunarity, float gain, float offset, float h)\n{\n    return 0.;\n}\n\n\nfloat graph(vec3 pos)\n{\n    //return Basis(pos * vec3( Basis(pos, 3, VALUE, QUINTIC)) *.02,1 , VALUE, QUINTIC) + ((White(pos,1u)-.5) *2.)*.1;\n    //return Basis(pos*.1*vec3(1,1,50), 0, GRADVAL, CUBIC)*0.2 + Basis(pos,0,WHITE,NONE)*1.0;\n    //return Basis(pos, 0, WHITE, NONE);\n    //return Basis(pos, 0, GRADVAL, CUBIC);\n    //return Basis(pos, 0, GRADIENT, NONE);\n    //return Basis(pos, 0, SIMPLEX, NONE);\n    //return Basis(pos*40.0*vec3(1,1,10), 0, VALUE, LINEAR);\n    return max(Basis(pos*.2*vec3(1,1,50), 0, VALUE, QUINTIC),Basis(pos*vec3(1,1,2), 0, SIMPLEX, NONE)) * .2 +Basis(pos,0,WHITE,NONE);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float f = graph( vec3(fragCoord*.03, iTime*1.) );\n    f = clamp(f,0.0,1.0);\n    \n    fragColor = vec4(f);\n    if(f < 0.0) /* RED   */ fragColor = vec4(1,0,0,1);\n    if(f > 1.0) /* GREEN */ fragColor = vec4(0,1,0,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ANL Config & porting shortcuts & forwards\n#define ANLFloatType float\nfloat base_noisegen(vec3 xyz, ivec3 ixyz, int seed, int noisefunc);\nconst ANLFloatType F2=0.36602540378443864676372317075294;\nconst ANLFloatType G2=0.21132486540518711774542560974902;\nconst ANLFloatType F3=1.0/3.0;\nconst ANLFloatType G3=1.0/6.0;\n\n// ANL Utils\n#define FNV_32_PRIME (uint(16777619))\n#define FNV_32_INIT (uint(2116136261))\n#define FNV_MASK_8 ((uint(uint(1)<<uint(8))-uint(1)))\nfloat lerp(float s, float v1, float v2){return v1+s*(v2-v1);}\nint fast_floor(float t) { return (t>0.0 ? int(t) : int(t) - 1); }\nuint fnv_32_a_combine(uint hash, uint val) { hash^=val;\thash*=FNV_32_PRIME;\treturn hash; }\nuint xor_fold_hash(uint hash){\n    return (uint((hash>>uint(8)) ^ (hash & FNV_MASK_8))) % uint(256);\n}\nuint hash_coords(ivec3 xyz, uint seed)\n{\n\tuint hash=FNV_32_INIT;\n\thash=fnv_32_a_combine(hash,uint(xyz.x));\n\thash=fnv_32_a_combine(hash,uint(xyz.y));\n\thash=fnv_32_a_combine(hash,uint(xyz.z));\n\thash=fnv_32_a_combine(hash,seed);\n\treturn xor_fold_hash(hash);\n}\nuint compute_hash_float(vec3 xyz, uint seed)\n{\n    uint hash=FNV_32_INIT;\n    hash=fnv_32_a_combine(hash,uint(xyz.x*1000000.));\n\thash=fnv_32_a_combine(hash,uint(xyz.y*1000000.));\n\thash=fnv_32_a_combine(hash,uint(xyz.z*1000000.));\n    hash=fnv_32_a_combine(hash, seed);\n    return xor_fold_hash(hash);\n}\nfloat array_dot3(vec3 arr, vec3 abc)\n{\n    return abc.x*arr[0]+abc.y*arr[1]+abc.z*arr[2];\n}\nfloat rand(float v){ return fract(sin(dot(v ,12.9898)) * 43758.5453);}\n// ANL Interp\n#define NONE 0\n#define LINEAR 2\n#define CUBIC 3\n#define QUINTIC 4\nfloat interpNONE(float t) {return 0.0;}\nfloat interpLINEAR(float t) {return t;}\nfloat interpCUBIC(float t) {return (t*t*(3.0-2.0*t));} \nfloat interpQUINTIC(float t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nfloat interp(float v, int t)\n{\n    if(t==NONE)    return interpNONE(v);\n    if(t==LINEAR)  return interpLINEAR(v);\n    if(t==CUBIC)   return interpCUBIC(v);\n    if(t==QUINTIC) return interpQUINTIC(v);\n    return -1.0;\n}\nfloat interp_X_3(vec3 xyz, float xs, int x0, int x1, int iy, int iz, int seed, int noisefunc) \n{\n    float v1=base_noisegen(xyz,ivec3(x0,iy,iz),seed,noisefunc);\n    float v2=base_noisegen(xyz,ivec3(x1,iy,iz),seed,noisefunc);\n    return lerp(xs,v1,v2);\n}\nfloat interp_XY_3(vec3 xyz, vec2 xys, ivec2 xyi0, ivec2 xyi1, int iz, int seed, int noisefunc)\n{\n    float v1=interp_X_3(xyz,xys.x,xyi0.x,xyi1.x,xyi0.y,iz,seed,noisefunc);\n    float v2=interp_X_3(xyz,xys.x,xyi0.x,xyi1.x,xyi1.y,iz,seed,noisefunc);\n    return lerp(xys.y,v1,v2);\n}\nfloat interp_XYZ_3(vec3 xyz, vec3 xyzs, ivec3 xyzi0, ivec3 xyzi1, int seed, int noisefunc)\n{\n    float v1=interp_XY_3(xyz, vec2(xyzs.x,xyzs.y), ivec2(xyzi0.x,xyzi0.y), ivec2(xyzi1.x,xyzi1.y), xyzi0.z,seed,noisefunc);\n    float v2=interp_XY_3(xyz, vec2(xyzs.x,xyzs.y), ivec2(xyzi0.x,xyzi0.y), ivec2(xyzi1.x,xyzi1.y), xyzi1.z,seed,noisefunc);\n    return lerp(xyzs.z,v1,v2);\n}\n\n\n// ANL Basis\n#define VALUE 0\n#define GRADIENT 1\n#define GRADVAL 2\n#define SIMPLEX 3\n#define WHITE 4\nfloat value_noise(vec3 xyz, ivec3 ixyz, uint seed)\n{\n    uint n = hash_coords(ixyz,seed);\n    float noise= float(n) /255.0;\n    return noise;\n}\nvec3 gradient(ivec3 ixyz, uint seed)\n{\n    float hashX = (float(hash_coords(ixyz,seed-1u))-128.) / 256.0;\n    float hashY = (float(hash_coords(ixyz,seed+0u))-128.) / 256.0;\n    float hashZ = (float(hash_coords(ixyz,seed+1u))-128.) / 256.0;\n    return normalize(vec3(hashX,hashY,hashZ));\n}\n\nfloat grad_noise(vec3 xyz, ivec3 ixyz, uint seed)\n{\n    vec3 grad = gradient(ixyz,seed);\n    vec3 d = xyz - vec3(ixyz);\n    return (d.x*grad.x + d.y*grad.y + d.z*grad.z);\n}\nfloat white_noise(vec3 xyz, ivec3 ixyz, uint seed)\n{\n\treturn float(compute_hash_float(xyz,seed)) / 255.0;\n}\nfloat simplex_noise(vec3 xyz, ivec3 ixyz, uint seed)\n{\n\tvec4 n;\n    float s=(xyz.x+xyz.y+xyz.z)*F3;\n    int i=fast_floor(xyz.x+s);\n    int j=fast_floor(xyz.y+s);\n    int k=fast_floor(xyz.z+s);\n    float t=float(i+j+k)*G3;\n    vec3 XYZ0 = vec3(ivec3(i,j,k))-vec3(t);\n    vec3 xyz0 = xyz - XYZ0;\n    ivec3 ijk1, ijk2;\n    if(xyz0.x>=xyz0.y)\n    {\n        if(xyz0.y>=xyz0.z)\n        {\n            ijk1 = ivec3(1,0,0); ijk2 = ivec3(1,1,0);\n        }\n        else if(xyz0.x>=xyz0.z)\n        {\n            ijk1 = ivec3(1,0,0); ijk2 = ivec3(1,0,1);\n        }\n        else\n        {\n            ijk1 = ivec3(0,0,1); ijk2 = ivec3(1,0,1);\n        }\n    }\n    else\n    {\n        if(xyz0.y<xyz0.z)\n        {\n            ijk1 = ivec3(0,0,1); ijk2 = ivec3(0,1,1);\n        }\n        else if(xyz0.x<xyz0.z)\n        {\n            ijk1 = ivec3(0,1,0); ijk2 = ivec3(0,1,1);\n        }\n        else\n        {\n            ijk1 = ivec3(0,1,0); ijk2 = ivec3(1,1,0);\n        }\n    }\n    vec3 xyz1 = xyz0 - vec3(ijk1) + G3;\n    vec3 xyz2 = xyz0 - vec3(ijk2) + 2.0*G3;\n    vec3 xyz3 = xyz0 - 1.0 + 3.0*G3;\n\t\n    vec3 g0 = gradient(ivec3(i,j,k),seed);\n    vec3 g1 = gradient(ivec3(i+ijk1.x,j+ijk1.y,k+ijk1.z),seed);\n    vec3 g2 = gradient(ivec3(i+ijk2.x, j+ijk2.y,k+ ijk2.z),seed);\n    vec3 g3 = gradient(ivec3(i+1,j+1,k+1),seed);\n    \n    float t0 = 0.6 - xyz0.x*xyz0.x - xyz0.y*xyz0.y - xyz0.z*xyz0.z;\n    if(t0<0.0) n[0]=0.0;\n    else {\n        t0 *= t0;\n        n[0] = t0*t0*array_dot3(g0,xyz0);\n    }\n    float t1 = 0.6 - xyz1.x*xyz1.x - xyz1.y*xyz1.y - xyz1.z*xyz1.z;\n    if(t1<0.0) n[1]=0.0;\n    else {\n        t1 *= t1;\n        n[1] = t1*t1*array_dot3(g1,xyz1);\n    }\n    float t2 = 0.6 - xyz2.x*xyz2.x - xyz2.y*xyz2.y - xyz2.z*xyz2.z;\n    if(t2<0.0) n[2]=0.0;\n    else\n    {\n        t2 *= t2;\n        n[2] = t2*t2*array_dot3(g2,xyz2);\n    }\n    float t3 = 0.6 - xyz3.x*xyz3.x - xyz3.y*xyz3.y - xyz3.z*xyz3.z;\n    if(t3<0.0) n[3]=0.0;\n    else\n    {\n        t3*=t3;\n        n[3]=t3*t3*array_dot3(g3,xyz3);\n    }\n    \n\treturn ((32.0*(n[0]+n[1]+n[2]+n[3]))*1.25086885 + 0.0003194984) /2.0 +0.5;\n}\nfloat base_noisegen(vec3 xyz, ivec3 ixyz, int seed, int noisefunc)\n{\n    if(noisefunc == VALUE) return value_noise(xyz, ixyz, uint(seed));\n    if(noisefunc == GRADIENT) return grad_noise(xyz, ixyz, uint(seed));\n    if(noisefunc == GRADVAL) return value_noise(xyz, ixyz, uint(seed)) + grad_noise(xyz, ixyz, uint(seed));\n    if(noisefunc == SIMPLEX) return simplex_noise(xyz, ixyz, uint(seed));\n    if(noisefunc == WHITE) return white_noise(xyz, ixyz, uint(seed));\n    return 0.0;\n}\nfloat basis_noise3D(vec3 xyz, int seed, int interpType, int basisType)\n{\n    int x0=fast_floor(xyz.x);\n    int y0=fast_floor(xyz.y);\n    int z0=fast_floor(xyz.z);\n    int x1=x0+1;\n    int y1=y0+1;\n    int z1=z0+1;\n    float xs=interp((xyz.x-float(x0)), interpType);\n    float ys=interp((xyz.y-float(y0)), interpType);\n    float zs=interp((xyz.z-float(z0)), interpType);\n    return interp_XYZ_3(xyz, vec3(xs,ys,zs), ivec3(x0,y0,z0), ivec3(x1,y1,z1),seed,basisType);\n}\nfloat Basis(vec3 pos, int seed, int basis, int interp)\n{\n    float nx,ny,nz;\n    return basis_noise3D(pos, seed, interp, basis);\n}\nfloat White(vec3 xyz, uint seed)\n{\n    return Basis(xyz, int(seed), WHITE, NONE);\n}\n\n// ANL Fractals\n#define FBM 0\n#define RIDGEDMULTI 1\n#define BILLOW 2\n#define MULTI 3\n#define HYBRIDMULTI 4\n#define DECARPENTIERSWISS 5\nfloat Fractal(vec3 pos, int type, int octaves, float frequency, float lacunarity, float gain, float offset, float h)\n{\n    return 0.;\n}\n\n\nfloat graph(vec3 pos)\n{\n    //return Basis(pos * vec3( Basis(pos, 3, VALUE, QUINTIC)) *.02,1 , VALUE, QUINTIC) + ((White(pos,1u)-.5) *2.)*.1;\n    //return Basis(pos*.1*vec3(1,1,50), 0, GRADVAL, CUBIC)*0.2 + Basis(pos,0,WHITE,NONE)*1.0;\n    //return Basis(pos, 0, WHITE, NONE);\n    //return Basis(pos, 0, GRADVAL, CUBIC);\n    //return Basis(pos, 0, GRADIENT, NONE);\n    //return Basis(pos, 0, SIMPLEX, NONE);\n    //return Basis(pos*40.0*vec3(1,1,10), 0, VALUE, LINEAR);\n    return max(Basis(pos*.2*vec3(1,1,50), 0, VALUE, QUINTIC),Basis(pos*vec3(1,1,2), 0, SIMPLEX, NONE)) * .2 +Basis(pos,0,WHITE,NONE);\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    vec3 tl = vec3(time*0.00023);\n    vec3 tr = vec3(time*0.00014);\n    //return vec2( graph(tl) , graph(tr)) * 0.4;\n    return vec2(\n        sin(time*10.0)*1.0,\n        sin(time*10.0)*1.0\n        //rand(time*0.023))*0.2 + vec2(rand(time*10.0)*0.4 * graph(tl)\n        //rand(time*0.014))*0.2 + vec2(rand(time*8.0)*0.4 * graph(tr)\n\t);\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}