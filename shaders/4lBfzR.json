{
    "Shader": {
        "info": {
            "date": "1514129548",
            "description": "Christmas coding",
            "flags": 0,
            "hasliked": 0,
            "id": "4lBfzR",
            "likes": 8,
            "name": "Sierpinski_KIFS",
            "published": 3,
            "tags": [
                "fractal",
                "kifs",
                "sierpinski"
            ],
            "usePreview": 0,
            "username": "EvilRyu",
            "viewed": 848
        },
        "renderpass": [
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nfloat stime, ctime;\n void ry(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.x = c * q.x + s * q.z;  \n  \tp.z = -s * q.x + c * q.z; \n }  \n  \nfloat plane(vec3 p, float y) {\n    return length(vec3(p.x, y, p.z) - p);\n}\n\nvec3 mat=vec3(0.0);\nbool bcolor = false;\n\nfloat tetrahedron(vec3 p){\n\treturn (max(\n            \tmax( -p.x-p.y-p.z, p.x+p.y-p.z ), \n            \tmax( -p.x+p.y+p.z, p.x-p.y+p.z ) \n        \t\t)\n        \t-1.)/sqrt(3.0); \n}\n\n\nfloat sierpinski(in vec3 z){\n    float scale = 2.;\n\tfor (int n = 0; n < 5; n++) {\n\t\tif(z.x+z.y<0.){z.xy = -z.yx;}\n      \tif(z.x+z.z<0.){z.xz = -z.zx;}\n      \tif(z.y+z.z<0.){z.yz = -z.zy;}\n\t\tz = z*2.-1.+0.3*sin(iTime);\n       \tif(bcolor && n==2)mat+=vec3(0.3)+sin(z.xyz)*vec3(1.0, 0.24, 0.245);\n    }\n\t\n    return tetrahedron(z) * pow(2., -5.);\n}\n\n vec3 f(vec3 p){ \n\t ry(p, stime);\n     float d1 = plane(p, -1.4);\n     float d2 = sierpinski(p);\n     if(d1 < d2)\n     {\n         return vec3(d1, 0.0, 0.0);\n     }\n     else\n     {\n         return vec3(d2, 1.0, 0.0);\n     } \n } \n\n float ao(vec3 p, vec3 n){ \n \tfloat ao=0.0,sca=1.0; \n \tfor(float i=0.0;i<20.0;++i){ \n \t\tfloat hr=0.05+0.015*i*i; \n \t\tao+=(hr-f(n*hr+p).x)*sca; \n \t\tsca*=0.75; \n \t} \n \treturn 1.0-clamp(ao,0.0,1.0); \n } \n\n\nfloat rand(vec2 t){\n\treturn fract(sin(dot(t*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n vec3 nor(vec3 p){ \n \tvec3 e=vec3(0.001,0.0,0.0); \n \treturn normalize(vec3(f(p+e.xyy).x-f(p-e.xyy).x, \n \t\t\t\t\t\t  f(p+e.yxy).x-f(p-e.yxy).x, \n \t\t\t\t\t\t  f(p+e.yyx).x-f(p-e.yyx).x)); \n } \n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    vec3 res = vec3(-1.0);\n\tvec3 h = vec3(1.0);\n    for( int i=0; i<84; i++ )\n    {\n\t\tif( h.x<0.005 || t>30.0 ){\n\t\t}else {\n        \th = f(ro + rd*t);\n        \tres = vec3(t,h.yz);\n        \tt += abs(h.x);\n\t\t}\n    }\n\tif( t>30.0 ) res=vec3(-1.0);\n    return res;\n}\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n { \n    vec2 q=fragCoord.xy/iResolution.xy; \n \tvec2 uv = -1.0 + 2.0*q; \n \tuv.x*=iResolution.x/iResolution.y; \n\t// camera\n \tstime=sin(iTime*0.2); \n \tctime=cos(iTime*0.2); \n\n \tvec3 ta=vec3(.0,0.0,0.0); \n \t//vec3 ro=vec3(3.0*stime,stime*2.0+1.0, 3.0*ctime); \n\tvec3 ro = vec3(4, 4.+0.5*ctime, 9.+1.0*stime) * 0.5;\n\n \tvec3 cf = normalize(ta-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf)); \n \tvec3 rd = normalize(uv.x*cs + uv.y*cu + 2.8*cf);  // transform from view to world\n\n    vec3 sundir = normalize(vec3(-3.5, 7.0,2.8)); \n    vec3 light_col = vec3(1.5);\n\n\tvec3 bg = vec3(1.0);//exp(uv.y-1.0)*vec3(0.6, 0.9, 1.4)*1.3;\n\n    float sc=clamp(dot(sundir, rd), 0.0, 1.0); \n    vec3 col=bg+vec3(1.0,0.8,0.4)*pow(sc,50.0); \n\n\n    float t=0.0;\n    vec3 p=ro; \n\t \n\tvec3 res = intersect(ro, rd);\n\t if(res.x > 0.0){\n\t\t   p = ro + res.x * rd;\n           bcolor = true;\n           mat=vec3(0.0);\n           vec3 n=nor(p);\n           mat/=6.0;\n           bcolor = false;\n           float occ = ao(p, n); \n\n           float dif = max(0.0, dot(n, sundir)); \n           float sky = 0.6 + 0.4 * max(0.0, dot(n, vec3(0.0, 1.0, 0.0))); \n \t\t   float bac = max(0.3 + 0.7 * dot(vec3(-sundir.x, -1.0, -sundir.z), n), 0.0); \n           float spe = max(0.0, pow(clamp(dot(sundir, reflect(rd, n)), 0.0, 1.0), 10.0)); \n\n           vec3 lin = 4.5 * light_col * dif * occ; \n           lin += 0.8 * bac * light_col * occ; \n           lin += 0.6 * sky * light_col * occ; \n           lin += 3.0 * spe * occ; \n\n           col = lin *(vec3(1.)*(1.0-res.y)+mat*res.y) *  0.2; \n \t\t   col=mix(col,bg, 1.0-exp(-0.002*res.x*res.x)); \n    } \n\n    // post\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n    col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n    col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);  // satuation\n    col*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n\n \tfragColor.xyz = col; \n }",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}