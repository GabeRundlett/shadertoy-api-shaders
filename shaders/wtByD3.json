{
    "Shader": {
        "info": {
            "date": "1595518944",
            "description": "This is a demonstration of the Gram-Schmidt orthonormalization process.",
            "flags": 0,
            "hasliked": 0,
            "id": "wtByD3",
            "likes": 19,
            "name": "Gram-Schmidt orthonormalization ",
            "published": 3,
            "tags": [
                "linear",
                "maths",
                "orthonormal",
                "method"
            ],
            "usePreview": 1,
            "username": "jeyko",
            "viewed": 698
        },
        "renderpass": [
            {
                "code": "// This is a demonstration of the Gram-Schmidt orthonormalization process.\n// Feel free to just copy and use the gramSchmidt() function.\n\n// The purple vectors are the input, and the green ones are the output. \n\n// If you would like to play around with the positions and stuff - they are in the demoGramSchmidt() function.\n\n// Thanks to IQ for triangle and line intersections.\n\nvec3 project(vec3 a, vec3 b){\n\treturn dot(a,b)/dot(b,b)*(b);\n}\n\nvoid gramSchmidt(vec3 A, vec3 B, vec3 C, out vec3 Ao, out vec3 Bo, out vec3 Co ){\n    Ao = A;\n    \n    Bo = B - project(B,A);\n    \n    Co = C - project(C,Bo) - project(C,Ao);\n    \n    Ao = normalize(Ao);\n    Bo = normalize(Bo);\n    Co = normalize(Co);\n}\n\n\n\nvec3 ro, rd, N, glow = vec3(0);\nvec2 d;\nbool assertion = true;\n\nvec4[7] materials = vec4[](\n\tvec4(0.6,1.,0.4,1.),\n\tvec4(0.,.0,0.,1.),      // background\n\tvec4(0.1,0.2,0.4,0.9),  // guidelines\n\tvec4(0.,0.4,0.7,1.),    // diff A\n\tvec4(0.4,0.,0.2,0.8),\n\tvec4(0.,1.,0.,0.6),\n\tvec4(0.5,0.,1.,1.)   \t// diff B\n);\n\nvoid assert(bool);\nvec2 dmin(vec2 , float , vec4 );\nvec2 dmax(vec2 , float , vec4 );\n\n\n\nvoid demoGramSchmidt(vec3 ro, vec3 rd){\n\t\n    vec3 A = vec3(-0.4,0.6,-0.4);\n    vec3 B = vec3(-0.7,0.3,0.1);\n    vec3 C = vec3(-0.4,-0.2,-0.7);\n    \n    \n    A = normalize(A)*0.5;\n    B = normalize(B)*0.5;\n    C = normalize(C)*0.5;\n    \n    \n    float t = iTime*0.5; \n    B += vec3(sin(t),cos(t),sin(t))*0.2;\n    C += vec3(cos(t),sin(t),sin(t))*0.2;\n    A.xz *= rot(sin(t)*0.2);\n    \n    vec3 Ao, Bo, Co;\n    \n\tgramSchmidt( A, B, C, Ao, Bo, Co );\n\t\n    assert(abs(dot(Ao,Bo)) < 0.001);\n    assert(abs(dot(Co,Bo)) < 0.001);\n    assert(abs(dot(Bo,Co)) < 0.001);\n    assert(abs(dot(Ao,Co)) < 0.001);\n    \n    \n    float r = 0.02;\n    \n    vec4 sphere = intersectSphere(ro, rd, r,1.);\n    \n    d = dmin(d,3.,sphere);\n    \n    d = dmin(d,6.,intersectSphere(ro - A, rd, r,1.));\n    d = dmin(d,6.,intersectSphere(ro - B, rd, r,1.));\n    d = dmin(d,6.,intersectSphere(ro - C, rd, r,1.));\n    \n    d = dmin(d,5.,intersectSphere(ro - Ao, rd, r,1.));\n    d = dmin(d,5.,intersectSphere(ro - Bo, rd, r,1.));\n    d = dmin(d,5.,intersectSphere(ro - Co, rd, r,1.));\n    \n    \n    d = dmin(d,6.,intersectLine( ro, rd,vec3(0),A, r*0.3));\n    d = dmin(d,6.,intersectLine( ro, rd,vec3(0),B, r*0.3));\n    d = dmin(d,6.,intersectLine( ro, rd,vec3(0),C, r*0.3));\n    \n    d = dmin(d,5.,intersectLine( ro, rd,vec3(0),Ao, r*0.5));\n    d = dmin(d,5.,intersectLine( ro, rd,vec3(0),Bo, r*0.5));\n    d = dmin(d,5.,intersectLine( ro, rd,vec3(0),Co, r*0.5));\n    \n    d = dmin(d,4.,intersectTri( ro, rd, Bo, vec3(0), Ao ));\n    d = dmin(d,4.,intersectTri( ro, rd, Co, vec3(0), Ao ));\n    d = dmin(d,4.,intersectTri( ro, rd, Co, vec3(0), Bo ));\n}\n\n\n\n\nvec3 shade( float id, float d, vec3 n){\n\tvec3 col = vec3(0);\n\t\n    vec4 m = materials[int(id)];\n    \n    vec3 p = ro + rd*d;\n    \n    if( id == 2.){\n    \t\n        float ld = 10e4;\n        \n        vec3 q = p;\n        \n        q = pmod(q,0.5);\n\t\t\n        float eps = 0.01;\n       \tif(abs(p.y) < eps){\n            ld = min(ld,abs(q.x));\n            ld = min(ld,abs(q.z));\n        } else if(abs(p.x) < eps){ \n            ld = min(ld,abs(q.y));\n            ld = min(ld,abs(q.z));\n        } else if(abs(p.z) < eps){ \n            ld = min(ld,abs(q.y));\n            ld = min(ld,abs(q.x));\n        }\n        \n        \n        col = mix(col,vec3(0.2),smoothstep(0.01,0.,ld ));\n        \n        \n        col *= smoothstep(1.,0.,d*0.16);\n        \n    } else {\n    \tvec3 l = normalize(vec3(1,0.25,-1.));\n\n        vec3 lcol = vec3(1,0.8,0.3);\n\n        col = m.xyz + n*0.2;\n\n        float diff = sin( dot(n,l) );\n        diff += mix(length(asin(sin(n*1.)*.9)*0.5+0.5)/sqrt(3.),0.,.0)*0.1; // um ok blackle thx, I have no clue what this is tho lol\n        float fres = pow(max( 1. - dot(n,-rd), 0.001), 5.);  \n\n        vec3 r = reflect(rd,n);\n\n        float spec1 = length(asin(sin(r*4.)*.9)*0.5+0.5)/sqrt(3.);\n\n        \n        vec3 hsv = rgb2hsv(col);\n\n        vec3 darkened = hsv2rgb(vec3(hsv.x,hsv.y*2.,hsv.z*0.6));\n\n        col += spec1*0.7*lcol;\n        col = mix(col,darkened,1.-diff);;\n\t\tcol = max(col,0.);\n        col *= m.w;\n    }\n    \n    \n    return col;\n}\n\n\n\n\n\nvec3 get( vec2 U ){\n\t\n    glow -= glow;\n    vec2 uv = (U - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    d = vec2(10e4);\n    \n    ro = vec3(0);\n    \n    float xz = sin(T*0.4)*0.4 - iMouse.x/iResolution.x*2. + 5. ;\n    float y = sin(iTime)*0.25 + iMouse.y/iResolution.x*4. + 0.4;\n    ro.xz += vec2(sin(xz), cos(xz))*3.;\n    ro.y += y + 1.;\n    \n    ro *= 0.7;\n    \n    vec3 lookAt = vec3(0);\n    \n    rd = getRd(ro, lookAt, uv);\n    \n    \n    \n    float pipew = 0.01;\n\t\n    // background\n    d = dmin(d,1.,intersectSphere(ro, rd, 25.2,0.)); \n\n    \n    // guidelines\n    d = dmin(d,3.,intersectLine( ro, rd,vec3(0,0,-6),vec3(0,0,1150), pipew));\n    d = dmin(d,3.,intersectLine( ro, rd,vec3(-6,0,0),vec3(1150,0,0), pipew));\n    d = dmin(d,3.,intersectLine( ro, rd,vec3(0,-10,0),vec3(0,150,0), pipew));\n    \n    // guideplanes\n    d = dmin(d,2.,intersectPlane(ro, rd, vec3(0.,-1,0.)));\n    d = dmin(d,2.,intersectPlane(ro, rd, vec3(1.,0.,0.)));\n    d = dmin(d,2.,intersectPlane(ro, rd, vec3(0.,0,1.)));\n    \n    \n\n\tdemoGramSchmidt( ro, rd);\n    \t \n    \n    vec3 p = ro + rd*d.x;\n    \n   \n    col += shade( d.y, d.x, N);\n    \n    \n    col += glow;\n    \n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = (U - 0.5*R)/R.y;\n    vec3 col = vec3(0);\n    for(float i =0.; i < AA*AA + min(float(iFrame),0.)   ; i++){\n    \tcol += get(U + vec2(mod(i,AA),floor(i/AA))/AA - .5);\n    }\n    col /= AA*AA;\n    \n    \n    if(!assertion){\n        col = mix(col,vec3(1,0.,0),smoothstep(dFdy(uv.y),0.,sdBox(uv - 0.5,vec2(0.1))));\n    }\n    \n    col = max(col, 0.);\n    C.xyz = pow(col.xyz,vec3(0.454545));\n        \n    C = vec4(col,1.0);\n}\n\n\nvec2 dmin(vec2 a, float id, vec4 b ){\n\tvec4 m = materials[int(id)];\n    if (a.x < b.x ||  b.x == NO_INTERSECTION){\n    \treturn a;\n    } else if (  m.w < 1. ){\n\t\tglow += shade(id,b.x,b.yzw);\n        return a;\n    } else {\n        N = b.yzw;\n        return vec2(b.x,id);\n    }\n    \n}\nvoid assert(bool thing){\n\tif(!thing)\n        assertion = false;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define R iResolution.xy\n#define T iTime\n#define AA 4.\n#define NO_INTERSECTION -1.\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n#define pmod(p,j) mod(p - 0.5*j, j) - 0.5*j\n\n// _________________________________________ //\n\nvec3 solveQuadratic(float a, float b, float c);\n\nvec4 intersectPlane(vec3 ro, vec3 rd, vec3 n);\nvec4 intersectLine( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, float ra );\nvec2 intersectCylinder( vec3 ro, vec3 rd, vec3 cb, vec3 ca, float cr );\nvec4 intersectSphere(vec3 ro, vec3 rd, float r, float first);\nvec4 intersectTri( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 );\n\nfloat sdBox(vec2 p, vec2 s);\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv);\n\nvec3 hsv2rgb( in vec3 c );\nvec3 rgb2hsv( in vec3 c);\n\n// _________________________________________ //\n\n\nvec4 intersectPlane(vec3 ro, vec3 rd, vec3 n){\n    n = normalize(n);\n    //dot(n, ro + rd*t) = 0;\n    //(ro.x + rd.x*t)*n.x + (ro.y + rd.y*t)*n.y + (ro.z + rd.z*t)*n.z = 0\n    //ro.x*n.x + rd.x*t*n.x + ro.y*n.y + rd.y*t*n.y + ro.z*n.z + rd.z*t*n.z = 0\n    // t  = - (ro.x*n.x +  ro.y*n.y  + ro.z*n.z)/( rd.x*n.x + rd.y*n.y + rd.z*n.z ) \n    //return vec4(-(dot(ro,n))/dot(rd,n), n);\n    \n    float dron = dot(ro, n); \n    if(dron > 0.){\n    \tro -= n * dron*2.;\n    \trd = -rd;\n    }\n    \n    float nominator = dot(ro,n); \n        \n    float denominator = dot(rd,n);\n        \n    if (denominator > 1e-9) { \n        return vec4( -nominator / denominator, n); \n    \n    } else {\n    \treturn vec4(NO_INTERSECTION);\n    }\n}\n\n\nvec3 solveQuadratic(float a, float b, float c){\n\t// returns vec3(xa,xb,solutions)\n\t\n    float disc = b*b - 4.*a*c;\n\n    float xa = (-b + sqrt(disc)) / (2. * a);\n\n    float xb = (-b - sqrt(disc)) / (2. * a);\n\n    if(disc >= 0.){\n        return vec3(xa,xb,2);\n    } else {\n        return vec3(0);\n    }    \n}\n\nvec4 intersectLine( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, float ra )\n{\n    vec3 ca = pb-pa;\n    vec3 oc = ro-pa;\n    float caca = dot(ca,ca);\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = caca - card*card;\n    float b = caca*dot( oc, rd) - caoc*card;\n    float c = caca*dot( oc, oc) - caoc*caoc - ra*ra*caca;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec4(NO_INTERSECTION); //no intersection\n    h = sqrt(h);\n    float t = (-b-h)/a;\n    // body\n    float y = caoc + t*card;\n    if( y>0.0 && y<caca ) return vec4( t, (oc+t*rd-ca*y/caca)/ra );\n    // caps\n    t = (((y<0.0)?0.0:caca) - caoc)/card;\n    if( abs(b+a*t)<h ) return vec4( t, ca*sign(y)/caca );\n    return vec4(NO_INTERSECTION); //no intersection\n}\n\nvec2 intersectCylinder( vec3 ro, vec3 rd, vec3 cb, vec3 ca, float cr )\n{\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0. ) return vec2(NO_INTERSECTION); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n\nvec4 intersectSphere(vec3 ro, vec3 rd, float r, float first){\n\t// x^2 + y^2 = r\n    \n    // (ro.x + rd.x*w)^2 + (ro.y + rd.y*w)^2 + (ro.z + rd.z*w)^2 = r  \n    // F = ro.x\n    // G = ro.y\n    // H = ro.z\n    // F*F + 2*F*rd.x*w + (rd.x*w)^2 + G*G + 2*G*rd.y*w + (rd.y*w)^2 = r  \n    // w^2(rd.x^2 + rd.y^2 + rd.z^2 ) + w(2*F*rd.x + 2*G*rd.y + 2*H*rd.z) + (F*F + G*G + H*H - r) = 0\n\n    \n    float F = ro.x;\n    float G = ro.y;\n    float H = ro.z;\n    \n    float a = rd.x*rd.x + rd.y*rd.y + rd.z*rd.z;\n    float b = 2.*F*rd.x + 2.*G*rd.y + 2.*H*rd.z;\n    float c = F*F + G*G + H*H - r*r;\n    \n    \n    vec3 Q = solveQuadratic(a, b, c);\n    \n    vec3 p;\n    \n    \n    float d; \n    \n    if( length(ro) < r){\n        d = Q.x;\n    } else {\n        d = min(Q.x,Q.y);\n    }\n    vec3 n = normalize( (ro + rd*d) );\n    \n    if(Q.z > 0.){\n\t\t\n        return vec4( d , n );\n        \n    } else {\n    \treturn vec4(NO_INTERSECTION);\n    }\n}\n\nvec4 intersectTri( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n    if( u<0.0 || u>1.0 || v<0.0 || (u+v)>1.0 ) t = NO_INTERSECTION;\n    \n    vec3 normal = normalize(cross(v0 - v1, v2 - v1));\n    return vec4( t, normal );\n}\n\n\nfloat sdBox(vec2 p, vec2 s){\n\tp = abs(p) - s;\n    return max(p.x,p.y);  \n}\n\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir, right));\n\treturn normalize(dir + right*uv.x + up*uv.y);\n}\n\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 rgb2hsv( in vec3 c)\n{\n    float eps = 0.01;\n    vec4 k = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.zy, k.wz), vec4(c.yz, k.xy), (c.z<c.y) ? 1.0 : 0.0);\n    vec4 q = mix(vec4(p.xyw, c.x), vec4(c.x, p.yzx), (p.x<c.x) ? 1.0 : 0.0);\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0*d+eps)), d / (q.x+eps), q.x);\n}\n\n    \n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}