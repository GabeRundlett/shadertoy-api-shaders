{
    "Shader": {
        "info": {
            "date": "1573179229",
            "description": " ",
            "flags": 0,
            "hasliked": 0,
            "id": "3dGSzR",
            "likes": 4,
            "name": "A trip to the void",
            "published": 3,
            "tags": [
                "raymarching",
                "psychadelic"
            ],
            "usePreview": 0,
            "username": "wessles",
            "viewed": 793
        },
        "renderpass": [
            {
                "code": "// ##########################\n// ### A trip to the void ###\n// ##########################\n//\n// As the name implies, this is a trippy demo I made messing\n// with raymarching. This code could be way more optimized.\n//\n// IF you want to know how it works, just mess with the flags\n// below and read the program.\n//\n// ----\n// 1.\n//   This is a lattice of spheres we are moving through\n// 2.\n//   I apply a hue shift based on how far the ray march goes\n// 3.\n//   I ray march, but each iteration i rotate the ray direction slightly\n//   the extent of this rotation is a sine function over time\n// 4.\n//   I mess with the FOV with a tan(mod(x, 3.14/2.)) function that makes\n//   the zoomy looking effect.\n\n\n#define CAM_ROTATE\n#define RAY_ROTATE\n#define WHACK_FOV\n#define WHACK_COLOR\n\n#define ITER 100\n#define BASE_FOV 2.0\n\n// distance function\n// returns distance from point p to nearest sphere\n// in infinite lattice\nfloat dist(vec3 p) {\n    p = fract(p) * 2.0 - 1.0;\n    return length(p) - (0.8);\n}\n\n// ray marching algorithm, with a modification:\n// if the RAY_ROTATE flag is defined, we can\n// rotate the ray's direction after each iteration.\n// *this is the primary source of \"whack\" in this shader*\nfloat march(vec3 o, vec3 r) {\n    float t = 0.0;\n    vec3 p = o;\n    for(int i = 0; i < ITER; i++) {\n        #ifdef RAY_ROTATE\n        float the = 0.04*sin(iTime/2.);\n        r.xy *= mat2(cos(the),-sin(the),sin(the),cos(the));\n        #endif\n        p = o+r*t;\n        t += dist(p)*0.5;\n    }\n    return t;\n}\n\n// hue2rgb function I ripped off.\n#ifndef saturate\n#define saturate(v) clamp(v,0.,1.)\n#endif\nvec3 hue2rgb(float hue){\n\thue=fract(hue);\n\treturn saturate(vec3(\n\t\tabs(hue*6.-3.)-1.,\n\t\t2.-abs(hue*6.-2.),\n\t\t2.-abs(hue*6.-4.)\n\t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = uv*2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // this technically isn't FOV, it's the initial distance\n    // the ray is pushed outwards into the z axis before being\n    // normalized and marched.\n    // 0 values of X mean 180 degrees, infinite means 0 degrees.\n    float x = 1.0;\n    #ifdef WHACK_FOV\n    x = 0.1*tan(mod(iTime/10., 3.14/2.));\n    #endif\n    \n    // raycast with optional camera rotation\n    vec3 ray;\n    ray = normalize(vec3(uv,BASE_FOV*x));\n    float the = iTime/2.;\n    #ifdef CAM_ROTATE\n    ray.xy *= mat2(cos(the),-sin(the),sin(the),cos(the));\n    #endif\n    \n    vec3 origin = vec3(0,0,iTime);\n    \n    float t = march(origin, ray);\n    \n    float fog = 1.0 / (1.0 + t*t*0.1);\n    \n    vec3 col = vec3(fog);\n    \n    // psychedelics ensue\n    #ifdef WHACK_COLOR\n    col*=hue2rgb(t*2.);\n    #endif\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}