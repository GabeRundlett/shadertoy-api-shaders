{
    "Shader": {
        "info": {
            "date": "1593930513",
            "description": "3D version of https://shadertoy.com/view/wtjyRW\ncamera in Z=0 plane. blue dots = box/plane intersections.\nGives closest positive ray-box intersection. Comment #44 for just that. Default =  BBox mode: d=0 inside.\nClick + drag mouse to chose ray start + dir",
            "flags": 16,
            "hasliked": 0,
            "id": "WtScRm",
            "likes": 14,
            "name": "box nearest intersection 3D ",
            "published": 3,
            "tags": [
                "raytracing",
                "intersection",
                "mm",
                "bbox"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 686
        },
        "renderpass": [
            {
                "code": "// 3D version of \"box nearest intersection\"  https://shadertoy.com/view/wtjyRW\n\n#define CALCOUTPOINT 1   // 0 to trim (most of) the code for out point\n#define showOut ( CALCOUTPOINT > 0 && texelFetch(iChannel3,ivec2(32,2),0).x <= 0.)\n\n\nvec3  P = vec3(1.1, .3, -.2),                    // bounding box at P, axis X0,X1,X2\n     X0 = vec3(.3,0,0), X1 = vec3(0,.5,0) , X2 = vec3(0,0,.4);\nfloat a0 = 0.2, a1 = 0.3, a2 = 0.5;              // Bbox rotation\n#define rot(a) mat2(cos(a+vec4(0,-1.5708,1.5708,0)));\n#define rotBBox()                                           \\\n    X0.yz *= rot(a0); X1.yz *= rot(a0); X2.yz *= rot(a0);   \\\n    X0.xz *= rot(a1); X1.xz *= rot(a1); X2.xz *= rot(a1);   \\\n    X0.xy *= rot(a2); X1.xy *= rot(a2); X2.xy *= rot(a2);\n\n  #define proj(P) ( (P).xy )                      // flat projection\n//#define proj(P) ( 1.5* (P).xy / (2.+(P).z) )    // perspective projection\n\n#define S(d) smoothstep( 1.5/R.y, 0., d )     // --- draw antialiased\nfloat line(vec2 p, vec3 A,vec3 B, out vec3 Z0) {      // --- segment with disc ends: seamless distance to segment\n    float l = -A.z/(B-A).z;                           // hack: also show intersection with z=0.\n    Z0 = l>=0. && l<=1. ? mix(A,B,l) : vec3(0);\n    vec2 a = proj(A), b = proj(B);                    // 3D projection\n    p -= a, b -= a;                                   // --- classical 2D draw part\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n    return length(p - b * h);                         // dist to segment\n}\nvec3 z; float _d;\n#define line(u,a,b) ( _d = line(u,a,b,z), vec4(_d,z) )// hack to carry the z=0 plane information\n#define Min(v0,v1)  ( v0.x < v1.x ? v0 : v1 ) \n\n#define spot(P)    S( length( proj(P) - U ) -.01 )    // draw dot\n\n\n// --- v2. maybe a bit cheaper\nfloat intersect(vec3 C, vec3 D) {                     // --- camera, direction. Return closest hit or -1\n    // you probably want to precompute these 2 : \n    vec3  L = vec3(length(X0), length(X1), length(X2) ), I; // box radii \n    mat3  F = mat3( X0/dot(X0,X0), X1/dot(X1,X1), X2/dot(X2,X2) );   // orthogonal normalized box frame\n    float d = 1e5, l;  _d=d;\n    \n    C = (C-P) * F;    D *= F;                         // to normalized coordinates in box frame\n    I = abs(C-.5); bool inside = max(I.x, max(I.y,I.z)) <= .5;\n    if ( inside && !showOut ) return 0.; // if inside the Bbox. Comment for box intersection\n    \n    // C+lD = 0|1 -> l = ( 0|1 - C ) / D    We want smallest positive l\n\n    // --- global _d stores the out point (attention, also used in line() ).\n#define test(i)                                                           \\\n    /* first, get the nearest positive per direction */                   \\\n    l =  D[i] > 0. ?  C[i] < 0. ? -C[i]   : C[i] < 1. ? 1.-C[i] : -1.     \\\n                   :  C[i] > 1. ? 1.-C[i] : C[i] > 0. ? -C[i]   :  1.;    \\\n    l /= D[i];                                                            \\\n    /* second, takes the min l>0 such that C+lD fits is inside the box */ \\\n    I = C+l*D;                                                            \\\n    if ( l > 0. && l < d                                                  \\\n         && I[(i+1)%3] >= 0. && I[(i+1)%3] <= 1.                          \\\n         && I[(i+2)%3] >= 0. && I[(i+2)%3] <= 1.                          \\\n       )  d = l\n        \n    test(0); // test in each directions\n    test(1);\n    test(2);\n#if CALCOUTPOINT                // delete if not interested in out point\n    if (showOut) {\n#define testO(i)                                                          \\\n    /* first, get the nearest positive per direction */                   \\\n    l =  D[i] > 0. ?  C[i] < 1. ? 1.-C[i] : -1.                           \\\n                   :  C[i] > 0. ? -C[i]   :  1.;                          \\\n    l /= D[i];                                                            \\\n    /* second, takes the min l>0 such that C+lD fits is inside the box */ \\\n    I = C+l*D;                                                            \\\n    if ( l > 0.   && l < _d                                               \\\n         && I[(i+1)%3] >= 0. && I[(i+1)%3] <= 1.                          \\\n         && I[(i+2)%3] >= 0. && I[(i+2)%3] <= 1.                          \\\n       ) _d = l\n        \n    testO(0); // test in each directions\n    testO(1);\n    testO(2);\n    }\n    if (inside) _d = d, d = 0.;\n#endif\n    return d==1e5 ? -1. : d;  // global _d contains the out point\n}\n\n/* // --- first version ( costlier ? )\nfloat intersect(vec2 C, vec2 D) {                     // --- camera, direction. Return closest hit or -1\n    // you probably want to precompute these 2 : \n    vec2  L = vec2(length(X0), length(X1) /* , length(X2) * / ), I; // box radii \n    mat2  F = mat2( X0/L.x, X1/L.y /* , X2/L.z * / ); // orthogonal unitary box frame\n    float d = 1e5, l;\n    \n    C = (C-P) * F;    D *= F;                         // to box frame\n    // C+lD = 0|L -> l = ( 0|L - C ) / D    We want smallest positive l\n\n#define test(i)                                                                \\\n    /* first, get the nearest positive per direction * /                        \\\n    l =  D[i] > 0. ?  C[i] < 0.   ? -C[i]     : C[i] < L[i] ? L[i]-C[i] : -1.  \\\n                   :  C[i] > L[i] ? L[i]-C[i] : C[i] > 0.   ? -C[i]     :  1.; \\\n    l /= D[i];                                                                 \\\n    /* second, takes the min l>0 such that C+lD fits is inside the box * /      \\\n    I = C+l*D;                                                                 \\\n    if ( l > 0. &&  l < d                                                      \\\n         && I[(i+1)%2] >= 0. && I[(i+1)%2] <= L[(i+1)%2]                       \\\n                /*  ^     3 in 3D       ^             ^   * /                   \\\n      /* && I[(i+2)%3] >= 0. && I[(i+2)%3] <= L[(i+2)%3] * /                    \\\n       ) d = l\n        \n    test(0); // test in each directions\n    test(1);\n // test(2);\n    return d==1e5 ? -1. : d;\n}\n*/\n    \nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = u/R.y,\n         M1 = iMouse.xy/R.y,\n         M0 = iMouse.zw/R.y, \n         D2 = normalize(M1-M0);\n    if (M1==vec2(0)) M1 = vec2(.4);\n    if (M0.x<=0.) M0 = M1, D2 = cos(iTime+vec2(0,11)), M1=M0+.2*D2;   \n    \n    vec3 C = vec3(M0,0), D = normalize(vec3(D2,0));          // setup camera\n    rotBBox();                                               // setup Bbox\n    \n    vec4 d ,bg; d.x = 1e5;\n    vec3 p = P;\n    d = Min ( Min ( line(U,p,p+X0),  line(U,p+X0,p+X0+X1) ), // draw box\n              Min ( line(U,p,p+X1),  line(U,p+X1,p+X0+X1) ) \n            );\n    p += X2;\n    d = Min( d,\n       (bg = Min ( Min ( line(U,p,p+X0),  line(U,p+X0,p+X0+X1) ),\n                   Min ( line(U,p,p+X1),  line(U,p+X1,p+X0+X1) ) \n          )      ));\n    p = P;\n    d = Min( d,\n             Min ( Min ( line(U,p+X0,p+X0+X2),  line(U,p,p+X2) ),\n                   Min ( line(U,p+X1,p+X1+X2),  line(U,p+X0+X1,p+X0+X1+X2) ) \n          )      );\n    O = vec4( S(d.x) ) * (d==bg?.5:1.);                      // draw the line\n    if (length(d.yzw)!=0.) O.b +=  spot( d.yzw );            // blue spot at intersection with Z=0 plane\n  \n    O.r += spot(C);\n    O.r += S( line(U, C, C+9.*D).x );                        // draw cam\n    \n    float l = intersect( C, D );                             // shortest distance or -1.\n    if (l>=0.) \n        O.g += spot( C + l*D );                              // draw hit point ( if exist )\n    if (showOut && _d<1e5)\n        O.g += .5*spot( C + _d*D );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}