{
    "Shader": {
        "info": {
            "date": "1578514331",
            "description": "A shadertoy port of my Graphics entry at MAGFest Demoparty 2020. Placed 1st out of 3 entries.\n\nDownload the original executable version here: [url]https://www.pouet.net/prod.php?which=84472[/url]",
            "flags": 32,
            "hasliked": 0,
            "id": "tty3Rm",
            "likes": 27,
            "name": "Forbidden Path",
            "published": 3,
            "tags": [
                "pathtracer",
                "magfest"
            ],
            "usePreview": 0,
            "username": "yx",
            "viewed": 1250
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    vec4 tex = texture(iChannel0,uv);\n    \n    // divide by sample-count\n\tvec3 color = tex.rgb/tex.a;\n    \n    // vignette to darken the corners\n\tuv-=.5;\n\tcolor *= 1.-dot(uv,uv)*2.;\n    \n    // tonemap\n    color *= 10.;\n    color /= color+1.;\n    \n    // gamma correction\n\tcolor = pow(color, vec3(.45));\n    \n    // make it pop\n\tcolor = smoothstep(0.,1.,color);\n\t\n    // warm tint\n    color = pow(color,vec3(1,1.05,1.1));\n    \n    // lift the black level\n    color += .02;\n    \n\tfragColor = vec4(color,1);\n}\n\n/*\n         \"Forbidden Path\"\n          by yx/Polarity\n\n      2kb executable graphics\n released at MAGFest Demoparty 2020\n\n     greetings from england <3\n*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define pi (acos(-1.))\n\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec2 hash2( const float n ) {\n\treturn fract(sin(vec2(n,n+1.))*vec2(43758.5453123));\n}\n\nint m;\n\n// distance function\nfloat scenediff(vec3 p)\n{\n    float d = 1e9;\n    \n    float tunnel = length(p.yx)-1.5;\n    d=-tunnel;\n    \n    // ridges\n    {\n        vec3 q=p;\n    \tq.z=mod(q.z,.4)-.2;\n    \td=min(d,sdTorus(q.xzy,vec2(1.51,.02)));\n    }\n    \n    // floor\n    float ground = p.y+1.;\n    d=min(d,ground);\n    \n    // tiles\n    {\n        vec3 q=p;\n        q.y+=.998;\n        q.xz=rotate(q.xz,-pi*.25);\n        q.xz=mod(q.xz,.1)-.05;\n        d=max(d,.005-length(q.yx));\n        d=max(d,.005-length(q.yz));\n    }\n    \n    return d;\n}\n\nfloat scenelite(vec3 p)\n{\n    float d=1e9;\n    \n    // lamps\n    {\n        vec3 q=p;\n        q.x=abs(q.x);\n        q.xy+=vec2(-1.1,1);\n        d=min(d,max(\n            length(q.yx)-.05,\n            abs(mod(q.z-1.,2.)-1.)-.01\n        ));\n        \n        // minus lamps at grill\n        d=max(d,1.-abs(p.z));\n    }\n    \n    //lasers\n    {\n        vec3 q=p;\n        q.xy=rotate(q.xy,-pi*.25);\n        d = min(d,max(\n            abs(q.z)-.1,\n            abs(mod(q.y,.2)-.1)-.01\n        ));\n    }\n    \n    return d;\n}\n\nfloat scene(vec3 p)\n{\n    float diff=scenediff(p);\n    float lite=scenelite(p);\n    m=(lite<diff)?1:0;\n    return min(lite,diff);\n}\n\n// ray bouncing function \"borrowed\" from I can't remember where\nvec2 rv2;\nvec3 B(vec3 n) {\n    float theta = 2. * pi * rv2.x;\n    float phi = acos(1. - 2. * rv2.y);\n    float x = sin(phi) * cos(theta);\n    float y = sin(phi) * sin(theta);\n    float z = cos(phi);\n    \n    vec3 a = normalize(vec3(x,y,z));\n    return dot(a,n)<0.?-a:a;\n}\n\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n    vec3 accum = vec3(1);\n    for(int bounce=0;bounce<4;++bounce)\n    {\n        float t=0.;\n        float k;\n        for(int i=0;i<100;++i)\n        {\n            k = scene(cam+dir*t);\n            t += k;\n            if (abs(k) < .001)\n                break;\n        }\n        \n\t\tvec3 h = cam+dir*t;\n\t\t\t\n        // if we hit something\n        if(abs(k)<.001)\n        {\n            if (m==1){\n                if (abs(h.z)<0.2){\n                    // red laser grill\n                \treturn vec3(1,0.15,0.15) * accum;\n                }else{\n                    // gold orbs\n                    return vec3(5,2,.5) * accum;\n                }\n            }\n            \n\t\t\tvec2 o = vec2(.001, 0);\n\t\t\tk=scene(h);\n\t\t\tvec3 n = normalize(vec3(\n\t\t\t\tscene(h+o.xyy) - k,\n\t\t\t\tscene(h+o.yxy) - k,\n\t\t\t\tscene(h+o.yyx) - k \n\t\t\t));\n\n            float roughness = .85;\n            if (h.y<=-.999) {\n                if (rv2.x<.95){\n                \taccum *= 0.125;\n                \troughness = .01;\n                }\n            }\n            \n            cam = h+n*.001;\n            vec3 mirror = reflect(dir,n);\n            vec3 bounce = B(n);\n            dir= normalize(mix(mirror,bounce,roughness));\n            accum *= mix(1.,dot(dir,n),roughness);\n        }\n    }\n    \n    return vec3(0);\n}\n\nvec2 bokeh(){\n\tvec2 a=rv2;\n    if(a.y>a.x)\n        a=1.-a;\n    a.y*=pi*2./a.x;\n    return a.x*vec2(cos(a.y),sin(a.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // recover previous frame for iterative rendering\n   \tfragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\t\n    \n    // get UVs\n    vec2 uv = fragCoord.xy/iResolution.xy-.5;\n    \n    // deliberately don't seed per-pixel\n    float seed = iTime;\n\trv2 = hash2(seed);\n    \n    // jitter for antialiasing\n    uv += (rv2-.5)/iResolution.xy;\n    \n    // correct UVs for aspect ratio\n    uv.x*=iResolution.x/iResolution.y;\n\n    // careful seeding for blocky effect\n    float blockSize=exp2(clamp(floor(length(uv)*9.),2.,9.));\n    seed+=mod(floor(fragCoord.x/blockSize)+.01,1.34672);\n    seed+=mod(floor(fragCoord.y/blockSize)+.01,1.72357);\n    rv2=hash2(seed);\n\t\n    // make a camera\n    vec3 cam = vec3(0,0,-8.);\n    vec3 dir = normalize(vec3(uv,1));\n    \n    // slight bokeh\n    float ds=.005;\n    vec2 bokehJitter=bokeh();\n    cam.xy+=bokehJitter*ds;\n    dir.xy-=bokehJitter*ds*dir.z/8.;\n\n    // move the camera some more\n    cam.y -=.25;\n    dir.yz = rotate(dir.yz, .06);\n    \n    // compute the pixel color\n\tvec4 pixel = vec4(trace(cam,dir),1);\n    \n    // cap the sample-count\n    if (iFrame < 512)\n\t\tfragColor += pixel;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}