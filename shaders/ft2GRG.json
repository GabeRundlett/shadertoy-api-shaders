{
    "Shader": {
        "info": {
            "date": "1652271637",
            "description": "Taking something I've been messin with a little further.. ",
            "flags": 32,
            "hasliked": 0,
            "id": "ft2GRG",
            "likes": 27,
            "name": "Input Error",
            "published": 3,
            "tags": [
                "truchetcubemapdemo"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 401
        },
        "renderpass": [
            {
                "code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    [Input Error] 5/11/22\n    created with love by your friendly @byt3_m3chanic\n\n*/\n\n#define PI  3.14159265359\n\nvec2 curvature = vec2(15.);\nvec2 remapUV(vec2 uv) {\n    uv = uv * 2. -1.;\n    vec2 offset = abs(uv.yx) / vec2(curvature.x, curvature.y);\n    uv = uv + uv * offset * offset;\n    uv = uv * .5 + .5;\n    return uv;\n}\n\nvec4 scanLine(float uv, float resolution, float opacity) {\n     float intensity = sin(uv * resolution * PI * 2.);\n     intensity = ((.5 * intensity) + .5) * .9 + .1;\n     return vec4(vec3(pow(intensity, opacity)), 1.);\n}\n\nvec4 vignette(vec2 uv, vec2 resolution, float opacity) {\n    float intensity = uv.x * uv.y * (1. - uv.x) * (1. - uv.y);\n    return vec4(vec3(clamp(pow((resolution.x / 4.) * intensity, opacity), 0.0, 1.)), 1.);\n}\n\nvec2 scanLineOpacity = vec2(.35);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {  \n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    uv=(uv*1.05)-vec2(.025,.025);\n    vec2 vuv = remapUV(uv);\n    \n    vec4 baseColor = texture(iChannel0, vuv);\n\n    baseColor *= vignette(vuv, iResolution.xy, .75);\n    baseColor *= scanLine(vuv.x, iResolution.y*.85, scanLineOpacity.x);\n    baseColor *= scanLine(vuv.y, iResolution.x*.85, scanLineOpacity.y);\n\n    if (vuv.x < 0.0 || vuv.y < 0.0 || vuv.x > 1.0 || vuv.y > 1.0){\n        baseColor = vec4(vec3(.0),0);\n    }\n   \n    fragColor = baseColor;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    [Input Error] 5/11/22\n    created with love by your friendly @byt3_m3chanic\n\n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    100.\n#define MIN_DIST    .001\n\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n// @gaz\nfloat zag(vec3 p, float s) {\n    p = abs(p)-s;\n    if (p.x < p.z) p.xz = p.zx;\n    if (p.y < p.z) p.yz = p.zy;\n    if (p.x < p.y) p.xy = p.yx;\n    return dot(p,normalize(vec3(s*1.,s,1.5)))-.15;\n    //return dot(p,normalize(vec3(s*.45,s,.0)));\n}\n//@iq\nfloat box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),.0);\n}\n\nvec3 hit=vec3(0),hitPoint=vec3(0);\nfloat mtime = 0.,time = 0.,glow = 0.;\nmat2 turn,r90,r45;\n\nvec2 map(vec3 pos, float sg)\n{\n    vec2 res = vec2(1e5,0.);\n    vec3 dp = pos-vec3(0,1.25,1);\n    \n    dp.yx*=turn;\n    dp.zx*=turn;\n\n    float d1 = box(dp,vec3(1.75));//\n    float d2 = d1;\n    d1 = max(d1,-zag(dp,.65));\n\n    if(d1<res.x){\n        res = vec2(d1,d2<d1?3.:2.);\n        hit=dp;\n    }\n\n    float m1 = length(dp)-.25;\n    if(m1<res.x){\n        res = vec2(m1,4.);\n        hit=dp;\n    }\n    if(sg>0.){\n        //glow += smoothstep(.1,.25,.0025/(.0105+m1*m1*m1));\n       glow += smoothstep(.01,.5,.025/(.0015+m1*m1));\n    }\n    \n    float flr = pos.y+3.;\n    if(flr<res.x){\n        res=vec2(flr,1.);\n    \thit=pos;\n    }\n    \n    return res;\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int maxsteps, float sg){\n\tfloat d = 0.;\n    float m = 0.;\n    for(int i=0;i<maxsteps;i++){\n    \tvec2 ray = map(ro + rd * d, sg);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<32 ? ray.x *.5 : ray.x;\n        m  = ray.y;\n    }\n\treturn vec2(d,m);\n}\n\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e,0.).x+\n             h.yyx * map(p+h.yyx*e,0.).x+\n             h.yxy * map(p+h.yxy*e,0.).x+\n             h.xxx * map(p+h.xxx*e,0.).x;\n    return normalize(n);\n}\n\nvec3 truchet(vec2 p) {\n\n    float px = fwidth(length(p)-1.);\n    vec2 grid = fract(p.xy)-.5;\n    vec2 id   = floor(p.xy);\n    \n    float hs = hash21(id);\n    if(hs>.5) grid.x*=-1.;\n    \n    vec3 bc = vec3(.05);\n    vec3 h = vec3(.2); \n    h=clamp(h+.45,vec3(0),vec3(1));\n\n    vec2 d2 = vec2(length(grid-.5), length(grid+.5));\n    vec2 gx = d2.x<d2.y? vec2(grid-.5) : vec2(grid+.5);\n    \n    float circle = length(gx)-.5;\n    float tt = -T*1.2;\n    float l1 = .025+.065*cos(p.x*3.25+tt);\n    float l2 = .085+.065*sin(p.x*3.25+tt);\n    float l3 = .085+.065*sin(p.x*2.25+tt);\n    \n    if(hs>.88){\n     circle = abs(length(gx.x)-.5)-.001;\n    circle = min(circle,abs(length(gx.y)-.5)-.001);\n    }\n    \n    float circle2 = abs(abs(circle)-l1)-(l2);\n    circle2=smoothstep(-px,px,circle2);\n\n    circle=smoothstep(-px,px,\n    abs(abs(abs(circle)-l1)-l2)-l3\n    );\n    \n    vec2 sx = abs(grid)-.5;\n    float cbx = length(sx)-.1;\n    cbx=abs(cbx)-(l3*.75);\n    cbx=smoothstep(px,-px,cbx);\n\n    h = mix(h, bc,circle);\n    h = mix(h, vec3(.2,0,0),min(circle2,circle));\n\n    h = mix(h, vec3(1,0,0),cbx);\n    return h;\n}\n\nvec2 logPolar(vec2 p) {//@mla\n\tp = vec2(log(length(p)), atan(p.y, p.x));\n\treturn p;\n}\n\nvec4 FC = vec4(0.006,0.006,0.006,0.);\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd,192, 1.);\n\n    hitPoint = hit;\n    d = ray.x;\n    float m = ray.y;\n    float alpha = 0.;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(2,8,5);\n        vec3 l = normalize(lpos-p);\n        \n        vec3 h = vec3(.5);\n        vec3 hp = hitPoint;\n\n        float diff = clamp(dot(n,l),0.,1.);\n\n        float shdw = 1.0;\n        for( float t=.01; t < 18.; )\n        {\n            float h = map(p + l*t,0.).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 24.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>42. ) break;\n        }\n        \n        diff = mix(diff,diff*shdw,.65);\n        \n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.5 * pow(max(dot(view, ret), 0.),24.);\n\n        if(m==1.){\n            vec2 uv =hitPoint.xz;\n            uv=logPolar(uv)*3.5;\n            \n            uv.x-=T*1.02;\n            h = truchet(uv);\n            C = (diff*h);\n            ref = vec3(1);\n        }\n        \n        if(m==2.){\n            h = vec3(0.01);\n            C = (diff*h)+spec;\n            ref = vec3(.25);\n        }\n        if(m==3.){\n            h = vec3(1,0,0);\n            C = (diff*h)+spec;\n            ref = h;\n        }\n        if(m==4.){\n            h = vec3(.5);\n            C = (diff*h)+spec;\n            ref = h;\n        }\n        ro = p+n*.01;\n        rd = reflect(rd,n);\n    } \n\n    float glowMask = clamp(glow,.0,1.);\n    C = mix(C,vec3(glow),glowMask);\n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    turn = rot(T*15.*PI/180.);\n    r45 = rot(.78);\n    r90 = rot(1.5707);\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,.05,10.5);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    //mouse\n    float y = M.xy == vec2(0) ? 0. : -(M.x/R.x * 1. - .5) * PI;\n\n    mat2 rx = rot(.6);\n    mat2 ry = rot(y);\n    \n    ro.yz *= rx;\n    rd.yz *= rx;\n    ro.xz *= ry;\n    rd.xz *= ry;\n    \n    vec3 C = vec3(0);\n    vec3 ref=vec3(0), fil=vec3(1);\n    float d =0.;\n    float numBounces = 2.;\n    for(float i=0.; i<numBounces; i++) {\n        vec4 pass = render(ro, rd, ref, i==numBounces-1., d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n        // first bounce - get fog layer\n        if(i==0.) FC = vec4(FC.rgb,exp(-.000015*d*d*d));\n    }\n\n    //layer fog in   \n    C = mix(C,FC.rgb,1.-FC.w);\n    C = clamp(C,vec3(0),vec3(1));\n    // gamma\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}