{
    "Shader": {
        "info": {
            "date": "1482742313",
            "description": "forking to tweak and optimize on mobile\noriginal : https://www.shadertoy.com/view/XdyGRw",
            "flags": 1,
            "hasliked": 0,
            "id": "XtyXz1",
            "likes": 6,
            "name": "Thing spawner (tweaked)",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "MobileForks01",
            "viewed": 692
        },
        "renderpass": [
            {
                "code": "float sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat lengthRound(vec3 p)\n{\n\tfloat n = 1.7;\n\treturn pow(pow(p.x,n) + pow(p.y,n) + pow(p.z,n), 1.0/n);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  \n  //float lengthRounded = lengthRound(max(d,0.0));\n  //return min(max(d.x,max(d.y,d.z)),0.0) + lengthRounded;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 repeatPos(vec3 p, vec3 c)\n{\n\treturn mod(p,c)-.5 * c;\n}\n\nfloat getDistance(vec3 position)\n{\t\n    vec3 pos = vec3\n        (\n            (position.x + 5.0 * sin(iTime)) - 2.0,\n            position.y + 5.0 * cos(iTime),\n            position.z - 1.5\n        );\n    \n    vec3 pos2 = vec3\n        (\n            (position.x + 5.0 * sin(iTime)) - 2.0,\n            position.y + 5.0 * cos(iTime),\n            position.z - 1.5\n        );\n    vec3 pos3 = vec3\n        (\n            position.x + 45.,\n            position.y - 52. - iTime * 5.,\n            position.z + 55.0\n        );\n    //vec3 pos3 = vec3(position.x + 1.8 * sin(iTime - 3.3) + 0.2, position.y + 1.8 * cos(iTime - 3.3), position.z - 0.5);\n  \n    vec3 floorPos = vec3\n        (\n            position.x,\n            position.y + 5.0,\n            position.z\n        );\n    \n    vec3 wallPos = vec3\n        (\n            position.x,\n            position.y + 5.0,\n            position.z - 25.\n        );\n    \n    pos3 = repeatPos(pos3, vec3(15.,25.,15.));\n    \n    //float dis1 = sdSphere(pos, 2.0);\n    \n    //float dis2 = sdSphere(pos2, 1.33);\n    //float dis2 = sdBox(pos2, vec3(1.5, 1.5, 1.5));\n    float floorDis = sdBox(floorPos, vec3(300, 1, 300));\n    float wallDis = sdBox(wallPos, vec3(300, 100, 1));\n    \n    \n    \n    float sphereDis = sdSphere(pos3, 1.);\n    //float sphereDis = sdBox(pos3, vec3(1., 1., 1.));\n  \n    \n    // distance = smin(dis1, dis2, 1.0);\n    float distance = smin(floorDis, sphereDis, 1.0);\n    \n    distance = smin(distance, floorDis, 0.5);\n    distance = min(distance, wallDis);\n   \n  \n    \n    //return dis1;\n    return distance;\n    //return dis3;\n    \n    \n    //return sdSphere(pos, 2.0);\n    //Repeat shape\n\t//vec3 repPos = repeatPos(position, vec3(5.0,20.0,4.5));\n    \n    //Draw cubes\n\t//return sdBox(repPos, vec3(1.,1.,1.));\n\t\n    //Draw spheres\n\t//return sdSphere(repPos, 1.0);\n}\n\nvec4 getColor(vec3 position)\n{\n\tfloat e = 0.001;\n\tfloat f0 = getDistance(position);\n\t\n    //Approximate the normal by stepping a minimal amount in each of the axes' direction\n\tfloat fx = getDistance(vec3(position.x + e, position.y, position.z));\n\tfloat fy = getDistance(vec3(position.x, position.y + e, position.z));\n\tfloat fz = getDistance(vec3(position.x, position.y, position.z + e));\n\t\n\t\n\t\n\tvec3 normal = normalize(vec3(fx - f0, fy - f0, fz - f0));\n\tvec3 lightPosition = vec3\n\t\t(\n\t\t\t0.0, //+ 12.0*sin(iTime*1.0),\n\t\t\t20.0, //+ 12.0*sin(iTime*2.0),\n            -5.0\n            //iTime * 20.0\n            \n            //-1.0 - sin(iTime) * 2.0\n\t\t\t//280.0 + 300.0*sin(iTime*1.0) //Make the light move on the z axis\n\t\t\t//iTime * 5.0 + 100.0\n\t\t);\n\tvec3 lightDir = normalize(lightPosition - position);\n    /*\n\tvec4 lightColor = vec4\n        (\n            (sin(iTime * 0.1) + 0.5)/ 25.0 + 0.1,\n            (sin(iTime / 1.1) + 1.5)/ 25.0 + 0.1,\n            (cos(iTime * 0.1) + 0.5)/ 25.0 + 0.1,\n            //0.5 * tan(iTime),\n            //0.5 - 0.5 * sin(iTime),\n            //0.5 - 0.5 * cos(iTime),\n            0.2);\n    */\n    vec4 lightColor = vec4\n        (\n            0.15,\n            0.2,\n            0.3,\n            //0.5 * tan(iTime),\n            //0.5 - 0.5 * sin(iTime),\n            //0.5 - 0.5 * cos(iTime),\n            0.2);\n\tvec4 lightIntensity = lightColor * dot(normal, lightDir);\n\tfloat reflectance = 0.5;\n\t\n\tfloat lightDistance = length(position-lightPosition);\n    \n    //Hacky but pretty good looking light intensity diminishing over distance\n\t//float distanceIntensity = (1.0 / (pow(lightDistance / 100.0, 1.1))); \n    float distanceIntensity = (5.0 / (pow(lightDistance / 25.0, 1.0001))); \n\t\n\treturn reflectance * lightIntensity * (distanceIntensity);\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Moving eye position, bugs on some weaker hardware and just shows grey as mentioned in the omments\n    //vec3 eye = vec3(0, 3, iTime * 20.0 - 50.0);\n    \n    //Still eye\n\tvec3 eye = vec3(0, 0, -45);\n\t//eye.z = -1.0*sin(iTime);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = vec3(1, 0, 0);\n    \n    //Epsilon for when we are close enough to a surface to decide the surface is right here\n    float epsilon = 0.1;\n    float maxDistance = 10000.0;\n\n\t//Normalized device coordinates\n\tvec2 ndcXY = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\t\n\t// aspect ratio\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n\t\n\t// scaled XY which fits the aspect ratio\n\tvec2 uv = ndcXY * vec2( aspectRatio, 1.0 );\n\t//uv.y += (0.07 * sin(uv.x + iTime*4.0));\n\n\t\n    \n    //Variables needed for ray marching this pixel\n    float focalLength = 1.0;\n    vec3 forward = normalize(cross(right, up));\n    \n    vec3 planePos = right * uv.x + up * uv.y;\n\t\n    vec3 pImagePlane = eye + forward * focalLength + planePos;\n    vec3 rayDirection = normalize(pImagePlane - eye);\n\n\t// Sky color\n    vec4 color = vec4\n\t\t(\n\t\t\t0.30,\n\t\t\t0.30,\n\t\t\t0.30,\n\t\t\t1\n\t\t); \n\n    float t = 0.0;\n    const float maxSteps = 512.0;\n    for(float i = 0.0; i < maxSteps; ++i)\n    {\n        vec3 p = pImagePlane + rayDirection * t;\n\t\tfloat d = getDistance(p);\n\t\tif(d > maxDistance) {break;}\n        if(d < epsilon)\n        {\n\t\t\n            //Fixed color, no shading\n\t\t\t//color = vec4(i*0.1+0.1,0.5,0,1);\n            \n            //Shade this surface\n\t\t\tcolor = getColor(p);\n            break;\n        }\n\t\t//March forward by the distance to the closest surface to current point in space\n        t += d;\n    }\n\n    fragColor = color;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir)\n{    \n    //Still eye\n    vec3 eye = vec3(0, 0.0, -45);\n\t//vec3 eye = vec3(0, 0, -15);\n\t//eye.z = -1.0*sin(iTime);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = vec3(1, 0, 0);\n    //Epsilon for when we are close enough to a surface to decide the surface is right here\n    float epsilon = 0.1;\n    float maxDistance = 100000.0;\n\n\t//Normalized device coordinates\n\tvec2 ndcXY = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\t\n\t// aspect ratio\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n\t\n\t// scaled XY which fits the aspect ratio\n\tvec2 uv = ndcXY * vec2( aspectRatio, 1.0 );\n\t//uv.y += (0.07 * sin(uv.x + iTime*4.0));\n\n\t\n    \n    //Variables needed for ray marching this pixel\n    float focalLength = 1.0;\n    vec3 forward = normalize(cross(right, up));\n    \n    vec3 planePos = right * uv.x + up * uv.y;\n\t\n    vec3 pImagePlane = eye + forward * focalLength + planePos;\n    //vec3 rayDirection = normalize(pImagePlane - eye);\n    vec3 rayDirection = fragRayDir;\n\n\t// Sky color\n    vec4 color = vec4\n\t\t(\n\t\t\t0.30,\n\t\t\t0.30,\n\t\t\t0.30,\n\t\t\t1\n\t\t); \n\n    float t = 0.0;\n    const float maxSteps = 512.0;\n    for(float i = 0.0; i < maxSteps; ++i)\n    {\n        vec3 p = pImagePlane + rayDirection * t;\n\t\tfloat d = getDistance(p);\n\t\tif(d > maxDistance) {break;}\n        if(d < epsilon)\n        {\n\t\t\n            //Fixed color, no shading\n\t\t\t//color = vec4(i*0.1+0.1,0.5,0,1);\n            \n            //Shade this surface\n\t\t\tcolor = getColor(p);\n            break;\n        }\n\t\t//March forward by the distance to the closest surface to current point in space\n        t += d;\n    }\n\n    fragColor = color;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}