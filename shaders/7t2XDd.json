{
    "Shader": {
        "info": {
            "date": "1628972889",
            "description": "Uses barycentric coords to map the coordinates of a 2x2 unit cube onto an arbitrary convex irregular cube. The values of this regular unit cube are then used to colour the irregular cube. Could be seen as inverse trilinear interpolation.",
            "flags": 0,
            "hasliked": 0,
            "id": "7t2XDd",
            "likes": 0,
            "name": "3D Barycentric Interpolation",
            "published": 3,
            "tags": [
                "raymarch",
                "sdf",
                "barycentric",
                "lerp",
                "trilinear",
                "interpolation"
            ],
            "usePreview": 0,
            "username": "Sambi",
            "viewed": 481
        },
        "renderpass": [
            {
                "code": "#define ROT rotationMatrix(vec3(1.0, 0.0, 0.0), iTime * 0.5)\n\n// define the unit 2x2 cube centred on the origin by 8 corners.\n#define uT0 vec3(-1.0, 1.0, -1.0)\n#define uT1 vec3(1.0, 1.0, -1.0)\n#define uT2 vec3(1.0, 1.0, 1.0)\n#define uT3 vec3(-1.0, 1.0, 1.0)\n#define uB0 vec3(-1.0, -1.0, -1.0)\n#define uB1 vec3(1.0, -1.0, -1.0)\n#define uB2 vec3(1.0, -1.0, 1.0)\n#define uB3 vec3(-1.0, -1.0, 1.0)\n\n// deform the unit cube. this is what we'll raymarch, and we'll map positions back onto the\n// unit cube to determine colour using barycentric coordinates.\n#define T0 (ROT * vec4(uT0, 1.0) + vec4(sin(iTime), 0.0, cos(iTime), 0.0) * 0.5).xyz\n#define T1 (ROT * vec4(uT1, 1.0) + vec4(0.0, sin(iTime), cos(iTime), 0.0) * 0.5).xyz\n#define T2 (ROT * vec4(uT2, 1.0) + vec4(cos(iTime), sin(iTime), 0.0, 0.0) * 0.5).xyz\n#define T3 (ROT * vec4(uT3, 1.0) + vec4(0.0, 0.0, 0.0, 0.0) * 0.5).xyz\n#define B0 (ROT * vec4(uB0, 1.0) + vec4(cos(iTime), sin(iTime), 0.0, 0.0) * 0.5).xyz\n#define B1 (ROT * vec4(uB1, 1.0) + vec4(0.0, 0.0, 0.0, 0.0) * 0.5).xyz\n#define B2 (ROT * vec4(uB2, 1.0) + vec4(sin(iTime), 0.0, cos(iTime), 0.0) * 0.5).xyz\n#define B3 (ROT * vec4(uB3, 1.0) + vec4(0.0, sin(iTime), cos(iTime), 0.0) * 0.5).xyz\n\nstruct Tetrahedra\n{\n    vec3 p0;\n    vec3 p1;\n    vec3 p2;\n    vec3 p3;\n};\n\nTetrahedra uTet[5];\nTetrahedra tet[5];\nint numTet = 5;\n\n// Utils ------------------------------------------------------------------\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n// SDF ------------------------------------------------------------------\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat sdTri( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nvec4 opU(vec4 d1, vec4 d2)\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nvec4 sdf(in vec3 pos)\n{\n    vec4 res = vec4(1e10, 0.0, 0.0, 0.0);\n    for (int i = 0; i < numTet; i++)\n    {\n        res = opU(res, vec4(sdTri(pos, tet[i].p0, tet[i].p1, tet[i].p2), 0.0, 0.0, 0.0));\n        res = opU(res, vec4(sdTri(pos, tet[i].p0, tet[i].p2, tet[i].p3), 0.0, 0.0, 0.0));\n        res = opU(res, vec4(sdTri(pos, tet[i].p0, tet[i].p3, tet[i].p1), 0.0, 0.0, 0.0));\n        res = opU(res, vec4(sdTri(pos, tet[i].p1, tet[i].p3, tet[i].p2), 0.0, 0.0, 0.0));\n    }    \n    return res;\n}\n\n// Interpolation ------------------------------------------------------------------\n\n// calculate barycentric coordinates from the 4 tetrahedron verts.\nvec4 bary(vec3 p, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    vec3 vap = p - a;\n    vec3 vbp = p - b;\n    vec3 vab = b - a;\n    vec3 vac = c - a;\n    vec3 vad = d - a;\n    vec3 vbc = c - b;\n    vec3 vbd = d - b;    \n    float v6 = 1.0 / dot(vab, cross(vac, vad));\n    float va6 = dot(vbp, cross(vbd, vbc)) * v6;\n    float vb6 = dot(vap, cross(vac, vad)) * v6;\n    float vc6 = dot(vap, cross(vad, vab)) * v6;\n    return vec4(va6, vb6, vc6, 1.0 - va6 - vb6 - vc6);\n}\n\n// calculate cartesian from barycentric coordinates using 4 tetrahedron verts. \nvec3 invBary(vec4 bary, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    vec3 ret = vec3(0.0);\n    ret.x = bary.x * a.x + bary.y * b.x + bary.z * c.x + bary.w * d.x;\n    ret.y = bary.x * a.y + bary.y * b.y + bary.z * c.y + bary.w * d.y;\n    ret.z = bary.x * a.z + bary.y * b.z + bary.z * c.z + bary.w * d.z;\n    return ret;\n}\n\n// map cartesian coordinate onto unit cube using barycentric coordinates.\nvec3 mapToUnitCube(vec3 pos)\n{\n    float highest = -999.9;\n    vec4 b = vec4(0.0);\n    int iT = -1;\n    \n    // determine which tetrahedron the point is closest to (if not inside)\n    // by finding the barycentric coords of each tetrahedron with the largest\n    // minimum.\n    for (int i = 0; i < tet.length(); i++)\n    {\n        vec4 bTest = bary(pos, tet[i].p0, tet[i].p1, tet[i].p2, tet[i].p3);\n        float low = min(min(min(bTest.x, bTest.y), bTest.z), bTest.w);\n        if (low >= 0.0)\n        {\n            // if all barycentric coords are positive, point is definitely within\n            // that tetrahedra.\n            b = bTest;\n            iT = i;\n            break;\n        }\n        else if (low > highest)\n        {\n            b = bTest;\n            highest = low;\n            iT = i;\n        }\n    }\n    // take the barycentric coords of point on the nearest tetrahedron, and\n    // convert back into cartesian coords using the corresponding unit tetrahedron.\n    return invBary(b, uTet[iT].p0, uTet[iT].p1, uTet[iT].p2, uTet[iT].p3);\n}\n\n// Rendering ------------------------------------------------------------------\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    // background\n    vec3 col = vec3(1.0, 1.0, 1.0);\n    \n    // raycast scene\n    float t = 0.0;\n    for(int i = 0; i < 90; i++)\n    {\n        vec3 p = ro + rd * t;\n        vec4 h = sdf(p);        \n        if(h.x < (0.001 * t))\n        {\n            col = mapToUnitCube(p);\n            break;\n        }\n        t += h.x;\n        if (t > 7.0)\n            break;\n    }\n\treturn col;\n}\n\nmat3 calcLookAtMatrix(in vec3 ro, in vec3 ta, in float roll)\n{\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,vec3(sin(roll),cos(roll),0.0)));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    \n    // drag along x to show/hide tetrahedrons\n    vec2 m = iMouse.xy / iResolution.xy;\n    numTet = 5 - int(m.x * 6.0);\n    \n    // break the cube down into 5 tetrahedra\n    tet[0] = Tetrahedra(T1, B2, T3, B0); // centre\n    tet[1] = Tetrahedra(T0, T1, T3, B0); // t0\n    tet[2] = Tetrahedra(T2, T3, T1, B2); // t2\n    tet[3] = Tetrahedra(B1, B0, B2, T1); // b1\n    tet[4] = Tetrahedra(B3, B2, B0, T3); // b3\n    \n    // this is our unit tetrahedra we're mapping onto\n    uTet[0] = Tetrahedra(uT1, uB2, uT3, uB0); // centre\n    uTet[1] = Tetrahedra(uT0, uT1, uT3, uB0); // t0\n    uTet[2] = Tetrahedra(uT2, uT3, uT1, uB2); // t2\n    uTet[3] = Tetrahedra(uB1, uB0, uB2, uT1); // b1\n    uTet[4] = Tetrahedra(uB3, uB2, uB0, uT3); // b3\n\n    // camera\n    vec3 ro = vec3(5.0 * sin(iTime * 0.5), 2.0, 5.0 * cos(iTime * 0.5));\n    mat3 camMat = calcLookAtMatrix(ro, vec3(0.0, 0.0, 0.0), 0.0);\n    \n\t// view ray\n\tvec3 rd = normalize(camMat * vec3(p.xy, 2.0));\n\n    // render\n    fragColor = vec4(render(ro, rd), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}