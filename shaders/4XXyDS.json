{
    "Shader": {
        "info": {
            "date": "1726591460",
            "description": "originals https://www.shadertoy.com/view/XXscRs",
            "flags": 0,
            "hasliked": 0,
            "id": "4XXyDS",
            "likes": 3,
            "name": "cosmos light 2",
            "published": 3,
            "tags": [
                "light",
                "cosmos",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 106
        },
        "renderpass": [
            {
                "code": "///////////////////////////\n#define PI 3.14159265\n#define TAU 6.2831853\n\n\n// Microfaceted normal distribution function.\nfloat D_GGX(float NoH, float roughness) {\n    float alpha = pow(roughness, 4.);\n    float b = (NoH*NoH*(alpha - 1.) + 1.);\n    return alpha/(PI*b*b);\n}\n\n\n#define S 4.\n// the wave amplitude\n#define A 1.9\n// the wave lenght\n#define WAVEL 1.1\n\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n// taken from thebookofshaderx.com\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\nvec2 cartesianToPolar(vec2 cartesian) {\n    float r = length(cartesian);          \n    float theta = atan(cartesian.y, cartesian.x); \n    return vec2(r, theta);  \n    \n}\n\n\n// Surface geometry function.\nfloat G1_GGX_Schlick(float NoV, float roughness) {\n    //float r = roughness; // original\n    float r = .5 + .5*roughness; // Disney remapping.\n    float k = (r*r)/2.;\n    float denom = NoV*(1. - k) + k;\n    return max(NoV, .001)/denom;\n}\n\nfloat G_Smith(float NoV, float NoL, float roughness) {\n    float g1_l = G1_GGX_Schlick(NoL, roughness);\n    float g1_v = G1_GGX_Schlick(NoV, roughness);\n    return g1_l*g1_v;\n}\n\n// Bidirectional Reflectance Distribution Function (BRDF). \n//\n// If you want a quick crash course in BRDF, see the following:\n// Microfacet BRDF: Theory and Implementation of Basic PBR Materials\n// https://www.youtube.com/watch?v=gya7x9H3mV0&t=730s\n//\nvec3 BRDF(vec3 col, vec3 n, vec3 l, vec3 v, \n          float type, float rough, float fresRef, vec3 lCol){\n     \n    vec3 h = normalize(v + l); // Half vector.\n\n    // Standard BRDF dot product calculations.\n    float nv = clamp(dot(n, v), 0., 1.);\n    float nl = clamp(dot(n, l), 0., 1.);\n    float nh = clamp(dot(n, h), 0., 1.);\n    float vh = clamp(dot(v, h), 0., 1.);  \n\n\n    // Specular microfacet (Cook- Torrance) BRDF.\n    //\n    // F0 for dielectics in range [0., .16] \n    // Default FO is (.16 * .5^2) = .04\n    // Common Fresnel values, F(0), or F0 here.\n    // Water: .02, Plastic: .05, Glass: .08, Diamond: .17\n    // Copper: vec3(.95, .64, .54), Aluminium: vec3(.91, .92, .92), Gold: vec3(1, .71, .29),\n    // Silver: vec3(.95, .93, .88), Iron: vec3(.56, .57, .58).\n    vec3 f0 = vec3(.16*(fresRef*fresRef)); \n    // For metals, the base color is used for F0.\n    f0 = mix(f0, col, type);\n    vec3 F = f0 + (1. - f0)*pow(1. - vh, 5.);  // Fresnel-Schlick reflected light term.\n    // Microfacet distribution... Most dominant term.\n    float D = D_GGX(nh, rough); \n    // Geometry self shadowing term.\n    float G = G_Smith(nv, nl, rough); \n    // Combining the terms above.\n    vec3 spec = F*D*G/(4.*max(nv, .001));\n\n\n    // Diffuse calculations.\n    vec3 diff = vec3(nl);\n    diff *= 1. - F; // If not specular, use as diffuse (optional).\n    diff *= (1. - type); // No diffuse for metals.\n\n\n    // Combining diffuse and specular.\n    // You could specify a specular color, multiply it by the base\n    // color, or multiply by a constant. It's up to you.\n    return (col*diff + lCol*spec*PI);\n  \n}\n////////////////////\n/*\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n*/\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n/*\n\n    Polar Grid Raymarch Traversal\n    -----------------------------\n    \n    I've been enjoying posting simple 2D shaders, but I figured it was probably \n    time to post something more technical. I enjoy coding 3D shaders, but groan at \n    the prospect of tidying up the code for presentation.\n    \n    This is a raymarched traversal of a polar grid. The polar grid traversal code\n    was written some time ago, so I've merely combined it with raymarching code in\n    order to benefit from soft shadows, and so forth. Polar grid traversal is \n    definitely not common, but not nonexistent -- Abje wrote one a few years ago...\n    and I'm willing to bet that he was able to do it far less time than it took \n    me. :) The link is below, for anyone interested.\n    \n    Most traversals -- and by most, I mean, virtually all -- involve cells \n    bordered by straight lines or planes. Polar traversals involve cells bordered\n    by the former with additional curved borders. Logistically speaking, it's not\n    much different; With a square grid, for example, you'll require four straight\n    line cell border intersections. However, an extruded polar cell traversal will \n    involve two straight line intersections and two circular intersections -- which\n    will be pretty simple for anyone with even a rudimentary raytracing knowledge.\n    \n    Anyway, the details are below. The code runs fine, but could benefit from some\n    streamlining to speed things up -- Apologies for anyone trying to run this on\n    a slower system. The comments were rushed, but I'll tidy them up in due course. \n    By the way, I'll post a 2D polar traversal to accompany this soon, for anyone \n    interested.\n    \n    \n    \n    \n    Similar examples:\n    \n    // Abje codes some really interesting examples, and he seems to \n    // code them up very quickly.\n    polar wave  - abje\n    https://www.shadertoy.com/view/wsSSWR\n\n*/\n\n// Infuse some color.\n#define ADD_COLOR\n\n \n// Maximum ray distance.\n#define FAR  20.\n\n\n// Light type: Point: 0, Direct: 1\n#define LIGHT_TYPE 0\n\n\n// Bore out some holes.\n#define HOLES\n\n//////////////\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n \n// Tri-Planar blending function: Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.xz).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n    // The first line relates to ensuring that icosahedron vertex identification\n    // points snap to the exact same position in order to avoid hash inaccuracies.\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\n// IQ's \"uint\" based uvec3 to float hash.\nfloat hash31(vec3 f){\n\n    uvec3 p = floatBitsToUint(f);\n    p = 1664525U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32 >> 16);\n    return float(n & uint(0x7fffffffU))/float(0x7fffffff);\n}\n\n// IQ's 2D signed box formula with some added rounding.\nfloat sBoxS(vec2 p, vec2 b, float sf){\n\n  p = abs(p) - b + sf;\n  return min(max(p.x, p.y), 0.) + length(max(p, 0.)) - sf;\n}\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n \n    // Slight rounding. A little nicer, but slower.\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;   \n     \n}\n\n\n// Height map value.\nfloat hm(in vec2 p){ \n\n    // Texture height value.\n    vec3 tx = texture(iChannel1, p).xyz; tx *= tx;\n    \n    return dot(tx, vec3(.299, .587, .114));\n}\n\n// Two value sign function.\n//vec2 sign2(in vec2 p){ return vec2(p.x<0.? -1 : 1, p.y<0.? -1 : 1); }\n \n\n// Ray origin, ray direction, point on the line, normal. \nfloat rayLine(vec2 ro, vec2 rd, vec2 p, vec2 n){\n   \n   // This it trimmed down, and can be trimmed down more. Note that \n   // \"1./dot(rd, n)\" can be precalculated outside the loop. However,\n   // this isn't a GPU intensive example, so it doesn't matter here.\n   //return max(dot(p - ro, n), 0.)/max(dot(rd, n), 1e-8);\n   float dn = dot(p - ro, n)/dot(rd, n);\n   return dn<0.? 1e8 : dn;   \n\n} \n\n\n// IQ's circle intersect function: I have my own, but IQ's functions\n// are known to people, and tend to be more reliable.\n//\n// I've substituted in a lot of comments, for anyone interested.\nvec2 circleIntersect(in vec2 ro, in vec2 rd, in vec2 ce, float ra){\n\n    // Standard quadratic solution to the ray circle intersection.\n    // Ie. Solving the circle equation (x*x + y*y - ra*ra = 0), where\n    // \"x = (ro - ce).x + rd.x*t\", and \"y = (ro - ce).y + rd.y*t\". \n    // Substituting produces a quadratic that can be solved for \"t\". \n   \n    vec2 oc = ro - ce;\n    float b = dot(oc, rd);\n    vec2 qc = oc - b*rd;\n    float h = ra*ra - dot(qc, qc);\n    \n    // No real roots, so no intersection.\n    if(h<0.) return vec2(1e8); //if(b<0. || h<0.)\n    \n    // Real roots, so there are, at most, two solutions -- In the rare case of \n    // the direction ray running perpendicular to the circle normal at the hit\n    // point, there'd be two equal values (so techniqally, one solution), but \n    // it shouldn't affect the following logic.\n    \n    // If the second (larger value) is negative, then both values will be negative, \n    // so there'll be no intersection points.\n    \n    // If the second value is positive, but the first value is negative, then\n    // we're inside the circle, so we'll need the positive distance in front of us.\n    // Ie. The second value.\n    \n    // If both values are positive, the we're outside the circle, so we'll need the\n    // lesser distance, or the first one.\n    h = sqrt(h);\n    return vec2(-b - h, -b + h); \n}\n\n\n// Global ring rotation matrix.\nmat2 gRot;\n\n// Number of cells.\nconst float rSpacing = 1./3.;\n\n\n// The polar grid.\nvec4 getGrid(inout vec2 p){\n\n    // Radial ID.\n    float iR = floor((length(p) + rSpacing/2.)/rSpacing);\n    // Number of segments per ring -- Roughly equal size chunks whilst \n    // maintaining some radial balance.\n    float aNum = max(floor(iR*3.), 1.);//6.2831*\n    \n    //if(iR>0.) aNum = max(aNum, 2.);\n\n\n     // More mechanical rotation.\n     float angT2 = cos(32./(iR + 1.)/1. + iTime + iR);\n     angT2 = smoothstep(-.4, .4, angT2)/1.5;\n     gRot = rot2(angT2);\n     // More fluid rotation.\n     //float angT = sin(32./(iR + 1.)/1. + iTime)/4.;\n     //gRot = rot2(angT);\n     p = gRot*p;\n\t\n    // Polar angle.\n    // Note: If using IDs, \"mod(atan(p.y, p.x), 6.2831)\" might be necessary.\n    float a = mod(atan(p.y, p.x), TAU);\n    \n\n    // Partitioning the angle into \"aNum\" cells.\n    float ia = mod(floor(a/TAU*aNum), aNum); // Modulo not always needed.\n    \n    // Radial ID, angular ID, angle, number of angular segments per ring.\n    return vec4(iR, ia, a, aNum);\n}\n \n\n\n// Global cell boundary distance variables.\nvec3 gDir; // Cell traversing direction.\nvec3 gRd; // Ray direction.\nfloat gCD; // Cell boundary distance.\n// ID and local XY coordinates.\n\nvec3 gP;\nvec4 gID;\n\n\n\nfloat map(vec3 q3) {\n\n    // Floor. Redundant here.\n    float fl = q3.y + .5;\n\n\n    //vec3 sc = GSCALE; // Scale.\n    // Local coordinates and cell ID.\n    vec2 p = q3.xz;//p4.xy;\n    vec4 d4 = getGrid(p); \n    //vec2 id = d4.xy;\n\n    float iR = d4.x;\n    float ia = d4.y;\n    float a = d4.z;\n    float aNum = d4.w;\n    float iaF = (ia + .5)/aNum*TAU;\n\n    vec2 pO = p;\n\n\n ////////////\n \n    // The minimum distance from the current position in the direction\n    // of the normalized XZ plane unit ray to the polar cell wall. There\n    // are four cell walls to check: The two straight edge sides and the\n    // the two inner and outer circular boundaries.\n    \n    // Cell radius.\n    float r = (iR + .5)*rSpacing;  \n\n    vec2 rdXZ = normalize(gRd.xz); // 2D XZ plane ray normal.\n    // Larger ring radius ray intersection.\n    vec2 pI = circleIntersect(q3.xz, rdXZ, vec2(0), r);\n    // Larger outer radius distance.\n    float t1 = pI.y<0.? 1e8 : pI.x<0.? pI.y : pI.x;\n\n    // Smaller inner radius ray intersection.\n    r -= rSpacing;\n    pI = circleIntersect(q3.xz, rdXZ, vec2(0), r);\n    // Smaller inner radius distance.\n    float t2 = pI.y<0.? 1e8 : pI.x<0.? pI.y : pI.x;\n\n    // Take the minimum.\n    float t = min(t1, t2);\n\n    // The edges of each segmented rings are the following:\n    // vec2 edgeLeft = r2(PI/aNum - iaF)*vec2(0, 1);\n    // vec2 edgeRight = r2(-PI/aNum - iaF)*vec2(0, 1);\n    // The inward-faceing normals to the edges are:\n    // vec2 normalLeft = normalize(edgeLeft*vec2(1, -1));\n    // vec2 normalRight = -normalize(edgeRight*vec2(1, -1));\n    //\n    // The following is just a way way to calculate the above.\n    vec2 n1 = vec2(sin(iaF - PI/aNum), -cos(-iaF + PI/aNum))/sqrt(2.);\n\n    // The rings, and as such, ring segments are rotated over time with individual \n    // rotation matrices, (gRot) so the normals need to be rotated accordingly.\n    n1 *= gRot; // Or, \"n1 = inverse(gRot)*n1;\".\n\n    // The two segment edge intersections. You could combine these, to save a few\n    // calculations, but this reads better. In instances where you're traversing a\n    // nonsegmented (single) ring, these calculations aren't necessary. In this \n    // example, the middle circle doesn't need side segment intersections, but\n    // we're doing them anyway to save on GPU nesting, branching, etc... which is\n    // not important here, but would be when traversing in 3D.\n    float t3 = rayLine(q3.xz, gRd.xz, vec2(0), n1);\n    float t4 = rayLine(q3.xz, gRd.xz, vec2(0), -rot2(TAU/aNum)*n1);\n    // The two segment edge distances.\n    t3 = t3<0.? 1e8 : t3;\n    t4 = t4<0.? 1e8 : t4;\n    \n    // Take the minimum of all distances, but only if the ring has been segmented.\n    if(d4.w>1.) t = min(t, min(t3, t4)); // Only segmented rings. Not single ones.\n    //t = max(t, 0.); \n    \n    // Minimum boundary wall distance.\n    gCD = t + .0015;\n\n////////////\n   \n   \n    // The extruded block height. See the height map function, above.\n    const float txSc = 5.;\n    vec2 rCoord = vec2(iResolution.y/iResolution.x, 1)*\n                  iR*rSpacing*vec2(cos(iaF), sin(iaF))/txSc + .5;\n   \n    // Block height.\n    float h = hm(rCoord)*20.;\n    // Adding some subtle randomized animation to break things up a bit.\n    h += (sin(hash21(vec2(ia, iR) + .55)*TAU + iTime)*2.5 + .5)*.3;\n \n   \n    // Radial coordinate.\n    r = length(p); \n    \n    // Repetition via polar coordinates. It repeats object as required, but warps \n    // space in the process. Sometimes, this is preferable, but not in this case.\n    //p = vec2(length(p), mod(a, TAU/aNum) - TAU/aNum/2.);\n    \n    // Converting the radial centers to their positions.\n  \n    // The line above is equivalent to:\n    //p = vec2(p.x*cos(ia) + p.y*sin(ia), p.y*cos(ia) - p.x*sin(ia));\n   \n  \n    \n    // Setting the radial distance.\n    // Moving the points out a bit along the radial line. If you didn't perform this,\n    // all objects would be superimposed on one another in the center.\n    p.x = mod(r - rSpacing/2., rSpacing) - rSpacing/2.; // Radial repetition.\n     \n    // The radial distance field. For continuous rings with no segments, this would\n    // be all you'd need.\n    float d2 = abs(p.x) - rSpacing/2.;\n    \n    // Rings, not including the central circle.\n    if(aNum > 1.){\n       // We only need to segment piecewise annuli, not\n       // those with a single piece running the entire\n       // circumference.\n       \n       vec2 pR = rot2(-(iaF - (PI/aNum)))*pO;\n       vec2 pR2 = rot2(-(iaF + (PI/aNum)))*pO;\n      \n        d2 = smax(d2, max(-pR.y, pR2.y), .04);\n\n    }\n    \n    // The central circle.\n    if(iR==0.){\n       // The inner circle is handled differently. Basically, we just want\n       // a regular circle with regular coordinates.\n       p = pO;\n       d2 = length(p) - rSpacing/2.;\n       \n       //p.x = mod(p.x - rSpacing/2., rSpacing) - rSpacing/2.;\n       //d = abs(length(p) - (iR)*rSpacing) - rSpacing/2.;\n    }\n    \n    // Move the distance field cell walls in a little.\n    d2 += .005;\n    \n    // Random block holes. \n    #ifdef HOLES\n    if(hash21(rCoord)<.5) d2 = max(d2, -(d2 + rSpacing/2.4)); //if(sc.x>1./16.) \n    #endif\n    \n    // Creating the extruded prisms.\n    float d = opExtrusion(d2, q3.y - h/2., h/2., 0.);\n    //d -= -d2*.25; \n    d -= min(-d2, .045)*.35;// \n    \n    // Ridges.\n    d -= (smoothstep(-.01, .01, abs(d2 + .045) - .01) - .5)*.0075;\n  d -= abs(fract(d2/rSpacing*6.) - .5)*.005;\n\n \n\n    // Saving the ID and local coordinates.\n    gP = vec3(p.x, (q3.y - h), p.y)/txSc;\n    gID = vec4(d, d2, vec2(iR, iaF));\n \n \n    // Scene distance.\n    return min(fl, d);\n}\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 normal(in vec3 p) {\n\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n \n// Raymarching.\nfloat rayMarch(vec3 ro, vec3 rd) {\n    \n    // Current and overall distance.\n    float d, t = 0.; //hash31(ro + rd)*.25; Jitter.\n    vec2 dt = vec2(1e8, 0); // IQ's edge desparkle trick.\n\n\n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = step(00., rd) - .5; // sign(rd)*.5;\n    gRd = rd;\n\n\n    const int iter = 128;\n    int i = 0;\n     \n    for (i = 0; i < iter; i++) {\n       \n        // Scene distance.\n        d = map(ro + rd*t);\n        \n        // IQ's clever edge desparkle trick. :)\n        if (d<dt.x) { dt = vec2(d, t); } \n\n        // Surface or far plane bailout.\n        if(d<.001 || t > FAR) {\n           break;\n        }\n        \n        // Take the minimum of the scene distance or the \n        // nearest cell wall in the direction of the ray.\n        t += min(d*.9, gCD);\n    }\n    \n    // Minimum distance in the event that we didn't hit the surface.\n    if(i == iter - 1) { t = dt.y; }\n\n    // Scene distance.\n    return min(t, FAR);\n}\n\nfloat softShadow(in vec3 p, in vec3 ld, in float lDist, in float k) {\n    \n    float res = 1.;\n    float t = 0.;\n\n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = step(0., ld) - .5;\n    gRd = ld; \n\n    for (int i=0; i<64; i++){\n\n        float d = map(p + ld*t);\n        res = min(res, k*d/t);\n        if (d<0. || t>lDist) break;\n\n        t += clamp(min(d*.9, gCD), .01, .25);\n    }\n    return clamp(res, 0., 1.);\n}\n\n\n// A slight variation on a function from Nimitz's hash collection, here: \n// Quality hashes collection WebGL2 - https://www.shadertoy.com/view/Xt3cDn\nvec2 hash23(vec3 f){\n\n    uvec3 p = floatBitsToUint(f);\n    p = 1103515245U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32>>16);\n\n    uvec2 rz = uvec2(n, n*48271U);\n    // Standard uvec2 to vec2 conversion with wrapping and normalizing.\n    return vec2((rz>>1)&uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\n \n// A nice random hemispherical routine taken out of one of IQ's examples.\n// The routine itself was written by Fizzer.\nvec3 cosDir(in vec3 p, in vec3 n){\n\n    vec2 rnd = hash23(p);\n    float u = rnd.x;\n    float v = rnd.y;\n    \n    // Method 1 and 2 first generate a frame of reference to use with an arbitrary\n    // distribution, cosine in this case. Method 3 (invented by fizzer) specializes \n    // the whole math to the cosine distribution and simplfies the result to a more \n    // compact version that does not depend on a full frame of reference.\n\n    // Method by fizzer: http://www.amietia.com/lambertnotangent.html\n    float a = 6.2831853*v;\n    u = 2.*u - 1.;\n    return normalize(n + vec3(sqrt(1. - u*u)*vec2(cos(a), sin(a)), u));\n    \n}\n\n\nfloat calcAO(in vec3 p, in vec3 n){\n \n\tfloat sca = 2., occ = 0.;\n    for(int i = 0; i<12; i++){\n    \n        float hr = (float(i) + 1.)*.35/12.; \n        \n        vec3 rn = cosDir(p + n*hr, n); // Random half hemisphere vector.\n        float d = map(p + rn*hr);\n        \n        occ = occ + max(hr - d, 0.)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);    \n    \n}\n\nvec4 render(vec3 ro, vec3 rd, vec2 uv){\n\n    // Lights.\n \n    // Point light.\n    vec3 lp = ro + vec3(0, 0, 0);\n  \n    // Direct light.\n    vec3 ld = normalize(vec3(10, 0, 0));\n    float lDist = FAR;\n  \n    \n    // Raymarch the scene.\n    float t = rayMarch(ro, rd);\n\n    // Saving the local cell coorinates and cell ID.\n    vec3 svP = gP;\n    vec4 svGID = gID;\n\n\n    // Initializing.\n    vec3 col = vec3(0);\n   \n    // If we've hit something, color it up.\n    if (t < FAR){\n  \n        // Position and normal.\n        vec3 p = ro + rd*t;\n        vec3 n = normal(p);\n        \n    \n        vec3 ld = lp - p;\n        float lDist = length(ld);\n        ld /= lDist;\n       \n        \n         \n        // Shadow and ambient occlusion.\n        float shd = softShadow(p + n*.0015, ld, lDist, 8.);\n        float ao = calcAO(p, n);\n\n \n        // Block ID and corresponding height.\n        vec2 id = svGID.zw;\n    \n        // Object color.\n        vec3 oCol = mix(vec3(0.8, 0.8, 3), vec3(.65, 2.6, .9)/1.25, hash21(id + 2.13))/2.;\n        \n        \n  \n        \n       \n        float ew = .007;\n        \n        // Face border coloring, etc.\n        if(svP.y>0.) {\n           \n           vec3 svCol = oCol;\n           oCol = mix(oCol*1.1, vec3(1), .25);\n           oCol = mix(oCol, oCol*.1, 1. - smoothstep(1., .003, svGID.y + .035));\n           oCol = mix(oCol, svCol*.9, 1. - smoothstep(0., .003, svGID.y + .035 + ew*2.5));\n           \n        }\n        \n        // Polar \"map\" function values.\n        // vec4(iR, ia, a, aNum)\n        vec2 pO = p.xz;\n        vec4 dm = getGrid(p.xz);\n        float iR = dm.x; // Radial.\n        float ia = dm.y; // Angular.\n        float a = dm.z;\n        float aNum = dm.w;\n        float iaF = (ia + .5)/aNum*TAU;\n\n       \n     \n       \n        // Blue gradient tinge.\n        //oCol = mix(oCol, oCol*vec3(1, 1.5, 3), max(svP.x + svP.z, 0.)*10.);\n   \n        \n        // Apply edges.  \n        float d = abs(svGID.y - ew/2.*0.);\n        d = max(d, -svP.y + ew/2.) - ew/2.;\n        oCol = mix(oCol, oCol*.0, 1. - smoothstep(0., .003, d));\n             \n       \n         \n        // Leftover effect from another shader. Interesting... but no. :)\n        //vec2 id2 = floor(id/2.);\n        //if(mod(id2.x + id2.y, 2.)<.5) oCol = mix(oCol, oCol.zyx, .5);\n      \n        // Texture coordinates that match the animation.\n        vec2 aspect = vec2(iResolution.y/iResolution.x, 1);\n        \n        // Tri-planar texturing, rotate to tie in with the animation.\n        vec3 txP = p;\n        vec3 txN = n;\n        txP.xz = rot2(dm.x)*txP.xz;\n        txN.xz = rot2(dm.z)*txN.xz;\n        vec3 tx = tex3D(iChannel0, txP/2., txN);\n         // Subtle texture color.\n        oCol = oCol*(tx*2. + .05);\n         \n       \n         \n        // Cheap specular reflections.\n        float speR = pow(max(dot(normalize(ld - rd), n), 0.), 5.);\n        vec3 rf = reflect(rd, n); // Surface reflection.\n      \n        oCol = oCol + oCol*speR*4.;\n        \n      \n        // I wanted to use a little more than a constant for ambient light this \n        // time around, but without having to resort to sophisticated methods, then I\n        // remembered Blackle's example, here:\n        // Quick Lighting Tech - blackle\n        // https://www.shadertoy.com/view/ttGfz1\n        //\n        // Studio.\n        float am = pow(length(sin(n*2.)*.5 + .5)/sqrt(3.), 2.); \n        // Outdoor.\n        //float am = length(sin(sn*2.)*.5 + .5)/sqrt(3.)*smoothstep(-1., 1., -sn.z); \n        \n  \n\n        // Greyscale texture value -- used for varying surface roughness.\n        float gr = dot(tx, vec3(.299, .587, .114));\n \n        // Material type: Dielectics, with varying roughnesss and reflectance.\n        float matType = 1., roughness = gr*gr*4. + .15, reflectance = .725;\n        /*\n        if(svP.y<0.){\n           // Sides with less reflectance and more roughness.\n           reflectance = .5;\n           roughness = gr*gr*1. + .05;\n        }\n        */\n\n        // Cook-Torrance based lighting.\n        vec3 ct = BRDF(oCol, n, ld, -rd, matType, roughness, reflectance, vec3(4));\n\n        // Combining the ambient and microfaceted terms to form the final color:\n        // None of it is technically correct, but it does the job. Note the hacky \n        // ambient shadow term. Shadows on the microfaceted metal doesn't look \n        // right without it... If an expert out there knows of simple ways to \n        // improve this, feel free to let me know. :)\n        col = (oCol*am*(shd*.5 + .5) + ct*(shd))*ao;\n        \n\n\n        // Light attenuation. Barely visible, but it's there\n        float rt = t/FAR;\n        col *= 1.25/(1. + rt*.2); \n\n    }\n  \n    // Fog. Not visible, but it's there anyway.\n    col = mix(col, vec3(0), smoothstep(.0, .99, t/FAR));\n    \n    // Returning the final color for this pass... There's only one\n    // pass here, but a render function is useful when you want to\n    // bounce light around.\n    return vec4(col, t);\n  \n}\n\nfloat sdCircle (vec2 _pos, float r){ // SDF Circle func\n    return length(_pos) - r;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n    // Coordinates.\n    vec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\n          vec2 uv = fragCoord/iResolution.xy-0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    // Look vector and camera origin.\n    vec3 lk = vec3(0, 0, 0);\n    vec3 ro = lk + vec3(0, 3,  0);\n   // Remap the space to -1. to 1 in a function of time\n\n    uv.x *= iResolution.x/iResolution.y;\n    //uv = sin(iTime) * uv +uv * cos(iTime);\n    \n    uv = rotate2d( sin(iTime)) * uv;\n    \n   \n    //uv = cartesianToPolar(uv);\n    vec2 wave1Center = vec2(-1., -0.5);\n    //vec2 wave2Center = vec2(1., 0.5);\n    wave1Center= vec2(0.);\n    \n    float disFromWave1Center = distance(uv, wave1Center);\n    //float disFromWave2Center = distance(uv, wave2Center);\n    \n    float wave1 =  A * sin(disFromWave1Center / WAVEL - iTime / WAVEL);\n    //float wave2 =  A * sin(disFromWave2Center / WAVEL - iTime / WAVEL) ;\n \n    uv = uv + uv * (wave1) / WAVEL;\n\n    // probe texture\n    vec3 textureColor = texture(iChannel0, uv).rgb;\n    // Setting up a camera using the usual process. The variable names\n    // here suggest that this lot came from one of IQ's examples.\n    vec3 ww = normalize(lk - ro);\n    vec3 uu = normalize(cross(vec3(0, 0.1, 1), ww ));\n    vec3 vv = cross(ww, uu);\n    const float FOV = 3.14159/2.; // Field of view.\n    vec3 rd = normalize(u.x*uu + u.y*vv + ww/FOV); // Unit direction vector.\n    \n    \n     \n    rd = normalize(rd);\n    \n    \n   \n \n  \n    // Render... I was going to perform a couple of passes, but decided against \n    // it. However, it's usually a good idea to have a separate render function.\n    vec4 c4 = render(ro, rd, u);\n    vec3 col = c4.xyz;\n    \n    \n    // Vignette and very rough Reinhard tone mapping.\n    col *= smoothstep(1.5, .5, length(2.*fragCoord/iResolution.xy - 1.)*.7);\n    col /= 1. + col/2.5;\n\n    \n    // Output the fragment color to the buffer.\n    fragColor = vec4(max(col, 0.), c4.w);\n     vec2 circlePos = vec2(.0,0.0);\n    \n    float circle = sdCircle(uv - circlePos, 0.5);\n    \n    vec2 dir = normalize(uv - circlePos) + (cos(iTime/4.f) + 1.0f) / 2.0f;\n    \n    float tex1 = texture( iChannel0,uv - dir).x;\n    float tex2 = texture( iChannel0,uv + dir).x;//moving tex\n    \n    float alpha = smoothstep(-0.5, circle, -0.43);\n    \n    float mask = (tex1 + tex2) / 2.0f;\n    \n    float maskAplha = mask * alpha;\n    \n    vec4 col2 = vec4(mix(maskAplha, alpha, alpha));\n    //vec4 col = vec4(alpha);\n    fragColor+= col2;\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}