{
    "Shader": {
        "info": {
            "date": "1589411625",
            "description": "Perlin noise implementation",
            "flags": 0,
            "hasliked": 0,
            "id": "tsjBzz",
            "likes": 4,
            "name": "Perlin Noise Example",
            "published": 3,
            "tags": [
                "noise"
            ],
            "usePreview": 0,
            "username": "peterekepeter",
            "viewed": 744
        },
        "renderpass": [
            {
                "code": "\n// Defines\n\n#define COLOR_SKY vec3(.1,.2,.6)\n#define COLOR_CLOUDS vec3(.98,.96,.92)\n#define COLOR_LIGHT_SOMETHING vec3(.01,0.1,.11)*.1\n#define COLOR_DARK_SOMETHING vec3(.41,.71,.81)*2.0\n#define SCREEN_GAMMA 2.2\n\n// Function prototypes\n\nfloat hash(float value); // Produces random values\nfloat hash(vec2 value); // Produces random values\nmat2 rotate2D(float a); // Returns 2D rotation matrix\nfloat perlin_noise(vec2 position); // Single layer of perlin noise\nfloat fractal_perlin_noise(vec2 position, int octaves); // Multiple layers\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    vec2 uv = fragCoord/iResolution.yy;\n    vec2 position = uv;\n    \n\t// Rotate and translate the camera using some random sine waves\n\tposition*=rotate2D(iTime*.1)*pow(2.0,sin(iTime*.1));\n\tposition = position*7.0+sin(vec2(iTime, iTime+2.0));\n    \n    // This is where the texture is sampled.\n\tfloat noise_value = fractal_perlin_noise(position*.25, 16);\n\n    // Apply gradient 1 which makes it look like clouds\n    vec3 col = mix(COLOR_CLOUDS, COLOR_SKY, smoothstep(.2,.5,noise_value));\n\n    // Apply another gradient\n    vec3 col2 = mix(COLOR_LIGHT_SOMETHING, COLOR_DARK_SOMETHING, \n\t\tmix(noise_value,pow(abs(fract(noise_value*16.0+iTime*.5)-(.5))*2.0,16.0),.5));\n    \n    // Mix between the two gradients\n\tcol=mix(col,col2, smoothstep(-.4,.4, sin(iTime+uv.x*.2))); // comment out for clouds only\n    \n    // Gamma correction\n\tcol=pow(col, vec3(1.0/SCREEN_GAMMA));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\nmat2 rotate2D(float a){\n\tfloat c=cos(a), s=sin(a);\n\treturn mat2(c,s,-s,c);\n}\n\nfloat fractal_perlin_noise(vec2 position, int octaves){\n\tfloat value = 0.0;\n    // Sum together various layers of noise\n\tfor (int i=1; i<octaves; i++)\n\t{\n\t\tfloat scale = pow(2.0,float(i)); // At different scales\n\t\tfloat contrib = 1.0/scale; // Weighted accordint to scale\n\t\tvalue += perlin_noise(position*scale)*contrib;\n\t}\n\treturn value;\n}\n\n// https://en.wikipedia.org/wiki/Perlin_noise\nfloat perlin_noise(vec2 position){\n    // Fractional part is used for interpolation\n\tvec2 fractional_part = fract(position);\n    // Integral part is used for sampling the hash function\n\tvec2 integral_part = position-fractional_part;\n    \n    // Positon of the 4 nearest grid points\n\tvec2 pos_00 = integral_part+vec2(0,0);\n\tvec2 pos_10 = integral_part+vec2(1,0);\n\tvec2 pos_11 = integral_part+vec2(1,1);\n\tvec2 pos_01 = integral_part+vec2(0,1);\n\n\t// Random gradient angle for each point\n\tconst float pi = 3.1415926535;\n\tfloat ang_00=hash(pos_00)*2.0*pi;\n\tfloat ang_10=hash(pos_10)*2.0*pi;\n\tfloat ang_11=hash(pos_11)*2.0*pi;\n\tfloat ang_01=hash(pos_01)*2.0*pi;\n\n\t// Gradient vector for each point\n\tvec2 grad_00 = vec2(cos(ang_00), sin(ang_00));\n\tvec2 grad_10 = vec2(cos(ang_10), sin(ang_10));\n\tvec2 grad_11 = vec2(cos(ang_11), sin(ang_11));\n\tvec2 grad_01 = vec2(cos(ang_01), sin(ang_01));\n\n\t// Distance to each point\n\tvec2 dist_00 = vec2(0,0) - fractional_part;\n\tvec2 dist_10 = vec2(1,0) - fractional_part;\n\tvec2 dist_11 = vec2(1,1) - fractional_part;\n\tvec2 dist_01 = vec2(0,1) - fractional_part;\n\n\t// Dot products and interpolation\n\treturn mix(\n\t\tmix(dot(dist_00, grad_00),dot(dist_10, grad_10),smoothstep(0.0, 1.0, fractional_part.x)),\n\t\tmix(dot(dist_01, grad_01),dot(dist_11, grad_11),smoothstep(0.0, 1.0, fractional_part.x)),\n\t\tsmoothstep(0.0, 1.0, fractional_part.y)\n\t)*.5+.5;\n}\n\nfloat hash(vec2 v) \n{ \n    // Random numbers thrown together to produce other random numbers\n    return fract(hash(v.x*.97+v.y*.98)*143.94213); \n}\n\nfloat hash(float v) \n{ \n    // Even more pseudo randomness\n    return fract(fract(v*11.3334)*fract(v*91.73362341)*43.123*429.32234643);  \n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}