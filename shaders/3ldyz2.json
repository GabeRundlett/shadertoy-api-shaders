{
    "Shader": {
        "info": {
            "date": "1613020630",
            "description": "a late descendant of guil's playing marble https://www.shadertoy.com/view/MtX3Ws. i would really appreciate a space-like cubemap background :) any suggestion for better performance? i'm toying with dt inside raymarch loop, but the fractal is expensive...",
            "flags": 0,
            "hasliked": 0,
            "id": "3ldyz2",
            "likes": 12,
            "name": "galaxy in a bubble",
            "published": 3,
            "tags": [
                "3d",
                "fractal",
                "volumetric"
            ],
            "usePreview": 0,
            "username": "pnoqable",
            "viewed": 515
        },
        "renderpass": [
            {
                "code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by L. Haeussler 2021\n\nfloat powi( float b, int e )\n{\n    float result = b;\n    \n    int ae = abs( e );\n    for( int i = 1; i < ae; i++ )\n        result *= b;\n        \n    return e >= 0 ? result : 1. / result;\n}\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec3 sph, float radius ) // from iq\n{\n\tvec3 oc = ro - sph;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - radius*radius;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\nfloat map( in vec3 p )\n{\n\tfloat res = 0.;\n    \n    float v = .8 - .7 * powi( sin( 0.15 * iTime ), 3 );\n\t\n    vec3 c = p;\n\tfor( int i = 0; i < 10; ++i ) {\n        float dp = dot(p,p);\n        p = v * p.zyx*p.zyx/dp/sqrt(dp) - v;\n        p.xy = vec2( p.x*p.x - p.z*p.z, 2.*p.x*p.z );\n        res += exp( -12. * abs( dot( p, c ) ) );\n\t}\n    \n\treturn res;\n}\n\n\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax, float radius )\n{\n    vec3 result = vec3( 0 );\n    \n    float factor = 1. / radius;\n\n    float c = 1.;\n    float t = max( 0., tminmax.x );\n    float translucency = 1.;\n    for( int i=0; i<256; i++ )\n\t{\n        float dt = mix( 0.05, 0.01, step( 0.1, c ) );\n        \n        t += dt;\n        \n        if( t >= tminmax.y )\n            break;\n\n        vec3 pos = ro + t*rd;\n        \n        float corona = 1.;\n        corona -= factor * length( pos );\n        corona = 4. * corona * ( 1. - corona );\n        c = map( pos ) * corona;\n        \n        \n        float hilights = 1. - 0.95 * smoothstep( 0.9, 1.1, c );\n        result += translucency * dt * hilights * vec3( 5.1*c*c*c, 4.*c*c, 3.1*c );\n        translucency *= 1. - 1.2 * dt * c;\n        \n        if( translucency < 0.1 )\n            break;\n    }\n    return result * sqrt( result );\n}\n\nmat3 setCamera( vec3 ro, vec3 ta, vec3 wu )\n{\n\tvec3 cw = normalize(ta-ro),\n\t     cu = normalize( cross(cw,wu) ),\n\t     cv = cross(cu,cw);\n    return mat3( cu, cv, cw );\n}\n\nvec3 fromSpherical( vec3 s ) // vec3( phi, theta, radius )\n{\n    return s.z * vec3(sin(s.x)*cos(s.y), sin(s.y),\n                      cos(s.x)*cos(s.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = 2.*iMouse.xy/iResolution.xy-1.;\n    \n    if( max( iMouse.x, iMouse.y ) < 10. )\n        m = vec2( 0.1 * iTime, 0.1 * sin( 0.3 * iTime ) );\n    \n    // uncomment for lg cinema3d:\n    // m.x -= 0.01 * ( mod( fragCoord.y, 2. ) - 1. );\n    \n    // camera\n    vec3 ro = fromSpherical( vec3( 3.1*m.x, 1.5*m.y, 4. + 1. * sin( 0.2 * iTime ) ) );\n    mat3 ca = setCamera( ro, vec3( 0. ), vec3( 0., 1., 0. ) );\n    \n    // ray\n    vec3 rd = ca * normalize( vec3( p, 2. ) );\n\n    // intersection\n    float radius = 2. + .1 * sin( 1. * iTime );\n    vec2 tmm = iSphere( ro, rd, vec3(0.), radius );\n\n\t// background\n    vec3 col = texture(iChannel0, rd).rgb;\n    \n    // bubble\n    vec3 nor = normalize( ro + tmm.x * rd );\n    float spec = clamp( 1. + dot( nor, rd ), 0., 1. );\n\n    // raymarch\n    vec3 innerColor = raymarch( ro, rd, tmm, radius );\n    vec3 bubble = mix( innerColor, col, spec*spec*spec ) ;\n\n    // reflection\n    vec3 reflection = texture( iChannel0, reflect( rd, nor ) ).rgb;        \n    bubble = mix( bubble, vec3(.9, .6, 1.9) * reflection, powi( spec, 2 ) );\n    \n    // anti alias\n    float r = sqrt( dot( ro, ro ) - powi( dot( ro, rd ), 2 ) );\n    col = mix( col, bubble, smoothstep( 0., 2. * fwidth( r ), radius-r ) );\n\t\n\t// shade\n    col = 1. - exp( -col );\n    fragColor = vec4( col, 1.0 );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}