{
    "Shader": {
        "info": {
            "date": "1551991877",
            "description": "C1-continuous interpolation of fields defined on adaptive grids such as quadtrees, part of the paper \"Interactive Visualization of Flood and Heavy Rain Simulations\" by D. Cornel et al. 2019.",
            "flags": 32,
            "hasliked": 0,
            "id": "WsXXRf",
            "likes": 54,
            "name": "Adaptive Grid Interpolation",
            "published": 3,
            "tags": [
                "bicubic",
                "interpolation",
                "bilinear",
                "bspline",
                "nearestneighbor"
            ],
            "usePreview": 0,
            "username": "drivenbynostalgia",
            "viewed": 3071
        },
        "renderpass": [
            {
                "code": "//=================================================================================================\n/**\n*\tC1-continuous interpolation of scalar and vector fields defined on adaptive grids.\n*\n*\tThis code is part of the paper \"Interactive Visualization of Flood and Heavy Rain Simulations\"\n*\tby Daniel Cornel^1, Andreas Buttinger-Kreuzhuber^{1,2}, Artem Konev^1, Zsolt Horváth^{1,2},\n*\tMichael Wimmer^2, Raimund Heidrich^3, and Jürgen Waser^1, presented at EuroVis 2019.\n*\n*\t^1 VRVis Zentrum für Virtual Reality und Visualisierung Forschungs-GmbH, Vienna, Austria\n*\t^2 TU Wien, Vienna, Austria\n*\t^3 RIOCOM Ingenieurbüro für Kulturtechnik und Wasserwirtschaft, Vienna, Austria\n*\n*\tPaper preprint: http://visdom.at/media/pdf/publications/Interactive_Visualization_of_Flood_and_Heavy_Rain_Simulations.pdf\n**/\n//=================================================================================================\n\n\n\n\n//=================================================================================================\n/**\n*\tShadertoy parameters\n**/\n//=================================================================================================\n\n// Switch between interpolation modi\n\n//#define CurrentInterpolationMode NearestNeighbor\n//#define CurrentInterpolationMode Bilinear\n//#define CurrentInterpolationMode Bicubic\n#define CurrentInterpolationMode BSpline\n\n// Show/hide cell grid\n\n#define SHOW_GRID\n\n// Use discrete/continuous transfer function\n\n#define DISCRETE_TRAFO\n\n\n\n\n//=================================================================================================\n/**\n*\tHelper functions\n**/\n//=================================================================================================\n\n// Returns the missing quadrants in the current level for the interpolation patch\n// defined by the provided bottom left grid index\nint getMissingQuadrants(ivec3 bottomLeftGridIndex)\n{\n\tivec2 gridExtents = getDimensionsOfLevel(bottomLeftGridIndex.z) - 1;\n\n\tivec4 gridIndices = ivec4(clamp(bottomLeftGridIndex.xyxy + ivec4(0, 0, 1, 1), ivec4(0), gridExtents.xyxy));\n\tivec3 retrievedGridIndex;\n\n\tint nodeIndex0 = getLeafNodeIndex(ivec3(gridIndices.xy, bottomLeftGridIndex.z), retrievedGridIndex);\n\tint missingQuadrants = ((nodeIndex0 != -1) && (retrievedGridIndex.z < bottomLeftGridIndex.z)) ? 1 : 0;\n\n\tint nodeIndex1 = getLeafNodeIndex(ivec3(gridIndices.zy, bottomLeftGridIndex.z), retrievedGridIndex);\n\tmissingQuadrants |= ((nodeIndex1 != -1) && (retrievedGridIndex.z < bottomLeftGridIndex.z)) ? 2 : 0;\n\n\tint nodeIndex2 = getLeafNodeIndex(ivec3(gridIndices.xw, bottomLeftGridIndex.z), retrievedGridIndex);\n\tmissingQuadrants |= ((nodeIndex2 != -1) && (retrievedGridIndex.z < bottomLeftGridIndex.z)) ? 4 : 0;\n\n\tint nodeIndex3 = getLeafNodeIndex(ivec3(gridIndices.zw, bottomLeftGridIndex.z), retrievedGridIndex);\n\tmissingQuadrants |= ((nodeIndex3 != -1) && (retrievedGridIndex.z < bottomLeftGridIndex.z)) ? 8 : 0;\n\n\treturn missingQuadrants;\n}\n\n// Returns the missing quadrants in the current and the next coarser levels\n// for the interpolation patch defined by the provided bottom left grid index\nivec2 getMissingQuadrantsFineAndCoarse(ivec3 bottomLeftGridIndex)\n{\n\tivec2 gridExtents = getDimensionsOfLevel(bottomLeftGridIndex.z) - 1;\n\tivec4 gridIndices = ivec4(clamp(bottomLeftGridIndex.xyxy + ivec4(0, 0, 1, 1), ivec4(0), gridExtents.xyxy));\n\n\tivec3 quadrantGridIndices[4];\n\tivec4 quadrantNodeIndices;\n\n\tquadrantNodeIndices.x = getLeafNodeIndex(ivec3(gridIndices.xy, bottomLeftGridIndex.z), quadrantGridIndices[0]);\n\tquadrantNodeIndices.y = getLeafNodeIndex(ivec3(gridIndices.zy, bottomLeftGridIndex.z), quadrantGridIndices[1]);\n\tquadrantNodeIndices.z = getLeafNodeIndex(ivec3(gridIndices.xw, bottomLeftGridIndex.z), quadrantGridIndices[2]);\n\tquadrantNodeIndices.w = getLeafNodeIndex(ivec3(gridIndices.zw, bottomLeftGridIndex.z), quadrantGridIndices[3]);\n\n\tivec4 quadrantLevels = ivec4(quadrantGridIndices[0].z, quadrantGridIndices[1].z, quadrantGridIndices[2].z, quadrantGridIndices[3].z);\n\tbvec4 levelLess = lessThan(quadrantLevels, ivec4(bottomLeftGridIndex.z));\n\tbvec4 levelGreaterEqual = greaterThanEqual(quadrantLevels, ivec4(bottomLeftGridIndex.z));\n\tbvec4 validNodeIndex = notEqual(quadrantNodeIndices, ivec4(-1));\n\n\tivec2 missingQuadrants = ivec2(((validNodeIndex.x) && (levelLess.x)) ? 1 : 0, ((validNodeIndex.x) && (levelGreaterEqual.x)) ? 1 : 0);\n\tmissingQuadrants |= ivec2(((validNodeIndex.y) && (levelLess.y)) ? 2 : 0, ((validNodeIndex.y) && (levelGreaterEqual.y)) ? 2 : 0);\n\tmissingQuadrants |= ivec2(((validNodeIndex.z) && (levelLess.z)) ? 4 : 0, ((validNodeIndex.z) && (levelGreaterEqual.z)) ? 4 : 0);\n\tmissingQuadrants |= ivec2(((validNodeIndex.w) && (levelLess.w)) ? 8 : 0, ((validNodeIndex.w) && (levelGreaterEqual.w)) ? 8 : 0);\n\n\treturn missingQuadrants;\n}\n\nconst ivec3 quadrantMasks[4] = ivec3[](ivec3(4, 2, 1), ivec3(8, 1, 2), ivec3(1, 8, 4), ivec3(2, 4, 8));\n\n// Returns weights for bilinear blending within the blending region\n// based on the arrangement of cells of different levels\nvec4 getBlendingWeights(bvec3 neighborFlags, ivec2 bottomLeftOffset)\n{\n\t// Given the restriction that neighboring cells must not differ by more than one level,\n\t// all possible arrangements of cells can be enumerated to precompute the weights in the\n\t// corners of the transition region. This is just an efficient way of saying \"zero if\n\t// the corner is covered by a coarser-level cell, else 1\".\n\n\tconst int[] weightBitsArray = int[](\n\t\t14, 11, 13, 7, 6, 9, 9, 6,\n\t\t10, 10, 5, 5, 2, 8, 1, 4,\n\t\t12, 3, 12, 3, 4, 1, 8, 2,\n\t\t8, 2, 4, 1, 0, 0, 0, 0);\n\n\tint i = (int(neighborFlags.x) << 4) + (int(neighborFlags.y) << 3) + (int(neighborFlags.z) << 2) + ((bottomLeftOffset.x + 1) << 1) + (bottomLeftOffset.y + 1);\n\tint weightBits = int(weightBitsArray[i]);\n\n\treturn vec4((weightBits & 8) >> 3, (weightBits & 4) >> 2, (weightBits & 2) >> 1, weightBits & 1);\n}\n\n// Calculates a transition region between cells of two different resolutions\n// and linearly combines the interpolated values of both levels with a\n// Hermite spline weight, which makes the result C1-continuous\nfloat smoothCombine(\n\tvec2 position,\n\tivec3 fineLevelGridIndex,\n\tivec3 fineLevelBottomLeftGridIndex,\n\tivec2 fineLevelBottomLeftOffset,\n\tint fineLevelMissingQuadrants,\n\tfloat valueFine,\n\tfloat valueCoarse,\n\tbool fineToCoarse)\n{\n\tivec3 quadrantMask = quadrantMasks[(fineLevelBottomLeftOffset.y << 1) + fineLevelBottomLeftOffset.x + 3];\n\tbvec3 neighborFlags = equal(fineLevelMissingQuadrants & quadrantMask, quadrantMask);\n\n\tif (fineToCoarse)\n\t{\n\t\tneighborFlags = not(neighborFlags);\n\t}\n\n\tvec4 blendingWeights = getBlendingWeights(neighborFlags, fineLevelBottomLeftOffset);\n\n\tif (fineToCoarse)\n\t{\n\t\tblendingWeights = 1.0 - blendingWeights;\n\t}\n\n\tvec2 relativePosition = (position - gOrigin) * getInverseCellSizeOfLevel(fineLevelGridIndex.z) - vec2(fineLevelBottomLeftGridIndex.xy) - 0.5;\n\n\tvec2 horizontalWeights = mix(blendingWeights.xz, blendingWeights.yw, relativePosition.x);\n\n\tfloat t = mix(horizontalWeights.x, horizontalWeights.y, relativePosition.y);\n\n\treturn mix(valueCoarse, valueFine, smoothstep(0.0, 1.0, t));\n}\n\n// Fetches the (possibly reconstructed) data value from the \"multi-level texture\",\n// the Buffers B, C, and D\nfloat getDataValue(int x, int y, int level)\n{\n    ivec2 gridIndex = clamp(ivec2(x, y), ivec2(0), getDimensionsOfLevel(level) - 1);\n    \n    if (level == 0)\n    {\n    \treturn texelFetch(iChannel0, gridIndex, 0).x;\n    }\n    else if (level == 1)\n    {\n    \treturn texelFetch(iChannel1, gridIndex, 0).x;\n    }\n    else if (level == 2)\n    {\n    \treturn texelFetch(iChannel2, gridIndex, 0).x;\n    }\n    else\n    {\n        return -1.0;\n    }\n}\n\n// Usual B-spline interpolation on a single level. For simplicity,\n// the texture lookups are very naive and therefore quite inefficient.\n// If only using scalar fields, they should be replaced by textureGather.\nfloat interpolateBSpline(vec2 samplePosition, ivec3 bottomLeftGridIndex)\n{\n    int level = bottomLeftGridIndex.z;\n\tivec4 xIndices = bottomLeftGridIndex.xxxx + ivec4(-1, 0, 1, 2);\n\tivec4 yIndices = bottomLeftGridIndex.yyyy + ivec4(-1, 0, 1, 2);\n\n\tfloat v0 = getDataValue(xIndices.x, yIndices.x, level);\n\tfloat v1 = getDataValue(xIndices.y, yIndices.x, level);\n\tfloat v2 = getDataValue(xIndices.z, yIndices.x, level);\n\tfloat v3 = getDataValue(xIndices.w, yIndices.x, level);\n\n\tfloat v4 = getDataValue(xIndices.x, yIndices.y, level);\n\tfloat v5 = getDataValue(xIndices.y, yIndices.y, level);\n\tfloat v6 = getDataValue(xIndices.z, yIndices.y, level);\n\tfloat v7 = getDataValue(xIndices.w, yIndices.y, level);\n\n\tfloat v8 = getDataValue(xIndices.x, yIndices.z, level);\n\tfloat v9 = getDataValue(xIndices.y, yIndices.z, level);\n\tfloat v10 = getDataValue(xIndices.z, yIndices.z, level);\n\tfloat v11 = getDataValue(xIndices.w, yIndices.z, level);\n\n\tfloat v12 = getDataValue(xIndices.x, yIndices.w, level);\n\tfloat v13 = getDataValue(xIndices.y, yIndices.w, level);\n\tfloat v14 = getDataValue(xIndices.z, yIndices.w, level);\n\tfloat v15 = getDataValue(xIndices.w, yIndices.w, level);\n\n\tvec2 relativeSamplePosition = (samplePosition - gOrigin) * getInverseCellSizeOfLevel(level);\n\tvec2 relativeCellCenter = vec2(bottomLeftGridIndex.xy) + 0.5;\n\tvec2 f = relativeSamplePosition - relativeCellCenter;\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\n\tvec2 oneMinusF = 1.0 - f;\n\tvec2 oneMinusF2 = oneMinusF * oneMinusF;\n\tvec2 oneMinusF3 = oneMinusF2 * oneMinusF;\n\n\tconst vec2 ONE_OVER_SIX_VEC2 = vec2(1.0 / 6.0);\n\tconst vec2 ONE_OVER_TWO_VEC2 = vec2(1.0 / 2.0);\n\tconst vec2 TWO_OVER_THREE_VEC2 = vec2(2.0 / 3.0);\n\n\tvec2 w0 = ONE_OVER_SIX_VEC2 * oneMinusF3;\n\tvec2 w1 = ONE_OVER_TWO_VEC2 * f3 - f2 + TWO_OVER_THREE_VEC2;\n\tvec2 w2 = ONE_OVER_TWO_VEC2 * oneMinusF3 - oneMinusF2 + TWO_OVER_THREE_VEC2;\n\tvec2 w3 = ONE_OVER_SIX_VEC2 * f3;\n\n\treturn w0.y * (w0.x * v0 + w1.x * v1 + w2.x * v2 + w3.x * v3) +\n\t\tw1.y * (w0.x * v4 + w1.x * v5 + w2.x * v6 + w3.x * v7) +\n\t\tw2.y * (w0.x * v8 + w1.x * v9 + w2.x * v10 + w3.x * v11) +\n\t\tw3.y * (w0.x * v12 + w1.x * v13 + w2.x * v14 + w3.x * v15);\n}\n\n// Usual Catmull-Rom interpolation on a single level. For simplicity,\n// the texture lookups are very naive and therefore quite inefficient.\n// If only using scalar fields, they should be replaced by textureGather.\nfloat interpolateBicubic(vec2 samplePosition, ivec3 bottomLeftGridIndex)\n{\n\tint level = bottomLeftGridIndex.z;\n\tivec4 xIndices = bottomLeftGridIndex.xxxx + ivec4(-1, 0, 1, 2);\n\tivec4 yIndices = bottomLeftGridIndex.yyyy + ivec4(-1, 0, 1, 2);\n\n\tfloat v0 = getDataValue(xIndices.x, yIndices.x, level);\n\tfloat v1 = getDataValue(xIndices.y, yIndices.x, level);\n\tfloat v2 = getDataValue(xIndices.z, yIndices.x, level);\n\tfloat v3 = getDataValue(xIndices.w, yIndices.x, level);\n\n\tfloat v4 = getDataValue(xIndices.x, yIndices.y, level);\n\tfloat v5 = getDataValue(xIndices.y, yIndices.y, level);\n\tfloat v6 = getDataValue(xIndices.z, yIndices.y, level);\n\tfloat v7 = getDataValue(xIndices.w, yIndices.y, level);\n\n\tfloat v8 = getDataValue(xIndices.x, yIndices.z, level);\n\tfloat v9 = getDataValue(xIndices.y, yIndices.z, level);\n\tfloat v10 = getDataValue(xIndices.z, yIndices.z, level);\n\tfloat v11 = getDataValue(xIndices.w, yIndices.z, level);\n\n\tfloat v12 = getDataValue(xIndices.x, yIndices.w, level);\n\tfloat v13 = getDataValue(xIndices.y, yIndices.w, level);\n\tfloat v14 = getDataValue(xIndices.z, yIndices.w, level);\n\tfloat v15 = getDataValue(xIndices.w, yIndices.w, level);\n\n\tvec2 relativeSamplePosition = (samplePosition - gOrigin) * getInverseCellSizeOfLevel(level);\n\tvec2 relativeCellCenter = vec2(bottomLeftGridIndex.xy) + 0.5;\n\tvec2 f = relativeSamplePosition - relativeCellCenter;\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\n\tvec2 w0 = -0.5 * (f3 + f) + f2;\n\tvec2 w1 = 1.5 * f3 - 2.5 * f2 + 1.0;\n\tvec2 w2 = -1.5 * f3 + 2.0 * f2 + 0.5 * f;\n\tvec2 w3 = 0.5 * (f3 - f2);\n\n\treturn w0.y * (w0.x * v0 + w1.x * v1 + w2.x * v2 + w3.x * v3) +\n\t\tw1.y * (w0.x * v4 + w1.x * v5 + w2.x * v6 + w3.x * v7) +\n\t\tw2.y * (w0.x * v8 + w1.x * v9 + w2.x * v10 + w3.x * v11) +\n\t\tw3.y * (w0.x * v12 + w1.x * v13 + w2.x * v14 + w3.x * v15);\n}\n\n// Usual bilinear interpolation on a single level. If your underlying\n// data structure is an actual OpenGL texture, this can be done by\n// hardware filtering.\nfloat interpolateBilinear(vec2 samplePosition, ivec3 bottomLeftGridIndex)\n{\n\tint level = bottomLeftGridIndex.z;\n    \n\tfloat v0 = getDataValue(bottomLeftGridIndex.x, bottomLeftGridIndex.y, level);\n\tfloat v1 = getDataValue(bottomLeftGridIndex.x + 1, bottomLeftGridIndex.y, level);\n\tfloat v2 = getDataValue(bottomLeftGridIndex.x, bottomLeftGridIndex.y + 1, level);\n\tfloat v3 = getDataValue(bottomLeftGridIndex.x + 1, bottomLeftGridIndex.y + 1, level);\n\n\tvec2 relativeSamplePosition = (samplePosition - gOrigin) * getInverseCellSizeOfLevel(level);\n\tvec2 relativeCellCenter = vec2(bottomLeftGridIndex.xy) + 0.5;\n\tvec2 f = relativeSamplePosition - relativeCellCenter;\n\n\treturn mix(mix(v0, v1, f.x), mix(v2, v3, f.x), f.y);\n}\n\n//=================================================================================================\n/**\n*\tThe adaptive interpolation function you came here to see\n**/\n//=================================================================================================\n\n// If all values required for interpolation are defined on the same grid level,\n// this function is equivalent to interpolation on a regular grid.\n// If the interpolation patch spans over a level discontinuity, it is necessary\n// to interpolate twice for the two different levels and then combine the\n// results to a single value. The combination is done by blending with a\n// Hermite spline weight, which makes the result C1-continuous.\nfloat sampleField(ivec3 gridIndex, vec2 position)\n{\n    int level = gridIndex.z;\n\n#if (CurrentInterpolationMode == NearestNeighbor)\n    ivec2 gridDimensions = getDimensionsOfLevel(level);\n\n\treturn getDataValue(gridIndex.x, gridIndex.y, level);\n#else\n\tvec2 fineNodePosition = getNodePosition(gridIndex);\n\tivec2 fineBottomLeftOffset = mixIvec2Bool(ivec2(0), ivec2(-1), lessThanEqual(position, fineNodePosition));\n\tivec3 fineBottomLeftGridIndex = ivec3(gridIndex.xy + fineBottomLeftOffset, level);\n\n\tivec2 missingQuadrants = getMissingQuadrantsFineAndCoarse(fineBottomLeftGridIndex);\n\tint fineMissingQuadrants = missingQuadrants.x;\n\n    // Regular interpolation on the first grid\n\n#if (CurrentInterpolationMode == Bilinear)\n\tfloat valueFine = interpolateBilinear(position, fineBottomLeftGridIndex);\n#elif (CurrentInterpolationMode == Bicubic)\n\tfloat valueFine = interpolateBicubic(position, fineBottomLeftGridIndex);\n#elif (CurrentInterpolationMode == BSpline)\n\tfloat valueFine = interpolateBSpline(position, fineBottomLeftGridIndex);\n#endif\n\n\tbool hasMissingCoarseQuadrants = (fineMissingQuadrants != 0);\n\tbool hasMissingFineQuadrants = (level < gNumGrids - 1) && (missingQuadrants.y != 0);\n\tbool coarseToFine = (!hasMissingCoarseQuadrants) && (hasMissingFineQuadrants);\n\tbool noBlending = (!hasMissingCoarseQuadrants) && (!hasMissingFineQuadrants);\n\n\tif (noBlending)\n\t{\n        // No values have been missing, return regularly interpolated result\n        \n\t\treturn valueFine;\n\t}\n\telse\n\t{\n        // Some values have been missing, interpolate at the same position on the second grid as well\n        \n\t\tivec3 fineGridIndex = gridIndex;\n\t\tivec3 otherLevelGridIndex;\n\t\tfloat valueCoarse;\n\n\t\tif (coarseToFine)\n\t\t{\n\t\t\tvalueCoarse = valueFine;\n\n\t\t\tivec2 fineCellQuadrantOffset = mixIvec2Bool(ivec2(0), ivec2(1), greaterThan(position, fineNodePosition));\n\n\t\t\totherLevelGridIndex = ivec3(gridIndex.xy << 1, level + 1) + ivec3(fineCellQuadrantOffset, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\totherLevelGridIndex = ivec3(gridIndex.xy >> 1, level - 1);\n\t\t}\n\n\t\tvec2 otherLevelCenterPosition = getNodePosition(otherLevelGridIndex);\n\t\tivec2 otherLevelBottomLeftOffset = mixIvec2Bool(ivec2(0), ivec2(-1), lessThanEqual(position, otherLevelCenterPosition));\n\t\tivec3 otherLevelBottomLeftGridIndex = ivec3(otherLevelGridIndex.xy + otherLevelBottomLeftOffset, otherLevelGridIndex.z);\n\n\t\tif (coarseToFine)\n\t\t{\n\t\t\tfineGridIndex = otherLevelGridIndex;\n\t\t\tfineBottomLeftOffset = otherLevelBottomLeftOffset;\n\t\t\tfineBottomLeftGridIndex = otherLevelBottomLeftGridIndex;\n\t\t\tfineMissingQuadrants = getMissingQuadrants(otherLevelBottomLeftGridIndex);\n\t\t}\n        \n        // Regular interpolation on the second grid\n\n#if (CurrentInterpolationMode == Bilinear)\n\t\tfloat otherValue = interpolateBilinear(position, otherLevelBottomLeftGridIndex);\n#elif (CurrentInterpolationMode == Bicubic)\n\t\tfloat otherValue = interpolateBicubic(position, otherLevelBottomLeftGridIndex);\n#elif (CurrentInterpolationMode == BSpline)\n\t\tfloat otherValue = interpolateBSpline(position, otherLevelBottomLeftGridIndex);\n#endif\n\n\t\tif (coarseToFine)\n\t\t{\n\t\t\tvalueFine = otherValue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvalueCoarse = otherValue;\n\t\t}\n        \n        // Smoothly combine the two interpolated values within the transition region\n\n\t\treturn smoothCombine(\n\t\t\tposition,\n\t\t\tfineGridIndex,\n\t\t\tfineBottomLeftGridIndex,\n\t\t\tfineBottomLeftOffset,\n\t\t\tfineMissingQuadrants,\n\t\t\tvalueFine,\n\t\t\tvalueCoarse,\n\t\t\t!coarseToFine);\n\t}\n#endif\n}\n\n// Transfer function\nvec4 mapToRGB(float value)\n{\n    // Color map generated with ColorBrewer\n    // http://colorbrewer2.org/#type=sequential&scheme=YlGnBu&n=9\n    const vec4[] colors = vec4[](\n        vec4(255.0, 255.0, 217.0, 255.0) / 255.0,\n        vec4(237.0, 248.0, 177.0, 255.0) / 255.0,\n        vec4(199.0, 233.0, 180.0, 255.0) / 255.0,\n        vec4(127.0, 205.0, 187.0, 255.0) / 255.0,\n        vec4(65.0, 182.0, 196.0, 255.0) / 255.0,\n        vec4(29.0, 145.0, 192.0, 255.0) / 255.0,\n        vec4(34.0, 94.0, 168.0, 255.0) / 255.0,\n        vec4(37.0, 52.0, 148.0, 255.0) / 255.0,\n        vec4(8.0, 29.0, 88.0, 255.0) / 255.0);\n    \n    int intervals = colors.length() - 1;\n    \n    float t = clamp(value, 0.0, 1.0) * float(intervals);\n    int interval = clamp(int(t), 0, intervals);\n\n    if (value == -1.0)\n    {\n        return vec4(1.0, 0.5, 0.5, 1.0);\n    }\n\n#ifdef DISCRETE_TRAFO\n    t = smoothstep(0.48, 0.52, fract(t));\n#else\n    t = fract(t);\n#endif\n    \n\treturn mix(colors[interval], colors[interval + 1], t);\n}\n\n// This function determines whether the current fragment is at a cell border\n// in the most inefficient way, traversing the quadtree twice more.\nfloat gridIntensity(vec2 fragCoord, int nodeIndex)\n{\n    if ((any(lessThanEqual(ivec2(fragCoord), ivec2(0)))) ||\n        (any(greaterThanEqual(ivec2(fragCoord), ivec2(iResolution.xy - 1.0)))))\n    {\n        return 1.0;\n    }\n    else\n    {\n        ivec3 temp;\n        ivec2 neighborNodeIndices = ivec2(\n\t\t\tgetLeafNodeIndex(mix(gOrigin, gUpper, vec2(fragCoord.x - 1.0, fragCoord.y) / iResolution.xy), temp),\n            getLeafNodeIndex(mix(gOrigin, gUpper, vec2(fragCoord.x, fragCoord.y - 1.0) / iResolution.xy), temp));\n                \n        return (any(notEqual(neighborNodeIndices, ivec2(nodeIndex)))) ? 1.0 : 0.0;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 worldSpacePosition = mix(gOrigin, gUpper, uv);\n    \n    ivec3 gridIndex;\n\tint nodeIndex = getLeafNodeIndex(worldSpacePosition, gridIndex);\n\tint cellIndex = convertNodeToCellIndex(nodeIndex);\n    \n    if (cellIndex < 0)\n    {\n        // In a real application, traversal with getLeafNodeIndex will not succeed\n        // if sampling outside the grid, so this case has to be handled somehow.\n        \n        fragColor = vec4(1.0, 0.5, 0.5, 1.0);\n    }\n    else\n    {\n    \tfloat interpolatedValue = sampleField(gridIndex, worldSpacePosition);\n\n    \tfragColor = mapToRGB(interpolatedValue);\n\n#ifdef SHOW_GRID\n        fragColor = mix(fragColor, vec4(0.0, 0.0, 0.0, 1.0), 0.5 * gridIntensity(fragCoord, nodeIndex));\n#endif        \n\t}\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// The purpose of Buffer A in this example is to provide data values to the reconstruction shaders.\n// One value per cell is provided in stored in a 1D-buffer like fashion. In a real application,\n// this buffer is provided by the host application whenever the data field changes.\n\nfloat rand(float p)\n{\n\tp = fract(p * 0.1031);\n\tp += 3.0 * p * (p + 19.19);\n\n\treturn fract(2.0 * p * p);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 bufferSize = ivec2(iResolution.xy);\n    ivec2 texel = ivec2(fragCoord);\n    int dataIndex = texel.y * bufferSize.x + texel.x;\n\n    if (dataIndex < gNumCells)\n    {\n        fragColor = vec4(0.5 * sin(0.05 * iTime + 13.37 * rand(float(dataIndex))) + 0.5, 0.0, 0.0, 1.0);\n    }\n    else\n    {\n        fragColor = vec4(1.0, 0.5, 0.5, 1.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// In this example, Buffer B serves as one level of a multi-level texture, i.e., a mipmap level.\n// Buffer B corresponds to level 0 of the quadtree, i.e., the level of the coarsest resolution.\n// It holds all values of level-0 cells as well as all values downsampled from higher-level cells\n// that the remaining level-0 nodes cover. In a real application, this step should be done with a\n// compute shader, but for shadertoy, this will suffice.\n// Also, reconstruction in this example is performed for every texel of the texture, which is not\n// necessary. When using bilinear interpolation, only the directly neighboring texels of cells on\n// that level have to be reconstructed, i.e., the 3x3 neighborhood around each cell. For bicubic\n// interpolation or B-spline approximation, the neighbors' direct neighbors also need to be\n// reconstructed, i.e., the 5x5 neighborhood around each cell.\n\n// Note: The code for Buffers B, C, and D is almost identical (and should be in an application),\n// except for the upsampling step missing on level 0.\n\n#define LEVEL 0\n\nivec2 cellIndexToTexel(int cellIndex)\n{\n    ivec2 dataBufferDimensions = textureSize(iChannel0, 0);\n    \n    return ivec2(cellIndex % dataBufferDimensions.x, cellIndex / dataBufferDimensions.x);\n}\n\nfloat fetchValue(int cellIndex)\n{\n\treturn texelFetch(iChannel0, cellIndexToTexel(cellIndex), 0).x;\n}\n\nfloat getDownsampledValue(ivec3 gridIndex, int nodeIndex)\n{\n    const int highestLevel = gNumGrids - 1;\n    int lowestLevel = gridIndex.z + 1;\n    \n\tint coveredCells = 2 << (highestLevel - lowestLevel);\n    ivec3 gridIndexOnLevel = ivec3(gridIndex.xy * coveredCells, highestLevel);\n    \n    float summedValues = 0.0;\n    \n    for (int y = 0; y < coveredCells; y++)\n    {\n    \tfor (int x = 0; x < coveredCells; x++)\n        {\n            ivec3 currentGridIndex = gridIndexOnLevel + ivec3(x, y, 0);\n        \tivec3 retrievedGridIndex;\n    \t\tint nodeIndex = getLeafNodeIndex(currentGridIndex, retrievedGridIndex);\n        \tint cellIndex = convertNodeToCellIndex(nodeIndex);\n            \n            summedValues += fetchValue(cellIndex);\n        }\n    }\n    \n    return summedValues / float(coveredCells * coveredCells);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 levelDimensions = getDimensionsOfLevel(LEVEL);\n    ivec3 gridIndex = ivec3(ivec2(fragCoord), LEVEL);\n    \n    if (all(lessThan(gridIndex.xy, levelDimensions)))\n    {\n    \tivec3 retrievedGridIndex;\n    \tint nodeIndex = getLeafNodeIndex(gridIndex, retrievedGridIndex);\n        int cellIndex = convertNodeToCellIndex(nodeIndex);\n        \n        float value = 0.0;\n\n        if (cellIndex < 0)\n        {\n            // The node has child nodes, downsample their values\n            \n            value = getDownsampledValue(gridIndex, nodeIndex);\n        }\n        else\n        {\n        \t// The node is a leaf node, fetch its data value\n                \n            value = fetchValue(cellIndex);\n        }\n        \n        fragColor = vec4(value, 0.0, 0.0, 1.0);\n    }\n    else\n    {\n     \tfragColor = vec4(-1.0, 0.0, 0.0, 1.0);   \n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// In this example, Buffer C serves as one level of a multi-level texture, i.e., a mipmap level.\n// Buffer C corresponds to level 1 of the quadtree, i.e., the level of the second-coarsest resolution.\n// It holds all values of level-1 cells as well as all values downsampled from higher-level cells\n// that the remaining level-1 nodes cover and all values upsampled from level-0 cells. In a real\n// application, this step should be done with a compute shader, but for shadertoy, this will suffice.\n// Also, reconstruction in this example is performed for every texel of the texture, which is not\n// necessary. When using bilinear interpolation, only the directly neighboring texels of cells on\n// that level have to be reconstructed, i.e., the 3x3 neighborhood around each cell. For bicubic\n// interpolation or B-spline approximation, the neighbors' direct neighbors also need to be\n// reconstructed, i.e., the 5x5 neighborhood around each cell.\n\n// Note: The code for Buffers B, C, and D is almost identical (and should be in an application),\n// except for the upsampling step missing on level 0.\n\n#define LEVEL 1\n\nivec2 cellIndexToTexel(int cellIndex)\n{\n    ivec2 dataBufferDimensions = textureSize(iChannel0, 0);\n    \n    return ivec2(cellIndex % dataBufferDimensions.x, cellIndex / dataBufferDimensions.x);\n}\n\nfloat fetchValue(int cellIndex)\n{\n\treturn texelFetch(iChannel0, cellIndexToTexel(cellIndex), 0).x;\n}\n\nfloat getDownsampledValue(ivec3 gridIndex, int nodeIndex)\n{\n    const int highestLevel = gNumGrids - 1;\n    int lowestLevel = gridIndex.z + 1;\n    \n\tint coveredCells = 2 << (highestLevel - lowestLevel);\n    ivec3 gridIndexOnLevel = ivec3(gridIndex.xy * coveredCells, highestLevel);\n    \n    float summedValues = 0.0;\n    \n    for (int y = 0; y < coveredCells; y++)\n    {\n    \tfor (int x = 0; x < coveredCells; x++)\n        {\n            ivec3 currentGridIndex = gridIndexOnLevel + ivec3(x, y, 0);\n        \tivec3 retrievedGridIndex;\n    \t\tint nodeIndex = getLeafNodeIndex(currentGridIndex, retrievedGridIndex);\n        \tint cellIndex = convertNodeToCellIndex(nodeIndex);\n            \n            summedValues += fetchValue(cellIndex);\n        }\n    }\n    \n    return summedValues / float(coveredCells * coveredCells);\n}\n\n#if (LEVEL > 0)\nfloat getUpsampledValue(ivec3 gridIndex, int cellIndex, int quadrant)\n{\n\tivec3 quadrantGridIndex = ivec3((gridIndex.xy << 1) + ivec2(quadrant & 1, (quadrant & 2) >> 1), gridIndex.z + 1);\n\n\tivec2 gridExtents = getDimensionsOfLevel(gridIndex.z) - 1;\n\n\tivec3 bottomLeftGridIndex = gridIndex;\n\tivec3 bottomRightGridIndex = gridIndex;\n\tivec3 topLeftGridIndex = gridIndex;\n\tivec3 topRightGridIndex = gridIndex;\n\n\tvec2 relativePosition;\n\n\tif (quadrant == 0)\n\t{\n\t\tbottomLeftGridIndex.xy = clamp(bottomLeftGridIndex.xy + ivec2(-1, -1), ivec2(0), gridExtents);\n\t\tbottomRightGridIndex.xy = clamp(bottomRightGridIndex.xy + ivec2(0, -1), ivec2(0), gridExtents);\n\t\ttopLeftGridIndex.xy = clamp(topLeftGridIndex.xy + ivec2(-1, 0), ivec2(0), gridExtents);\n\t\ttopRightGridIndex.xy = clamp(topRightGridIndex.xy + ivec2(0, 0), ivec2(0), gridExtents);\n\n\t\trelativePosition = vec2(0.75, 0.75);\n\t}\n\telse if (quadrant == 1)\n\t{\n\t\tbottomLeftGridIndex.xy = clamp(bottomLeftGridIndex.xy + ivec2(0, -1), ivec2(0), gridExtents);\n\t\tbottomRightGridIndex.xy = clamp(bottomRightGridIndex.xy + ivec2(1, -1), ivec2(0), gridExtents);\n\t\ttopLeftGridIndex.xy = clamp(topLeftGridIndex.xy + ivec2(0, 0), ivec2(0), gridExtents);\n\t\ttopRightGridIndex.xy = clamp(topRightGridIndex.xy + ivec2(1, 0), ivec2(0), gridExtents);\n\n\t\trelativePosition = vec2(0.25, 0.75);\n\t}\n\telse if (quadrant == 2)\n\t{\n\t\tbottomLeftGridIndex.xy = clamp(bottomLeftGridIndex.xy + ivec2(-1, 0), ivec2(0), gridExtents);\n\t\tbottomRightGridIndex.xy = clamp(bottomRightGridIndex.xy + ivec2(0, 0), ivec2(0), gridExtents);\n\t\ttopLeftGridIndex.xy = clamp(topLeftGridIndex.xy + ivec2(-1, 1), ivec2(0), gridExtents);\n\t\ttopRightGridIndex.xy = clamp(topRightGridIndex.xy + ivec2(0, 1), ivec2(0), gridExtents);\n\n\t\trelativePosition = vec2(0.75, 0.25);\n\t}\n\telse\n\t{\n\t\tbottomLeftGridIndex.xy = clamp(bottomLeftGridIndex.xy + ivec2(0, 0), ivec2(0), gridExtents);\n\t\tbottomRightGridIndex.xy = clamp(bottomRightGridIndex.xy + ivec2(1, 0), ivec2(0), gridExtents);\n\t\ttopLeftGridIndex.xy = clamp(topLeftGridIndex.xy + ivec2(0, 1), ivec2(0), gridExtents);\n\t\ttopRightGridIndex.xy = clamp(topRightGridIndex.xy + ivec2(1, 1), ivec2(0), gridExtents);\n\n\t\trelativePosition = vec2(0.25, 0.25);\n\t}\n\n\tfloat v0 = texelFetch(iChannel1, clamp(bottomLeftGridIndex.xy, ivec2(0), gridExtents), 0).x;\n\tfloat v1 = texelFetch(iChannel1, clamp(bottomRightGridIndex.xy, ivec2(0), gridExtents), 0).x;\n\tfloat v2 = texelFetch(iChannel1, clamp(topLeftGridIndex.xy, ivec2(0), gridExtents), 0).x;\n\tfloat v3 = texelFetch(iChannel1, clamp(topRightGridIndex.xy, ivec2(0), gridExtents), 0).x;\n\n\treturn mix(mix(v0, v1, relativePosition.x), mix(v2, v3, relativePosition.x), relativePosition.y);\n}\n#endif\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 levelDimensions = getDimensionsOfLevel(LEVEL);\n    ivec3 gridIndex = ivec3(ivec2(fragCoord), LEVEL);\n    \n    if (all(lessThan(gridIndex.xy, levelDimensions)))\n    {\n    \tivec3 retrievedGridIndex;\n    \tint nodeIndex = getLeafNodeIndex(gridIndex, retrievedGridIndex);\n        int cellIndex = convertNodeToCellIndex(nodeIndex);\n        \n        float value = 0.0;\n\n        if (cellIndex < 0)\n        {\n            // The node has child nodes, downsample their values\n            \n            value = getDownsampledValue(gridIndex, nodeIndex);\n        }\n        else\n        {\n#if (LEVEL > 0)\n            if (retrievedGridIndex.z == LEVEL)\n            {\n#endif\n                // The node is a leaf node, fetch its data value\n                \n                value = fetchValue(cellIndex);\n#if (LEVEL > 0)\n            }\n            else\n            {\n\t\t\t\t// The node covering the grid index is on a lower level, upsample the coarser values\n                \n                int quadrant = 2 * (gridIndex.y & 1) + (gridIndex.x & 1);\n\n\t\t\t\tvalue = getUpsampledValue(retrievedGridIndex, cellIndex, quadrant);\n            }\n#endif\n        }\n        \n        fragColor = vec4(value, 0.0, 0.0, 1.0);\n    }\n    else\n    {\n     \tfragColor = vec4(-1.0, 0.0, 0.0, 1.0);   \n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// In this example, Buffer D serves as one level of a multi-level texture, i.e., a mipmap level.\n// Buffer D corresponds to level 2 of the quadtree, i.e., the level of the highest resolution.\n// It holds all values of level-2 cells as well as all values downsampled from higher-level cells\n// that the remaining level-2 nodes cover and all values upsampled from lower-level cells. In a real\n// application, this step should be done with a compute shader, but for shadertoy, this will suffice.\n// Also, reconstruction in this example is performed for every texel of the texture, which is not\n// necessary. When using bilinear interpolation, only the directly neighboring texels of cells on\n// that level have to be reconstructed, i.e., the 3x3 neighborhood around each cell. For bicubic\n// interpolation or B-spline approximation, the neighbors' direct neighbors also need to be\n// reconstructed, i.e., the 5x5 neighborhood around each cell.\n\n// Note: The code for Buffers B, C, and D is almost identical (and should be in an application),\n// except for the upsampling step missing on level 0.\n\n#define LEVEL 2\n\nivec2 cellIndexToTexel(int cellIndex)\n{\n    ivec2 dataBufferDimensions = textureSize(iChannel0, 0);\n    \n    return ivec2(cellIndex % dataBufferDimensions.x, cellIndex / dataBufferDimensions.x);\n}\n\nfloat fetchValue(int cellIndex)\n{\n\treturn texelFetch(iChannel0, cellIndexToTexel(cellIndex), 0).x;\n}\n\nfloat getDownsampledValue(ivec3 gridIndex, int nodeIndex)\n{\n    const int highestLevel = gNumGrids - 1;\n    int lowestLevel = gridIndex.z + 1;\n    \n\tint coveredCells = 2 << (highestLevel - lowestLevel);\n    ivec3 gridIndexOnLevel = ivec3(gridIndex.xy * coveredCells, highestLevel);\n    \n    float summedValues = 0.0;\n    \n    for (int y = 0; y < coveredCells; y++)\n    {\n    \tfor (int x = 0; x < coveredCells; x++)\n        {\n            ivec3 currentGridIndex = gridIndexOnLevel + ivec3(x, y, 0);\n        \tivec3 retrievedGridIndex;\n    \t\tint nodeIndex = getLeafNodeIndex(currentGridIndex, retrievedGridIndex);\n        \tint cellIndex = convertNodeToCellIndex(nodeIndex);\n            \n            summedValues += fetchValue(cellIndex);\n        }\n    }\n    \n    return summedValues / float(coveredCells * coveredCells);\n}\n\n#if (LEVEL > 0)\nfloat getUpsampledValue(ivec3 gridIndex, int cellIndex, int quadrant)\n{\n\tivec3 quadrantGridIndex = ivec3((gridIndex.xy << 1) + ivec2(quadrant & 1, (quadrant & 2) >> 1), gridIndex.z + 1);\n\n\tivec2 gridExtents = getDimensionsOfLevel(gridIndex.z) - 1;\n\n\tivec3 bottomLeftGridIndex = gridIndex;\n\tivec3 bottomRightGridIndex = gridIndex;\n\tivec3 topLeftGridIndex = gridIndex;\n\tivec3 topRightGridIndex = gridIndex;\n\n\tvec2 relativePosition;\n\n\tif (quadrant == 0)\n\t{\n\t\tbottomLeftGridIndex.xy = clamp(bottomLeftGridIndex.xy + ivec2(-1, -1), ivec2(0), gridExtents);\n\t\tbottomRightGridIndex.xy = clamp(bottomRightGridIndex.xy + ivec2(0, -1), ivec2(0), gridExtents);\n\t\ttopLeftGridIndex.xy = clamp(topLeftGridIndex.xy + ivec2(-1, 0), ivec2(0), gridExtents);\n\t\ttopRightGridIndex.xy = clamp(topRightGridIndex.xy + ivec2(0, 0), ivec2(0), gridExtents);\n\n\t\trelativePosition = vec2(0.75, 0.75);\n\t}\n\telse if (quadrant == 1)\n\t{\n\t\tbottomLeftGridIndex.xy = clamp(bottomLeftGridIndex.xy + ivec2(0, -1), ivec2(0), gridExtents);\n\t\tbottomRightGridIndex.xy = clamp(bottomRightGridIndex.xy + ivec2(1, -1), ivec2(0), gridExtents);\n\t\ttopLeftGridIndex.xy = clamp(topLeftGridIndex.xy + ivec2(0, 0), ivec2(0), gridExtents);\n\t\ttopRightGridIndex.xy = clamp(topRightGridIndex.xy + ivec2(1, 0), ivec2(0), gridExtents);\n\n\t\trelativePosition = vec2(0.25, 0.75);\n\t}\n\telse if (quadrant == 2)\n\t{\n\t\tbottomLeftGridIndex.xy = clamp(bottomLeftGridIndex.xy + ivec2(-1, 0), ivec2(0), gridExtents);\n\t\tbottomRightGridIndex.xy = clamp(bottomRightGridIndex.xy + ivec2(0, 0), ivec2(0), gridExtents);\n\t\ttopLeftGridIndex.xy = clamp(topLeftGridIndex.xy + ivec2(-1, 1), ivec2(0), gridExtents);\n\t\ttopRightGridIndex.xy = clamp(topRightGridIndex.xy + ivec2(0, 1), ivec2(0), gridExtents);\n\n\t\trelativePosition = vec2(0.75, 0.25);\n\t}\n\telse\n\t{\n\t\tbottomLeftGridIndex.xy = clamp(bottomLeftGridIndex.xy + ivec2(0, 0), ivec2(0), gridExtents);\n\t\tbottomRightGridIndex.xy = clamp(bottomRightGridIndex.xy + ivec2(1, 0), ivec2(0), gridExtents);\n\t\ttopLeftGridIndex.xy = clamp(topLeftGridIndex.xy + ivec2(0, 1), ivec2(0), gridExtents);\n\t\ttopRightGridIndex.xy = clamp(topRightGridIndex.xy + ivec2(1, 1), ivec2(0), gridExtents);\n\n\t\trelativePosition = vec2(0.25, 0.25);\n\t}\n\n\tfloat v0 = texelFetch(iChannel1, clamp(bottomLeftGridIndex.xy, ivec2(0), gridExtents), 0).x;\n\tfloat v1 = texelFetch(iChannel1, clamp(bottomRightGridIndex.xy, ivec2(0), gridExtents), 0).x;\n\tfloat v2 = texelFetch(iChannel1, clamp(topLeftGridIndex.xy, ivec2(0), gridExtents), 0).x;\n\tfloat v3 = texelFetch(iChannel1, clamp(topRightGridIndex.xy, ivec2(0), gridExtents), 0).x;\n\n\treturn mix(mix(v0, v1, relativePosition.x), mix(v2, v3, relativePosition.x), relativePosition.y);\n}\n#endif\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 levelDimensions = getDimensionsOfLevel(LEVEL);\n    ivec3 gridIndex = ivec3(ivec2(fragCoord), LEVEL);\n    \n    if (all(lessThan(gridIndex.xy, levelDimensions)))\n    {\n    \tivec3 retrievedGridIndex;\n    \tint nodeIndex = getLeafNodeIndex(gridIndex, retrievedGridIndex);\n        int cellIndex = convertNodeToCellIndex(nodeIndex);\n        \n        float value = 0.0;\n\n        if (cellIndex < 0)\n        {\n            // The node has child nodes, downsample their values\n            \n            value = getDownsampledValue(gridIndex, nodeIndex);\n        }\n        else\n        {\n#if (LEVEL > 0)\n            if (retrievedGridIndex.z == LEVEL)\n            {\n#endif\n                // The node is a leaf node, fetch its data value\n                \n                value = fetchValue(cellIndex);\n#if (LEVEL > 0)\n            }\n            else\n            {\n\t\t\t\t// The node covering the grid index is on a lower level, upsample the coarser values\n                \n                int quadrant = 2 * (gridIndex.y & 1) + (gridIndex.x & 1);\n\n\t\t\t\tvalue = getUpsampledValue(retrievedGridIndex, cellIndex, quadrant);\n            }\n#endif\n        }\n        \n        fragColor = vec4(value, 0.0, 0.0, 1.0);\n    }\n    else\n    {\n     \tfragColor = vec4(-1.0, 0.0, 0.0, 1.0);   \n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Hard-coded adaptive grid data structure (quadtree)\n// Each node has four child nodes, each leaf node is called a cell and holds a data value\n// These buffers and constants are supposed to be provided by the host application\n\nconst int gNumGrids = 3;\nconst int gNumNodes = 204; // Traversable nodes of the quadtree / hierarchical data structure\nconst int gNumCells = 159; // Leaf nodes with data values\n\nconst vec2 gOrigin = vec2(-20.0, 20.0); // Application-dependent grid origin in world units\nconst vec2 gLevel0CellSize = vec2(100.0, 100.0); // Application-dependent largest cell size in world units\nconst ivec2 gLevel0Dimensions = ivec2(6, 4);\n\n// Cell index of each leaf node (-1 for nodes with children)\nconst int[gNumNodes] gNodeToCellIndices = int[](\n    0, 1, 2, -1, -1, -1, 3, -1, -1, -1,\n    -1, -1, -1, -1, -1, -1, -1, 4, -1, -1,\n    -1, -1, -1, 5, 6, 7, 12, 13, 8, 9,\n    14, -1, 10, 11, 15, 16, 19, 20, 29, 30,\n    17, 18, 27, 28, 21, 22, 31, 32, 23, 24,\n    33, 34, 25, 26, 35, 36, 37, 38, -1, -1,\n    39, -1, 41, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, 40, 42, 43, 44, -1, 47, -1,\n    45, -1, 48, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, 46, 49, 50, 51, 52, 53, 54,\n    55, 56, 67, 68, 83, 84, 97, 98, 79, 80,\n    93, 94, 65, 66, 77, 78, 81, 82, 95, 96,\n    107, 108, 121, 122, 57, 58, 69, 70, 63, 64,\n    75, 76, 61, 62, 73, 74, 109, 110, 123, 124,\n    89, 90, 103, 104, 59, 60, 71, 72, 91, 92,\n    105, 106, 137, 138, 149, 150, 135, 136, 147, 148,\n    85, 86, 99, 100, 111, 112, 125, 126, 115, 116,\n    129, 130, 113, 114, 127, 128, 119, 120, 133, 134,\n    87, 88, 101, 102, 117, 118, 131, 132, 139, 140,\n    151, 152, 143, 144, 155, 156, 141, 142, 153, 154,\n    145, 146, 157, 158);\n\n// Grid index (x, y, level) of each node relative to the grid in its corresponding level\nconst ivec3[gNumNodes] gNodeToGridIndices = ivec3[](\n\tivec3(0, 0, 0), ivec3(1, 0, 0), ivec3(2, 0, 0), ivec3(3, 0, 0), ivec3(4, 0, 0), ivec3(5, 0, 0),\n    ivec3(0, 1, 0), ivec3(1, 1, 0), ivec3(2, 1, 0), ivec3(3, 1, 0), ivec3(4, 1, 0), ivec3(5, 1, 0),\n    ivec3(0, 2, 0), ivec3(1, 2, 0), ivec3(2, 2, 0), ivec3(3, 2, 0), ivec3(4, 2, 0), ivec3(5, 2, 0),\n    ivec3(0, 3, 0), ivec3(1, 3, 0), ivec3(2, 3, 0), ivec3(3, 3, 0), ivec3(4, 3, 0), ivec3(5, 3, 0),\n    ivec3(6, 0, 1), ivec3(7, 0, 1), ivec3(6, 1, 1), ivec3(7, 1, 1), ivec3(8, 0, 1), ivec3(9, 0, 1),\n    ivec3(8, 1, 1), ivec3(9, 1, 1), ivec3(10, 0, 1), ivec3(11, 0, 1), ivec3(10, 1, 1), ivec3(11, 1, 1),\n    ivec3(4, 2, 1), ivec3(5, 2, 1), ivec3(4, 3, 1), ivec3(5, 3, 1), ivec3(2, 2, 1), ivec3(3, 2, 1),\n    ivec3(2, 3, 1), ivec3(3, 3, 1), ivec3(6, 2, 1), ivec3(7, 2, 1), ivec3(6, 3, 1), ivec3(7, 3, 1), \n    ivec3(8, 2, 1), ivec3(9, 2, 1), ivec3(8, 3, 1), ivec3(9, 3, 1), ivec3(10, 2, 1), ivec3(11, 2, 1),\n    ivec3(10, 3, 1), ivec3(11, 3, 1), ivec3(0, 4, 1), ivec3(1, 4, 1), ivec3(0, 5, 1), ivec3(1, 5, 1),\n    ivec3(2, 4, 1), ivec3(3, 4, 1), ivec3(2, 5, 1), ivec3(3, 5, 1), ivec3(4, 4, 1), ivec3(5, 4, 1),\n    ivec3(4, 5, 1), ivec3(5, 5, 1), ivec3(6, 4, 1), ivec3(7, 4, 1), ivec3(6, 5, 1), ivec3(7, 5, 1),\n    ivec3(8, 4, 1), ivec3(9, 4, 1), ivec3(8, 5, 1), ivec3(9, 5, 1), ivec3(0, 6, 1), ivec3(1, 6, 1),\n    ivec3(0, 7, 1), ivec3(1, 7, 1), ivec3(2, 6, 1), ivec3(3, 6, 1), ivec3(2, 7, 1), ivec3(3, 7, 1),\n    ivec3(4, 6, 1), ivec3(5, 6, 1), ivec3(4, 7, 1), ivec3(5, 7, 1), ivec3(6, 6, 1), ivec3(7, 6, 1),\n    ivec3(6, 7, 1), ivec3(7, 7, 1), ivec3(8, 6, 1), ivec3(9, 6, 1), ivec3(8, 7, 1), ivec3(9, 7, 1),\n    ivec3(18, 2, 2), ivec3(19, 2, 2), ivec3(18, 3, 2), ivec3(19, 3, 2), ivec3(6, 8, 2), ivec3(7, 8, 2),\n    ivec3(6, 9, 2), ivec3(7, 9, 2), ivec3(6, 10, 2), ivec3(7, 10, 2), ivec3(6, 11, 2), ivec3(7, 11, 2),\n    ivec3(0, 10, 2), ivec3(1, 10, 2), ivec3(0, 11, 2), ivec3(1, 11, 2), ivec3(16, 8, 2), ivec3(17, 8, 2),\n    ivec3(16, 9, 2), ivec3(17, 9, 2), ivec3(2, 10, 2), ivec3(3, 10, 2), ivec3(2, 11, 2), ivec3(3, 11, 2),\n    ivec3(2, 12, 2), ivec3(3, 12, 2), ivec3(2, 13, 2), ivec3(3, 13, 2), ivec3(8, 8, 2), ivec3(9, 8, 2),\n    ivec3(8, 9, 2), ivec3(9, 9, 2), ivec3(14, 8, 2), ivec3(15, 8, 2), ivec3(14, 9, 2), ivec3(15, 9, 2),\n    ivec3(12, 8, 2), ivec3(13, 8, 2), ivec3(12, 9, 2), ivec3(13, 9, 2), ivec3(6, 12, 2), ivec3(7, 12, 2),\n    ivec3(6, 13, 2), ivec3(7, 13, 2), ivec3(12, 10, 2), ivec3(13, 10, 2), ivec3(12, 11, 2), ivec3(13, 11, 2),\n    ivec3(10, 8, 2), ivec3(11, 8, 2), ivec3(10, 9, 2), ivec3(11, 9, 2), ivec3(14, 10, 2), ivec3(15, 10, 2),\n    ivec3(14, 11, 2), ivec3(15, 11, 2), ivec3(6, 14, 2), ivec3(7, 14, 2), ivec3(6, 15, 2), ivec3(7, 15, 2),\n    ivec3(2, 14, 2), ivec3(3, 14, 2), ivec3(2, 15, 2), ivec3(3, 15, 2), ivec3(8, 10, 2), ivec3(9, 10, 2),\n    ivec3(8, 11, 2), ivec3(9, 11, 2), ivec3(8, 12, 2), ivec3(9, 12, 2), ivec3(8, 13, 2), ivec3(9, 13, 2),\n    ivec3(12, 12, 2), ivec3(13, 12, 2), ivec3(12, 13, 2), ivec3(13, 13, 2), ivec3(10, 12, 2), ivec3(11, 12, 2),\n    ivec3(10, 13, 2), ivec3(11, 13, 2), ivec3(16, 12, 2), ivec3(17, 12, 2), ivec3(16, 13, 2), ivec3(17, 13, 2),\n    ivec3(10, 10, 2), ivec3(11, 10, 2), ivec3(10, 11, 2), ivec3(11, 11, 2), ivec3(14, 12, 2), ivec3(15, 12, 2),\n    ivec3(14, 13, 2), ivec3(15, 13, 2), ivec3(8, 14, 2), ivec3(9, 14, 2), ivec3(8, 15, 2), ivec3(9, 15, 2),\n    ivec3(12, 14, 2), ivec3(13, 14, 2), ivec3(12, 15, 2), ivec3(13, 15, 2), ivec3(10, 14, 2), ivec3(11, 14, 2),\n    ivec3(10, 15, 2), ivec3(11, 15, 2), ivec3(14, 14, 2), ivec3(15, 14, 2), ivec3(14, 15, 2), ivec3(15, 15, 2));\n\n// The bottom left child index of each node, may be -1 if no child in the quadrant\n// Note: Nodes on the highest level cannot have child nodes, so including all these\n// -1s is superfluous. But it might help to understand the sample better.\nconst int[gNumNodes] gChildIndices = int[](\n    -1, -1, -1, 24, 28, 32, -1, 40, 36, 44,\n    48, 52, 56, 60, 64, 68, 72, -1, 76, 80,\n    84, 88, 92, -1, -1, -1, -1, -1, -1, -1,\n    -1, 96, -1, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, -1, -1, -1, -1, -1, 108, 116,\n    -1, 100, -1, 104, 124, 144, 160, 180, 132, 128,\n    140, 148, 112, -1, -1, -1, -1, 120, -1, 156,\n    -1, 136, -1, 152, 164, 172, 188, 196, 168, 184,\n    192, 200, 176, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, -1);\n\nconst vec2 gInverseLevel0CellSize = 1.0 / gLevel0CellSize;\nconst vec2 gSmallestCellSize = gLevel0CellSize / float(1 << (gNumGrids - 1));\nconst vec2 gInverseSmallestCellSize = 1.0 / gSmallestCellSize;\nconst vec2 gUpper = vec2(gLevel0Dimensions) * gLevel0CellSize + gOrigin;\nconst vec2 gGridSize = gUpper - gOrigin;\nconst vec2 gInverseGridSize = 1.0 / gGridSize;\n\nint getChildIndex(int nodeIndex) { return gChildIndices[nodeIndex]; }\n\nint convertNodeToCellIndex(int nodeIndex) { return (nodeIndex < 0) ? -1 : gNodeToCellIndices[nodeIndex]; }\n\nvec2 getCellSizeOfLevel(int level) { return gSmallestCellSize * float(1 << (gNumGrids - level - 1)); }\n\nfloat getPowerOfTwo(int exponent) { return intBitsToFloat((127 + exponent) << 23); }\n\nvec2 getInverseCellSizeOfLevel(int level) { return gInverseSmallestCellSize * getPowerOfTwo(level + 1 - gNumGrids); }\n\nivec2 getDimensionsOfLevel(int level) { return gLevel0Dimensions << level; }\n\nivec2 getLevel0GridIndex(vec2 position) { return ivec2(floor((position - gOrigin) * gInverseLevel0CellSize)); }\n\nvec2 getNodePosition(ivec3 gridIndex) { return getCellSizeOfLevel(gridIndex.z) * (vec2(gridIndex.xy) + vec2(0.5)) + gOrigin; }\n\nivec2 mixIvec2Bool(ivec2 a, ivec2 b, bvec2 c) { return ivec2(c.x ? b.x : a.x, c.y ? b.y : a.y); }\n\n// Traverses the quadtree to get the node index of the cell that covers the position\nint getLeafNodeIndex(vec2 samplePosition, out ivec3 gridIndex)\n{\n\tivec2 level0GridExtents = gLevel0Dimensions - 1;\n\tivec2 level0GridIndex = getLevel0GridIndex(samplePosition);\n\n\tif (any(lessThan(ivec4(level0GridIndex, level0GridExtents), ivec4(0, 0, level0GridIndex))))\n\t{\n\t\treturn -1;\n\t}\n\telse\n\t{\n\t\tivec3 currentGridIndex = ivec3(level0GridIndex, 0);\n\t\tint currentNodeIndex = level0GridIndex.y * gLevel0Dimensions.x + level0GridIndex.x;\n\n\t\tint bottomLeftChildIndex = getChildIndex(currentNodeIndex);\n\n        // Traverse the quadtree from level 0 to the highest level - This traversal can be replaced\n\t\t// by a pre-computed lookup table to make sampling a constant-time operation at the cost of\n\t\t// additional video memory\n\t\twhile (bottomLeftChildIndex != -1)\n\t\t{\n\t\t\tvec2 currentPosition = getNodePosition(currentGridIndex).xy;\n\t\t\tbvec2 xy = greaterThan(samplePosition, currentPosition);\n\n\t\t\tcurrentNodeIndex = bottomLeftChildIndex + (int(xy.y) << 1) + int(xy.x);\n\t\t\tbottomLeftChildIndex = getChildIndex(currentNodeIndex);\n\n\t\t\tcurrentGridIndex.xy = (currentGridIndex.xy << 1) + ivec2(xy);\n\t\t\tcurrentGridIndex.z += 1;\n\t\t}\n\n\t\tgridIndex = currentGridIndex;\n\n\t\treturn currentNodeIndex;\n\t}\n}\n\n// Traverses the quadtree to get the node index of the cell that covers the node\nint getLeafNodeIndex(ivec3 gridIndex, out ivec3 retrievedGridIndex)\n{\n\tivec2 currentLevelDimensions = getDimensionsOfLevel(gridIndex.z);\n\n\tif ((any(lessThan(gridIndex, ivec3(0)))) || (any(greaterThanEqual(gridIndex.xy, currentLevelDimensions))))\n\t{\n\t\tretrievedGridIndex = ivec3(-1);\n\n\t\treturn -1;\n\t}\n\telse\n\t{\n\t\tivec2 level0GridIndex = gridIndex.xy >> gridIndex.z;\n\t\tint currentNodeIndex = level0GridIndex.y * gLevel0Dimensions.x + level0GridIndex.x;\n\t\tretrievedGridIndex = ivec3(level0GridIndex, 0);\n\n\t\tif (gNumGrids > 1)\n\t\t{\n\t\t\tint currentLevel = 0;\n\t\t\tint bottomLeftChildIndex = getChildIndex(currentNodeIndex);\n\n\t\t\t// Traverse the quadtree from level 0 to the highest level - This traversal can be replaced\n\t\t\t// by a pre-computed lookup table to make sampling a constant-time operation at the cost of\n\t\t\t// additional video memory\n\t\t\twhile ((bottomLeftChildIndex != -1) && (currentLevel < gridIndex.z))\n\t\t\t{\n\t\t\t\tcurrentLevel++;\n\n\t\t\t\tretrievedGridIndex = ivec3(gridIndex.xy >> (gridIndex.z - currentLevel), currentLevel);\n\t\t\t\tivec2 quadrantOffset = retrievedGridIndex.xy & 1;\n\n\t\t\t\tcurrentNodeIndex = bottomLeftChildIndex + (quadrantOffset.y << 1) + quadrantOffset.x;\n\t\t\t\tbottomLeftChildIndex = getChildIndex(currentNodeIndex);\n\t\t\t}\n\t\t}\n\n\t\treturn currentNodeIndex;\n\t}\n}\n\n#define NearestNeighbor 0\n#define Bilinear 1\n#define Bicubic 2\n#define BSpline 3",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}