{
    "Shader": {
        "info": {
            "date": "1566403164",
            "description": "a thing i made a long while ago",
            "flags": 32,
            "hasliked": 0,
            "id": "wtBSzG",
            "likes": 0,
            "name": "path tracer",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "fractal"
            ],
            "usePreview": 0,
            "username": "unnick",
            "viewed": 281
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MAX_BOUNCES 6\n#define NUM_SAMPLES 1\n\nstruct ray {\n    vec3 ro;\n    vec3 rd;\n};\n\nvoid intersect_sphere(in float rad, in vec3 o, in ray r, inout float dist, out vec3 normal, out bool hit, in int iid, out int oid) {\n    vec3 oc = r.ro - o;\n    float a = dot(r.rd, r.rd);\n    float b = dot(oc, r.rd);\n    float c = dot(oc, oc) - rad*rad;\n    float d = b*b - a*c;\n    if(d < 0.) return;\n    else {\n        float tmp = (-b - sqrt(d)) / a;\n        if (tmp > .005 && tmp < dist) {\n            dist = tmp;\n            normal = normalize(oc + r.rd * tmp);\n            oid = iid;\n            hit = true;\n        }\n        tmp = (-b + sqrt(d)) / a;\n        if (tmp > .005 && tmp < dist) {\n            dist = tmp;\n            normal = normalize(oc + r.rd * tmp);\n            oid = iid;\n            hit = true;\n        }\n    }\n}\n\n#define SCALE 3.\nvoid kifs_iter(inout vec3 z) {\n    z = abs(z);\n    const vec3 a = normalize(vec3(1.,-2.,3.));\n    if(dot(z, a) < 0.) z = reflect(z, a);\n    if(z.x-z.y < 0.) z.xy = z.yx;\n    if(z.x-z.z < 0.) z.xz = z.zx;\n    if(z.y-z.z < 0.) z.yz = z.zy;\n    z.z -= .5 * (SCALE-1.)/SCALE;\n    z.z = -abs(-z.z);\n    z.z += .5 * (SCALE-1.)/SCALE;\n    z = (z - vec3(1.,1.,0.)) * SCALE + vec3(1.,1.,0.);\n}\n\nfloat kifs_sdf(vec3 p) {\n    vec3 z = p;\n    for(int i = 0; i < 4; i++) kifs_iter(z);\n    return (length(z) - 2.) / pow(SCALE, 4.);\n}\n\nvec3 kifs_color(vec3 p) {\n    vec3 z = p;\n    vec3 trap = abs(vec3(2.5,1.5,1.7)-abs(z));\n    for(int i = 0; i < 4; i++) {\n        kifs_iter(z);\n        trap = min(trap, abs(vec3(2.5,1.5,1.7)-abs(z)));\n    }\n    return trap;\n}\n\n/*vec3 kifs_normal(vec3 p) {\n    #define ZERO (min(iFrame,0))\n    const float h = 0.0001;\n    const vec2 k = vec2(1.,-1.);\n    for(int i = ZERO; i < 1; i++) {\n        return normalize(k.xyy*kifs_sdf(p + k.xyy*h) + \n                         k.yyx*kifs_sdf(p + k.yyx*h) + \n                         k.yxy*kifs_sdf(p + k.yxy*h) + \n                         k.xxx*kifs_sdf(p + k.xxx*h)\n                        );\n    }\n}*/\n\nvec3 kifs_normal(vec3 p)\n{\n    const float h = 0.0001;\n    #define ZERO (min(iFrame,0))\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*kifs_sdf(p+e*h);\n    }\n    return normalize(n);\n}\n#undef SCALE\n//have fun understanding the code beyond this line :)\n//because i probably wouldnt even understand it if i tried\n\nvoid intersect_kifs(in ray r, inout float dist, out vec3 normal, out bool hit, in int iid, out int oid) {\n    {\n        float a = 100.;\n        vec3 b;\n        bool hit = false;\n        int c;\n        intersect_sphere(2., vec3(0.), r, a, b, hit, 0, c);\n        if(!hit) return;\n    }\n    float len = length(r.rd);\n    vec3 rd = normalize(r.rd);\n    float dist2 = 0.;\n    for(int i = 0; i < 48; i++) {\n        float dist3 = kifs_sdf(r.ro + rd * dist2);\n        dist2 += dist3;\n        if(dist2 > dist) break;\n        if(dist2 > .005 && dist3 < .001) {\n            if(dist2 < dist) {\n                {\n                    vec3 p = r.ro + rd * dist2;\n                    vec3 normal = kifs_normal(p);\n                    dist2 += kifs_sdf(p) * clamp(1. / -dot(normal, r.rd), -10., 10.);\n                }\n                dist = dist2 / len;\n                normal = kifs_normal(r.ro + rd * dist2);\n                oid = iid;\n                hit = true;\n            }\n            return;\n        }\n    }\n}\n\nvoid intersect(in ray r, inout float dist, out vec3 normal, out bool hit, out int id) {\n    intersect_sphere(1.   , vec3(-2., 0.     , 0.)   , r, dist, normal, hit, 0, id);\n    intersect_sphere(1.   , vec3( 2., 0.     , 0.)   , r, dist, normal, hit, 1, id);\n    intersect_kifs(r, dist, normal, hit, 2, id);\n    intersect_sphere(10000., vec3( 0., -10001.1, 0. ), r, dist, normal, hit, 3, id);\n}\n\nvec3 sky(vec3 rd) {\n    return texture(iChannel0, rd).rgb;\n}\n\nfloat rand(inout float seed) {\n    seed *= 23.9763;\n    seed += 16.901;\n    seed = fract(seed);\n    return seed;\n}\n\nvec2 rand2(inout float seed) {\n    return vec2(rand(seed), rand(seed));\n}\n\nvec2 rand_gauss2(inout float seed) {\n    vec2 u = rand2(seed);\n    float r = sqrt(-2. * log(u.x));\n    return vec2(sin(u.y * TAU), cos(u.y * TAU)) * r;\n}\n\n//vec2 rand_disk(inout float seed) {\n//    return normalize(rand_gauss2(seed)) * sqrt(rand(seed));\n//}\n\nvec3 rand_sphere(inout float seed) {\n    vec3 tmp = vec3(rand_gauss2(seed), rand_gauss2(seed).x);\n    return normalize(tmp) * pow(rand(seed), 1./3.);\n}\n\nvec3 hue(float h) {\n    return vec3(\n        cos(h - TAU*0./3.),\n        cos(h - TAU*1./3.),\n        cos(h - TAU*2./3.)\n    ) * .5 + .5;\n}\n\nconst int[] mats = int[](1,2,0,0);\nconst vec3[] colors = vec3[](\n    vec3(0., 1., 1.),\n    vec3(1.),//vec3(1., 1.2, .5),\n    vec3(1.),\n    vec3(.8)\n);\n\nconst vec3[] glow = vec3[](\n    vec3(.0),\n    vec3(.0),\n    vec3(.6, .6, .1),\n    vec3(.0)\n);\n\nmat3 lookat(vec3 cam, vec3 p, float fov) {\n    fov = fov / 360. * TAU * .5;\n    vec3 fwd = normalize(p-cam);\n    vec3 up = normalize(vec3(0.,1.,0.) - fwd * fwd.y);\n    vec3 right = cross(fwd, up);\n    float s = sin(fov);\n    float c = cos(fov);\n    return transpose(mat3(right*s, up*s, fwd*c));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 mpos = (iMouse.xy * 2. - iResolution.xy) / iResolution.y;\n    float seed = fract(texelFetch(iChannel3, ivec2(mod(fragCoord, vec2(256.))), 0).x + float(iFrame) * PHI);\n    for(int i = 0; i < 32; i++) rand(seed);\n    vec4 sum = vec4(0.);\n    vec3 cam = vec3(-sin(mpos.x)*cos(mpos.y), -sin(mpos.y), cos(mpos.x)*cos(mpos.y)) * 2.5;\n    mat3 view = lookat(cam, vec3(0.,0.,0.), 110.);\n    for(int smpl = 0; smpl < NUM_SAMPLES; smpl++) {\n        vec2 pos = ((fragCoord + rand2(seed) - .5) * 2. - iResolution.xy) / iResolution.y;\n        ray r;\n        r.ro = cam;\n        r.rd = vec3(pos, 1.) * view;\n        vec3[MAX_BOUNCES] mul;\n        vec3[MAX_BOUNCES] add;\n        float importance = 1.;\n        int bounce;\n        bool esc = false;\n        for(bounce = 0; bounce < MAX_BOUNCES && !esc; bounce++) {\n            float dist = 100.;\n            vec3 normal;\n            bool hit = false;\n            int id;\n            intersect(r, dist, normal, hit, id);\n            if(hit) {\n                r.ro += r.rd * dist;\n                bool brk = false;\n                vec3 objcolor = colors[id];\n                if(id == 2) objcolor *= kifs_color(r.ro);\n                vec3 objglow = glow[id];\n                vec3 tmpmul = objcolor;\n                vec3 tmpadd = objglow;\n                switch(mats[id]) {\n                case 0:\n                    r.rd = normal + rand_sphere(seed);\n                    break;\n                case 1:\n                    r.rd = reflect(r.rd, normal);\n                    break;\n                case 2:\n                    if(rand(seed) < .0) {\n                        r.rd = reflect(r.rd, normal);\n                    } else {\n                        float a = .62;\n                        r.rd = normalize(r.rd);\n                        if(dot(r.rd, normal) > 0.) {\n                            normal *= -1.; a = 1./a;\n                            float dist2 = dist * length(r.rd);\n                            tmpmul = vec3(\n                                pow(objcolor.r, dist2),\n                                pow(objcolor.g, dist2),\n                                pow(objcolor.b, dist2)\n                            );\n                            /*tmpadd = vec3(\n                                pow(objglow.r, dist2),\n                                pow(objglow.g, dist2),\n                                pow(objglow.b, dist2)\n                            );*/\n                        }\n                        r.rd = refract(r.rd, normal, a);\n                    }\n                    break;\n                }\n                mul[bounce] = tmpmul;\n                add[bounce] = tmpadd;\n                if(importance < .01) break;\n                r.ro += normalize(r.rd) * .001;\n            } else {\n                esc = true;\n                break;\n            }\n        }\n        vec3 color = texture(iChannel0, r.rd).rgb;\n        if(bounce == MAX_BOUNCES) color *= 0.;\n        for(int i = bounce-1; i >= 0; i--) {\n            color *= mul[i];\n            color += add[i];\n        }\n        sum.rgb += color * importance;\n        sum.w += importance;\n    }\n    fragColor = vec4(sum.rgb / (sum.w > .5 ? sum.w : 1.), sum.w) * .3\n                    + texelFetch(iChannel2, ivec2(fragCoord), 0) * .7;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define TAU 6.283184\n#define PHI 1.618033\n\nconst float[49] gaussKernel = float[49](\n0.0183,\n0.0254,\n0.0347,\n0.0468,\n0.0622,\n0.0815,\n0.1054,\n0.1344,\n0.1690,\n0.2096,\n0.2564,\n0.3092,\n0.3679,\n0.4316,\n0.4994,\n0.5698,\n0.6412,\n0.7116,\n0.7788,\n0.8406,\n0.8948,\n0.9394,\n0.9726,\n0.9931,\n1.0000,\n0.9931,\n0.9726,\n0.9394,\n0.8948,\n0.8406,\n0.7788,\n0.7116,\n0.6412,\n0.5698,\n0.4994,\n0.4316,\n0.3679,\n0.3092,\n0.2564,\n0.2096,\n0.1690,\n0.1344,\n0.1054,\n0.0815,\n0.0622,\n0.0468,\n0.0347,\n0.0254,\n0.0183\n);\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//gaussian x-axis blur\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 sum = vec4(0.);\n    ivec2 pos = ivec2(fragCoord);\n    for(int x = -24; x <= 24; x++) {\n        sum += max(texelFetch(iChannel0, pos + ivec2(x,0), 0)-1., 0.) * gaussKernel[x+24];\n    }\n    fragColor = sum;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//gaussian y-axis blur\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 sum = vec4(0.);\n    ivec2 pos = ivec2(fragCoord);\n    for(int y = -24; y <= 24; y++) {\n        sum += texelFetch(iChannel0, pos + ivec2(0,y), 0) * gaussKernel[y+24];\n    }\n    fragColor = sum / 448.90591876 * 2.5 + min(texelFetch(iChannel1, pos, 0), 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}