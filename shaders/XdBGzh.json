{
    "Shader": {
        "info": {
            "date": "1383191584",
            "description": "The raving ernie guy from fr-minus-017: coderp0rn by BeRo from farbrausch<br/><br/>Reflection commented out for WebGL instruction count limit of ANGLE<br/>The head of the ernie model simplifed for WebGL instruction count limit of ANGLE<br/>",
            "flags": 0,
            "hasliked": 0,
            "id": "XdBGzh",
            "likes": 13,
            "name": "Raving ernie from fr-minus-017",
            "published": 3,
            "tags": [
                "ernie",
                "raving",
                "frminus017",
                "coderporn",
                "bero",
                "coderp0rn"
            ],
            "usePreview": 0,
            "username": "BeRo",
            "viewed": 1361
        },
        "renderpass": [
            {
                "code": "// The raving ernie guy from fr-minus-017: coderp0rn by BeRo from farbrausch\n// A bit stripped-down version for WebGL without camera envelope uniforms etc.\n// (so hardcoded camera here)\n// Reflection commented out for WebGL instruction count limit of ANGLE\n// The head of the ernie model simplifed for WebGL instruction count limit of ANGLE\n// Changelog:\n// 2013/11/02 iq's changes applied and removed head code as commented out code readded\n\n#define time (iTime*2.0)\n#define tczu (iTime*8.0)\n\nconst float e1=6.0; // raving speed\n\nconst int maxSteps=64;\nconst int shadowSteps=32;\nconst float maxDistance=64.0;\nconst float PI=3.14159265358979323846264;\n\nvec3 safenormalize(vec3 n){ // div-by-zero-safe-replacement for normalize (anti-black-pixel-workaround)\n \tfloat l=length(n);\n\treturn (abs(l)>1e-10)?(n/l):n;\t\n}\n\nfloat _union(float a,float b){\n  return min(a,b);\n}\n\nfloat _union(float a,float b,inout float m,float nm){\n  m=(b<a)?nm:m;\n  return min(a, b);\t\t\n}\n\nfloat intersect(float a,float b){\n  return max(a,b);\n}\n\nfloat difference(float a,float b){\n  return max(a,-b);\n}                                                                \n\nfloat hash(float n){\n  return fract(sin(n)*43758.5453123);\n}\n\nvec3 rotateX(vec3 p,float a){\n  vec2 cs=vec2(cos(a),sin(a));\n  return vec3(p.x,(cs.x*p.y)-(cs.y*p.z),(cs.y*p.y)+(cs.x*p.z));\n}\n\nvec3 rotateY(vec3 p,float a){\n  vec2 cs=vec2(cos(a),sin(a));\n  return vec3((cs.x*p.x)+(cs.y*p.z),p.y,(cs.x*p.z)-(cs.y*p.x));\n}\n\nvec3 rotateZ(vec3 p,float a){\n  vec2 cs=vec2(cos(a),sin(a));\n  return vec3((cs.x*p.x)+(cs.y*p.y),(cs.x*p.y)-(cs.y*p.x),p.z);\n}\n\nfloat sdPlane(vec3 p,vec4 n){\n  return dot(p,n.xyz)+n.w;\n}\n\nfloat plane(vec3 p,vec3 n,vec3 pointOnPlane){\t\n  return dot(p,n)-dot(pointOnPlane,n);\n}\n\nfloat edge(vec3 p,vec2 a,vec2 b){\n  vec2 e=b-a;\n  vec3 n=normalize(vec3(e.y,-e.x,0.0));\n  return plane(p,n,vec3(a,0.0));\n//return intersect(plane(p,n,vec3(a,0.0)),plane(p,-n,vec3(a,0.0))-0.1);\n}\n\nfloat sdBox(vec3 p,vec3 b){\n  vec3 di=abs(p)-b;\n  float mc=max(di.x,max(di.y,di.z));\n  return min(mc,length(max(di,0.0)));\n}\n\nfloat sdCylinder(vec3 p,vec3 c){\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sphere(vec3 p,float r){\n  return length(p)-r;\n}\n\nfloat box(vec3 p,vec3 bmin,vec3 bmax){\n  return sdBox(p-((bmin+bmax)*0.5),(bmax-bmin)*0.5);\n}\n\nvec3 closestPtPointSegment(vec3 c,vec3 a,vec3 b,out float t){\n  vec3 ab=b-a;\n  t=clamp(dot(c-a,ab)/dot(ab,ab),0.0,1.0);\n  return a+(t*ab);\n}\n\nfloat capsule(vec3 p,vec3 a,vec3 b,float r){\n  float t;\n  vec3 c=closestPtPointSegment(p,a,b,t);\n  return length(c-p)-r;\n}\n\nfloat cylinder(vec3 p,vec3 a,vec3 b,float r){\n  vec3 ab=b-a;\n  vec3 c=a+((dot(p-a,ab)/dot(ab,ab)))*ab;\n  float d=length(c-p)-r;\n  vec3 n=normalize(ab);\n  return intersect(intersect(d,plane(p,n,b)),plane(p,-n,a));\n}\n\nfloat sdCone(vec3 p,vec2 c){\n  float q=length(p.xy);\n  return dot(c,vec2(q,p.z));\n}\n\nfloat sdTorus(vec3 p, vec2 t){\n  vec2 q=vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat torus(vec3 p,float r,float r2){\n  return sdTorus(p,vec2(r,r2));\t\n}\n\nfloat cone(vec3 p,vec3 a,float baseR,vec3 b,float capR){\n  vec3 ab=b-a;\n  float t=dot(p-a,ab)/dot(ab,ab);\n  //t = clamp(t, 0.0, 1.0);\n  vec3 c=a+(t*ab);\t\n  float r=mix(baseR,capR,t);\n  float d=(length(c-p)-r)*0.5;\n  vec3 n=normalize(ab);\n  return intersect(intersect(d,plane(p,n,b)),plane(p,-n,a));\n}\n\nvec2 sdSegment(vec3 a,vec3 b,vec3 p){\n  vec3 pa=p-a;\n  vec3 ba=b-a;\n  float h=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n  return vec2(length(pa-(ba*h)),h);\n}\n\nfloat bein(vec3 p,float b,inout float m){\n  float d;\n  m=1.0;\n  d=sdSegment(vec3(-0.5,b,0.0),vec3(-(0.625-(b*0.5)),0.0,0.25),p).x-0.25;\n  d=_union(d,sdSegment(vec3(-0.5,b,0.0),vec3(-0.4,1.0+b,b),p).x-0.1,m,2.0);\n  d=_union(d,sdSegment(vec3(-0.4,1.0+b,b),vec3(-0.3,2.0+b,0.0),p).x-0.2,m,3.0);\n  return d;\n}\n\nfloat oberkoerper(vec3 p,float b,inout float m){\n  float d;\n  m=3.0;\n  d=sdSegment(vec3(0.0,2.0+b,0.0),vec3(0.0,2.25+b,-b*0.5),p).x-0.45;\n  d=_union(d,sdSegment(vec3(0.0,2.25+b,-b*0.5),vec3(0.0,3.25+b,0.0),p).x-0.5,m,4.0);\n  return d;\n}\n\nfloat arm(vec3 p,float b,inout float m){\n  float d;\n  m=4.0;\n  vec3 l=vec3(-(0.75+(b*0.25)),2.75+b,0.0);\n  vec3 l2=vec3(-(0.75+(b*0.95)),3.25+b-(b*0.25),1.0);\n  vec3 l3=vec3(-(0.75+(b*0.95)),3.25+b-(b*0.25),1.25);\n  d=sdSegment(vec3(-0.375,3.25+b,0.0),l,p).x-0.2;\n  d=_union(d,sdSegment(l,l2,p).x-0.1,m,2.0);\n  d=_union(d,sdSegment(l2,l3,p).x-0.2,m,2.0);\n  return d;\n}\n\nfloat kopf(vec3 p,float b,inout float m){\n  float d;\n  float tcz=tczu*e1;\n  vec3 bv=vec3(0.0,4.0+b,0.0);\n  \n  m=2.0;\n  d=sdSegment(vec3(0.0,3.25+b,0.0),bv,p).x-0.2;\n\n  p-=bv;\n  p=rotateY(p,(b*0.25)+((sin(tcz/32.0*PI)*1.0*PI)*0.1));\n  p=rotateZ(p,(b*0.125)+((sin(tcz/64.0*PI)*1.0*PI)*0.1));\n  p=rotateX(p,(b*0.75)+((sin(tcz/8.0*PI)*1.0*PI)*0.1));\n  p+=bv;\n\n  d=_union(d,sphere(p-vec3(0.0,4.25+b,0.0),0.5));\n  /*d=_union(d,sphere(p-vec3(0.0,4.75+b,0.0),0.25),m,1.0);\n  \n  d=_union(d,sphere(p-vec3(-0.45,4.25+b,0.0),0.175),m,2.0);\n  d=_union(d,sphere(p-vec3(0.45,4.25+b,0.0),0.175),m,2.0);\n\n  d=_union(d,sphere(p-vec3(0.0,4.25+b,0.5),0.125),m,2.0);\n\n  d=_union(d,sdSegment(vec3(-0.125,4.0+b,0.5),vec3(0.125,4.0+b,0.5),p).x-0.075,m,5.0);\n  d=_union(d,sdSegment(vec3(-0.125,4.0+b,0.585),vec3(0.125,4.0+b,0.585),p).x-0.025,m,1.0);\n\n  d=_union(d,sphere(p-vec3(0.125,4.4+b,0.5),0.125),m,4.0);\n  d=_union(d,sphere(p-vec3(-0.125,4.4+b,0.5),0.125),m,4.0);\n\n  d=_union(d,sphere(p-vec3(0.125,4.4+b,0.6),0.075),m,1.0);\n  d=_union(d,sphere(p-vec3(-0.125,4.4+b,0.6),0.075),m,1.0);\n  \n  d=_union(d,sphere(p-vec3(-0.25,4.75+b,0.0),0.25),m,1.0);\n  d=_union(d,sphere(p-vec3(0.25,4.75+b,0.0),0.25),m,1.0);\n  d=_union(d,sphere(p-vec3(-0.25,4.75+b,-0.25),0.25),m,1.0);\n  d=_union(d,sphere(p-vec3(0.25,4.75+b,-0.25),0.25),m,1.0);\n  d=_union(d,sphere(p-vec3(-0.25,4.75+b,0.25),0.25),m,1.0);\n  d=_union(d,sphere(p-vec3(0.25,4.75+b,0.25),0.25),m,1.0);*/\n  return d;\n}\n\n\nvec4 scene(vec3 p){\n  float tcz=tczu*e1;\n  float d=1e+8,d1=1e-14,d2=1e-14;\n  float b=tcz/64.0,t=(1.0+pow(sin(b*4.0*PI),2.0))*0.5*0.25,s=(sin(time*8.0*PI)*0.5*t),m=0.0,m1=0.0,m2=0.0;\n\n  p+=vec3(0.0,1.5,0.0);                \n\n  vec3 q = vec3( -abs(p.x), p.yz );\n\n  d1=sdPlane(p,vec4(0.0,1.0,0.0,0.0)); \n  d1=_union(d1,sdPlane(p+vec3(0.0,0.0,10.0),vec4(0.0,0.0,1.0,0.0)),m1,1.0); \n  d1=_union(d1,sdPlane(p+vec3(0.0,0.0,-10.0),vec4(0.0,0.0,-1.0,0.0)),m1,1.0); \n  d1=_union(d1,sdPlane(q+vec3(10.0,0.0,0.0),vec4(1.0,0.0,0.0,0.0)),m1,1.0); \n  d1=_union(d1,sdPlane(p+vec3(0.0,-10.0,0.0),vec4(0.0,-1.0,0.0,0.0)),m1,1.0);\n  \n  float beinY=((sin((tcz/8.0)*PI)*0.5)+0.5)*0.5;\n\n  m=1.0;\n\n  float bd=0.0;\n\n  d=bein(q,beinY,m);\n\n  d2=oberkoerper(p,beinY,m2);\n  d=_union(d,d2,m,m2);\n\n  d2=arm(q,beinY,m2);\n  d=_union(d,d2,m,m2);\n\n  d2=kopf(p,beinY,m2);\n  d=_union(d,d2,m,m2);\n\n  d=_union(d,d1,m,m1);  \n\n  return vec4(d,m,0.0,0.0);\n}\n\nvec3 sceneNormal(vec3 pos){\n  float eps=1e-5,d=scene(pos).x;\n  return safenormalize(vec3(scene(vec3(pos.x+eps,pos.y,pos.z)).x-d,\n                            scene(vec3(pos.x,pos.y+eps,pos.z)).x-d,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tscene(vec3(pos.x,pos.y,pos.z+eps)).x-d));\n}\n\nfloat ambientOcclusion(vec3 p,vec3 n){\n  const int steps=3;\n  const float delta=0.5;\n  float a=0.0,weight=1.0;\n  for(int i=1;i<=steps;i++){\n    float d=(float(i)/float(steps))*delta; \n    a+=weight*(d-scene(p+(n*d)).x);\n    weight*=0.5;\n  }\n  return clamp(1.0-a,0.0,1.0);\n}\n\nfloat softShadow(vec3 ro,vec3 rd,float mint,float maxt,float k){\n  float dt=(maxt-mint)/float(shadowSteps),t=mint+(hash((ro.z*574854.0)+(ro.y*517.0)+ro.x)*mint*0.25),r=1.0;\n  for(int i=0;i<shadowSteps;i++){\n    float h=scene(ro+(rd*t)).x;\n    if(h<(t*0.003)){\n      return 0.0;\t\n    } \n    r=min(r,(k*h)/t);\n    t+=dt;\n  }\n  return clamp(r,0.0,1.0);\n}                \n\nvec3 lightShade(vec3 pos,vec3 n,vec3 eyePos,vec3 mc,vec3 lc,vec3 lp,float shininess){\n  vec3 l=lp-pos;\n  float ld=length(l);\n  if(abs(ld)>1e-10){ \n    l/=ld;\n  } \n  vec3 v=safenormalize(eyePos-pos),h=safenormalize(v+l);\n  float d=dot(n,l);\n  float dnh=dot(n,h);\n  return vec3((((max(0.0,d)*0.5)+0.5)*mix(0.5,1.0,softShadow(pos,l,0.1,ld,10.0)))*mc*lc)+vec3(max(0.0,(dnh>0.0)?pow(dnh,shininess):0.0)*float((d>0.0)&&(shininess<32768.0)));\n}\n\nvec3 sky(vec3 rd){\n  return mix(vec3(0.2,0.3,0.0),vec3(0.3,0.6,1.0),(rd.y*0.5)+0.5);\n}\n\nvec3 shade(vec3 pos,vec3 n,vec3 eyePos,float m){\n  float s=128.0;\n  s=mix(s,65535.0,clamp(m,0.0,1.0));\n  vec3 color=vec3(0.25);\n  color=mix(color,vec3(0.125),clamp(m,0.0,1.0));\n  color=mix(color,vec3(0.75,0.6,0.0625),clamp(m-1.0,0.0,1.0));\n  color=mix(color,vec3(0.125,0.125,0.75),clamp(m-2.0,0.0,1.0));\n  color=mix(color,vec3(1.0,1.0,1.0),clamp(m-3.0,0.0,1.0));\n  color=mix(color,vec3(1.0,0.25,0.125),clamp(m-4.0,0.0,1.0));\n  float ao=ambientOcclusion(pos,n);\n  vec3 c=ao*((sky(n)*0.125)+(color*0.125));\n  float tcz=tczu*0.5;\n  float r=mod(tcz*(1.0/2.0),3.0);\n  if(r<1.0){\n    c+=lightShade(pos,n,eyePos,color,vec3(1.0,0.25,0.25),vec3(cos(time*4.0*PI)*5.0,1.0,sin(time*4.0*PI)*5.0),s)*((sin((tcz/8.0)*PI*2.0)*0.5)+0.5);\n  }else if(r<2.0){\n    c+=lightShade(pos,n,eyePos,color,vec3(0.25,1.0,0.25),vec3(cos(time*2.0*PI)*5.0,1.0,sin(time*2.0*PI)*5.0),s)*((sin(time*PI*2.0)*0.5)+0.5);\n  }else{\n   c+=lightShade(pos,n,eyePos,color,vec3(0.25,0.25,1.0),vec3(cos(time*1.0*PI)*5.0,1.0,sin(time*1.0*PI)*5.0),s)*((sin(time*PI*1.0)*0.5)+0.5);\n  }\n  return c;\n}\n\nvec4 trace(vec3 ro,vec3 rd){\n  vec3 hp=ro,p=ro;\t \n  float m=-1.0;\n  for(int i=0;i<maxSteps;i++){\n    vec2 v=scene(p).xy;\n\tif(v.x<0.001){\n      hp=p;\n\t  m=v.y;\n    }\n\tp+=rd*v.x;\n  }\n  return vec4(hp,m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 pixel=-1.0+(2.0*(fragCoord.xy/iResolution.xy));\n  float asp=iResolution.x/iResolution.y,m=0.0,roty=0.0,rotx=0.0;\n  vec3 rd=vec3(0.0),ro=vec3(0.0),c=vec3(0.0);\n  rd=normalize(vec3(asp*pixel.x,pixel.y,-2.0));\n  ro=vec3(0.0,1.5,8.0);\n  roty=(sin(time*PI*0.125)*0.5);\n  rotx=(cos(time*PI*0.5)*0.25)-0.25;\n  rd=rotateY(rotateX(rd,rotx),roty);\n  ro=rotateY(rotateX(ro,rotx),roty);\n  vec4 ph=trace(ro,rd);\n  vec3 pos=ph.xyz;\n  m=ph.w;\t\n  if(m>=0.0){\n    vec3 n=sceneNormal(pos);   \n    c+=shade(pos,n,ro,m);\n   /*/\n  // Reflection commented out for WebGL\n    if(m==0.0){\n      vec3 v=safenormalize(ro-pos);\n      ro=pos+(n*0.01); \n      rd=reflect(-v,n);\n      ph=trace(ro,rd);\n      pos=ph.xyz;\n      m=ph.w;\t\n      if(m>=0.0){\n        c+=shade(pos,sceneNormal(pos),ro,m)*vec3(0.1+(0.4*pow(max(0.0,1.0-dot(n,v)),5.0)));\n      }\n    }/**/\n  }\n  fragColor=vec4(c,1.0);\n} \t\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}