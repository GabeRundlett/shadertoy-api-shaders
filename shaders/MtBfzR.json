{
    "Shader": {
        "info": {
            "date": "1514326823",
            "description": "Randomly adding animations uppon animations I came up with this",
            "flags": 0,
            "hasliked": 0,
            "id": "MtBfzR",
            "likes": 27,
            "name": "Dynamic Targets",
            "published": 3,
            "tags": [
                "2d",
                "circle"
            ],
            "usePreview": 0,
            "username": "antonOTI",
            "viewed": 916
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159\n#define TAU (2. * PI)\n#define HPI (PI / 2.)\n\n#define SMOOTH(r,p) smoothstep(-.004, .004, p-(r)) \n\nfloat diskDf(vec2 p,float r)\n{\n    return length(p) - r;\n}\n\nfloat circleDf(vec2 p,float r, float t)\n{\n    float ht = t/2.;\n    return max(diskDf(p,r + ht), - diskDf(p,r - ht));\n}\n\n//from https://www.shadertoy.com/view/4sSyDd\nvec2 modA (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\n\n//from https://www.shadertoy.com/view/Ml33W7\nfloat rectDist(vec2 p, vec2 dim) {\n    return max(abs(p).x - dim.x*0.5, abs(p).y - dim.y*0.5);\n}\n\nmat2 rot(float a)\n{\n    float c = cos(a); float s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat bounce(float p, float b)\n{\n    return .5 - cos(p * PI) * .5 + sin(p * PI) * p * b ;\n}\n\nfloat multiplexer(float channel, float nbChannel, float t, float b)\n{\n    float ft = floor(t);\n    float mt = t- ft;\n    mt *= nbChannel;\n    channel = clamp(mt - channel,0.,1.);\n    channel = bounce(channel, b) ;\n    return ft + channel;\n}\n\nfloat multiplexer(float channel,float nbChannel,float t)\n{\n    return multiplexer(channel, nbChannel, t, .0);\n}\n\nfloat noise(vec2 p)\n{\n    return fract(dot(sin(p.x * 123.12)*142.,cos(p.y *34.95)*165.47));\n}\n\nfloat sigil(vec2 p, float id)\n{\n    p.x = floor(p.x * 4.) / 4.;\n    p.y = floor(p.y * 5.) / 5.;\n    \n    float f = step(.1,p.x) * step(p.x, .9) * step(.1,p.y) * step(p.y, .9);\n    f *= step(noise(p + id), .5);\n    \n    return f;\n}\n\nfloat sigilSheet(vec2 p, float seedDelta)\n{\n    float rep = .1;\n    \n    vec2 ruv = mod(p,rep) / rep;\n    vec2 idUV = floor(p/rep) * rep;\n    \n    float no = noise(idUV + rep*.5);\n    float nbChar = 30.;\n    no = floor(no * nbChar) / nbChar; \n    \n    return sigil(ruv, no + seedDelta);\n}\n\nvec2 triChecker(vec2 p, float s)\n{\n    p.x += p.y * .5 ;\n    vec2 m = mod(p,s); \n    vec2 base = p - m;\n    p = m / s; \n    \n    base.x *= 2. + step(p.x,p.y);\n    \n    return base;\n}\n\n#define NB_CHANNEL 31.\n#define CHANNEL_DURATION .5\n#define TOTAL_DURATION (NB_CHANNEL * CHANNEL_DURATION)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x /= iResolution.y / iResolution.x;\n    \n    float time = mod(iTime,TOTAL_DURATION) / TOTAL_DURATION;\n    \n    float t0 = multiplexer(0.,NB_CHANNEL,time, .1);\n    float t3 = multiplexer(3.,NB_CHANNEL, time, .1);\n    float t5 = multiplexer(5.,NB_CHANNEL, time);\n    float t12 = multiplexer(12.,NB_CHANNEL, time);\n    float t13 = multiplexer(13.,NB_CHANNEL,time);\n    float t14 = multiplexer(14.,NB_CHANNEL,time,.2);\n    float t16 = multiplexer(16.,NB_CHANNEL, time, .2);\n    float t17 = multiplexer(17.,NB_CHANNEL,time);\n    float t17_5 = multiplexer(17.5,NB_CHANNEL,time);\n    float t18 = multiplexer(18.,NB_CHANNEL,time);\n    float t19 = multiplexer(19.,NB_CHANNEL,time);\n    float t21 = multiplexer(21.,NB_CHANNEL,time, .3);\n    float t22 = multiplexer(22.,NB_CHANNEL,time);\n    float t24 = multiplexer(24., NB_CHANNEL, time);\n    float t26 = multiplexer(26., NB_CHANNEL, time);\n    float t28 = multiplexer(28.,NB_CHANNEL,time, .25);\n    float t30 = multiplexer(30.,NB_CHANNEL, time, .1);\n    \n    float distor = 0.;\n    distor += sin(t16 *  PI);\n    uv.x += sin(uv.y * iResolution.y) * .075 * distor;\n    \n    vec2 mirrored;\n    \n    float r1 = .25 + 2. * (1. - t0) + 2. * t28;\n    float f = circleDf(uv, r1, .01);\n    \n    \n    float raSpeed = .15;\n    float a = atan(uv.y,uv.x);\n    float an = (a + PI) / TAU;\n    float aa = mod(an + .25 + time * raSpeed, 1.);\n    float r3 = .32;\n   \tfloat st = sin(aa * TAU * 24.);\n    st = SMOOTH(st,0.);\n    \n    an = mod(an + .25,1.);\n    st *= step(1. - an, t13) * step(t26, 1. - an );\n    \n    float c3 = circleDf(uv,r3, st * .03 - .03);\n   \t\n    f = min(c3,f);\n    float r4 = .45;\n    float c4 = circleDf(uv,r4, st * .03 - .03);\n    f = min(c4,f);\n    \n    float dist = length(uv);\n    vec2 po = vec2(an, dist * .48) * 3.; po.y += .01;\n    \n    \n    float tSigil = floor(time * 400. * step(t12, .0));\n    \n    float si =  sigilSheet(po, tSigil);\n   \t\n    si *= step(sin(t12 * TAU * 4.), .0);\n    \n    si *=  (1. - circleDf(uv,.385,.05));\n    si *=  t5  * step(t26, 1. - an );\n    \n    f = min(f, 1. - si);\n    \n    float nbMirror = 3.;\n    mirrored = modA(uv * rot(t21 * PI - t14 * HPI) ,nbMirror);\n    float quadrant = floor(an * nbMirror);\n    float tLine = multiplexer(4. + quadrant * .1 ,NB_CHANNEL, time);\n    mirrored.x -=  .2 + (1. - tLine) * 2.;\n    \n    \n    float line = rectDist(mirrored, vec2(.03 - t22 *.03,-.005));\n    f = min(f,line);\n    \n    \n    float top = .4; float bot = -.4;\n    float height = top - bot;\n    \n    vec2 siUv = uv; ; siUv.x -= .025;\n    si =  sigilSheet(siUv, 0.);\n    float side = 1. -  si  * step(-.57,uv.x) * step(uv.x,-.47) * step(uv.y, .4) * step(-.4,uv.y);\n    \n    \n    side = max(side, step(t17 * height, uv.y - bot));\n    side = max(side , sin(t18 * TAU * 4.));\n    \n    f = min(f,side);\n    \n    siUv.x += .075;\n    si =  sigilSheet(siUv, 8.);\n    side = 1. -   si  * step(.47,uv.x) * step(uv.x,.57) * step(uv.y, .4) * step(-.4,uv.y);\n    \n    side = max(side, step(t17_5 * height, uv.y - bot));\n    side = max(side , sin(t18 * TAU * 4.));\n    \n    f = min(f,side);\n    \n    float r2 = .15 + 2. * (1. - t3) + 2. * t30;\n    f =  max(step(dist, r2),f);\n    f = min(circleDf(uv, r2, .015), f);\n    \n    mirrored = modA(uv * rot( -t12 * PI + HPI - t30 * PI),3. + t17 * 3. - t28 * 2. - t24);\n    \n    float li = distance(mirrored.x, .03 + (t12 - t24) * .045) * 2.;\n\t\n    f = min(f, li);\n    \n    f = SMOOTH(f,.01);\n    \n    \n    uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x /= iResolution.y / iResolution.x;\n    vec2 tri = triChecker(uv + iTime * .01, .07);\n    f += noise(tri) * .1;\n    \n    fragColor = vec4(mix(vec4(0.),vec4(1.,1.,.7,1.)*.75,f));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}