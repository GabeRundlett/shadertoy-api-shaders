{
    "Shader": {
        "info": {
            "date": "1719222955",
            "description": "/*originals https://www.shadertoy.com/view/McG3RK https://www.shadertoy.com/view/4X3XD7 https://www.shadertoy.com/view/X3dSWM*/",
            "flags": 0,
            "hasliked": 0,
            "id": "43tXzS",
            "likes": 1,
            "name": "Planet love you",
            "published": 3,
            "tags": [
                "planet",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 233
        },
        "renderpass": [
            {
                "code": "/*originals https://www.shadertoy.com/view/McG3RK https://www.shadertoy.com/view/4X3XD7 https://www.shadertoy.com/view/X3dSWM*/\n#define INTERVAL 111115.0\n#define PIXEL_SIZE 0.0001\n#define DITHER_STRENGTH 0.095\n\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b / cos(6.28318 * (c * t + d));\n}\n\nstruct ColorScheme {\n    vec3 color1;\n    vec3 color2;\n    vec3 color3;\n    vec3 color4;\n    vec3 color5;\n    vec3 color6;\n    vec3 color7;\n    float seed;\n    vec3 atmosphereColor;\n};\n\nvec3 getColor(float n, ColorScheme scheme) {\n    if(n > 0.85)\n        return scheme.color7;\n    else if(n > 0.70)\n        return scheme.color6;\n    else if(n > 0.55)\n        return scheme.color5;\n    else if(n > 0.40)\n        return scheme.color4;\n    else if(n > 0.25)\n        return scheme.color3;\n    else if(n > 0.15)\n        return scheme.color2;\n    else\n        return scheme.color1;\n}\n\nfloat hash(float n, float seed) {\n    return fract(sin(n + seed) * 53738.14534123);\n}\n\nfloat noise(vec2 p, float seed) {\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u * u * (3.0 - 2.0 * u);\n\n    return mix(mix(hash(ip.x + ip.y * 57.0, seed), hash(ip.x + 1.0 + ip.y * 57.0, seed), u.x), mix(hash(ip.x + (ip.y + 1.0) * 57.0, seed), hash(ip.x + 1.0 + (ip.y + 1.0) * 57.0, seed), u.x), u.y);\n}\n\nColorScheme getProceduralColorScheme(float seed) {\n    vec3 a = vec3(noise(vec2(seed, 1.0), seed), noise(vec2(seed, 2.0), seed), noise(vec2(seed, 3.0), seed)) * 1.5;\n    vec3 b = vec3(noise(vec2(seed, 4.0), seed), noise(vec2(seed, 5.0), seed), noise(vec2(seed, 6.0), seed)) * 1.5;\n    vec3 c = vec3(noise(vec2(seed, 7.0), seed), noise(vec2(seed, 8.0), seed), noise(vec2(seed, 9.0), seed)) * 1.5;\n    vec3 d = vec3(noise(vec2(seed, 10.0), seed), noise(vec2(seed, 11.0), seed), noise(vec2(seed, 12.0), seed)) * 0.75;\n\n    return ColorScheme(palette(0.1, a, b, c, d), palette(0.2, a, b, c, d), palette(0.4, a, b, c, d), palette(0.6, a, b, c, d), palette(0.8, a, b, c, d), palette(1.0, a, b, c, d), palette(1.2, a, b, c, d), fract(seed * 0.1) * 1000.0, palette(1.5, a, b, c, d));\n}\n\nvec3 rotate(vec3 p, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec3(c * p.x - s * p.z, p.y, s * p.x + c * p.z);\n}\n\nfloat layeredNoise(vec3 p, float amplitude, float frequency, float persistence, int octaves, float seed) {\n    float n = 0.0;\n    for(int i = 0; i < octaves; i++) {\n        n += noise(p.xy * frequency, seed) * amplitude;\n        amplitude *= persistence;\n        frequency *= 2.0;\n        p = rotate(p, 45.0);\n    }\n    return n;\n}\n\nfloat sphere(vec3 ro, vec3 rd, float radius) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - radius * radius;\n    float h = b * b - c;\n    if(h < 0.0)\n        return -1.0;\n    return -b - sqrt(h);\n}\n\nvec3 colorBanding(float n, ColorScheme scheme) {\n    vec3 color = vec3(0);\n    if(n > 0.92)\n        return scheme.color7;\n    else if(n > 0.80)\n        color = scheme.color6;\n    else if(n > 0.68)\n        color = scheme.color5;\n    else if(n > 0.53)\n        color = scheme.color4;\n    else if(n > 0.37)\n        color = scheme.color3;\n    else if(n > 0.21)\n        color = scheme.color2;\n    else\n        color = scheme.color1;\n    return color;\n}\n\nconst mat4 bayerMatrix = mat4(0.0 / 16.0, 8.0 / 16.0, 2.0 / 16.0, 10.0 / 16.0, 12.0 / 16.0, 4.0 / 16.0, 14.0 / 16.0, 6.0 / 16.0, 3.0 / 16.0, 11.0 / 16.0, 1.0 / 16.0, 9.0 / 16.0, 15.0 / 16.0, 7.0 / 16.0, 13.0 / 16.0, 5.0 / 16.0);\n\nvec3 applyDithering(float noiseValue, vec2 uv, ColorScheme scheme) {\n    int x = int(mod(uv.x, 4.0));\n    int y = int(mod(uv.y, 4.0));\n    float threshold = bayerMatrix[x][y];\n    noiseValue += threshold * DITHER_STRENGTH;\n    return colorBanding(noiseValue, scheme);\n}\n\nvec3 applyLighting(vec3 color, vec3 normal, vec3 lightDir) {\n    float diffuse = max(dot(normal, lightDir), 0.0);\n    return color * diffuse;\n}\n\nconst float PI = 3.14159265;\n\nconst vec2 freq_range = vec2(1., 2. * PI); // frequency range for r1\nconst vec2 amp_range  = vec2(1., 1.);      // amplitude range for r1\nconst int num_waves   = 5;                 // number of waves for r2\nconst float dampening = 1.;                // \nconst float speed     = 0.25;                // how fast the image changes\nconst int num_sectors = 5;                 // number of radial sectors\nconst float pole_size = 100.;              // \n\n// pseudorandom number generator\nfloat rand(inout vec2 seed) {\n    seed += 1.;\n    \n    float x = fract(seed.x);\n    float s0 = fract(sin(dot(floor(seed - 1.), vec2(12.9898, 78.233))) * 43758.5453);\n    float s1 = fract(sin(dot(floor(seed),      vec2(12.9898, 78.233))) * 43758.5453);\n    float s2 = fract(sin(dot( ceil(seed),      vec2(12.9898, 78.233))) * 43758.5453);\n    float s3 = fract(sin(dot( ceil(seed + 1.), vec2(12.9898, 78.233))) * 43758.5453);\n    \n    float r1 = 0.5 * (s2 - s0);\n    float r2 = 0.5 * (s3 - s1);\n    \n    return (((2. * (s1 - s2) + r1 + r2) * x - 3. * (s1 - s2) - 2. * r1 - r2) * x + r1) * x + s1;\n}\n\n// sine wave with random amplitude, phase, and frequency\nfloat r1(inout vec2 seed, float x) {\n    x *= ((freq_range.y - freq_range.x) * rand(seed) + freq_range.x);\n    x += 2. * PI * rand(seed);\n    return ((amp_range.y - amp_range.x) * rand(seed) + amp_range.x) * sin(x);\n}\n\n// fourier series\nfloat r2(inout vec2 seed, float x) {\n    float value = 0.;\n    for (int i = 0; i < num_waves; i++)\n        value += r1(seed, x);\n    return atan(dampening * value) / dampening; // atan to reduce the higher values\n}\n\n// gives the fourier series sharp points\nfloat r3(inout vec2 seed, float x) {\n    return (abs(r2(seed, x)) * r2(seed, x) + abs(r2(seed, x)) * r2(seed, x));\n}\n\n// hue from angle\nvec3 color(float theta) {\n    return sqrt(0.5 + cos(theta - PI * vec3(0, 1, 2) * 2. / 3.) / 2.);\n}\n#define saturate(x) clamp(x, 0., 1.)\nfloat plainstep(float a, float b, float t) { return saturate((t - a) / (b - a)); }\n\n// smooth fract from: https://www.shadertoy.com/view/clB3zc\nfloat sfract(float x){ float fw = saturate(fwidth(x)); return min(fract(x) / (1. - fw), fract(-x) / fw); }\nfloat sfloor(float x){ return max(floor(x), x - sfract(x)); }\n\n\n// SDF heart from iq: https://www.shadertoy.com/view/3tyBzV\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdHeart( in vec2 p ) {\n    p.x = abs(p.x);\n    if (p.y + p.x > 1.0) return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)), dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nvec3 palette(float t, vec3 scale, vec3 offset) {\n    vec3 x = 0.55 + 0.5 * cos(6.28318 * (scale * t + offset));\n    x=1.-x; x*=x; x=1.-x;\n    return x; }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (floor(fragCoord / PIXEL_SIZE) * PIXEL_SIZE - iResolution.xy * 0.5) / iResolution.y;\n\n    float intervalNumber = floor((5.0 + iTime) / INTERVAL);\n    ColorScheme scheme = getProceduralColorScheme(intervalNumber);\n\n    vec3 ro_planet = vec3(0.0, 0.0, 2.3);\n    vec3 ro_clouds = vec3(0.0, 0.0, 2.25);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    float t_planet = sphere(ro_planet, rd, 1.0);\n   \n  \n    \n        vec3 pos = ro_planet + t_planet * rd;\n        vec3 norm = normalize(pos);\n\n        pos = rotate(pos, iTime * 0.15);\n        vec3 rotatedNorm = normalize(rotate(norm, iTime * 0.1));\n\n        float noiseValue = layeredNoise(rotatedNorm * 3.1415, 0.75, 1.0, 0.5, 8, scheme.seed);\n\n        vec3 color;\n       \n            color = applyDithering(noiseValue, fragCoord.xy / PIXEL_SIZE, scheme);\n      \n\n        vec3 lightDir = normalize(vec3(1.5, 1.0, 1.5));\n        color = applyLighting(color, norm, lightDir);\n      \n            vec3 pos2 =   rd;\n            vec3 rotatedNorm2 = normalize(rotate(pos2, iTime * 0.0));\n            vec3 norm2 = normalize(pos2);\n\n            float noiseValue2 = layeredNoise(rotatedNorm2 * 1.311, 1.0, 1.0, 0.5, 41, scheme.seed);\n            float noiseValueFinal = pow(noiseValue2, 1.05) - 1.0;\n            vec3 color2 = vec3(noiseValueFinal);\n\n            color2 = applyDithering(noiseValue2, fragCoord.xy / PIXEL_SIZE, scheme);\n            color2 = applyLighting(color2, norm2, lightDir);\n\n            fragColor = vec4(mix(color, (color2 * 0.56) * scheme.atmosphereColor, noiseValue2 * 0.45) + color, 1.0);\n       \n            fragColor = vec4(color*vec3(0,0,2.), 1.0);\n        \n        \n        \n\n    \n    \n     vec2 seed = vec2(speed * iTime*0.0);\n    vec2 p = fragCoord.xy / iResolution.xy;\n \n    p = p * 2. - vec2(1.0, 0.5);\n    p.x *= iResolution.x / iResolution.y;\n\n    float div = 10.;\n\n    float heartBeat = 0.;\n    heartBeat = pow(1. - abs(abs(sin(iTime * 3.14159) * 2.) - 1.), 2.) *.01;    \n    float x = saturate(sdHeart(p) + heartBeat + 2./div);\n\n    x = sfloor(x*div)/div; // smooth floor gradient\n\n    x = mix(x, smoothstep(0., 5., x), 0.5);\n\n    vec3 col = palette( x * 05.15 + -5.05, vec3(5.0,0.0,1.0),vec3(0.0,0.33,0.67) );\n    col = normalize(col);\n    // center origin and convert to polar coordinates\n    vec2 coord = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    coord = vec2(length(coord), atan(coord.x, -coord.y) / 2.);\n    \n    float theta = 0.;\n    for (int i = 0; i < num_sectors; i++)\n        theta += r3(seed, coord.x+cos(iTime)) * pow(sin(coord.y + float(i) * PI / float(num_sectors)+cos(iTime)), 2.);\n    \n\n    fragColor+=vec4(col+color*theta\n    ,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}