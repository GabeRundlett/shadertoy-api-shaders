{
    "Shader": {
        "info": {
            "date": "1580826115",
            "description": "If you would like to the isometric framework, fill the sdMain(vec3 p, vec2 idD) function.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "WtcXD8",
            "likes": 36,
            "name": "Day 47 - Isometric 2",
            "published": 3,
            "tags": [
                "isometric",
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 947
        },
        "renderpass": [
            {
                "code": "// Fork of \"Day 45 - Isometric\" by jeyko. https://shadertoy.com/view/WltXR7\n// 2020-02-04 12:31:12\n\nvec3 glow = vec3(0);\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n#define pmod(p, x) mod(p, x) - x*0.5\n#define pi acos(-1.)\n\n#define modDist vec2(1.42,1.)\n\n#define xOffs 0.71\n#define yOffs 0.7\n\n#define ZOOM 5.\n#define mx (50.*iMouse.x/iResolution.x)\n#define my (-iTime + 50.*iMouse.y/iResolution.x)\nfloat sdBox(vec3 p, vec3 r){\n\tp = abs(p) - r;\n\treturn max(p.x, max(p.y, p.z));\n}\nfloat sdBoxIQ( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdOcta(vec3 p, vec3 s, vec2 id){\n\tp = abs(p) - s;\n    float d = max(p.x, max(p.y, p.z));\n    \n    d =  dot(p.xz + s.zx*0.5, normalize(vec2(1)));\n    \n    d = max(d, dot(p.xy + s.xy*0.5, normalize(vec2(1))));\n    \n    d = max(d, dot(p.yz + s.xy*0.5, normalize(vec2(1))));\n    \n    return d;\n}\nfloat sdMain(vec3 p, vec2 idD){\n\tfloat d = 10e6;\n    vec3 q = p;\n    float steps = 5.;\n    float m = sin(iTime + idD.x + idD.y*4.);\n    for(float i = 0.; i < steps; i++){\n    \td = min(d,sdBoxIQ(p, vec3(0.51 - 0.5*i/steps)) - .02);\t\n        p.y -= 0.25 + m*0.15;\n    }\n    \n    vec3 s = vec3(0.77);\n    \n    d = max(d, -max(sdOcta(q, s, idD), q.y - 0.5));\n\treturn d;\n}\n\n\nvec2 id;\n\nfloat sdIso(vec3 p, vec2 id){\n\tfloat d = 10e6;\n    //p.z -= 0.;\n    vec3 q = p;\n    \n    // ME\n    p.x -= id.y*xOffs;\n    p.y += id.y*yOffs;\n    p.xz = pmod(p.xz, modDist);\n    p.xy *= rot(pi*0.25);\n    d = min(d, sdMain(p, id));\n    \n    vec2 idD = id;\n    \n    // BOTTOM\n    p = q;\n    idD.y += 1.;\n    p.x -= idD.y*xOffs;\n    p.y += idD.y*yOffs;\n    p.xz = pmod(p.xz + vec2(0,0. - id.y), vec2(modDist.x,modDist.y*3.));\n    \n    if (p.x > 0.){\n        idD.x -= 1.;\n    }\n    p.xy *= rot(pi*0.25);\n    d = min(d, sdMain(p, idD));\n    \n\n    // RIGHT\n    p = q;\n    idD = id;\n    idD.x -= 1.;\n    p.x -= idD.y*xOffs;\n    p.y += idD.y*yOffs;\n    p.xz = pmod(p.xz + vec2(modDist.x*1.- idD.x*modDist.x*1.,0), vec2(modDist.x*3.,modDist.y));\n    p.xy *= rot(pi*.25);\n    d = min(d, sdMain(p, idD));\n    \n    // LEFT\n    p = q;\n    idD = id;\n    idD.x += 1.;\n    p.x -= idD.y*xOffs;\n    p.y += idD.y*yOffs;\n    p.xz = pmod(p.xz + vec2(modDist.x*1.- idD.x*modDist.x*1.,0), vec2(modDist.x*3.,modDist.y));\n    p.xy *= rot(pi*.25);\n    d = min(d, sdMain(p, idD));\n    \n    // TOP\n    idD = id;\n    idD.y -= 1.;\n    p = q;\n    p.x -= idD.y*xOffs;\n    p.y += idD.y*yOffs;\n    p.xz = pmod(p.xz + vec2(0.,-1. - id.y), vec2(modDist.x,modDist.y*3.));\n    if (p.x < 0.){\n      idD.x += 1.;\n    }\n    p.xy *= rot(pi*0.25);\n    d = min(d, sdMain(p, idD));\n    \n    \n\treturn d;\n}\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n    id = floor(p.xz/modDist);\n    id.x = floor((p.x - modDist.x*0.5*id.y)/modDist.x);\n    d.x = min(d.x, sdIso(p, id));\n    d.x *= 0.7;\n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tp = ro;\n    vec2 d;\n    hit = false;\n    for(int i = 0; i < 100 ;i++){\n    \td = map(p);\n        //glow += exp(-d.x*60.);\n        if(d.x < 0.001){\n        \thit = true;\n            break;\n        }\n        if(t > 10.){\n        \t//hit = true;\n            break;\n        }\n    \tt += d.x;\n        p = ro + rd*t;\n    }\n\n\treturn d;\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.0001,0);\n\treturn normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x\n    ));\n}\n\nvec3 getRd(inout vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro );\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    ro -= ZOOM*dir;\n\treturn dir + right*uv.x + up*uv.y;\n}\nvec3 getRdIsometric(inout vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 rd = normalize(\n        lookAt -\n        ro\n    );\n    \n    vec3 right = normalize(cross(vec3(0,1,0), rd));\n    vec3 up = normalize(cross(rd, right));\n    \n    \n    ro += right*uv.x*ZOOM;\n    ro += up*uv.y*ZOOM;\n \treturn rd;\n\n}\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.4, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 quv = uv;\n    uv.xy *= rot(0.7);\n    vec3 col = vec3(0.0);\n    vec3 lookAt = vec3(0,-1,-2);\n    \n    \n    vec3 ro = vec3(0,8,0);\n   \n    vec3 rd = getRdIsometric(ro, lookAt, uv); \n    //vec3 rd = getRd(ro, lookAt, uv); \n        \n    vec3 p;\n    \n    //ro.x += mx;\n    ro.z += my;\n    ro.y -= my*0.65;\n    //ro += rd*5.4;\n    \n    float t = 0.; bool hit;\n    \n    vec2 d = march(ro, rd, p, t, hit);\n    \n    vec3 l = normalize(vec3(1.9,1.,.7));\n    \n    if (hit){\n        vec3 n = getNormal(p);\n        n.y *= -1.;\n        n.g*=0.4;\n        n.xy *= rot(0.2 + sin(iTime)*0.2 + uv.x*0.6);\n        float s = calcSoftshadow(p,l,0.01,2.4, 0);\n    \tcol += 0.5 + n*0.6;\n        \n        col = clamp(col, 0., 1.);\n\n        \n        col *= s;\n    \t\n    } else {\n    \tcol = mix(\n            vec3(0.8,0.1,0.1)*1.9,\n            vec3(0.4,0.6,0.5)*1.7,    \n\t\t\tabs(sin(iTime*0.5))\n                 );\n        ;\n        col.xy *= rot(0.1 - uv.x*0.3);\n    }\n    \n    \n    //col -= glow*0.01;\n    \n    col = max(col, 0.);\n    \n    col = clamp(col, 0., 1.);\n    //col = pow(col, vec3(0.45));\n    col = pow(col, vec3(0.7));\n    \n    \n    //col = pow(col, vec3(1.7));\n    \n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}