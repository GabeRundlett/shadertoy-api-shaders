{
    "Shader": {
        "info": {
            "date": "1665029254",
            "description": "scalar wave equation\n1 unit = 1 pixel\nwarning: the code is messy and I am playing with it, like a sandbox",
            "flags": 32,
            "hasliked": 0,
            "id": "slyfRt",
            "likes": 11,
            "name": "2D Scalar Wave Equation",
            "published": 3,
            "tags": [
                "wave",
                "equation",
                "pde"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 286
        },
        "renderpass": [
            {
                "code": "// 2D Scalar Wave Equation\n// Made by Jacob Bingham (Zi7ar21) on October 6th, 2022\n// Last updated: still being worked on lol\n\n// Features\n// - Implementation of the 2-dimensional scalar wave equation\n// - high-accuracy central finite differences\n//   - https://en.wikipedia.org/wiki/Finite_difference_coefficient#Central_finite_difference\n\n// You can run multiple timesteps per frame with the Shadertoy Unofficial Plugin\n// You can also copy and paste Buffer A but be weary you may need to make a few modifications to wherever iFrame is used\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    //   red: positive amplitude\n    // green: rate of change\n    //  blue: negative amplitude\n    fragColor = vec4(max( fragColor.x, 0.0), 0.1 * abs(fragColor.y), max(-fragColor.x, 0.0), 1.0);\n\n    //fragColor = vec4(0.5 * vec3(fragColor.x + fragColor.y), 1.0); // greyscale total ampltiude approximation\n\n    //fragColor = vec4(0.5 * vec3(fragColor.r + 1.5 * fragColor.g + fragColor.b), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// timestep\n#define dt 0.0166666666666667\n//#define dt 0.0333333333333333\n//#define dt 0.01\n\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\nconst float     PI = 3.141592653589793; // Pi\nconst float TWO_PI = 6.283185307179586; // 2 * Pi = \"Tau\"\nconst float INV_PI = 0.318309886183791; // 1 / Pi\n//const float     PI = uintBitsToFloat(0x40490FDBu); // Pi\n//const float TWO_PI = uintBitsToFloat(0x40C90FDBu); // 2 * Pi = \"Tau\"\n//const float INV_PI = uintBitsToFloat(0x3EA2F983u); // 1 / Pi\n\n// pro tip: if you are going to square or compare lengths of vectors, use dot product instead\n// it saves an extra sqrt() operation and improves performance, if the compiler didn't already\n// notice what you were trying to do and optimize it... (spoiler: it probably won't)\n// length(v)^2 = dot(v, v)\nfloat dot2(vec2 v) { return dot(v, v); }\nfloat dot2(vec3 v) { return dot(v, v); }\nfloat dot2(vec4 v) { return dot(v, v); }\n\nfloat sinc(float x) {\n    // definite integral of pi\n    //return x != 0.0 ? sin(x) / x : 1.0; // un-normalized\n\n    // definite integral of 1\n    return x != 0.0 ? sin(PI * x) / (PI * x) : 1.0; // normalized\n}\n\n// Even smoother smoothstep(), see https://en.wikipedia.org/wiki/Smoothstep\nfloat smootherstep(float edge0, float edge1, float x) {\n    x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n\n    return x * x * x * (x * (x * 6.0 - 15.0) + 10.0);\n}\n\n// Repeating texelFetch()\nvec4 texelFetch_repeat(sampler2D _sampler, ivec2 _P, int _lod) {\n    ivec2 _textureSize = textureSize(_sampler, _lod);\n\n    // Broken on every platform I've tried testing, see explanation below\n    //_P.x = _P.x % _textureSize.x;\n    //_P.y = _P.y % _textureSize.y;\n\n    // :sob: as of GLSL 300, the % operator is undefined if one or both input integers are negative\n    // so we blasphemously convert our integers to floats and back and use floating point modulo...\n    // See 12.33: https://registry.khronos.org/OpenGL/specs/es/3.0/GLSL_ES_Specification_3.00.pdf\n    _P.x = int(mod(float(_P.x), float(_textureSize.x)));\n    _P.y = int(mod(float(_P.y), float(_textureSize.y)));\n\n    return texelFetch(_sampler, _P, _lod);\n}\n\n/*\n*/\n// Cellular noise (\"Worley noise\") in 2D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n// https://github.com/stegu/webgl-noise\n\n// Modulo 289 without a division (only multiplications)\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\n// Modulo 7 without a division\nvec3 mod7(vec3 x) {\n  return x - floor(x * (1.0 / 7.0)) * 7.0;\n}\n\n// Permutation polynomial: (34x^2 + 6x) mod 289\nvec3 permute(vec3 x) {\n  return mod289((34.0 * x + 10.0) * x);\n}\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Standard 3x3 search window for good F1 and F2 values\nvec2 cellular(vec2 P) {\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 3/7\n#define jitter 1.0 // Less gives more regular pattern\n\tvec2 Pi = mod289(floor(P));\n \tvec2 Pf = fract(P);\n\tvec3 oi = vec3(-1.0, 0.0, 1.0);\n\tvec3 of = vec3(-0.5, 0.5, 1.5);\n\tvec3 px = permute(Pi.x + oi);\n\tvec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13\n\tvec3 ox = fract(p*K) - Ko;\n\tvec3 oy = mod7(floor(p*K))*K - Ko;\n\tvec3 dx = Pf.x + 0.5 + jitter*ox;\n\tvec3 dy = Pf.y - of + jitter*oy;\n\tvec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n\tp = permute(px.y + Pi.y + oi); // p21, p22, p23\n\tox = fract(p*K) - Ko;\n\toy = mod7(floor(p*K))*K - Ko;\n\tdx = Pf.x - 0.5 + jitter*ox;\n\tdy = Pf.y - of + jitter*oy;\n\tvec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n\tp = permute(px.z + Pi.y + oi); // p31, p32, p33\n\tox = fract(p*K) - Ko;\n\toy = mod7(floor(p*K))*K - Ko;\n\tdx = Pf.x - 1.5 + jitter*ox;\n\tdy = Pf.y - of + jitter*oy;\n\tvec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n\t// Sort out the two smallest distances (F1, F2)\n\tvec3 d1a = min(d1, d2);\n\td2 = max(d1, d2); // Swap to keep candidates for F2\n\td2 = min(d2, d3); // neither F1 nor F2 are now in d3\n\td1 = min(d1a, d2); // F1 is now in d1\n\td2 = max(d1a, d2); // Swap to keep candidates for F2\n\td1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n\td1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n\td1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n\td1.y = min(d1.y, d1.z); // nor in  d1.z\n\td1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n\treturn sqrt(d1.xy);\n}\n/*\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "float source_waveform(float t) {\n    return sin(t);\n    //return sin(1.0 * t) + sin(2.0 * t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    if(iFrame < 1) {\n        fragColor = vec4(0);\n\n        //fragColor = vec4(2.0 * sinc(TWO_PI * length(uv - vec2(0.5, 0.0)) * 10.0), 0.0, 0.0, 0.0);\n        //fragColor = vec4(0.5 * texture(iChannel1, fragCoord / 256.0).x, 0.0, 0.0, 0.0);\n        //uv = 40.0 * (uv - vec2(0.5, 0.0));\n        //fragColor = vec4(10.0 * exp(-dot2(uv)), 0.0, 0.0, 0.0);\n        //if(length(uv) < 0.1) fragColor = vec4(0);\n\n        return;\n    }\n\n    // Wave Speed\n    const float c = 10.0;\n    //float c = 5.0 * uv.y + 10.0;\n    //float c = 10.0 - 2.0 * smootherstep(0.0, 1.0, 1.0 - dot(4.0 * uv, 4.0 * uv));\n    //float c = dot2(vec2(8.0, 2.0) * (uv - vec2(0.75, 0.0))) < 1.0 ? 6.5 : 10.0;\n    //float c = 10.0 - 3.5 * smootherstep(1.0, 0.9, dot2(vec2(8.0, 2.0) * (uv - vec2(0.75, 0.0))));\n    //float c = 10.0 - 3.3333333333333333 * smootherstep(1.0, 0.8, dot2(vec2(2.0, 2.0) * uv));\n    //float c = 10.0 - 3.5 * smootherstep(0.8, 0.85, 1.0 - cellular(2.5 * uv).x);\n    //float c = abs(uv.y) < 0.5 && dot2(0.5 * (uv - vec2(1.9, 0.0))) < 1.0 && dot2(0.5 * (uv + vec2(1.9, 0.0))) < 1.0 ? 6.6666666666666667 : 10.0;\n\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    // https://en.wikipedia.org/wiki/Finite_difference_coefficient#Central_finite_difference\n\n    /*\n    float x0 = texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(2, 0), 0).x;\n    float x1 = texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(1, 0), 0).x;\n    float x2 = texelFetch_repeat(iChannel0, ivec2(fragCoord)              , 0).x;\n    float x3 = texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(1, 0), 0).x;\n    float x4 = texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(2, 0), 0).x;\n    float y0 = texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 2), 0).x;\n    float y1 = texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 1), 0).x;\n    float y2 = texelFetch_repeat(iChannel0, ivec2(fragCoord)              , 0).x;\n    float y3 = texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 1), 0).x;\n    float y4 = texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 2), 0).x;\n\n    float d2x = -(1.0 / 12.0) * x0 + (4.0 / 3.0) * x1 - (5.0 / 2.0) * x2 + (4.0 / 3.0) * x3 - (1.0 / 12.0) * x4;\n    float d2y = -(1.0 / 12.0) * y0 + (4.0 / 3.0) * y1 - (5.0 / 2.0) * y2 + (4.0 / 3.0) * y3 - (1.0 / 12.0) * y4;\n    */\n    /*\n    float x0 = texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(4, 0), 0).x;\n    float x1 = texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(3, 0), 0).x;\n    float x2 = texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(2, 0), 0).x;\n    float x3 = texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(1, 0), 0).x;\n    float x4 = fragColor.x;\n    float x5 = texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(1, 0), 0).x;\n    float x6 = texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(2, 0), 0).x;\n    float x7 = texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(3, 0), 0).x;\n    float x8 = texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(4, 0), 0).x;\n\n    float y0 = texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 4), 0).x;\n    float y1 = texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 3), 0).x;\n    float y2 = texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 2), 0).x;\n    float y3 = texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 1), 0).x;\n    float y4 = fragColor.x;\n    float y5 = texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 1), 0).x;\n    float y6 = texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 2), 0).x;\n    float y7 = texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 3), 0).x;\n    float y8 = texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 4), 0).x;\n\n    const float c0 = -(  1.0 / 560.0);\n    const float c1 =  (  8.0 / 315.0);\n    const float c2 = -(  1.0 /   5.0);\n    const float c3 =  (  8.0 /   5.0);\n    const float c4 = -(205.0 /  72.0);\n    const float c5 =  (  8.0 /   5.0);\n    const float c6 = -(  1.0 /   5.0);\n    const float c7 =  (  8.0 / 315.0);\n    const float c8 = -(  1.0 / 560.0);\n\n    float d2x = (c0 * x0) + (c1 * x1) + (c2 * x2) + (c3 * x3) + (c4 * x4) + (c5 * x5) + (c6 * x6) + (c7 * x7) + (c8 * x8);\n    float d2y = (c0 * y0) + (c1 * y1) + (c2 * y2) + (c3 * y3) + (c4 * y4) + (c5 * y5) + (c6 * y6) + (c7 * y7) + (c8 * y8);\n    float lap = d2x + d2y;\n    */\n\n    float lap =\n    ( 0.250 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(-1,  1), 0).x) +\n    ( 0.500 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2( 0,  1), 0).x) +\n    ( 0.250 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2( 1,  1), 0).x) +\n    ( 0.500 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(-1,  0), 0).x) +\n    (-3.000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2( 0,  0), 0).x) +\n    ( 0.500 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2( 1,  0), 0).x) +\n    ( 0.250 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(-1, -1), 0).x) +\n    ( 0.500 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2( 0, -1), 0).x) +\n    ( 0.250 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2( 1, -1), 0).x);\n\n    fragColor.y = fragColor.y + dt * (c * c * lap);\n    \n    fragColor.x = fragColor.x + dt * fragColor.y;\n\n    //fragColor.x += 0.1 * exp(10.0 * -length(uv)) * sin(TWO_PI * length(uv) * 10.0 - dt * 0.1 * float(iFrame));\n\n    //if(uv.x < 0.0 && texture(iChannel1, 0.5 * uv).x < 0.3) fragColor = vec4(0);\n\n    \n    //if(length(uv - vec2(0.76, 0.3)) < 0.06) fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    //if(length(uv - vec2(0.75, 0.3)) < 0.05) fragColor = vec4(sin(1.0 * TWO_PI * mod(dt * float(iFrame), 1.0)), 0.0, 0.0, 0.0);\n    //if(abs(uv.x - 0.75) < 0.05 && abs(uv.y - 0.5) < 0.05) fragColor = vec4(sin(1.0 * TWO_PI * mod(dt * float(iFrame), 1.0)), 0.0, 0.0, 0.0);\n    //if(fragCoord.x > iResolution.x - 30.0 && fragCoord.y > 0.0 && fragCoord.y < iResolution.y - 0.0) fragColor = vec4(sin(mod(1.0 * TWO_PI * dt * float(iFrame), TWO_PI)), 0.0, 0.0, 0.0);\n    //if(fragCoord.x > iResolution.x - 25.0) fragColor = vec4(0);\n\n    //fragColor = mix(dt * vec4(2.0 * sin(TWO_PI * dt * float(iFrame) * 0.1), 0.0, 0.0, 0.0), fragColor, clamp(length(uv - vec2(0.5, 0.0)) / 0.03, 0.0, 1.0));\n\n    //fragColor = mix(fragColor, vec4(5.0 * sin(TWO_PI * dt * float(iFrame) * 1.0), 0.0, 0.0, 0.0), smoothstep(0.05, 0.0, length(uv - vec2(dt * float(iFrame) * 0.015, 0.0))));\n    float th = TWO_PI * fract(TWO_PI * dt * float(iFrame) * 0.01);\n    //fragColor = mix(fragColor, vec4(2.5 * sin(TWO_PI * dt * float(iFrame) * 1.0), 0.0, 0.0, 0.0), smoothstep(0.03, 0.0, length(uv - vec2(dt * float(iFrame) * 0.01, 0.0))));\n    fragColor = mix(fragColor, vec4(5.0 * source_waveform(TWO_PI * dt * float(iFrame) * 1.00), 0.0, 0.0, 0.0), smoothstep(0.05, 0.0, length(uv - 0.05 * vec2(cos(th), sin(th)))));\n    fragColor = mix(fragColor, vec4(5.0 * source_waveform(TWO_PI * dt * float(iFrame) * 1.00), 0.0, 0.0, 0.0), smoothstep(0.05, 0.0, length(uv - 0.05 * vec2(cos(th+1.5), sin(th+1.5)))));\n\n    //if(uv.x > 1.6 && abs(uv.y) < 0.2) fragColor = dt * vec4(2.0 * sin(TWO_PI * dt * float(iFrame) * 0.02), 0.0, 0.0, 0.0);\n\n    // slits\n\n    \n\n    const float r = 20.0; // repetition rate\n\n    //if(abs(fragCoord.x - 0.5 * iResolution.x) < 5.0 && abs(mod((fragCoord.y - 0.5 * iResolution.y) + 0.5 * r, r) - 0.5 * r) < 5.0) fragColor = vec4(0);\n\n\n    // Boundary conditions\n    if(fragCoord.x < 25.0 || fragCoord.x > iResolution.x - 25.0\n    //|| fragCoord.y < 20.0 || fragCoord.y > iResolution.y - 20.0) fragColor = vec4(0); // reflective\n    || fragCoord.y < 25.0 || fragCoord.y > iResolution.y - 25.0) fragColor.xy *= 0.985; // absorbant (not perfect)\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}