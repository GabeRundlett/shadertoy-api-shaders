{
    "Shader": {
        "info": {
            "date": "1568901703",
            "description": "Constructing a grid of generalized isosceles triangles, then using the resultant geometric components to produce a jigsaw related pattern.",
            "flags": 0,
            "hasliked": 0,
            "id": "3sd3Rj",
            "likes": 17,
            "name": "Isosceles Jigsaw Strips",
            "published": 3,
            "tags": [
                "2d",
                "2d",
                "grid",
                "triangle",
                "pattern",
                "art",
                "jigsaw",
                "isosceles"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 1134
        },
        "renderpass": [
            {
                "code": "/*\n\n\tIsosceles Jigsaw Strips\n\t-----------------------\n\n\tAfter looking at Fizzer's really cool and clever diamond grid based jigsaw \n\tpattern (the link's below), I made a comment regarding some hexagon and\n\ttriangle jigsaw patterns I'd been meaning to post, then forgot about it. \n\tAnyway, it's been a while, but better late than never. \n\n\tTriangle jigsaw patterns aren't common. I haven't seen code for one, but I'm\n\tsure it's out there, and you can find pictures in equilateral form. Just to \n    be different, I figured I'd put together an isosceles version. To mix things \n\tup some more, I decided to give the resultant pattern some pseudo depth by \n    taking the nodules off one side of the individual triangle pieces, then \n    applying an edge-shadow trick I've seen in various triangle grid examples, \n    which gives it that weird sense of layered depth.\n\n    By the way, there are a couple of defines below for anyone wants to see a \n    regular triangle jigsaw pattern with connecting nodules on all three sides.\n\n\tThe jigsaw logic itself wasn't that difficult, but coding the isosceles grid \n\twas a little frustrating, since I decided to code it from scratch. There's a \n\tcommon way to code up a basic equilateral triangle grid that involves scaling \n    and skewing. However, I wanted to take a more direct approach that would \n    bypass the skewing, eliminate grid rotation, and allow for any isosceles \n    triangle grid to be rendered by simply changing the scaling coordinates.\n\n    Later, I'll put up a simpler example that makes use of the isosceles grid, \n    but for now, this is just a demonstration to show that it works. At some \n    stage, I'd like to put together a 3D version. \n\t\n\tBy the way, if you've never coded a jigsaw example before, it'd probably be\n\tbetter to start with a simple square jigsaw.\n\n    \n    \n    Other Examples:\n\n    // A regular square jigsaw pattern, but taking a clever diamond grid\n    // approach to avoid neighbor calculations. I wish I'd thought of it. :)\n    // On a side note, I was able to run with Fizzer's original geometric idea\n    // and cut down on things even more, so I might put up the results later.\n    Jigsaw Pattern - Fizzer\n    https://www.shadertoy.com/view/3tlXR4\n\n\n    // A jigsaw pattern on the 3D plane. Frustrating to make. :D\n    Jigsaw - Shane\n\thttps://www.shadertoy.com/view/XdGBDW\n\n*/\n\n\n// If you'd like to see a regular 3-sided triangle jigsaw pattern, then \n// uncomment this. It probably looks more natural with the equilateral \n// triangle setting turned on below.\n//#define STANDARD_JIGSAW\n\n// A regular equilateral scaling, which is just a special form of isosceles.\n//#define EQUILATERAL\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\n//float hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n\n    // The first line relates to ensuring that icosahedron vertex identification\n    // points snap to the exact same position in order to avoid hash inaccuracies.\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\n\n// IQ's signed distance to a 2D triangle.\nfloat sdTri(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2){\n\n\tvec2 e0 = p1 - p0, e1 = p2 - p1, e2 = p0 - p2;\n\n\tvec2 v0 = p - p0, v1 = p - p1, v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0, e0)/dot(e0, e0), 0., 1.);\n\tvec2 pq1 = v1 - e1*clamp( dot(v1, e1)/dot(e1, e1), 0., 1.);\n\tvec2 pq2 = v2 - e2*clamp( dot(v2, e2)/dot(e2, e2), 0., 1.);\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x);\n    vec2 d = min( min( vec2(dot(pq0, pq0), s*(v0.x*e0.y - v0.y*e0.x)),\n                       vec2(dot(pq1, pq1), s*(v1.x*e1.y - v1.y*e1.x))),\n                       vec2(dot(pq2, pq2), s*(v2.x*e2.y - v2.y*e2.x)));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\n\n// Triangle's incenter: The center of the inscribed circle, which in essence is \n// the largest circle that you can fit into a triangle.\nvec2 inCent(vec2 a, vec2 b, vec2 c){\n    \n    // Side lengths.\n    float bc = length(b - c), ac = length(a - c), ab = length(a - b);\n    return (bc*a + ac*b + ab*c)/(bc + ac + ab);    \n}\n\n// The scaling vector. Basically, it determines the height to width ratio.\n//\n#ifdef EQUILATERAL\n// An equilateral scaling, which is just a special kind of isosceles.\nconst vec2 s = vec2(1./.8660254, 1); \n#else\n// The default scale for this example. There's no reason behind it. I just liked\n// the way it made things look.\nconst vec2 s = vec2(1, 1./.8660254); \n#endif\n// Similar size equilateral. Just a larger version of vec2(1./.8660254, 1).\n//const vec2 s = vec2(4./3., 1./.8660254);\n//\n// One to one scaling -- which would effectively make the scaling redundant.\n//const vec2 s = vec2(1); \n\nvec3 triJigsaw(vec2 p){    \n \n    \n    // The relative vertice positions. You could hardcode these into the formulae \n    // below, but if you're performing various edge arithmetic, etc, they're handy \n    // to keep around.\n    const vec2 v0 = vec2(-.5), v1 = vec2(0, .5), v2 = vec2(.5, -.5);\n\n    // Scaling the cordinates down, which makes them easier to work with. You scale \n    // them back up, after the calculations are done.\n    p /= s;\n    \n    // Triangles pack a grid nicely, but unfortunately, if you want vertices to \n    // match up, each alternate row needs to be shifted along by half the base \n    // width. The following vector will help effect that.\n    float ys = mod(floor(p.y), 2.)*.5;\n    vec4 ipY = vec4(ys, 0, ys + .5, 0);\n    \n    // Two triangles pack into each square cell, and each triangle uses the bottom \n    // left point as it's unique identifier. The two points are stored here.\n    vec4 ip4 = floor(p.xyxy + ipY) - ipY + .5; \n    \n    // The local coordinates of the two triangles are stored here.\n    vec4 p4 = fract(p.xyxy - ipY) - .5;\n    \n    // Which isoso... I always struggle to spell it... isosceles triangle\n    // are we in? Right way up, or upside down. By the way, if you're wondering\n    // where the following arises from, \"abs(x) + abs(y) - c\" partitions \n    // a square and \"abs(x) + y - c\" partitions a triangle.\n    float itri = (abs(p4.x)*2. + p4.y<.5)? 1. : -1.;\n    \n    // Depending on which triangle we're in, return a vector containing the local \n    // coordinates in the first two spots, and the unique position-based identifying \n    // number in the latter two spots. These two positions would be all you'd need\n    // to render a colored triangle grid. However, when combined with the triangle \n    // orientation and vertices (above), you can render more interesting things.\n    p4 = itri>0.? vec4(p4.xy*s, ip4.xy) : vec4(p4.zw*s, ip4.zw);\n\n    // Making a copy of the triangle's local coordinates and ID. It's not particularly\n    // necessary, but saves a bit of extra writing and confusion.\n    p = p4.xy; // Local coordinates.\n    vec2 ip = p4.zw; // Triangle ID.\n    \n    \n    // The unscaled triangle vertices, which double as an ID: Note that the vertices of\n    // alternate triangles are flipped in a such a way that edge neighboring edge vertices\n    // match up.\n    vec2[3] vID = vec2[3](v0*itri, v1*itri, v2*itri);\n    \n    // Edge IDs, based on the vertex IDs above. The mid points of neighboring triangles\n    // occur in the same position, which means both triangles will generate the same\n    // unique random number at that position. This is handy for all kinds of things,\n    // including determining where and how to place a jigsaw nodule.\n    vec2[3] eID = vec2[3](mix(vID[0], vID[1], .5), mix(vID[1], vID[2], .5), mix(vID[2], vID[0], .5));\n\n    \n    // Using the triangle vertices to calculate the incenter. If we were simply\n    // rendering a triangle with the vertices, we wouldn't need this, but we're \n    // going to perform some neighboring triangle comparisons.\n    vec2 cnID = inCent(vID[0], vID[1], vID[2]); \n    // A more accurate ID. It's three times larger than usual to avoid divide-by-three \n    // errors.\n    vec2 cnID2 = (vID[0] + vID[1] + vID[2]);///3.;\n    \n\n    \n    // Scaled vertices -- It's not absolutely necessary to have these, but when doing more\n    // complicated things, I like to swith between the unscaled IDs and the physical scaled\n    // vertices themselves.\n    vec2[3] vV = vec2[3](vID[0]*s, vID[1]*s, vID[2]*s);\n\n    // Scaled mid-edge vertices.\n    vec2[3] vE = vec2[3](eID[0]*s, eID[1]*s, eID[2]*s);\n\n \n    // Producing the triangle, then rounding the edges slightly, for aesthetic purposes.\n    //\n    // The folowing line moves the vertices in a bit. Normalizing the vectors is a choice. \n    // I think you need to leave them unnormalized for border width consistancy, but I'm\n    // not positive. Either way, it doesn't effect things too much.\n    vec2 vn0 = vID[0] - cnID, vn1 = vID[1] - cnID, vn2 = vID[2] - cnID;//*s*s \n    //\n    // The triangle is rendered smaller than needed, then a scalar is added to the\n    // final jigsaw piece (tri -= a;) prior to returning the values (See below).\n    float tri = sdTri(p, vV[0] - vn0*.2, vV[1] - vn1*.2, vV[2] - vn2*.2);\n    \n    //tri = max(tri, -(length(p - cnID*s) - .055)); // Displaying the scaled incenter.\n    //tri = max(tri, -(tri+ .27)); // Carving out the center.\n    \n    // Constructing the little jigsaw nodules, or whatever they're called. :)\n    //\n    // Neighboring triangles share boundaries from lines crossing from\n    // incircle to incircle. With an equilateral triangle, the \"cn\" value\n    // is zero, but for non-equilateral triangles -- like the isosceles, \n    // the extra step is necessary... Well, I'm pretty sure it is, but I'd\n    // double check. :)\n    float rndC = hash21(ip*3. - cnID2);\n\n     \n    for(int i = 0; i<3; i++){\n     \n        #ifndef STANDARD_JIGSAW\n        if(i == 1) continue;\n        #endif\n        \n        //vec2 n = normalize(eID[i] - cnID)*.04;\n        vec2 n = normalize(eID[i])*.04;\n        \n        // The normal running parallel to this specific edge.\n        vec2 n2 = normalize(vID[i] - vID[(i + 1)%3]);\n        \n         // Triangles on either side of an edge have the mid point of the shared\n        // edge in common. You can use this point to generate random values common\n        // to each triangle. In this case, it will be used to offset the jigsaw\n        // nodule by the normal running parallel to the edge.\n        float rndI2 = (hash21(ip + eID[i] + .1) - .5)*.25;\n        \n        // The random value of the edge's neighboring triangle, which will be\n        // compared to the value of the current triangle. In this case, if the\n        // current triangle has a random value less than that of the triangle\n        // on its neighboring edge, carve out a nodule, and update the ID. If \n        // it's not less, then render a prodruding nodule.\n        float rndI = hash21(ip*3. + eID[i]*6. + cnID2);\n        \n        // If the current random value is less than the edge neighbor, carve out\n        // a circular gap, then add a smaller circle to represent the prodruding\n        // nodule on the neighboring edge triangle.\n        if(rndC<rndI){\n            \n            float nodule = length(p - vE[i] + (n - n2*rndI2)) - .09;\n            \n            // Carve out a la\n            tri = max(tri, -(nodule - .12));\n            \n            //\n            if(nodule<tri){\n                ip += eID[i]*2.;\n                // The neighboring triangle has an incircle in the oppposite\n                // direction. I'd like to say I figured this obvious fact out \n                // immediately, but that's never how it goes. :)\n                cnID = -cnID; \n                \n                tri = min(tri, nodule);\n            }\n            \n        }\n        else {\n            \n            // If the current random value for the triangle is greater than\n            // that of the triangle on its neighboring edge, add a circular\n            // nodule. If you comment this out, you'll see that it doesn't\n            // do much, but is still necessary. With larger edge gaps, it'd\n            // be more visible. With no edge gaps, it wouldn't be.\n            float nodule = length(p - vE[i] - (n - n2*rndI2)) - .09;\n            tri = min(tri, nodule);\n            \n            // We should probably update the ID on the other side, but it \n\t\t\t// doesn't effect things, in this case, so I've left it out.\n            //if(nodule<tri) {\n                //ip += eID[i]*2.;\n                //cnID = -cnID;\n            //}\n\n        }\n    }\n    \n    \n    // This gives the triangular jigsaw piece a bit of roundness. If you took\n    // it away for a sharp look, you'd have to retweak the triangle and nodule\n    // sizes a bit.\n    tri -= .053;\n\n    // Return the distance field value, and the cell ID. Note that the cell ID\n    // is based on position, which means you could theoretically map it to \n    // height map, etc. Multiplying the value by the scaling vector will keep\n    // the aspect ratio intact.\n    return vec3(tri, (ip + cnID)*s);\n}\n\nvec3 fPalette(float i){\n    \n    \n    vec3 c = pow(min(vec3(1.4, 1, 1)*i, 1.), vec3(1, 2, 8));\n    \n    return mix(c, c.xzy, (1. - i)*.7);\n    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n\n    // Restricting the fullscreen resolution.\n    float iRes = min(iResolution.y, 800.);\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iRes;\n    \n    \n    // Scaling and translation.\n    float gSc = 7.;\n    // Depending on perspective; Moving the scene toward the bottom left, \n    // or the camera in the north east (top right) direction. \n    vec2 p = (uv*gSc - vec2(-1, -.5)*iTime);\n    \n    \n    // The smoothing factor.\n    float sf = 1./iRes*gSc;\n    \n    \n    // The isosceles jigsaw grid object.\n    vec3 d = triJigsaw(p);\n    // Taking an extra sample for highlighting purpuses.\n    vec3 dh = triJigsaw(p - vec2(-.02, .02)*s);\n    \n\n    #ifndef STANDARD_JIGSAW\n    // Applying some simple trigonometry to produce a repeat rotated shadow.\n    //\n    // The shadow depends upon the scaling vector to produce the triangles.\n    // If you look at the hight and half width of the isosceles, you'll see \n    // where the following comes from.\n\tfloat a = atan(s.x/s.y/2.);\n    // The base width of the triangle.\n    float w = cos(a)*s.x;\n    // Rotating by the base angle.\n    vec2 q = rot2(a)*p;\n    // Repeating the shadow object once every triangular base width.\n    q.x = abs(mod(q.x, w) - w);\n    // Giving the shadow a bit of length.\n    float sh = q.x - .02*w;   \n    #endif\n    \n  \n    // Setting the scene background to black.\n    vec3 col = vec3(0);\n\n    // Creating the textured overlay:\n    //\n    // Reading in the texture using the global coordinates, roughly converting \n    // from sRGB to linear (tx *= tx), then tweaking the result to suit. \n    vec3 tx = texture(iChannel0, p/gSc).xyz; tx *= tx;\n    tx = smoothstep(-.05, .35, tx); // Fading and lightening a bit.\n    // Giving each triangle and indidual texture color based on the unique\n    // positional ID. This gives things a little extra visual interest.\n    vec3 txTri = texture(iChannel0, d.yz/gSc/2.).xyz;  txTri *= txTri;\n    txTri = smoothstep(0., .5, txTri);\n\n    // Mixing the two textures above to give the individual triangle color.\n    vec3 tCol = min(txTri*tx, 1.);\n    \n    // Using the ID do dermine which triangles are upside down. Sometimes, you'd\n    // need to do this, so this is here to show that all that you need from a \n    // triangle grid function is the local coordinates and positional ID.\n    //if(fract(d.z/s.y)>.57) tCol *= vec3(3, 2, 1);\n    \n    // Using the distance values from the two field samples above to produce two\n    // shade values. Their difference produces a pseudo hightlight. Essentially,\n    // it's directional derivative based bump mapping.\n    //\n    float b = max(clamp(d.x/.1 + .5, 0., 1.) - clamp(dh.x/.1 + .5, 0., 1.), 0.)/(.03);\n\n    // Adding the bumped highlight to the triangle color. There are other ways\n    // to add layer highlights, but this will do.\n    tCol = min(tCol*(.9 + b*b*.02), 1.);    \n\n    // Adding the dark edge: Since the background is black, it's not necessary,\n    // but for other background colors, you'd need it.\n    //col = mix(col, vec3(0), (1. - smoothstep(0., sf, d.x)));\n    // Adding the colored triangle layer (slightly edged in) to the top. \n    col = mix(col, tCol, (1. - smoothstep(0., sf, d.x + .02)));\n\n    \n    #ifndef STANDARD_JIGSAW\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*16.*iRes/450., sh))*.7);\n    #endif\n    \n    // Applying a subtle silhouette, for art's sake.\n\tuv = fragCoord/iResolution.xy;\n    col *= pow(16.*(1. - uv.x)*(1. - uv.y)*uv.x*uv.y, 1./16.)*1.05; \n    \n    // Rough gamma correction, then output to the screen.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}