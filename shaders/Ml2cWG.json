{
    "Shader": {
        "info": {
            "date": "1510045921",
            "description": "Just another non-physical-based sky I made. I hope you like it!",
            "flags": 0,
            "hasliked": 0,
            "id": "Ml2cWG",
            "likes": 100,
            "name": "Non-accurate atmosphere",
            "published": 3,
            "tags": [
                "sunset",
                "sun",
                "shadow",
                "earth",
                "gradient",
                "sky",
                "yellow",
                "shader",
                "red",
                "scattering",
                "blue",
                "atmosphere",
                "scatter",
                "atmospheric"
            ],
            "usePreview": 0,
            "username": "robobo1221",
            "viewed": 10213
        },
        "renderpass": [
            {
                "code": "/*\n\n\tNon physical based atmospheric scattering made by robobo1221\n\tSite: http://www.robobo1221.net/shaders\n\tShadertoy: http://www.shadertoy.com/user/robobo1221\n\n*/\n\nconst float pi = 3.14159265359;\nconst float invPi = 1.0 / pi;\n\nconst float zenithOffset = 0.1;\nconst float multiScatterPhase = 0.1;\nconst float density = 0.7;\n\nconst float anisotropicIntensity = 0.0; //Higher numbers result in more anisotropic scattering\n\nconst vec3 skyColor = vec3(0.39, 0.57, 1.0) * (1.0 + anisotropicIntensity); //Make sure one of the conponents is never 0.0\n\n#define smooth(x) x*x*(3.0-2.0*x)\n#define zenithDensity(x) density / pow(max(x - zenithOffset, 0.35e-2), 0.75)\n\nvec3 getSkyAbsorption(vec3 x, float y){\n\t\n\tvec3 absorption = x * -y;\n\t     absorption = exp2(absorption) * 2.0;\n\t\n\treturn absorption;\n}\n\nfloat getSunPoint(vec2 p, vec2 lp){\n\treturn smoothstep(0.03, 0.026, distance(p, lp)) * 50.0;\n}\n\nfloat getRayleigMultiplier(vec2 p, vec2 lp){\n\treturn 1.0 + pow(1.0 - clamp(distance(p, lp), 0.0, 1.0), 2.0) * pi * 0.5;\n}\n\nfloat getMie(vec2 p, vec2 lp){\n\tfloat disk = clamp(1.0 - pow(distance(p, lp), 0.1), 0.0, 1.0);\n\t\n\treturn disk*disk*(3.0 - 2.0 * disk) * 2.0 * pi;\n}\n\nvec3 getAtmosphericScattering(vec2 p, vec2 lp){\n\tvec2 correctedLp = lp / max(iResolution.x, iResolution.y) * iResolution.xy;\n\t\t\n\tfloat zenith = zenithDensity(p.y);\n\tfloat sunPointDistMult =  clamp(length(max(correctedLp.y + multiScatterPhase - zenithOffset, 0.0)), 0.0, 1.0);\n\t\n\tfloat rayleighMult = getRayleigMultiplier(p, correctedLp);\n\t\n\tvec3 absorption = getSkyAbsorption(skyColor, zenith);\n    vec3 sunAbsorption = getSkyAbsorption(skyColor, zenithDensity(correctedLp.y + multiScatterPhase));\n\tvec3 sky = skyColor * zenith * rayleighMult;\n\tvec3 sun = getSunPoint(p, correctedLp) * absorption;\n\tvec3 mie = getMie(p, correctedLp) * sunAbsorption;\n\t\n\tvec3 totalSky = mix(sky * absorption, sky / (sky + 0.5), sunPointDistMult);\n         totalSky += sun + mie;\n\t     totalSky *= sunAbsorption * 0.5 + 0.5 * length(sunAbsorption);\n\t\n\treturn totalSky;\n}\n\nvec3 jodieReinhardTonemap(vec3 c){\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    vec3 tc = c / (c + 1.0);\n\n    return mix(c / (l + 1.0), tc, tc);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\tvec2 position = fragCoord.xy / max(iResolution.x, iResolution.y) * 2.0;\n\tvec2 lightPosition = iMouse.xy / iResolution.xy * 2.0 + ((iMouse.x + iMouse.y) == 0.0 ? vec2(1.0, 0.4) : vec2(0.0));\n\t\n\tvec3 color = getAtmosphericScattering(position, lightPosition) * pi;\n\tcolor = jodieReinhardTonemap(color);\n    color = pow(color, vec3(2.2)); //Back to linear\n\t\n\tfragColor = vec4(color, 1.0 );\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}