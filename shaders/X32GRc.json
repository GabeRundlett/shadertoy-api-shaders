{
    "Shader": {
        "info": {
            "date": "1722950194",
            "description": "Trying to simplifiy stb's fine maze generation algorithm even further if possible.  Press R for a new maze.  Set mazeSize in Common.",
            "flags": 48,
            "hasliked": 0,
            "id": "X32GRc",
            "likes": 10,
            "name": "Maze Generator Simplified",
            "published": 3,
            "tags": [
                "2d",
                "distance",
                "field",
                "maze"
            ],
            "usePreview": 0,
            "username": "spalmer",
            "viewed": 143
        },
        "renderpass": [
            {
                "code": "// another fork by spalmer of stb's http://shadertoy.com/view/XdKGWK\n// a damn good maze generation algorithm.\n// crystallizes wall connections, grows\n// maze outward from existing boundaries.\n\n// CCA 3.0 BY-NC-SA default site license since that's what original toy had implicitly.\n\n// I am really glad I forked this when I did,\n// because as of few days later, @stb has now\n// seemingly deleted entire account.  Bizarre.\n// We'll miss you, stb!  :love:\n\n// it's pretty simplified now.\n// (it was simple to start with!)\n// spalmer added some intermediate walls that \n// constrain the generation more, to \n// prevent any direct path, just to see\n// if I could do it, mostly, and to see\n// if the generator could handle it.\n\n// the main thing I still dislike about it, is that\n// the wall connections can go either direction,\n// which complicates *other* applications of this maze algo.\n// it's fine here, but when we begin encoding the wall dir\n// and packing to minimal bit storage, we encounter duplication\n// and when trying to use the data elsewhere, say, in\n// image tab for drawing, we must scan more directions\n// than the minimum we should need.  It's just not optimal yet.\n\n// but this only works because each new connection only connects to the one before it.\n// so connecting an unconnected corner to an existing corner is guaranteed to \n// form a mazelike system with no unconnected cells, no unconnected walls, no \n// unreachable cells.  It works great, because it then can centralize the \n// connectivity decisions for each corner uniquely, which makes possible\n// doing this in a fragment shader with no scatter write capability.\n// if I split up the wall connectivity into north and/or east only,\n// the decisionmaking about what cell is connecting to what other cell\n// gets distributed around more and then coordination would be required.\n// so it would effectively shift some complexity around but not remove it.\n// it would simplify the image tab though.\n\n// would be worth a try anyway, but seems like it would\n// complicate things in several ways simultaneously,\n// for the generation part.\n// Perhaps as an auxiliary construction step?\n// also this is only storing wall connectivity,\n// the details about the cells aren't even considered,\n// that's a whole other perspective on the maze.\n// Perhaps once walls are built, cells can be analyzed\n// and the final rendering wall bits could be stored in the cells.\n// like rn the connection dir for the corners is stored in x,y\n// could store the H/V wall bits somewhere like w\n\n// could store connection direction encoded in 3 bits somehow,\n// but for purposes of this demonstration toy,\n// the actual storage is certainly not a problem.\n\n// I finally fixed the fullscreen switching bug!\n// Originally I was trying to simplify the rendering and generation,\n// but gave up on most of that so I could just show the original way, mostly.\n// At this point I may as well public it,\n// so others can have access to this fine algorithm again.\n\n\n// TODO use dijkstra to find the solution to the maze like Cheese Sniffer\n\nfloat drawWall(vec2 p, vec2 d)\n{\n    // rotate wall to +x axis\n    p = fract(mat2(d.y, d.x, -d.x, d.y) * p) - .5;\n    // square ends\n    //return 2. * max(-p.y, abs(p.x));\n    // round ends\n    p.y = max(0., -p.y);\n    return 2. * length(p);\n}\n\nvoid mainImage(out vec4 o, vec2 q)\n{\n    vec2 r = iResolution.xy; //,\n        //mazeSize = floor(vec2(r.x / r.y, 1) * 31.); // must match Buffer A calculation now\n    vec2 p = (q - .5 * r + .001) * mazeSize.y / r.y + .5 * mazeSize;\n    \n    // hide mess outside border\n    p = clamp(p, vec2(.5), mazeSize - .5);\n    \n    #define T(o) texelFetch(iChannel0, ivec2(floor(p) + (o)), 0).xy\n        //textureLod(iChannel0, (floor(p) + .5 + o) / r, 0.).xy\n\n    // this wall\n    float d = drawWall(p, T(vec2(0)));\n    \n    // neighbor walls\n    for (int i = 0; i < 4; ++i) {\n        vec2 w = nesw[i], n = T(-w);\n        if (all(equal(w, n)))\n            d = min(d, drawWall(p, -n));\n    }\n    \n    #undef T\n\n    d -= 1. / 3.; // wall thickness:  1/2 works best for high resolution mazes\n    \n    // aa\n    float aa = 1. / r.y * mazeSize.y;    \n    o = vec4(vec3(sqrt(smoothstep(-aa, aa, d))), 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// generates the maze incrementally\n\n// altered Hoskins hash without sine\n// http://shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n    vec3 q = fract(vec3(p.xyx) * vec3(443.8975, 397.2973, 491.1871));\n    q += dot(q, q.yzx + 19.19);\n    return fract((q.x + q.y) * q.z);\n}\n\nvoid mainImage(out vec4 o, vec2 q)\n{\n    o = vec4(0);\n    vec2 r = iResolution.xy,\n        //mazeSize = floor(vec2(r.x / r.y, 1) * 31.), // must match Image tab calculation\n        p = floor(q),\n        d; // = vec2(0); // wall direction to be stored\n    // store maze size\n    if (all(equal(ivec2(p), ivec2(mazeSize)))) {\n       o.zw = mazeSize; return; // maze size / resolution change detection pixel\n    }\n    // this optimization was breaking fullscreen switching; \n    // back to window would find the old resolution where expected, leaving walls busted;\n    // now I just set a common size in Common\n    if (any(lessThan(mazeSize + 1., q)))\n        discard;\n    \n    bool reinit = iFrame < 2 ||\n        mazeSize != round(texelFetch(iChannel0, ivec2(mazeSize), 0).zw) ||\n        texture(iChannel3, vec2(82.5, .5) / 256.).x > 0.; // R key\n    bool wh, wv;\n    // initialize wall boundaries\n    if (reinit) {\n        // obstacle walls\n             if (p.x == floor(1. / 3. * mazeSize.x) && p.y <= floor(2. / 3. * mazeSize.y) && p.y > 0.)\n            d = vec2(0, -1);\n        else if (p.x == floor(2. / 3. * mazeSize.x) && p.y >= floor(1. / 3. * mazeSize.y) && p.y < mazeSize.y - 1.)\n            d = vec2(0, 1);\n             if (p.y == 0.)\n            d = vec2(-1, 0);\n        else if (p.x == 0.)\n            d = vec2(0, 1);\n        else if (p.y == mazeSize.y - 1.)\n            d = vec2(-1, 0);\n        else if (p.x == mazeSize.x - 1.)\n            d = vec2(0, -1);\n    } else {\n        // create maze walls\n        #define T(o) texelFetch(iChannel0, ivec2((p) + (o)), 0).xy\n            //textureLod(iChannel0, (p + o) / r, 0.).xy\n\n        // this cell corner's stored wall connection direction, if any\n        d = T(vec2(0));\n        \n        // is this cell corner yet unconnected?\n        if (dot(d, d) == 0.) {\n            // pick a random, cardinal direction\n            float h = hash(p + mod(iDate.w + iTime, 64.));\n            vec2 w = nesw[int(floor(4. * h))];\n\t\t\t// if wall exists in direction r, make a new connection in that direction\n            if (T(w) != vec2(0))\n                d = w;\n        }\n    \n        vec2 ne = T(vec2(1,0)), nn = T(vec2(0,1));\n\n        #undef T\n        \n        if ((d == vec2(1, 0) && ne != vec2(0))\n         || (d != vec2(0) && ne == vec2(-1, 0)))\n             wh = true;\n        if ((d == vec2(0, 1) && nn != vec2(0))\n         || (d != vec2(0) && nn == vec2(0, -1)))\n             wv = true;\n        // store wall bits\n        o.w = .25 * float(wh) + .5 * float(wv);\n    }\n\n    // store wall direction\n    o.xy = d;    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const vec2 mazeSize = vec2(16,9) * 2.; // needs to be small enough for the preview thumbnails to fit\n\n// cardinal directions\nconst vec2[] nesw = vec2[]( vec2(0,1), vec2(1,0), vec2(0,-1), vec2(-1,0) );    \n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}