{
    "Shader": {
        "info": {
            "date": "1564590649",
            "description": "Performing biquadratic interpolation with 4 bilinear taps. Left: bilinear interpolation, Right: biquadratic interpolation. Bottom: first derivative. Also contains triquadratic functions.",
            "flags": 0,
            "hasliked": 0,
            "id": "wtXXDl",
            "likes": 42,
            "name": "Fast Biquadratic Interpolation",
            "published": 3,
            "tags": [
                "interpolation",
                "biquadratic"
            ],
            "usePreview": 1,
            "username": "paniq",
            "viewed": 3196
        },
        "renderpass": [
            {
                "code": "\n// this code is in the public domain\n\nvec4 sample_biquadratic(sampler2D channel, vec2 res, vec2 uv) {\n    vec2 q = fract(uv * res);\n    vec2 c = (q*(q - 1.0) + 0.5) / res;\n    vec2 w0 = uv - c;\n    vec2 w1 = uv + c;\n    vec4 s = texture(channel, vec2(w0.x, w0.y))\n    \t   + texture(channel, vec2(w0.x, w1.y))\n    \t   + texture(channel, vec2(w1.x, w1.y))\n    \t   + texture(channel, vec2(w1.x, w0.y));\n\treturn s / 4.0;\n}\n\n// accurate analytical gradient with 8 taps\nvec2 sample_biquadratic_gradient(sampler2D channel, vec2 res, vec2 uv) {\n    vec2 q = fract(uv * res);\n    vec2 c = (q*(q - 1.0) + 0.5) / res;\n    vec2 w0 = uv - c;\n    vec2 w1 = uv + c;\n    vec2 cc = 0.5 / res;\n    vec2 ww0 = uv - cc;\n    vec2 ww1 = uv + cc;\n    float nx0 = texture(channel, vec2(ww1.x, w0.y)).r - texture(channel, vec2(ww0.x, w0.y)).r;\n    float nx1 = texture(channel, vec2(ww1.x, w1.y)).r - texture(channel, vec2(ww0.x, w1.y)).r;\n    \n    float ny0 = texture(channel, vec2(w0.x, ww1.y)).r - texture(channel, vec2(w0.x, ww0.y)).r;\n    float ny1 = texture(channel, vec2(w1.x, ww1.y)).r - texture(channel, vec2(w1.x, ww0.y)).r;\n    \n\treturn vec2(nx0 + nx1, ny0 + ny1) / 2.0;\n}\n\n// approximate analytical gradient with 4 taps\nvec2 sample_biquadratic_gradient_approx(sampler2D channel, vec2 res, vec2 uv) {\n    vec2 q = fract(uv * res);\n    vec2 cc = 0.5 / res;\n    vec2 ww0 = uv - cc;\n    vec2 ww1 = uv + cc;\n    float nx = texture(channel, vec2(ww1.x, uv.y)).r - texture(channel, vec2(ww0.x, uv.y)).r;\n    float ny = texture(channel, vec2(uv.x, ww1.y)).r - texture(channel, vec2(uv.x, ww0.y)).r;\n\treturn vec2(nx, ny);\n}\n\n// avoid hardware interpolation\nvec4 sample_biquadratic_exact(sampler2D channel, vec2 res, vec2 uv) {\n    vec2 pixelpos = uv * res;\n    vec2 q = fract(pixelpos);\n    ivec2 t = ivec2(pixelpos);\n    ivec2 ires = ivec2(res);\n    ivec3 e = ivec3(-1, 0, 1);\n    vec4 s00 = texelFetch(channel, (t + e.xx) % ires, 0);\n    vec4 s01 = texelFetch(channel, (t + e.xy) % ires, 0);\n    vec4 s02 = texelFetch(channel, (t + e.xz) % ires, 0);\n    vec4 s10 = texelFetch(channel, (t + e.yx) % ires, 0);\n    vec4 s11 = texelFetch(channel, (t + e.yy) % ires, 0);\n    vec4 s12 = texelFetch(channel, (t + e.yz) % ires, 0);\n    vec4 s20 = texelFetch(channel, (t + e.zx) % ires, 0);\n    vec4 s21 = texelFetch(channel, (t + e.zy) % ires, 0);\n    vec4 s22 = texelFetch(channel, (t + e.zz) % ires, 0); \n    vec2 q0 = (q+1.0)/2.0;\n    vec2 q1 = q/2.0;\t\n    vec4 x0 = mix(mix(s00, s01, q0.y), mix(s01, s02, q1.y), q.y);\n    vec4 x1 = mix(mix(s10, s11, q0.y), mix(s11, s12, q1.y), q.y);\n    vec4 x2 = mix(mix(s20, s21, q0.y), mix(s21, s22, q1.y), q.y);    \n\treturn mix(mix(x0, x1, q0.x), mix(x1, x2, q1.x), q.x);\n}\n\n// bonus: triquadratic functions\n\nvec4 sample_triquadratic(sampler3D channel, vec3 res, vec3 uv) {\n    vec3 q = fract(uv * res);\n    vec3 c = (q*(q - 1.0) + 0.5) / res;\n    vec3 w0 = uv - c;\n    vec3 w1 = uv + c;\n    vec4 s = texture(channel, vec3(w0.x, w0.y, w0.z))\n    \t   + texture(channel, vec3(w1.x, w0.y, w0.z))\n    \t   + texture(channel, vec3(w1.x, w1.y, w0.z))\n    \t   + texture(channel, vec3(w0.x, w1.y, w0.z))\n    \t   + texture(channel, vec3(w0.x, w1.y, w1.z))\n    \t   + texture(channel, vec3(w1.x, w1.y, w1.z))\n    \t   + texture(channel, vec3(w1.x, w0.y, w1.z))\n\t\t   + texture(channel, vec3(w0.x, w0.y, w1.z));\n\treturn s / 8.0;\n}\n\nvec3 sample_triquadratic_gradient_approx(sampler3D channel, vec3 res, vec3 uv) {\n    vec3 q = fract(uv * res);\n    vec3 cc = 0.5 / res;\n    vec3 ww0 = uv - cc;\n    vec3 ww1 = uv + cc;\n    float nx = texture(channel, vec3(ww1.x, uv.y, uv.z)).r - texture(channel, vec3(ww0.x, uv.y, uv.z)).r;\n    float ny = texture(channel, vec3(uv.x, ww1.y, uv.z)).r - texture(channel, vec3(uv.x, ww0.y, uv.z)).r;\n    float nz = texture(channel, vec3(uv.x, uv.y, ww1.z)).r - texture(channel, vec3(uv.x, uv.y, ww0.z)).r;\n\treturn vec3(nx, ny, nz);\n}\n\nvec4 sample_triquadratic_exact(sampler3D channel, vec3 res, vec3 uv) {\n    vec3 q = fract(uv * res);\n    ivec3 t = ivec3(uv * res);\n    ivec3 e = ivec3(-1, 0, 1);\n    \n    vec3 q0 = (q+1.0)/2.0;\n    vec3 q1 = q/2.0;\t\n    \n    vec4 s000 = texelFetch(channel, t + e.xxx, 0);\n    vec4 s001 = texelFetch(channel, t + e.xxy, 0);\n    vec4 s002 = texelFetch(channel, t + e.xxz, 0);\n    vec4 s012 = texelFetch(channel, t + e.xyz, 0);\n    vec4 s011 = texelFetch(channel, t + e.xyy, 0);\n    vec4 s010 = texelFetch(channel, t + e.xyx, 0);\n    vec4 s020 = texelFetch(channel, t + e.xzx, 0);\n    vec4 s021 = texelFetch(channel, t + e.xzy, 0);\n    vec4 s022 = texelFetch(channel, t + e.xzz, 0);\n\n    vec4 y00 = mix(mix(s000, s001, q0.z), mix(s001, s002, q1.z), q.z);\n    vec4 y01 = mix(mix(s010, s011, q0.z), mix(s011, s012, q1.z), q.z);\n    vec4 y02 = mix(mix(s020, s021, q0.z), mix(s021, s022, q1.z), q.z);\n\tvec4 x0 = mix(mix(y00, y01, q0.y), mix(y01, y02, q1.y), q.y);\n    \n    vec4 s122 = texelFetch(channel, t + e.yzz, 0);\n    vec4 s121 = texelFetch(channel, t + e.yzy, 0);\n    vec4 s120 = texelFetch(channel, t + e.yzx, 0);\n    vec4 s110 = texelFetch(channel, t + e.yyx, 0);\n    vec4 s111 = texelFetch(channel, t + e.yyy, 0);\n    vec4 s112 = texelFetch(channel, t + e.yyz, 0);\n    vec4 s102 = texelFetch(channel, t + e.yxz, 0);\n    vec4 s101 = texelFetch(channel, t + e.yxy, 0);\n    vec4 s100 = texelFetch(channel, t + e.yxx, 0);\n\n    vec4 y10 = mix(mix(s100, s101, q0.z), mix(s101, s102, q1.z), q.z);\n    vec4 y11 = mix(mix(s110, s111, q0.z), mix(s111, s112, q1.z), q.z);\n    vec4 y12 = mix(mix(s120, s121, q0.z), mix(s121, s122, q1.z), q.z);\n    vec4 x1 = mix(mix(y10, y11, q0.y), mix(y11, y12, q1.y), q.y);\n    \n    vec4 s200 = texelFetch(channel, t + e.zxx, 0);\n    vec4 s201 = texelFetch(channel, t + e.zxy, 0);\n    vec4 s202 = texelFetch(channel, t + e.zxz, 0);\n    vec4 s212 = texelFetch(channel, t + e.zyz, 0);\n    vec4 s211 = texelFetch(channel, t + e.zyy, 0);\n    vec4 s210 = texelFetch(channel, t + e.zyx, 0);\n    vec4 s220 = texelFetch(channel, t + e.zzx, 0);\n    vec4 s221 = texelFetch(channel, t + e.zzy, 0);\n    vec4 s222 = texelFetch(channel, t + e.zzz, 0);\n\n    vec4 y20 = mix(mix(s200, s201, q0.z), mix(s201, s202, q1.z), q.z);\n    vec4 y21 = mix(mix(s210, s211, q0.z), mix(s211, s212, q1.z), q.z);\n    vec4 y22 = mix(mix(s220, s221, q0.z), mix(s221, s222, q1.z), q.z);\n    vec4 x2 = mix(mix(y20, y21, q0.y), mix(y21, y22, q1.y), q.y);\n    \n    return mix(mix(x0, x1, q0.x), mix(x1, x2, q1.x), q.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    \n    float h = uv.x;\n    float w = uv.y;\n    \n    uv += iTime * 0.2;\n    uv /= 30.0;\n\n    vec4 col;\n    vec2 n;\n    if (h < 0.0) {\n    \tcol = texture(iChannel0, uv).rrrr;\n        n = vec2(dFdx(col.r), dFdy(col.r)) * iResolution.y / 16.0;\n    } else {\n        col = sample_biquadratic(iChannel0, iChannelResolution[0].xy, uv).rrrr;\n        n = vec2(dFdx(col.r), dFdy(col.r)) * iResolution.y / 16.0;\n        if (h > 0.9) {\n        \tn = sample_biquadratic_gradient(iChannel0, iChannelResolution[0].xy, uv);\n        }\n    }\n    float ph = sin(iTime * 0.1);\n    n = mix(n, normalize(n), ph*ph);\n    if (w > -0.5) {\n        fragColor = col;\n    } else {\n        fragColor = vec4(n*0.5+0.5, 0.0, 1.0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}