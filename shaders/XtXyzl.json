{
    "Shader": {
        "info": {
            "date": "1505900034",
            "description": "mouse.xy sets fbm torus/TILE size\n\nfbmT() is fractal Brownian motion  with modulo octaves and Hermite interpolation to tessellate seamlessly without mirroring\nuseful tor tiles with large composite interval, avoiding \"Far_Lands\" glitches. ",
            "flags": 0,
            "hasliked": 0,
            "id": "XtXyzl",
            "likes": 4,
            "name": "seamless torus fbmT",
            "published": 3,
            "tags": [
                "torus",
                "fbm",
                "brownian",
                "gaussian",
                "tile",
                "hermite",
                "tesselation",
                "library",
                "seamless",
                "babel"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1567
        },
        "renderpass": [
            {
                "code": "//number of base2 fbm octaves.\n#define iterFbmT 6\n\n/*\nmouse.xy sets fbm TILE size\n Tile size is not meant to be dynamic,\n  Chhanging tile size just shows its general case potentialutility.\n\nfbmT() is fractal Brownian Motion \n with modulo octaves and Hermite interpolation \n to tessellate seamlessly without mirroring.\n It skips between integer steps and gets scaled by a float.\n It does a few base2 octave iterations of fbm noise.\n It scales up nicely adnd is faster than similar \"infinize zoom noise\".\n It is more for speed than for \"good noise\". \n  Hermite interpolation makes this a multi octave gaussian-blur noise.\n   Base2 octaves of that are too symmetric to appear noisy.\n  This is more to set tiles on an infinite track\n   than to set a height map:\n  This is for chase scene sets: https://www.shadertoy.com/view/4tXcRl\n\n fbmT() has no Far_Lands, instead it repeats endlessly.\n By averaging multiple (fbmT()+fbmT())*.5 ,\n  that are scaled to different large primes, \n  you can have 2 large octaves of noise with larger composite interval.\n  Even though you know that it repeats (like a mersenne twister), \n   you are still easily lost in a large enough interval.\n\n It is intended for large scale noises that do NOT suffer from \n \"minecraft Far_Lands rng glitches\":\n  https://minecraft.gamepedia.com/Far_Lands\n due  to precision loss of ieee floats on larger distances.\n\n Berare: There are some mod() intervals \n  that do NOT interpolate seamlessly.\n I assume this is similar to the unecpected ieee float behavior of \n mod(33.,33.)!=0. , so you have to catch and avoid these:\n  https://www.shadertoy.com/view/Xlt3W4\n I assume pow(2,n)+1 contains most of these glichy cases.\n  fine, because the large mersenne primes are found at \n  pow(2,n)-1\n \n  To do; include a mersenne twister for insanely large tile sizes?\n   Fun part about including a mersenne twist function would be\n  that it has a fast inverse, useful for a SEARCHABLE \n   https://libraryofbabel.info/\n  So the plan is basically to do Hermite interpolation on\n   https://babelia.libraryofbabel.info/\n  This then would bea hash where you could finda \"good enough match\"\n   relatively simple (like in a VERY BAD sha256-like, encryption).\n*/\n\n/*\nInclides lots of commented code and links on (a)symmetry & optimization:\nLibrary: Lib.Frames.8\nGuide  : Bisymmetry.4\nGuide  : Bisymmetry.4+1 (optimization pointers)\n*/\n\n/* end__.Head\n   start.Manual\n/*\nMouse sets coefficients; ...swiveled sideways  ...\nMouse.x sets cubic     == cubic change over x\nMouse.y sets null      == baseline height.y at x=0;\nMouse.z sets linear    == linear change\nMouse.w sets quadratic == a*a change\n\nFor hased bands of [bounding volumes] to be filled with dots or moons.\n\nThis turns any y=f(x) curve (including HASH,noise) into a dotted line.\n of any (homogeneous) period.x,interval.x \n WITHOUT A LOOP, by using fract()\np4() returns y=f(x) where f(x) is a (general) cubic polynomial.\n\nThis generalization blurs some lines between analysis, hashes and RNG.LCG.PCG\n ==Random/Linear/Permuted Number/Congruential/Congruential Generator\nThis makes me wonder what loops can be converted into single passes with fract()\n And what the constrains to types of loops are that can be turned to fract().\n And when it is worth it, and when not. (I bet it is worth it for binary trees).\n\nThe gradient is good within the mod() interval, \nJust make sure that the visible parts (dots) are within boundingVolume==interval==[i]\nLeonard Euler: \"The best inverval is [i]==0;\n...\n*/\n/* end__.Manual\n   start.Manual.Parameters\n*/\n//  set period,interval==[i]~0, not just VERY small, but actually divide by 0.\n//   Just to screw with (or implement basiccalculus) analysis on a fundamental level!\n//   TestDivideByZeroCase==0 will calculate; .0*vec2(fract(a/.0),floor(a/.0));\n//  Effects of settings depend on implementation:\n//              Leonard Euler : ==0  \"This is fine, I invented this\"\n//fract(Congruental Generator): ==0  \"No it is not fine! Null-State equals death!\"\n//          Low IEEE precision: ==1  \"Where is my hash! Screw you, all of you!\"\n//     Heuristic large epsilon: ==2  \"Whatever, this is as close as we can get!\"\n//       Euclidean Unit circle: ==-1 \"Null-State-death only affects me tangentially\"\n#define TestDivideByZeroCase -1\n\n//control speed of time, to make time static or negative.\n#define TimeS (iTime-1.)\n//-1. makes a better thumbnail for the first frame\n//-1. also offsets from [the initial VOID-state]:\n// Because Shadertoy has the PATHETIC error that iTime and iGlobalTime are not initialized.\n// iTime and iGlobalTime are initially ==NullPointer != 0. \n// This confuses many webgl implementations, eg: when using i=cos(acos(-1.)+iTime);\n// cos(acos(-1.)+0.)==-1. is fine.\n// (NullPointer +0.)!= 0. confuses many implementations. -> black screen on iTime==0.\n\n//  ColorgGradient==x>0, shows different gradients, index[1..4], points to a 2*2 matrix:\n//   2 gradients are euclidean sqrt(a), 2 of them 1/dot(a,a)\n//   2 gradients them are fract(a), 2 of them are not.\n//  ColorgGradient==0  is, by your powers combined, Captain Planet, all of the above.\n//  ColorgGradient==-1 is, a (disappearing) ring-variant of ColorgGradient==0\n//  ColorgGradient==-1 shows a spherical [Bounding Volume] in white/yellow\n#define ColorGradient 0\n\n//  HasMix linear interpolates between a hasn and a PolynomialWithExponent3\n#define MixHashPoly3 u5(cos(TimeS*.61))\n//#define MixHashPoly3 .0\n\n//sub-pixel blur\n#define fsaa 14./min(iResolution.x,iResolution.y)\n\n//swivel view, make .y horizontal, more horizontal ScreenSpace for higher exponents.\n#define ViewSvivel\n//View.Zoom\n#define ViewZoom 4.\n//View.Frame\n#define fra(u) (u-.5*iResolution.xy)*ViewZoom/iResolution.y\n\n\n\n/* end__.Manual.Parameters\n   start.Lib.Frame.8\n*/\n//library of often used functions: //ounting, index starts at 0!\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define u5(a) (a*.5+.5)\n#define u2(a) (a*2.-1.)\nv0 suv(v3 a){return dot(v3(1),a);}v0 suv(v2 a){return dot(v2(1),a);}\nv0 suv(v1 a){return a.x+a.y;}//sum of vector\nv0 mav(v1 a){return max(a.y,a.x);}\nv0 mav(v2 a){return max(a.z,mav(a.xy));}\nv0 mav(v3 a){return max(mav(a.zw),mav(a.xy));}\n//max of vector\n#define miv(a) -mav(-a)\n//triangle wave //euclidean grid\n#define tri(a) abs(u2(fract(a)))\n#define grid(a) mav(tri(a))\n//clamp().special clamp.general; //clamp().pseudo.inverse\n#define sat(a) clamp(a,0.,1.)\nv0 sat2(v0 a,v1 m){a=.5*(sign(a)+m.x)*a+m.y;a=(sign(2.-a)+1.)*(a-2.)+2.;return a*.5;}\n//stretch; mirror_centric, most common, atomic\n#define stretch(u,m) .5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretchMinus; positive values do not change; stretchPlus; negatives do not change.\n#define stretchM(u,m) stretch((u*2.+m),m)*.5\n#define stretchP(u,m) stretch((u*2.-m),m)*.5\n//return squared length of a()\n#define dd(a) dot(a,a)\nv1 perp(v1 a){return v1(-a.y,a.x);}//perpendicular ==90deg rotation\nv0 dotp(v1 a,v1 b){return dot(perp(a),b);}//return [perpendicular dot product], can be useful for distance to line with niormalizedd input\nv0 dLine (v1 p,v1 a,v1 b){p-=a;b-=a;return dd(p-b*sat(dot(p,b)/dd(b)));}//return squared distance of [u] from segment, from [a] to [b]\nvec4 aOverB(vec4 a,vec4 b){a.xyz*=a.w;b.xyz*=b.w;return vec4(a+b*(1.-a));}\n//not sure if aXorB() is correct, but looks useful. //https://en.wikipedia.org/wiki/Alpha_compositing\nvec4 aXorB(vec4 a,vec4 b){a.xyz*=a.w;b.xyz*=b.w;return vec4(a*(1.-b)+b*(1.-a));}\n//---trigonometry, rotations and (distance to) Quadratic functions.\n//(distance to quadratic is a cubic with less than 2 intersections==roots)\n#define cs(a) vec2(cos(a),sin(a))\n//mirror p at half rotated axis == cheap SINGLE 2d rotation.\n#define rs(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n//golden ratios are the best factors for hashes because; phi.xy-1.=1/phi.xy\nconst v1 phi=v1(sqrt(5.)*.5)+v1(-.5,.5);\n//a not too work save plotter for quadratic functions.\nv1 evalQuad(v1 t,v1 A,v1 B,v1 C){A=(1.-t)*(A/B+C/A);return A*A;}\n//Solve quadratic equation for roots \nv2 SolveQuad(v2 a){v0 e=-a.x/3.;v0 p=a.y+a.x*e,t=p*p*p,\n q=-(2.*a.x*a.x-9.*a.y)*e/9.+a.z,d=q*q+4.*t/27.;if(d>.0){v1 x=(v1(1,-1)*sqrt(d)-q)*.5;\n return v2(suv(sign(x)*pow(abs(x),v1(1./3.)))+e);}v1 m=cs(acos(-sqrt(-27./t)*q*.5)/3.)\n  *v1(1,sqrt(3.));return v2(m.x+m.x,-suv(m),m.y-m.x)*sqrt(-p/3.)+e;}\n//return squared distance to line segment\n#define ddb(a) (dd(d+(c+b*t.a)*t.a))\n// Find the signed distance from a point to a bezier curve\nv0 dBezier(v1 p,v1 A,v1 B,v1 C){   \n //B=mix(B+v1(1e-4), B, abs(sign(B * 2.0 - A - C)));//colinear CV triviality\n v1 a=B-A,b=A-B*2.+C,c=a*2.,d=A-p;v2 k=v2(3.*dot(a,b),2.*dd(a)+dot(d,b),dot(d,a))/dd(b),\n t=sat(SolveQuad(k));return sqrt(miv(v2(ddb(x),ddb(y),ddb(z))));}\n//---window function curve fittings.y:  https://www.shadertoy.com/view/Xtscz7\n#define bma(b,a,c) (((b)-(a))*(c)+a)\n//float Linear(float x, float a, float b){return  a*(x*(b/a-1.)+1.);}//doesnt look too good.\n#define wLinear(x,a,b) a*(x*(b/a-1.)+1.)\n//float Cosine(float x, float a, float b){return (b-a)*(1.-cos(x*acos(-1.)))*.5 + a;}\n#define wCosine(x,a,b) (bma(b,a,(1.-cos(x*acos(-1.)))*.5)\n//float Smoothstep(0,1,x), without sat(a);\n#define wSs2(x) (x)*(x)*(3.-2.*(x))\n#define wSs(x,a,b) wSs2((x)-(a)/((b)-(a)))//this is not too useful, without sat it sucks\n//bma(b,a,x*x*(3.-2.*x))\n//lower lipschitz == less likely spheretracking overestimation.\n//most general, smoothest most excessive, most zigzag, lowest lipschitz\n#define wHermiteD(x,a,b,e,f) (b+.5*x*(e+b-a+x*(a-b+e+x*3.*(e*3.+f+x*5./3.*(-e*3.-f+x*.4*(e*3.+f))))))\n#define wHermite(x,a,b,c,d) HermiteD(x,a,b,(c-b),(a-d))\n//special case of Hermite(), with a smooth .5 average. medium zigzag\n#define wCatmullRom(x,a,b,c,d) ((((d-a+3.*(b-c))*x+(2.*(a+c+c)-d-5.*b))*x+(c-a))*.5*x+b)\n//efficient and smooth 2nd derivative, least zigzag, highest lipschitz \n#define wCubic(x,a,b,c,d) ((((d-c-a+b)*(x-1.)+a-b)*x+(c-a))*x+b)\n//Cosine() is smoother than Cubic()\n//fast good monochrome distance field visualization.\nv3 rg(v3 c){v3 b=smoothstep(fsaa,-fsaa,c);\n return mix(fract(c*4.),b,.5+(atan(c))/acos(-1.));}\n//return y=f(a,m); m.xyzw coefficients of GeneralPoynomWithExponent3==f();\nv0 p3(v0 a,v3 m){\n //return m.x+a*m.y+a*a*m.z+a*a*a*m.w;//lazy, worst\n //return dot(vec4(1),m*vec4(1.,a*vec3(1,a*vec2(1.,a))));//overly explicit vector processor\n return dot(vec4(1),m*vec4(1.,a,a*a,a*a*a));//explicit vector processor\n return m.x+a*(m.y+a*(m.z+a* m.w));//explixit MAD() (better precision)\n ;}//#define p3(u,f) (f.x+u*f.y+(u*u)*f.z+(u*u*u)*f.w)\n//---hash, either multiply sin(a) by a large value and fract it, or dot(a,a.yzx)_swivel a lot with linear equations.\n\n///silly me, hash only needs to be labeld by number of output domain + subtype, unput types are explicit by context.\n\n\n#define hs vec4(1031,.1030,.0973,.1099)\n#define fs(a) fract(sin(a)*43758.5453123);\nv0 h12s(vec2 n){return fs(dot(n,vec2(12.9898,78.233)));}//most common hash12. minor variants exist;\n//strange mix of dot and 2 octaves, used for oscillating water pressure\nfloat h12sd(vec2 p){return dot(sin(p*.6345)+sin(p*1.62423),vec2(.125))+.5;}//www.shadertoy.com/view/lsXGzH\n\n//swivel hashes wihthout sin, fast mediocre, better for mobile gpu, Sans Euclid, without trigonometry.\nv0 h11(v0 p){v2 f=fract(v2(p)*hs.y);f+=dot(f,f.yzx+19.19);return fract((f.x+f.y)*f.z);}\nv1 mod289(v1 a){return a-floor(a/289.)*289.;}//famous basis for simmplex noise. overly explixit. 289=17*17\nv2 h33(v2 a){a=fract(a*hs.xyz);a+=dot(a,a.yxz +19.19);return fract(a.zyx *(a.xxy +a.yzz ));}//https://www.shadertoy.com/view/4djSRW\nv3 h44(v3 a){a=fract(a*hs)    ;a+=dot(a,a.wzxy+19.19);return fract(a.zywx*(a.xxyz+a.yzzw));}//https://www.shadertoy.com/view/4djSRW\n/* //these 5 smell silly. basis for tessellated bouncy balls, so some of them do not bounce at all, makes sense there.\nfloat hash(float n){return fract(sin(n)*43758.5453);}\nvec2 hash2(float n){return fract(sin(vec2(n,n+1.))         *vec2(2.1459123,3.3490423));}\nvec2 hash2(vec2   n){return fract(sin(vec2(n.x*n.y,n.x+n.y))*vec2(2.1459123,3.3490423));}\nvec3 hash3(float n){return fract(sin(vec3(n,n+1.,n+2.))    *vec3(3.5453123,4.1459123,1.3490423));}\nvec3 hash3(vec2   n){return fract(sin(vec3(n.x,n.y,n+2.))   *vec3(3.5453123,4.1459123,1.3490423));}\n*/\nfloat inv_error_function2(float x){//defined for x <1??\n x=max(x,0.); float m=.125;//m makes a poor variable.\n float y=log(1.-x*x),z=2./acos(-1.)/m+y*.5;\n\treturn sqrt(sqrt((z*z-y/m))-z);}//the sign seems obsoleted by my making it worksafe..\n//gaussian distributed noise (good for refraction)\nfloat gaussian_rand(vec2 n,vec4 m){\tfloat x=u2(h12s(n*.61+fract(m.x)));return inv_error_function2(x)*.15+.5;}//*.61 hides hyperplane\n//modulo repeating (fbm iteration) noise is better over extreme differentials, less precision issues due to limited address space.\n//moulo repeating noise, assumes [p] buffered as p=mod(p,s), sâ‚¬N>0\n\n\n//blurry rectangular smoothstep noise. not work-safe for small m.xy, losing too much precision in some fract() cases.\nfloat iHash(vec2 u,vec2 m){\n const vec2 V=vec2(0,1);\n vec2 i=vec2(smoothstep(V.xx,V.yy,mod(u*m,1.))),j=vec2(1.-i.x,i.x),\n g=j*vec2(h12s(vec2(floor(u*m+V.xx)/m)),h12s(vec2(floor(u*m+V.yx)/m))),    \n h=j*vec2(h12s(vec2(floor(u*m+V.xy)/m)),h12s(vec2(floor(u*m+V.yy)/m)));//should do a h22 instead of 2 h12\n return suv(g)*(1.-i.y)+suv(h)*i.y;//last symetry break is intentional, and makes it \"noisy\"\n}\n\n\n/*\nfloat hash(float n){return fract(sin(n*43758.5453));}\nfloat noise(vec2 p){return hash(mod(p.x+p.y*57.,1024.0));}\nfloat smoothNoise2(vec2 p){vec2 pf=fract(p);\n return mix(mix(noise(floor(p          )),noise(floor(p+vec2(1,0))),pf.x),\n             mix(noise(floor(p+vec2(0,1))),noise(floor(p+vec2(1,1))),pf.x),pf.y);}//from \"3d voronoi lava flow\"\n*///as a side note \"3d voronoi lava flow\" uses a tesselated noise, similar to noisemod below:\n//above is used as basis for a voronoi.\n\n//below is similar to above and belower, but less repetitive in its source code\n#define cHashA4 vec4(0,1,57,58)\n//#define cHashA3 vec3(1,57,113)\n#define cHashM 43758.54\nvec4 Hashv4f (float p){return fract(sin(p+cHashA4)*cHashM);}\nfloat Noisefv2 (vec2 p){\n  vec4 t=Hashv4f(dot(floor(p),cHashA4.yz));\n  p=fract(p);p*=p*(3.-2.*p);\n  return mix (mix(t.x,t.y,p.x),\n               mix(t.z,t.w,p.x),p.y);}//and then it uses Hashv4f() as basis to swivel it over 4 domains, and mix() flatten it, rather silly.\n//https://www.shadertoy.com/view/ldlBRM\n//x-wing like ships shot in canyon\n\n\nfloat noiseMod(vec2 u,vec2 s){u*=s;vec2 f=fract(u);u=floor(u);\tf=f*f*(3.-2.*f);//any interpolation is fine for f\n\treturn mix(mix(h12s(mod(u          ,s)),h12s(mod(u+vec2(1,0),s)),f.x),\n\t\t\t\t\t    mix(h12s(mod(u+vec2(0,1),s)),h12s(mod(u+vec2(1,1),s)),f.x),f.y);}// https://www.shadertoy.com/view/4dlGW2\n//a trick is to set m.xy to primesaand vary ovrave interval between primes?\nfloat fbmT(vec2 u,vec4 m){\tm.xy=max(vec2(1),floor(abs(m.xy)));//makes it a bit mopre worksafe.\n  u=mod(u,m.xy);float a=.5,f=.0;//m.z=(cos(iTime))+1.;//these 2 params are likely not worth to become vars\n\tfor (int i=0;i< iterFbmT;i++){f+=noiseMod(u,m.xy)*a;a*=.5;m.xy*=2.;}return min(f,1.);}\n//with more iterations, \"endlesszoom\" may be a better approach\n\n\n\n\n/* End__.Lib.Frame.8\n   Start.Special\n*/\n//subroutines that are too special to enter the Library,\n// to not be generalized or specialized (for now).\n\n//a mix (interpolate between) a polynom.y and a hash.y\nfloat ph(float a,vec4 m){return mix(h11(a),p3(a,m),MixHashPoly3);}\n\n/*\n\n\nvec3 blackBodyALaPewDiePie(float k){//most common blackbody code\n    //it is shit, in case you cant tell just by looking at it:\n    //to make sure you can not mis how bad this one is, \n    //i gave it a fitting namespace\n\tvec3 c = vec3(255.);\n    c.x = 56100000. * pow(k,(-3. / 2.)) + 148.;\n   \tc.y = 100.04 * log(k) - 623.6;\n   \tif (k > 6500.) c.y = 35200000. * pow(k,(-3. / 2.)) + 184.;\n   \tc.z = 194.18 * log(k) - 1448.6;\n   \tc = clamp(c, 0., 255.)/255.;\n    if (k < 1000.) return c*k/1000.;\n    return c;}//this one is pretty terricle on too mayny levels\n\n//and i code golfed it into evel lower precision:\n//code golfed by ollj\nvec3 blackB0(float k){float l=-log(k)*1.5;return clamp(\n  vec3(.71,mix(.6,-2.1,(step(l,13.))),-4.8)\n  -l*vec3(0.,.11*(-sign(l-13.)+1.),.4)\n  +exp(l)*vec3(2e5,39e3*(sign(l-13.)+1.),0)\n ,0.,1.)*mix(k/1000.,1.,step(l,-log(1000.)*1.5));} //not good\n\n//return blackbody color of temperature in [k] kelvin.\n//code golfed by ollj\nvec3 blackB(float k){float l=-log(k)*1.5-13.,s=sign(l);return clamp(\n vec3(.71,-2.55*(-s+1.)-.3*(s+1.),-10)-l*vec3(0,.115*(-s+1.),.4)\n +k*vec3(73e3,38e3*(s+1.),0),0.,1.)*mix(1.,k/1e3,step(-l,23.35));}\n//something got lst here.\n\n\n//---- above is shit below id good\n    \n//iq https://www.shadertoy.com/view/4tdGWM\nvec4 blackBodyFab( vec4 O,  vec2 U ){\n   // U /= iResolution.xy;\n    float y = 2.*U.y,\n          m = .01+5.*iMouse.y/iResolution.y,\n        T = U.x*16000.; // absolute temperature (K)\n    //O -= O;\n    \n  // --- with physical units: (but math conditionning can be an issue)\n    float h = 6.6e-34, k=1.4e-23, c=3e8; // Planck, Boltzmann, light speed  constants\n\n    for (float i=0.; i<3.; i++) {  // +=.1 if you want to better sample the spectrum.\n        float f = 4e14 * (1.+.5*i); \n        O[int(i)] += 1e7/m* 2.*(h*f*f*f)/(c*c) / (exp((h*f)/(k*T)) - 1.);  // Planck law\n    }\n\n    // --- with normalized units:  f = 1 (red) to 2 (violet). \n    // const 19E3 also disappears if you normalized temperatures with 1 = 19000 K\n     for (float i=0.; i<3.; i++) {  // +=.1 if you want to better sample the spectrum.\n        float f = 1.+.5*i; \n        O[int(i)] += 10./m* (f*f*f) / (exp((19E3*f/T)) - 1.);  // Planck law\n    }\n    //if (y<1.)\n    O /= max(O.r,max(O.g,O.b));  // chrominance\n  return O;   \n}\n\n//https://www.shadertoy.com/view/XlcSDr\n//code golfed: iq: https://www.shadertoy.com/view/4tdGWM\nvec3 blackBodyColor(float k){\n vec3 c=vec3(1.,3.375,8.)/(exp((19e3*vec3(2,3,4)/k/64e3))-1.);\n //the -1 barely changes much, could be cut.\n return c/mav(c);}\n /*\n if (u.y>0.){\n     u.y-=1.5;\n  \n   //c=blackBodyFab(O,u)+u.y;   //iq \n   c.xyz=blackBodyColor(u.x*.5)+u.y;//iq  unrolled\n } else {\n     u.y+=.5;\n c.xyz=blackBodyALaPewDiePie(u.x*10000.)+u.y;//most common\n //below 2 ones have some big errors in them..\n        \n //c.xyz=blackB0(u.x*24000.)+u.y;//i messed up a bit\n  //c.xyz=blackB(u.x*12000.)+u.y;//i messed up a lot\n  c.xy=vec2(hermite3(u.x)+u.y);\n }\n c=abs(c)-.01;\n    */\n\n\n//#define hermite3(a) 4.*(a)*(a)*(3.-2.*(a))\n//#define hermite3s(a) (hermite34((a)))*.25\n#define hermite3s(a) (a)*(a)*(3.-2.*(a))\n\n#define hermite3(a) (a)*(a)*(3.-2.*(a))\n\n\n\n/* End__.Special\n   Start.Main\n*/\n\nvoid mainImage( out vec4 O,in vec2 U){\n vec2 u =fra(U);vec4 m=vec4(fra(iMouse.xy),fra(iMouse.zw));  \n #ifdef ViewSvivel\n  //u=u.yx;m=m.yxwz;//swivel view, use horizontal space to show higher exponentials.\n #endif    \n  if(iMouse.z<=0.)m.xy=vec2(sin(iTime*.3),cos(iTime*.61*.3))*1.5+1.8;\n vec4 c=vec4(1); //c=eulerEuclid(u,m);\n \n c.r=sqrt(dLine(u,vec2(0),m.xy))-.25;//line segment\n //c.g=inv_error_function2(u.x)-u.y;\n c.b=length(u-m.xy)-.1;\n c.rg=mix(c.rg,c.aa,.5);//mix a as yellow;\n    \n    \n   \n\n c=rg(c);//distance gradient\n\n     \n\n c.r=abs(gaussian_rand(u,m))-u.y;//gaussian distributed noise\n m.xy*=8.;c.r=fbmT(u*8./m.xy,m);//tesselated seamless fbm\n //c.r=iHash(u,16./m.xy);\n //c.r=Noisefv2(u);\n \n \n\n    \n    \n  \n   //float =sat(grid(u)*2.-1.5);\n //c=aOverB(vec4(sat(grid(u)*2.-1.5)),vec4(c.xyz,1.));\n    \n//if(u.y>0.)\n //c.rgb=blackBodyColor(u.x);\n    //else\n       // blackBodyFab(O,u);\n    \n O=vec4(c.xyz,1);\n}\n/* End__.Main\n   start.Dump.Memos  //bisymmetry is cut to save scroll trime\n*/\n\n//memo on bezier bounding volume: http://i.imgur.com/b4q3r2n.jpg\n//if a bezier is meant to define a surface, and i want to trace the BoundingVolume first\n//but the *.tricky points for the BV possibly make the BV not worth calculating.\n//still worth buffering for a static object?\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}