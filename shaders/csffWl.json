{
    "Shader": {
        "info": {
            "date": "1689260249",
            "description": "I like color and tunnels!\nremoved carne, mouse controls additive shadow\nreducing MAX_STEPS from 200 -> 30 results in satisfying 'goop'.\nTry going back to 200 to get idea how forked shader looks with the color added.",
            "flags": 0,
            "hasliked": 0,
            "id": "csffWl",
            "likes": 16,
            "name": "Colorful Sans Carne",
            "published": 3,
            "tags": [
                "tunnel",
                "color",
                "camera",
                "mine",
                "cave",
                "gyroid",
                "path",
                "goop",
                "lime",
                "osso"
            ],
            "usePreview": 0,
            "username": "timmaffett",
            "viewed": 271
        },
        "renderpass": [
            {
                "code": "// Fork of \"Carne\" by Elsio. https://shadertoy.com/view/msXfDf\n// 2023-07-13 14:22:36\n// Altered color() function and reduced MAX_STEPS from 200->30\n// removed carne return from map(), mouse controls additive shadow\n#define MAX_STEPS 30\n#define MAX_DIST 200.0\n#define EPS 0.01\n#define STEP_COEF .3\n#define NORMAL_COEF EPS * .5\n\n#define funcRayMarch float step, t = 0.; for(int i = 0; i < MAX_STEPS; i++){step = map(ro + t * rd); t += step * STEP_COEF; if(t > MAX_DIST || step < EPS) break;} return t;\n#define funcNormal float d = map(p); vec2 e = vec2(NORMAL_COEF, 0); vec3 n = vec3(d) - vec3(map(p-e.xyy), map(p-e.yxy), map(p-e.yyx)); return n;\n#define funcShadow return dot(normalize(normal(p)), normalize(lightPos - p));\n\n#define PI atan(.0, -1.)\n#define T (iTime/2.0)\n#define walk T * 4.\n\n#define rot(a) mat2 (cos(a), sin(a), -sin(a), cos(a))\n#define rotAbs(p, a) length(p) * vec2(sin(a), cos(a))\n#define wmod(s, w) mod(s, w) - w/2.\n\n vec2 mouse;\n\nfloat id;\n\nvec2 path(in float z) {\n    float a = sin(z * .07);\n    float b = cos(z * .09);\n    return 3. * vec2(a + b, a - b);\n}\n\n\nfloat smoothMin(float a, float b, float c, float t){\n    return -log(exp(t * -a) + exp(t * -b) + exp(t * -c)) / t;\n}\n\nfloat smoothMin(float a, float b, float t){\n    return -log(exp(t * -a) + exp(t * -b)) / t;\n}\n\n\n\n\nvec3 tri(vec3 p) {\n    return abs(fract(p) - .5);\n}\n\n\n\nfloat surf(in vec3 p) {\n    return dot(tri(p * .5), vec3(.5)) - p.y*.6;\n}\n\n\n\n\nfloat map(vec3 p) {\n    p.xy -= path(p.z);\n    \n    vec3 q = p * PI/2.;\n    \n    float gyr = dot(cos(q), sin(q.yzx));\n    \n    float osso =  gyr + 1.3;\n    \n    p.xy *= rot(T*.8);\n    \n    float cyl = length(p.xy) - 1.8;\n    float carne = -smoothMin(cyl, gyr, 2.) + surf(p);\n    \n    id = step(carne, osso);\n    \n    //return carne;\n    return osso;\n    return min(carne, osso);\n}\n\n\nfloat rayMarch(vec3 ro, vec3 rd){funcRayMarch}\nvec3 normal(vec3 p) {funcNormal}\nfloat shadow(vec3 p, vec3 lightPos) {funcShadow}\n\n\nvec3 hsb2rgb( in vec3 c )\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return (c.z * mix( vec3(1.0), rgb, c.y));\n}\n\n\nvec3 color(vec3 ro, float t, vec3 rd, vec3 lightPos){\n    \n    vec3 col2 = hsb2rgb(vec3(0.02*ro.y*3.1514,0.9,0.9))*0.5;\n    vec3 col3 = hsb2rgb(vec3(0.1*(ro.z + t * rd.z)*3.1514,0.9,0.9))*0.5;\n    vec3 col = id < 0.5 ? col3*vec3(1.) : col2+(col3*vec3(clamp(mouse.y/mouse.x,0.1,1.0)*0.8)); //vec3(4,3,2)*.1;\n    \n    col += mouse.y/mouse.x*shadow(ro + t * rd, lightPos); \n    \n    col = mix(/*vec3(1, .1, 0)*/col2, col, 1. / (t / MAX_DIST + .9));\n    \n    return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    mouse = (iMouse.xy == vec2(0.)) ? vec2(0.3,0.1) : iMouse.xy/iResolution.xy;\n    \n\n\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n\n#ifdef MOUSESTEERING\n    vec3 lookAt = vec3(mouse.x*3.,-mouse.y*.3, walk);\n#else\n    vec3 lookAt = vec3(0, 1, walk);\n#endif\n    vec3 ro = lookAt + vec3(0, 0, -0.1);\n    vec3 lightPos = ro + vec3(0, 0, 4);\n    \n    lookAt.xy += path(lookAt.z);\n    ro.xy += path(ro.z);\n    lightPos.xy += path(lightPos.z);\n\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x));\n    vec3 up = cross(forward, right);\n    vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n\n    float t = rayMarch(ro, rd);\n\n    \n    vec3 col = color(ro, t, rd, lightPos);\n    \n    fragColor = vec4(col * 2., 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}