{
    "Shader": {
        "info": {
            "date": "1471052533",
            "description": "A collection of 18 experiments in creating objects using domain operations, now divided into three parts because the earlier version was causing webgl crashes for some viewers. Shader begins in auto mode, 10 seconds per object. ",
            "flags": 48,
            "hasliked": 0,
            "id": "MtdGzs",
            "likes": 8,
            "name": "DomainManipMenagerie part three",
            "published": 3,
            "tags": [
                "3d",
                "domainmanipulation",
                "keyboardiinput"
            ],
            "usePreview": 0,
            "username": "wjbgrafx",
            "viewed": 654
        },
        "renderpass": [
            {
                "code": "/*\n\t\"Domain Manipulation Menagerie\" by wjbgrafx\n\t\n\tA collection of experiments in creating objects using domain operations.\n\t\n\tCode based on :\n\t---------------\t\n\tPlaying with symmetries - Torus\t   by @paulofalcao\t\n\thttp://glslsandbox.com/e#29755.0\n\t\n\tCode for saving and updating data in a buffer :\n\t-----------------------------------------------\n\thttps://www.shadertoy.com/view/MscGDS\n\tState Demo     Uploaded by sixstring982 in 2016-Jan-4\n\t\"RAM in Shadertoy\" tutorial by Trent Small ( sixstring982 ) :\n\thttp://lunagameserve.com/articles/shadertoy_ram.html\n\t\n\tAdditional sources:\n\t-------------------\n\t\"Raymarching Primitives\"  Created by inigo quilez\n\thttps://www.shadertoy.com/view/Xds3zN\n\t\n\tHG_SDF : GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n\thttp://mercury.sexy/hg_sdf\n\t\n\tpyramid function :\n\thttps://www.shadertoy.com/view/lsBGzG\n\tpyramids    Uploaded by avix in 2014-Jan-16\n\t\n\tkeyToggle and keyPress functions :\n\thttps://www.shadertoy.com/view/MdKGRw\n    digits/sliders/kbd widgets - 2    Uploaded by FabriceNeyret2 in 2016-Jan-26\n\n\tScreen transition technique ( blend ) :\n\thttps://www.shadertoy.com/view/4tS3Rw\n    Preparations    Uploaded by movAX13h in 2015-Mar-27\n    \n    repeat function :\n    Ruslan Shestopalyuk\n    http://blog.ruslans.com/2015/01/raymarching-christmas-tree.html\n    \t\t\n*/\n//==============================================================================\n\n#define PI\t\t\t\t\t3.1415926535897932384626433832795\n\nconst int NUM_DISPLAYS = 6;\nconst float DISPLAY_PERIOD = 10.0,\n            TOTAL_TIME = DISPLAY_PERIOD * float( NUM_DISPLAYS );\n\n//------------------------------------------------------------------------------\n// Function declarations\n\nfloat sdSphere( vec3 p, float s );\nfloat sdBox( vec3 p, vec3 b );\nfloat sdEllipsoid( in vec3 p, in vec3 r );\nvec3 opTwist( vec3 p, float factor );\n\nvec2 rot( vec2 p, float r );\nvec2 rotsim( vec2 p, float s );\n\nfloat pModPolar(inout vec2 p, float repetitions);\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset); \nfloat pMirror (inout float p, float dist); \nvec2 pMirrorOctant (inout vec2 p, vec2 dist); \nfloat fCylinder(vec3 p, float r, float height); \nfloat fCapsule(vec3 p, float r, float c); \n \nfloat pyramid( vec3 p, float h);  \nfloat modPyramid( vec3 p, float h, float baseScale ); \nfloat diamondCutoutCube( vec3 p, float height );\nfloat octahedron( vec3 p, float height );\nfloat modOctahedron( vec3 p, float height, float scale );\nfloat modCutoutPyramid( vec3 p, float height, float scaleVal );\n\nvec3 getObjectColor( float id );\nfloat read( in float index );\n\n//------------------------------------------------------------------------------\n\n// MAP\n// ---\n// Returns vec2( distance, objID )\n\nvec2 map( vec3 p, bool autoMode, float choice )\n{\t\n\tvec2 closest = vec2( 0.0 );\n\tif ( autoMode )\n    {\n        choice = mod( iTime, TOTAL_TIME ) / DISPLAY_PERIOD;\n    }\n\n\t//========================================================\n\tif ( choice < 1.0 ) // HOOPCUT CUBES \t\n\t{\n\t\tp.yz = rot( p.yz, iTime * 0.23 );\n\t\tp.xz = rot( p.xz, iTime * 0.29 );\n\t\tp.xy = rot( p.xy, iTime * 0.19 );\n\t\n\t\tp.yz = rotsim( p.yz, 6.0 );\n\t\tp.z -= 30.0;\n\t\t\n\t\tp.xz = rot( p.xz, iTime * 0.51 );\n\t\n\t\tpMirror( p.x, 6.0 );\n\t\tpMirror( p.z, 6.0 );\n\t\tpMirror( p.y, 6.0 );\n\t\t\n\t\tp.xy = rot( p.xy, iTime * 0.53 );\n\t\n\t\tp.xz = rotsim( p.xz, 2.0 );\n\t\tp.z -= 6.0;\n\t\n\t\tfloat objID = 1.0;\n\t\tvec2 obj1 = vec2( diamondCutoutCube( p, 3.0 ), objID );\n\t\t\n\t\tp.yz = rot( p.yz, iTime * -0.73 );\n\t\tp.xz = rot( p.xz, iTime * -0.87 );\n\t\tp.xy = rot( p.xy, iTime * -0.67 );\n\t\t\t\n\t\tobjID = 2.0;\n\t\tvec2 obj2 = vec2( octahedron( p, 3.0 ), objID );\n\t\t\n\t\tclosest = obj1.s < obj2.s ? obj1 : obj2;\n\t\t\n\t} // end else if ( choice < 1.0 )\n\t//========================================================\t\n\telse if ( choice < 2.0 ) // FIREDICE\t\n\t{\n\t\t// Side to side movement of object\n\t\tp.x -= 6.0 * sin( iTime * 0.13 );\n\t\t\t\t\n\t\tp.yz = rot( p.yz, iTime * 0.13 );\n\t\tp.xz = rot( p.xz, iTime * 0.11 );\n\t\tp.xy = rot( p.xy, iTime * 0.17 );\n\t\n\t\tp.xz = rotsim( p.xz, 4.0 );\n\t\tp.z -= 1.0 + 4.0 * abs( sin( iTime * 0.03 ) );\n\t\t\n\t\tp.yz = rotsim( p.yz, 6.0 );\n\t\tp.z -= 0.2 + 4.0 * abs( sin( iTime * 0.07 ) );\n\t\t\n\t\tp.xy = rotsim( p.xy, 5.0 );\n\t\tp.y -= 0.1 + abs( sin( iTime * 0.13 ) );\n\t\t\n\t\tpMirror( p.x, 0.6 * abs( sin( iTime * 0.09 ) ) );\n\t\tpMirror( p.y, 0.75 * abs( sin( iTime * 0.17 ) ) );\n\t\tpMirror( p.z, abs( sin( iTime * 0.23 ) ) );\n\t\t\n\t\tp.xz = rot( p.xz, iTime * -0.17 );\n\t\tp.xy = rot( p.xy, iTime *  0.13 );\n\t\t\n\t\tfloat objID = 3.0,\n\t\t      d1 = modOctahedron( p, 1.0, 0.5 ),\n\t\t      d2 = modOctahedron( p.xzy, 1.0, 0.5 ),\n\t\t      d3 = modOctahedron( p.yxz, 1.0, 0.5 ),\n\t\t      d4 = sdSphere( p, 0.45 );\n\t\t\n\t\tvec2 obj1 = vec2( max( min( d1, min( d2, d3 ) ), -d4 ), objID );\n\t\t\t\n\t\tp.yz = rot( p.yz, iTime * -1.51 );\n\t\tp.xz = rot( p.xz, iTime * -1.47 );\n\t\tp.xy = rot( p.xy, iTime * -1.53 );\n\t\n\t\tobjID = 4.0;\n\t\td1 = modOctahedron( p, 0.4, 0.5 );\n\t\td2 = modOctahedron( p.xzy, 0.4, 0.5 );\n\t\td3 = modOctahedron( p.yxz, 0.4, 0.5 );\n\t\td4 = sdSphere( p, 0.18 );\n\t\t\n\t\tvec2 obj2 = vec2( max( min( d1, min( d2, d3 ) ), -d4 ), objID );\n\t\t\n\t\tobjID = 5.0;\n\t\tvec2 obj3 = vec2( sdSphere( p, 0.1 ), objID );\n\t\t\n\t\tclosest = obj1.s < obj2.s ? obj1 : obj2;\n\t\tclosest = closest.s < obj3.s ? closest : obj3;\n\t\t\t\t\n\t} // end else if ( choice < 2.0 )\n\t//========================================================\t\n\telse if ( choice < 3.0 )\t// TRANSMITION \n\t{\n\t\tp.x -= 10.0 * sin( iTime * 0.11 );\n\t\t\n\t\tp.yz = rot( p.yz, iTime * 0.23 );\n\t\tp.xz = rot( p.xz, iTime * 0.17 );\n\t\tp.xy = rot( p.xy, iTime * 0.13 );\n\t\t\n\t\tp.xz = rotsim( p.xz, 8.0 );\n\t\tp.z -= 2.0 * sin( iTime * 0.17 );\n\t\t\n\t\tp.xy = rotsim( p.xy, 4.0 );\n\t\tp.y -= 4.0 + 2.0 * sin( iTime * 0.11 );\n\t\t\n\t\tp.yz = rotsim( p.yz, 5.0 );\n\t\tp.z -= 4.0 + 2.0 * sin( iTime * 0.23 );\n\t\t\n\t\tp.xz = rotsim( p.xz, 2.0 );\n\t\tp.z -= 2.0 + 1.0 * sin( iTime * 0.05 );\n\t\n\t\tpModPolar( p.yz, 6.0 + 5.0 * sin( iTime * 0.03 ) );\n\t\tpModPolar( p.xz, 6.0 + 5.0 * sin( iTime * 0.01 ) );\n\t\tpModPolar( p.xy, 6.0 + 5.0 * sin( iTime * 0.05 ) );\n\n\t\tp = opTwist( p, sin( iTime * 0.11 ) );\n\t\n\t\tp.yz = rot( p.yz, iTime * -0.17 );\n\t\tp.xz = rot( p.xz, iTime * -0.13 );\n\t\tp.xy = rot( p.xy, iTime * -0.07 );\n\t\t\n\t\tfloat objID = 6.0,\n\t\t      dist1 = sdBox( p, vec3( 1.0 ) ),\n\t\t      dist2 = sdEllipsoid( p, vec3( 1.0 + abs( sin( iTime ) ),\n\t\t                                                    0.95, 0.95 ) ),\n\t\t      dist3 = sdEllipsoid( p.xzy, vec3( 0.95, 0.95, \n\t\t                               1.0 + abs( sin( iTime ) ) ) ),\n\t\t      dist4 = sdEllipsoid( p.yzx, vec3( 0.95,\n\t\t                         1.0 + abs( sin( iTime ) ), 0.95 ) );\t\n\t\tvec2 obj1 = vec2( max( max( max( dist1, -dist2 ), -dist3 ),\n\t\t                                                 -dist4 ), objID );\t\t\n\t\tp.yz = rot( p.yz, iTime * -0.41 );\n\t\tp.xz = rot( p.xz, iTime * -0.57 );\n\t\tp.xy = rot( p.xy, iTime * -0.53 );\n\t\n\t\tobjID = 7.0;\n\t\tdist1 = sdBox( p, vec3( 0.6 ) );\n\t\tdist2 = sdEllipsoid( p, vec3( 0.6 + abs( sin( iTime - 0.5 ) ),\n\t\t                                                    0.55, 0.55 ) );\n\t\tdist3 = sdEllipsoid( p.xzy, vec3( 0.55, 0.55,\n\t\t                         0.6 + abs( sin( iTime - 0.5 ) ) ) );\n\t\tdist4 = sdEllipsoid( p.yzx, vec3( 0.55,\n\t\t                   0.6 + abs( sin( iTime - 0.5 ) ), 0.55 ) );\t\n\t\tvec2 obj2 = vec2( max( max( max( dist1, -dist2 ), -dist3 ),\n\t\t                                                 -dist4 ), objID );\t\t\n\t\tp.yz = rot( p.yz, iTime * 0.47 );\n\t\tp.xz = rot( p.xz, iTime * 0.37 );\n\t\tp.xy = rot( p.xy, iTime * 0.43 );\n\t\n\t\tobjID = 8.0;\n\t\tdist1 = sdBox( p, vec3( 0.35 ) );\n\t\tdist2 = sdEllipsoid( \n\t\t     p, vec3( 0.35 + abs( sin( iTime - 1.0 ) ), 0.3, 0.3 ) );\n\t\tdist3 = sdEllipsoid( \n\t\t p.xzy, vec3( 0.3, 0.3, 0.35 + abs( sin( iTime - 1.0 ) ) ) );\n\t\tdist4 = sdEllipsoid( \n\t\t p.yzx, vec3( 0.3, 0.35 + abs( sin( iTime - 1.0 ) ), 0.3 ) );\t\n\t\tvec2 obj3 = vec2( max( max( max( dist1, -dist2 ), -dist3 ),\n\t\t                                                 -dist4 ), objID );\t\t\t\n\t\tobjID = 9.0;\n\t\tvec2 obj4 = vec2( sdSphere( p, 0.25 ), objID );\n\t\t\t\t\t\t\n\t\tclosest = obj1.s < obj2.s ? obj1 : obj2;\n\t\tclosest = closest.s < obj3.s ? closest : obj3;\n\t\tclosest = closest.s < obj4.s ? closest : obj4;\n\t\t\n\t} // end else if ( choice < 3.0 )\n\t//========================================================\t\n\telse if ( choice < 4.0 )  // SPOUQET\t\n\t{\n\t\tp.x -= 10.0 * sin( iTime * 0.31 );\n\t\t\n\t\tp.yz = rot( p.yz, iTime * 0.11 );\n\t\tp.xz = rot( p.xz, iTime * 0.13 );\n\t\tp.xy = rot( p.xy, iTime * 0.07 );\n\t\n\t\tp.xy = rotsim( p.xy, 4.0 );\n\t\tp.y -= 3.0 + 3.0 * sin( iTime * 0.31 );\n\t\t\n\t\tp.yz = rotsim( p.yz, 4.0 );\n\t\tp.z -= 5.0 + 5.0 * sin( iTime * 0.23 );\n\t\t\n\t\tp.xz = rotsim( p.xz, 4.0 );\n\t\tp.z -= 3.0 + 3.0 * sin( iTime * 0.29 );\n\t\t\t\t\t\t\n\t\tpModPolar( p.xy, 8.0 );\n\t\t\n\t\tp.xy = rotsim( p.xy, 4.0 );\n\t\tp.y -= 2.0 + sin( iTime * 0.11 );\n\t\t\t\n\t\tp.yz = rotsim( p.yz, 4.0 );\n\t\tp.z -= 4.0 + 2.0 * sin( iTime * 0.13 );\n\t\t\n\t\tfloat objID = 10.0,\n\t\t      d1 = fCapsule( p.zxy, 0.25, 6.0 ),\t                         \n\t\t\t  d2 = fCapsule( p, 0.25, 6.0 ),\n\t\t      d3 = fCylinder( p.xzy, 0.8, 1.1 ),\n\t\t      d4 = 0.0,\n\t\t      d5 = 0.0,\n\t\t      d6 = 0.0;\t                                \n\t\t\n\t\tvec2 obj1 = vec2( max( min( d1, d2 ), -d3 ), objID );                              \n\t\n\t\tobjID = 11.0;\n\t\td1 = sdSphere( p, 1.0 );\n\t\td2 = sdSphere( p - vec3( 1.0, 1.0, 0.0 ), 0.375 ),\n\t\td4 = sdSphere( p - vec3( -1.0, 1.0, 0.0 ), 0.375 );\n\t\td5 = sdSphere( p - vec3( 1.0, -1.0, 0.0 ), 0.375 ),\n\t\td6 = sdSphere( p - vec3( -1.0, -1.0, 0.0 ), 0.375 );\n\t\tvec2 obj2 = vec2( max( min( min( min( min( d1, d2 ), d4 ), d5 ),\n\t\t                                              d6 ), -d3 ), objID );\n\t\t\n\t\tp.yz = rot( p.yz, iTime * -0.79 );\n\t\tp.xz = rot( p.xz, iTime * -0.83 );\n\t\tp.xy = rot( p.xy, iTime * -0.73 );\n\t\t\n\t\tobjID = 12.0;\n\t\tvec2 obj3 = vec2( octahedron( p, 0.8 ), objID );\n\t\t\n\t\tclosest = obj1.s < obj2.s ? obj1 : obj2;\n\t\tclosest = closest.s < obj3.s ? closest : obj3;\n\t        \n\t} // end else if ( choice < 4.0 )\n\t//========================================================\t\n\telse if ( choice < 5.0 )  // RATCHETTE\t\n\t{\n\t\tp.xz = rot( p.xz, iTime * 0.11 );\n\t\tp.yz = rot( p.yz, iTime * 0.19 );\n\t\tp.xy = rot( p.xy, iTime * 0.17 );\n\t\t\n\t\tpMirror( p.y, 0.0 );\n\t\tpMirror( p.x, 1.0 );\n\t\tpMirror( p.z, 1.0 );\n\t\t\n\t\tpModPolar( p.xz, 8.0 );\n\t\tp.x -= 0.85 + 0.6 * sin( iTime * 0.13 );\n\t\t\n\t\tpModPolar( p.xz, 8.0 );\n\t\tp.x -= 0.85 + 0.6 * sin( iTime * 0.17 );\n\t\t\n\t\tpModPolar( p.yz, 8.0 );\n\t\tp.y -= 0.85 + 0.6 * sin( iTime * 0.11 );\n\t\t\n\t\tpModPolar( p.yz, 8.0 );\n\t\tp.y -= 0.85 + 0.6 * sin( iTime * 0.19 );\n\t\t\n\t\tpModPolar( p.xy, 8.0 );\n\t\tp.x -= 0.85 + 0.6 * sin( iTime * 0.53 );\n\t\t\n\t\tp.xz = rot( p.xz, iTime * 0.47 );\n\t\tfloat objID = 13.0,\n\t\t      d1 = modCutoutPyramid( p, 1.0, 1.3 ), \n\t\t      d2 = fCylinder( p, 0.6, 0.25 );\n\t\t\n\t\tvec2 obj1 = vec2( max( d1, -d2 ), objID );\n\t\t\n\t\tobjID = 14.0;\n\t\tp.xz = rot( p.xz, iTime * -0.53 );\n\t    d1 = octahedron( p, 0.6 );\n\t    d2 = sdSphere( p, 0.4 );\n\t\tvec2 obj2 = vec2( max( d1, -d2 ), objID );\n\t\t\n\t\tobjID = 15.0;\n\t\tvec2 obj3 = vec2( sdSphere( p, 0.25 + 0.15 * sin( iTime ) ), \n\t\t                                                           objID );\n\t\t                                      \n\t\tclosest = obj1.s < obj2.s ? obj1 : obj2;\n\t\tclosest = closest.s < obj3.s ? closest : obj3;\n\t\t\n\t} // end else if ( choice < 5.0 )\n\t//========================================================\t\n\telse if ( choice < 6.0 )\t// PIROUETTE\t\n\t{\n\t\tvec3 p2 = p;\n\t\t\n\t\tp.xz = p2.xz = rot( p.xz, iTime * 0.43 );\n\t\tp.yz = p2.yz = rot( p.yz, iTime * 0.37 );\n\t\tp.xy = p2.xy = rot( p.xy, iTime * 0.31 );\n\t\t\n\t\tp2.xy = rotsim( p2.xy, 4.0 );\t\n\t\tp2.y -= 5.0 + 2.5 * sin( iTime * 0.91);\n\t\t\n\t\tp2.xz = rotsim( p2.xz, 4.0 );\n\t\tp2.z -= 1.1 + 1.099 * sin( iTime * 0.73 );\n\t\t\n\t\tpMirrorOctant( p2.xy, vec2( 0.001 + 0.999 * \n\t\t                              abs( sin( iTime * 0.13 ) ) ) );\n\t\tp2.x -= 2.0 + 1.99 * sin( iTime * 0.23 );\n\t\t\n\t\tpMirrorOctant( p2.yz, vec2( 0.76 + 0.75 * \n\t\t                                     sin( iTime * 0.11 ) ) );\n\t\tp2.y -= 2.0 + sin( iTime * 0.19 );\n\t\t\n\t\tpMirrorOctant( p2.xz, vec2( 0.001 + 1.499 * \n\t\t                              abs( sin( iTime * 0.17 ) ) ) );\n\t\tp2.x -= 3.0 + 3.0 * sin( iTime * 0.29 );\n\t\t\n\t\tpReflect( p2, vec3( 0.0, 1.0, 0.0 ), \n\t\t                         10.0 + 10.0 * sin( iTime * 0.07 ) );\n\t\tpReflect( p2, vec3( 1.0, 0.0, 0.0 ), \n\t\t                         10.0 + 10.0 * sin( iTime * 0.17 ) );\n\t\tpReflect( p2, vec3( 0.0, 0.0, 1.0 ), \n\t\t                         10.0 + 10.0 * sin( iTime * 0.29 ) );\n\t\t\n\t\tp2.xz = rot( p2.xz, iTime * -0.31 );\n\t\tp2.yz = rot( p2.yz, iTime * -0.37 );\n\t\tp2.xy = rot( p2.xy, iTime * -0.43 );\n\t\n\t\tfloat d1 = sdSphere( p2, 1.0 ),\n\t\t      d2 = pyramid( p2 - vec3( 0.0, -1.125, 0.0 ), 1.1 );\n\t\t\n\t\t// sphere in first cutout\n\t\tfloat objID = 16.0;\n\t\tvec2 obj2 = \n\t\t       vec2( sdSphere( p2 - vec3( 0.0, 0.6, 0.0 ), 0.25 ), objID );\n\t\t\n\t\tp2.yz = rot( p2.yz, PI );\n\t\tfloat d3 = pyramid( p2 - vec3( 0.0, -1.125, 0.0 ), 1.1 );\n\t\t\n\t\t// sphere in second cutout\n\t\tobjID = 17.0;\n\t\tvec2 obj3 = \n\t\t       vec2( sdSphere( p2 - vec3( 0.0, 0.6, 0.0 ), 0.25 ), objID );\n\t\t\t      \n\t\tp2.yz = rot( p2.yz, PI * -0.5 );\n\t\tp2.xy = rot( p2.xy, PI * 0.5 );\n\t\tfloat d4 = pyramid( p2 - vec3( 0.0, -1.125, 0.0 ), 1.1 );\n\t\t\n\t\t// sphere in third cutout\n\t\tobjID = 18.0;\n\t\tvec2 obj4 = \n\t\t       vec2( sdSphere( p2 - vec3( 0.0, 0.6, 0.0 ), 0.25 ), objID );\n\t\t\n\t\tp2.xy = rot( p2.xy, PI );\n\t\tfloat d5 = pyramid( p2 - vec3( 0.0, -1.125, 0.0 ), 1.1 );\n\t\t\n\t\t// sphere in fourth cutout\n\t\tobjID = 19.0;\n\t\tvec2 obj5 = \n\t\t       vec2( sdSphere( p2 - vec3( 0.0, 0.6, 0.0 ), 0.25 ), objID );\n\t\t\t\n\t\tp2.xy = rot( p2.xy, PI * 0.5 );\n\t\tp2.xz = rot( p2.xz, PI * 0.5 );\n\t\tfloat d6 = pyramid( p2 - vec3( 0.0, -1.125, 0.0 ), 1.1 );\n\t\t\n\t\t// sphere in fifth cutout\n\t\tobjID = 20.0;\n\t\tvec2 obj6 = \n\t\t       vec2( sdSphere( p2 - vec3( 0.0, 0.6, 0.0 ), 0.25 ), objID );\n\t\t\n\t\tp2.xy = rot( p2.xy, PI );\n\t\tfloat d7 = pyramid( p2 - vec3( 0.0, -1.125, 0.0 ), 1.1 );\n\t\t\n\t\t// sphere in sixth cutout\n\t\tobjID = 21.0;\n\t\tvec2 obj7 = \n\t\t       vec2( sdSphere( p2 - vec3( 0.0, 0.6, 0.0 ), 0.25 ), objID );\n\t\t\n\t\tobjID = 22.0;\n\t\tvec2 obj1 = vec2( max( max( max( max( max( max( d1, -d2 ), -d3 ), \n\t\t                               -d4 ), -d5 ), -d6 ), -d7 ), objID );\n\t\t                                                            \n\t\t\t\t\t\n\t\tclosest = obj1.s < obj2.s ? obj1 : obj2;\n\t\tclosest = closest.s < obj3.s ? closest : obj3;\n\t\tclosest = closest.s < obj4.s ? closest : obj4;\n\t\tclosest = closest.s < obj5.s ? closest : obj5;\n\t\tclosest = closest.s < obj6.s ? closest : obj6;\n\t\tclosest = closest.s < obj7.s ? closest : obj7;\n\n\t} // end else if ( choice < 6.0 )\n\t//========================================================\t\n\t\t\n\treturn closest;\t\n}\n\n// end map()\n\n//------------------------------------------------------------------------------\n\n// MAIN IMAGE\n// ----------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat viewDist = 0.0,\n\t      maxDist = 0.0,\n\t      brightness = 0.0;\n\t      \n\tfloat choice = 0.0;\t      \n\t\n\tbool autoMode = true;\n\t\n\t//-----------------------------------------------------\n    // Test for autoMode status : keyboard check\n    // Keys are either keyboard or numpad\n    \n    float temp = read( 345.0 );\n    \n    if ( temp == 0.0 ) // key 0\n    {\n\t\tautoMode = true;\n\t}    \t\n    else if (temp == 0.1 ) //  key 1\n    {\n\t\tautoMode = false;\n        choice = 0.0;\t// display 1 \n    }\n    else if ( temp == 0.2 ) //  key 2\n    {\n\t\tautoMode = false;\n\t\tchoice = 1.0;\t// display 2 \n    }\n    else if ( temp == 0.3 ) //  key 3\n    {\n\t\tautoMode = false;\n\t\tchoice = 2.0; \n    }\n    else if ( temp == 0.4 ) //  key 4\n    {\n\t\tautoMode = false;\n\t\tchoice = 3.0; \n    }\n    else if ( temp == 0.5 ) //  key 5\n    {\n\t\tautoMode = false;\n\t\tchoice = 4.0; \n    }\n    else if ( temp == 0.6 ) //  key 6\n    {\n\t\tautoMode = false;\n\t\tchoice = 5.0; \n    }\n \t//--------------------------------------------------------\n    \n\tif ( autoMode )\n\t{\n\t\tchoice = mod( iTime, TOTAL_TIME ) / DISPLAY_PERIOD;\n\t} \n\n\t//-----------------------\n\t// Assign values for each display.\n\tif ( choice < 1.0 )\t\t\t\t\t\n\t{\n\t\tviewDist = -85.0;\n\t\tbrightness = 0.001;\n\t\tmaxDist = 180.0;\n\t}\n\telse if ( choice < 2.0 )\t\t\t\n\t{\n\t\tviewDist = -18.0;\n\t\tbrightness = 0.0000000001;\n\t\tmaxDist = 60.0;\n\t}\n\telse if ( choice < 3.0 )\t\t\t\n\t{\n\t\tviewDist = -30.0;\n\t\tbrightness = 0.005;\n\t\tmaxDist = 120.0;\n\t}\n\telse if ( choice < 4.0 )\t\t\t\n\t{\n\t\tviewDist = -40.0;\n\t\tbrightness = 0.01;\n\t\tmaxDist = 120.0;\n\t}\n\telse if ( choice < 5.0 )\t\t\t\n\t{\n\t\tviewDist = -12.0;\n\t\tbrightness = 0.01;\n\t\tmaxDist = 90.0;\n\t}\n\telse if ( choice < 6.0 )\t\t\t\n\t{\n\t\tviewDist = -30.0;\n\t\tbrightness = 0.005;\n\t\tmaxDist = 90.0;\n\t}\n\t//-----------------------\n\t\n\t// Adjust aspect ratio, normalize coords, center origin in xy-plane.\t\n\t// xRange = -1.7777778 to 1.775926, yRange = -1.0 to 0.9981482 at 1920x1080\n\tvec2 curPix = ( -iResolution.xy + 2.0 * gl_FragCoord.xy ) / iResolution.y;\n\t\n\tvec3 camUpVec = vec3( 0.0, 1.0, 0.0 );\n\tvec3 camView = vec3( 0.0, 0.0, 0.0 ); // Look-at\n\tvec3 camPos = vec3( 0.0, 0.0, viewDist ); \n\t\t\n\t//Camera setup\n\tfloat fov = 1.5;  \n\tvec3 forwardVec = normalize( camView - camPos ); // camera view direction\n\tvec3 rightVec = normalize( cross( camUpVec, forwardVec ) );\n\tvec3 upVec = cross( forwardVec, rightVec );\n\t\n\tvec3 scrCoord = camPos + forwardVec * fov + \n\t                                    curPix.x * rightVec + curPix.y * upVec;\n\t\n\tvec3 rayDir = normalize( scrCoord - camPos );\n\t\n\t//-----------\n\t//Raymarching\n\tconst vec3 e = vec3( 0.1, 0.0, 0.0 );\t\n\t\n\tvec2 distID = vec2( 0.1, 0.0 );\n\t\n\tvec3 clr = vec3( 0.0 ), \n\t     curRayPos = vec3( 0.0 ), \n\t     n = vec3( 0.0 ); // normal vector to hit position on object\n\t\n\tfloat dist = 1.0;\n\t\n\tfor ( int i = 0; i < 256; i++ )\n\t{\n\t\tif ( abs( distID.s ) < 0.001 || dist > maxDist ) break;\n\t\tdist += distID.s;\n\t\tcurRayPos = camPos + rayDir * dist;\n\t\tdistID = map( curRayPos, autoMode, choice );\n\t}\n\t\n\tif ( dist < maxDist )\n\t{\n\t\tclr = getObjectColor( distID.t );\n\t\t\n\t\t//tetrahedron normal\n\t\tconst float n_er = 0.01;\n\t\tfloat v1 =\n\t\tmap(vec3(curRayPos.x+n_er,curRayPos.y-n_er,curRayPos.z-n_er),\n\t\t                                                  autoMode, choice ).x;\n\t\tfloat v2 =\n\t\tmap(vec3(curRayPos.x-n_er,curRayPos.y-n_er,curRayPos.z+n_er),\n\t\t                                                  autoMode, choice ).x;\n\t\tfloat v3 = \n\t\tmap(vec3(curRayPos.x-n_er,curRayPos.y+n_er,curRayPos.z-n_er),\n\t\t                                                  autoMode, choice ).x;\n\t\tfloat v4 = \n\t\tmap(vec3(curRayPos.x+n_er,curRayPos.y+n_er,curRayPos.z+n_er),\n\t\t                                                  autoMode, choice ).x;\n\t\tn=normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n\t\t\t\t\n        //simple phong LightPosition=CameraPosition\n        float b = dot( n, normalize( camPos - curRayPos ) );\n        clr = ( b * clr + pow( b,8.0 ) ) * ( 1.0 - dist * brightness );\n\t\t\n\t\t//--------------------------------------------------\n\t\t// blend, from https://www.shadertoy.com/view/4tS3Rw\n\t\t//             Preparations    Uploaded by movAX13h in 2015-Mar-27\n\t\t\n\t\t// Affects how quickly the out-to-black then in-to-scene fade occurs.\n\t\t// Smaller number = longer fade time.\n\t\tfloat fadeVal = 1.6;\n\t\t\n\t\t// Measures the cycle time between all-black screens, i.e., within 5 \n\t\t// seconds, the screen starts black, fades into a scene, then fades \n\t\t// back to all black.\n\t\tfloat cycleLength = DISPLAY_PERIOD;\n\n\t\tif ( autoMode )\n        {\n        \tclr *= min( 1.0, \n\t\t              abs( fadeVal * sin( PI * iTime / cycleLength ) ) );\n        }\n\t\t//-----------------------------------------------------------------\n\t\t\n\t\tfragColor = vec4( clr, 1.0 );\n\t}\n\telse \n\t{\n\t\tfragColor = vec4( 0, 0, 0, 1.0 ); // background color\n\t}\n}\n\n// end mainImage()\n\n//------------------------------------------------------------------------------\n\n// GET OBJECT COLOR\n// ----------------\n\nvec3 getObjectColor( float id )\n{\n    vec3 clr = vec3( 1.0 );\n\n    // Circular Cutout Cubes\n    if ( id == 1.0 )\n    {\n    \tclr = vec3( 1.0, 0.7, 0.0 );\t\n    }\n    else if ( id == 2.0 )\n    {\n    \tclr = vec3( 0.3, 1.0, 0.75 );\t  \t\n    }\n    // Fired Ice\n    else if ( id == 3.0 )\n    {\n\t\tclr = vec3( 0.0, 0.0, 1.0 );\t\n    }\n    else if ( id == 4.0 )\n    {\n\t\tclr = vec3( 1.0, 0.33, 0.0 );\n    }\n    else if ( id == 5.0 )\n    {\n\t\tclr = vec3( 1.0, 1.0, 0.0 );\n    }\n    // TransmitIon\n    else if ( id == 6.0 )\n    {\n\t    clr = vec3( abs( sin( iTime * 0.03 ) ), \n\t\t            abs( sin( iTime * 0.05 ) ),\n\t\t            abs( sin( iTime * 0.07 ) ) );\n    }\n    else if ( id == 7.0 )\n    {\n\t\tclr = vec3( abs( sin( iTime * 0.07 ) ), \n\t\t\t        abs( sin( iTime * 0.11 ) ),\n\t\t\t        abs( sin( iTime * 0.13 ) ) );\n    }\n    else if ( id == 8.0 )\n    {\n\t\tclr = vec3( abs( sin( iTime * 0.13 ) ), \n\t\t\t        abs( sin( iTime * 0.17 ) ),\n\t\t\t        abs( sin( iTime * 0.19 ) ) );\n    }\n    else if ( id == 9.0 )\n    {\n\t\tclr = vec3( abs( sin( iTime * 0.19 ) ), \n\t\t\t        abs( sin( iTime * 0.23 ) ),\n\t\t\t        abs( sin( iTime * 0.29 ) ) );\n    }\n    // Spouqet\n    else if ( id == 10.0 )\n    {\n\t\tclr = vec3( 0.7, 0.8, 0.95 );\n    }\n    else if ( id == 11.0 )\n    {\n\t\tclr = vec3( abs( sin( iTime * 0.05 ) ), \n\t\t\t        abs( sin( iTime * 0.07 ) ),\n\t\t\t        abs( sin( iTime * 0.11 ) ) );\n    }\n    else if ( id == 12.0 )\n    {\n\t\tclr = vec3( abs( sin( iTime * 0.13 ) ), \n\t\t\t        abs( sin( iTime * 0.11 ) ),\n\t\t\t        abs( sin( iTime * 0.07 ) ) );\n    }\n    // Ratchette\n    else if ( id == 13.0 )\n    {\n    \tclr = vec3( 0.0, abs( sin( iTime * 0.01 ) ), 1.0 );\t\n    }\n    else if ( id == 14.0 )\n    {\n\t\tclr = vec3( 0.8, 0.9, 1.0 );\t\n    }\n    else if ( id == 15.0 )\n    {\n\t\tclr = vec3( abs( sin( iTime * 0.07 ) ), \n\t\t            abs( sin( iTime * 0.03 ) ),\n\t\t            abs( sin( iTime * 0.05 ) ) );\n    }\n\t// Pirouette\n    else if ( id == 16.0 )\n    {\n\t\tclr = vec3( 0.7, 0.8, 0.9 );\t\n    }\n    else if ( id == 17.0 )\n    {\n\t    clr = vec3( abs( sin( iTime * 0.03 ) ), \n\t\t\t\t    abs( sin( iTime * 0.05 ) ),\n\t\t\t\t    abs( sin( iTime * 0.07 ) ) );\n    }\n    else if ( id == 18.0 )\n    {\n\t    clr = vec3( abs( sin( iTime * 0.04 ) ), \n\t\t\t\t    abs( sin( iTime * 0.06 ) ),\n\t\t\t\t    abs( sin( iTime * 0.08 ) ) );\n    }\n    else if ( id == 19.0 )\n    {\n\t    clr = vec3( abs( sin( iTime * 0.05 ) ), \n\t\t\t\t    abs( sin( iTime * 0.07 ) ),\n\t\t\t\t    abs( sin( iTime * 0.09 ) ) );\n    }\n    else if ( id == 20.0 )\n    {\n\t    clr = vec3( abs( sin( iTime * 0.06 ) ), \n\t\t\t\t    abs( sin( iTime * 0.08 ) ),\n\t\t\t\t    abs( sin( iTime * 0.1 ) ) );\n    }\n    else if ( id == 21.0 )\n    {\n\t    clr = vec3( abs( sin( iTime * 0.07 ) ), \n\t\t\t\t    abs( sin( iTime * 0.09 ) ),\n\t\t\t\t    abs( sin( iTime * 0.11 ) ) );\n    }\n    else if ( id == 22.0 )\n    {\n\t    clr = vec3( abs( sin( iTime * 0.08 ) ), \n\t\t\t\t    abs( sin( iTime * 0.1 ) ),\n\t\t\t\t    abs( sin( iTime * 0.12 ) ) );\n    }\n\t\n\treturn clr;\t\n}\n\n// end getObjectColor()\n\n//------------------------------------------------------------------------------\n\n// Based on\n// https://www.shadertoy.com/view/MscGDS\n// State Demo     Uploaded by sixstring982 in 2016-Jan-4\n\n#define RAM_SIZE 128.0\n\n// Convert a linear index to a vec2 used to \n// index into the 128 * 128 virtual \"RAM\".\nvec2 cellFromIndex(float idx) \n{\n    return vec2( floor( idx / RAM_SIZE ), floor( mod( idx, RAM_SIZE ) ) ) / \n                                                      iChannelResolution[0].xy;\n}\n\n// Read a value from \"RAM\", given an index.\n// This assumes that \"RAM\" is a 128 * 128 region,\n// which gives 128 * 128 = 16384 floats of memory.\n// This function assumes that this is indexed linearly,\n// sort of like RAM would be indexed in C.\nfloat read( in float index ) \n{\n    return texture( iChannel0, cellFromIndex( index ) ).r;\n}\n//------------------------------------------------------------------------------\n\n// From \"Raymarching Primitives\" - // Created by inigo quilez - iq/2013\n// https://www.shadertoy.com/view/Xds3zN\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// b = vec3( halfWidth, halfHeight, halfDepth )\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nvec3 opTwist( vec3 p, float factor )\n{\n    float  c = cos(factor*p.y+factor);\n    float  s = sin(factor*p.y+factor);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//------------------------------------------------------------------------------\n\n// From \"Playing with symmetries - Torus\"\t   by @paulofalcao\t\n// http://glslsandbox.com/e#29755.0\n\n// Rotation around z-axis when vec2 p.xy;\n// Rotation around y-axis when vec2 p.xz;\n// Rotation around x-axis when vec2 p.yz.\nvec2 rot(vec2 p,float r)\n{\n   vec2 ret;\n   ret.x=p.x*cos(r)-p.y*sin(r);\n   ret.y=p.x*sin(r)+p.y*cos(r);\n   return ret;\n}\n\n// When vec2 p.xy, rotational symmetry about z-axis;\n// when vec2 p.xz, rotational symmetry about y-axis\n// when vec2 p.yz, rotational symmetry about x-axis\nvec2 rotsim(vec2 p,float s)\n{\n   vec2 ret=p;\n   ret=rot(p,-PI/(s*2.0));\n   ret=rot(p,floor(atan(ret.x,ret.y)/PI*s)*(PI/s));\n   return ret;\n}\n\n//------------------------------------------------------------------------------\n\n// HG_SDF : GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n// http://mercury.sexy/hg_sdf\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\n\n\t// To obtain separation of the cloned objects, either:\n\t// 1.) translate the original object in the object definition function, or\n\t// 2.) translate p *after* the pModPolar function is called.\n\t//  This version preserves the full object shapes, without shearing, when \n\t// they're offset from the origin - but along the correct axis.\n\t//pModPolar( p.xy, 4.0 );\n\t//p -= vec3( 1.0, 0.0, 0.0 ); // this works\n\t//p -= vec3( 0.0, 1.0, 0.0 ); // this doesn't - causes shearing\n\nfloat pModPolar(inout vec2 p, float repetitions) \n{\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Sign function that doesn't return 0\nfloat sgn(float x) \n{\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) \n{                           // added from 3rd version - wjb\n\treturn vec2((v.x<0.0)?-1.0:1.0, (v.y<0.0)?-1.0:1.0);\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) \n{\n\tfloat t = dot(p, planeNormal)+offset;\n\tif (t < 0.) {\n\t\tp = p - (2.*t)*planeNormal;\n\t}\n\treturn sgn(t);\t//return sign(t); Changed in third version - wjb\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> \n// from the origin.\nfloat pMirror (inout float p, float dist) \n{\n\tfloat s = sgn(p); \n\tp = abs(p)-dist;\n\treturn s;\n}\n\n// Mirror in both dimensions and at the diagonal, yielding one eighth of the \n// space.\n// translate by dist before mirroring.\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) \n{\n\tvec2 s = sgn(p);\t\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) \n{\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// Capsule: A Cylinder with round caps on both sides\nfloat fCapsule(vec3 p, float r, float c) \n{\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n//------------------------------------------------------------------------------\n\n// https://www.shadertoy.com/view/lsBGzG\n// pyramids    Uploaded by avix in 2014-Jan-16\n\n// Pyramid with base on xz-plane at y=0.0, h = height, width, and depth\nfloat pyramid( vec3 p, float h) \n{\n\tvec3 q=abs(p);\n\treturn max(-p.y, (q.x+q.y+q.z-h)/3.0 );\n}\n//------------------------------------------------------------------------------\n// wjb : Using the octahedron to cut out the inside of the cube resulted in a\n// very thin but noticeable plane where the two pyramid bases joined; so it was\n// necessary to offset both pyramids towards the center to remove the plane.\n\nfloat diamondCutoutCube( vec3 p, float height )\n{\n\tfloat d1 = sdBox( p, vec3( height ) ),\n\t      d2 = pyramid( p - vec3( 0.0, -0.1, 0.0 ), 2.0 * height );\n\tp.yz = rot( p.yz, PI );\n\tfloat d3 = pyramid( p - vec3( 0.0, -0.1, 0.0 ), 2.0 * height ),\n\t      d4 = min( d2, d3 );\n\t      \t      \n\treturn max( d1, -d4 );\t\n}\n//------------------------------------------------------------------------------\n// wjb : Note that using this as a cutout object may make the thin plane visible\n// where the two pyramid bases join. See diamondCutoutCube.\nfloat octahedron( vec3 p, float height )\n{\n\tfloat d1 = pyramid( p, height );\n\tp.yz = rot( p.yz, PI );\n\tfloat d2 = pyramid( p, height );\n\treturn min( d1, d2 );\t\t\n}\n//------------------------------------------------------------------------------\n// wjb: Joining two modPyramids to form an octahedron with variable base length.\n// scale MUST BE >= 0.5\n\nfloat modOctahedron( vec3 p, float height, float scale )\n{\n\tfloat d1 = modPyramid( p, height, scale );\n\tp.yz = rot( p.yz, PI );\n\tfloat d2 = modPyramid( p, height, scale );\n\treturn min( d1, d2 );\t\t\n}\n//------------------------------------------------------------------------------\n// wjb : This should replace cutoutPyramid, as it allows adjustment of size of\n// cutout.\nfloat modCutoutPyramid( vec3 p, float height, float scaleVal )\n{\n\tvec3 p2 = p;\n\tp2.xz = rot( p2.xz, PI * 0.25 );\n\t\n\tfloat d1 = pyramid( p2, height ),\n\t      d2 = modPyramid( p - vec3( 0.0, 0.1, 0.0 ),  \n\t                                       height * ( scaleVal / 1.5 ), 1.35 );\n\treturn max( d1, -d2 );\n}\n\n// Modified from pyramid(), above.\n// Pyramid with base on xz-plane at y=0.0, h = height, s = scaling factor for\n// length of an edge of the square pyramid base, where edge length = s * h, \n// i.e., h = 2.0, s = 0.5, base edge = 1.0; or h = 2.0, s = 2.0, base edge = 4.0\n// s MUST BE >= 0.5\n//------------------------------------------------------------------------------\n                        \nfloat modPyramid( vec3 p, float h, float s ) \n{\n\tvec3 q = abs( p );\n\tfloat scale = 1.0 / s;\n\treturn max( -p.y, ( q.x * scale + q.y + q.z * scale - h ) / 3.0 );\n}\n//------------------------------------------------------------------------------\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n *\tBUF_A \n *\n *\tContains Buf A in iChannel0 and keyboard in iChannel3\n *\n */\n//========================================================================= \n\n// https://www.shadertoy.com/view/MdKGRw\n// digits/sliders/kbd widgets - 2    Uploaded by FabriceNeyret2 in 2016-Jan-26\n\nbool keyToggle( int ascii ) \n{\n\treturn ( texture( iChannel3, \n\t                vec2( ( 0.5 + float( ascii ) ) / 256.0, 0.75 ) ).x > 0.0 );\t                                                        \n}\nbool keyPress( int ascii ) \n{\n\treturn ( texture( iChannel3, \n\t                vec2( ( 0.5 + float( ascii ) ) / 256.0, 0.25 ) ).x > 0.0 );\n}\n//------------------------------------------------------------------------------\n\n// https://www.shadertoy.com/view/MscGDS\n// State Demo     Uploaded by sixstring982 in 2016-Jan-4\n\n#define RAM_SIZE 128.0\n\n// Convert a linear index to a vec2 used to \n// index into the 128 * 128 virtual \"RAM\".\nvec2 cellFromIndex( float idx ) \n{\n    return vec2( floor( idx / RAM_SIZE ), floor( mod( idx, RAM_SIZE ) ) ) / \n                                                      iChannelResolution[0].xy;\n}\n\n// Read a value from \"RAM\", given an index.\n// This assumes that \"RAM\" is a 128 * 128 region,\n// which gives 128 * 128 = 16384 floats of memory.\n// This function assumes that this is indexed linearly,\n// sort of like RAM would be indexed in C.\nfloat read( in float index ) \n{\n    return texture( iChannel0, cellFromIndex( index ) ).r;\n}\n\n// Checks to see if the current fragCoord is in a \n// target RAM cell. This allows checking for each\n// cell in parallel.\nbool isCell( in vec2 uv, in float index ) \n{\n    vec2 target = cellFromIndex( index );\n    return uv.x >= target.x - 0.005 &&\n           uv.x <= target.x + 0.005 &&\n           uv.y >= target.y - 0.005 &&\n           uv.y <= target.y + 0.005;\n}\n\n// This function, if you're used to game development,\n// is a little like the \"update\" function. This is\n// where updating of all variables should be done.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    // See if this particular fragment is the RAM cell\n    // we want to update\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    if ( isCell( uv, 345.0 ) ) \n    {\n        // Initialize variable\n    \tif ( iFrame == 0 ) \n        {\n\t        fragColor = vec4( 0.0 );\n            return;\n        }\t\n        \n\t    // Check condition. Keys are either keyboard or numpad\n\t    if ( keyPress( 48 ) || keyPress( 96 ) ) //  key 0\n\t    {\n\t\t\tfragColor = vec4( vec3( 0.0 ), 1.0 );   \t\n\t    }\n\t    else if ( keyPress( 49 ) || keyPress( 97 )  ) //  key 1\t\n\t    {\n\t\t\tfragColor = vec4( vec3( 0.1 ), 1.0  );  \n\t    }\n\t    else if ( keyPress( 50 ) || keyPress( 98 )  ) //  key 2\t\n\t    {\n\t\t\tfragColor = vec4( vec3( 0.2 ), 1.0  );  \n\t    }\n \t    else if ( keyPress( 51 ) || keyPress( 99 )  ) //  key 3\t\n\t    {\n\t\t\tfragColor = vec4( vec3( 0.3 ), 1.0  );  \n\t    }\n\t    else if ( keyPress( 52 ) || keyPress( 100 )  ) //  key 4\t\n\t    {\n\t\t\tfragColor = vec4( vec3( 0.4 ), 1.0  );  \n\t    }\n\t    else if ( keyPress( 53 ) || keyPress( 101 )  ) //  key 5\t\n\t    {\n\t\t\tfragColor = vec4( vec3( 0.5 ), 1.0  );  \n\t    }\n\t    else if ( keyPress( 54 ) || keyPress( 102 )  ) //  key 6\t\n\t    {\n\t\t\tfragColor = vec4( vec3( 0.6 ), 1.0  );  \n\t    }\n       else // State remains unchanged\n        {\n            fragColor = vec4( read( 345.0 ) );\n        }\n    }\n        \n    // Set variable to previous state\n    else \n    {\n        fragColor = vec4( read( 345.0 ) );\n    }\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}