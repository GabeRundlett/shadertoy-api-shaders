{
    "Shader": {
        "info": {
            "date": "1462967278",
            "description": "First attempt at raymarched mountains. Tried to find an elementary way of producing some not-terrible looking terrain.  IQ's articles were really helpful. I might revisit this later since it doesn't look too pretty at the moment.",
            "flags": 0,
            "hasliked": 0,
            "id": "MsKXRh",
            "likes": 0,
            "name": "Mountain March",
            "published": 3,
            "tags": [
                "raymarching",
                "terrain"
            ],
            "usePreview": 0,
            "username": "Aspect",
            "viewed": 718
        },
        "renderpass": [
            {
                "code": "  float pi=3.14159265358979323846264338;\n\n\nconst mat2 rotate2D = mat2(1.3623, 1.7531, -1.7131, 1.4623);\n\nfloat terrain(float x,float z)\n{\n  \n    vec2 pos=vec2(x,z);\n   pos= rotate2D*pos;\n    \n    float sum=0.0;\n    float hdetail=17.15;\n    float pepper=0.;\n    for (float i=5.0;i<15.;i+=5.)\n    {\n     sum+= (i/3.6905)*texture(iChannel1,pos/hdetail).x;   \n        hdetail*=2.;\n    }\n    \n   float ldetail=512.;\n    for (float i=5.0;i<15.;i+=5.)\n    {\n     ldetail*=2.;\n     sum+= (12.*i)*texture(iChannel1,pos/ldetail).y;   \n        \n    }\n    \n return 0.0685*sum;  \n}\n\n\n\n\n\nvec3 sky(in vec3 color,in vec3 lightpos,in vec3 rayDir,in vec3 camo)\n{\n    \tfloat sundot = clamp(dot(rayDir,lightpos),0.5,1.0);\n\t\tvec3 col = vec3(0.3,.7,0.8)*(1.0-0.5*rayDir.y)*1.0;\n\t\tcol += 0.65*vec3(0.2,0.7,0.9)*pow( sundot,32.0 );\n\t\tcol += 0.52*vec3(0.75,0.7,0.9)*pow( sundot,12.0 );\n        col = mix( col, vec3(0.6,0.6,0.85), pow( 1.0-max(rayDir.y,0.2), 0.85 ) );\n    \n    return col;\n}\n\n\nvec3 rayMarch(vec3 pos,vec3 rayDir,float EPSILON,out float dist,out float sdist,out float wtvd)\n{\n    float mini=999999.0;\n     float stepsize= 0.002;\n    const float maxd= 30.0;\n    const float maxiter=1300.;\n    float wtv=0.0;\n    float stepdist=0.;\n    for (float i = 0.0; i < maxiter; i+=1.)\n    {       \n      float height=  terrain(pos.x,pos.z);\n      dist=pos.y-height;\n      if((dist<EPSILON)||(stepdist>maxd))\n      {\n          \n        wtv=stepdist;  \n       \tbreak;\n        \n        \n      }\n      else\n      {\n          stepdist+=stepsize;\n        pos+=rayDir*stepsize;  \n        stepsize*=1.00315;//incrase slightly for perfomance\n      }\n        \n       \n    wtv=stepdist;\n    wtvd=i;\n    }\n    sdist=distance(pos-wtv*rayDir,pos);\n    wtvd=stepdist;\n    return pos;\n}\n\n\n\nvec3 calculateNormal(float EPSILON, vec3 pos,out float wtvd)\n{\n    EPSILON=EPSILON*(2500./(wtvd+1400.));\n\tvec3 normal = normalize(vec3(    terrain(pos.x+EPSILON,pos.z) - terrain(pos.x-EPSILON,pos.z),    2.0*EPSILON,\n                                 terrain(pos.x,pos.z + EPSILON) - terrain(pos.x,pos.z - EPSILON)));\n            \n    return normal;\n}\n\n\nvoid getRay(vec2 screenPos,out vec3 cameraOrigin,out vec3 rayDir,out vec3 lightpos)\n{\n    cameraOrigin = vec3(0.0, 5.75,2.*mod(iTime,155.));  \n    vec3 cameraTarget = vec3(0.0, 0.0, cameraOrigin.z+30.);\n    vec3 upDirection = vec3(0.0, 1.0, 0.0);\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n\tvec3 cameraUp = (cross(cameraDir, cameraRight));\n    lightpos.z=cameraOrigin.z+35.0;\n    lightpos.y=cameraOrigin.y+20.;\n    rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n   \n\n}\n\n\nvec3 applyFog( in vec3  rgb,       \n               in float distance ) \n{\n    float b=0.125;\n    float fogAmount = 1.0 - exp( -distance*b );\n    vec3  fogColor  = vec3(0.55,0.56,0.67*exp( 0.025*distance*b ));\n    return mix( rgb, fogColor, fogAmount );\n}\n\n\nvec4 render(vec2 ScreenPos)\n{\n    vec3 rayDir=vec3(0.0);\n    vec3 pos=vec3(0.0);\n    vec3 lightpos=vec3(25.0,55.0,0.0);\n    getRay(ScreenPos,pos,rayDir,lightpos);\n    vec3 camo= pos;\n \n    const int MAX_ITER = 100;\n    const float MAX_DIST = 30.0; \n    float EPSILON = 0.01;\n    float totalDist = 0.0;\n    float dist = 0.0;\n    float sdist= 0.0;\n        vec3 color=vec3(0.0);\n    float wtvd=0.0;\n\n    //initial march towards objects\n    pos=rayMarch(pos,rayDir,EPSILON,dist,sdist,wtvd);\n                     \n   if ((dist) <EPSILON)\n\t{\n     EPSILON=0.005;\n     vec3 normal=calculateNormal(EPSILON,pos,wtvd);\n        \n    \n   \n    vec3  lightdir=   normalize(lightpos-pos);  \n    vec3 halfvec= normalize(lightdir-rayDir);\n    vec3 reflected= normalize(reflect(rayDir,normal));\n\n\n        float diffuse = max(0.0, dot(lightdir, normal));\n         float specular=0.0;\n        color = vec3(0.45,0.45,0.45)*mix(diffuse,terrain(pos.x,pos.z),0.01);\n        color=applyFog(color,sdist);\n        return vec4(color,1.0);\n    \t\n\t}\n    \n    \n    return vec4(sky(color,lightpos,rayDir,camo),1.0);\n\n   \n    \n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{         \n\tvec2 uv = fragCoord.xy / iResolution.xy;   \n    vec2 xy = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n \n    vec2 screenPos = -1.0 + 2.0 * gl_FragCoord.xy / iResolution.xy; \n\tscreenPos.x *= iResolution.x / iResolution.y; \n     vec2 mo = iMouse.xy/iResolution.xy;\n  \n    fragColor=render(screenPos);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}