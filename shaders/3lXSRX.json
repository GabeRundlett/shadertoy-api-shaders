{
    "Shader": {
        "info": {
            "date": "1563630621",
            "description": "This is a first attempt at doing raytracing with GLSL.",
            "flags": 0,
            "hasliked": 0,
            "id": "3lXSRX",
            "likes": 2,
            "name": "x0004 - raytracing - 001",
            "published": 3,
            "tags": [
                "raytracing",
                "multiplelights"
            ],
            "usePreview": 0,
            "username": "xigh",
            "viewed": 406
        },
        "renderpass": [
            {
                "code": "// SDF stands for Signed Distance Function :\n//\n// - if point inside surface, return negative value\n// - if point outside surface, return positive value\n// - if point on the surface, return 0\n\nstruct Sdf {\n\tfloat dist;\n    vec3  norm;\n};\n\nSdf sphereSDF(vec3 point, vec3 pos, float radius)\n{\n    return Sdf(\n        length(point-pos) - radius,\n        normalize(point-pos)\n    );    \n}\n\nvec3  light1Pos      = vec3(-1.0, +1.0, +0.0);\nvec3  light1Color    = vec3(+1.0, +0.5, +0.0);\n\nvec3  light2Pos      = vec3(+1.0, +1.0, +0.0);\nvec3  light2Color    = vec3(+0.0, +0.5, +1.0);\n\nvec3  sphere1Pos     = vec3(+0.0, +0.0, +0.0);\nvec3  sphere1Color   = vec3(+1.0, +1.0, +1.0);\n\nvec3 computeScene(in vec3 eyePos, in vec3 eyeDir, in vec2 uv)\n{\n    float depth = -100.0;\n    for (int i = 0; i < 32; i++)\n    {\n        vec3 pt = eyePos + depth * eyeDir;\n\n        Sdf s1 = sphereSDF(pt, sphere1Pos, 1.0);\n        Sdf s2 = sphereSDF(pt, light1Pos, 0.1);\n        Sdf s3 = sphereSDF(pt, light2Pos, 0.1);\n        \n        float d = min(s1.dist, min(s2.dist, s3.dist));\n        if (d < 0.0001)\n        {\n            if (d == s2.dist)\n        \t{\n            \treturn light1Color;\n        \t}\n        \n        \tif (d == s3.dist)\n        \t{\n            \treturn light2Color;\n        \t}\n        \n            // we have a hit, now compute color\n            vec3 normal = s1.norm;\n            \n            float diffuse1 = clamp(dot(normal, normalize(light1Pos)), 0.0, 1.0);\n            float diffuse2 = clamp(dot(normal, normalize(light2Pos)), 0.0, 1.0);\n            \n            vec3 color1 = diffuse1 * light1Color;\n            vec3 color2 = diffuse2 * light2Color;\n            \n            return mix(color1, color2, 0.5) + sphere1Color * 0.7;\n        }\n        \n        depth += d;\n        if (depth > 100.0)\n            break;\n    }\n\n    return vec3(smoothstep(0.0, 1.0, max(0.0, 0.1-uv.y)));\n}\n\nconst float PI = 3.1415;\n\nvoid moveLights()\n{\n    light1Pos.xz = 2.0 * vec2(sin(iTime), cos(iTime));\n    light1Pos.y = +2.5;\n\n    light2Pos.xz = 2.0 * vec2(sin(iTime+PI), cos(iTime+PI));\n    light2Pos.y = +2.5;\n}\n\nvoid moveSphere()\n{\n    sphere1Pos.xz = vec2(0.0);\n    sphere1Pos.y = -0.5 + sin(iTime*2.1)/2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // prepare coordinate so that :\n    //     -1.0 <= ux.y <= +1.0\n    // and -rat <= ux.x <= +rat\n    vec2 uv = (fragCoord/iResolution.xy)-0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    moveLights();\n    moveSphere();\n\n    // define camera position and direction\n\tvec3 camPos = vec3(0.0, 0.5, 20.0);\n    vec3 camDir = normalize(vec3(uv, -1.0 / tan(PI/10.0)));\n\n    // compute scene\n    vec3 col = computeScene(camPos, camDir, uv);\n    fragColor = vec4(vec3(col),1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}