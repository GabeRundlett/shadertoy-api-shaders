{
    "Shader": {
        "info": {
            "date": "1716997852",
            "description": "Left: Original\nMiddle: RGB10A2 Octadronal Normal + Diamond Tangent + Bitangent Sign\nRight: RGBA8 QTangent\n\nTop: Tangent\nMiddle: Bitangent\nBottom: Normal\n\nEvery 5 seconds the display switches back and forth between error distance display and normal shading",
            "flags": 0,
            "hasliked": 0,
            "id": "lXt3DB",
            "likes": 6,
            "name": "RGB10A2 vs. RGBA8 TangentSpace",
            "published": 3,
            "tags": [
                "3d",
                "normals",
                "compression"
            ],
            "usePreview": 0,
            "username": "BeRo",
            "viewed": 181
        },
        "renderpass": [
            {
                "code": "// Encoding&Decoding functions - Copyright 2024, Benjamin 'BeRo' Rosseaux - zlib licensed\n\n// Left: Original\n// Middle: RGB10A2 Octadronal Normal + Diamond Tangent + Bitangent Sign\n// Right: RGBA8 QTangent\n\n// Top: Tangent\n// Middle: Bitangent\n// Bottom: Normal\n\n// Every 5 seconds the display switches back and forth between error \n// distance display and normal shading.\n\n// Comparison shader based on: https://www.shadertoy.com/view/Mtfyzl\n// The MIT License\n// Copyright Â© 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n//=================================================================================================\n// all iq code below\n//=================================================================================================\n\nfloat map( vec3 p )\n{\n    p.xz *= 0.8;\n    p.xyz += 1.000*sin(  2.0*p.yzx );\n    p.xyz -= 0.500*sin(  4.0*p.yzx );\n    float d = length( p.xyz ) - 1.5;\n\treturn d * 0.25;\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 7.0;\n\n\tfloat precis = 0.001;\n    float h = 1.0;\n    float t = 1.0;\n    for( int i=0; i<256; i++ )\n    {\n        if( (h<precis) || (t>maxd) ) break;\n\t    h = map( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\treturn t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    // from Paul Malin (4 samples only in a tetrahedron\t\n    vec2 e = vec2(1.0,-1.0)*0.002;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvoid getTangentSpaceBasisFromNormal(in vec3 n, out vec3 t, out vec3 b){\n  if(abs(n.z) >= 1e-6){\n    float a = n.y / (1.0 + n.z),\n          d = n.y * a,\n          c = -n.x * a;\n    t = normalize(vec3(n.z + d, c, -n.x));\n    b = normalize(vec3(c, 1.0 - d, -n.y));\n  }else{\n    t = n.yzx - n.zxy; \n    t = normalize(t - dot(t, n));\n    b = cross(n, t);\n  }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n\tvec2 q = fragCoord/iResolution.xy;\n\t\n    //-----------------------------------------------------\n\n    float ti = mod( 0.25*iTime, 8.0 );\n    float am = clamp( ti/3.0, 0.0, 1.0 ) - clamp( (ti-4.0)/3.0, 0.0, 1.0 );\n    uint precis = 1u + uint(floor(15.0*am));\n    \n    //-----------------------------------------------------\n\t\n\tfloat an = 4.0 + 0.1*iTime*2.0;\n    \n\tvec3 ro = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    vec3 ta = vec3(0.0,0.0,0.0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = normalize( ca * vec3(p,-1.5) );\n\n    //-----------------------------------------------------\n    \n\tvec3 col = vec3(0.07)*clamp(1.0-length(q-0.5),0.0,1.0);\n\n    float t = intersect(ro,rd);\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        \n        vec3 nor = calcNormal(pos);\n        vec3 t,b;\n        getTangentSpaceBasisFromNormal(nor,t,b);\n   \n        vec3 ref = reflect( rd, nor );\n        mat3 tbn0 = mat3(t,b,nor);\n\n        mat3 tbn1 = decodeTangentSpaceFromRGB10A2SNorm(encodeTangentSpaceAsRGB10A2SNorm(tbn0)); \n           \n        mat3 tbn2 = unpackQTangent(round(packQTangent(tbn0) * 127.0) / 127.0);\n        \n        int w;\n        if(p.y < -(1.0/3.0)){\n          w = 2; // Normal\n        }else if(p.y < (1.0/3.0)){\n          w = 1; // Bitangent\n        }else{\n          w = 0; // Tangent\n        }\n        nor = (p.x < (-1.0 / 1.5)) ? tbn0[w] : ((p.x < (1.0 / 1.5)) ? tbn1[w] : tbn2[w]);\n        \n        vec3 error = abs(tbn0[w] - nor);\n\n        // material\n\t\tcol = vec3(0.2);\n        col *= 1.0 + 0.5*nor;\n        \n\t\t// lighting\n        float sky = 0.5 + 0.5*nor.y;\n        float fre = clamp( 1.0 + dot(nor,rd), 0.0, 1.0 );\n        float spe = pow(max( dot(-rd,nor),0.0),32.0);\n\t\t// lights\n\t\tvec3 lin  = vec3(0.0);\n\t\t     lin += 3.0*vec3(0.7,0.80,1.00)*sky;\n        \t lin += 8.0*vec3(0.7,0.8,1.00)*smoothstep(0.0,0.2,ref.y)*(0.1+0.9*pow(fre,5.0))*sky;\n             lin += 1.0*fre*vec3(1.0,0.90,0.80);\n        col = col * lin;\n        col += 0.50*spe;\n        col += 0.15*spe*spe*spe;\n        \n        if(fract(iTime * 0.1) >= 0.5){\n          col = error;\n        }\n        \n\t}\n\n\tcol = sqrt(col);\n    \n   // col += PrintInt( (q-vec2(0.75,0.8))*12.0*vec2(1.0,iResolution.y/iResolution.x), float(2u*precis) );\n\n    col *= smoothstep( 0.003,0.004,abs(q.x-(0.5+(1.0/3.0)*(iResolution.y/iResolution.x))));\n    col *= smoothstep( 0.003,0.004,abs(q.x-(0.5-(1.0/3.0)*(iResolution.y/iResolution.x))));\n    \n    col *= smoothstep( 0.003,0.006,abs(q.y-(0.5+(1.0/6.0))));\n    col *= smoothstep( 0.003,0.006,abs(q.y-(0.5-(1.0/6.0))));\n\n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Copyright 2024, Benjamin 'BeRo' Rosseaux - zlib licensed\n\n/*\n** Encoding and decoding functions from tangent space vectors to a single 32-bit unsigned integer (four bytes) in\n** RGB10A2_SNORM format and back.\n** \n** These functions are used to encode and decode tangent space vectors into a single 32-bit unsigned integer.\n** The encoding is done using the RGB10A2 snorm format, which allows to store the tangent space in a single integer.\n** The encoding is lossy, but the loss is very small and the precision is enough for most use cases.\n** \n** The encoding is done as follows:\n** 1. The normal is projected onto the octahedron, which is a 2D shape that represents the normal in a more efficient way.\n** 2. The tangent is projected onto the canonical diamond space, which is a 2D space that is aligned with the normal.\n** 3. The tangent is projected onto the tangent diamond, which is a 1D space that represents the tangent in a more efficient way.\n** 4. The bitangent sign is stored in signed 2 bits as -1.0 or 1.0.\n** 5. The values are packed into a single 32-bit unsigned integer using the RGB10A2 snorm format.\n** \n** The decoding is done as follows:\n** 1. The values are unpacked from the RGB10A2 snorm format.\n** 2. The normal is decoded from the octahedron.\n** 3. The canonical directions are found.\n** 4. The tangent diamond is decoded.\n** 5. The tangent is found using the canonical directions and the tangent diamond.\n** 6. The bitangent is found using the normal, the tangent and the bitangent sign. \n** \n** Idea based on https://www.jeremyong.com/graphics/2023/01/09/tangent-spaces-and-diamond-encoding/ but with improvements for\n** packing into RGB10A2 snorm to a 32-bit unsigned integer.\n**\n**/\n\n// WebGL GLSL doesn't have fma(), so we need to define it ourself here\n#define fma(a,b,c) (((a)*(b))+(c))\n\nmat2x3 getCanonicalSpaceFromNormal(in vec3 n){\n  vec3 t = n.yzx - n.zxy, b = normalize(cross(n, t = normalize(t - dot(t, n))));\n  return mat2x3(t, b); \n}\n\nmat3 decodeTangentSpaceFromRGB10A2SNorm(const in uint encodedTangentSpace){\n\n  // Unpack the values from RGB10A2 snorm\n  ivec4 encodedTangentSpaceUnpacked = ivec4(\n    int(uint(encodedTangentSpace << 22u)) >> 22,\n    int(uint(encodedTangentSpace << 12u)) >> 22,\n    int(uint(encodedTangentSpace << 2u)) >> 22,\n    int(uint(encodedTangentSpace << 0u)) >> 30\n  );\n\n  // Decode the tangent space\n  vec2 octahedronalNormal = vec2(encodedTangentSpaceUnpacked.xy) / 511.0;\n  vec3 normal = vec3(octahedronalNormal, 1.0 - (abs(octahedronalNormal.x) + abs(octahedronalNormal.y)));\n  normal = normalize((normal.z < 0.0) ? vec3((1.0 - abs(normal.yx)) * fma(step(vec2(0.0), normal.xy), vec2(2.0), vec2(-1.0)), normal.z) : normal);\n\n  // Find the canonical space\n  mat2x3 canonicalSpace = getCanonicalSpaceFromNormal(normal);\n  \n  // Decode the tangent diamond direction\n  float tangentDiamond = float(encodedTangentSpaceUnpacked.z) / 511.0;\n  float tangentDiamondSign = (tangentDiamond < 0.0) ? -1.0 : 1.0; // No sign() because for 0.0 in => 1.0 out\n  vec2 tangentInCanonicalSpace;\n  tangentInCanonicalSpace.x = 1.0 - (tangentDiamond * tangentDiamondSign * 2.0);\n  tangentInCanonicalSpace.y = tangentDiamondSign * (1.0 - abs(tangentInCanonicalSpace.x));\n  tangentInCanonicalSpace = normalize(tangentInCanonicalSpace);\n  \n  // Decode the tangent\n  vec3 tangent = normalize(canonicalSpace * tangentInCanonicalSpace);\n\n  // Decode the bitangent\n  vec3 bitangent = normalize(cross(normal, tangent) * float(encodedTangentSpaceUnpacked.w));\n\n  return mat3(tangent, bitangent, normal);\n\n}\n\nuint encodeTangentSpaceAsRGB10A2SNorm(mat3 tbn){\n\n  // Normalize tangent space vectors, just for the sake of clarity and for to be sure\n  tbn[0] = normalize(tbn[0]);\n  tbn[1] = normalize(tbn[1]);\n  tbn[2] = normalize(tbn[2]);\n\n  // Get the octahedron normal\n  vec3 normal = tbn[2];\n  vec2 octahedronalNormal = normal.xy / (abs(normal.x) + abs(normal.y) + abs(normal.z)); \n  octahedronalNormal = (normal.z < 0.0) ? ((1.0 - abs(octahedronalNormal.yx)) * fma(step(vec2(0.0), octahedronalNormal.xy), vec2(2.0), vec2(-1.0))) : octahedronalNormal;\n  \n  // Find the canonical space\n  mat2x3 canonicalSpace = getCanonicalSpaceFromNormal(normal);\n\n  // Project the tangent into the canonical space \n  vec2 tangentInCanonicalSpace = vec2(dot(tbn[0], canonicalSpace[0]), dot(tbn[0], canonicalSpace[1]));\n  \n  // Find the tangent diamond direction (a diamond is more or less the 2D equivalent of the 3D octahedron here in this case)\n  float tangentDiamond = (1.0 - (tangentInCanonicalSpace.x / (abs(tangentInCanonicalSpace.x) + abs(tangentInCanonicalSpace.y)))) * ((tangentInCanonicalSpace.y < 0.0) ? -1.0 : 1.0) * 0.5;\n\n  // Find the bitangent sign\n  float bittangentSign = (dot(cross(tbn[0], tbn[1]), tbn[2]) < 0.0) ? -1.0 : 1.0; \n\n  // Encode the tangent space as signed values\n  ivec4 encodedTangentSpace = ivec4(\n    ivec2(clamp(octahedronalNormal, vec2(-1.0), vec2(1.0)) * 511.0), // 10 bits including sign\n    int(clamp(tangentDiamond, -1.0, 1.0) * 511.0), // 10 bits including sign\n    int(clamp(bittangentSign, -1.0, 1.0)) // 2 bits\n  );\n  \n  // Pack the values into RGB10A2 snorm\n  uint t = ((uint(encodedTangentSpace.x) & 0x3ffu) << 0u) | \n           ((uint(encodedTangentSpace.y) & 0x3ffu) << 10u) | \n           ((uint(encodedTangentSpace.z) & 0x3ffu) << 20u) | \n           ((uint(encodedTangentSpace.w) & 0x3u) << 30u);\n     \n#if 1\n  // Optional step for ensure that the bitangent sign is correct \n  if(dot(decodeTangentSpaceFromRGB10A2SNorm(t)[1], tbn[1]) < 0.0){\n     t = (t & 0x3fffffffu) | ((uint(int(-encodedTangentSpace.w)) & 0x3u) << 30u);\n  }\n#endif\n  \n  return t;\n\n}\n\nvec4 packQTangent(mat3 m){\n  const float threshold = 1.0 / 127.0; \n  const float renormalization = sqrt(1.0 - (threshold * threshold));\n  float t = m[0][0] + (m[1][1] + m[2][2]);\n  vec4 q;\n  if(t > 2.9999999){\n    q = vec4(0.0, 0.0, 0.0, 1.0);\n  }else if(t > 0.0000001){\n    float s = sqrt(1.0 + t) * 2.0;\n    q = vec4(vec3(m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / s, s * 0.25);\n  }else if((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])){\n    float s = sqrt(1.0 + (m[0][0] - (m[1][1] + m[2][2]))) * 2.0;\n    q = vec4(s * 0.25, vec3(m[1][0] + m[0][1], m[2][0] + m[0][2], m[1][2] - m[2][1]) / s);    \n  }else if(m[1][1] > m[2][2]){\n    float s = sqrt(1.0 + (m[1][1] - (m[0][0] + m[2][2]))) * 2.0;\n    q = vec4(vec3(m[1][0] + m[0][1], m[2][1] + m[1][2], m[2][0] - m[0][2]) / s, s * 0.25).xwyz;\n  }else{\n    float s = sqrt(1.0 + (m[2][2] - (m[0][0] + m[1][1]))) * 2.0;\n    q = vec4(vec3(m[2][0] + m[0][2], m[2][1] + m[1][2], m[0][1] - m[1][0]) / s, s * 0.25).xywz; \n  }\n  q = normalize(q); \n  q = mix(q, -q, float(q.w < 0.0));\n  q = mix(q, vec4(q.xyz * renormalization, threshold), float(q.w < threshold));\n  return mix(q, -q, float(dot(cross(m[0], m[2]), m[1]) <= 0.0)); \n}\n\nmat3 unpackQTangent(vec4 q){\n  q = normalize(q); \n  float qx2 = q.x + q.x,\n        qy2 = q.y + q.y,\n        qz2 = q.z + q.z,\n        qxqx2 = q.x * qx2,\n        qxqy2 = q.x * qy2,\n        qxqz2 = q.x * qz2,\n        qxqw2 = q.w * qx2,\n        qyqy2 = q.y * qy2,\n        qyqz2 = q.y * qz2,\n        qyqw2 = q.w * qy2,\n        qzqz2 = q.z * qz2,\n        qzqw2 = q.w * qz2;\n  vec3 tangent = vec3(1.0 - (qyqy2 + qzqz2), qxqy2 + qzqw2, qxqz2 - qyqw2);\n  vec3 normal = vec3(qxqz2 + qyqw2, qyqz2 - qxqw2, 1.0 - (qxqx2 + qyqy2));\n  return mat3(tangent, cross(tangent, normal) * sign(q.w), normal);\n} \n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}