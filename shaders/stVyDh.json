{
    "Shader": {
        "info": {
            "date": "1661787968",
            "description": "Cannon-Thurston map",
            "flags": 8,
            "hasliked": 0,
            "id": "stVyDh",
            "likes": 13,
            "name": "[â™ª]Garden of Thorns",
            "published": 3,
            "tags": [
                "fractal",
                "music"
            ],
            "usePreview": 0,
            "username": "Catzpaw",
            "viewed": 423
        },
        "renderpass": [
            {
                "code": "//---Garden of Thorns\n// by Catzpaw 2022\n\n//Image:Cannon-Thurston map (figure eight knot)\n\nconst float pi=acos(-1.);\nconst float tau=pi*2.;\n\nfloat beat(){return 1.+sin(iTime*tau*20.)*pow(1.-fract(iTime*BPM/60.+.1),6.)*.1;}\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,s,-s,c);}\nvec3 hsv(float h,float s,float v){return ((clamp(abs(fract(h+vec3(0.,.666,.333))*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;}\nvec4 mul(vec4 a,vec4 b){return vec4(a.x*b.x-a.y*b.y-a.z*b.z-a.w*b.w,a.x*b.y+a.y*b.x+a.z*b.w-a.w*b.z,a.x*b.z-a.y*b.w+a.z*b.x+a.w*b.y,a.x*b.w+a.y*b.z-a.z*b.y+a.w*b.x);}\nvec4 div(vec4 a,vec4 b){return mul(a,vec4(b.x,-b.yzw)/dot(b,b));}\nvec4 mobius(vec2 a,vec2 b,vec2 c,vec2 d,vec4 z){return div(mul(vec4(a,0,0),z)+vec4(b,0,0),mul(vec4(c,0,0),z)+vec4(d,0,0));}\n\nconst float sr3=sqrt(3.);\nconst vec2 w=vec2(.5,sr3*.5),iw=vec2(.5,-sr3*.5);\nconst vec2 o=vec2(0,0),c=vec2(1,0);\nbool t1(vec4 p){return p.x*-w.y>-p.y*w.x;}\nbool t2(vec4 p){return p.x*-w.y>p.y*w.x;}\nbool i2(vec4 p){return (p.x-1.)*w.y>-p.y*w.x;}\nbool t3(vec4 p){return (p.x-1.)*w.y>p.y*w.x;}\nbool i3(vec4 p){p-=vec4((c+ w)/3.,0,0);return dot(p.xyz,p.xyz)<1./3.;}\nbool i1(vec4 p){p-=vec4((c+iw)/3.,0,0);p*=p;return p.x+p.y+p.z<1./3.;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv=(fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    uv/=dot(uv,uv);\n    uv*=rot(iTime*.14);\n    float at=iTime*tau*BPM/(60.*128.);\n    float bt=iTime*tau*BPM/(60.*64.);\n    float a=clamp(cos(at-.1)*80.,0.,1.);\n    float b=clamp(cos(bt-.1)*40.,0.,1.);\n    float z=.2+sin(iTime*.3)*.19;\n    vec2 p=vec2(cos(at)+.5,sin(bt))+z*uv*beat();\n    vec4 q=vec4(p,z*.01,0);\n    float h=0.,v=0.;\n    for(int i=0;i<40;i++){\n        if      (t1(q)){q=mobius(   c,-w, c,  iw,q);h+=.03;}\n        else if (i1(q)){q=mobius(  iw, w,-c,   c,q);h-=.03;}\n        else if (t2(q)){q=mobius(   c, w, o,   c,q);v-=1.;}\n        else if (i2(q)){q=mobius(   c,-w,-o,   c,q);v+=1.;}\n        else if (t3(q)){q=mobius( -iw,-w, w,-w-c,q);v-=1.;}        \n        else if (i3(q)){q=mobius(-w-c, w,-w, -iw,q);v+=1.;}\n        else break;\n        v-=mix(0.,q.z,a)+mix(-q.w,q.x,b);\n    }\n    fragColor = vec4(hsv(h+a*.3+b*.4+iTime*.02,.3,.5+b*.5+v*.1),1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//---Garden of Thorns\n// by Catzpaw 2022\n\n//Sound:scale sequencer\n\n//--- Scale Sequencer 3.5 by Catzpaw 2022\n\n//================================================================================\n// SETUP\n//--------------------------------------------------------------------------------\nconst float base =440.;\t//master tuning (Hz)\nconst float bpm  =BPM;\t//beats per minute\nconst float steps=240.;\t//steps per measure (default:240steps)\nconst float start=2.;   //start count (beats)\nconst float fade =10.;  //fade out time (default:10sec)\nconst float sec  =180.; //performance time (includes fade out time and start count)\n\nconst int gateSeed=241; //random seed for gate generator;\nconst int noteSeed=147; //random seed for note generator;\n\n//SCALE\nint key=4; //0:C 1:C+ 2:D 3:D+ 4:E 5:F 6:F+ ... 11:B\nconst uint[4] scl=uint[](0xca875320u,0xcb975420u,0xcb875320u,0xcb975320u); //minor,major,harmonic,melodic\n\n//================================================================================\n// SEQUENCE DATA\n//--------------------------------------------------------------------------------\n//CHORD SEQUENCE (version 3)\n//div1(2),scale2(2),div2(2),scale3(2),chord1(8),chord2(8),chord3(8)\n//chord:\n//  00-07:I,I,II,III,IV,V,VI,VII\n//  +00:triad\n//  +10:-3\t  +18:+3\n//\t+20:-5\t  +28:+5\n//\t+30:-3-5  +38:+3+5\n//\t+40:add9\n//\t+80:diatonic6(m6 or 6)\n//\t+c0:diatonic7(7 or M7)\n//  Example...symbol:C7 = key:C,scale:minor,chord:Im7+3 = 0x01+0x18+0xc0 = 0xd9\n// The length of the sequence is unlimited.\nconst int chordlen=16;const uint chordseq[chordlen]=uint[](\n\t0x01u,0x21u,0x31u,0x01u,0x01u,0x21u,0x31u,0x01u,\n    0x43u,0x22u,0xc2u,0x43u,0x04u,0x42u,0x82u,0x41u);\n\n//PATTERN (version 3)\n// melodic:range(4),rest(4),seed1(12),seed2(12)\n// percussive:note(2x16)\n// You can set up to 256 patterns.\nconst uint[32] pat=uint[](\n    0x0f000000u,0x00000000u,0x48008001u,0x470af101u,  //00-03 mute(melo),mute(perc),chord,chord\n    0x36605711u,0x46529114u,0x56183614u,0x34151883u,  //04-07 melody\n    0x45043102u,0x47476291u,0x54973179u,0x36390710u,  //08-0B melody\n    0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,  //0C-13 \n    0x70080868u,0x70086865u,0x18164656u,0x18164656u,  //14-17 accompaniment,bass\n    0x3238e232u,0x3138e132u,0x61382132u,0x9d1ce136u,  //18-1B sd+hh\n    0x01010101u,0x01c10181u,0x11c14581u,0x55d10591u); //1C-1F bd+fx\n\n//PATTERN SEQUENCE (version 3)\n// speed1(2),speed2(2),division(4),top1(4),pattern1(8),top2(4),pattern2(8)\n// speed    0:1x 1:2x 2:0.25x 3:0.5x\n// top      0-e ... auto inversion amount (0:no inversion 7:octave)\n// division 0-f ... timing to switch pattern1 to pattern2 (0:only pattern2 8:half)\n// The length of each sequence is unlimited.\nconst int len1=8;const uint[len1] seq1=uint[]( //snare+hihat\n    0x18u,0x1au,0x18u,0x19u,0x18u,0x19u,0x18u,0x1bu);\nconst int len2=8;const uint[len2] seq2=uint[]( //bassdrum\n    0x1cu,0x1du,0x1cu,0x1du,0x1cu,0x1du,0x1cu,0x1fu);\nconst int len3=1;const uint[len3] seq3=uint[]( //bass\n    0x0616u);\nconst int len4=4;const uint[len4] seq4=uint[]( //chord\n    0x03u,0x03u,0x02u,0x03u);\nconst int len5=4;const uint[len5] seq5=uint[]( //accompaniment\n    0x0814u,0x0814u,0x0815u,0x0814u);\nconst int len6=16;const uint[len6] seq6=uint[]( //melody\n    0x04u,0x05u,0x06u,0x0bu,0x04u,0x05u,0x06u,0x07u,\n    0x04u,0x09u,0x08u,0x07u,0x04u,0x09u,0x0au,0x0bu);\n\n\n//================================================================================\n// INSTRUMENTS & EFFECTS\n//--------------------------------------------------------------------------------\n//AMP\n//  vec3 p( drive, pressure, volume)\nvec2 amp(vec2 i,vec3 p){return clamp(sign(i)*pow(abs(i*p.x)*.01,vec2(1./p.y))*100.,-1.,1.)*p.z;}\n\n//FREQUENCY FROM MIDI NOTE NUMBER\nconst float i12=1./12.;\nfloat freq(float n){return pow(2.,(n-69.)*i12)*base;}\n\n//ENVELOPE\nfloat env_d(float x,float d){return max(0.,1.-x/max(d,1e-4));}\n\n//NES SOUND GENERATORS(without DPCM)\nfloat osc_duty(float x,float d){return fract(x)<d?1.:-1.;}\n//float osc_tri4(float x){return abs(floor(fract(x)*15.9999)/7.5-1.);}\nconst float nc=1789772.5;const float[16] nt=float[](\n    nc/2.,nc/4.,nc/8.,nc/16.,nc/32.,nc/48.,nc/64.,nc/80.,nc/101.,\n    nc/127.,nc/190.,nc/254.,nc/381.,nc/508.,nc/1017.,nc/2034.);\nfloat osc_nesnoise(float x,int i){return fract(sin(floor(x*nt[i])*179.2)*204.8);}\n\n//WAVETABLE OSC(namco C30/N163)\nconst int wtsamples=24;\nconst float wtlen=float(wtsamples);\nconst uint[wtsamples] wt=uint[](\n    0x000bb8bau,0x100de7fdu,0x203efdefu,0x303ff7dfu,0x4020efedu,0x5020b7dau,0x6a60af97u,0x7a6f9735u,\n    0x8a0e9d04u,0x9a0d9734u,0xaa3b9a75u,0xba398786u,0x45c67879u,0x55c4658au,0x65f268cbu,0x75f162fbu,\n    0x859068cau,0x959f5068u,0xafdf4825u,0xbfdf1012u,0xcfc00820u,0xdfc10210u,0xeff21802u,0xfff44745u);\nconst float i15=1./15.;\nfloat osc_c30(float x,int i){return(float((wt[int(mod(x*wtlen,wtlen))]>>(i*4))&15u)*i15-.5);}\n\n//CHIPTUNE INSTRUMENTS (freq,time)\nconst float detune =.0025;\nvec2 dutybass(float f,float x){return vec2(osc_duty(f*(.5+detune),.5),osc_duty(f*(.5-detune),.5))*env_d(x,.5);}\nvec2 c30chord(float f,float x){return vec2(osc_c30(f*(1.-detune),7),osc_c30(f*(1.+detune),7));}\nvec2 c30bell(float f,float x){return vec2(osc_c30(f*(1.-detune),1),osc_c30(f*(1.+detune),1))*env_d(x,.6);}\n\n//CHIPTUNE PERCUSSION (time)\n//float nessd(float x){return osc_nesnoise(x,11)*env_d(x,.25);}\nfloat neshh(float x,float d){return osc_nesnoise(x,0)*env_d(x,d);}\nfloat nesbd(float x){return osc_duty(3./(x*.5+.1),.5)*env_d(x,.1);}\n\n//LPF\n#define LPFI 96\n#define LPF(fn) float b=0.,o=0.;c+=1e-10;n=freq(n);for(int i=0;i<LPFI;i++){float f=n*(x+float(i)/iSampleRate);b+=c*((fn)+q*(b-o)/(1.-c)-o);o+=c*(b-o);}return o;\n\n//SAW WITH LPF (note,time,cutoff,lpq)\nfloat lpfsaw(float n,float x,float c,float q){LPF(mod(f,2.)-1.)}\n\n//C30 WITH LPF (note,time,cutoff,lpq,sound)\nfloat lpfc30(float n,float x,float c,float q,int s){LPF(osc_c30(f,s))}\n\n//Special instruments\nfloat fx1(float x){return (osc_c30(293.*x,7)+osc_c30(440.*x,7))*env_d(x,.12);}\nfloat fx2(float x){return osc_duty(3e2*x*(1.+x*3.),.5)*env_d(x,.07);}\nfloat sd(float x){return osc_nesnoise(x,11)*env_d(x,.25)+osc_duty(6./(x*.5+.1),.5)*.3*env_d(x,.05);}\n\n\n//================================================================================\n// SEQUENCER\n//--------------------------------------------------------------------------------\n//BIT OPERATION\nint imod(int x,int y){return int(x-y*(x/y));}\nint get12(uint b,int l){return int(b>>l*4)&4095;}\nint get8(uint b,int l){return int(b>>l*4)&255;}\nint get4(uint b,int l){return int(b>>l*4)&15;}\nint get2(uint b,int l){return int(b>>l*2)&3;}\nint get3(int b,int p){return int(b>>p)&7;}\n\n//GET NOTE FROM SCALE\nint degree=0;uint scale=0u;\t//internal use\nint scaleNote(int y){int n=y>6?12:0;return y<-50?-99:key+int((scale>>((y+56)%7)*4)&15u)+n;}\n\n//GET PATTERN FROM SEQUENCE\nfloat mp=0.; //note length multiplier(from speed)\nint   to=0;  //top note for auto inversion\nuint  pt=0u; //pattern now playing\nint   st=0;  //step now playing\nconst vec4 spd=vec4(16.,32.,4.,8.);\nvoid getPattern(float t,uint sq){\n    bool di=int(mod(t*bpm*16./steps,16.))<get4(sq,6);\n    to=di?get4(sq,5):get4(sq,2);\n    pt=di?pat[get8(sq,3)]:pat[get8(sq,0)];\n    mp=spd[di?get2(sq,15):get2(sq,14)];\n    st=int(mod(t*bpm*mp/steps,16.));\n}\n\n//GET CHORD SEQUENCE\nuint scop(uint sc,int p,int op){p*=4;int n=int(sc&(15u<<p));sc^=uint(n);n>>=p;n+=op;n=n<0?n+12:n;return sc|uint((n&15)<<p);}\nuint scset(uint sc,int p,int b){p*=4;int n=int(sc&(15u<<p));sc^=uint(n);return sc|uint(b<<p);}\nivec4 seven=ivec4(7,1,5,6);\nvoid scaleChord(float t,float l,uint p){\n    int st=int(mod(t*bpm*4./steps,4.)),d=get2(p,15),sc=st<d?0:get2(p,14),ch=st<d?get8(p,4):get8(p,2);\n    d+=get2(p,13);ch=st<d?ch:get8(p,0);sc=st<d?sc:get2(p,12);scale=scl[sc];\n    degree=get3(ch,0);degree-=degree>0?1:0;\n    int c35=get3(ch,3);\n    scale=scop(scale,(degree+2)&7,(c35&2)>0?(c35&1)*2-1:0);\n    scale=scop(scale,(degree+4)&7,(c35&4)>0?(c35&1)*2-1:0);\n    int c7=(seven[get2(uint(ch),3)]+degree)%7;\n    scale=scset(scale,(degree+6)&7,int(scl[sc]>>c7*4)&15);\n}\n\n//GET NOTE FROM PATTERN\nint notegen(int s,int s1,int s2){\n    return (imod((s*s1+s2)*gateSeed+67,173)&15)<=get4(pt,6)?-99:\n        imod(((s+s1+s2)*noteSeed+71),get4(pt,7)+1);\n}\nvec2 getNote(float t,float l){\n    int s1=get12(pt,3),s2=get12(pt,0),n=notegen(st,s1,s2);float x=mod(t,l/mp);\n    if((st>=1)&&(n<-50)){n=notegen(st-1,s1,s2);x+=l/mp;}\n    n+=n<-50?0:degree+7;n-=n>16-to?7:0;\n    return (n<-50)?vec2(x,-99):vec2(x,scaleNote(n));\n}\nfloat getChord(int n){\n    n+=degree+7;n-=n>16-to?7:0;\n    return float(scaleNote(n));\n}\nvec2 getNoteByChord(float t,float l){\n    int s1=get12(pt,3),s2=get12(pt,0),n=notegen(st,s1,s2);n-=n&1;float x=mod(t,l/mp);\n    if((st>=1)&&(n<-50)){n=notegen(st-1,s1,s2);x+=l/mp;n-=n&1;}\n    n+=n<-50?0:degree+7;n-=n>16-to?7:0;\n    return (n<-50)?vec2(x,-99):vec2(x,scaleNote(n));\n}\nvec2 getGate(float t,float l){\n    int n=get2(pt,st);float x=mod(t,l/mp);\n    if((st>=1)&&(n==0)){n=get2(pt,st-1);x+=l/mp;}\n    return vec2(x,n);\n}\n\n//================================================================================\n// RENDERER\n//--------------------------------------------------------------------------------\n//TRACK 1 snaredrum,closehh,openhh\nvec2 track1(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq1[imod(s,len1)]);\n    vec2 n=getGate(t,l);\n    o+=(n.y==1.)?sd(n.x)*vec2(.48,.62):vec2(0);\n    o+=(n.y==2.)?neshh(n.x,.08)*vec2(.15,.24):vec2(0);\n    o+=(n.y==3.)?neshh(n.x,.2)*vec2(.15,.24):vec2(0);\n    return o;\n}\n//TRACK 2 bassdrum,fx1,fx2\nvec2 track2(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq2[imod(s,len2)]);\n    vec2 n=getGate(t,l);\n    o+=(n.y==1.)?nesbd(n.x)*vec2(.4,.55):vec2(0);\n    o+=(n.y==2.)?fx1(n.x)*vec2(.45,.65):vec2(0);\n    o+=(n.y==3.)?fx2(n.x)*vec2(.35,.15):vec2(0);\n    return o;\n}\n//TRACK 3 bass\nvec2 track3(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq3[imod(s,len3)]);\n    vec2 n=getNoteByChord(t,l);\n    o+=(n.y>-50.)?dutybass(freq(n.y+24.)*n.x,n.x)*vec2(.28,.31):vec2(0);\n    o+=(n.y>-50.)?lpfsaw(n.y+36.,n.x,sin(t*bpm*3.142/480.)*.3+.34,.9)*vec2(.2)*env_d(n.x,.6)*vec2(.88,.98):vec2(0);\n    return o;\n}\n//TRACK 4 chord\nvec2 track4(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq4[imod(s,len4)]);\n    vec2 n=getNote(t,l);\n    o+=(n.y>-50.)?c30chord(freq(n.y+36.03)*n.x,n.x)*.25:vec2(0);\n    o+=(n.y>-50.)?c30chord(freq(getChord(2)+48.02)*n.x,n.x)*vec2(.30,.20):vec2(0);\n    o+=(n.y>-50.)?c30chord(freq(getChord(4)+36.01)*n.x,n.x)*vec2(.31,.19):vec2(0);\n    o+=(n.y>-50.)?c30chord(freq(getChord(6)+48.01)*n.x,n.x)*vec2(.32,.18):vec2(0);\n    return o;\n}\n//TRACK 5 accompaniment\nvec2 track5(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq5[imod(s,len5)]);\n    vec2 n=getNoteByChord(t,l);\n    o+=(n.y>-50.)?c30bell(freq(n.y+72.)*n.x,n.x)*vec2(.30,.35):vec2(0);\n    return o;\n}\n//TRACK 6 melody\nvec2 track6(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq6[imod(s,len6)]);\n    vec2 n=getNoteByChord(t,l);\n    o+=(n.y>-50.)?lpfc30(n.y+36.03,n.x,sin(t*bpm*3.142/64.)*.3+.4,.9,5)*vec2(.40,.50):vec2(0);\n    return o;\n}\nvoid render(float t,float l,inout vec2 o,bool e){\n    int s=int(t/l); //sequence number now playing\n    scaleChord(t,l,chordseq[imod(s,chordlen)]); //set scale & chord\n    o+=e?track1(t,l,s):track1(t,l,s)*.7; //TRACK 1 snaredrum,closehh,openhh\n    o+=e?track2(t,l,s):track2(t,l,s)*.5; //TRACK 2 bassdrum,fx1,fx2\n    o+=  track3(t,l,s);                  //TRACK 3 bass\n    o+=  track4(t,l,s);                  //TRACK 4 chord\n    o+=e?track5(t,l,s):track5(t,l,s)*.8; //TRACK 5 accompaniment\n    o+=  track6(t,l,s);                  //TRACK 6 melody\n}\n\n//================================================================================\n// MASTER\n//--------------------------------------------------------------------------------\n#define MASTER_DRIVE    0.35\n#define MASTER_PRESSURE 1.05\n#define DELAY_REPEAT    8\n#define DELAY_WET       0.50\n#define DELAY_FEEDBACK  0.88\n#define DELAY_TIME      0.153\n#define DELAY_STEREO    0.11\nvec2 mainSound(in int Samp,float time){\n    float l=steps/bpm,vol=1.,d=DELAY_WET,r=DELAY_TIME;\n    vec2 o=vec2(0);\n    if(time>sec-fade){vol=(sec-min(time,sec))/fade;}\n    time-=start*60./bpm;\n    if(time<0.)return o;\n    render(time,l,o,true);\n    float ff=0.,p=0.;\n    for(int i=0;i<DELAY_REPEAT;i++){\n        time-=r;\n        if(time<0.)continue;\n        vec2 a=vec2(0);\n        render(time,l,a,false);\n        d*=DELAY_FEEDBACK;\n        o+=a*d*vec2(1.+p*ff,1.-p*ff);\n        ff=ff<0.?1.:-1.;\n        p+=DELAY_STEREO;\n    }\n    return amp(o,vec3(MASTER_DRIVE,MASTER_PRESSURE,vol));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "\n#define BPM 135.\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}