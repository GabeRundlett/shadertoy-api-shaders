{
    "Shader": {
        "info": {
            "date": "1655035972",
            "description": "The three possible variations of the 3-mirror kaleidoscope - see code comments.\nBrightness is attenuated by the number of reflections.\nUse mouse to manually scroll the texture.",
            "flags": 0,
            "hasliked": 0,
            "id": "7dyyWm",
            "likes": 7,
            "name": "kaleidoscope variations",
            "published": 3,
            "tags": [
                "reflection",
                "interactive",
                "folding",
                "kaleidoscope",
                "tiling",
                "symmetry"
            ],
            "usePreview": 0,
            "username": "hnh",
            "viewed": 305
        },
        "renderpass": [
            {
                "code": "\n// The three possible variations of the 3-mirror kaleidoscope [1,2].\n// The image is composed by reflections of a base triangle, tiling the plane.\n// Here, I adopted the folding scheme [3,4] for the Euclidean plane whereas\n// in general it also works for the spherical and hyperbolic case. \n// A similar example with good comments is also found in [5]. \n// You may also try using the webcam in iChannel0\n// (don't forget setting Filter->mipmap and Wrap->repeat).\n// Note: lines marked by '//o' are comment-switchable (optional).\n// '//p' indicates parameters for manual tuning.\n// Shadertoy plugin: use R/L arrows to switch modes\n//\n// See also https://www.shadertoy.com/view/ssyyRG for a visualization of the folding scheme.\n//\n// [1] https://en.wikipedia.org/wiki/Kaleidoscope#Different_versions_suggested_by_Brewster\n// [2] https://en.wikipedia.org/wiki/Triangle_group\n// [3] mla, Wythoffian Tiling Generator, https://shadertoy.com/view/wlGSWc\n// [4] knighty, Tilings, https://www.shadertoy.com/view/4sf3zX\n// [5] TotallyReal, Euclidean triangle groups, https://www.shadertoy.com/view/7lV3Wy\n// [6] Artleet, The most compact hueshift, https://www.shadertoy.com/view/3tjGWm\n// [7] https://de.wikipedia.org/wiki/Datei:Kaleidoscope-abc.jpg\n\n#define PI 3.14159265\n#define R iResolution\n\n// The angles are defined by divisors of PI in each row (1st row: classical kaleidoscope, [1]).\n// In the Euclidean plane their inverses must sum to one.\nconst mat3 D = mat3(3,3,3,\n                    2,4,4,\n                    2,3,6);\n\nvec3 hs(vec3 c, float s) {  // hue shift [5]\n    vec3 m = vec3(cos(s), s=sin(s)*.5774, -s);\n    return c*mat3(m+=(1.-m.x)/3., m.zxy, m.yzx);\n}\n\n// Iterative folding/reflection adopted from [2,3] and streamlined for the Euclidean case.\n// The fold count (nf) can be useful, e.g. to attenuate reflections as in a real kaleidoscope [6].\nvec4 fold(vec2 p, float sc, vec3 ang, out int nf) {\n    vec3 c = cos(ang), s = sin(ang);\n    mat3 N = mat3(1, 0, .0,  //p .0 -> .1: show unit cells\n                 -c.x, s.x, 0,\n                 -c.z, -(c.y+c.x*c.z)/s.x, 1);  // normals\n    sc *= s.z;  // set longest edge to unit length\n    vec3 u, q = vec3(p,sc);\n    nf = 0;  // fold counter\n    for(int i=0; i<9999; i++) {\n        for(int j=0; j<3; j++) {\n            u[j] = dot(q, N[j]);\n            if(u[j] < 0.) {q -= 2.*u[j]*N[j]*vec3(1,1,0); nf++;}\n        }\n        if(i >= nf) break;  // central (proto-) triangle is reached\n    }\n    return vec4(q.xy, u.yz);  // q.xy: cartesian coords, u.xyz: trilinear coords, note that u.x = q.x\n}\n\n\nvoid mainImage(out vec4 O, vec2 U) {\n    float t = iTime*.1;\n    \n    int m = 0;  //p reflection mode (0,1,2)\n    m = int(t)%3;  //o cycle modes\n    //m = int(U.x*3./R.x);  //o simultaneous view\n        \n    float sc = 10., a = .8, b = R.y*.075;  //p scale, bounce interval\n    sc = sqrt(b*a)*pow(b/a, .5*cos(2.*PI*t));  //o bouncing zoom\n            \n    U = sc*(U*2. - R.xy)/R.y;\n    \n    int nf;\n    O = fold(U, 1., PI/D[m], nf);\n    U = O.xy;\n    vec3 u = O.xzw;\n    \n    if(iMouse.z>0.) U -= (iMouse.xy*2.-R.xy)/R.y; else U -= t; //o scrolling\n    //U += vec2(nf)*.01;  //o reflection shift\n    O = texture(iChannel0,U);\n    O.rgb = hs((O.bgr-.35)*3., PI*(1.-.5*float(m)));  //o color modes\n    \n    //O = u.xyzz;  //o RGB = trilinear coordinates\n    //O = vec4(.75);  //o blank background\n\n    O *= exp(-float(nf)/sc*.5)*1.5;  //o attenuate reflections\n    //O *= .5 + .5*float(nf%2);  //o 'checkerboard'\n    O *= smoothstep(-1.,1.,(min(u.x,min(u.y,u.z))-.01)*R.y/(sc*2.));  //o edges\n    \n    O.a= 1.;  // who knows...\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}