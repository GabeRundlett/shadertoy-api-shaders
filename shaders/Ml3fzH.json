{
    "Shader": {
        "info": {
            "date": "1538603964",
            "description": "Coded live on twitch stream in Bonzomatic, and tidied/ported to shadertoy.\nUnedited Bonzomatic shader here: [url]https://gist.github.com/willkirkby/b2f315e2e0ae582127a6d04843835d5e[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "Ml3fzH",
            "likes": 16,
            "name": "[twitch] Datamatics Dot Plotter",
            "published": 3,
            "tags": [
                "twitch",
                "ryojiikeda"
            ],
            "usePreview": 0,
            "username": "yx",
            "viewed": 887
        },
        "renderpass": [
            {
                "code": "const float FONT_SCALE = 2.;\nconst float POINT_SIZE = 1.5;\nconst float LINE_SIZE = 1.;\nconst float FOV = 2.;\nconst int NUM_POINTS = 128;\nconst float SPEED = 1.;\n\nfloat noise(float a)\n{\n  return fract(sin(a)*43758.5453123);\n}\n\nvec2 rotate(vec2 a, float b)\n{\n  float c = cos(b);\n  float s = sin(b);\n  return vec2(\n    a.x * c - a.y * s,\n    a.x * s + a.y * c\n  );\n}\n\nvoid spin(inout vec3 p)\n{\n  p.yz = rotate(p.yz, cos(iTime*.01)*.15+.1);  // tweaked for shadertoy\n  p.xz = rotate(p.xz, iTime * .1);\n}\n\nmat4 projMtx()\n{\n  float aspect = iResolution.x / iResolution.y;\n  float nearz = 0.1;\n  float farz = 100.;\n  return mat4(\n    1./(aspect*tan(FOV/2.)), 0,0,0,\n    0,-1./tan(FOV/2.),0,0,\n    0,0,(-nearz-farz)/(nearz-farz),(2.*farz*nearz)/(nearz-farz),\n    0,0,1,0\n  );\n}\n\nvec3 cameraPos()\n{\n  vec3 pos = vec3(0,0,-2.);\n  spin(pos);\n  return pos;\n}\n\nvec3 rayDir()\n{\n  vec2 uv = (gl_FragCoord.xy/iResolution.xy)-.5;\n  uv.x *= iResolution.x / iResolution.y;\n  uv *= 2.;\n\n  vec3 dir = normalize(vec3(\n    uv,(4.8/tan(FOV/2.)) // where's the 4.8 from?!??!?!?!?!\n  ));\n  spin(dir);\n  return dir;\n}\n\nmat4 cameraMtx()\n{\n  vec3 pos = cameraPos();\n  vec3 dir = vec3(0,0,1);\n\n  spin(dir);\n\n  vec3 up = vec3(0,1,0);\n  vec3 right = cross(dir, up);\n  up = cross(right, dir);\n  mat4 orientation = mat4(\n    right.x, up.x, dir.x, 0,\n    right.y, up.y, dir.y, 0,\n    right.z, up.z, dir.z, 0,\n    0,0,0,1\n  );\n  mat4 translation = mat4(\n    1,0,0,0,\n    0,1,0,0,\n    0,0,1,0,\n    -pos.x, -pos.y, -pos.z, 1\n  );\n  return orientation * translation;\n}\n\nvec2 project(vec3 p3, mat4 mtx)\n{\n  vec4 p = mtx * vec4(p3,1);\n  p /= p.w;\n  return (p.xy*.5+.5)*iResolution.xy;\n}\n\nvoid drawLine2D(inout vec4 fragColor, vec2 a, vec2 b, vec4 color)\n{\n  a-=.5;\n  b-=.5;\n  vec2 midpoint = (a+b)*.5;\n  float radius = distance(a,b)*.5;\n  vec2 normal = normalize((b-a).yx*vec2(-1,1));\n  float d = dot(normal, gl_FragCoord.xy-midpoint);\n  fragColor += (clamp(LINE_SIZE-abs(d),0.,1.) * smoothstep(radius+.5,radius-.5,distance(gl_FragCoord.xy,midpoint))) * color;\n}\n\nvoid drawLine3D(inout vec4 fragColor, vec3 a, vec3 b, vec4 color, mat4 mtx)\n{\n  vec2 pa = project(a, mtx);\n  vec2 pb = project(b, mtx);\n  drawLine2D(fragColor, pa, pb, color);\n}\n\nvoid drawPoint2D(inout vec4 fragColor, vec2 a, vec4 color)\n{\n  a-=.5;\n  float d = distance(a,gl_FragCoord.xy);\n  fragColor += smoothstep(POINT_SIZE,POINT_SIZE-1.,d) * color;\n}\n\nvoid drawPoint3D(inout vec4 fragColor, vec3 a, vec4 color, mat4 mtx)\n{\n  drawPoint2D(fragColor,project(a,mtx),color);\n}\n\nvoid drawCrosshair3D(inout vec4 fragColor, vec3 a, vec4 color, mat4 mtx)\n{\n  vec2 o = vec2(.007, 0);\n  drawLine3D(fragColor, a+o.xyy, a-o.xyy, color, mtx);\n  drawLine3D(fragColor, a+o.yxy, a-o.yxy, color, mtx);\n  drawLine3D(fragColor, a+o.yyx, a-o.yyx, color, mtx);\n}\n\nvoid drawDotGrid3D(inout vec4 fragColor, float y, vec4 color)\n{\n  vec3 camPos = cameraPos();\n  vec3 rayDir = rayDir();\n\n  float distGrid = (camPos.y - y) / -rayDir.y;\n  vec3 hitGrid = abs(camPos + rayDir * distGrid);\n\n  if (hitGrid.x <= 1. && hitGrid.z <= 1.)\n  {\n    vec2 gridUv = fract(hitGrid.xz * 16.);\n    float dotSize = distGrid*.07; //length(dFdy(hitGrid.xz * 16.)) * 2.;\n    fragColor += smoothstep(dotSize,0.,length(gridUv-.5)) * color;\n  }\n}\n\nvoid drawBarcodeGrid3D(inout vec4 fragColor, float y)\n{\n  vec3 camPos = cameraPos();\n  vec3 rayDir = rayDir();\n\n  float distGrid = (camPos.y - y) / -rayDir.y;\n  vec3 hitGrid = camPos + rayDir * distGrid;\n  vec2 absHitGrid = abs(hitGrid.xz);\n\n  if (absHitGrid.x <= 1. && absHitGrid.y <= 1.)\n  {\n    vec2 gridUv = hitGrid.xz*.5+.5;\n    float speed = .3;\n    gridUv.x += iTime*speed;\n    float mask = 1.-step(1./32.,mod(gridUv.x,4.));\n    float barcode = step(.5, fract(iTime*2.+noise(floor(gridUv.y * 256.)+.1*floor(gridUv.x*64.))));\n    fragColor += mask * barcode * .5;\n  }\n}\n\nvec3 starPosition(int i)\n{\n  float f = float(i);\n  vec3 p = vec3(\n    noise(f),\n    1.-float(i)/float(NUM_POINTS),//noise(f+.1),  // tweaked for shadertoy\n    noise(f+.2)\n  );\n  p=p*2.-1.;\n  p/=sqrt(3.);\n  p*=pow(length(p), 2.3);\n  return clamp(p*1.2,-1.,1.);\n}\n\nvoid textWriter(inout vec4 fragColor, ivec2 p, int digit)\n{\n  p--;\n  int[10]font=int[10](\n    0x75557,\n    0x23227,\n    0x74717,\n    0x74747,\n    0x55744,\n    0x71747,\n    0x71757,\n    0x74444,\n    0x75757,\n    0x75747\n  );\n  if (p.x<0||p.y<0||p.x>=3||p.y>=5) return;\n  fragColor += float((font[digit]>>(p.x+p.y*4))&1);\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  out_color = vec4(0);\n\n  mat4 mtx = projMtx() * cameraMtx();\n  float time = iTime * SPEED;\n\n  int currentPointIdx = int(floor(time)) % NUM_POINTS;\n  int nextPointIdx = (currentPointIdx+1) % NUM_POINTS;\n  float timeBetweenPoints = fract(time);\n\n  vec3 currentPoint = starPosition(currentPointIdx);\n  vec3 nextPoint = starPosition(nextPointIdx);\n  vec3 lerpPoint = mix(currentPoint, nextPoint, timeBetweenPoints < .5 ? 0. : timeBetweenPoints*2.-1.);\n\n  for(int i=0;i<NUM_POINTS;++i)\n  {\n    drawCrosshair3D(out_color, starPosition(i), i <= currentPointIdx ? vec4(1,0,0,1) : vec4(1), mtx);\n  }\n\n  drawLine3D(out_color, vec3(lerpPoint.x,lerpPoint.y,-1), vec3(lerpPoint.x,lerpPoint.y,1), vec4(1), mtx);\n  drawLine3D(out_color, vec3(-1,lerpPoint.y,lerpPoint.z), vec3(1,lerpPoint.y,lerpPoint.z), vec4(1), mtx);\n  drawLine3D(out_color, vec3(-1,lerpPoint.y,-1), vec3(1,lerpPoint.y,-1), vec4(1), mtx);\n  drawLine3D(out_color, vec3(1,lerpPoint.y,-1), vec3(1,lerpPoint.y,1), vec4(1), mtx);\n  drawLine3D(out_color, vec3(1,lerpPoint.y,1), vec3(-1,lerpPoint.y,1), vec4(1), mtx);\n  drawLine3D(out_color, vec3(-1,lerpPoint.y,1), vec3(-1,lerpPoint.y,-1), vec4(1), mtx);\n  if (timeBetweenPoints < .5)\n  {\n    drawLine3D(out_color, lerpPoint, vec3(lerpPoint.x, 0, lerpPoint.z), vec4(1), mtx);\n    vec2 screenPoint = project(lerpPoint, mtx);\n    for(int x=0;x<7;++x)\n      textWriter(out_color, ivec2((gl_FragCoord.xy-4.-screenPoint)/FONT_SCALE-vec2(x*4,0)), int(noise(float(x+7*currentPointIdx))*10.));\n  }\n\n  float gridHeight = (1. - fract(time / 8.) * 2.);\n  drawDotGrid3D(out_color, gridHeight, vec4(1.-abs(gridHeight)) * .5);\n  if (gridHeight < 0.)\n    drawDotGrid3D(out_color, 0., vec4(1.+gridHeight) * .5);\n\n  drawBarcodeGrid3D(out_color, lerpPoint.y);\n\n  out_color = clamp(out_color, 0., 1.);\n  out_color = pow(out_color, vec4(1.3,1.15,1,1));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}