{
    "Shader": {
        "info": {
            "date": "1496765571",
            "description": "This is another proof-of-concept (read: I couldn't be bothered to make it look good) where I modified my previous voxel shader to animate the voxels.",
            "flags": 0,
            "hasliked": 0,
            "id": "XsffzS",
            "likes": 12,
            "name": "Cube Tracing with Animated Voxel",
            "published": 3,
            "tags": [
                "raytracing",
                "voxel",
                "animated"
            ],
            "usePreview": 0,
            "username": "culdevu",
            "viewed": 853
        },
        "renderpass": [
            {
                "code": "/* \n    Author: Daniel Taylor\n\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\tI got the cool idea the other day. Instead of voxel tracing animated models, why don't\n\tI try animated the actual voxels instead!\n\n\tThis is slow, unfortunately. It can be made a lot faster by ensuring that the camera\n\tis always at the origin. This code doesn't assume that, though.\n\n\tAlso, the AO is made by the same broken system as my last one: \n\t\thttps://www.shadertoy.com/view/XssfDN\n\tIt looks terrible, though. Don't use it. The same effect could easily be accomplished\n\tby the old SDF method, and it would look a lot nicer.\n\n\tAlso note this is almost a direct copy-and-paste of my truncated-octohedron tracer. The\n\timportant changes are highlighted with exclamation marks (!!!!). Honestly, not much has\n\tchanged. Mostly just stability-related things.\n*/\n\n#define PI 3.14159\n \n// Plane-Ray intersection\nfloat fp(vec3 p, vec3 r, vec3 n)\n{\n    if (abs(dot(n, r)) < 0.001)\n        return 10000.;\n    return dot(n, p) / dot(n, r);\n}\n\n// Ulities\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nfloat sgn(int a)\n{\n    return (a > 0) ? 1. : -1.;\n}\nfloat sgn(float a)\n{\n    return (a > 0.) ? 1. : -1.;\n}\nint isgn(int a)\n{\n    return int(sgn(a));\n}\nvoid round1(inout vec3 r)\n{\n    r.xyz = floor(r.xyz + 0.5);\n}\n\n// Determines which cells are solid based on their centers\nbool isSolid(vec3 center)\n{\n    if (center.y <= 0.)\n        return true;\n    if (length(center) < 8.)\n        return true;\n    if (abs(center.z) < 2. && abs(length(center.xy) - 20.) < 5.)\n        return true;\n    \n    return false;\n}\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c          );\n}\n#define rotMat rotationMatrix(normalize(vec3(1,1,1)), iTime/1.5)\n\n//---------------------------------------------------\n// Intersection and tracing code\n//---------------------------------------------------\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// Inspired by dr2's take on the truncated octohedron code:\n// (https://www.shadertoy.com/view/MdffRS)\nvec3 Fv(int i)\n{\n    vec3 r = vec3(1,0,0);\n    if (i == 1)\n        r = vec3(0,1,0);\n    if (i == 2)\n        r = vec3(0,0,1);\n    return rotMat * r;\n}\n\n// This just tests against a bunch of planes\nfloat truncOctInner(vec3 p, vec3 ray, out int best_norm)\n{\n    float best_d = 1000.0;\n    best_norm = -1;\n    \n    vec3 offset, n;\n    float d;\n    \n    for (int i = 0; i < 3; ++i)\n    {\n        offset = Fv(i);\n        n = normalize(offset);\n        d = fp(p + offset, ray, n);\n        if (d < best_d && dot(n, ray) > 0.)\n        {\n            best_d = d;\n            best_norm = i + 1;\n        }\n        \n        offset = -offset;\n        n = normalize(offset);\n        d = fp(p + offset, ray, n);\n        if (d < best_d && dot(n, ray) > 0.)\n        {\n            best_d = d;\n            best_norm = -i - 1;\n        }\n    }\n    \n    return best_d;\n}\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// This is the worst possible way to do this, but I can't\n// think of any other (remotely easy) way.\n// This is also a large part of why the shader is slow. If you\n// can fix this, you can speed the entire thing up.\nvec3 findCenter(vec3 o)\n{\n    vec3 center = vec3(0);\n    float L = length(o);\n    vec3 ray = normalize(o);\n    o = vec3(0);\n\n    float d = 0.;\n    int normId;\n    \n    // keeps track of the total distance traveled\n    float totalD = 0.;\n    \n    for (int i = 0; i < 30; ++i)\n    {\n        d = truncOctInner(center - o, ray, normId);\n        o = o + ray * d;\n        \n        totalD += d;\n        \n        if (totalD > L)\n        {\n            return center;\n        }\n        \n        center += float(sign(normId)) * 2. * Fv( abs(normId - sign(normId)) );\n    }\n    \n    return vec3(0,0,0);\n}\n\n// This is just cube marching\nfloat traceTruncOct(vec3 o, vec3 ray, out vec3 norm, out vec3 center, int depth)\n{\n    center = findCenter(o);\n    \n    norm = vec3(0);\n    float d = 0.;\n    vec3 p = center - o;\n    \n    int normId;\n    \n    // keeps track of the total distance traveled\n    float totalD = 0.;\n    \n    for (int i = 0; i < depth; ++i)\n    {\n        d = truncOctInner(p, ray, normId);\n        o = o + ray * d;\n        center += float(sign(normId)) * 2. * Fv( abs(normId - sign(normId)) );\n        p = center - o;\n        \n        totalD += d;\n        \n        if (isSolid(center))\n        {\n            norm = -float(sign(normId)) * normalize(Fv( abs(normId - sign(normId)) ));\n            return totalD;\n        }\n    }\n    \n    return -1.;\n}\n\nfloat aoDist(vec3 o, vec3 center, vec3 norm)\n{\n    vec3 trash;\n    o += norm / 5.;\n    \n    float best = 0.;\n    vec3 r;\n    \n    for (int i = 0; i < 3; ++i)\n    {\n        // these two lines are equivalent to:\n        //   vec3 p = Fv(i)\n        //   vec3 q = p;\n        // for cubes. This form is for truncated octohedrons.\n        // I'm not sure if this generalizes to any other space-filling\n        // polyhedra or not.\n        //\n        // Either way, it looks horrible. Don't do this.\n        vec3 p = normalize(Fv(i));\n        vec3 q = p - norm * dot(norm, p);\n        \n        if (dot(o - center, q) > best && dot(norm, p) < 0.95)\n        {\n            r = q;\n            best = dot(o - center, q);\n        }\n        \n        q = -q;\n        if (dot(o - center, q) > best && dot(norm, p) < 0.95)\n        {\n            r = q;\n            best = dot(o - center, q);\n        }\n    }\n    \n    return traceTruncOct(o, normalize(r), trash, trash, 1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y - vec2(iResolution.x/iResolution.y/2., 0.5);\n    float mouseU = 2. * (iMouse.x / iResolution.x - 0.5);\n    vec3 trash;\n    \n    vec3 cam = vec3(0,8,30.);\n    vec3 screenPos = vec3(uv, -0.5);\n    \n    pR(cam.xz, mouseU * 2. * PI);\n    pR(screenPos.xz, mouseU * 2. * PI);\n    \n    vec3 ray = normalize(screenPos);\n    \n    vec3 norm, center;\n    float d = traceTruncOct(cam, ray, norm, center, 80);\n    vec3 pt = cam + ray*d;\n    \n    if (d < 0.)\n    {\n        fragColor = vec4(uv.y);\n        return;\n    }\n    \n    //--------------------------------------------------\n    // Lighting Time!\n    //--------------------------------------------------\n    float ambient = 0.1;\n    float ao = aoDist(pt, center, norm);\n    if (ao < 0.)\n        ao = 5.0;\n    if (ao/5. < 0.1)\n        ambient = ao/5.;\n    \n    // Lighting\n    vec3 light = 10. * vec3(1,1,1);\n    vec3 lightDir = d*ray + cam - light;\n    float lightIntensity = 10.0;\n    \n    // These shadows look really ugly.\n    // I'm not all that knowledged about how cube marching people do shadows,\n    // but it's probably *not* something like this... oh well.\n    // If you have any suggestions, please tell me!\n    float lightDist = traceTruncOct(light, normalize(lightDir), trash, trash, 40);\n    float shadow = 0.;\n    if (abs(lightDist - length(lightDir)) < 0.2)\n        shadow = 1.;\n    \n    // Yeah, that's right, I used linear falloff. Sue me.\n    fragColor = shadow * lightIntensity * vec4(max(0., dot(norm, -normalize(lightDir)) )) / length(lightDir);\n    fragColor += vec4(ambient);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}