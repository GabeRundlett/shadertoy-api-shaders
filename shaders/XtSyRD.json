{
    "Shader": {
        "info": {
            "date": "1507644629",
            "description": "An intersectable primitive that defines a quadratic surface as a barycentric interpolation of bezier weights along a tetrahedron. This demo stitches three primitives together and blends between different weights.",
            "flags": 0,
            "hasliked": 0,
            "id": "XtSyRD",
            "likes": 59,
            "name": "iSimplexPrim",
            "published": 3,
            "tags": [
                "ray",
                "quadric",
                "bezier",
                "intersection",
                "simplex",
                "cone",
                "tetrahedron",
                "ellipsoid",
                "cylinder",
                "prim"
            ],
            "usePreview": 0,
            "username": "paniq",
            "viewed": 2958
        },
        "renderpass": [
            {
                "code": "\n// uncomment to solve for quadratic surface only\n#define HIT_TET_PLANES\n\nvoid compute_edges(vec3 p[4], out vec3 e[6]) {\n    e[0] = p[2] - p[1];\n    e[1] = p[0] - p[2];\n    e[2] = p[1] - p[0];\n    e[3] = p[1] - p[3];\n    e[4] = p[2] - p[3];\n    e[5] = p[0] - p[3];\n}\n\nvoid compute_planes(vec3 p[4], out vec3 n[3]) {\n    vec3 e[6];\n    compute_edges(p, e);\n    n[0] = cross(e[0], e[3]);\n    n[1] = cross(e[1], e[4]);\n    n[2] = cross(e[2], e[5]);\n    float det = 1.0/dot(n[0], e[1]);\n    // premultiply the plane orthogonals by the inverse determinant\n    n[0] *= det;\n    n[1] *= det;\n    n[2] *= det;\n}\n\n// computes barycentric coordinates for point from the fourth vertex,\n// three plane normals with premultiplied inverse determinant\nvec4 to_bary(vec3 p3, vec3 n[3], vec3 t) {\n    // weights are scaled distance of point to individual planes\n    t -= p3;\n    float w0 = dot(t, n[0]); \n    float w1 = dot(t, n[1]); \n    float w2 = dot(t, n[2]); \n    float w3 = 1.0 - w0 - w1 - w2;\n    return vec4(w0, w1, w2, w3);\n}\n\nvec3 from_bary(vec3 p[4], vec4 w) {\n\treturn p[0] * w.x + p[1] * w.y + p[2] * w.z + p[3] * w.w;\n}\n\nvec3 normal_from_bary(vec3 n[3], vec4 w) {\n    return normalize(n[0] * (w.w - w.x) + n[1] * (w.w - w.y) + n[2] * (w.w - w.z));\n}\n\n// evaluate quadratic in tetrahedron with given corners and midweights\n// first set of weights are the weights on face xyz opposite of each vertex\n// second set of weights are on edges xyz-w\nfloat eval_quadratic(vec4 w, vec4 c, vec3 m1, vec3 m2) {\n    return w.x*w.x*c.x + w.y*w.y*c.y + w.z*w.z*c.z + w.w*w.w*c.w\n        + 2.0*(m1.x*w.y*w.z + m1.y*w.x*w.z + m1.z*w.x*w.y\n             + m2.x*w.w*w.x + m2.y*w.w*w.y + m2.z*w.w*w.z);\n}\n\n// return first derivative at given point in barycentric basis\nvec4 eval_quadratic_diff(vec4 w, vec4 c, vec3 m1, vec3 m2) {\n    return 2.0*vec4(\n    m2.x*w.w + c.x*w.x + m1.z*w.y + m1.y*w.z,\n    m2.y*w.w + m1.z*w.x + c.y*w.y + m1.x*w.z,\n    m2.z*w.w + m1.y*w.x + m1.x*w.y + c.z*w.z,\n    c.w*w.w + m2.x*w.x + m2.y*w.y + m2.z*w.z\n\t);\n}\n\nstruct Hit {\n    // ray scalar\n    float t;\n    // barycenter\n    vec4 b;\n    // normal\n    vec3 n;\n};\n\n// return normal of nearest plane in barycentric coordinates\nvec4 select_plane_normal(vec4 b) {\n    float lc = min(min(b.x, b.y), min(b.z, b.w));\n    return step(b, vec4(lc));\n}\n\n// return the intersection of ray, tetrahedron and a quadratic function\n// with the corner weights c and the edge weights m1 and m2\n// as well as the barycentric coordinates and normals of the hit points\nbool iSimplexPrim(vec3 p[4], \n\tvec4 c, vec3 m1, vec3 m2, \n\tvec3 ro, vec3 rd, \n\tout Hit near, out Hit far) {\n    \n    vec3 sn[3];\n    compute_planes(p, sn);\n    \n    // convert ray endpoints to barycentric basis\n    // this can be optimized further by caching the determinant\n    vec4 r0 = to_bary(p[3], sn, ro);\n    vec4 r1 = to_bary(p[3], sn, ro + rd);\n\n    // build barycentric ray direction from endpoints\n    vec4 brd = r1 - r0;\n    // compute ray scalars for each plane\n    vec4 t = -r0/brd;\n    \n    // valid since GL 4.1\n    near.t = -1.0 / 0.0;\n    far.t = 1.0 / 0.0;    \n#if 0\n    for (int i = 0; i < 4; ++i) {\n        // equivalent to checking dot product of ray dir and plane normal\n        if (brd[i] < 0.0) {\n            far.t = min(far.t, t[i]);\n        } else {\n            near.t = max(near.t, t[i]);\n        }\n    }\n#else\n    // loopless, branchless alternative\n    // equivalent to checking dot product of ray dir and plane normal    \n    bvec4 comp = lessThan(brd, vec4(0.0));\n    vec4 far4 = mix(vec4(far.t), t, comp);\n    vec4 near4 = mix(t, vec4(near.t), comp);\n    far.t = min(min(far4.x,far4.y),min(far4.z,far4.w));\n    near.t = max(max(near4.x,near4.y),max(near4.z,near4.w));\n#endif\n    \n    if ((far.t <= 0.0) || (far.t <= near.t))\n        return false;\n    near.b = r0 + brd * near.t;\n    far.b = r0 + brd * far.t;\n\n#ifdef HIT_TET_PLANES\n    vec4 n0 = select_plane_normal(near.b);\n    vec4 n1 = select_plane_normal(far.b);\n#else\n    vec4 n0;\n    vec4 n1;\n#endif\n        \n#if 1\n    // reconstruct 1D quadratic coefficients from three samples\n    float c0 = eval_quadratic(near.b, c, m1, m2);\n    float c1 = eval_quadratic(r0 + brd * (near.t + far.t) * 0.5, c, m1, m2);\n    float c2 = eval_quadratic(far.b, c, m1, m2);\n\n    float A = 2.0*(c2 + c0 - 2.0*c1);\n    float B = 4.0*c1 - 3.0*c0 - c2;\n    float C = c0;\n    \n    if (A == 0.0) return false;\n    // solve quadratic\n    float k = B*B - 4.0*A*C;\n    if (k < 0.0)\n        return false;\n    k = sqrt(k);\n    float d0 = (-B - k) / (2.0*A);\n    float d1 = (-B + k) / (2.0*A);\n    \n    //if (min(B,C) > 0.0) return false;\n    \n    if (d0 > 1.0) return false;\n    // for a conic surface, d1 can be smaller than d0\n    if ((d1 <= d0)||(d1 > 1.0))\n        d1 = 1.0;\n    else if (d1 < 0.0) return false;\n    if (d0 > 0.0) {\n        near.t = near.t + (far.t - near.t)*d0;\n    }\n    far.t = near.t + (far.t - near.t)*d1;\n    near.b = r0 + brd * near.t;\n    far.b = r0 + brd * far.t;\n#ifdef HIT_TET_PLANES\n    if ((d0 > 0.0) && (d0 < 1.0)) {\n        n0 = -eval_quadratic_diff(near.b, c, m1, m2);\n    }\n    if ((d1 > 0.0) && (d1 < 1.0)) {\n        n1 = -eval_quadratic_diff(far.b, c, m1, m2);\n    }\n#else\n    if ((d0 > 0.0) && (d0 < 1.0)) {\n        n0 = -eval_quadratic_diff(near.b, c, m1, m2);\n    } else if ((d1 > 0.0) && (d1 < 1.0)) {\n        n0 = eval_quadratic_diff(far.b, c, m1, m2);\n    }  else {\n        return false;\n    }\n#endif\n    \n#else\n#endif\n    near.n = normal_from_bary(sn, n0);\n    far.n = normal_from_bary(sn, n1);\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////\n\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = iTime * 0.5;\n    float d = 3.0;\n\tcamPos = vec3(d*sin(an),mix(-0.8,2.0,sin(iTime*0.25)*0.5+0.5),d*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\nfloat imTestSphere(vec3 p) {\n    float r = 0.5;\n    return p.x*p.x + p.y*p.y + p.z*p.z - r*r;\n}\n\nfloat imTestCylinder(vec3 p) {\n    float r = 0.5;\n    return p.x*p.x + p.y*p.y - r*r;\n}\n\nfloat imTestCone(vec3 p) {\n    p.z = (p.z - 1.0)*0.5;\n    float r = 0.5;\n    return (p.x*p.x + p.y*p.y)/(r * r) - p.z*p.z;\n}\n\nfloat imSolid(vec3 p) {\n    float r = 1.0;\n    return p.x*p.x + p.y*p.y - r*r;\n}\n\n#define SHAPE_COUNT 5.0\nvoid getfactor (int i, out float c[6], out float m[12]) {\n    // reference coordinates\n    vec3 p[6];\n    p[0] = vec3(cos(radians(0.0)),sin(radians(0.0)),-1.0);\n    p[1] = vec3(cos(radians(120.0)),sin(radians(120.0)),-1.0);\n    p[2] = vec3(cos(radians(240.0)),sin(radians(240.0)),-1.0);\n    p[3] = vec3(cos(radians(0.0)),sin(radians(0.0)), 1.0);\n    p[4] = vec3(cos(radians(240.0)),sin(radians(240.0)), 1.0);\n    p[5] = vec3(cos(radians(120.0)),sin(radians(120.0)), 1.0);\n\n#define DEF_C(F) for (int i = 0; i < 6; ++i) { c[i] = F(p[i]); }\n#define DEF_M(I, F, V1, V2) m[I] = F((p[V1]+p[V2])*0.5)*2.0 - (c[V1]+c[V2])*0.5\n#define DEF_M0(F) DEF_M(0, F, 1, 2); DEF_M(1, F, 2, 0); DEF_M(2, F, 1, 0);\n#define DEF_M1(F) DEF_M(3, F, 4, 5); DEF_M(4, F, 5, 3); DEF_M(5, F, 4, 3);\n#define DEF_M2(F) DEF_M(6, F, 3, 0); DEF_M(7, F, 2, 3); DEF_M(8, F, 2, 4);\n#define DEF_M3(F) DEF_M(9, F, 4, 1); DEF_M(10, F, 5, 1); DEF_M(11, F, 1, 3);\n#define DEF_F(F) DEF_C(F); DEF_M0(F); DEF_M1(F); DEF_M2(F); DEF_M3(F);\n    \n    if (i == 0) {\n        DEF_F(imTestSphere);\n    } else if (i == 1) {\n        DEF_F(imTestCylinder);\n    } else if (i == 2) {\n        DEF_F(imTestCone);\n    } else if (i == 3) {\n        DEF_F(imSolid);\n    } else if (i == 4) {\n        for (int i = 0; i < 6; ++i) {\n            c[i] = 2.0;\n        }\n        for (int i = 0; i < 12; ++i) {\n            m[i] = -1.0;\n        }        \n    }\n}\n\nvoid anim_coeffs(out float c[6], out float m[12]) {\n    float k = iTime*0.5;\n    float u = smoothstep(0.0,1.0,smoothstep(0.0,1.0,fract(k)));\n    int s1 = int(mod(k,SHAPE_COUNT));\n    int s2 = int(mod(k+1.0,SHAPE_COUNT));\n    float c1[6];\n    float c2[6];\n    float m1[12];\n    float m2[12];\n    getfactor(s1, c1, m1);\n    getfactor(s2, c2, m2);\n    for (int i = 0; i < 6; ++i) {\n        c[i] = mix(c1[i],c2[i],u);\n    }\n    for (int i = 0; i < 12; ++i) {\n        m[i] = mix(m1[i],m2[i],u);\n    }\n}\n\nvec2 rotate_xy(vec2 p, float a) {\n    vec2 o;\n    float s = sin(a); float c = cos(a);\n    o.x = c*p.x + s*p.y;\n    o.y = -s*p.x + c*p.y;\n    return o;\n}\n\nvoid anim_split(inout vec3 p[4]) {\n#if 0\n    vec3 c = (p[0]+p[1]+p[2]+p[3])/4.0;\n    float s = mix(1.0, 0.8, clamp(pow(sin(iTime*0.1),16.0),0.0,1.0));\n    for (int i = 0; i < 4; ++i) {\n\t    p[i] = c + (p[i] - c)*s;\n    }\n#endif\n}\n\nbool anim_prism( in vec3 ro, in vec3 rd, out Hit h0, out Hit h1) {\n    // prism vertices\n    vec3 p[6];\n    p[0] = vec3(cos(radians(0.0)),sin(radians(0.0)),-1.0);\n    p[1] = vec3(cos(radians(120.0)),sin(radians(120.0)),-1.0);\n    p[2] = vec3(cos(radians(240.0)),sin(radians(240.0)),-1.0);\n    p[3] = vec3(cos(radians(0.0)),sin(radians(0.0)), 1.0);\n    p[4] = vec3(cos(radians(240.0)),sin(radians(240.0)), 1.0);\n    p[5] = vec3(cos(radians(120.0)),sin(radians(120.0)), 1.0);\n    for (int i = 3; i < 6; ++i) {\n        vec3 v = p[i];\n        v.xz = rotate_xy(v.xz, sin(iTime * 10.0)*sin(iTime)*0.1);\n        v.z += mix(-1.5, 0.0, sin(iTime * 0.2)*0.5+0.5);\n        p[i] = v;\n        \n    }\n    float c[6];\n    c[0] = 2.0; c[1] = 2.0; c[2] = 2.0;\n    c[3] = 2.0; c[4] = 2.0; c[5] = 2.0;\n    float m[12];\n    m[0] = -1.0; m[ 1] = -1.0; m[ 2] = -1.0;\n    m[3] = -1.0; m[ 4] = -1.0; m[ 5] = -1.0;\n    m[6] = -1.0; m[ 7] = -1.0; m[ 8] = -1.0;\n    m[9] = -1.0; m[10] = -1.0; m[11] = -1.0;\n\n    anim_coeffs(c, m);\n    \n    vec4 qc; vec3 qm1, qm2;\n    \n    vec3 q[4];\n    Hit near; Hit far;\n    h0.t = 1.0/0.0;\n\th1.t = -1.0/0.0;\n    q[0] = p[0]; q[1] = p[1]; q[2] = p[2]; q[3] = p[3];\n    anim_split(q);\n    qc = vec4(c[0], c[1], c[2], c[3]);\n    qm1 = vec3(m[0], m[1], m[2]); qm2 = vec3(m[6], m[11], m[7]);\n    bool hit = false;\n    if (iSimplexPrim(q, qc, qm1, qm2, ro, rd, near, far)) {\n        if (near.t < h0.t)\n            h0 = near;\n        if (far.t > h1.t)\n            h1 = far;\n        hit = true;\n    }\n    q[0] = p[1]; q[1] = p[2]; q[2] = p[3]; q[3] = p[4];\n    anim_split(q);\n    qc = vec4(c[1], c[2], c[3], c[4]);\n    qm1 = vec3(m[7], m[11], m[0]); qm2 = vec3(m[9], m[8], m[5]);\n    if (iSimplexPrim(q, qc, qm1, qm2, ro, rd, near, far)) {\n        if (near.t < h0.t)\n            h0 = near;\n        if (far.t > h1.t)\n            h1 = far;\n        hit = true;\n    }\n    q[0] = p[3]; q[1] = p[4]; q[2] = p[5]; q[3] = p[1];\n    anim_split(q);\n    qc = vec4(c[3], c[4], c[5], c[1]);\n    qm1 = vec3(m[3], m[4], m[5]); qm2 = vec3(m[11], m[9], m[10]);\n    if (iSimplexPrim(q, qc, qm1, qm2, ro, rd, near, far)) {\n        if (near.t < h0.t)\n            h0 = near;\n        if (far.t > h1.t)\n            h1 = far;\n        hit = true;\n    }    \n    return hit;\n}\n\nvec3 calc_intersection( in vec3 ro, in vec3 rd ) {\n    ro = ro.zxy;\n    rd = rd.zxy;    \n    vec3 l = normalize(vec3(1.0, -1.0, -2.0));\n    \n    vec3 col = vec3(0.0);\n    \n    Hit h0, h1;\n    if (anim_prism(ro, rd, h0, h1)) {\n        vec4 c = (h0.t > 0.0)?h0.b:h1.b;\n        \n        float lit = max(0.0, dot(l, -h0.n));\n        \n        lit += 0.1;\n        \n#if 1\n        col += lit * vec3(0.1, 0.5, 1.0);\n#else\n        col += lit * (\n              c.x * vec3(1.0, 0.0, 0.0)\n        \t+ c.y * vec3(0.0, 1.0, 0.0)\n            + c.z * vec3(0.0, 0.0, 1.0)\n            + c.w * vec3(1.0, 1.0, 1.0));\n#endif\n        col += lit * pow(max(0.0, dot(-l, reflect(rd, h0.n)) - 0.1), 25.0)*1e-7;\n    } else {\n        float plane_t = -(ro.z + 1.0) / rd.z;\n        if (plane_t > 0.0) {\n            vec3 plane_p = ro + rd * plane_t;\n\n            float sh = anim_prism(plane_p, -l, h0, h1)?0.3:1.0;\n            col += vec3(sh) * abs(rd.z);\n        }\n    }    \n    return col;\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, 0.0 );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = ( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    col = calc_intersection( ro, rd );\n\t   \n    fragColor = vec4( sqrt(col), 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}