{
    "Shader": {
        "info": {
            "date": "1692982612",
            "description": "poto",
            "flags": 32,
            "hasliked": 0,
            "id": "clsfD4",
            "likes": 16,
            "name": "Day 1345",
            "published": 3,
            "tags": [
                "pathtracing",
                "monochrome",
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 399
        },
        "renderpass": [
            {
                "code": "// Fork of \"Day 1344\" by jeyko. https://shadertoy.com/view/clsfW8\n// 2023-08-25 08:31:43\n\n// Fork of \"Day 60smth WIP\" by jeyko. https://shadertoy.com/view/7tjXWd\n// 2023-08-24 08:52:32\n\n// box intersection from IQ\n// agx from https://www.shadertoy.com/view/cd3XWr\n\nvoid mainImage( out vec4 C, in vec2 U){\n    vec2 uvn = U.xy/R;\n\n    C= max(texture(iChannel1,U/R),0.);\n    //C = min(C,0.95);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define R iResolution.xy\n#define T(u) texture(iChannel0,(u)/R)\n#define NO_INTERSECTION -1.123456\n\n#define Ta(u) texture(iChannel0,u)\n#define Tb(u) texture(iChannel1,u)\n#define Tc(u) texture(iChannel2,u)\n#define Td(u) texture(iChannel3,u)\n#define iTime (iTime + 18.)\n\nuint seed = 111425u;\n\nuint hash_u(uint _a) {\n   uint a = _a;\n   a ^= a >> 16;\n   a *= 0x7feb352du;\n   a ^= a >> 15;\n   a *= 0x846ca68bu;\n   a ^= a >> 16;\n   return a; \n}\n\nfloat hash_f(){ uint s = hash_u(seed); seed = s;return ( float( s ) / float( 0xffffffffu ) ); }\nvec2 hash_v2(){ return vec2(hash_f(), hash_f()); }\nvec3 hash_v3(){ return vec3(hash_f(), hash_f(), hash_f()); }\nvec4 hash_v4(){ return vec4(hash_f(), hash_f(), hash_f(), hash_f()); }\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv ){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(dir,vec3(0,1,0)));\n    vec3 up = normalize(cross(dir,right));\n    return normalize(dir + right*uv.x + up * uv.y);\n}\nvec3 tonemap_uchimura2(vec3 v)\n{\n    const float P = 4.;  // max display brightness\n    const float a = 2.5;  // contrast\n    const float m = 0.2; // linear section start\n    const float l = 0.;  // linear section length\n    const float c = 1.3; // black\n    const float b = 0.;  // pedestal\n\n    float l0 = ((P - m) * l) / a;\n    float L0 = m - m / a;\n    float L1 = m + (1.0 - m) / a;\n    float S0 = m + l0;\n    float S1 = m + a * l0;\n    float C2 = (a * P) / (P - S1);\n    float CP = -C2 / P;\n\n    vec3 w0 = 1.0 - smoothstep(0.0, m, v);\n    vec3 w2 = step(m + l0, v);\n    vec3 w1 = 1.0 - w0 - w2;\n\n    vec3 T = m * pow(v / m, vec3(c)) + vec3(b);\n    vec3 S = P - (P - S1) * exp(CP * (v - S0));\n    vec3 L = m + a * (v - vec3(m));\n\n    return T * w0 + L * w1 + S * w2;\n}\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\nfloat r11(float g){return fract(sin(g*12.5)*4.5);}\n\nvec3 temp_norm;\nfloat boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out bool inters_inside) {\n    //boxSize -= 0.004;\n    // convert from ray to box space\n\tvec3 rdd = (vec4(rd,0.)).xyz;\n\tvec3 roo = (vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    \n    vec3 n = m*roo;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x,t1.y),t1.z);\n    float tF = min(min(t2.x,t2.y),t2.z);\n    \n    // no intersection\n\tif( tN>tF || tF<0.0 ) return NO_INTERSECTION;\n    \n    // use this instead if your rays origin can be inside the box\n    inters_inside = tN < 0.0;\n    vec4 res = !inters_inside ? vec4( tN, step(vec3(tN),t1)) :\n                          vec4( tF, step(t2,vec3(tF)));\n    //vec4 res = vec4(tN, step(tN,t1) );\n    \n    temp_norm = (vec4(-sign(rdd)*res.yzw,0.0)).xyz;\n    //temp_norm = normalize(temp_norm);\n    //if(inters_inside && temp_norm.y<-0.9){\n    if(temp_norm.y>0.9){\n        return NO_INTERSECTION;\n    }\n    if(inters_inside){\n        temp_norm = temp_norm;\n    }\n    \n    return res.x;\n}\n\n\n#define pi acos(-1.0)\n#define tau (2.*pi) \n\n#define pmod(p,a) mod(p,a) - 0.5*a\n\nfloat hash_f_s(uint s){ s = hash_u(s); return ( float( s ) / float( 0xffffffffu ) ); }\n// vec2 hash_22_s(uvec2 s){ uint _s = hash_u(s.x) + hash_u(s.y); return vec2(hash_f_s(_s.x), hash_f_s(_s.y)); }\nfloat hash_21_s(ivec2 _s_){ \n  uvec2 s = uvec2(_s_ + 2000);\n  uint _s = hash_u(s.x + hash_u(s.y)) + hash_u(s.y + hash_u(s.x)); \n  return hash_f_s(_s); \n}\nfloat valueNoise( in vec2 p ){\n    p += 100.;\n    ivec2 i = ivec2(floor( p ));\n    vec2 f = fract( p );\n\n    // cubic interpolant\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash_21_s( i + ivec2(0,0) ), \n                     hash_21_s( i + ivec2(1,0) ), u.x),\n                mix( hash_21_s( i + ivec2(0,1) ), \n                     hash_21_s( i + ivec2(1,1) ), u.x), u.y);\n}\n\nfloat Tonemap_Uchimura(float x, float P, float a, float m, float l, float c, float b) {\n    // Uchimura 2017, \"HDR theory and practice\"\n    // Math: https://www.desmos.com/calculator/gslcdxvipg\n    // Source: https://www.slideshare.net/nikuque/hdr-theory-and-practicce-jp\n    float l0 = ((P - m) * l) / a;\n    float L0 = m - m / a;\n    float L1 = m + (1.0 - m) / a;\n    float S0 = m + l0;\n    float S1 = m + a * l0;\n    float C2 = (a * P) / (P - S1);\n    float CP = -C2 / P;\n\n    float w0 = 1.0 - smoothstep(0.0, m, x);\n    float w2 = step(m + l0, x);\n    float w1 = 1.0 - w0 - w2;\n\n    float T = m * pow(x / m, c) + b;\n    float S = P - (P - S1) * exp(CP * (x - S0));\n    float L = m + a * (x - m);\n\n    return T * w0 + L * w1 + S * w2;\n}\n\n/*\nvoid mainImagea( out vec4 C, in vec2 U){\n    vec2 uvn = U.xy/R;\n\n    C = T(U);\n    C -= C;\n    vec2 uv = (U - 0.5*R)/R.y;\n    vec2 muv = (iMouse.xy - 0.5*R)/min(R.y,R.x);\n    \n    vec3 ro = vec3(\n        sin(muv.x*pi)*cos(muv.y*pi/1.),\n        cos(muv.y*pi/1.),\n        cos(muv.x*pi)*cos(muv.y*pi/1.)\n    )*0.4;\n    \n    vec3 rd = getRd(ro,vec3(0.0),uv);\n    const float bayer[] = float[64](\n         0./63., 32./63., 8./63., 40./63., 2./63., 34./63., 10./63., 42./63., \n        48./63., 16./63., 56./63., 24./63., 50./63., 18./63., 58./63., 26./63., \n        12./63., 44./63., 4./63., 36./63., 14./63., 46./63., 6./63., 38./63.,\n        60./63., 28./63., 52./63., 20./63., 62./63., 30./63., 54./63., 22./63., \n         3./63., 35./63., 11./63., 43./63., 1./63., 33./63., 9./63., 41./63., \n        51./63., 19./63., 59./63., 27./63., 49./63., 17./63., 57./63., 25./63.,\n        15./63., 47./63., 7./63., 39./63., 13./63., 45./63., 5./63., 37./63.,\n        63./63., 31./63., 55./63., 23./63., 61./63., 29./63., 53./63., 21./63.\n    );    \n\tvec2 buv = mod(floor(U.xy), 8.);\n\tfloat bay = bayer[int(buv.x) + int(buv.y)*8];\n    \n    //seed += uint(bay*64.);\n    \n    vec3 p = ro;\n    //rd = normalize(vec3(uv,0.5));\n    \n    float t = iTime + sin(iTime + 3.);\n    //rd.xz *= rot((t)*0.4);\n    //rd.xy *= rot((t)*0.4);\n    vec3 thr = vec3(1);\n    \n    vec3 em = vec3(0);\n    \n    for(float bnc = 0.; bnc < 1.; bnc++){\n        vec2 box = intersect(p,rd);\n        p = p + rd *  (box.x > 0. ? box.x : box.y);\n        vec4 c = get(p);\n        \n        thr *= c.xyz;\n        if(c.w > 0.1){\n            em += c.xyz*c.w;\n        }\n        \n        \n        float bncSubCnt = 1240.;\n        \n        p += n*0.002;\n        \n        vec3 subs = vec3(0);\n        for(float bncSub = 0.; bncSub < bncSubCnt; bncSub++){\n            vec3 brd = randomCosineHemisphere(n*1.);\n            \n            vec2 scene = intersect(p,brd);\n            \n            vec3 pp = p + brd * (scene.x > 0. ? scene.x : scene.y);\n            vec4 c = get(pp);\n            if(c.w > 0.03){\n                subs += thr * c.xyz / bncSubCnt;\n                em += c.w * thr * c.xyz / bncSubCnt;\n            }\n            \n            //att *= c;\n        \n            //vec2 \n        }\n        thr *= subs;\n    }\n    C.xyz += em;\n    \n    \n    if(iFrame == 0){\n        C = vec4(0,0,0,1);\n    }\n}\n*/\n\n#define AGX_LOOK 2\n\n// AgX\n// ->\n\n// Mean error^2: 3.6705141e-06\nvec3 agxDefaultContrastApprox(vec3 x) {\n  vec3 x2 = x * x;\n  vec3 x4 = x2 * x2;\n  \n  return + 15.5     * x4 * x2\n         - 40.14    * x4 * x\n         + 31.96    * x4\n         - 6.868    * x2 * x\n         + 0.4298   * x2\n         + 0.1191   * x\n         - 0.00232;\n}\n\nvec3 agx(vec3 val) {\n  const mat3 agx_mat = mat3(\n    0.842479062253094, 0.0423282422610123, 0.0423756549057051,\n    0.0784335999999992,  0.878468636469772,  0.0784336,\n    0.0792237451477643, 0.0791661274605434, 0.879142973793104);\n    \n  const float min_ev = -12.47393f;\n  const float max_ev = 4.026069f;\n\n  // Input transform\n  val = agx_mat * val;\n  \n  // Log2 space encoding\n  val = clamp(log2(val), min_ev, max_ev);\n  val = (val - min_ev) / (max_ev - min_ev);\n  \n  // Apply sigmoid function approximation\n  val = agxDefaultContrastApprox(val);\n\n  return val;\n}\n\nvec3 agxEotf(vec3 val) {\n  const mat3 agx_mat_inv = mat3(\n    1.19687900512017, -0.0528968517574562, -0.0529716355144438,\n    -0.0980208811401368, 1.15190312990417, -0.0980434501171241,\n    -0.0990297440797205, -0.0989611768448433, 1.15107367264116);\n    \n  // Undo input transform\n  val = agx_mat_inv * val;\n  \n  // sRGB IEC 61966-2-1 2.2 Exponent Reference EOTF Display\n  //val = pow(val, vec3(2.2));\n\n  return val;\n}\n\nvec3 agxLook(vec3 val) {\n  const vec3 lw = vec3(0.2126, 0.7152, 0.0722);\n  float luma = dot(val, lw);\n  \n  // Default\n  vec3 offset = vec3(0.0);\n  vec3 slope = vec3(1.0);\n  vec3 power = vec3(1.0);\n  float sat = 1.0;\n \n#if AGX_LOOK == 1\n  // Golden\n  slope = vec3(1.0, 0.9, 0.5);\n  power = vec3(0.8);\n  sat = 0.8;\n#elif AGX_LOOK == 2\n  // Punchy\n  slope = vec3(1.0);\n  power = vec3(1.35, 1.35, 1.35);\n  sat = 1.4;\n#endif\n  \n  // ASC CDL\n  val = pow(val * slope + offset, power);\n  return luma + sat * (val - luma);\n}\n\n// <-\n\nvec4 do_agx( vec4 fragColor)\n{\n  vec3 col = fragColor.xyz;\n  \n  // AgX\n  // ->\n  col = agx(col);\n  col = agxLook(col);\n  col = agxEotf(col);\n  // <-\n  \n  fragColor = vec4(col, 1.0);\n  return fragColor;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n#define pi acos(-1.0)\n//#define tau 2.*pi\n\n#define intersects(a)  (abs(a - NO_INTERSECTION) > 0.02)\n#define pmod(p,a) mod(p,a) - 0.5*a\n\n\nvec3 gp;\nvec3 norm;\nfloat id;\nfloat inside = -1.;\nfloat first_inside = -1.;\n\nvec4 get(vec3 p){\n    vec4 c;\n    if(\n        p.y > 0.01 && norm.y < -0.04\n        //&& norm.y < -0.1\n    ){\n        c = vec4(\n            //0.2*abs(sin(p.y*25.1 + iTime*20.)),\n            //1.5 + sin(p.y*8. + iTime)*1.,\n            0. + ((sin(p.y*55. + iTime) > 0.8) ? 5. : 0.),\n            0.5 ,\n            1.0 + ((sin(p.y*125. + iTime) > 0.8) ? 2. : 0.),\n            1.0);\n        c.xyz = sin(c.xyz + iTime*sin(p.y*15.)) + 0.5;\n    } else {\n        c = vec4(vec3(0.5),0.);\n    }\n    c = abs(c);\n    //c = max(c,0.);\n    return c;\n    //return vec4(0.5,0.5,0.5,0.4);\n}\n\nvec2 dmin(vec2 a, float b, float id){\n    if(abs(id - inside) < 0.001){\n        return a;\n    }\n    vec2 inters = a;\n    \n    if(!intersects(b)){\n    } else if (\n        ( b < a.x) ||\n        !intersects(a.x)\n        ) {\n        inters = vec2(b, id);\n        norm = temp_norm;\n    }\n    return inters;\n}\nint bnc = 0;\nvec2 intersect(vec3 ro, vec3 rd){\n    vec3 oro = ro;\n    vec2 ba = vec2(NO_INTERSECTION);\n    bool inters_inside;\n    ba = dmin(ba,boxIntersection(ro - vec3(0,4.0,0),rd,vec3(20.2,4.0,11.4),inters_inside),1.);\n    ba = dmin(ba,boxIntersection(ro + vec3(0,0,2.),rd,vec3(12.4,2.,0.4),inters_inside),4.);\n    //ba = dmin(ba,boxIntersection(ro - vec3(0,0,2.),rd,vec3(12.4,2.,0.4),inters_inside),4.);\n    ba = dmin(ba,boxIntersection(ro - vec3(3.,0,0.),rd,vec3(0.4,2.,102.4),inters_inside),4.);\n    ba = dmin(ba,boxIntersection(ro - vec3(-3.,0,0.),rd,vec3(0.4,2.,102.4),inters_inside),4.);\n    vec2 bounds = vec2(3.,2);\n    id = ba.y;\n    \n    if(intersects(ba.x) || (inside > 0.)){\n        if(inside < 0.0){\n            ro = ro + rd * ba.x;\n        }\n        \n        int t = 1*iFrame/50*0 + 1;\n        bool hit = false;\n        for(int i = 0; i < 4; i++){\n            ivec2 tidb = ivec2(t + i);\n            float sb = hash_21_s(tidb);\n            \n            sb = mix(0.6,1.,sb);\n            vec2 md = vec2(sb,mix(0.1,2.,mod(sb*12.5,1.)));\n            ivec2 id = ivec2(ro.xz/md);\n            vec3 q = ro;\n            ro.z += iTime*sb + sin(float(id.x)+ iTime);\n            q.xz = mod(ro.xz,md) - 0.5*md;\n\n            ivec2 tid = ivec2(id + t + i*20);\n            float s = hash_21_s(tid);\n            if(mod(s*125.61,1.0) < 0.7 + sin(iTime)*0.15){\n                s = 0.;\n            }\n            vec3 sz = vec3(1,mix(0.01,.8,s*s*s),1)*(vec3(0,1.0,0) + s*vec3(1,0,1)*md.xyy*0.5);\n            float inters = boxIntersection(q,rd,sz,inters_inside);\n\n\n            float inters_d = (inters + (intersects(ba.x) ? ba.x : 0.0));\n            \n            vec3 pp = oro + rd * inters_d;\n            if( intersects(inters) && inters_inside && inters_d > ba.x\n                && abs(pp.x) < 2.45 && abs(pp.z) < 1.8\n            ){\n                if(bnc == 0)\n                    inside = ba.y;\n                ba.x = inters_d;\n                norm = temp_norm;\n                hit = true;\n                //break;\n            }        \n        }\n        //ro += 0.1*vec3(0,1,0);\n        \n\n        //if()\n        //if()\n    }\n    \n    //ba = dmin(ba,boxIntersection(ro - vec3(0.2),rd,vec3(5.,0.2,5.)),1.);\n    return ba;\n}\n\n\nvec3 rand_sphere_dfox(){\n    float z = hash_f() * 2.0f - 1.0f;\n    float a = hash_f() * tau;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nvec3 randomCosineHemisphere(vec3 n){\n    return normalize(rand_sphere_dfox() + n);\n}\n\nvoid mainImage( out vec4 C, in vec2 U){\n    vec2 uvn = U.xy/R;\n\n    C = T(U);\n    C = vec4(0);\n    vec2 uv = (U - 0.5*R)/R.y;\n    \n    vec2 muv = (iMouse.xy - 0.5*R)/min(R.y,R.x);\n    \n    vec3 ro = vec3(0.1);\n    vec3 rd = normalize(vec3(uv,0.5));\n    \n    muv = vec2(0.3,-0.1);\n    \n    float zoom = 7.5;\n    \n    float id = floor(iTime/9.0);\n    float idb = 0.;\n    if(mod(iTime,9.) < 3.0){\n        if(mod(id,2.) == 1.){\n            muv = vec2(0.,-0.4);\n            zoom *= 1.5;\n            idb = 1.;\n        }\n        muv.x += sin(iTime*.4 + sin(iTime*0.6))*0.02;\n        muv.y += sin(iTime*.4 + sin(iTime*0.6))*0.02;\n    } else {\n        muv = vec2(0.,0);\n        muv.x += sin(iTime*.4 + sin(iTime*0.6))*0.1;\n        idb = 2.;\n    }\n    \n    //muv.y += sin(iTime*0.7 + sin(iTime*0.4))*0.05;\n    float t = iTime + sin(iTime + 3.);\n    //rd.xz *= rot((t)*0.4);\n    vec3 lookat = vec3(0.0,-0.4,0);\n    \n    if(idb == 0.){\n        lookat.y -= 0.7;\n        lookat += sin(vec3(0.5,0.2,0.6)*iTime)*vec3(0.2,0.1,0.2)*2.;\n    }else{\n        if(idb == 1.){\n            lookat += sin(vec3(0.5,0.2,0.6)*iTime*0.2 + idb*4. + sin(iTime*0.2))*vec3(0.5,0.1,0.3)*2.;\n        } else{\n            lookat += sin(vec3(0.3,0.3,0.6)*iTime*1. + idb*4. + sin(iTime*0.4))*vec3(0.5,0.1,0.3)*2.;\n            uv*=rot(0. + sin(iTime + cos(iTime))*0.05);\n        \n        }\n    }\n    //rd.xy *= rot((muv.x)*1.4);\n    if(true){\n        ro = vec3(\n            sin(muv.x*pi)*cos(muv.y*pi/1.),\n            sin(muv.y*pi/1.),\n            cos(muv.x*pi)*cos(muv.y*pi/1.)\n        )*zoom + vec3(0,-2.5,0);\n        rd = getRd(ro,lookat,uv*(0.3 + sin(idb + id)*0.05));\n    }\n    vec2 buv = mod(floor(U.xy), 8.);\n    seed += uint(iFrame);\n    seed += uint(texelFetch(iChannel1,ivec2(buv),0)*64.0)/1u;\n\t//float bay = bayer[int(buv.x) + int(buv.y)*8];\n    \n    \n    vec3 p = ro;\n    vec3 thr = vec3(1);\n    \n    vec3 acc = vec3(0);\n    \n        vec2 res = intersect(p,rd);\n        if(intersects(res.x)){\n            vec3 N = norm;\n            p = p + rd*res.x;\n            vec4 c = get(p);\n            \n            thr *= c.xyz;\n            if(c.w > 0.02){\n                acc += c.xyz*c.w;\n            }\n\n\n            float bncSubCnt =241.;\n            first_inside = inside;\n            p += N*0.002;\n            //acc += p.y;///\n            //acc += sin(p.y*11145.)*0.1;\n            bnc++;\n            if(c.w < 1.){\n                for(float bncSub = 0.; bncSub < bncSubCnt + min(float(iFrame),0.); bncSub++){\n                    vec3 brd = randomCosineHemisphere(N);\n\n                    vec2 res = intersect(p,brd);\n\n                    vec3 pp = p + brd * res.x;\n                    vec4 c = get(pp);\n                    if(intersects(res.x)){\n                        acc += c.w * thr * c.xyz / bncSubCnt;\n                        //acc -= 0.2/bncSubCnt;\n                        //acc -= 0.001;\n                    } else if(!intersects(res.x)){\n                        // sky\n                        acc += 0.05 * thr * vec3(0.1) / bncSubCnt;\n                    }\n\n                    //att *= c;\n\n                    //vec2 \n                }\n            }\n        } else {\n            acc += 1.0;\n        }\n    C.xyz += acc;\n    \n    \n    //C.xyz = tonemap_uchimura2(C.xyz*2.5);\n    //C.xyz = Tonemap_Uchimura(float x, float P, float a, float m, float l, float c, float b);\n    //C = C/(1.+C);\n    C*= 1.0;\n    C = do_agx( abs(C) );\n    C = max(C,0.);\n    C = pow(C,vec4(.4545));\n    //C = clamp(C,0.,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n// idk where this is from, copied from noby shader\n\nfloat FXAAamt = 0.25;\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 p = fragCoord.xy/iResolution.xy;\n    vec2 pp = 1. / iResolution.xy;\n    vec4 color = texture(iChannel0, vec2(fragCoord.xy * pp));\n    vec3 luma = vec3(.299, 0.587, 0.114);\n    \n    float lumaNW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, -1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaNE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, -1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaSW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, 1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaSE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, 1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaM  = dot(color.xyz,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * (1.0/8.0)), (1.0/128.0));\n\n    float rcpDirMin = 2.5 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(8.0, 8.0),\n              max(vec2(-8.0, -8.0),\n              dir * rcpDirMin)) * pp;\n\n    vec3 rgbA = 0.5 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * -0.5).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax)){\n        fragColor = vec4(rgbA, color.w);\n    } else {\n        fragColor = vec4(rgbB, color.w);\n    }\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}