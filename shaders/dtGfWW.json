{
    "Shader": {
        "info": {
            "date": "1702133221",
            "description": "TL: No adjustment\nTR: Naive backoff\nBL: Frontface the Normal\nBR: Backoff to previous march step\n\nextension of [url]https://www.shadertoy.com/view/dtGfWW[/url] .",
            "flags": 0,
            "hasliked": 0,
            "id": "dtGfWW",
            "likes": 10,
            "name": "back off, normals - 3",
            "published": 3,
            "tags": [
                "raymarching",
                "normals",
                "artifacts"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 181
        },
        "renderpass": [
            {
                "code": "// Fork of \"back off, normals.\" by elenzil. https://shadertoy.com/view/mlVcWV\n// 2023-11-28 17:12:59\n\n/*\n\n    back off, normals #3\n    --------------------\n\n    More exploration here.\n    This time the SDF is composed of just the simple Union\n    of three exact Box SDFs.  No subtractions or intersections.\n    In the entire SDF is exact.\n    \n    Top-Left:  No adjustment\n    Bot-Left:  \"Front-Face\" the normal after the fact.\n    Top-Right: Backoff along the ray by march epsilon * 4.\n    Bot-Right: Backoff along the ray to the previous sample point.\n    \n    At t = 0, with no mouse interaction yet,\n    only backing off by Epsilon * 4 is free from hot pixels.\n    \n    I don't really understand why the backoff needs to be so much (eps * 4),\n    nor why backing up to the previous sample point is not sufficient.\n    \n    I also don't understand why making the normal epsilon very tiny\n    (eg, marchEpsilon * 1e-4) doesn't fix this more.\n    \n    \n    Orion Elenzil 20231208\n*/\n\n#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n\nconst float gSceneCenterY  = 3.0;\nconst float gFOVFac        = 0.3;\n\nconst uint  gMarchMaxSteps = 150u;\nconst float gMarchEps      =   0.002;\nconst float gNormEps       = gMarchEps * 1e-1;\n      float gNormBackoff   = gMarchEps * 5.0;\n      bool  gIsUpperHalf;\n      bool  gIsRightHalf;\n      vec3  gDebugRGB      = v0;\n\nconst vec3  gLightDir      = normalize(vec3(-2.2, 0.5, 4.0));\nconst vec3  gAmbient       = v1 * 0.05;\nconst float reflectAmt     = 0.05;\n      float gT;\n\nvec3 sky(in vec3 ro, in vec3 rd) {\n    vec3 c = vec3(1.0, 0.9, 0.8);\n    c = mix(c, vZ * 0.5, pow(rd.y, 0.3));\n    c = mix(c, v1, max(0.0, dot(rd, gLightDir)));\n    return c;\n}\n\nvec3 albedo(in vec3 p) {\n    if (p.y < gMarchEps) {\n        return v1;\n    }\n    if (p.x > 0.0) {\n        return vec3(1.0, 1.0, 0.0);\n    }\n    else {\n        return vec3(0.0, 1.0, 1.0);\n    }\n}\n\nfloat sdScene(in vec3 p) {\n    float d = 1e9;\n    \n    float rad = gSceneCenterY;\n    \n    vec3 q = (p - vY * rad).zyx;\n    opUnn(d, sdBox   (q                  , rad * (v1 - vX * 0.75)));\n    opUnn(d, sdBox   (q + vX * rad * 0.75, rad * (v1 - vX * 0.75)));\n    opUnn(d, sdBox   (q - vX * rad * 0.75, rad * (v1 - vX * 0.75)));\n    \n    return d;\n}\n\n// ∇(sdScene())\nvec3 gradScene(in vec3 p) {\n    float d = sdScene(p);\n    return vec3(\n        sdScene(p + vX * gNormEps) - d,\n        sdScene(p + vY * gNormEps) - d,\n        sdScene(p + vZ * gNormEps) - d\n    );\n}\n\nvec3 normScene(in vec3 p) {\n    return normalize(gradScene(p));\n}\n\nvec2 march(in vec3 ro, in vec3 rd) {\n    \n    float tPrev = 0.0;\n    float t = 0.0;\n    for (uint n = 0u; n < gMarchMaxSteps; ++n) {\n        vec3  p = ro + rd * t;\n        float d = sdScene(p);\n        if (d < gMarchEps) {\n            // a hit\n            return vec2(tPrev, t);\n        }\n        tPrev = t;\n        t += d;\n        if (t > 1e2) {\n            // too far away\n            return vec2(1e9, 1e9);\n        }\n    }\n    \n    return vec2(1e9, 1e9);\n}\n\nvec2 rayVsScene(in vec3 ro, in vec3 rd) {\n    vec2  tMarch = march(ro, rd);\n    float tTrace = rayVsPlane(ro, rd, vY, 0.0);\n    \n    if (tTrace < tMarch[1]) {\n        return vec2(tTrace);\n    }\n    else {\n        return tMarch;\n    }\n}\n\nvec3 runRaySegment(in vec3 ro, in vec3 rd, out vec3 p, out vec3 n) {\n\n    // returns t[1] = the final t the ray reached\n    //         t[0] = the t of the previous step\n\n    vec2 t = rayVsScene(ro, rd);\n    \n    if (t.y > 1e4) {\n        p = v1 * 1e9;\n        return sky(ro, rd);\n    }\n    \n    vec3 rgb = v0;\n    \n    p        = ro + rd * t.y;\n    // floor is not part of SDF, so we cheat\n    if (p.y < gMarchEps) {\n        n = vY;\n    }\n    else {\n    \n    \n    \n    \n    \n        ////////////////////////////////////////////////////////////////\n        // NORMAL CORRECTION HERE.\n        //\n        //\n        bool TL =  gIsUpperHalf && !gIsRightHalf;\n        bool TR =  gIsUpperHalf &&  gIsRightHalf;\n        bool BL = !gIsUpperHalf && !gIsRightHalf;\n        bool BR = !gIsUpperHalf &&  gIsRightHalf;\n        \n        vec3 normalSamplePoint;\n        \n        if (TL) {\n            // no adjustment\n            normalSamplePoint = p;\n        }\n        \n        if (TR) {\n            // naive backoff\n            normalSamplePoint = p - rd * gNormBackoff;\n        }\n        \n        if (BR) {\n            // backoff to previous raymarch step point\n            normalSamplePoint = ro + rd * t.x;\n        }\n        \n        if (BL) {\n            // no adjustment to sample point, but test after.\n            normalSamplePoint = p;\n        }\n        \n        n = normScene(normalSamplePoint);\n        \n        if (BL) {\n            // face forward\n            n *= sign(dot(n,-rd));\n\n        }\n        \n        //\n        //\n        ////////////////////////////////////////////////////////////////\n        \n        \n        \n    }\n    vec3 alb = albedo(p);\n    \n    rgb += gAmbient * alb;\n    float diffuseAmt = max(0.0, dot(n, gLightDir));\n    if (diffuseAmt > 0.0) {\n        float tShadow = rayVsScene(p + n * gMarchEps * 2.0, gLightDir).y;\n        if (tShadow > 1e4) {\n            rgb += alb * diffuseAmt;\n        }\n    }\n    \n    return rgb;\n}\n\nvec3 runRay(in vec3 ro, in vec3 rd) {\n    uint bouncesLeft = 4u;\n    \n    float rayAmt = 1.0;\n    \n    vec3 rgb = v0;\n    \n    while (bouncesLeft > 0u) {\n        vec3 p, n;\n        \n        vec3 c = runRaySegment(ro, rd, p, n);\n        \n        if (p.x < 1e8) {\n\n            rgb += c * rayAmt * (1.0 - reflectAmt);\n\n            // no fresnel\n            rayAmt *= reflectAmt;\n            ro = p + n * gMarchEps * 2.0;\n            rd = reflect(rd, n);\n\n            bouncesLeft -= 1u;\n        }\n        else {\n            rgb += c * rayAmt;\n            bouncesLeft = 0u;\n        }\n    }\n    \n    return rgb;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    gIsUpperHalf = XY.y * 2.0 > RES.y;\n    gIsRightHalf = XY.x * 2.0 > RES.x;\n    \n    vec2 xy = XY;\n    // split into four copies\n    vec2 halves = vec2(bvec2(gIsRightHalf, gIsUpperHalf));\n    xy = xy * 2.0 - RES * halves;\n    \n    \n    if (false) {\n        const float pixelate = 10.0;\n        xy = round(xy / pixelate) * pixelate;\n    }\n\n    gT     = iTime * pi / 30.0;\n    const float zoom = 1.0;\n    vec2 p = (xy        * 2.0 - RES) / MINRES / zoom;\n    vec2 m = (iMouse.xy * 2.0 - RES) / MINRES / zoom;\n    if (iMouse.x < 20.0) {\n        float q = smoothstep(-1.0, 1.0, sin(gT * 2.0 - 5.0)) * 2.0 - 1.0;\n        m = vec2(q * 0.03 + 0.01, 0.25);\n    }\n    \n    // compose ray\n    vec3 lf = vec3(0.0, 5.0, 20.0);\n    lf.yz  *= rot2(smoothstep(1.0, -1.0, m.y) - 0.2);\n    lf.xz  *= rot2(smoothstep(1.0, -1.0, m.x) * pi * 3.0);\n    vec3 lt = vY * gSceneCenterY;\n    vec3 fw = normalize(lt - lf);\n    vec3 rt = normalize(cross(fw, vY));\n    vec3 up = cross(rt, fw);\n    vec3 ro = lf;\n    vec3 rd = normalize(fw + (rt * p.x + up * p.y) * gFOVFac);\n    \n    vec3 rgb = runRay(ro, rd);\n    \n    float splitsD = 1e9;\n    opUnn(splitsD, abs(RES.y / 2.0 - XY.y));\n    opUnn(splitsD, abs(RES.x / 2.0 - XY.x));\n    rgb = mix(rgb, vY * 0.0, smoothstep(3.0, 2.0, splitsD));\n    \n    RGBA.rgb = pow(rgb, vec3(1.0 / 1.8));\n    RGBA.rgb += gDebugRGB;\n    RGBA.a   = 1.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const vec3  vX = vec3(1, 0 ,0);\nconst vec3  vY = vX.yxy;\nconst vec3  vZ = vX.yyx;\nconst vec3  v0 = vX.yyy;\nconst vec3  v1 = vX.xxx;\n\nconst float pi = 3.14159265359;\n\n//--------------------------------------------------------------------------------\n\n// A = ∪(A, B)\nvoid opUnn(inout float A, in float B) {\n    A = min(A, B);\n}\n\n// A = A - B\nvoid opSub(inout float A, in float B) {\n    A = max(A, -B);\n}\n\n// A = ∩(A, B)\nvoid opInt(inout float A, in float B) {\n    A = max(A, B);\n}\n\n//--------------------------------------------------------------------------------\n\nmat2  rot2    (float theta) { float c = cos(theta); float s = sin(theta); return mat2(c, s, -s, c); }\n\n//--------------------------------------------------------------------------------\n\nfloat sdSphere(in vec3 p, in float r) { return length(p) - r; }\nfloat sdCyl   (in vec2 p, in float r) { return length(p) - r; }\nfloat sdShell (in vec3 p, in float r, in float t) {\n    float d  = length(p);\n    float d1 = d - (r + t / 2.0);\n    float d2 = d - (r - t / 2.0);\n    opSub(d1, d2);\n    return d1;\n}\n\n// Inigo Quilez, https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b ){  vec3 q = abs(p) - b;  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0); }\n\n\n\n//--------------------------------------------------------------------------------\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nfloat rayVsPlane(in vec3 ro, in vec3 rd, in vec3 n, in float d) { float t = -(dot(ro, n) + d) / (dot(rd, n)); if (t < 0.0) { t = 1e9; } return t; }\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}