{
    "Shader": {
        "info": {
            "date": "1624789773",
            "description": "Version of shader done during livecode.demozoo launch party jamming. FFT and motion blur are not same as in the jam version.",
            "flags": 32,
            "hasliked": 0,
            "id": "7lj3DV",
            "likes": 4,
            "name": "livecode.demozoo launch, eimink",
            "published": 3,
            "tags": [
                "sdf"
            ],
            "usePreview": 0,
            "username": "eimink",
            "viewed": 315
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//HI EVERYONE!\n\n// Mercury SDF <3 - https://mercury.sexy/hg_sdf/\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (sqrt(5)*0.5 + 0.5)\n#define saturate(x) clamp(x, 0, 1)\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n#define M1 1.0\n#define M2 2.0\n#define M3 3.0\n\nvec3 glow = vec3(0);\n\nstruct SceneResult\n{\n  float d;\n  float cid;\n  float mid;\n};\n\nstruct MarchResult\n{\n  vec3 position;\n  vec3 normal;\n  SceneResult sres;\n};\n\nfloat ffts;\nfloat ffti = 0.;\nfloat time;\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nvoid rot(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// base from iq\nSceneResult opU(SceneResult d1, SceneResult d2)\n{\n    if (d1.d < d2.d)\n    {\n        return d1;\n    }\n    return d2;\n   // return (d1.d < d2.d) ? d1 : d2;\n}\n\n// 3D noise function (IQ)\nfloat noise(vec3 p){\n\tvec3 ip = floor(p);\n    p -= ip;\n    vec3 s = vec3(7.0,157.0,113.0);\n    vec4 h = vec4(0.0, s.yz, s.y+s.z)+dot(ip, s);\n    p = p*p*(3.0-2.0*p);\n    h = mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\nSceneResult scene(vec3 p) {\n  SceneResult r;\n  rot(p.xy,ffti*20.);\n  vec3 pp = abs(p);\n  for (int i = 0; i < 2; ++i)\n  {\n    pp = abs(pp) - vec3(4.,4.,5.);\n    rot(pp.xy,(time+20.*ffts)*.1);\n    rot(pp.yz,time*.1);\n  }\n  float c = pModPolar(pp.xz,5.);\n  pp -= vec3(5,0,0);\n  rot(pp.xz,ffti*2.);\n   \n  vec3 ppp = p;\n  float cc = pModPolar(ppp.xz,5.);\n  ppp -= vec3(5.,cc*3.,0.);\n  rot(ppp.yz,PI);\n  rot(ppp.xz, -time);\n  rot(ppp.xy,ffti*.20);\n    \n  SceneResult box;\n  box.d = sdBox(pp,vec3(2.,1.+ffts*20.,1))+noise(pp);\n  box.cid = c;\n  box.mid = M1;\n  \n  SceneResult tp;\n  tp.d = sdTriPrism(ppp,vec2(1.5+ffts*20.,.2));\n  tp.mid = M2;\n\n  vec3 pppp = abs(p);\n  for (int i = 0; i < 4; ++i)\n  {\n    pppp = abs(pppp) - vec3(3.,6.,9.);\n    rot(pp.xy, (time+texelFetch( iChannel0, ivec2(pp.x,0), 0 ).x));\n    //rot(pp.xy, (time+texture( texFFT, pp.x ).r*1));\n    rot(pp.yz, time*0.1);\n  }\n  \n  SceneResult tp2;\n  tp2.d = sdTriPrism(pppp,vec2(2.5+ffts*10.,.4));\n  tp2.mid = M3;\n\n  r = opU(opU(box,tp),tp2);\n  \n  glow += vec3(.8,.4,.2)*0.01/(0.01+abs(tp.d));\n  glow += vec3(.9,.2,.6)*0.01/(0.9+abs(box.d));\n  glow += vec3(.2,.4,.8)*0.01/(0.2+abs(tp2.d));\n  \n  return r;\n}\n\nvec3 calcNormal (in vec3 pos)\n{\n  vec2 e = vec2(0.0001,0.0);\n  return normalize(vec3(scene(pos+e.xyy).d-scene(pos-e.xyy).d,\n                        scene(pos+e.yxy).d-scene(pos-e.yxy).d,\n                        scene(pos+e.yyx).d-scene(pos-e.yyx).d));\n}\n\nMarchResult raymarch(in vec3 ro, in vec3 rd)\n{\n  vec3 p = ro+rd;\n  float s = .0;\n  float id = M1;\n  float t = 0.;\n  SceneResult d;\n  for (int i = 0; i < 100; ++i){\n    d = scene(p);\n    t += d.d;\n    p += rd*d.d;\n    s = float(i);\n    if (d.d < 0.01 || t > 100.) {\n      break;\n    }\n  }\n  MarchResult res;\n  res.position = p;\n  res.normal = calcNormal(p);\n  res.sres = d;\n  res.sres.d = t;\n  return res;\n}\n\nvec3 shade(MarchResult mr, vec3 rd, vec3 ld)\n{\n  float l = max(dot(mr.normal,ld),.0);\n  float a = max(dot(reflect(ld,mr.normal),rd),.0);\n  float s = pow(a,10.);\n  \n  float m = mod(mr.sres.cid,8.);\n  \n  vec3 col = vec3(.8,.4,.2);\n  if (mr.sres.mid == M1){\n    if (m < 1.)\n      col = vec3(.2,.6,.9);\n    else if (m < 2.)\n      col = vec3(.9,.6,.2)*.1;\n    else\n      col = vec3(.9,.2,.6)*.1;\n  }\n  else if (mr.sres.mid == M2)\n  {\n    col = vec3(.8,.2,.4);\n  }\n  else {\n    col = vec3(1.,.5,.5)*.25;\n  }\n  return l * col * .5 + s * (col * vec3(1.1,1.2,1.2))*.8;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  time = iTime;\n  ffts = texelFetch( iChannel0, ivec2(85,.25), 0).x*.05; \n  ffti = iTime*.05+abs(texelFetch( iChannel0, ivec2(.1,.25), 0).x)*.01; \n  \n  vec3 cp = vec3(sin(10.*ffti)+10.,5.+sin(ffti),cos(20.*ffti)+20.);\n  vec3 ct = vec3(0);\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 q = -1.0+2.0*uv;\n  q.x *= iResolution.x/iResolution.y;\n  \n  vec3 cf = normalize(ct-cp);\n  vec3 cr = normalize(cross(vec3(0,1,0),cf));\n  vec3 cu = normalize(cross(cf,cr));\n  vec3 rd = normalize(mat3(cr,cu,cf)*vec3(q,radians(90.0)));\n  vec3 ld = -rd;  \n  \n  \n  vec3 col = vec3(0);\n  \n  MarchResult m = raymarch(cp,rd);\n  if (m.sres.d < 100.)\n  {\n    col = shade(m,rd,ld);\n  }\n  \n  col += glow * .3;\n  fragColor = vec4(col,1.);\n  \n  \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 18,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 bufB = texelFetch(iChannel1,ivec2(fragCoord),0);\n    vec4 bufA = texelFetch(iChannel0,ivec2(fragCoord),0);\n    vec3 col;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n      // Hi rimina! Using your code here!\n  \n  /*vec4 pcol = vec4(0.0);\n  vec2 puv = vec2(20./iResolution.x, 20./iResolution.y);\n  vec4 mults = vec4(0.1531, 0.11245, 0.0918, 0.051);\n  pcol = texelFetch(iChannel1, ivec2(uv),0) * 0.1633;\n  pcol += texelFetch(iChannel1, ivec2(uv),0) * 0.1633;\n  for (int i = 0; i < 4; ++i)\n  {\n    pcol += texelFetch(iChannel1, ivec2(uv.x - (float(i)+1.0) * puv.y, uv.y - (float(i)+1.0) * puv.x),0) * mults[i] +\n            texelFetch(iChannel1, ivec2(uv.x - (float(i)+1.0) * puv.y, uv.y - (float(i)+1.0) * puv.x),0) * mults[i] +\n            texelFetch(iChannel1, ivec2(uv.x - (float(i)+1.0) * puv.y, uv.y - (float(i)+1.0) * puv.x),0) * mults[i] +\n            texelFetch(iChannel1, ivec2(uv.x - (float(i)+1.0) * puv.y, uv.y - (float(i)+1.0) * puv.x),0) * mults[i];\n  }\n  col += pcol.rgb;\n  col *= 0.35;\n  \n  col = mix(col, bufA.rgb,.5);//texelFetch(iChannel0, ivec2(uv),0).rgb,.5);\n  \n  col = smoothstep(-.1, 1., col);\n  \n  vec4 bufC = vec4(col,1);*/\n  \n  fragColor = mix(bufB,bufA,0.05);\n  //fragColor = bufC;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}