{
    "Shader": {
        "info": {
            "date": "1461191444",
            "description": "cloud montecarlo pathtrace",
            "flags": 32,
            "hasliked": 0,
            "id": "ldcXWB",
            "likes": 8,
            "name": "cloudtunnel progressivepathtrace",
            "published": 3,
            "tags": [
                "cloud",
                "montecarlo",
                "trace",
                "path",
                "progressive"
            ],
            "usePreview": 0,
            "username": "public_int_i",
            "viewed": 1099
        },
        "renderpass": [
            {
                "code": "//Ethan Alexander Shulman 2016\n//Image - Renders BufA\n\n\n#define devrender 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #if devrender == 0\n    fragColor = pow(texture(iChannel0, fragCoord/iResolution.xy)/(float(iFrame-120)), vec4(1./2.2));\n    \n    //used for exporting image in the format of r=lighting, g=opacity\n\t//fragColor = texture(iChannel0, fragCoord/iResolution.xy)/(float(iFrame-120));\n    //fragColor.x = pow(fragColor.x, 1./2.2);\n    \n\t#else\n    fragColor = pow(texture(iChannel0, fragCoord/iResolution.xy), vec4(1./2.2));\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Ethan Alexander Shulman 2016\n\n\n#define pi 3.1415926\n#define iterations 512\n#define minDelta .2\n#define maxDelta .6\n#define range 256.\n\n\nconst vec3 sunDirection = normalize(vec3(3.,5.,1.)),\n    \t   sunColor = vec3(1.,.74,.94)*2.,\n    \t   skyColor = vec3(0.),\n    \t   cloudColor = vec3(.88),\n    \t   ambientColor = vec3(.99);\n\nconst float sunSize = .004,//0-1, relative to the result of dot product\n    \t\tcloudDensity = 1.5,//0-2, density/alpha of the clouds\n    \t\tcloudFluff = .1,//0-1, fluffiness/alpha fade of clouds\n    \t\tcloudRoughness = .38,// roughness of the clouds features\n            ambientDensity = .0;//0-2, global mist\n\n\n\n#define devrender 0\n\n\n\nfloat ffract(float p) {\n    return fract(p)*2.-1.;\n}\nvec3 ffract(vec3 p) {\n    return fract(p)*2.-1.;\n}\n\n//random float 0-1 from seed a\nfloat hash(float a) {\n    return fract(fract(a*24384.2973)*512.34593+a*128.739623);\n}\n//random float 0-1 from seed p\nfloat hash3(in vec3 p) {\n    return fract(fract(p.x)*128.234+fract(p.y)*124.234+fract(fract(p.z)*128.234)+\n                 fract(p.x*128.234)*18.234+fract(p.y*128.234)*18.234+fract(fract(p.z*128.234)*18.234));\n}\n\n//random ray in a hemisphere relative to d, uses p as a seed\nvec3 randomHemiRay(in vec3 d, in vec3 p) {\n    vec3 rand = normalize(ffract(ffract(p)*512.124+ffract(p*16.234)*64.3249+ffract(p*128.234)*12.4345));\n    return rand*sign(dot(d,rand));\n}\n\n//random ray using p as a seed\nvec3 randomRay(in vec3 p) {\n    vec3 rand = normalize(ffract(ffract(p)*512.124+ffract(p*16.234)*64.3249+ffract(p*128.234)*12.4345));\n    return rand;\n}\n\n//static backgrund\nvec3 background(vec3 d) {\n    float sun = dot(normalize(sunDirection), d);\n    return mix(skyColor,\n               sunColor,\n               pow(max(0., sun-(1.-sunSize))/sunSize,.3));\n}\n\n//distance function defining the clouds shape\nfloat df(vec3 p) {\n\t\n    //base shape\n   \tfloat d = abs(length(p.xy)-10.)-1.9;\n    \n    //cloud shape deform\n\t#define ldst d\n    #define deformAmount 1.\n    for (int i = 1; i < 4; i++) {\n        float pfi = pow(float(i),2.)*deformAmount;\n        ldst += abs(cos(p.x/pfi+cos(26.2348+ldst*cloudRoughness*p.z/pfi+(p.y*.39)/pfi)*4.)*\n     \t\t     cos(p.y/pfi+cos(29.8937+ldst*cloudRoughness*p.x/pfi+(p.z*.37)/pfi)*4.)*\n       \t\t     cos(p.z/pfi+cos(14.972+ldst*cloudRoughness*p.y/pfi+(p.x*.41)/pfi)*4.))*pfi;\n    }\n\n    \n    return max(.1, ldst);\n}\n//density lerp percent from distance d and point p\nfloat dstToDensity(float d, vec3 p) {\n    return min(1., (d-.1)*10.*(1.-cloudFluff));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 120) {\n        //initialize frame data\n        fragColor = vec4(0.);\n        return;\n    }\n       \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    //ray direction from uvs and ray position at origin\n    vec3 rd = normalize(vec3((fragCoord*2.-iResolution.xy)*vec2(-1.,1.)/iResolution.x,1.)),\n         ird = rd,\n         rp = vec3(0.,0.,-3.2);\n        \n    float ifrm = float(iFrame);\n    #define rndifrm(s) fract(fract(ifrm*.044877+s)*256.494+ifrm*.02934)\n    \n    vec4 c = vec4(1,1,1,0);\n    \n    #if devrender == 0\n    \n    \n    //render\n    for (int i = 0; i < iterations; i++) {\n        float d = df(rp),\n              dt = d*(minDelta+hash3(rp+rndifrm(rp)*1024.)*(maxDelta-minDelta)),\n              k = dstToDensity(d,rp);\n        if (mix(cloudDensity,ambientDensity,k)*max(1.,dt*.1) > hash3(rp+rndifrm(rp)*256.)) {//if density > random then ray hits cloud\n            c.xyz *= pow(mix(cloudColor,ambientColor,k),\n                             vec3(1.));\n            c.w = 1.;\n            rd = mix(sunDirection, randomRay(rp+rndifrm(rp*1024.)*1024.), floor(hash3(rp*.9+rndifrm(rp*1.5)*512.)+.5));\n        }\n        \n        rp += rd*dt;\n        if (length(rp) > range) break;\n    }\n   \n    c.xyz *= background(rd)*float(length(rp)/range > 1.);//if light ray makes it too edge of world illuminate it  \n    fragColor = mix(vec4(background(ird),1.), c, c.w)+texture(iChannel0, uv);//blend result with background and add to buffer\n\n    //used for exporting image in the format of r=lighting, g=opacity\n    /*(fragColor = vec4(c.x*float(max(length(rp)/range,max(0.,-rp.y)/yRange) > 1.),c.w,0,0)+\n                     texture(iChannel0, uv);\n    */\n    \n    #else\n    for (int i = 0; i < iterations; i++) {\n        float d = df(rp);\n        if (d < .2 || c.w > range) break;\n        \n        rp += rd*d;\n        c.w += d;\n    }\n    if (df(rp) < .2) {\n       c = vec4(cloudColor*(.3+max(0.,(df(rp)-df(rp-sunDirection)))),1.);\n    } else {\n       c = vec4(background(ird),1.); \n    }\n    fragColor = c+texture(iChannel0,uv);\n    #endif\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}