{
    "Shader": {
        "info": {
            "date": "1636071593",
            "description": "really expensive...not sure why but it's late",
            "flags": 8,
            "hasliked": 0,
            "id": "Nt33WH",
            "likes": 10,
            "name": "Nodevember day 3/4 - 4 sides",
            "published": 3,
            "tags": [
                "raymarching",
                "nodevember"
            ],
            "usePreview": 0,
            "username": "y2k_cyborg",
            "viewed": 349
        },
        "renderpass": [
            {
                "code": "// Based on https://www.shadertoy.com/view/sllGDN\n// by Martijn Steinrucken aka The Art of Code/BigWings - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Performance settings\n// Enabling AA is more expensive but looks quite a lot better\n#define USE_AA 1\n// Continue further raycast after refraction?\n#define MAX_RAYS_PER_PRIMARY 2.\n\n#define MAX_STEPS 128\n#define MAX_DIST 1000.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nconst int MAT_CHROME=1;\nconst int MAT_SAND=2;\nconst int MAT_SKY=3;\n\nvec2 sdSand(vec3 p) {\n  p -= vec3(25., -5., 4.);\n  float h = p.y;\n  h += -10. * smoothstep(0., 1., .01 * length(p.xz));\n  h += .52 * sin(p.x * .351 + p.z * .225 + 0.1);\n  h += 1.13 * sin(p.x * .1242 + p.z * .1452 + 0.5);\n  h += 3.43 * sin(p.x * .0642 + p.z * 0.0543+ 0.5);\n  h += 2.94 * sin(p.z * .09842 + 0.7);\n  h += .63 * sin(p.z * .1212 - 0.3);\n  return vec2(h, MAT_SAND);\n}\n\n// This is where we define the scene itself\nvec2 GetDist(vec3 p) {\n    vec2 dMat = vec2(MAX_DIST, MAT_SKY);\n    \n    float pyramidScale = 10.;\n    vec3 pyrPos = vec3(0., 0., 0.);\n    vec2 dPyr = vec2(sdPyramid((p - pyrPos) / pyramidScale, 1.1) * pyramidScale, MAT_CHROME);\n    vec2 dSand = sdSand(p - vec3(0., 3., 0.));\n    dMat = Min(dMat, Min(dPyr, dSand));\n    \n    return dMat;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side) {\n\tfloat dO=0.;\n    vec2 dSMat = vec2(0.);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        dSMat = GetDist(p)*side;\n   \n        dO += dSMat.x;\n        if(dO>MAX_DIST || abs(dSMat.x)<SURF_DIST) break;\n    }\n    \n    return vec2(dO, dSMat.y);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n// based on https://www.shadertoy.com/view/4tdSWr\nvec3 cloud2D(vec2 p, float h) {\n    const float cloudscale = .11;\n    const float speed = 0.03;\n    const float clouddark = 0.5;\n    const float cloudlight = 0.3;\n    const float cloudcover = 0.2;\n    const float cloudalpha = 8.0;\n    const float skytint = 0.5;\n    const vec3 skycolour1 = vec3(0.2, 0.4, 0.6);\n    const vec3 skycolour2 = vec3(0.4, 0.7, 1.0);\n        \n    vec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);\n    float time = iTime * speed;\n    float q = fbm(uv * cloudscale * 0.5);\n    \n    //ridged noise shape\n\tfloat r = 0.0;\n\tuv *= cloudscale;\n    uv -= q - time;\n    float weight = 0.8;\n    for (int i=0; i<8; i++){\n\t\tr += abs(weight*noise( uv ));\n        uv = m*uv + time;\n\t\tweight *= 0.7;\n    }\n    \n    //noise shape\n\tfloat f = 0.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale;\n    uv -= q - time;\n    weight = 0.7;\n    for (int i=0; i<8; i++){\n\t\tf += weight*noise( uv );\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n    \n    f *= r + f;\n    \n    //noise colour\n    float c = 0.0;\n    time = iTime * speed * 2.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale*2.0;\n    uv -= q - time;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc += weight*noise( uv );\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n    \n    //noise ridge colour\n    float c1 = 0.0;\n    time = iTime * speed * 3.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale*3.0;\n    uv -= q - time;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc1 += abs(weight*noise( uv ));\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n\t\n    c += c1;\n    \n    vec3 skycolour = mix(skycolour2, skycolour1, h);\n    vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*c), 0.0, 1.0);\n   \n    f = cloudcover + cloudalpha*f*r;\n    \n    return mix(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));\n}\n\nvec3 cloudCol(vec3 rd) {\n  float h = 2.;\n  vec3 c = vec3(h * rd.x / rd.y, h * rd.z / rd.y, h);\n  vec3 cloud = vec3(0.);\n  cloud += cloud2D(c.xy, 1. - .5 * rd.y);\n  return cloud;\n}\n\nvec3 sandCol(vec3 p) {\n  vec3 sand_hi = vec3(.7, .7,.4);\n  vec3 sand_lo = vec3(.2, .1, 0.);\n  float t = 0.;\n  t += -3.*fbm(.02 * p.zx) + 2.*fbm(13.4154 * p.xz)+.5;\n  return mix(sand_lo, sand_hi, t);\n}\n\n\nvec4 fogCol() {\n  return vec4(.7, .7, .4, .95 * 2.* windStrength(iTime));\n}\n\n\nvec3 EnvCol(vec3 rd) {\n  return cloudCol(rd);\n}\n\nvec4 Render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last) {\n    vec3 col = EnvCol(rd);\n    vec2 dMat = RayMarch(ro, rd, 1.);\n    float d = dMat.x;\n    float mat = dMat.y;\n    \n    ref *= 0.;\n    \n    float depth = 0.;\n    \n    if (d < MAX_DIST) {\n        vec3 p = ro + rd * d; // 3d hit position\n        vec3 n = GetNormal(p); // normal of surface... orientation\n        vec3 r = reflect(rd, n); // reflected ray\n        \n        // Colour of reflection, going to environment\n        vec3 refEnv = EnvCol(r);\n        \n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(0);\n        \n        int mat = int(dMat.y);\n        \n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 5.);\n        fresnel = mix(.01, .7, fresnel);\n        if (mat==MAT_SKY) {\n           \n        } else if(mat==MAT_SAND) {\n           col += sandCol(p);\n        } else if(mat==MAT_CHROME) {\n           ref = vec3(.9);\n           if (last) {\n             vec4 fog = fogCol();\n             vec3 envCol = mix(refEnv, fog.rgb, fog.a);\n             col += envCol*ref;\n           }\n        }\n            \n        ro = p + n*SURF_DIST*3.;\n        rd = r;\n    }\n    depth = d;\n    return vec4(col, depth);\n}\n\nvec3 RenderAll(vec2 fragCoord) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    // hack for the initial value being strange\n    m = (m == vec2(0., 0.)) ? vec2(0,0) : (m - .5);\n    if (m.y < 0.) { m.y = 0.; }\n    \n    vec3 cam_look_at = vec3(6., 5., 0.);\n    vec3 cam_pos = vec3(0., 2., 20.);\n    cam_pos.xz *= Rot(.1*2.*PI);\n    float fov_z = 1.5;\n    \n    cam_pos.yz *= Rot(-m.y*.02*PI);\n    cam_pos.xz *= Rot(-m.x*.03*PI);\n    cam_pos.y += 2.*GetDist(cam_pos).x;\n\n    // ray origin\n    vec3 ro = cam_pos;\n    // ray direction\n    vec3 rd = GetRayDir(uv, ro, cam_look_at, fov_z);\n    \n    vec3 col = vec3(0.);\n    vec3 ref, fil=vec3(1);\n   \n    float depth = 99999.;\n    for(float i=0.; i<MAX_RAYS_PER_PRIMARY; i++) {\n        vec4 pass = Render(ro, rd, ref, i==MAX_RAYS_PER_PRIMARY-1.);\n        if (i == 0.) { depth = pass.a;}\n        col += pass.rgb*fil;\n        fil*=ref;\n    }\n    \n    vec4 fog = fogCol();\n    return mix(\n      col,\n      fog.rgb,\n      clamp(1. - 9./depth, 0., fog.a)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = RenderAll(fragCoord);\n    \n    // Anti-aliasing\n    #if USE_AA\n    col +=\n        RenderAll(fragCoord+vec2(.5,.0))+\n        RenderAll(fragCoord+vec2(.0,.5))+\n        RenderAll(fragCoord+vec2(.5,.5));\n    col /= 4.;\n    #endif\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Library functions\n\n// From https://www.shadertoy.com/view/sllGDN\n// by Martijn Steinrucken aka The Art of Code/BigWings - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.1415926535\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec2 Min(vec2 a, vec2 b) {\n    return a.x<b.x ? a : b;\n}\n\n// from https://www.shadertoy.com/view/4tdSWr\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 0.1;\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn = m * n;\n\t\tamplitude *= 0.4;\n\t}\n\treturn total;\n}\n\n// from https://iquilezles.org/articles/distfunctions\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdBox(vec2 p, vec2 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, p.y), 0.);\n}\n\nfloat sdLineSeg(vec3 p, vec3 a, vec3 b) {\n    vec3 ap=p-a, ab=b-a;\n    float t = clamp(dot(ap, ab)/dot(ab, ab), 0., 1.);\n    vec3 c = a + ab*t;\n    return length(p-c);\n}\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nfloat udIsoTriangle( vec3 p, float r )\n{\n  const float cos30 = 0.86602540378;\n  float h = r;\n  vec3 a = vec3(-h, -h*cos30, 0.);\n  vec3 b = vec3(+h, -h*cos30, 0.);\n  vec3 c = vec3( 0,  h*cos30, 0.);\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdPrism( in vec3 p, in float r, in float h )\n{\n    float d = udIsoTriangle(vec3(p.xy, 0.), r);\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat nGon(in int n, in vec2 p, in float r) {\n    // these 2 lines can be precomputed\n    float an = 6.2831853 / float(n);\n    float he = r * tan(0.5 * an);\n\n    // rotate to first sector\n    p = -p.yx; // if you want the corner to be up\n    float bn = an * floor((atan(p.y, p.x) + 0.5 * an) / an);\n    vec2 cs = vec2(cos(bn), sin(bn));\n    p = mat2(cs.x, -cs.y, cs.y, cs.x) * p;\n\n    // side of polygon\n    return length(p - vec2(r, clamp(p.y, -he, he))) * sign(p.x-r);\n}\n\n// for the distance result of any 2D SDF, returns a 3D prism for the 3rd axis position value v\nfloat toPrism(in float d2d, in float v, in float size) {\n    vec2 d = vec2(d2d, abs(v) - 0.5 * size);\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat nPrism(in int n, in vec3 p, in float r, in float depth) {\n    float d = nGon(n, p.xy, r);\n    return toPrism(d, p.z, depth);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat windStrength(float time) {\n  return clamp(sin(time * 0.4) * 0.4 + 0.2, 0., .5);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Based on https://www.shadertoy.com/view/4l2XWh\n// Tweaked to sound more like wind\n\n\n\n// 1D version of IQ code, see https://www.shadertoy.com/view/lsf3WH\nfloat hash( float p ){\n\tfloat h = p * 127.1;\n    return fract(sin(h)*43758.5453123);\n}\nfloat perlinNoise( in float x ) {\n    float lower = floor(x);\n    float upper = lower + 1.0;\n    float lowerV = hash(lower);\n    float upperV = hash(upper);\n    return smoothstep(lower, upper, x) * (upperV - lowerV) + lowerV;\n}\n\n// return a different white noise on both channels\n// thanks Dave Hoskins! see https://www.shadertoy.com/view/4djSRW\n#define ITERATIONS 8\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\nvec2 hash22( in vec2 p ) {\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return fract(vec2(p3.x * p3.y, p3.z*p3.x));\n}\nvec2 noise( in float time ) {\n\tvec2 audio = vec2(0.0);\n    for (int t = 0; t < ITERATIONS; t++) {\n        float v = float(t)*3.21239;\n\t\taudio += hash22(vec2(time + v, time*1.423 + v)) * 2.0 - 1.0;\n    }\n    audio /= float(ITERATIONS);\n    \n    // convert to mid/side, reduce side, recombine\n    vec2 mid_side = vec2(.5*(audio.x + audio.y), .5*(audio.x - audio.y));\n    mid_side.y *= 0.8;\n    return vec2(mid_side.x + mid_side.y, mid_side.x - mid_side.y);\n}\n\n// do a low pass on the white noise and get the wave sound\n#define SAMPLES 8\nvec2 getWaveSound( in float time ) {\n    // snap to the nearest 1/iSampleRate\n    float period = 1.0 / iSampleRate;\n    time = floor(time/period)*period;\n    float totAmpl = 0.0;\n    vec2 audio = vec2(0);\n    for (int i = 0 ; i < SAMPLES ; i++) {\n        float index = float(i - SAMPLES/2);\n        float currStepF = period * index;\n        vec2 curr = noise(time + currStepF);\n        index /= 8.0;\n        index *= index;\n        float ampl = 1.0 - index;\n        totAmpl += ampl;\n        audio += curr*ampl;\n    }\n    return audio/totAmpl;\n}\n\nvec2 mainSound( in int samp,float time) {\n    vec2 result = vec2(0);\n\n    float waveAmpl = windStrength(time);\n    float perlinAmpl = 1.0 - perlinNoise( time * 0.2 ) * 0.3;\n    result += smoothstep(0.0, 10.0, time) * getWaveSound(time) * waveAmpl * perlinAmpl;\n\n    return result;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}