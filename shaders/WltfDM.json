{
    "Shader": {
        "info": {
            "date": "1612871384",
            "description": "Spectrum plot of a blue noise-like sampling pattern that uses 3 sub-samples per pixel.",
            "flags": 32,
            "hasliked": 0,
            "id": "WltfDM",
            "likes": 9,
            "name": "3 Sub-Samples Pattern Spectrum",
            "published": 3,
            "tags": [
                "noise",
                "antialiasing",
                "blue",
                "sampling",
                "aa"
            ],
            "usePreview": 0,
            "username": "TinyTexel",
            "viewed": 478
        },
        "renderpass": [
            {
                "code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\nSpectrum plot of a blue noise-like sampling pattern that uses 3 sub-samples per pixel.\n\nRelated:\n    https://www.shadertoy.com/view/WtdfWM - \"3 Sub-Samples Pattern Test\"   (sampling a checkerboard tunnel using the pattern)\n    https://www.shadertoy.com/view/3tdBWM - \"Blue Noise via 3 Sub-Samples\" (plot of the used sampling pattern)\n*/\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    float b = (iResolution.y - SIZE)*0.5;\n    \n    if(uv0.y < b || uv0.y > iResolution.y-b) { outCol = vec4(0.11); return; }\n    \n    uv0.y -= b;\n    \n    vec2 tc = uv0/iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n    \n    if (tc.x > 0.5)\n    {\n        // spectrum 2d plot\n        vec2 dft = texelFetch(iChannel1, ivec2(uv0-0.5-vec2(SIZE,0.0)), 0).xy;\n        \n        float amp = length(dft); \n        \n        float s = 0.01;\n        amp *= s;\n        \n        col = vec3(amp);\n\n        if(amp <= exp2(-13.0)) col = vec3(1.0, 0.0, 0.0)*0.25;\n        if(amp <= exp2(-16.0)) col = vec3(1.0, 0.5, 0.0)*0.25;\n        \n        col = clamp01(col);\n    }\t\n    else\n    {\n        // kernel 2d plot\n        float n = textureLod(iChannel0, tc, 0.).r;\n        col = vec3(abs(n));\n        if(n < 0.0) col *= vec3(1.0, 0., 0.0);\n        \n        col = pow(clamp01(col), vec3(1.0/2.2));\n    }\n    \n\n    outCol = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n  #define SIZE (floor(iResolution.y/2.25)*2.)\n\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nvec2 cossin(float x) { return vec2(cos(x), sin(x)); }\n\nvec2 cmul(vec2 c0, vec2 c1)\n{\n\treturn vec2(c0.x * c1.x - c0.y * c1.y, \n\t\t        c0.y * c1.x + c0.x * c1.y);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n// experimental stuffs\n\n#if 0\n\n    dots = PlotDot(uvf+off0, vec2(0.5) + (vec2(uvi0.y * rPhi1, uvi0.x * (-rPhi1)))* (1.0 / 4294967296.0) - 0.5, 0.02); \n    //dots = PlotDot(uvf+off0, vec2(0.5) + (vec2(float(uvi0.y * rPhi1)* (1.0 / 4294967296.0), fract(float(uvi0.x) * mix(0.0, 1.0,iMouse.x/iResolution.x)))) - 0.5, 0.02); \n    //dots = PlotDot(uvf+off0, vec2(0.5) + (vec2(uvi0.y * rPhi2a, uvi0.x * (rPhi2b)))* (1.0 / 4294967296.0) - 0.5, 0.02); \n  \n  \nvec2 Dir(uvec2 uvi, float i)\n{\n#if 1\n    if(((uvi.x ^ uvi.y) & 4u) == 0u) uvi   = uvi.yx;\n    if(((uvi.x        ) & 4u) == 0u) uvi.x =-uvi.x;\n\n    // constants of the 1d and 2d Roberts sequences\n    const uint rPhi1  = 2654435761u;\n    const uint rPhi2a = 3242174893u;\n    const uint rPhi2b = 2447445397u;\n    \n    uint a = 3316612456u;\n    uint b = 1538627358u;\n    \n    float u = float((uvi.x * rPhi2a) + (uvi.y * rPhi2b)) * (1.0 / 4294967296.0);\n     u = float((uvi.x * a) + (uvi.y * b)) * (1.0 / 4294967296.0);\n     u = float((uvi.x * a) + (uvi.y * b) + WeylHash(uvi/4u)) * (1.0 / 4294967296.0);\n    //u = fract(float(uvi.x)*0.7722090128189392 + float(uvi.y)*0.35823959808621314);\n#else\n    float u = float( WeylHash(uvi)) * (1.0 / 4294967296.0);\n#endif\n\n    float ang = (Pi*0.666667) * (i+u);\n    //ang = Pi * 2.0 * u;\n    vec2 dir = vec2(cos(ang), sin(ang));\n    \n    return dir;\n}\n\nvec2 DirA(uvec2 uvi, float i)\n{\n    vec2 dir = vec2(0.0);\n    \n    {\n        float w = 0.25*0.25;\n        \n        dir += Dir(uvi + uvec2( 1u, 1u), i);\n        dir += Dir(uvi + uvec2(-1u, 1u), i);\n        dir += Dir(uvi + uvec2( 1u,-1u), i);\n        dir += Dir(uvi + uvec2(-1u,-1u), i);\n    }\n    \n    {\n        float w = 0.5*0.25;\n        \n        dir += Dir(uvi + uvec2( 1u, 0u), i);\n        dir += Dir(uvi + uvec2(-1u, 0u), i);\n        dir += Dir(uvi + uvec2( 0u, 1u), i);\n        dir += Dir(uvi + uvec2( 0u,-1u), i);\n    }\n    \n    dir = Dir(uvi, i) * (0.5*0.5);\n    //dir = Dir(uvi, i) - dir; \n    dir = normalize(dir);\n    \n    return dir;\n}\n\nfloat SimpleStep(float x)\n{\n    x = clamp(x, 0.0, 1.0);\n    \n    float xp = x < 0.5 ? x * 2.0 : x * -2.0 + 2.0;\n    \n    float y = xp*xp;\n    \n    return x < 0.5 ? y * 0.5 : y * -0.5 + 1.0;\n}\n\n#if 0\n    off.y = float((uvi.x * rPhi1) + WellonsHash2(uvi.y)) * (1.0 / 4294967296.0) - 0.5;\n    off.x = float((uvi.y * rPhi1) + WellonsHash2(uvi.x^0x1452Cu)) * (1.0 / 4294967296.0) - 0.5;\n#else\n    off.y = (float(WellonsHash2( uvec2(uvi.x   , uvi.y), 0u)) * (1.0 / 4294967296.0) - 0.5) * 0.5;\n    off.y -= (float(WellonsHash2(uvec2(uvi.x-1u, uvi.y), 0u)) * (1.0 / 4294967296.0) - 0.5) * 0.25;\n    off.y -= (float(WellonsHash2(uvec2(uvi.x+1u, uvi.y), 0u)) * (1.0 / 4294967296.0) - 0.5) * 0.25;\n    off.y = SimpleStep(off.y + 0.5) - 0.5;\n    \n    off.x = (float(WellonsHash2( uvec2(uvi.x, uvi.y   ), 1u)) * (1.0 / 4294967296.0) - 0.5) * 0.5;\n    off.x -= (float(WellonsHash2(uvec2(uvi.x, uvi.y-1u), 1u)) * (1.0 / 4294967296.0) - 0.5) * 0.25;\n    off.x -= (float(WellonsHash2(uvec2(uvi.x, uvi.y+1u), 1u)) * (1.0 / 4294967296.0) - 0.5) * 0.25;\n    off.x = SimpleStep(off.x + 0.5) - 0.5;\n    \n#endif\n\n#endif",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n*/\n\nfloat PlotDot(vec2 sp, vec2 dp, float dr)\n{\n    float v = length(sp - dp) - dr;\n    \n    v = smoothstep(1.0, 0.0, v * 12.0);\n    \n    return v;\n}\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c) \n{\n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u; \n}\n\nuint Dot(uvec2 a, uvec2 b) { return a.x*b.x + a.y*b.y;}\n\n\nfloat Map0(vec2 uv2, vec2 uvf, vec2 off0)\n{\n    uvec2 uvi0 = uvec2(floor(uv2));\n    uvec2 uvi = uvec2(floor(uv2));\n    if(((uvi.x ^ uvi.y) & 4u) == 0u) uvi   = uvi.yx;\n\tif(((uvi.x        ) & 4u) == 0u) uvi.x =-uvi.x;\n\n    // constants of the 1d and 2d Roberts sequences\n    const uint rPhi1  = 2654435761u;\n    const uint rPhi2a = 3242174893u;\n    const uint rPhi2b = 2447445397u;\n    \n    float u = float((uvi.x * rPhi2a) + (uvi.y * rPhi2b)) * (1.0 / 4294967296.0);\n    uint  h = WeylHash(uvi);\n\n    //if(((uvi.x ^ uvi.y) & 1u) == 0u) u += 0.5;\n\n    float dots = 0.0;\n    \n  #if 1\n    float count = 3.0;\n    for(float i = 0.0; i < count; ++i) \n    {\n        float ang = (Pi*2.0/count) * (i+u);\n        \n        vec2 off = vec2(cos(ang), sin(ang));\n       // off /= max(abs(off.x), abs(off.y));\n      #if 0\n        off *= 0.333333;\n      #elif 1\n        off *= 0.4;\n      #elif 0\n        // based on Fabrice Neyret's suggestion\n        off *= float(h+uint(i)*rPhi1) * (0.111111/4294967296.0) + 0.333333;\n      #else\n        off *= float(h+uint(i)*rPhi1) * (0.25/4294967296.0) + 0.25;\n      #endif\n      \n        dots += PlotDot(uvf+off0, vec2(0.5) + off, 0.02); \n    }\n  #else\n    for(float i = 0.0; i < 2.0; ++i) \n    {\n        float ang = Pi * (i+u);\n        \n        vec2 off = vec2(cos(ang), sin(ang));\n       \n        off *= 0.333333;\n       \n        dots += PlotDot(uvf+off0, vec2(0.5) + off, 0.02); \n    }\n  #endif\n      \n    return dots;\n}\n\nfloat Map(vec2 uv)\n{\n    vec2 uv2 = uv / 16.0;\n    vec2 uvf = fract(uv2);\n    \n   #if 0\n    return Map0(uv2, uvf, vec2(0.0));\n   #else\n    // use this to prevent points placed close to a cell's border from getting clipped\n    return Map0(uv2, uvf, vec2(0.0, 0.0))+\n    Map0(uv2-vec2(1.0, 0.0), uvf, vec2(1.0, 0.0))+\n    Map0(uv2-vec2(0.0, 1.0), uvf, vec2(0.0, 1.0))+\n    Map0(uv2+vec2(0.0, 1.0), uvf, -vec2(0.0, 1.0))+\n    Map0(uv2+vec2(1.0, 0.0), uvf, -vec2(1.0, 0.0));\n   #endif\n}\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    if(uv0.x > SIZE || uv0.y > SIZE)\n    {\n        discard;\n        return;\n    }\n    \n    vec2 uv = uv0 - 0.5;\n    \n    float v = Map(uv);\n    \n    outCol = vec4(v, 0.0, 0.0, 1.0);\n    \n    return;\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n    vec2 uv = fragCoord.xy - 0.5;\n    \n    if(fragCoord.x >= SIZE || fragCoord.y >= SIZE) {fragColor = vec4(0.01); return;}\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\tvec2 xn = texelFetch(iChannel0, ivec2(i, uv.y), 0).rg;\n        vec2 yn = texelFetch(iChannel1, ivec2(uv.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (uv -SIZE/2.) * i/SIZE;\n\t\tfragColor.zw += cmul(xn, ang.x);\n\t\tfragColor.xy += cmul(yn, ang.y);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}