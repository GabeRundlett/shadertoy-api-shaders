{
    "Shader": {
        "info": {
            "date": "1716133913",
            "description": "Glass tracing. Hacked together extremely fast from an old shader for #wccchallenge",
            "flags": 32,
            "hasliked": 0,
            "id": "McKSWt",
            "likes": 11,
            "name": "Aqua in glass",
            "published": 3,
            "tags": [
                "raytracing",
                "glass",
                "aqua"
            ],
            "usePreview": 0,
            "username": "Alie",
            "viewed": 276
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec4 col = texture(iChannel0, uv);\n    col = vec4(col.rgb/col.a, 1.0);\n    uv = uv * 2. - 1.;\n\tcol = pow(col*pow(saturate(2.1-length(uv)),.5), vec4(1. / 1.8));\n\n\n    // Output to screen\n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define NANLEVEL 20\n\n\t// Minor values\n#define Epsilon 1e-3 // epsilon\n#define PI 3.142\n#define MAXFLOAT 1e15\n\n\t// Useful functions\n\n#define Rotate(p,a) p=cos(a)*p+sin(a)*vec2(-p.y,p.x);\n#define saturate(x) clamp(0.,1.,x)\n#define nanCheck(x) if(any(isnan(x)))\n\n#define CRYSTAL(f,p,s,a,b,c) p*=s;a=floor(p)/s,b=ceil(p)/s,c=fract(p);s=mix(mix(mix(f(vec3(a.x,a.y,a.z)),f(vec3(b.x,a.y,a.z)),c.x),mix(f(vec3(a.x,b.y,a.z)),f(vec3(b.x,b.y,a.z)),c.x),c.y),mix(mix(f(vec3(a.x,a.y,b.z)),f(vec3(b.x,a.y,b.z)),c.x),mix(f(vec3(a.x,b.y,b.z)),f(vec3(b.x,b.y,b.z)),c.x),c.y),c.z);\n\nstruct Ray { // Ray\n\tvec4 origin;\n\tvec3 dir;\n\tbool inside; // Used to indicate ray is inside surface (e.g. glass)\n};\n\nstruct Box {\n\tvec3 a, b;\n};\n\nstruct Triangle {\n\tvec3 v, a, b;\n};\n\n    // id, color, baseSmoothness, coatSmoothness, coatOpacity, fresnel, coatSaturation\nstruct Material{\n\tint id; // 0: standard, 1: light, 2: glass\n\tvec3 color;\n\t\t// Standard materials have 2 layers, allowing for e.g. matte base and reflective coat\n\tfloat baseSmoothness, coatSmoothness, coatOpacity, fresnel, coatSaturation;\n};\n\n\t/// Stores the result of an intersection test - normal, distance, material\nstruct Intersection {\n\tvec4 result; // Result: xyz = normal, w = dist\n\tMaterial material; // Material\n\t\t\t   //\tS scene; // S number\n};\n\n// *** Prototypes ***\n\nIntersection intersectScene(inout Ray ray, in vec3 k);\n\n// *** Hashing and sampling ***\n\n\t/// Basic hash function\nvec3 hash(in vec3 p){\n\tp=fract(p*vec3(443.897,441.423,437.195));\n\tp+=dot(p,p.yxz+19.19);\n\treturn fract((p.xxy+p.yxx)*p.zyx);\n}\n\n\t/// Returns a point on a sphere, r is in 0..1 range\nvec3 pointOnSphere(in vec2 r) {\n\tr=vec2(6.283185*r.x,2.*r.y-1.);\n\tvec3 p = vec3(sqrt(1.+Epsilon-r.y*r.y)*vec2(cos(r.x),sin(r.x)),r.y); // 1.001 required to avoid NaN\n          \n    #if NANLEVEL>9\n    nanCheck(p) {p = vec3(0,1,0);} \n    #endif\n    \n    return p;\n}\n\n\t/// Returns a cosine weighted sample\nvec3 lambertSample(in vec3 n, in vec2 r) {\n\tvec3 p = normalize(n*(1.+Epsilon)+pointOnSphere(r)); // 1.001 required to avoid NaN\n\n    #if NANLEVEL>10\n    nanCheck(p) {p = vec3(0,1,0);} \n    #endif\n    \n    return p;\n}\n\n// *** Materials\n\n\t/// Applies glass, including fresnel reflection\nvoid applyGlass(inout Ray ray, in Intersection hit, in vec3 k, inout vec4 rayColouration){\n\t\n\t\t// Fresnel term\n\tfloat fresnel = 1. - max(0., -dot(ray.dir, hit.result.xyz));\n\tfresnel = pow(fresnel, 2.);\n    #if NANLEVEL>11\n    if(isnan(fresnel)) {fresnel = 0.;} \n    #endif\n\t\n\t\t// Randomly reflect or refract, probability based on fresnel term\n\t\t// If non-fresnel, refract\n\tif (k.z > fresnel) {\n\t\t\t// refraction\n\t\t\t// Index of refraction\n\t\tfloat ior = ray.inside ? 1.5 : 1./1.5;\n\t\t\n\t\t\t// Find refraction angle, accounting for surface roughness\n\t\tvec3 rayDir = normalize( // Ray dir must be normalised\n\t\t\t\t\t  mix( // Mix between...\n\t\t\t\t\t      refract(ray.dir, hit.result.xyz, ior), // the refracted angle\n\t\t\t\t\t      lambertSample(-hit.result.xyz, k.xy), // and a random angle projected into the surface\n\t\t\t\t\t      hit.material.baseSmoothness // based on how smooth the glass surface is\n\t\t\t\t\t      )\n\t\t\t\t\t  );\n    #if NANLEVEL>12\n    nanCheck(rayDir) {rayDir = vec3(0,1,0);} \n    #endif\n\t\t\n\t\t\t// Test for total internal reflection\n\t\tif(dot(hit.result.xyz, rayDir) < 0.) {\n\t\t\t\t// Not TIR, we're OK to refract\n\t\t\t\t// Step through suface along normal\n\t\t\tray.origin.xyz -= hit.result.xyz * Epsilon * 4.;\n\t\t\t\n\t\t\t\t// Set the ray direction\n\t\t\tray.dir=rayDir;\n\t\t\t\n\t\t\t\t// Flip the inside value as we pass through the surface\n\t\t\tray.inside=!ray.inside;\n    #if NANLEVEL>13\n    nanCheck(ray.dir) {ray.dir = vec3(0,1,0);} \n    nanCheck(ray.origin) {ray.origin = vec4(0,0,-10,0);} \n    #endif\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\t\t// Ray failed to refract, therefore reflection\n\t\t// Step away from the surface along the normal\n\tray.origin.xyz+=hit.result.xyz*Epsilon*2.;\n\t\n\t\t// Standard reflection\n\tray.dir=reflect(ray.dir,hit.result.xyz);//mix(reflect(ray.dir,hit.result.xyz),lambertSample(hit.result.xyz,k.xy),hit.material.baseSmoothness);\n\n    #if NANLEVEL>14\n    nanCheck(ray.dir) {ray.dir = vec3(0,1,0);} \n    #endif\n}\n\n\t/// This is hacky, I need to rework it, but it works for basic materials for now\nvoid applyMaterial(inout Ray ray, inout Intersection hit, in vec3 k, inout vec4 rayColouration, inout vec3 outputColour){\n\t\t// useROI, useMainLight, angular (0=volume)\n\t\t// b, cs, o, f, s\n\t\t// There's no refraction so step away from suRayFactorace to prevent re-intersection\n\tray.origin.xyz+=hit.result.xyz*Epsilon*2.;\n\t\n\t\t// Fresnel value\n\tfloat f=1.+dot(ray.dir,hit.result.xyz),c; // 0 head on, 1 at oblique angle\n\tf*=f*f*hit.material.fresnel; // Fresnel is dependent on the coating\n\t\n\t\t// Add the coat opacity. This means the outer suRayFactorace will be visible, but still respects fresnel\n\tf+=(hit.material.coatOpacity);\n    \n    #if NANLEVEL>15\n    if(isnan(f)) f = 0.;\n    #endif\n\t\n\t\t// Split randomly between coat and base\n\t\t//\tShould write this without conditionals - coatLayer = 0 | 1, then just change base values to base or coat accordingly\n\tc=step(k.z,f);\n\t\n\t\t// Colour by m, blended into whe (no colouration) according to coat colouration (allows for coloured reflections)\n\trayColouration.xyz*=mix(hit.material.color,mix(vec3(1),hit.material.color,hit.material.coatSaturation),c);\n\t\n\t\t// We'll use base m only, so set that to base or coat\n\thit.material.baseSmoothness=pow(mix(hit.material.baseSmoothness,hit.material.coatSmoothness,c),.5);\n\t\t//\thit.material.baseSmoothness = 0.0;\n\t\t// If there's a main light, sample it\n\t\n\t\t//\tlightSample(r,h,k,i,o);\n\t\n\t\n\t\t// Standard suRayFactorace handling\n\t\t// Properties: base roughness, coat roughness, coat opacity, coat fresnel\n\t\n\t\t// Get random direction\n\tvec3 s=pointOnSphere(k.xy),n=normalize(hit.result.xyz+s*.9*(1.-pow(hit.material.baseSmoothness,.125)));\n\tray.dir=normalize(reflect(ray.dir,n)*hit.material.baseSmoothness // mirror\n\t\t\t  +s*pow(k.z+Epsilon,hit.material.baseSmoothness*hit.material.baseSmoothness*10.) // rough\n\t\t\t  );\n    #if NANLEVEL>16\n    nanCheck(ray.dir) {ray.dir = vec3(0,1,0);} \n    #endif\n\t\n\t\t// If normal points away from r, flip it\n\tif(dot(ray.dir,hit.result.xyz)<0.)ray.dir=normalize(hit.result.xyz*(1.+Epsilon)+s*pow(k.z+Epsilon,0.25));\n    #if NANLEVEL>17\n    nanCheck(ray.dir) {ray.dir = vec3(0,1,0);} \n    #endif\n\t\n}\n\n\t/// Applies a checkerboard texture to the material\nvoid check(in Ray ray, inout Intersection hit, float s) {\n\tray.origin.xyz = ray.origin.xyz + ray.dir * hit.result.w;\n\tray.origin.xz = mod(floor(ray.origin.xz * s), 2.0);\n\thit.material.color *= floor(mod(ray.origin.x + ray.origin.z, 2.0) * .95 + .05);\n}\n\n\t/// Applies a polka dot texture to the material\nvoid polka(in Ray ray, inout Intersection hit, float s){\n\tray.origin.xyz = ray.origin.xyz + ray.dir * hit.result.w;\n\thit.material.color *= step(0.35, length(mod(ray.origin.xz * s, 1.0) - 0.5));\n    #if NANLEVEL>18\n    nanCheck(hit.material.color) {hit.material.color = vec3(0,1,0);} \n    #endif\n}\n\n// *** Ray intersection functions\n\n\t/// Ground plane intersection\nvoid intersectGround(in Ray ray, inout Intersection hit, in Material material){\n\tray.origin.w = -ray.origin.y / ray.dir.y;\n\tif(ray.origin.w > 0. && ray.origin.w < hit.result.w){\n\t\thit.result = vec4(0,1,0, ray.origin.w);\n\t\thit.material = material;\n\t}\n}\n\n\t/// Sphere intersection\nvoid intersectSphere(in Ray ray, in vec4 sphere, inout Intersection hit, in Material material){\n\tray.origin.xyz -= sphere.xyz;\n\tray.origin.w = dot(ray.dir.xyz, ray.origin.xyz) * 2.;\n\tfloat a = dot(ray.origin.xyz, ray.origin.xyz) - sphere.w * sphere.w;\n\ta = ray.origin.w * ray.origin.w - 4. * a;\n\tif (a < 0.) { return; }\n\ta = sqrt(a);\n\tvec2 g = (vec2(-a, a) - ray.origin.w) / 2.;\n\ta = g.x < 0. ? g.y : g.x;\n\tsphere.w *= sign(g.x);\n\tif (a> hit.result.w || a < 0.) { return; }\n\thit.result = vec4((ray.dir.xyz * a + ray.origin.xyz) / sphere.w, a);\n\thit.material = material;\n}\n\n\t/// Cube intersection\nvoid intersectCube(in Ray r, in Box c, inout Intersection hit, in Material m){\n\tvec3 a=(c.a-r.origin.xyz)/r.dir, // near\n\tb=(c.b-r.origin.xyz)/r.dir, // far\n\tf=max(a,b), // furthest\n\tn=min(a,b); // nearest\n\tfloat x=min(f.x,min(f.y,f.z)), // furthest plane\n\td=max(n.x,max(n.y,n.z)), // nearest plane\n\to=d<0.?x:d; // nearest in front\n\tif(isnan(n.x)||d>=x||o>hit.result.w||o<0.)return; // d>=x = invalid, o>t = behind other geometry, o<0 behind\n\thit.result.w=o;\n\thit.result.xyz=normalize(step(Epsilon,abs(a-hit.result.w))-step(Epsilon,abs(b-hit.result.w)))*sign(d);\n\thit.material=m;\n}\n\n\n\t/// Intersection test for triangle\nvoid intersectTriangle(in Ray r, in Triangle t, inout Intersection hit, in Material m){\n\tvec3 p=cross(r.dir,t.b),q,s;\n\tfloat e=dot(t.a,p),u,v;\n\tif(e<Epsilon)return;\n\t\n\tfloat f=1./e;\n\t\n\ts=r.origin.xyz-t.v;\n\tu=dot(s,p)*f;\n\tfloat i=step(0.,u)*(1.-step(1.,u));\n\t\n\tq=cross(s,t.a);\n\tv=dot(r.dir,q)*f;\n\ti*=step(0.,v)*(1.-step(1.,u+v));\n\tif(i==0.)return;\n\t\n\tu=dot(t.b,q)*f;\n\t\n\tf=step(0.,-u);\n\tu=u*(1.-f)+(f*MAXFLOAT);\n\tif(u>hit.result.w)return;\n\tp=normalize(cross(t.a,t.b));\n\thit = Intersection(vec4(p*sign(e),u),m);\n}\n\n// *** Distance functions\n\n\t/// Box, origin is o, size is s\nfloat boxDist(vec3 p, vec3 o, vec3 s){\n\tvec3 q = abs(p-o) - s;\n\treturn length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\n\t/// Torus\nfloat torus(vec3 p, vec2 t){\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nvec2 minDF(vec2 a, vec2 b){\n    return a.x<b.x ? a : b;\n}\n\nfloat smin(float a, float b, float k) {\n    float res = exp2(-k*a) + exp2(-k*b);\n    return -log2(res)/k;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define RayFactor 2. // total rays is square of this\n#define RayCount (RayFactor*RayFactor) // Number of rays per pixel\n#define Bounces 12 // Number of bounces per ray\n#define Tilesize 2\n\n\t// Camera values\n#define CameraTarget vec3(0,1.5,0)\n#define CameraPosition (vec3(0, 0.2+(iMouse.y*5. / iResolution.y), 3))\n#define Zoom 0.9 // Lens zoom\n#define Fisheye 0.5 // Use with wider lenses (zoom of 1 or less)\n#define Aperture 0.2 // For depth of field\n#define BokehShape 0.5 // Changes the bokeh shape between gaussian (1), disk (0.5) and ring (0)\n\n\t// The scene can have a main light (a sphere)\n#define LightPosition vec3(-10,0,10)\n#define LightSize 4.0 // Sphere radius\n\n\t// Materials\n\t// We have to #define these like barbarians because there's no enums in GLSL\n\n#define MatteWhite 0\n#define Silver 1\n#define Gold 2\n#define Glass 3\n#define ColorGlass 4\n#define MatteGrey 5\n#define GlossyBlue 6\n\n// Material definitions:\n// MaterialID (0=standard, 1=light, 2=glass)\n// The next parameters control material properties, depending on type:\n// Standard:\n\t// baseSmoothness, coatSmoothness, coatOpacity, fresnel, coatSaturation;\n// Glass:\n\t// Roughness, \n\nconst Material materials[] = Material[](\n    Material(0, vec3(1.),\t\t0., 0., 0., 0., 0.), // MatteWhite\n    Material(0, vec3(1.),\t\t.7, 0., 0., 0., 0.), // Silver\n    Material(0, vec3(1,0,0),\t.8, 0., 0., 0., 0.), // Gold\n    Material(2, vec3(.2, .2, 1),\t\t0., 0., 0., 0., 0.), // Glass\n    Material(2, vec3(1,0,0),\t.1, 0., 0., 0., 0.), // ColorGlass\n    Material(0, vec3(.7),\t\t0., 0., 0., 0., 0.), // MatteGrey\n    Material(0, vec3(.1,.3,1),\t.1, .7, .1, 1., 0.)  // GlossyBlue\n);\n\n// *** Lighting *** \n\n\t/// Not used atm, but takes a direct light sample\nbool lightSample(in Ray ray, in Intersection hit, in vec3 k, in vec4 i, inout vec3 o) {\n\t\t// Get r to random point on light\n\t\t//\t\t\treturn 0;\n\t\t//\tr.dir=lD(r,k);\n\t\n\tray.dir = LightPosition + (k*2.-1.) * LightSize;\n\tray.dir = normalize(ray.dir - ray.origin.xyz);\n\t\n\t\t// Get cosine of r and normal\n\tfloat c=dot(ray.dir,hit.result.xyz);\n\t\n\t\t// Reject if facing away from light\n\tif(c<=0.) return false;\n\t\n\t\t// Shiny suRayFactoraces have no falloff with angle\n\t\t//\tc = mix(c, 1, hit.material.properties.x);\n\t\t//\tc = pow(c, hit.material.baseSmoothness + 1.);\n\t\n\t\t// See if the r hs a light souRayCounte (can be any light or the sky)\n\thit = intersectScene(ray,k);\n\t\n\tif(hit.material.id==1){\n\t\t\t//\t\tC is measuring cosine of light dir and normal, which is right for diffuse only\n\t\to+=i.xyz*c*hit.material.color*(hit.material.color/(4.*PI*hit.result.w));\n\t\t\t//\t\tlI(hit.material.color,hit.result.w);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n// *** Scene functions\n\n\t/// Distance function for the raymarched elements\n\t/// Returns 2 components, distance and material ID\nvec2 df(vec3 p) {\n    p.y -= 2.001;\n    vec2 d = vec2(3.), e = vec2(4);;\n    d.x = boxDist(p, vec3(0), vec3(1, 1.9, 1));\n    d.x = abs(d.x)-.1;\n    d.x = max(d.x, p.y-.9);\n    e.x = p.y + (\n        sin(p.x * 4. + sin(p.z * 7.) * .5) \n        + sin(p.z * 7. + sin(p.x * 7.) * .5)\n    ) * .1;\n    e.x = max(boxDist(p, vec3(0), vec3(.9,1.8,.9)), e.x) * .7;\n    d = d.x<e.x ? d : e;\n    return d;\n}\n\nvoid rayMarch(in Ray ray, inout Intersection hit, in vec3 k){\n\t\t// Current position\n\tvec3 p = ray.origin.xyz;\n\t\n\t\t// distance field thickness - this clamps the range of p.y (early termination if ray goes out of bounds)\n\t\t// and also steps to bounds if the ray is outside\n\t\t// TODO: It should be bounding volume based really!\n\tfloat dfThickness = 6.;\n\t\n\t\t// Trace to near plane\n\tif (abs(p.y) > dfThickness) {\n\t\tfloat distToPlane = (p.y - (dfThickness * sign(p.y))) / -ray.dir.y;\n\t\tif (distToPlane < 0.) {\n\t\t\t\t// Near plane is behind\n\t\t\treturn; // ray pointing away from zone\n\t\t} else {\n\t\t\t\t// Near plane is in front\n\t\t\tp += ray.dir * distToPlane;\n\t\t}\n\t}\n\t\n\t\t// How much to step the ray by. Inverted when ray is inside\n\tfloat scale = ray.inside?-1.:1.;\n\t\t//\tscale*=1; // If you need shorter steps (inaccurate distance function) set it here\n\t\n\t\t// Marching loop\n\tfor(int i=0; i<150; i++) {\n\t\t\n\t\t\t// Total distance ray travelled (used for early termination and returning intersection distance)\n\t\tfloat totalDist = length(ray.origin.xyz-p);\n\t\t\n\t\t\t// Early termination if ray travelled further than the last intersection, or if out of bounds\n\t\tif(totalDist>hit.result.w || abs(p.y) > dfThickness+Epsilon) return;\n\t\t\n\t\t\t// Get the distance (x = dist, y = material ID)\n\t\tvec2 dist=df(p);\n\t\t\n\t\t\t// Check if we hit a surface\n\t\tif (abs(dist.x) < Epsilon * 0.5) {\n\t\t\t\t// intersection\n\t\t\t\t// Get normals\n\t\t\tvec2 e = vec2(Epsilon * .01, 0.);\n\t\t\tvec3 n=normalize(\n\t\t\t\t\t   vec3(\n\t\t\t\t\t\t  df(p+e.xyy).x-df(p-e.xyy).x,\n\t\t\t\t\t\t  df(p+e.yxy).x-df(p-e.yxy).x,\n\t\t\t\t\t\t  df(p+e.yyx).x-df(p-e.yyx).x\n\t\t\t\t\t\t  )\n\t\t\t\t\t   );\n\t\t\t\n\t\t\t\t// Flip normals if inside object\n\t\t\tif (ray.inside) n = -n;\n            \n    #if NANLEVEL>1\n    nanCheck(n) {n = vec3(0,1,0);} \n    #endif\n\t\t\t\n\t\t\t\t// Set the intersection result\n\t\t\thit.result=vec4(n,totalDist);\n            \n\t\t\t\t// Set the material\n\t\t\thit.material = materials[int(dist.y)];\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\t// Step along ray\n\t\tp+=ray.dir*dist.x*scale;\n\t}\n}\n\n\t/// This is where you set up the scene\nIntersection intersectScene(inout Ray ray, in vec3 k){\n\t\t// Create a material\n\tMaterial mat;\n\t\n\t\t// Create an intersection result. This is the background, so no intersection needed. The normal is\n\t\t// the opposite of the ray dir and distance is 'far away'. Material is undefined, we'll set that later.\n\tIntersection hit = Intersection(vec4(-ray.dir, MAXFLOAT), mat);\n\t\n\t\t// Background lighting materials\n\t\t//\t hit.material = {1,mix(vec3(1.5,.5,.3), vec3(0,0,1), hit.result.y*hit.result.y)}; // pink / blue\n\t\t//\thit.material = {1,abs(hit.result.y)*1.5}; // white with dark horizon\n\thit.material = Material(1,vec3(1.-ray.dir.y)+ray.dir.y * vec3(.4,.5,1.),.0,.0,.0,.0,.0); // Blue sky\n\t\t\t      //\thit.material = {1, mix(mix(vec3(2,.3,.3), vec3(2,.3,0), ray.dir.x*.5+.5),vec3(1), ray.dir.y*.25+.25)}; // orange pink gradient\n\t\t\t      //\thit.material = {1, vec3(2,.3,.3)}; // pink\n\t\t\t      //\thit.material = {1, vec3(2,.3,0)}; // orange\n\t\t\t      //\thit.material = {1,pow(ray.dir.x*.5+.5,4)*4}; // Biased white\n\t\t\t      //\thit.material = {1,pow(max(0., dot(ray.dir, normalize(vec3(1,2,1)))*.5+.5),8)*2+.5}; // Biased white up right\n\t\t\t      //\thit.material = {1, mix(vec3(2,.3,.3), vec3(2,.3,0), ray.dir.x*.5+.5) + pow(max(0., dot(ray.dir, normalize(vec3(1,2,1)))*.5+.5),8)*2}; // orange pink gradient\n\t\t\t      //\thit.material = {1,step(0.5, fract(abs(ray.dir)*5))*2}; // Coloured stripes\n\t\n    // Add some directional light\n    hit.material.color += pow(dot(ray.dir, normalize(vec3(4,4,0))), 60.)*16.;\n    hit.material = Material(1,texture(iChannel1, ray.dir).rgb,.0,.0,.0,.0,.0); // Blue sky\n\t\n    \t// Ground\n\t\t// set material\n\tmat = materials[MatteWhite];\n\tintersectGround(ray, hit, mat);\n    \n    \t// Can check if the material is ground because the material ID is 0\n    if (hit.material.id == 0) {\n        // Apply a texture to the material\n        //check(ray, hit, 0.5);\n        polka(ray,hit,0.5);\n    }\n    \n\t\t// Set material to matte grey\n\tmat = materials[MatteGrey];\n    \n\t\t// Intersect a box\n\tintersectCube(ray, Box(vec3(-6,0,-3), vec3(-4,3.5,-1)), hit, mat);\n\t\n    \t// Set material colour to grey (preserving other values)\n\tmat = materials[GlossyBlue];\n    \n\t\t// Intersect a sphere\n\tintersectSphere(ray, vec4(5,1.5,-2,1.5), hit, mat);\n    \n    // Set material to gold\n    mat = materials[Gold];\n    intersectTriangle(ray, Triangle(vec3(0,0,-2), vec3(3,4,-2), vec3(-3,4,-2)), hit, mat);\n\t\n\t\t// Raymarch (do this last for better performance)\n\trayMarch(ray, hit, k);\n\t        \n    #if NANLEVEL>2\n    nanCheck(hit.result) {hit.result = vec4(0,1,0,MAXFLOAT);} \n    #endif\n    \n\treturn hit;\n}\n\n/// Sets the camera up. uv = screen position, k = random value\nRay setupCamera(Ray ray, vec2 uv, vec3 k){\n\t\t// Basic lens zoom first\n\tuv /= Zoom;\n\t\n\t\t// get the ray dir\n    vec3 camPos = CameraPosition;\n    Rotate(camPos.xz, ((iMouse.x / iResolution.x)*2.-1.)*PI);\n\tray.dir = CameraTarget - camPos;\n\t\n\t\t// f = focal length\n\tfloat f = length(ray.dir), a;\n\t\n\t\t// This transforms k into a random point in a sphere\n\tk = pointOnSphere(k.xy) * pow(k.z, BokehShape);\n\t\n\t\t// Add random sphere point * aperture to camera position for DoF\n\tray.origin.xyz = camPos + k * Aperture;// * length(uv); // Can uncomment this to create soft focus at edges only\n\t\n\t\t// Update the ray direction, then project back from the camera target to the camera plane\n\tray.dir=normalize(CameraTarget-ray.origin.xyz);\n\tray.origin.xyz=CameraTarget-ray.dir*f;\n\t\n\t\t// Transform the camera to account for uv\n\ta = inversesqrt(1. - ray.dir.y * ray.dir.y);\n\tmat3x3 c = mat3x3(\n\t\tvec3(-ray.dir.z, 0, ray.dir.x) * a,\n\t\tvec3(-ray.dir.x * ray.dir.y, 1. - ray.dir.y * ray.dir.y, -ray.dir.y * ray.dir.z) * a,\n\t\t-ray.dir\n\t);\n\ta=length(uv);\n\t\n\t\t// Scaling for fisheye distortion\n\tf = a * Fisheye;\n\t\n\t\t// Last bit of uv transform\n\tray.dir=normalize(c*mix(vec3(uv,-1),vec3(uv/a*sin(f),-cos(f)),.4));\n        \n    #if NANLEVEL>3\n    nanCheck(ray.dir) {ray.dir = vec3(0,0,1);} \n    #endif     \n    #if NANLEVEL>4\n    nanCheck(ray.origin) {ray.origin = vec4(0,0,-10,0);} \n    #endif\n    \n    return ray;\n}\n\nvec3 traceRay(vec2 uv, float pixelSize, float t, int rayCount, Ray ray) {\n\t\n\tvec3 lightSum = vec3(0), // Light sum, we add lights to this and return it at the end\n\tk=hash(vec3(uv+t,t)); // initial random value\n\t\n\t\t// Go through rays\n\tfor(int j=0; j<rayCount; j++){\n\t\tray.inside = false; // Set to 1 if the camera is inside a glass object!\n\t\t\n\t\t\t// This gives us 2 values of stratified sampling plus one random value on z\n\t\tk.xy = vec2(\n\t\t\t      mod(float(j), RayFactor),\n\t\t\t      floor(float(j) / RayFactor)\n\t\t\t      ) / RayFactor + k.xy / RayFactor;\n             \n    #if NANLEVEL>5\n    nanCheck(k) {k = vec3(0.);} \n    #endif\n\t\t\n\t\t\t// To save memory and registers, use append the time to the ray origin\n\t\tray.origin.w=t;\n\t\t\n\t\t\t// setup camera, get ray\n\t\t\t// We add a small random value to uv here, this gives us anti-aliasing\n\t\tray = setupCamera(ray, uv + k.xy * pixelSize, k);\n\t\t\n\t\t\t// This stores the ray colouration. If the ray hits a surface, this is multiplied by the surface colour.\n\t\t\t// That stores the light absorbed by each surface the ray intersects\n\t\t\t// If we hit a light, we just multiply the light colour by the ray colouration to get a light value for the whole path\n\t\t\t// The w value stores hue if we do spectral rendering\n\t\tvec4 rayColouration = vec4(1,1,1,0);\n\t\t\n\t\t\t// iterate through Bounces\n\t\tfor(int bounce=0; bounce<Bounces; bounce++) {\n\t\t\t\t// intersect and move ray\n\t\t\tIntersection hit = intersectScene(ray, k);\n\t\t\t\n\t\t\t\t// If the ray is inside an object, subtract the material colour scaled by the distance the ray just travelled\n\t\t\t\t// This gives us accurate coloured glass, including when the ray bounces multiple times inside the object\n\t\t\tif(ray.inside) {\n\t\t\t\trayColouration.xyz = max(vec3(0), rayColouration.xyz - (hit.material.color * hit.result.w));\n\t\t\t}\n             \n    #if NANLEVEL>6\n    nanCheck(rayColouration) {rayColouration = vec4(1,0,1,1);} \n    #endif\n\t\t\t\n\t\t\t\t// Move along ray to surface\n\t\t\tray.origin.xyz += ray.dir * hit.result.w;\n             \n    #if NANLEVEL>7\n    nanCheck(ray.origin) {ray.origin = vec4(0,0,-10,0);} \n    #endif\n\t\t\t\n\t\t\t\t// Apply the material\n\t\t\t\t// Light\n\t\t\tif(hit.material.id == 1) {\n\t\t\t\t\t// Add light and terminate the ray\n\t\t\t\tlightSum += hit.material.color * rayColouration.xyz;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t\t// Glass\n\t\t\tif(hit.material.id == 2) {\n\t\t\t\tapplyGlass(ray, hit, k, rayColouration);\n\t\t\t}\n\t\t\t\n\t\t\t\t// Standard material\n\t\t\tif(hit.material.id == 0) {\n\t\t\t\tapplyMaterial(ray, hit, k, rayColouration, lightSum);\n\t\t\t}\n\t\t\t\n\t\t\t\t// Early exit if h light or r nearly expired\n\t\t\t\t// This improves performance in scenes with dark surfaces, as the ray gets terminated if it's too dark\n\t\t\t\t//\t\t\tif(all(rayColouration.xyz < .1)) break;\n\t\t\t\n\t\t\t\t// Sometimes useful for debug...\n\t\t\t\t//\t\t\tif (Bounces >= 2.0) break;\n\t\t}\n\t\t\n\t\t\t// New hash value for next ray\n\t\tk=hash(k);\n\t}\n    \nif (any(isnan(lightSum))) lightSum = vec3(0);\n\treturn lightSum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    // Normalized pixel coordinates (from 0 to 1)\n\tvec2 res = iResolution.xy;\n    vec2 uv = fragCoord / res;\n    \n    // Stole from yx\n    // grab the previous color so we can iteratively render.\n   \tfragColor = texture(iChannel0, uv);\n             \n    #if NANLEVEL>8\n    nanCheck(fragColor) {fragColor = vec4(0,1,0,1);} \n    #endif\n    \n    // Stolen from yx\n    // reset buffer if we're clicking\n    bool mouseDown = iMouse.z > 0.;\n    if (mouseDown) fragColor *= 0.;\n    \n    int index = iFrame % (Tilesize * Tilesize);\n    int x = iFrame % Tilesize, y = (iFrame / Tilesize) % Tilesize;\n    vec2 tileSize = res / float(Tilesize);\n    vec2 tileCenter = vec2(x, y) * tileSize + (tileSize / 2.);\n    vec2 outsideTile = max(vec2(0.), abs(fragCoord - tileCenter) - (tileSize / 2.));\n    if (outsideTile.x + outsideTile.y == 0. || mouseDown) {\n    \tuv = (vec2(fragCoord*2.)-res)/res.y;\n    \n\t\tRay a;\n    \n\t\tvec3 p = traceRay(\n\t\t\t\t    uv,\n\t\t\t\t    4. / res.x, // AA\n\t\t\t\t   iTime,\n\t\t\t\t    int(RayCount),\n\t\t\t\t    a\n\t\t\t\t    );\n\t\tp /= RayCount;\n\n//p = pow(p*pow(saturate(2.1-length(uv)),.5) / RayCount, vec3(1. / 2.2));\n\n//if (any(isnan(p))) p = vec3(1,0,1);\n//if (any(isinf(p))) p = vec3(0,1,1);\n    \tfragColor += vec4(p, 1.0);\n    } \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}