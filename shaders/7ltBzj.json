{
    "Shader": {
        "info": {
            "date": "1690583393",
            "description": "Nicely behaved (injective) 2D Bézier patches have the property that every point is within its boundary curves.",
            "flags": 0,
            "hasliked": 0,
            "id": "7ltBzj",
            "likes": 10,
            "name": "2D Cubic Bézier patch",
            "published": 3,
            "tags": [
                "bezier",
                "inverse",
                "subdivision",
                "patch"
            ],
            "usePreview": 1,
            "username": "Reynolds",
            "viewed": 356
        },
        "renderpass": [
            {
                "code": "#define ZERO min(0,iFrame)\n#define maxIterations 10\n\n//From Trisomie21\n//But instead of his cancellation fix i'm using a newton iteration\nint solve_cubic(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\tr[0] = offset + u * (m + m);\n    r[1] = offset - u * (n + m);\n    r[2] = offset + u * (n - m);\n\n\tvec3 f = ((r + a) * r + b) * r + c;\n\tvec3 f1 = (3. * r + 2. * a) * r + b;\n\n\tr -= f / f1;\n\n\treturn 3;\n}\n\n//From Trisomie21\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n\t// normal form: x^2 + px + q = 0\n\tfloat p = coeffs[1] / 2.;\n\tfloat q = coeffs[0];\n\n\tfloat D = p * p - q;\n\n\tif (D < 0.){\n\t\treturn 0;\n\t}\n\telse{\n\t\troots[0] = -sqrt(D) - p;\n\t\troots[1] = sqrt(D) - p;\n\n\t\treturn 2;\n\t}\n}\n\n//From Trisomie21\nint cubic_bezier_int_test(vec2 p0, vec2 p1, vec2 p2, vec2 p3, vec2 uv){\n\n\tfloat cu = (-p0.y + 3. * p1.y - 3. * p2.y + p3.y);\n\tfloat qu = (3. * p0.y - 6. * p1.y + 3. * p2.y);\n\tfloat li = (-3. * p0.y + 3. * p1.y);\n\tfloat co = p0.y - uv.y;\n\n\tvec3 roots = vec3(1e38);\n\tint n_roots;\n    \n    int n_ints=0;\n        \n    if(uv.x<min(min(p0.x,p1.x),min(p2.x,p3.x))){\n\t\tif(uv.y>=min(p0.y,p3.y) && uv.y<=max(p0.y,p3.y)){\n\t\t\tn_ints=1;\n\t\t}\n\t}\n    else{\n    \n        if(abs(cu) < .00001){\n            n_roots = solve_quadric(vec2(co/qu,li/qu),roots.xy);\n        }\n        else{\n            n_roots = solve_cubic(vec3(co/cu,li/cu,qu/cu),roots);\n        }\n\n        for(int i=ZERO;i<n_roots;i++){\n            if(roots[i] >= 0.0 && roots[i] <= 1.){\n                float x_pos = -p0.x + 3. * p1.x - 3. * p2.x + p3.x;\n                x_pos = x_pos * roots[i] + 3. * p0.x - 6. * p1.x + 3. * p2.x;\n                x_pos = x_pos * roots[i] + -3. * p0.x + 3. * p1.x;\n                x_pos = x_pos * roots[i] + p0.x;\n\n                if(x_pos > uv.x){\n                    n_ints++;\n                }\n            }\n        }\n    }\n\n\treturn n_ints;\n}\n\nvec2 bez(vec2 A, vec2 B, vec2 C, vec2 D, float t)\n{\n    return mix(\n            mix(mix(A, B, t), mix(B, C, t), t),\n            mix(mix(B, C, t), mix(C, D, t), t), t);\n}\n\nvec2 thirdCp(vec2 A, vec2 B, vec2 C, vec2 D, float t)\n{\n    return mix(mix(A, B, t), mix(B, C, t), t);\n}\n\nvec2 fifthCp(vec2 A, vec2 B, vec2 C, vec2 D, float t)\n{\n    return mix(mix(B, C, t), mix(C, D, t), t);\n}\n\nvec2 evalPatch(vec2 uv, vec2 b00, vec2 b10, vec2 b20, vec2 b30, vec2 b01, vec2 b11, vec2 b21, vec2 b31, vec2 b02, vec2 b12, vec2 b22, vec2 b32, vec2 b03, vec2 b13, vec2 b23, vec2 b33) {\n    vec2 bu0 = bez(b00, b10, b20, b30, uv.x);\n    vec2 bu1 = bez(b01, b11, b21, b31, uv.x);\n    vec2 bu2 = bez(b02, b12, b22, b32, uv.x);\n    vec2 bu3 = bez(b03, b13, b23, b33, uv.x);\n\n    return bez(bu0, bu1, bu2, bu3, uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y*2.0 - vec2(1.3, 0.5);\n    \n    //perturb base control points randomly\n    vec2 B00 = vec2(0.0, 0.0) +0.05*vec2(cos(iTime/2.6), sin(iTime/0.5));\n    vec2 B10 = vec2(1.0/3.0, 0.0) + 0.1*vec2(cos(iTime/2.6), 2.0*sin(iTime/0.5));\n    vec2 B20 = vec2(2.0/3.0, 0.0) - 0.1*vec2(cos(iTime/0.7), 2.0*sin(iTime));\n    vec2 B30 = vec2(1.0, 0.0) + +0.05*vec2(cos(iTime/0.5), sin(iTime/2.6));\n   \n    vec2 B01 = vec2(0.0, 1.0/3.0) + 0.1*vec2(cos(iTime/2.5), sin(iTime));\n    vec2 B11 = vec2(1.0/3.0, 1.0/3.0) + 0.1*vec2(cos(iTime), sin(iTime));\n    vec2 B21 = vec2(2.0/3.0, 1.0/3.0) + 0.1*vec2(cos(iTime/1.3), sin(iTime/0.7));\n    vec2 B31 = vec2(1.0, 1.0/3.0) + 0.1*vec2(cos(iTime), sin(iTime));\n    \n    vec2 B02 = vec2(0.0, 2.0/3.0) - 0.1*vec2(cos(iTime/0.7), 2.0*sin(iTime));\n    vec2 B12 = vec2(1.0/3.0, 2.0/3.0) + 0.1*vec2(cos(iTime/0.3), sin(iTime/1.1));\n    vec2 B22 = vec2(2.0/3.0, 2.0/3.0) + 0.1*vec2(cos(iTime), sin(iTime));\n    vec2 B32 = vec2(1.0, 2.0/3.0) - 0.1*vec2(cos(iTime/0.7), 2.0*sin(iTime));\n    \n    vec2 B03 = vec2(0.0, 1.0) + 0.05*vec2(cos(iTime/2.6), sin(iTime/0.5));\n    vec2 B13 = vec2(1.0/3.0, 1.0) + 0.1*vec2(cos(iTime), sin(iTime));\n    vec2 B23 = vec2(2.0/3.0, 1.0) + 0.1*vec2(cos(iTime), sin(iTime));\n    vec2 B33 = vec2(1.0, 1.0) + 0.05*vec2(cos(iTime/2.6), sin(iTime/0.5));\n  \n    vec2 b00 = B00;\n    vec2 b10 = B10;\n    vec2 b20 = B20;\n    vec2 b30 = B30;\n   \n    vec2 b01 = B01;\n    vec2 b11 = B11;\n    vec2 b21 = B21;\n    vec2 b31 = B31;\n    \n    vec2 b02 = B02;\n    vec2 b12 = B12;\n    vec2 b22 = B22;\n    vec2 b32 = B32;\n    \n    vec2 b03 = B03;\n    vec2 b13 = B13;\n    vec2 b23 = B23;\n    vec2 b33 = B33;\n    \n    //switch for colour interpolation to texture mode\n    int mode = 0;\n    float changeTime = 2.*float(maxIterations);\n    if(mod(iTime, changeTime) > changeTime * 0.50)\n        mode = 1;\n\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec2 t = vec2(0.5);\n    float d;\n    //new control point positions\n    vec2 b00_n, b10_n, b20_n, b30_n, b01_n, b11_n, b21_n, b31_n, b02_n, b12_n, b22_n, b32_n, b03_n, b13_n, b23_n, b33_n;\n    \n    float f = 0.5;\n    \n    vec2 miu = vec2(0.0);\n    vec2 mau = vec2(1.0);\n\n    int s0 = cubic_bezier_int_test(b00, b10, b20, b30, uv);\n    s0 += cubic_bezier_int_test(b30, b31, b32, b33, uv);\n    s0 += cubic_bezier_int_test(b33, b23, b13, b03, uv);\n    s0 += cubic_bezier_int_test(b03, b02, b01, b00, uv);\n\n    int iterations = maxIterations;\n    iterations = max(1, int(iTime) % maxIterations);\n\n    if(s0 % 2 == 1) { //first test whether uv is bound by 4 main boundary curves\n        col = vec3(1.0);\n        for(int i = 0; i < iterations; ++i) {\n            f = f * 0.5;\n\n            vec2 bu0 = bez(b00, b10, b20, b30, 0.5);\n            vec2 bu1 = bez(b01, b11, b21, b31, 0.5);\n            vec2 bu2 = bez(b02, b12, b22, b32, 0.5);\n            vec2 bu3 = bez(b03, b13, b23, b33, 0.5);\n\n            vec2 bv0 = bez(b00, b01, b02, b03, 0.5);\n            vec2 bv1 = bez(b10, b11, b12, b13, 0.5);\n            vec2 bv2 = bez(b20, b21, b22, b23, 0.5);\n            vec2 bv3 = bez(b30, b31, b32, b33, 0.5);\n\n            vec2 C = bez(bu0, bu1, bu2, bu3, 0.5);\n\n            col = vec3(1.0);\n\n            //lo\n            vec2 b10_lo = 0.5*(b00 + b10);\n            vec2 b20_lo = thirdCp(b00, b10, b20, b30, 0.5);\n\n            vec2 b01_lo = 0.5*(b00 + b01);\n            vec2 b02_lo = thirdCp(b00, b01, b02, b03, 0.5);\n\n            vec2 b31_lo = 0.5*(bu0 + bu1);\n            vec2 b32_lo = thirdCp(bu0, bu1, bu2, bu3, 0.5);\n\n            vec2 b13_lo = 0.5*(bv0 + bv1);\n            vec2 b23_lo = thirdCp(bv0, bv1, bv2, bv3, 0.5);\n\n            //lb\n            vec2 b01_lb = fifthCp(b00, b01, b02, b03, 0.5);\n            vec2 b02_lb = 0.5 * (b02 + b03);\n\n            vec2 b13_lb = 0.5 * (b03 + b13);\n            vec2 b23_lb = thirdCp(b03, b13, b23, b33, 0.5);\n\n            vec2 b31_lb = fifthCp(bu0, bu1, bu2, bu3, 0.5);\n            vec2 b32_lb = 0.5 * (bu3 + bu2);\n\n            //rb\n            vec2 b13_rb = fifthCp(b03, b13, b23, b33, 0.5);\n            vec2 b23_rb = 0.5*(b23 + b33);\n\n            vec2 b31_rb = fifthCp(b30, b31, b32, b33, 0.5);\n            vec2 b32_rb = 0.5*(b32 + b33);\n\n            vec2 b10_rb = fifthCp(bv0, bv1, bv2, bv3, 0.5);\n            vec2 b20_rb = 0.5*(bv2 + bv3);\n\n            //ro\n            vec2 b10_ro = fifthCp(b00, b10, b20, b30, 0.5);\n            vec2 b20_ro = 0.5*(b20 + b30);\n\n            vec2 b31_ro = 0.5*(b30 + b31);\n            vec2 b32_ro = thirdCp(b30, b31, b32, b33, 0.5);\n\n            //we know it is on the patch check three quadrants to find out in which one we are\n            int s_lo = cubic_bezier_int_test(b00, b10_lo, b20_lo, bu0, uv);\n            s_lo += cubic_bezier_int_test(bu0, b31_lo, b32_lo, C, uv);\n            s_lo += cubic_bezier_int_test(C, b23_lo, b13_lo, bv0, uv);\n            s_lo += cubic_bezier_int_test(bv0, b02_lo, b01_lo, b00, uv);\n\n            int s_lb = cubic_bezier_int_test(bv0, b13_lo, b23_lo, C, uv);\n            s_lb += cubic_bezier_int_test(C, b31_lb, b32_lb, bu3, uv);\n            s_lb += cubic_bezier_int_test(bu3, b23_lb, b13_lb, b03, uv);\n            s_lb += cubic_bezier_int_test(b03, b02_lb, b01_lb, bv0, uv);\n\n            int s_rb = cubic_bezier_int_test(C, b10_rb, b20_rb, bv3, uv);\n            s_rb += cubic_bezier_int_test(bv3, b31_rb, b32_rb, b33, uv);\n            s_rb += cubic_bezier_int_test(b33, b23_rb, b13_rb, bu3, uv);\n            s_rb += cubic_bezier_int_test(bu3, b32_lb, b31_lb, C, uv);\n\n            vec2 small_c = 0.25*(b11 + b21 + b22 + b12);\n\n            if(s_lo % 2 == 1) {\n                //left bottom\n                col = vec3(1.0, 0.0, 0.0);\n                miu = miu;\n                mau = mau - f;\n                \n                t = vec2(t.x - f, t.y - f);\n\n                vec2 lo = 0.25*(b00 + b10 + b01 + b11);\n                vec2 ro = 0.25*(b10 + b20 + b21 + b11);\n                vec2 lb = 0.25*(b01 + b11 + b12 + b02);\n                \n                //compute control points of quadrant\n                b00_n = b00;\n                b10_n = b10_lo;\n                b20_n = b20_lo;\n                b30_n = bu0;\n\n                b01_n = b01_lo;\n                b11_n = lo;\n                b21_n = 0.5 * (lo + ro); \n                b31_n = b31_lo;\n\n                b02_n = b02_lo;\n                b12_n = 0.5 * (lo + lb);\n                b22_n = 0.25 * (lo + ro + lb + small_c);\n                b32_n = b32_lo;\n\n                b03_n = bv0;\n                b13_n = b13_lo;\n                b23_n = b23_lo;\n                b33_n = C;\n            }\n            else if(s_lb % 2 == 1) {\n                //right bottom\n                col = vec3(0.0, 0.0, 1.0);\n                miu = vec2(miu.x - f, miu.y);\n                mau = vec2(mau.x, mau.y - f);\n\n                t = vec2(t.x - f, t.y + f);\n\n                vec2 lo = 0.25*(b01 + b11 + b12 + b02);\n                vec2 lb = 0.25*(b02 + b12 + b13 + b03);\n                vec2 rb = 0.25*(b12 + b22 + b23 + b13);\n\n                //compute control points of quadrant\n                b00_n = bv0;\n                b10_n = b13_lo;\n                b20_n = b23_lo;\n                b30_n = C;\n\n                b01_n = b01_lb;\n                b11_n = 0.5*(lb + lo);\n                b21_n = 0.25*(lo + lb + rb + small_c); \n                b31_n = b31_lb;\n\n                b02_n = b02_lb;\n                b12_n = lb;\n                b22_n = 0.5*(lb + rb);\n                b32_n = b32_lb;\n\n                b03_n = b03;\n                b13_n = b13_lb;\n                b23_n = b23_lb;\n                b33_n = bu3;\n            }\n            else if(s_rb % 2 == 1) {\n                //right top\n                col = vec3(1.0, 0.0, 1.0);\n                miu = vec2(miu.x + f, miu.y + f);\n                mau = vec2(mau.x, mau.y);\n\n                t = vec2(t.x + f, t.y + f);\n\n                vec2 lb = 0.25*(b12 + b22 + b23 + b13);\n                vec2 ro = 0.25*(b21 + b31 + b32 + b22);\n                vec2 rb = 0.25*(b22 + b32 + b33 + b23);\n\n                //compute control points of quadrant\n                b00_n = C;\n                b10_n = b10_rb;\n                b20_n = b20_rb;\n                b30_n = bv3;\n\n                b01_n = b31_lb;\n                b11_n = 0.25*(lb + ro + rb + small_c);\n                b21_n = 0.5 * (rb + ro); \n                b31_n = b31_rb;\n\n                b02_n = b32_lb;\n                b12_n = 0.5*(rb + lb);\n                b22_n = rb;\n                b32_n = b32_rb;\n\n                b03_n = bu3;\n                b13_n = b13_rb;\n                b23_n = b23_rb;\n                b33_n = b33;\n            }\n            else {\n                //left top\n                col = vec3(0.0, 1.0, 0.0);\n                miu = vec2(miu.x, miu.y + f);\n                mau = vec2(mau.x - f, mau.y);\n\n                t = vec2(t.x + f, t.y - f);\n\n                vec2 lo = 0.25*(b10 + b20 + b21 + b11);\n                vec2 ro = 0.25*(b20 + b30 + b31 + b21);\n                vec2 rb = 0.25*(b21 + b31 + b32 + b22);\n\n                //compute control points of quadrant\n                b00_n = bu0;\n                b10_n = b10_ro;\n                b20_n = b20_ro;\n                b30_n = b30;\n\n                b01_n = b31_lo;\n                b11_n = 0.5*(lo + ro);\n                b21_n = ro; \n                b31_n = b31_ro;\n\n                b02_n = b32_lo;\n                b12_n = 0.25*(lo + ro + rb + small_c);\n                b22_n = 0.5*(ro + rb);\n                b32_n = b32_ro;\n\n                b03_n = C;\n                b13_n = b10_rb;\n                b23_n = b20_rb;\n                b33_n = bv3;\n            }\n\n            \n            b00 = b00_n;\n            b10 = b10_n;\n            b20 = b20_n;\n            b30 = b30_n;\n\n            b01 = b01_n;\n            b11 = b11_n;\n            b21 = b21_n;\n            b31 = b31_n;\n\n            b02 = b02_n;\n            b12 = b12_n;\n            b22 = b22_n;\n            b32 = b32_n;\n\n            b03 = b03_n;\n            b13 = b13_n;\n            b23 = b23_n;\n            b33 = b33_n;\n        }\n    }\n       \n    //compute parametric corners of subpatch\n    vec2 h = vec2(f * 0.5);\n    vec2 miuv = t - h;\n    vec2 mauv = t + h;\n    //do something with it to approximate interpolation? \n    //inverse bilinear does not work because there will still be discontinuties \n    \n    \n    vec3 c1 = vec3(1.0, 0.0, 0.0);\n    vec3 c2 = vec3(0.0, 1.0, 0.0);\n    vec3 c3 = vec3(0.0, 0.0, 1.0);\n    vec3 c4 = vec3(1.0, 1.0, 0.0);\n    \n    //interpolate colour\n    vec3 cd = mix(mix(c1, c2, t.x), \n                   mix(c3, c4, t.x), t.y); \n\n    //comment this to show quadrant debug colours\n    col = cd;\n                   \n    //show control points\n    if(length(uv - B00) < 0.01) col = vec3(0.0);\n    if(length(uv - B10) < 0.01) col = vec3(0.0);\n    if(length(uv - B20) < 0.01) col = vec3(0.0);\n    if(length(uv - B30) < 0.01) col = vec3(0.0);\n    \n    if(length(uv - B01) < 0.01) col = vec3(0.0);\n    if(length(uv - B11) < 0.01) col = vec3(0.0);\n    if(length(uv - B21) < 0.01) col = vec3(0.0);\n    if(length(uv - B31) < 0.01) col = vec3(0.0);\n    \n    if(length(uv - B02) < 0.01) col = vec3(0.0);\n    if(length(uv - B12) < 0.01) col = vec3(0.0);\n    if(length(uv - B22) < 0.01) col = vec3(0.0);\n    if(length(uv - B32) < 0.01) col = vec3(0.0);\n    \n    if(length(uv - B03) < 0.01) col = vec3(0.0);\n    if(length(uv - B13) < 0.01) col = vec3(0.0);\n    if(length(uv - B23) < 0.01) col = vec3(0.0);\n    if(length(uv - B33) < 0.01) col = vec3(0.0);\n    \n    if(mode == 1)\n        col = textureLod(iChannel0, t, 0.).xyz  ;  \n         \n        \n    fragColor = vec4(col, 1.0);\n    //uncomment to show parametrisation\n    //fragColor = vec4(vec3(t, 0.0), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}