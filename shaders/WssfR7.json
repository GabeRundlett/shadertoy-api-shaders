{
    "Shader": {
        "info": {
            "date": "1587930876",
            "description": "Just a morphing cube with some modifiers applied and simple reflections. Created while learning Raymarching.",
            "flags": 0,
            "hasliked": 0,
            "id": "WssfR7",
            "likes": 2,
            "name": "Cubething",
            "published": 3,
            "tags": [
                "raymarching",
                "cube"
            ],
            "usePreview": 0,
            "username": "donnerbrenn",
            "viewed": 371
        },
        "renderpass": [
            {
                "code": "float detail=10000.;\nvec2 uv;\nvec3 color;\n\nstruct RR\n{\n      vec3 col;\n      vec3 pos;\n      bool hit;\n};\n\nvec3 rotate(vec3 p,vec3 t)\n{\n      float c=cos(t.x),s=sin(t.x);\n      mat3 m=mat3(vec3(1,0,0),vec3(0,c,-s),vec3(0,s,c));\n\n      c=cos(t.y);s=sin(t.y);\n      m*=mat3(vec3(c,0,s),vec3(0,1,0),vec3(-s,0,c));\n\n      c=cos(t.z);s=sin(t.z);\n      m*=mat3(vec3(c,-s,0),vec3(s,c,0),vec3(0,0,1));\n\n      return m*p;\n}\n\n\nvec4 _min(vec4 a, vec4 b)\n{\n      return a.w<b.w?a:b;\n}\n\nvec4 _max(vec4 a, vec4 b, bool cut)\n{\n      b.w*=cut?-1.:1.;   \n      return a.w<b.w?b:a;\n}\n\nvec4 softmin(vec4 f1, vec4 f2, float val)\n{\n      if(val==.0)\n            return _min (f1,f2);\n      vec4 res;\n      float e = max(val - abs(f1.w - f2.w), 0.0);\n      res=_min(f1, f2);\n      \n      res.w-=e*e*0.25 / val;\n      res.xyz=mix(f1.xyz,f2.xyz,clamp(abs(f1.w-res.w)/abs(f1.w - f2.w),0.,1.));\n      return res;\n}\n\nvec4 sdSphere(vec3 p, float r, vec3 color)\n{\n      return vec4(color,length(p)-r);\n}\n\nvec4 sdRoundBox( vec3 p, vec3 b, float r, vec3 color)\n{\n  vec3 q = abs(p) - b;\n  return vec4(color,length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r);\n}\n\nvec4 sdCross(vec3 p, vec2 s, float r, vec3 color)\n{\n      return _min(_min(sdRoundBox(p,s.xyy,r,color),sdRoundBox(p,s.yxy,r,color)),sdRoundBox(p,s.yyx,r,color));\n}\n\nvec4 map(vec3 p)\n{\n      vec4 ground=sdRoundBox(rotate(p+vec3(0,2.5,0),vec3(1.,0.,0.)),vec3(40,40,.1),.0,vec3(.2,.2,.2));\n      p=rotate(p,vec3(iTime*.5,iTime*.5,.5));\n      vec4 final=sdCross(p,vec2(4.5,.89),.21,vec3(.1,.1,.75));\n      vec4 box=sdRoundBox(p,vec3(1.),.25,vec3(.1,.75,.1));\n      final=_max(box,final, true);\n      final=_min(final,sdRoundBox(p,vec3(.0),.4,vec3(.7,.0,.0)));\n      final=mix(box,final,sin(iTime)*.5+.5);\n      return _min(final,ground);\n}\n\nvec3 normal(vec3 p)\n{\n      vec2 eps=vec2(.005,0.);\n      return normalize(vec3(map(p+eps.xyy).w-map(p-eps.xyy).w,\n                            map(p+eps.yxy).w-map(p-eps.yxy).w,\n                            map(p+eps.yyx).w-map(p-eps.yyx).w));\n}\n\nfloat lightRender(vec3 n,vec3 l, vec3 v, float strength)\n{\n      return ((dot(n,normalize(l))*.5+.5)+pow(max(dot(v,reflect(normalize(l),n)),0.),128.))*strength;\n}\n\nRR march(vec3 ro, vec3 rd, float maxl, float aprox)\n{\n      rd=normalize(rd);\n      RR res;\n      res.pos=ro;\n      res.hit=false;\n      vec4 d;\n      for(float l=.0; l<maxl;)\n      {\n            d=map(res.pos);\n            if(d.w<aprox)\n            {\n                  res.hit=true;\n                  res.col=d.xyz;\n                  break;\n            }\n            res.pos+=rd*d.w;\n            l+=d.w;\n      }\n      return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n      uv=gl_FragCoord.xy/vec2(iResolution.x)-vec2(.5,.3);\n      vec3 ro=vec3(.0,.0,-10.5); \n      vec3 n;\n      vec3 rd=normalize(vec3(uv,1.));\n      float light=.0;\n\n      vec3 l1=vec3(-2.8,5.,-3.0);\n      vec3 l2=vec3(-.3,2.15,-2.25);\n      vec3 l3=vec3(-4.2,1.5,-2.25);\n\n      RR res=march(ro,rd,40.,1./detail);\n\n      if (res.hit==true)\n      {\n            n=normal(res.pos);\n            light=lightRender(n,l1,rd,.4);\n            light+=lightRender(n,l2,rd,.350);\n            light+=lightRender(n,l3,rd,.125);\n\n            color=res.col*light;\n            if(res.hit)\n            {\n                  res.pos-=rd*.001;\n                  vec3 nrd=reflect(rd,n);\n                  RR reflection=march(res.pos,nrd,20.,3./detail);\n                  n=normal(reflection.pos);\n                  light=lightRender(n,l1,nrd,.4);\n                  light+=lightRender(n,l2,nrd,.350);\n                  light+=lightRender(n,l3,nrd,.125);\n                  reflection.col*=light;\n\n                  color=mix(color, reflection.col,.125);\n\n                  RR shadow=march(res.pos,l1-res.pos,20.,1./detail);\n                  if(shadow.hit)\n                        color*=.5;\n            }\n      }\n    color*=color;\n    color = pow (color,vec3(1.0 / 2.2)); // gamma correction\n   \n    fragColor=vec4(color,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}