{
    "Shader": {
        "info": {
            "date": "1609961394",
            "description": "We use polar coordinates to create such symmetric patterns\nChange the constant parameters of the program to see other variants.",
            "flags": 0,
            "hasliked": 0,
            "id": "wtdyW2",
            "likes": 3,
            "name": "kaleidoscope of noise patterns",
            "published": 3,
            "tags": [
                "2d",
                "noise",
                "kaleidoscope",
                "pattern",
                "polar",
                "bilinear",
                "generativeart",
                "creativecoding"
            ],
            "usePreview": 0,
            "username": "AI",
            "viewed": 307
        },
        "renderpass": [
            {
                "code": "const float PI = 3.141592658;\nconst float TWOPI = 2.0 * PI;\n\n// pseudo-random function, returns value between [0.,1.]\nfloat rand (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(31.7667,14.9876)))\n                 * 833443.123456);\n}\n\n//bilinear value noise function\nfloat bilinearNoise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners of a 2D square\n    float f00 = rand(i);\n    float f10 = rand(i + vec2(1.0, 0.0));\n    float f01 = rand(i + vec2(0.0, 1.0));\n    float f11 = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = smoothstep(0.,1.,(1.-f));\n\treturn u.x*u.y*f00+(1.-u.x)*u.y*f10+\n    u.x*(1.-u.y)*f01+(1.-u.x)*(1.-u.y)*f11;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 uv =fragCoord.xy/ iResolution.xy;\n  //from Cartesian to polar coordinates\n  float scale=3.;\n  uv=fract(scale*uv)-.5;\n  float radius = length(uv);\n  float angle = atan(uv.y, uv.x);\n  //change Nsections using horizontal movement of mouse\n    float Nsections=20.;//-15.*iMouse.x/iResolution.x;\n  //create Nsections which are identical\n  float angleM = mod(angle, TWOPI/Nsections);\n  //make each section symmetric along its bisector\n  angleM = abs(angleM -PI/Nsections);\n  //back to Cartesian coordinates\n  uv = radius*vec2(cos(angleM),sin(angleM));\n  uv=sin(uv+.04*iTime);\n  vec3 color=vec3(bilinearNoise(100.*uv),bilinearNoise(75.*uv),bilinearNoise(50.*uv));\n  fragColor = vec4(color,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}