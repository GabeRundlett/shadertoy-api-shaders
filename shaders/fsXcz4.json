{
    "Shader": {
        "info": {
            "date": "1641757410",
            "description": "Experiment with hue preserving tonemapping/output transforms. \n\nScaling chroma based on the derivative of the tone curve. This behave similarly to per channel tone mapping for low saturation colors, but preserves hue for saturated colors.",
            "flags": 0,
            "hasliked": 0,
            "id": "fsXcz4",
            "likes": 25,
            "name": "Tonemapping experiment",
            "published": 3,
            "tags": [
                "tonemapping",
                "tonemap",
                "oklab"
            ],
            "usePreview": 0,
            "username": "bjornornorn",
            "viewed": 2292
        },
        "renderpass": [
            {
                "code": "// Copyright(c) 2022 Bj√∂rn Ottosson\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this softwareand associated documentation files(the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and /or sell copies\n// of the Software, and to permit persons to whom the Software is furnished to do\n// so, subject to the following conditions :\n// The above copyright noticeand this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nconst float softness_scale = 0.2; // controls softness of RGB clipping\nconst float offset = 0.75; // controls how colors desaturate as they brighten. 0 results in that colors never fluoresce, 1 in very saturated colors \nconst float chroma_scale = 1.2; // overall scale of chroma\n\nconst mat3 rec2020toSrgb = mat3(\n    1.6603034854, -0.5875701425, -0.0728900602,\n    -0.1243755953,  1.1328344814, -0.0083597372,\n    -0.0181122800, -0.1005836085,  1.1187703262);\n\nconst mat3 displayP3toSrgb = mat3(\n    1.2248021163, -0.2249112615, -0.0000475721,\n    -0.0419281049,  1.0420298967, -0.0000026429,\n    -0.0196088092, -0.0786321233,  1.0983153702);\n\nconst mat3 SrgbToSrgb = mat3(\n    1.0,0.0,0.0,\n    0.0,1.0,0.0,\n    0.0,0.0,1.0);\n    \nconst mat3 sourceColorSpaceToSrgb = SrgbToSrgb; // change for different input color space\n\n// Origin: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n// Using this since it was easy to differentiate, same technique would work for any curve \nvec3 s_curve(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    x = max(x, 0.0);\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.0,1.0);\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    \n    x = max(x, 0.0);\n    vec3 r = (x*(c*x + d) + e);\n    return (a*x*(d*x + 2.0*e) + b*(e - c*x*x))/(r*r);\n}\n\nvec3 tonemap_per_channel(vec3 c)\n{\n    return s_curve(c);\n}\n\nvec2 findCenterAndPurity(vec3 x)\n{\n    // Matrix derived for (c_smooth+s_smooth) to be an approximation of the macadam limit\n    // this makes it some kind of g0-like estimate\n    mat3 M = mat3(\n        2.26775149, -1.43293879,  0.1651873,\n        -0.98535505,  2.1260072, -0.14065215,\n        -0.02501605, -0.26349465,  1.2885107);\n\n    x = x*M;\n    \n    float x_min = min(x.r,min(x.g,x.b));\n    float x_max = max(x.r,max(x.g,x.b));\n    \n    float c = 0.5*(x_max+x_min);\n    float s = (x_max-x_min);\n    \n    // math trickery to create values close to c and s, but without producing hard edges\n    vec3 y = (x-c)/s;\n    float c_smooth = c + dot(y*y*y, vec3(1.0/3.0))*s;\n    float s_smooth = sqrt(dot(x-c_smooth,x-c_smooth)/2.0);\n    return vec2(c_smooth, s_smooth);\n}\n\nvec3 toLms(vec3 c)\n{\n    mat3 rgbToLms = mat3(\n        0.4122214708, 0.5363325363, 0.0514459929,\n        0.2119034982, 0.6806995451, 0.1073969566,\n        0.0883024619, 0.2817188376, 0.6299787005);\n\n    vec3 lms_ = c*rgbToLms;\n    return sign(lms_)*pow(abs(lms_), vec3(1.0/3.0));\n}\n\nfloat calculateC(vec3 lms)\n{\n    // Most of this could be precomputed\n    // Creating a transform that maps R,G,B in the target gamut to have same distance from grey axis\n\n    vec3 lmsR = toLms(vec3(1.0,0.0,0.0));\n    vec3 lmsG = toLms(vec3(0.0,1.0,0.0));\n    vec3 lmsB = toLms(vec3(0.0,0.0,1.0));\n    \n    vec3 uDir = (lmsR - lmsG)/sqrt(2.0);\n    vec3 vDir = (lmsR + lmsG - 2.0*lmsB)/sqrt(6.0);\n    \n    mat3 to_uv = inverse(mat3(\n    1.0, uDir.x, vDir.x,\n    1.0, uDir.y, vDir.y,\n    1.0, uDir.z, vDir.z\n    ));\n    \n    vec3 _uv = lms * to_uv;\n    \n    return sqrt(_uv.y*_uv.y + _uv.z*_uv.z);\n    \n    float a = 1.9779984951f*lms.x - 2.4285922050f*lms.y + 0.4505937099f*lms.z;\n    float b = 0.0259040371f*lms.x + 0.7827717662f*lms.y - 0.8086757660f*lms.z;\n\n    return sqrt(a*a + b*b);\n}\n\nvec2 calculateMC(vec3 c)\n{\n    vec3 lms = toLms(c);\n    \n    float M = findCenterAndPurity(lms).x; \n    \n    return vec2(M, calculateC(lms));\n}\n\nvec2 expandShape(vec3 rgb, vec2 ST)\n{\n    vec2 MC = calculateMC(rgb);\n    vec2 STnew = vec2((MC.x)/MC.y, (1.0-MC.x)/MC.y);\n    STnew = (STnew + 3.0*STnew*STnew*MC.y);\n    \n    return vec2(min(ST.x, STnew.x), min(ST.y, STnew.y));\n}\n\nfloat expandScale(vec3 rgb, vec2 ST, float scale)\n{\n    vec2 MC = calculateMC(rgb);\n    float Cnew = (1.0/((ST.x/(MC.x)) + (ST.y/(1.0-MC.x))));\n\n    return max(MC.y/Cnew, scale);\n}\n\nvec2 approximateShape()\n{\n    float m = -softness_scale*0.2;\n    float s = 1.0 + (softness_scale*0.2+softness_scale*0.8);\n    \n    vec2 ST = vec2(1000.0,1000.0);\n    ST = expandShape(m+s*vec3(1.0,0.0,0.0), ST);\n    ST = expandShape(m+s*vec3(1.0,1.0,0.0), ST);\n    ST = expandShape(m+s*vec3(0.0,1.0,0.0), ST);\n    ST = expandShape(m+s*vec3(0.0,1.0,1.0), ST);\n    ST = expandShape(m+s*vec3(0.0,0.0,1.0), ST);\n    ST = expandShape(m+s*vec3(1.0,0.0,1.0), ST);\n    \n    float scale = 0.0;\n    scale = expandScale(m+s*vec3(1.0,0.0,0.0), ST, scale);\n    scale = expandScale(m+s*vec3(1.0,1.0,0.0), ST, scale);\n    scale = expandScale(m+s*vec3(0.0,1.0,0.0), ST, scale);\n    scale = expandScale(m+s*vec3(0.0,1.0,1.0), ST, scale);\n    scale = expandScale(m+s*vec3(0.0,0.0,1.0), ST, scale);\n    scale = expandScale(m+s*vec3(1.0,0.0,1.0), ST, scale);\n    \n    return ST/scale;\n}\n\nvec3 tonemap_hue_preserving(vec3 c)\n{\n    mat3 toLms = mat3(\n        0.4122214708, 0.5363325363, 0.0514459929,\n        0.2119034982, 0.6806995451, 0.1073969566,\n        0.0883024619, 0.2817188376, 0.6299787005);\n        \n    mat3 fromLms = mat3(\n        +4.0767416621f , -3.3077115913, +0.2309699292,\n        -1.2684380046f , +2.6097574011, -0.3413193965,\n        -0.0041960863f , -0.7034186147, +1.7076147010);\n        \n    vec3 lms_ = c*toLms;\n    vec3 lms = sign(lms_)*pow(abs(lms_), vec3(1.0/3.0));\n    \n    vec2 MP = findCenterAndPurity(lms);\n    \n    // apply tone curve\n    \n    // Approach 1: scale chroma based on derivative of chrome curve\n    if (true)\n    { \n        float I = (MP.x+(1.0-offset)*MP.y);\n        // Remove comment to see what the results are with Oklab L\n        //I = dot(lms, vec3(0.2104542553f, 0.7936177850f, - 0.0040720468f));\n        \n        lms = lms*I*I;\n        I = I*I*I;\n        vec3 dLms = lms - I;\n\n        float Icurve = s_curve(vec3(I)).x;\n        lms = 1.0f + chroma_scale*dLms*d_s_curve(vec3(I))/Icurve;     \n        I = pow(Icurve, 1.0/3.0);\n\n        lms = lms*I;\n    }\n    \n    // Approach 2: Separate color into a whiteness/blackness part, apply scale to them independendtly\n    if (false)\n    {\n        lms = chroma_scale*(lms - MP.x) + MP.x;\n    \n        float invBlackness = (MP.x+MP.y);\n        float whiteness = (MP.x-MP.y);\n        \n        float invBlacknessC = pow(s_curve(vec3(invBlackness*invBlackness*invBlackness)).x, 1.0/3.0);\n        float whitenessC = pow(s_curve(vec3(whiteness*whiteness*whiteness)).x, 1.0/3.0);\n        \n        lms = (invBlacknessC+whitenessC)/2.0 + (lms-(invBlackness+whiteness)/2.0)*(invBlacknessC-whitenessC)/(invBlackness-whiteness);\n    }\n    \n    \n    // compress to a smooth approximation of the target gamut\n    { \n        float M = findCenterAndPurity(lms).x;\n        vec2 ST = approximateShape(); // this can be precomputed, only depends on RGB gamut\n        float C_smooth_gamut = (1.0)/((ST.x/(M)) + (ST.y/(1.0-M)));\n        float C = calculateC(lms);\n\n        lms = (lms-M)/sqrt(C*C/C_smooth_gamut/C_smooth_gamut+1.0) + M;\n    }\n    \n    vec3 rgb = lms*lms*lms*fromLms;\n\n    return rgb;\n}\n\nvec3 softSaturate(vec3 x, vec3 a)\n{\n    a = clamp(a, 0.0,softness_scale);\n    a = 1.0+a;\n    x = min(x, a);\n    vec3 b = (a-1.0)*sqrt(a/(2.0-a));\n    return 1.0 - (sqrt((x-a)*(x-a) + b*b) - b)/(sqrt(a*a+b*b)-b);\n}\n\nvec3 softClipColor(vec3 color)\n{\n    // soft clip of rgb values to avoid artifacts of hard clipping\n    // causes hues distortions, but is a smooth mapping\n    // not quite sure this mapping is easy to invert, but should be possible to construct similar ones that do\n    \n    float grey = 0.2;\n        \n    vec3 x = color-grey;\n\n    vec3 xsgn = sign(x);\n    vec3 xscale = 0.5 + xsgn*(0.5-grey);\n    x /= xscale;\n\n    float maxRGB = max(color.r, max(color.g, color.b));\n    float minRGB = min(color.r, min(color.g, color.b));\n \n    float softness_0 = maxRGB/(1.0+softness_scale)*softness_scale; \n    float softness_1 = (1.0-minRGB)/(1.0+softness_scale)*softness_scale;\n    \n    vec3 softness = vec3(0.5)*(softness_0+softness_1 + xsgn*(softness_1 - softness_0));\n\n    return grey + xscale*xsgn*softSaturate(abs(x), softness);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*(fragCoord-0.5*iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec3 color;\n    \n    const int N = 8;\n    \n    float time = 0.125*iTime;\n    \n    for (int i = 0; i <= N; i++)\n    {\n        for (int j = 0; j <= i; j++)\n        {\n            float fi = float(i)/float(N);\n            float fj = float(j)/float(N);\n        \n            float x = 1.5*(fi-0.5*fj-0.5);\n            float y = 1.5*sqrt(3.0)/2.0*(fj-0.5);            \n            vec2 xyd = vec2(x,y)-uv;\n            \n            float d = min(0.0006/dot(xyd,xyd),1.0);\n            \n            vec3 c = vec3(fi-fj, fj, 1.0-fi);\n                   \n            c = c*sourceColorSpaceToSrgb;\n\n            color += pow(2.0,-3.0*cos(2.0*3.14159*time))*d*c;\n        }\n    }\n    \n    color = tonemap_hue_preserving(color);\n    color = softClipColor(color);\n    \n    //color = tonemap_per_channel(color);\n  \n    \n    // highlight colors that clip if any\n    float diff = length(color - clamp(color, 0., 1.));\n    if(diff != 0.)\n        color = vec3(0.5,0.5,0.5);    \n    \n    \n    // Output to screen\n    fragColor = vec4(pow(color,vec3(1.0/2.2)),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}