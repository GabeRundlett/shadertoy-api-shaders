{
    "Shader": {
        "info": {
            "date": "1514628671",
            "description": "One chiral set of the f1 stellation cells of the icosahedron, the 10th stellation according to Wenninger.\n\nMouse to rotate, Key 'a' to show both chiral sets.\n\nUses code from knighty's polyhedron shader: https://www.shadertoy.com/view/XlX3zB",
            "flags": 16,
            "hasliked": 0,
            "id": "lljBRh",
            "likes": 1,
            "name": "Icosahedron 10th Stellation",
            "published": 3,
            "tags": [
                "raymarching",
                "icosahedron",
                "stellation",
                "chiral"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 660
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Created by Matthew Arcus, 2017.\n//\n// Uses parts of knighty's polyhedron shader: https://www.shadertoy.com/view/XlX3zB,\n// particularly the raymarching code & some of the geometry.\n//\n// Display one set of the chiral f1 cells in the stellation of the icosahedron.\n// Each set of cells can be generated by the intersection of certain planes\n// of the icosahedron with the fundamental region. Since the f1 cells are\n// chiral, we need to keep track of the number of mirror flips when folding\n// and the final DE has to take into account the parity - for odd parity, use\n// distance when position reflected into the neighbouring cells.\n//\n// All the other cell sets of the icosahedron are achiral and are easier\n// to generate (see forthcoming shader).\n//\n////////////////////////////////////////////////////////////////////////////////\n\nbool achiral = false; // Show both chiral forms\n\nconst float scale = 2.0;\nconst vec3 color0 = vec3(0.7,0.7,0.1);\nconst vec3 color1 = vec3(0.1,0.1,0.1);\n\n// Setup folding planes and vertex\nconst float PI\t= 3.1415927;\nconst int M = 3, N = 5;\nconst float A = cos(PI/float(N));\nconst float B = cos(PI/float(M));\nconst float C = sqrt(1.0 - A*A - B*B);\nconst vec3 R = vec3(-A,-B,C); // 3rd folding plane. The two others are xz and yz planes\nconst vec3 plane0 = vec3(-0.5774, 0.5774, 0.5774);\nconst vec3 plane1 = vec3(0, 0.9342, 0.3568);\nconst vec3 plane2 = vec3(0.5774, -0.5774, 0.5774);\nconst vec3 plane3 = vec3(-0.5774, -0.5774, 0.5774);\n\nvec3 refla(vec3 p) { return vec3(-p.x,p.y,p.z); }\nvec3 reflb(vec3 p) { return vec3(p.x,-p.y,p.z); }\nvec3 reflc(vec3 p) { return p - 2.0*dot(p,R)*R; } //fold about R plane\n\n// Return the parity of the number of mirror flips\nint fold(inout vec3 pos) {\n  int flips = 0;\n  for (int i = 0; i < 5; i++) {\n    flips += int(pos.x < 0.0); // I hope this is branchless\n    pos.x = abs(pos.x);\n    flips += int(pos.y < 0.0);\n    pos.y = abs(pos.y);\n    float k = dot(pos,R);\n    flips += int(k < 0.0);\n    pos -= 2.0*min(0.0,k)*R; //fold about R plane\n  }\n  return flips-flips/2*2; // For version < 3.00\n}\n\nfloat f1a(vec3 pos) {\n  float d = -(dot(pos,plane0) - 1.0);\n  d = max(d,dot(pos,plane1) - 1.0);\n  d = max(d,-(dot(pos,plane2) - 1.0));\n  d = max(d,dot(pos,plane3) - 1.0);\n  return d;\n}\n\nfloat f1(vec3 pos, int parity) {\n  if (parity == 0 || achiral) return f1a(pos);\n  float d = f1a(refla(pos));\n  d = min(d,f1a(reflb(pos)));\n  d = min(d,f1a(reflc(pos)));\n  return d;\n}\n\nfloat poly(vec3 pos) {\n  pos *= scale;\n  int parity = fold(pos);\n  return f1(pos,parity)/scale;\n}\n\nvec3 getcolor(vec3 pos) {\n  pos *= scale;\n  int parity = fold(pos);\n  return (achiral && parity == 1) ? color1 : color0;\n}\n\n//-------------------------------------------------\n//From https://www.shadertoy.com/view/XtXGRS#\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 calcNormal(in vec3 p) {\n  const vec2 e = vec2(0.0001, 0.0);\n  return normalize(vec3(poly(p + e.xyy) - poly(p - e.xyy),\n                        poly(p + e.yxy) - poly(p - e.yxy),\n                        poly(p + e.yyx) - poly(p - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd) {\n  const float maxd = 4.0;\n  const float precis = 0.0001;\n  float h = precis * 2.0;\n  float t = 0.0;\n  float res = -1.0;\n  for (int i = 0; i < 100; i++) {\n      if (h < precis || t > maxd) break;\n      h = poly(ro + rd * t);\n      t += h;\n    }\n  if (t < maxd) res = t;\n  return res;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = -(2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = -(2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  p.yz = rotate(p.yz,iTime * 0.125);\n  p.zx = rotate(p.zx,iTime * 0.2);\n  return p;\n}\n\nconst int CHAR_A = 65;\nbool keypress(int code) {\n#if __VERSION__ < 300\n  return false;\n#else\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  achiral = keypress(CHAR_A);\n  vec2 p = 2.0*fragCoord.xy / iResolution.xy - 1.0;\n  p *= 3.0*vec2(1,-1)*iResolution.xy/iResolution.y;\n  vec3 col = vec3(0.3 + p.y * 0.1);\n  vec3 ro = vec3(0.0, 0.0, 2.5);\n  vec3 rd = normalize(vec3(p, -6.0));\n  vec3 li = normalize(vec3(0.5, 0.8, 3.0));\n  ro = transform(ro);\n  rd = transform(rd);\n  li = transform(li);\n  float t = march(ro,rd);\n  if (t > 0.001) {\n    vec3 pos = ro + t * rd;\n    vec3 n = calcNormal(pos);\n    col = getcolor(pos);\n    float diffuse = clamp(dot(n, li), 0.0, 1.0);\n    col *= diffuse;\n    col = pow(col, vec3(0.4545));\n  }\n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}