{
    "Shader": {
        "info": {
            "date": "1629909690",
            "description": "Just a plane and a quad, playing around with polygonal mesh lights as a first draft of a real time implementation ",
            "flags": 0,
            "hasliked": 0,
            "id": "fsc3WM",
            "likes": 11,
            "name": "Planar Light",
            "published": 3,
            "tags": [
                "raytracingbrdfplanarlight"
            ],
            "usePreview": 0,
            "username": "rodousse",
            "viewed": 391
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265\n//Camera field of view Â°\n#define FOV 45.0\n//Camera rotation speed \n#define ROTATION_SPEED 0.5\n//distance of the camera from the sphere\n#define CAM_DISTANCE 10.0\n//distance of the camera from the ground\n#define CAM_HEIGHT 3.0\n\nvec3 center = vec3(0.0,1.0,0.0);\n\nvec3 lightColor = vec3(1.0,1.0,1.0);\nfloat intensity = 5.0;\nvec3 diffuse = vec3(1.0,1.0,1.0);\nvec3 spec = vec3(1.0, 1.0,1.0);\n\nvec3 quadCenter = vec3(0.0,1.0,0.0);\nvec3 quadNormal = normalize(vec3(1.0,0.0,0.0)); // fix Y orientation causing trouble to compute the up vector\nvec2 quadSize = vec2(3.5, 2.0);\n\nvec3 background = vec3(.05); \n\n//Todo : Compute the spherical triangle area not the planar triangle\nfloat triangleArea(vec3 A, vec3 B, vec3 C)\n{\n    return length(cross(B-A, C-A))*0.5;\n}\n\n// Diffuse BRDF\n// Todo, sample the quad domain, and weight the samples with a ggx\nvec3 BRDF(vec3 normal, vec3 pos, vec3 qc, vec3 qn, vec2 qs)\n{\n    vec3 right = normalize(cross(qn, vec3(0., 1., 0.)));\n    vec3 up = cross(right, qn);\n    vec2 qsH = qs*0.5;\n    vec3 qcPos = qc - pos;\n    vec3 hRight = right * qsH.x;\n    vec3 hUp = up * qsH.y;\n    \n    //Coordinate of the rectangle vertices on the unit sphere\n    vec3 A = normalize(qcPos - hRight - hUp);\n    vec3 B = normalize(qcPos - hRight + hUp);\n    vec3 C = normalize(qcPos + hRight + hUp);\n    vec3 D = normalize(qcPos + hRight - hUp);\n    \n    return intensity * lightColor * (triangleArea(A, B, C) + triangleArea(A, D, C)) / (2. * PI);\n}\n\n\nfloat hitPlane(vec3 dir, vec3 rayPoint, vec3 center, vec3 normal)\n{\n    return max(-(dot(rayPoint, normal)-dot(center, normal)) / dot(normal, dir),0.0);\n}\n\nfloat hitQuad(vec3 dir, vec3 rayPoint, vec3 center, vec3 normal, vec2 size, out vec2 uv)\n{\n    float t = hitPlane(dir, rayPoint, center, normal);\n    vec3 interPoint = rayPoint + t*dir;\n    vec3 right = normalize(cross(normal, vec3(0., 1., 0.)));\n    vec3 up = cross(right, normal);\n    vec3 interVec = interPoint - center;\n    uv = vec2(dot(right, interVec), dot(up, interVec));\n    vec2 posCenter = abs(uv);\n    uv = (uv/size) + vec2(.5);\n    if(posCenter.x<size.x*0.5 && posCenter.y<size.y*0.5)\n        return t;\n    else\n        return -9999999999999.;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    quadNormal.y = quadNormal.y - .000001;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = (uv - vec2(0.5)) * 2.0 * vec2(1.0, float(iResolution.x)/float(iResolution.y));\n    \n    // Camera infos\n    vec3 cam = vec3(CAM_DISTANCE, 1.0, CAM_DISTANCE) * vec3(cos(iTime * ROTATION_SPEED), CAM_HEIGHT, sin(iTime * ROTATION_SPEED)) ;\n    \n    float near = 0.01f;\n    float viewportHeight = 2.0f * near * tan(FOV * 0.5f * PI/180.0f);\n    float viewportWidth = viewportHeight * iResolution.x / iResolution.y;\n    vec3 forward = normalize(center-cam) * near;\n\n    vec3 right = normalize(cross(forward, vec3(0.0,1.0,0.0)));\n    vec3 up = normalize(cross(right, forward)) / (float(iResolution.x)/float(iResolution.y));\n    \n    // Ray generation\n    vec3 dir = (right * cuv.x * (viewportWidth/2.0f));\n    dir += (up * cuv.y * (viewportHeight/2.0f));\n    dir += forward;\n    dir = normalize(dir);\n    \n    // Raytrace ground\n    vec3 normal = vec3(0.0,1.0,0.0);\n    float t = hitPlane(dir, cam, vec3(0.0,0.0,0.0), normal);\n    vec3 colGround = BRDF(normal, cam + dir*t, quadCenter, quadNormal , quadSize);\n    \n    //Raytrace quad\n    vec2 quadUv;\n    float quadT = hitQuad(dir, cam, quadCenter, quadNormal , quadSize, quadUv);\n    vec3 colQuad = lightColor;\n    \n    //Compose\n\tvec3 col;\n    if(length(t*dir) < length(quadT*dir))\n     col = colGround;\n    else\n     col = colQuad;\n     \n    col = mix(background, col, min(max(t, quadT),1.0));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}