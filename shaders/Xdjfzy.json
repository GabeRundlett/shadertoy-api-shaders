{
    "Shader": {
        "info": {
            "date": "1500977254",
            "description": "lara croft on much simpler planet...\noriginal version crashes some browsers [url]https://www.shadertoy.com/view/XdBBRy[/url]\n(took it out as a private shader - don't wanna cause a nuisance)\nunfortunately don't have time for a better fix :-(\n",
            "flags": 48,
            "hasliked": 0,
            "id": "Xdjfzy",
            "likes": 4,
            "name": "[SH17B] lara simple planet",
            "published": 3,
            "tags": [
                "lara"
            ],
            "usePreview": 0,
            "username": "flockaroo",
            "viewed": 726
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// lara on simpler planet\n// original version used to crash some peoples browsers https://www.shadertoy.com/view/XdBBRy\n\nvec3 readPos() { return texelFetch(iChannel2,ivec2(0,0),0).xyz; }\nvec3 readVel() { return texelFetch(iChannel2,ivec2(1,0),0).xyz; }\nvec3 readFwd() { return texelFetch(iChannel2,ivec2(2,0),0).xyz; }\nfloat readHealth() { return texelFetch(iChannel2,ivec2(3,0),0).x; }\nfloat readTravel() { return texelFetch(iChannel2,ivec2(3,0),0).y; }\n\n\n#define PI 3.141592653\n\n// get some 3d rand values by multiplying 2d rand in xy, yz, zx plane\nvec4 getRand(vec3 pos)\n{\n    vec4 r = vec4(1.0);\n    r*=texture(iChannel0,pos.xy)*2.-1.;\n    r*=texture(iChannel0,pos.xz)*2.-1.;\n    r*=texture(iChannel0,pos.zy)*2.-1.;\n    return r;\n}\n\n// distancefield of torus around arbitrary axis z\n// similar to https://iquilezles.org/articles/distfunctions\nfloat distTorus(vec3 pos, float r1, float r2, vec3 z)\n{\n    float pz = dot(pos,normalize(z));\n    return length(vec2(length(pos-z*pz)-r1,pz))-r2;\n}\n\nfloat distTorus(vec3 pos, float r1, float r2, vec3 z, out float ang)\n{\n    float pz = dot(pos,normalize(z));\n    vec2 r = vec2(length(pos-z*pz)-r1,pz);\n    ang = atan(r.y,r.x);\n    return length(r)-r2;\n}\n\nvec4 getRand01Sph(vec3 pos)\n{\n    vec2 res = iChannelResolution[0].xy;\n    vec2 texc=((pos.xy*123.+pos.z)*res+.5)/res;\n    return texture(iChannel0,texc);\n}\n\nfloat distSphere(vec3 pos, float r)\n{\n\treturn length(pos)-r;\n}\n\n// final distance funtion\nfloat distLand(vec3 pos)\n{\n    pos+=.001*getRand(pos*3.).xyz;\n    vec3 p1,p2,p3;\n    float d = 10000.;\n    float sc = 1.;\n    \n    d=min(d,distSphere(pos,.9));\n    vec3 sphpos = floor(pos/.16)*.16+.08;\n    if(length(sphpos)<.95)\n    \td=min(d,distSphere(pos-sphpos,.06));\n    //d-=getRand(pos*.03).x*.1-.1;\n    return d;\n}\n\n// final distance funtion\nfloat distWater(vec3 pos)\n{\n    pos+=.00040*getRand(pos*.15+.01*iTime).xyz*3.;\n    float d = 10000.;\n    \n    // sphere in the middle\n\td=min(d,distSphere(pos,.95));\n    //d-=(length(texture(iChannel3,sph2frag(pos)/iResolution.xy).xy-.5))*.2;\n    return d;\n}\n\n// capsule signed distfield from iq\nfloat distCyl( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat distLara(vec3 pos)\n{   \n    vec3 fwd=readFwd();\n    vec3 up =normalize(readPos());\n    vec3 right=cross(fwd,up);\n    pos=pos*mat3(right,fwd,up);\n    //pos+=.00040*getRand(pos*.15+.01*iTime).xyz*3.;\n    float d = 10000.;\n    //float time = iTime*5.;\n    float time = readTravel()*20.;\n    \n    // butt\n\td=min(d,distSphere(pos-vec3( .1,-.05,0),.1));\n\td=min(d,distSphere(pos-vec3(-.1,-.05,0),.1));\n    // tits\n\td=min(d,distSphere(pos-vec3( .1,.1,.4),.08));\n\td=min(d,distSphere(pos-vec3(-.1,.1,.4),.08));\n    // head\n\td=min(d,distSphere(pos-vec3(0,0,.8),.12));\n    // body\n\td=min(d,distCyl(pos,vec3(0,0,0),vec3(0,0,.7),.06));\n\td=min(d,distCyl(pos,vec3(-.15,0,.6),vec3(.15,0,.6),.04));\n    // arms\n    float ra =.6;\n    float pha = sin(time)*.5;\n\td=min(d,distCyl(pos,vec3(-.15,0,.6),vec3(-.15,-ra*sin(pha),.6-ra*cos(pha)),.03));\n\td=min(d,distCyl(pos,vec3( .15,0,.6),vec3( .15, ra*sin(pha),.6-ra*cos(pha)),.03));\n    // legs\n    float rl =.8;\n    float phl = sin(time)*.5;\n\td=min(d,distCyl(pos,vec3(-.1,0,0),vec3(-.1, rl*sin(phl),-rl*cos(phl)),.03));\n\td=min(d,distCyl(pos,vec3( .1,0,0),vec3( .1,-rl*sin(phl),-rl*cos(phl)),.03));\n    // tail\n    float rt =.3;\n    float pht = sin(time)*.5;\n\td=min(d,distCyl(pos,vec3(0,-.12,.8),vec3(rt*sin(pht),-.13,.8-rt*cos(pht)),.03));\n    \n    return d;\n}\n\n// final distance funtion\nvec4 dist4(vec3 pos)\n{\n    float dw=distWater(pos);\n    float dl=distLand(pos);\n    //dl=min(dl,length(pos-readPos())-.04);\n    dl=min(dl,distLara((pos-readPos())/.04)*.04);\n    return vec4(min(dl,dw),dl<dw?1.:0.,0,0);\n}\n\nfloat dist(vec3 pos)\n{\n    return dist4(pos).x;\n}\n\nvec3 getGrad(vec3 pos, float eps)\n{\n    vec2 d=vec2(eps,0);\n    float d0=dist(pos);\n    return vec3(dist(pos+d.xyy)-d0,\n                dist(pos+d.yxy)-d0,\n                dist(pos+d.yyx)-d0)/eps;\n                \n}\n\n// march it...\nvec4 march(inout vec3 pos, inout vec3 dir)\n{\n    float br=1.;\n    // cull the sphere\n    if(length(pos-dir*dot(dir,pos))>1.15) \n    \treturn vec4(br,0,0,1);\n    float eps=0.001;\n    float bg=1.0;\n    for(int cnt=0;cnt<52;cnt++)\n    {\n        vec4 d = dist4(pos);\n        pos+=d.x*dir*.8;\n        if(d.x<eps) { \n            if(d.y>.5) { bg=0.0; break; } \n            vec3 n=getGrad(pos,.001); \n            dir=reflect(dir,n); \n            br*=pow(1.-.6*dot(dir,n),2.);\n            pos+=eps*dir*1.5; \n        }\n    }\n    return vec4(br,0,0,bg); // .w=1 => background\n}\n\nmat3 rotX(float ang)\n{\n    float c=cos(ang), s=sin(ang);\n    return mat3(1,0,0, 0,c,s, 0,-s,c);\n}\n\nmat3 rotZ(float ang)\n{\n    float c=cos(ang), s=sin(ang);\n    return mat3(c,s,0, -s,c,0, 0,0,1);\n}\n\nvec3 getEnvironment(vec3 dir)\n{\n\tvec3 cube=texture(iChannel1,dir).xyz;\n    return cube*2.;\n    vec3 c=vec3(0);\n    vec3 r=getRand(dir).xyz;\n    vec3 rg=vec3(dot(r,vec3(.333)));\n    c+=2.*rg+.5*r;\n    //c+=12.*getRand(dir).xyz*getRand(dir).xyz*(.1+getRand(dir).xyz);\n    c+=.01/(abs(dir.x*dir.x*5.))*(2.*rg+.5*r+.1);\n    return clamp((c*1.+sqrt(cube)*.4)*1.,0.,1.);\n}\n\nfloat rect(vec2 p1,vec2 p2,vec2 c)\n{\n    return step(p1.x,c.x)*step(p1.y,c.y)*(1.-step(p2.x,c.x))*(1.-step(p2.y,c.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // screen coord -1..1\n    vec2 sc = (fragCoord.xy/iResolution.xy)*2.-1.;\n    // viewer position\n    vec3 userpos = readPos();\n    vec3 up = normalize(userpos);\n    vec3 fwd = readFwd();\n    vec3 right = cross(fwd,up);\n    //up = normalize(up+fwd*1.5);\n    //vec3 fwdC = normalize(cross(up,right));\n    vec2 mouse=iMouse.xy;\n    if(iMouse.x==0.) mouse.x=iResolution.x*.5;\n    if(iMouse.y==0.) mouse.y=iResolution.y*.25;\n    vec3 pos = userpos-(fwd-up*.7)*(.2+mouse.y/iResolution.y)+right*(mouse.x/iResolution.x-.5)*1.2;\n    \n    // cam base\n    fwd=normalize(userpos-pos);\n    right=normalize(cross(fwd,up));\n    up=cross(right,fwd);\n    \n    // pixel view direction\n    vec3 dir = normalize(fwd*2.+right*sc.x+up*sc.y*iResolution.y/iResolution.x);\n    // rotate view around x,z\n    float phi = iMouse.x/iResolution.x*7.*0.;\n    float th  = iMouse.y/iResolution.y*7.*0.;\n    //if (iMouse.x==0.) { phi=iTime*.5; th=.27*.5*iTime; }\n    mat3 rx = rotX(th);\n    mat3 rz = rotZ(phi);\n    pos = rz*(rx*pos);\n    dir = rz*(rx*dir);\n    \n    // march it...\n   \tvec4 rval=march(pos,dir);\n    vec3 n = getGrad(pos,.001);\n    float bg=rval.w;\n    float bright=rval.x;\n        \n    // calc some ambient occlusion\n    float ao=1.;\n    #if 0\n    // calc simple ao by stepping along radius\n    ao*=dist(pos*1.02)/.02;\n    ao*=dist(pos*1.05)/.05;\n    ao*=dist(pos*1.1)/.1;\n    #else\n    // calc ao by stepping along normal\n    ao*=dist(pos+n.xyz*.02)/.02;\n    ao*=dist(pos+n.xyz*.05)/.05;\n    ao*=dist(pos+n.xyz*.10)/.10;\n    #endif\n    // adjust contrast of ao\n    ao=pow(ao,.4);\n    \n    // reflection dir\n    vec3 R = pos-2.0*dot(pos,n.xyz)*n.xyz;\n    R = -((R*rz)*rx).yzx;\n    \n    vec3 c = vec3(1);\n    // simply add some parts of the normal to the color\n    // gives impression of 3 lights from different dir with different color temperature\n    c += n.xyz*.05+.05\n        ;\n    // slight green tint\n    c+=vec3(0,.1,0);\n\n    //  reflection of cubemap\n    c *= getEnvironment(R)*.8+.3;\n    //c *= vec3(.7,.5,.3);\n    \n    // add some depth darkening\n\t//c*=clamp(-dot(dir,pos)*.7+.7, .2, 1.);\n    \n    // apply ambient occlusion\n    c*=ao;\n    \n    // apply background (medusa poison green)\n    float aspect=iResolution.y/iResolution.x;\n    phi=atan(sc.y*aspect,sc.x);\n    float r = length(vec2(sc.y*aspect,sc.x));\n    if(bg>=.5) c=getEnvironment(dir);\n    c*=bright;\n    \n    // vignetting\n    float vign = (1.-.3*dot(sc.xy,sc.xy)/*-.3*sc.x*sc.x*sc.x*sc.x-.3*sc.y*sc.y*sc.y*sc.y*/);\n    //vign=1.;\n    \n\tfragColor = vec4(c*vign,1);\n    fragColor *= 1.-rect(vec2(-.9,.85),vec2(-.1,.9),fragCoord/iResolution.xy*2.-1.);\n    fragColor += rect(vec2(-.9,.85),vec2(-.9+.8*readHealth(),.9),fragCoord/iResolution.xy*2.-1.)*vec4(1,0,0,0);\n    //fragColor = texture(iChannel3,fragCoord/iResolution.xy);\n    if(readHealth()<.2) fragColor.x+=sin(iTime*10.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// lara on simpler planet\n// original version used to crash some peoples browsers https://www.shadertoy.com/view/XdBBRy\n\n#define keyTex iChannel1\n#define A_     (texture(keyTex,vec2(65.5/256.0,(0.5+0.0)/3.0)).x>.5)\n#define S_     (texture(keyTex,vec2(83.5/256.0,(0.5+0.0)/3.0)).x>.5)\n#define D_     (texture(keyTex,vec2(68.5/256.0,(0.5+0.0)/3.0)).x>.5)\n#define W_     (texture(keyTex,vec2(87.5/256.0,(0.5+0.0)/3.0)).x>.5)\n#define LEFT_  (texture(keyTex,vec2(37.5/256.0,(0.5+0.0)/3.0)).x>.5)\n#define UP_    (texture(keyTex,vec2(38.5/256.0,(0.5+0.0)/3.0)).x>.5)\n#define RIGHT_ (texture(keyTex,vec2(39.5/256.0,(0.5+0.0)/3.0)).x>.5)\n#define DOWN_  (texture(keyTex,vec2(40.5/256.0,(0.5+0.0)/3.0)).x>.5)\n#define SPACE_ (texture(keyTex,vec2(32.5/256.0,(0.5+0.0)/3.0)).x>.5)\n\nvec3 readPos() { return texelFetch(iChannel2,ivec2(0,0),0).xyz; }\nvec3 readVel() { return texelFetch(iChannel2,ivec2(1,0),0).xyz; }\nvec3 readFwd() { return texelFetch(iChannel2,ivec2(2,0),0).xyz; }\nfloat readHealth() { return texelFetch(iChannel2,ivec2(3,0),0).x; }\nfloat readTravel() { return texelFetch(iChannel2,ivec2(3,0),0).y; }\n\nvoid writePos(vec3 val, inout vec4 col, in vec2 coord) { if (ivec2(coord)==ivec2(0,0)) col.xyz=val; }\nvoid writeVel(vec3 val, inout vec4 col, in vec2 coord) { if (ivec2(coord)==ivec2(1,0)) col.xyz=val; }\nvoid writeFwd(vec3 val, inout vec4 col, in vec2 coord) { if (ivec2(coord)==ivec2(2,0)) col.xyz=val; }\nvoid writeHealth(float val, inout vec4 col, in vec2 coord) { if (ivec2(coord)==ivec2(3,0)) col.x=val; }\nvoid writeTravel(float val, inout vec4 col, in vec2 coord) { if (ivec2(coord)==ivec2(3,0)) col.y=val; }\n\n#define PI 3.141592653\n\n// get some 3d rand values by multiplying 2d rand in xy, yz, zx plane\nvec4 getRand(vec3 pos)\n{\n    vec4 r = vec4(1.0);\n    r*=texture(iChannel0,pos.xy)*2.-1.;\n    r*=texture(iChannel0,pos.xz)*2.-1.;\n    r*=texture(iChannel0,pos.zy)*2.-1.;\n    return r;\n}\n\n// distancefield of torus around arbitrary axis z\n// similar to https://iquilezles.org/articles/distfunctions\nfloat distTorus(vec3 pos, float r1, float r2, vec3 z)\n{\n    float pz = dot(pos,normalize(z));\n    return length(vec2(length(pos-z*pz)-r1,pz))-r2;\n}\n\nfloat distTorus(vec3 pos, float r1, float r2, vec3 z, out float ang)\n{\n    float pz = dot(pos,normalize(z));\n    vec2 r = vec2(length(pos-z*pz)-r1,pz);\n    ang = atan(r.y,r.x);\n    return length(r)-r2;\n}\n\nvec4 getRand01Sph(vec3 pos)\n{\n    vec2 res = iChannelResolution[0].xy;\n    vec2 texc=((pos.xy*123.+pos.z)*res+.5)/res;\n    return texture(iChannel0,texc);\n}\n\nfloat distSphere(vec3 pos, float r)\n{\n\treturn length(pos)-r;\n}\n\n// final distance funtion\nfloat distLand(vec3 pos)\n{\n \t//pos+=.001*getRand(pos*3.).xyz;\n    vec3 p1,p2,p3;\n    float d = 10000.;\n    float sc = 1.;\n    \n    d=min(d,distSphere(pos,.9));\n    vec3 sphpos = floor(pos/.16)*.16+.08;\n    if(length(sphpos)<.95)\n    \td=min(d,distSphere(pos-sphpos,.06));\n    //d-=getRand(pos*.03).x*.1-.1;\n    return d;\n}\n\n// final distance funtion\nfloat distWater(vec3 pos)\n{\n    //pos+=.00040*getRand(pos*.15+.01*iTime).xyz*3.;\n    float d = 10000.;\n    \n    // sphere in the middle\n\td=min(d,distSphere(pos,.095));\n    //d-=(length(texture(iChannel3,sph2frag(pos)/iResolution.xy).xy-.5))*.2;\n    return d;\n}\n\n// final distance funtion\nvec4 dist4(vec3 pos)\n{\n    float dw=distWater(pos);\n    float dl=distLand(pos);\n    return vec4(min(dl,dw),dl<dw?1.:0.,0,0);\n}\n\nfloat dist(vec3 pos)\n{\n    return dist4(pos).x;\n}\n\nvec3 getGrad(vec3 pos, float eps)\n{\n    vec2 d=vec2(eps,0);\n    float d0=dist(pos);\n    return vec3(dist(pos+d.xyy)-d0,\n                dist(pos+d.yxy)-d0,\n                dist(pos+d.yyx)-d0)/eps;\n                \n}\n\n\n// march it...\nvoid march(inout vec3 pos, vec3 dir)\n{\n    // cull the sphere\n    if(length(pos-dir*dot(dir,pos))>1.1) \n    \treturn;\n    \n    float eps=0.001;\n    float bg=1.0;\n    for(int cnt=0;cnt<52;cnt++)\n    {\n        float d = dist(pos);\n        pos+=d*dir*.8;\n        if(d<eps) break;\n    }\n}\n\nvec3 rotateAx(vec3 v, vec3 ax, float ang)\n{\n    return vec3(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos=readPos();\n    vec3 vel=readVel();\n    vec3 fwd=readFwd();\n    float health=readHealth();\n    float travel=readTravel();\n    \n    vec3 up=normalize(pos);\n    vec3 right=cross(fwd,up);\n    \n    #define PHYSICS\n    #ifndef PHYSICS\n    \n    if(SPACE_      ) pos+=up*1.1;\n    if(UP_    || W_) pos+=fwd*.003;\n    if(DOWN_  || S_) pos-=fwd*.003;\n    if(LEFT_  || A_) fwd=normalize(fwd-right*.01);\n    if(RIGHT_ || D_) fwd=normalize(fwd+right*.01);\n    pos*=1.5;\n    march(pos,-up);\n    pos+=up*.03;\n    vec3 gr=getGrad(pos,.001);\n    pos+=.0005*(gr-dot(gr,up)*up);\n    if(length(pos)<.97) \n    {\n        vec2 fr=sph2frag(pos);\n        vec2 flow=texture(iChannel3,fr/iResolution.xy).xy-.5;\n        pos+=-4.*frag2sphDiff(fr, flow);\n    }\n    \n    #else\n    \n    float dt=.04;\n    vec3 acc=vec3(0);\n    acc-=vel*.5;\n    vel=vel-dot(vel,up)*up*((dist(pos)<.04)?.1:0.);\n    acc-=normalize(pos)*.1;\n    //acc+=-10000.*clamp(-dist(pos),0.04,100.)*getGrad(pos,.001)/dist();\n    acc+=50.*normalize(getGrad(pos,.001))*(clamp(-(dist(pos)-.04),0.,1.));\n    //if(dist(pos)-.04<0.) vel*=.9;\n    \n    if(SPACE_) acc+=normalize(pos)*.4*((dist(pos)<.08)?1.:0.);\n    if(UP_    || W_) vel+=.002*fwd;\n    if(DOWN_  || S_) vel-=.002*fwd;\n    if(LEFT_  || A_) fwd=normalize(fwd-right*.03);\n    if(RIGHT_ || D_) fwd=normalize(fwd+right*.03);\n    \n    if(length(pos)<.97) \n    {\n        health-=.04*dt;\n    }\n    \n    travel+=length(vel)*dt;\n    \n    pos+=vel*dt*.5;\n    vel+=acc*dt;\n    pos+=vel*dt*.5;\n    \n    #endif\n\n    up=normalize(pos);\n    fwd=normalize(fwd-dot(fwd,up)*up);\n    \n    \n    if(iFrame<10 || health<0.) {\n        pos=vec3(-.282,-.282,1.03);\n        fwd=vec3(0,1,0);\n        vel=vec3(0,0,0);\n        health = 1.;\n        travel = 0.;\n    }\n    \n    writePos(pos,fragColor,fragCoord);\n    writeVel(vel,fragColor,fragCoord);\n    writeFwd(fwd,fragColor,fragCoord);\n    writeHealth(health,fragColor,fragCoord);\n    writeTravel(travel,fragColor,fragCoord);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}