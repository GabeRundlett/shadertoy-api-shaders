{
    "Shader": {
        "info": {
            "date": "1722870493",
            "description": "it's so close\nedit : it is done",
            "flags": 0,
            "hasliked": 0,
            "id": "Mf2yzt",
            "likes": 0,
            "name": "parametric func experiments",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf",
                "parametric"
            ],
            "usePreview": 0,
            "username": "dottedboxguy",
            "viewed": 130
        },
        "renderpass": [
            {
                "code": "#define MAXSTEP 1024\n#define MAXDIST 20.0\n#define MINDIST 0.001\n#define PI 3.14159265359\n#define TWOPI 6.28318530718\nmat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(\nvec3(1.,.0,.0),    \nvec3(.0,ca,sa),   \nvec3(.0,-sa,ca));}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(\nvec3(ca,.0,sa),    \nvec3(.0,1.,.0),   \nvec3(-sa,.0,ca));}\n\n\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(vec3(ca,sa,.0),    vec3(-sa,ca,.0),  vec3(.0,.0,1.));}\n\nfloat dot2(vec2 v){return v.x*v.x - v.y*v.y;}\n\nfloat opUnion( float d1, float d2 ){\n    return min(d1,d2);\n}\n\nfloat sdSphere( vec3 p, float s ){\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 parametric_circle(in float t, in float r){\n    return r*vec3(cos(t*TWOPI), sin(t*TWOPI), 0.);\n}\n\n//angle is :\n//    x is angle around the x axis\n//    z is angle around the z axis\n// i know, that makes a lot of sense, but it's better to make it clear\nvec3 angled_circle(in float t, in float r, in float a_x, in float a_z){\n    float cx = cos(a_x*TWOPI);\n    float sx = sin(a_x*TWOPI);\n    float cz = cos(a_z*TWOPI);\n    float sz = sin(a_z*TWOPI);\n    return r*(cos(t*TWOPI)*vec3(cz, -sz, 0.) + sin(t*TWOPI)*vec3(sz*cx, cx*cz, -sx)); //x-z order\n    \n}\n\n/*vec3 rodrigues(in float t, in float r, in vec3 n){\n    \n    float time = t*TWOPI;\n    \n    vec3 vec = vec3(r, 0., 0.);\n    float cos_t = cos(time);\n    \n    return vec*cos_t + n*vec*sin(time) + n*dot(n, vec)*(1.-cos_t);\n}*/\n\nfloat map(in vec3 p){\n\n\n    float time = iTime/6.;\n    \n    \n    float d = sdSphere(p, .1);\n    float fi = 0.;\n    \n    \n    for (int i = 0; i<20; i++){\n        //d = opUnion(d, sdBox(p+circle_angled_towards_normal(time + fi/20., 1., normal), vec3(.1)));\n        d = opUnion(d, sdBox(p+angled_circle(time*3. + fi/20., 1., iTime/2., time), vec3(.1)));\n        //d = opUnion(d, sdBox(p+rodrigues(time + fi/20., 1., normal), vec3(.1)));\n        fi++;\n    }\n    \n    return d;\n\n}\n\nvec3 calcNormal( in vec3 pos ){\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n\nvec3 color(vec3 p){\n    \n    vec3 col = vec3(.5);\n\n    //lighting, comes from iq, i just fiddled with the values a bit\n    vec3 nor = calcNormal(p);\n    float dif = clamp(dot(nor,vec3(0.57703)), 0.0, 1.0);\n    float amb = 0.5 + 0.5*dot(nor,vec3(.0,.0,1.));\n    col *= amb + vec3(0.5,0.5,0.5)*dif;\n    \n    return col;\n}\n\nvec3 render(in vec3 p, in vec2 fragCoord){\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.xy;\n    uv.y *= iResolution.y/iResolution.x;\n    vec3 dir = normalize(vec3(uv.x, 1.0, uv.y));\n    //dir *= rotate_z(iTime);\n    //dir *= rotate_x(.3);\n    float init_d =  map(p + dir);\n    float d = init_d;\n    float t = d;\n    \n    for (int i = 0; i < MAXSTEP; i++){\n        if (d < MINDIST*init_d){\n            return color(p + dir*t);\n        }\n        else if (t > MAXDIST){\n            return vec3(.992, .961, .902);\n        }\n        d = map(p + dir*t);\n        t += d;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 p = vec3(0., -5., 0.);\n    //p *= rotate_z(iTime);\n \n    vec3 col = render(p, fragCoord).xyz;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}