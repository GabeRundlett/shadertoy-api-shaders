{
    "Shader": {
        "info": {
            "date": "1708027617",
            "description": "Working on recreating some effects from Ton Legacy",
            "flags": 0,
            "hasliked": 0,
            "id": "X3f3Dl",
            "likes": 1,
            "name": "Quorra Identity Disc",
            "published": 3,
            "tags": [
                "tron"
            ],
            "usePreview": 0,
            "username": "jherico",
            "viewed": 108
        },
        "renderpass": [
            {
                "code": "\nconst float MAX_TRACE_DISTANCE = 10.; // max trace distance\nconst float INTERSECTION_PRECISION = .001; // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\nconst float FUDGE_FACTOR = 1.0; // Default is 1, reduce to fix overshoots\nconst vec3 BACKGROUND_COLOR = vec3(.0, .005, .03);\nconst vec3 COLOR = vec3(24.0, 202.0, 230.0) / 255.0;\n\nstruct QuorraBall {\n    vec2 bounds;\n    float radius;\n};\n\n// float iWidth = 0.015;\n// float iMiddle = 0.5;\n// float iShell = 1.0;\n// float iSpeed = 1.0;\n\n\nQuorraBall makeBall(float width, float middle, float radius) {\n    float lowerBound = middle - width;\n    float upperBound = middle + width;\n    return QuorraBall(vec2(lowerBound, upperBound), radius);\n}\n\nbool quorra(vec3 normal, QuorraBall ball) {\n    float intensity = 0.0;\n    float time = iTime / 5.0;\n    vec3 position = normal.xyz * 1.5;\n\n    for (float i = 0.0; i < 2.0; i = i + 1.0) {\n        float modifier = pow(2.0, i);\n        vec3 noisePosition = position * modifier;\n        float noise = snoise(vec4(noisePosition, time));\n        noise /= modifier;\n        intensity += noise;\n    }\n    intensity += 1.0;\n    intensity /= 2.0;\n    if (true && (intensity < ball.bounds.x || intensity > ball.bounds.y)) {\n        return false;\n    }\n    return true;\n}\n\nModel sphereModel(vec3 raypos, float radius) {\n    float spheredist = length(raypos)-radius;\n    vec3 normal = vec3(0.0);\n    if (spheredist <= INTERSECTION_PRECISION) {\n        normal = raypos / radius;\n    }\n    return Model(spheredist, normal);\n}\n\nModel map( vec3 p, float radius ){\n    mat3 m = modelRotation(iMouse.xy / iResolution.xy);\n    p *= m;  \n    Model model = sphereModel(p, radius);\n    return model;\n}\n\nHit raymarch(CastRay castRay, in QuorraBall ball){\n    float currentDist = INTERSECTION_PRECISION * 2.0;\n    Ray ray = Ray(castRay.origin, castRay.direction, 0.);\n\n    Model model = map(ray.origin + ray.direction * ray.len, ball.radius);\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        if (ray.len >= MAX_TRACE_DISTANCE) {\n            break;\n        }\n        if (currentDist <= INTERSECTION_PRECISION) {\n            break;\n        }\n        model = map(ray.origin + ray.direction * ray.len, ball.radius);\n        currentDist = model.dist;\n        ray.len += currentDist * FUDGE_FACTOR;\n    }\n    \n    bool isBackground = false;\n    vec3 pos = vec3(0);\n    vec3 color = vec3(0);\n    \n    if (ray.len >= MAX_TRACE_DISTANCE) {\n        isBackground = true;\n    } else {\n        pos = ray.origin + ray.direction * ray.len;\n        if (!quorra(pos, ball)) {\n            isBackground = true;\n        } else {\n            color = COLOR;\n        }\n    } \n    \n    return Hit(ray, model, pos, isBackground, model.normal, color);\n}\n\n// --------------------------------------------------------\n// Rendering\n// --------------------------------------------------------\n\nvec3 shadeSurface(in Hit hit){\n    #if defined(DEBUG)\n        return abs(hit.normal) * 0.5 + 0.5;\n    #endif\n    return hit.color;\n}\n\nvec3 render(in Hit hit){\n    if (hit.isBackground) {\n        return BACKGROUND_COLOR;\n    }\n    \n\treturn shadeSurface(hit);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef LOOP\n        #if LOOP == 1\n            time = mod(time, 2.);   \n        #endif\n        #if LOOP == 2\n            time = mod(time, 4.);   \n        #endif\n        #if LOOP == 3\n            time = mod(time, 2.);\n    \t#endif\n    #endif\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    // camera movement\n    Camera cam = doCamera(vec3(0.0, 0.0, -4.0), vec3(0.0), m);\n    \n    // create view ray\n    vec3 rd = normalize(cam.lookAt * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n#define BALL_COUNT 8\n    QuorraBall balls[BALL_COUNT];\n    for (int i = 0; i < BALL_COUNT; ++i) {\n        int index = BALL_COUNT - 1 - i;\n        float radius = 1.0 - (float(i) * 0.04);\n        balls[index] = makeBall(0.010, 0.5, radius);\n    }\n    Hit hit;\n    for (int i = 0; i < BALL_COUNT; ++i) {\n        hit = raymarch(CastRay(cam.pos, rd), balls[i]);\n        if (!hit.isBackground) {\n            break;\n        }\n    }\n\n    vec3 color = render(hit);\n    color = linearToScreen(color);\n    fragColor = vec4(color,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.1415926535898\n#define iGlobalTime iTime\n#define time iTime\n#define iWorldScale 1.0\n#define MODEL_ROTATION vec2(.3, .25)\n#define CAMERA_ROTATION vec2(.5, .5)\n\n// 0: Defaults\n// 1: Model\n// 2: Camera\n#define MOUSE_CONTROL 2\n\n// #define DEBUG\n\n// 1, 2, or 3\n//#define LOOP 1\n\n\nfloat mod289(float x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nfloat permute(float x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec3 permute(vec3 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 permute(vec4 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat taylorInvSqrt(float r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip) {\n    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n    vec4 p, s;\n\n    p.xyz = floor(fract(vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n    s = vec4(lessThan(p, vec4(0.0)));\n    p.xyz = p.xyz + (s.xyz * 2.0 - 1.0) * s.www;\n\n    return p;\n}\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v) {\n    const vec4 C = vec4(0.138196601125011,  // (5 - sqrt(5))/20  G4\n            0.276393202250021,  // 2 * G4\n            0.414589803375032,  // 3 * G4\n            -0.447213595499958); // -1 + 4 * G4\n\n    // First corner\n    vec4 i = floor(v + dot(v, vec4(F4)));\n    vec4 x0 = v - i + dot(i, C.xxxx);\n\n    // Other corners\n\n    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n    vec4 i0;\n    vec3 isX = step(x0.yzw, x0.xxx);\n    vec3 isYZ = step(x0.zww, x0.yyz);\n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    // i0 now contains the unique values 0,1,2,3 in each channel\n    vec4 i3 = clamp(i0, 0.0, 1.0);\n    vec4 i2 = clamp(i0 - 1.0, 0.0, 1.0);\n    vec4 i1 = clamp(i0 - 2.0, 0.0, 1.0);\n\n    vec4 x1 = x0 - i1 + C.xxxx;\n    vec4 x2 = x0 - i2 + C.yyyy;\n    vec4 x3 = x0 - i3 + C.zzzz;\n    vec4 x4 = x0 + C.wwww;\n\n    // Permutations\n    i = mod289(i);\n    float j0 = permute(permute(permute(permute(i.w) + i.z) + i.y) + i.x);\n    vec4 j1 = permute(\n            permute(\n                    permute(\n                            permute(i.w + vec4(i1.w, i2.w, i3.w, 1.0)) + i.z\n                                    + vec4(i1.z, i2.z, i3.z, 1.0)) + i.y\n                            + vec4(i1.y, i2.y, i3.y, 1.0)) + i.x\n                    + vec4(i1.x, i2.x, i3.x, 1.0));\n\n    // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n    vec4 ip = vec4(1.0 / 294.0, 1.0 / 49.0, 1.0 / 7.0, 0.0);\n\n    vec4 p0 = grad4(j0, ip);\n    vec4 p1 = grad4(j1.x, ip);\n    vec4 p2 = grad4(j1.y, ip);\n    vec4 p3 = grad4(j1.z, ip);\n    vec4 p4 = grad4(j1.w, ip);\n\n    // Normalise gradients\n    vec4 norm = taylorInvSqrt(\n            vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt(dot(p4, p4));\n\n    // Mix contributions from the five corners\n    vec3 m0 = max(0.6 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0);\n    vec2 m1 = max(0.6 - vec2(dot(x3, x3), dot(x4, x4)), 0.0);\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0\n            * (dot(m0 * m0, vec3(dot(p0, x0), dot(p1, x1), dot(p2, x2)))\n                    + dot(m1 * m1, vec2(dot(p3, x3), dot(p4, x4))));\n\n}\n\nfloat snoise(vec3 v) {\n    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i);\n    vec4 p = permute(\n            permute(\n                    permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y\n                            + vec4(0.0, i1.y, i2.y, 1.0)) + i.x\n                    + vec4(0.0, i1.x, i2.x, 1.0));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_);    // mod(j,N)\n\n    vec4 x = x_ * ns.x + ns.yyyy;\n    vec4 y = y_ * ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n    vec3 p0 = vec3(a0.xy, h.x);\n    vec3 p1 = vec3(a0.zw, h.y);\n    vec3 p2 = vec3(a1.xy, h.z);\n    vec3 p3 = vec3(a1.zw, h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(\n            vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)),\n            0.0);\n    m = m * m;\n    return 42.0\n            * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));\n}\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n            0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n            -0.577350269189626,  // -1.0 + 2.0 * C.x\n            0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    float check = float(x0.x > x0.y);\n    i1 = vec2(check, 1.0 - check);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute(\n            permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));\n\n    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)),\n            0.0);\n    m = m * m;\n    m = m * m;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x = a0.x * x0.x + h.x * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n\n//\n// Mostly cribbed from https://www.shadertoy.com/view/llVXRd\n//\n\n\n// --------------------------------------------------------\n// Ray Marching\n// Adapted from cabbibo https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nstruct Model {\n    float dist;\n    vec3 normal;\n};\n\n\n\nstruct CastRay {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    float len;\n};\n\nstruct Hit {\n    Ray ray;\n    Model model;\n    vec3 pos;\n    bool isBackground;\n    vec3 normal;\n    vec3 color;\n};\n\n// --------------------------------------------------------\n// Gamma\n// https://www.shadertoy.com/view/Xds3zN\n// --------------------------------------------------------\n\nconst float GAMMA = 2.2;\n\nvec3 gamma(vec3 color, float g) {\n    return pow(color, vec3(g));\n}\n\nvec3 linearToScreen(vec3 linearRGB) {\n    return gamma(linearRGB, 1.0 / GAMMA);\n}\n\n// --------------------------------------------------------\n// Model/Camera Rotation\n// --------------------------------------------------------\nmat3 sphericalMatrix(float theta, float phi) {\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(\n        cy, -sy * -sx, -sy * cx,\n        0, cx, sx,\n        sy, cy * -sx, cy * cx\n    );\n}\n\n\nmat3 mouseRotation(bool enable, vec2 mouse, vec2 xy) {\n    if (!enable || mouse.x == 0.0 || mouse.y == 0.0) {\n        return mat3(1.0);\n    }\n\n    xy.x = mouse.x;\n    xy.y = mouse.y;\n    float rx, ry;\n    rx = (xy.y + .5) * PI;\n    ry = (-xy.x) * 2. * PI;\n    \n    return sphericalMatrix(rx, ry);\n}\n\nmat3 modelRotation(vec2 mouse) {\n    mat3 m = mouseRotation(MOUSE_CONTROL==1, mouse, MODEL_ROTATION);\n    return m;\n}\n\nmat3 cameraRotation(vec2 mouse) {\n    mat3 m = mouseRotation(MOUSE_CONTROL==2,  mouse, CAMERA_ROTATION);\n    return m;\n}\n\n\n// --------------------------------------------------------\n// Camera\n// https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nstruct Camera {\n    vec3 pos;\n    vec3 tar;\n    float roll;\n    mat3 lookAt;\n};\n\nCamera doCamera(in vec3 pos, in vec3 tar, in vec2 mouse) {\n    float roll = 0.;\n    pos *= cameraRotation(mouse);\n    pos += tar;\n    mat3 lookAt = calcLookAtMatrix(pos, tar, roll);\n    return Camera(pos, tar, roll, lookAt);\n}\n\n\nfloat length2(vec3 v) {\n    return (v.x * v.x) + (v.y * v.y) + (v.z * v.z);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}