{
    "Shader": {
        "info": {
            "date": "1457216695",
            "description": "applying Convex Cone Tracing ( https://www.shadertoy.com/view/4sy3Wd ) but approaching the surface from the far end",
            "flags": 0,
            "hasliked": 0,
            "id": "lsVGWd",
            "likes": 4,
            "name": "Concave Cone Tracing",
            "published": 3,
            "tags": [
                "newton",
                "silhouette",
                "conservative",
                "raphson",
                "concave"
            ],
            "usePreview": 0,
            "username": "paniq",
            "viewed": 1043
        },
        "renderpass": [
            {
                "code": "\n#define MAX_STEPS 20\n\n#define DAValue vec4\n\nstruct DAVec3 {\n    DAValue x;\n    DAValue y;\n    DAValue z;\n};\n\nDAVec3 da_domain(vec3 p) {\n\treturn DAVec3(\n        DAValue(1.0,0.0,0.0,p.x),\n        DAValue(0.0,1.0,0.0,p.y),\n        DAValue(0.0,0.0,1.0,p.z));\n}\n\nDAValue da_const(float a) {\n    return DAValue(0.0,0.0,0.0,a);\n}\n\nfloat safeinv(float x) {\n    return (x == 0.0)?x:1.0/x;\n}\n\nDAValue da_sub(DAValue a, DAValue b) {\n    return a - b;\n}\nDAValue da_sub(DAValue a, float b) {\n    return DAValue(a.xyz, a.w - b);\n}\nDAValue da_sub(float a, DAValue b) {\n    return DAValue(-b.xyz, a - b.w);\n}\n\nDAValue da_add(DAValue a, DAValue b) {\n    return a + b;\n}\nDAValue da_add(DAValue a, float b) {\n    return DAValue(a.xyz, a.w + b);\n}\nDAValue da_add(float a, DAValue b) {\n    return DAValue(b.xyz, a + b.w);\n}\n\nDAValue da_mul(DAValue a, DAValue b) {\n    return DAValue(a.xyz * b.w + a.w * b.xyz, a.w * b.w);\n}\nDAValue da_mul(DAValue a, float b) {\n    return a * b;\n}\nDAValue da_mul(float a, DAValue b) {\n    return a * b;\n}\n\nDAValue da_div(DAValue a, DAValue b) {\n    return DAValue((a.xyz * b.w - a.w * b.xyz) / (b.w * b.w), a.w / b.w);\n}\nDAValue da_div(DAValue a, float b) {\n    return a / b;\n}\nDAValue da_div(float a, DAValue b) {\n    return DAValue((-a * b.xyz) / (b.w * b.w), a / b.w);\n}\n\nDAValue da_min(DAValue a, DAValue b) {\n    return (a.w <= b.w)?a:b;\n}\nDAValue da_min(DAValue a, float b) {\n    return (a.w <= b)?a:da_const(b);\n}\nDAValue da_min(float a, DAValue b) {\n    return (a < b.w)?da_const(a):b;\n}\n\nDAValue da_max(DAValue a, DAValue b) {\n    return (a.w >= b.w)?a:b;\n}\nDAValue da_max(DAValue a, float b) {\n    return (a.w >= b)?a:da_const(b);\n}\nDAValue da_max(float a, DAValue b) {\n    return (a > b.w)?da_const(a):b;\n}\n\nDAValue da_pow2 (DAValue a) {\n    return DAValue(2.0 * a.w * a.xyz, a.w * a.w);\n}\n\nDAValue da_sqrt (DAValue a) {\n    float q = sqrt(a.w);\n    return DAValue(0.5 * a.xyz * safeinv(q), q);\n}\n        \nDAValue da_abs(DAValue a) {\n    return DAValue(a.xyz * sign(a.w), abs(a.w));\n}\nDAValue da_sin(DAValue a) {\n    return DAValue(a.xyz * cos(a.w), sin(a.w));\n}\nDAValue da_cos(DAValue a) {\n    return DAValue(-a.xyz * sin(a.w), cos(a.w));\n}\nDAValue da_log(DAValue a) {\n    return DAValue(a.xyz / a.w, log(a.w));\n}\nDAValue da_exp(DAValue a) {\n    float w = exp(a.w);\n    return DAValue(a.xyz * w, w);\n}\n\n\nDAValue da_length(DAValue x,DAValue y) {\n    float q = length(vec2(x.w,y.w));\n    return DAValue((x.xyz * x.w + y.xyz * y.w) * safeinv(q), q);\n}\nDAValue da_length(DAValue x,DAValue y,DAValue z) {\n    float q = length(vec3(x.w,y.w,z.w));\n    return DAValue((x.xyz * x.w + y.xyz * y.w + z.xyz * z.w) * safeinv(q), q);\n}\n\n// s: width, height, depth, thickness\n// r: xy corner radius, z corner radius\nDAValue sdSuperprim(DAVec3 p, vec4 s, vec2 r) {\n    DAValue dx = da_sub(da_abs(p.x),s.x);\n    DAValue dy = da_sub(da_abs(p.y),s.y);\n    DAValue dz = da_sub(da_abs(p.z),s.z);\n    DAValue q = \n        da_add(\n            da_length(\n                da_max(da_add(dx, r.x), 0.0),\n                da_max(da_add(dy, r.x), 0.0)),\n            da_min(-r.x,da_max(dx,dy)));\n    return da_add(\n                da_length(\n                    da_max(da_add(q, r.y),0.0),\n                    da_max(da_add(dz, r.y),0.0)),\n                da_min(-r.y,da_max(q,dz)));\n}\n\n// example parameters\n#define SHAPE_COUNT 10.0\nvoid getfactor (int i, out vec4 s, out vec2 r) {\n    //i = 8;\n    if (i == 0) { // cube\n        s = vec4(1.0);\n        r = vec2(0.0);\n    } else if (i == 1) { // corridor\n        s = vec4(vec3(1.0),0.25);\n        r = vec2(0.0);\n    } else if (i == 2) { // pipe\n        s = vec4(vec3(1.0),0.25);\n        r = vec2(1.0,0.0);\n    } else if (i == 3) { // cylinder\n        s = vec4(1.0);\n        r = vec2(1.0,0.0);\n\t} else if (i == 4) { // pill\n        s = vec4(1.0,1.0,2.0,1.0);\n        r = vec2(1.0);\n    } else if (i == 5) { // sphere\n        s = vec4(1.0);\n        r = vec2(1.0);\n    } else if (i == 6) { // pellet\n        s = vec4(1.0,1.0,0.25,1.0);\n        r = vec2(1.0,0.25);\n    } else if (i == 7) { // torus\n        s = vec4(1.0,1.0,0.25,0.25);\n        r = vec2(1.0,0.25);\n    } else if (i == 8) { // sausage mouth\n        s = vec4(2.0,0.5,0.25,0.25);\n        r = vec2(0.5,0.25);\n    } else if (i == 9) { // beveled O\n        s = vec4(0.7,1.0,1.0,0.25);\n        r = vec2(0.125);\n\t}\n}\n\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 1.5 + sin(time * 0.1) * 0.7;\n\tcamPos = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nDAValue doobject (DAVec3 p, float k) {\n    float u = smoothstep(0.0,1.0,smoothstep(0.0,1.0,fract(k)));\n    int s1 = int(mod(k,SHAPE_COUNT));\n    int s2 = int(mod(k+1.0,SHAPE_COUNT));\n    \n    vec4 sa,sb;\n    vec2 ra,rb;\n    getfactor(s1,sa,ra);\n    getfactor(s2,sb,rb);\n    \n    return  sdSuperprim(DAVec3(p.z, p.y, p.x), mix(sa,sb,u), mix(ra,rb,u));\n}\n\nbool interior;\n\nDAValue doModel( DAVec3 p ) {\n    float k = iTime*0.5;\n    DAValue d = doobject(p, k);\n    return d;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd, vec2 pixel, float bias, out int steps )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\t//float precis = 0.86602540378444 * max(pixel.y,pixel.x);        // precission of the intersection\n    float precis = 0.70710678118655 * max(pixel.y,pixel.x);        // precission of the intersection\n    DAValue h;\n    float t = 0.0;\n\tfloat res = -1.0;\n    steps = 0;\n    float tc = (bias > 0.0)?0.0:1.0;\n    \n    for( int i=0; i<MAX_STEPS; i++ )          // max number of raymarching iterations is 90\n    {\n        steps = i;\n        float rt = maxd - t;\n        DAValue dt = DAValue(-1.0,0.0,0.0,rt);\n        DAValue px = da_add(ro.x, da_mul(rd.x, dt));\n        DAValue py = da_add(ro.y, da_mul(rd.y, dt));\n        DAValue pz = da_add(ro.z, da_mul(rd.z, dt));\n\t    h = doModel(DAVec3(px,py,pz));\n        // apply conic shearing\n        h = da_sub(h, da_mul(dt, bias*precis));\n        // compute step size towards root\n        float st = abs(h.w) / max(-h.x,0.0);        \n        t += st;\n    \tif((abs(h.w) <= 1e-6) || (t > maxd)) {\n            break;\n        }\n    }\n    \n    if (abs(h.w) <= 1e-3)\n\t\tres = maxd - t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    DAValue d = doModel(da_domain(pos));\n    return d.xyz;\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nbool dorender( out float dist, out int steps, out vec3 position, in vec2 fragCoord, in vec2 resolution, in float bias)\n{\n    vec2 p = (-resolution.xy + 2.0*fragCoord.xy)/resolution.y;\n\n    //-----------------------------------------------------\n    // camera1\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, 0.0 );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd, 1.0 / resolution, bias, steps );\n    dist = t;\n    if( t>-0.5 )\n    {\n        // geometry\n        position = ro + t*rd;\n        return true;\n\t}\n    return false;\n}\n\nvec3 hue2rgb (float hue) {\n    return clamp(abs(mod(hue * 6.0 + vec3(0.0,4.0,2.0),6.0) - 3.0) - 1.0,0.0,1.0);\n}\n\n// maps n=0 to blue, n=1 to red, n=0.5 to green\nvec3 normhue (float n)  {\n    return hue2rgb((1.0 - clamp(n,0.0,1.0)) * 0.66667);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    float dist;\n    float dist_inner;\n    float dist_outer;\n    \n    interior = false;\n    vec2 resolution = iResolution.xy;\n    vec3 pos;\n    int steps;\n    bool hit = dorender(dist, steps, pos, fragCoord, resolution, 1.0);\n    \n    float K = 16.0;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 hresolution = floor((iResolution.xy + (K - 1.0)) / K);\n    vec2 hfragCoord = floor(uv * hresolution) + 0.5;\n    interior = false;\n    vec3 pos_inner;\n    int steps_inner;\n    bool hit_inner = dorender(dist_inner, steps_inner, pos_inner, hfragCoord, hresolution, -1.0);\n    interior = false;\n    vec3 pos_outer;\n    int steps_outer;\n    bool hit_outer = dorender(dist_outer, steps_outer, pos_outer, hfragCoord, hresolution, 1.0);\n    \n    fragColor = vec4(vec3(0.0),1.0);\n    if (hit_outer) {\n        if (hit_inner) {\n            if (hit) {\n\t        \tvec3 nor = calcNormal(pos);\n            \tfragColor = vec4((nor*0.5+0.5)*0.5,1.0);\n            } else {\n                // must not happen\n                fragColor = vec4(vec3(1.0),1.0);\n            }\n        } else if (hit)\n            fragColor.g = 1.0;\t\n        else\n        \tfragColor.r = 1.0;\n\t} else if (hit) {\n        // must not happen\n        fragColor = vec4(vec3(1.0),1.0);\n    }\n\n    if (hit) {\n        // outer shell always further than surface\n        if (dist > dist_outer)\n            fragColor = vec4(1.0,0.7,0.0,1.0);\n       \t// inner shell always contained within surface\n        else if (hit_inner && (dist_inner > dist))\n            fragColor = vec4(1.0,0.7,1.0,1.0);\n    }\n    //fragColor = vec4(normhue(dist - dist_inner),1.0);\n    //fragColor = vec4(normhue(float(steps_outer) / 10.0),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}