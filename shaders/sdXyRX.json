{
    "Shader": {
        "info": {
            "date": "1642447276",
            "description": "Ghost Village",
            "flags": 0,
            "hasliked": 0,
            "id": "sdXyRX",
            "likes": 13,
            "name": "Ghost Village",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "butadiene",
            "viewed": 366
        },
        "renderpass": [
            {
                "code": "#define HOUSWPOS vec3(8,4.,-10)\n\nmat2 rot(float r){\n  return mat2(cos(r),sin(r),-sin(r),cos(r));\n}\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nvec2 pmod(vec2 p,float n){\n    float np = 2.*3.14159265/n;\n    float r =atan(p.x,p.y)-0.5*np;\n    r = mod(r,np)-0.5*np;\n    return length(p)*vec2(cos(r),sin(r));\n}\n\nvec2 random2(vec2 st){\n    return texelFetch(iChannel0,ivec2(st),0).xy;\n}\n\nfloat noise (in vec2 st) {\n       vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n#define OCTAVES 4\nfloat fbm (in vec2 st) {\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .8;\n    }\n    return value;\n}\n\nfloat cylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n//https://iquilezles.org/articles/distfunctions\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat box(vec3 p,vec3 s){\n  vec3 q = abs(p);\n  vec3 m = max(s-q,0.);\n  return length(max(q-s,0.))-min(min(m.x,m.y),m.z);\n}\n\nvec2 froor(vec3 p,vec3 housepos){\n  float h = 1.4*fbm(100.+0.08*p.xz);\n  h += housepos.y*exp(-0.2*length(vec2(0.2,0.9)*(p.xz-housepos.xz-vec2(0,1.9)))); \n  return vec2(p.y-h,h);\n}\n\nfloat house(vec3 p,vec3 housepos){\nfloat sc = 1.2;\n  float radi = 0.125;\n  p -= housepos;\n  p *= sc;\n  p.xz *= rot(1.9);\n  p.y += 0.3;\n  vec3 sp = p;\n  \n  p.y -= 1.+2.*radi;\n  p.y = abs(p.y)-4.*radi;\n  p.xy *= rot(0.5*3.1416);\n  p.y = abs(p.y)-1.4121*1.5;\n  p.xz = abs(p.xz)-radi;\n  p.zy *= rot(0.25*3.141592);\n  p.x = abs(p.x-radi)-radi*1.;\n  float cyl = cylinder(p,radi*2.*12.,radi);\n  \n  p = sp;\n  p.y -= 3.;\n  p.xz *= rot(0.25*3.141592);\n  p.xz = abs(p.xz);\n  p.yz *= rot(0.25*3.141592);\n  float wall = box(p-vec3(1.4,-0.9,0.2),vec3(0.1,radi*12.,radi*12.));\n  float roof = box(p-vec3(0,0.7,0.4),vec3(1.8,0.1,1.8));\n  \n  p = sp;\n  p.zx *= rot(0.25*3.141592);\n  float door = box(p-vec3(0.6,1,0.9),vec3(0.5,1,1));\n  float d =  min(min(cyl,roof),min(wall,door));\n  return d/sc;\n}\n\nfloat grass(vec3 p,float h){\np.y -= 0.13;\nfloat k = 0.05;\nfloat cylinhigh = 2.8*noise(200.+p.xz*0.05);\nvec3 sp = p;\nfloat ks = 4.;\nfloat kt = 0.3;\nfloat kzx = 0.1;\nvec3 ds = 0.2*vec3((p.y-h)*ks*sin(kzx*p.x+iTime*kt),0,(p.y-h)*ks*cos(kzx*p.z+iTime*kt));\nfloat d2 = sdCappedCone(p-ds-vec3(0,h+cylinhigh*2.,0.),cylinhigh,0.025,0.);\n/*\nfor(int i = 0;i<8;i++){\np.xz = abs(p.xz)-1.;\n//p.xz *= rot(0.3);\nd2 = min(d2,sdCappedCone(p-vec3(0,h+cylinhigh*2.,0.),cylinhigh,0.025,0.));\n\n}*/\n\np = sp;\n  p.xz = mod(p.xz,k)-0.5*k;\n  float d = sdCappedCone(p-ds-vec3(0,h+cylinhigh*.5,0.),cylinhigh,0.05,0.);\n  return min(d2,d);\n}\n\nvec2 tree(vec3 p){ \nfloat sc = 0.6;\np *= sc;\n  float shi = 0.9;\n  float sr = 0.17;\n  float sd = cylinder(p,shi,sr);\n  p.y -= shi;\n  p.xz = pmod(p.xz,4.);\n  vec2 scale = vec2(0.75,0.67);\n  vec2 size = vec2(1.,sr);\n  float d = cylinder(p,size.x,size.y);\n  for(int i =0;i<3;i++){\n   p.x = abs(p.x);\n   p.y -= size.x;\n   p.xy *= rot(-0.7);\n   size *= scale;\n   d = min(d,cylinder(p,size.x,size.y));\n  }\n   p.xz = pmod(p.xz,7.);\n   for(int i =0;i<3;i++){\n   p.x = abs(p.x);\n   p.y -= size.x;\n   p.xy *= rot(-0.6);\n   size *= scale;\n   d = min(d,cylinder(p,size.x,size.y));\n  }\n  scale = vec2(0.6,0.6);\n   p.x = abs(p.x);\n   p.y -= size.x;\n   p.xy *= rot(-0.4);\n   size *= scale;\n   float ind = 0.;\n   d = min(d,cylinder(p,2.*size.x,size.y));\n   float kd = box(p-vec3(0,size.x*2.,0),1.2*vec3(0.05,0.07,0.01));\n    d = min(d,sd);\n   if(d>kd) ind = 1.0;\n   d = min(d,kd);\n \n  return vec2(d/sc,ind);\n\n}\n\nvec4 dist(vec3 p){\n  vec3 col = vec3(0);\n  vec3 housepos = HOUSWPOS;\n  vec2 dfroor = froor(p,housepos);\n  float dhouse = house(p,housepos);\n  float dgrass = grass(p,dfroor.y);\n  float dtree =tree(p-housepos-vec3(-4,0,0)).x;\n  float d = dhouse;\n  d = min(d,dfroor.x);\n  d = min(d,dgrass);\n  d = min(d,dtree);\n  return vec4(col,d);\n}\n\nvec3 getnormal(vec3 p){\n  vec2 e = vec2(0.0001,0.);\n  return normalize(vec3(\n    dist(p+e.xyy).w-dist(p-e.xyy).w,\n    dist(p+e.yxy).w-dist(p-e.yxy).w,\n    dist(p+e.yyx).w-dist(p-e.yyx).w\n    ));\n}\nfloat softray(vec3 ro, vec3 rd , float hn)\n{\n\tfloat t = 0.1;\n\tfloat jt = 0.0;\n\tfloat res = 1.;\n\tfor (int i = 0; i < 20; ++i) {\n\t\tjt = dist(ro+rd*t).w;\n\t\tres = min(res,jt*hn/t);\n\t\tt = t+ clamp(0.02,2.,jt);\n\t}\n\treturn clamp(res,0.,1.);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 r=iResolution.xy,p=(fragCoord.xy*2.-r)/min(r.x,r.y);\n    vec2 uv= fragCoord.xy/r;\n    vec3 ro = vec3(0,1.2,15.+25.*fract(iTime/25.));\n    vec3 ta = vec3(-1,5.8,0);\n    vec3 cdir = normalize(ta-ro);\n    vec3 side = cross(cdir,vec3(0,1,0));\n    vec3 up = cross(side,cdir);\n    vec3 rd = normalize(side*p.x+up*p.y+2.*cdir);\n    float d,t=0.0;\n    vec4 rsd = vec4(0);\n\n    float faraway = 100.;\n    float esp = 0.0001;\n    for(int i = 0;i<308;i++){\n      rsd = dist(ro+rd*t);\n      d = rsd.w;\n      t += d;\n      if(d<esp||t>faraway)break;\n    }\n    vec3 sp = ro+rd*t;\n    vec3 col = vec3(0);\n    if(d<esp&&t<faraway){\n        vec3 diffuse = vec3(0,0,0);\n          vec3 housepos = HOUSWPOS;\n        vec2 st = tree(sp-housepos-vec3(-4,0,0));\n      \n        vec2 sr = froor(sp,housepos);\n        float sh = house(sp,housepos);\n        float sg = grass(sp,sr.y);\n        \n        if(min(st.x,sr.x)<min(sh,sg)){\n         if(st.x<sr.x){\n             if(st.y<0.5){diffuse = vec3(0.3,0.22,0.1);\n             }else{\n             diffuse = vec3(0.3,0.8,0.3);\n             }\n         }\n         else{\n             diffuse = vec3(0.4,0.3,0.04);\n         }\n        }else if(sh<sg){\n         diffuse = vec3(0.7,0.5,0.3);\n        }else{\n           diffuse =vec3 (0.6,0.9,0.6);\n        }\n        \n        vec3 normal = getnormal(sp);\n        vec3 lightdir = normalize(vec3(0.1,1,1));\n\n        float val =max(dot(normal,lightdir),0.)*0.5+0.5;\n        float hlc = val *val*(3./(4.*3.141592));\n\n        vec3 shadowRay = normalize(vec3(0.1,1.,1));\n        float shadow = softray(sp,shadowRay,3.1);\n        col = vec3(diffuse*hlc*shadow);\n    }\n    vec3 fogcol = vec3(0.9,0.9,1.);\n    float far = 30.;\n    float near = 1.;\n    //col = mix(col,fogcol,clamp((t-near)/(far-near),0.,1.));\n   col = mix(fogcol,col,exp(-0.06*(t+fbm(uv*0.2+0.2*iTime)*10.)));\n   col = clamp(col,vec3(0),vec3(1));\n   col = pow(col,vec3(1.2,1.2,1.));\n    fragColor=vec4(col,1);\n    }",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}