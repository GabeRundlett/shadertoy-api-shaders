{
    "Shader": {
        "info": {
            "date": "1538401824",
            "description": "fog, repetition, csg. \nstarting to figure out better ways of applying colors",
            "flags": 0,
            "hasliked": 0,
            "id": "4tcBzn",
            "likes": 4,
            "name": "gloopalicious",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "benhardy",
            "viewed": 535
        },
        "renderpass": [
            {
                "code": "\nconst int BLDG_ID = 1;\nconst int GROUND_ID = 2;\nconst int BEAM_ID = 3;\nconst int EDGE_ID = 4;\nconst int HOLE_ID = 5;\n\n/**\n * Measure the distance between the given point\n * and the closest object in the scene.\n * Returns a vector containing:\n *.   x: the distance to the closest object\n *.   y: the id of the closest object, as a float\n */\nvec2 measure(vec3 where) {\n    vec3 offset = vec3(1.5, 1.5, 1.5);\n    vec3 center1 = ORIGIN;\n    vec3 local = repeat(where + offset, vec3(3,NEVER,3)) - offset;\n    float l= length(local.xz);\n    //local.xz = vec2(\n    local.xz = abs(local.xz);\n    local = vec3(min(local.x, local.z), local.y, max(local.x, local.z));\n    float s1 = sphere(local, center1, 1.00);\n    /*\n    float hole_spacing = 0.42;\n    vec3 hole_disp = vec3(hole_spacing,hole_spacing,hole_spacing);\n    float hole_size = 0.05;\n    vec3 hole_off = 0.5 * hole_disp;\n    vec3 hole_dims = vec3(hole_size, hole_size, hole_size);\n    vec3 holespot = repeat(local + hole_off, hole_disp) -hole_off;\n    float hole = round_box(holespot, hole_dims, 0.1);\n    \n    //beam = max(beam, -hole);\n    //float hole2 = round_box(holespot, hole_dims, 0.01);\n    //beam = max(beam, -hole);\n    */\n    float beam = round_box(local, vec3(0.25, 0.05, 3.00), 0.0);\n    float dist_exterior = blend(s1, beam, 0.1);\n    \n    vec3 holepos = local - vec3(0, 0.15, 0);\n    float beamhole = round_box(holepos, vec3(0.22, 0.15, 6.00), 0.005);\n    float dist_interior = max(dist_exterior, -beamhole);\n    \n    // do some edging around the beam hole on the building side\n    float d_edging = length(vec2(s1, beamhole-0.01501)) - 0.015;\n    float d_edging2 = length(vec2(s1, beamhole-0.06)) - 0.015;\n    float closest_edging = min(d_edging, d_edging2);\n    \n    float dist_plane = dot(where, Y) + 3.0;\n    \n    int who = GROUND_ID;\n    float closest = dist_plane;\n\n    if (dist_interior < closest) {\n\t    who = (beam < s1) ? BEAM_ID : BLDG_ID;\n        closest = dist_interior;\n    }\n    if (beamhole < closest) {\n        who = HOLE_ID;\n        closest = dist_interior;\n    }\n    if (closest_edging < closest) {\n        who = EDGE_ID;\n        closest = closest_edging;\n    }\n    return vec2(closest, who);\n}\n\n\n/**\n * Figure out coloring for where we hit\n */\nvec3 paint(vec2 hit, vec3 where) {\n    vec3 ground_color = vec3(0.18,0.18,0.22);\n    vec3 bldg_color = vec3(0.9,0.41,0.43);\n    vec3 edge_color = WHITE;\n    vec3 hole_color = WHITE;\n    vec3 beam_color = vec3(0.28,0.28,0.28);\n\n    int who = int(hit.y);\n    \n    if (who == BLDG_ID) {\n        return bldg_color;\n    }\n    if (who == GROUND_ID) {\n        return ground_color;\n    }\n    if (who == BEAM_ID) {\n        return beam_color;\n    }\n    if (who == EDGE_ID) {\n        return edge_color;\n    }\n    if (who == HOLE_ID) {\n        vec2 w = fract(where.xz*10.0);\n        return min(w.x, w.y) > 0.1 ? hole_color : BLACK;\n    }\n    return BLACK;\n}\n\n/**\n * Ray marching parameters for this scene\n */\nconst int   MAX_STEPS = 1000;\nconst float MAX_DIST = 30.0;\nconst float EPSILON = 0.001;\nconst float STEP_RATIO = 0.5;\n\nvec3 calc_surface_normal(vec3 hit);\n\n\n/**\n * main entrypoint\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(sin(iTime*0.1)*10.0+5.0,\n                    sin(iTime*0.13)*4.0+5.0,\n                    cos(iTime*0.1)*10.0-2.0);\n    vec3 look_at = ORIGIN;\n    vec3 up = Y;\n    vec3 ray = calculateRay(iResolution, fragCoord, eye, look_at, up);\n    \n    vec3 where = eye;\n    float total_dist = 0.0;\n    vec2 current;\n    int who = 0;\n    for(int steps =0;steps < MAX_STEPS; steps++) {\n        current = measure(where);\n        float current_dist = current.x;\n        if (current_dist < EPSILON) {\n            who = int(current.y);\n            break;\n        }\n        total_dist += current_dist * STEP_RATIO;\n        if (total_dist > MAX_DIST) {\n            break;\n        }\n        where = eye + total_dist * ray;\n    }\n\n    vec3 fog_color = vec3(0.9, 0.8, 0.45);\n    if (who == 0){\n        fragColor = vec4(fog_color, 1.0);\n        return;\n    }\n\tvec3 hit = where;\n    vec3 diffuse = paint(current, where);\n    vec3 to_light = normalize(vec3(1,3,-2));\n    float light_amount = max(0.0, dot(to_light, calc_surface_normal(hit)));\n    float light_fade = max(0.0, 1.0-total_dist / MAX_DIST);\n    float lighting = 0.5 * (1.0 + light_amount * light_fade);\n    // try some ambient occlusion\n    float unoccludedness = \n        max(0.0, measure(eye + (total_dist - 0.04) * ray).x) +\n        max(0.0, measure(eye + (total_dist - 0.06) * ray).x) +\n        max(0.0, measure(eye + (total_dist - 0.08) * ray).x) +\n        max(0.0, measure(eye + (total_dist - 0.10) * ray).x);\n    unoccludedness = 1.0; //min(1.0, 5.0 * unoccludedness)*0.7 + 0.3;\n    \n\tvec3 coloring = light_fade *(diffuse * unoccludedness * lighting)\n        + fog_color * (1.0-light_fade);\n    fragColor = vec4(coloring,1.0);\n}\n\n#define NORMAL_DELTA 0.001\n\nvec3 calc_surface_normal(vec3 hit) {\n\treturn normalize(vec3(\n            measure(hit+vec3(NORMAL_DELTA, 0.0, 0.0)).x - measure(hit-vec3(NORMAL_DELTA, 0.0, 0.0)).x,\n            measure(hit+vec3(0.0, NORMAL_DELTA, 0.0)).x - measure(hit-vec3(0.0, NORMAL_DELTA, 0.0)).x,\n            measure(hit+vec3(0.0, 0.0, NORMAL_DELTA)).x - measure(hit-vec3(0.0, 0.0, NORMAL_DELTA)).x\n    ));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MAX_FLOAT 3.402823466e+38\n#define MIN_FLOAT 1.175494351e-38\n#define MAX_DOUBLE 1.7976931348623158e+308\n#define MIN_DOUBLE 2.2250738585072014e-308\n\n// Indicate to 'repeat' function that we don't wish to\n#define NEVER 1000000.0\n\n/**\n * Common vectors\n */\nconst vec3 ORIGIN = vec3(0,0,0);\nconst vec3 X = vec3(1,0,0);\nconst vec3 Y = vec3(0,1,0);\nconst vec3 Z = vec3(0,0,1);\n\n/**\n * Common color values\n */\nconst vec3 BLACK = vec3(0,0,0);\nconst vec3 WHITE = vec3(1,1,1);\nconst vec3 RED   = vec3(1,0,0);\nconst vec3 GREEN = vec3(0,1,0);\nconst vec3 BLUE  = vec3(0,0,1);\nconst vec3 YELLOW  = vec3(1,1,0);\nconst vec3 CYAN    = vec3(0,1,1);\nconst vec3 MAGENTA = vec3(1,0,1);\n\n/**\n * For the given 2d screen position, figure out the ray vector\n */\nvec3 calculateRay(vec3 res, vec2 screenPos, \n                  vec3 eye, vec3 look_at, vec3 up) {\n\tvec2 screen_pos = screenPos.xy / res.xy;\n    float aspect = res.y / res.x;\n    screen_pos -= 0.5;\n    screen_pos.y *= aspect;\n    vec3 look_center = normalize(look_at - eye);\n    vec3 look_right = cross(up, look_center);\n    vec3 look_up = cross(look_center, look_right);\n        \n\tvec3 newRay = normalize(look_center + screen_pos.x * look_right + screen_pos.y * look_up);\n    return newRay;\n}\n\n/*\n * Signed distance functions for object primitives\n */\nfloat sphere(vec3 where, vec3 center, float radius) {\n  return length(where - center) - radius;\n}\n\nfloat round_box( vec3 where, vec3 sizes, float roundness ) {\n\treturn length(max(abs(where)-sizes,0.0))-roundness;\n}\n\nvec3 repeat(vec3 where, vec3 repetition) {\n\n    return mod(where, repetition);\n}\n\n\n#define PI 3.141592653589793\nvec3 radial_symmetry_xz(vec3 where, float count) {\n    float ang = mod(atan(where.x, where.z) + PI, 2.0 *PI /count);\n    float r = length(where.xz);\n    return vec3(r *cos(ang), where.y, r * sin(ang));\n}\n\n// polynomial smooth min (k = 0.1);\nfloat blend( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*0.25/k;\n}\n\n\nint hash(int x) {\n    x = ((x >> 16) ^ x) * 0x45d9f3b;\n    x = ((x >> 16) ^ x) * 0x45d9f3b;\n    x = (x >> 16) ^ x;\n    return x;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}