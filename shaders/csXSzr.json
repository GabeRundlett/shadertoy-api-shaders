{
    "Shader": {
        "info": {
            "date": "1668414816",
            "description": "Using mipmaps as a quadtree, I wrote a FAST traversal algorithm to find the signed distance within a pixel field.\nPrior to that I use a broad phase search.\nThis allows me to recursively search very deep down.\n\nF--K YES",
            "flags": 0,
            "hasliked": 0,
            "id": "csXSzr",
            "likes": 13,
            "name": "Texture SDF",
            "published": 3,
            "tags": [
                "2d",
                "sdf",
                "distance",
                "field",
                "signed"
            ],
            "usePreview": 1,
            "username": "Hatchling",
            "viewed": 393
        },
        "renderpass": [
            {
                "code": "// HOLY ---- I DID IT\n// Broad crawl outward, then a recursive mipmap quadtree search.\n// FAST runtime, FAST compilation (comparitavely).\n// Should compile in about ~7 seconds, ~70 FPS @ 1000x563\n\nconst int mipCount = 8;\nconst int maxMip = mipCount - 1;\n\nbool containsEdge(bool mySign, ivec2 coord, int mipLevel)\n{\n    float occupancy = cubeFetch(iChannel0, coord, mipLevel).r;\n\n    if(mySign)\n    {\n        return occupancy < 1.;\n    }\n    else\n    {\n        return occupancy > 0.;\n    }\n}\n\nbool isOccupied(vec2 uv)\n{\n    float occupancy = cubeLod(iChannel0, uv, 0.0).r;\n    return occupancy > 0.;\n}\n\nconst int SampleCoordCount = 64*8;\nconst ivec2 SampleCoords[64*8] = ivec2[64*8]\n(\n    ivec2( 0, -1), ivec2(-1,  0), ivec2(-1, -1), ivec2(+1,  0), \n    ivec2( 0, +1), ivec2(+1, -1), ivec2(-1, +1), ivec2(+1, +1), \n    ivec2( 0, -2), ivec2(-2,  0), ivec2(-1, -2), ivec2(-2, -1), \n    ivec2(+1, -2), ivec2(+2,  0), ivec2(-2, +1), ivec2( 0, +2), \n    ivec2(+2, -1), ivec2(-1, +2), ivec2(+2, +1), ivec2(+1, +2), \n    ivec2(-2, -2), ivec2( 0, -3), ivec2(+2, -2), ivec2(-3,  0), \n    ivec2(-1, -3), ivec2(-2, +2), ivec2(-3, -1), ivec2(+1, -3), \n    ivec2(+2, +2), ivec2(-3, +1), ivec2(+3,  0), ivec2(+3, -1), \n    ivec2( 0, +3), ivec2(-2, -3), ivec2(-3, -2), ivec2(-1, +3), \n    ivec2(+3, +1), ivec2(+1, +3), ivec2(+2, -3), ivec2(+3, -2), \n    ivec2(-3, +2), ivec2(-2, +3), ivec2( 0, -4), ivec2(-1, -4), \n    ivec2(+3, +2), ivec2(-4,  0), ivec2(+2, +3), ivec2(+1, -4), \n    ivec2(-4, -1), ivec2(-3, -3), ivec2(-4, +1), ivec2(+4,  0), \n    ivec2(+3, -3), ivec2(-2, -4), ivec2(+4, -1), ivec2(-4, -2), \n    ivec2( 0, +4), ivec2(+2, -4), ivec2(+4, +1), ivec2(-3, +3), \n    ivec2(-1, +4), ivec2(+1, +4), ivec2(-4, +2), ivec2(+4, -2),\n\n    ivec2( 0, -1), ivec2(+1,  0), ivec2(-1,  0), ivec2(+1, -1), \n    ivec2( 0, +1), ivec2(-1, -1), ivec2(+1, +1), ivec2(-1, +1), \n    ivec2( 0, -2), ivec2(+2,  0), ivec2(+1, -2), ivec2(+2, -1), \n    ivec2(-1, -2), ivec2(-2,  0), ivec2(-2, -1), ivec2( 0, +2), \n    ivec2(+2, +1), ivec2(+1, +2), ivec2(-2, +1), ivec2(-1, +2), \n    ivec2(+2, -2), ivec2(-2, -2), ivec2( 0, -3), ivec2(+1, -3), \n    ivec2(+3,  0), ivec2(+2, +2), ivec2(-1, -3), ivec2(+3, -1), \n    ivec2(-2, +2), ivec2(-3,  0), ivec2(+3, +1), ivec2(-3, -1), \n    ivec2( 0, +3), ivec2(+2, -3), ivec2(-3, +1), ivec2(+1, +3), \n    ivec2(+3, -2), ivec2(-1, +3), ivec2(-2, -3), ivec2(-3, -2), \n    ivec2(+3, +2), ivec2( 0, -4), ivec2(+2, +3), ivec2(-3, +2), \n    ivec2(+1, -4), ivec2(-2, +3), ivec2(+4,  0), ivec2(-1, -4), \n    ivec2(+4, -1), ivec2(+3, -3), ivec2(+4, +1), ivec2(-4,  0), \n    ivec2(-3, -3), ivec2(-4, -1), ivec2(+2, -4), ivec2( 0, +4), \n    ivec2(+4, -2), ivec2(-4, +1), ivec2(-2, -4), ivec2(+1, +4), \n    ivec2(+3, +3), ivec2(-1, +4), ivec2(-4, -2), ivec2(+4, +2),\n\n    ivec2( 0, +1), ivec2(-1,  0), ivec2(-1, +1), ivec2(+1,  0), \n    ivec2( 0, -1), ivec2(+1, +1), ivec2(-1, -1), ivec2(+1, -1), \n    ivec2( 0, +2), ivec2(-2,  0), ivec2(-1, +2), ivec2(-2, +1), \n    ivec2(+1, +2), ivec2(+2,  0), ivec2(-2, -1), ivec2( 0, -2), \n    ivec2(+2, +1), ivec2(-1, -2), ivec2(+2, -1), ivec2(+1, -2), \n    ivec2(-2, +2), ivec2( 0, +3), ivec2(+2, +2), ivec2(-3,  0), \n    ivec2(-1, +3), ivec2(-2, -2), ivec2(-3, +1), ivec2(+1, +3), \n    ivec2(+2, -2), ivec2(-3, -1), ivec2(+3,  0), ivec2(+3, +1), \n    ivec2( 0, -3), ivec2(-2, +3), ivec2(-3, +2), ivec2(-1, -3), \n    ivec2(+3, -1), ivec2(+1, -3), ivec2(+2, +3), ivec2(+3, +2), \n    ivec2(-3, -2), ivec2(-2, -3), ivec2( 0, +4), ivec2(-1, +4), \n    ivec2(+3, -2), ivec2(-4,  0), ivec2(+2, -3), ivec2(+1, +4), \n    ivec2(-4, +1), ivec2(-3, +3), ivec2(-4, -1), ivec2(+4,  0), \n    ivec2(+3, +3), ivec2(-2, +4), ivec2(+4, +1), ivec2(-4, +2), \n    ivec2( 0, -4), ivec2(+2, +4), ivec2(+4, -1), ivec2(-3, -3), \n    ivec2(-1, -4), ivec2(+1, -4), ivec2(-4, -2), ivec2(+4, +2),\n\n    ivec2( 0, +1), ivec2(+1,  0), ivec2(-1,  0), ivec2(+1, +1), \n    ivec2( 0, -1), ivec2(-1, +1), ivec2(+1, -1), ivec2(-1, -1), \n    ivec2( 0, +2), ivec2(+2,  0), ivec2(+1, +2), ivec2(+2, +1), \n    ivec2(-1, +2), ivec2(-2,  0), ivec2(-2, +1), ivec2( 0, -2), \n    ivec2(+2, -1), ivec2(+1, -2), ivec2(-2, -1), ivec2(-1, -2), \n    ivec2(+2, +2), ivec2(-2, +2), ivec2( 0, +3), ivec2(+1, +3), \n    ivec2(+3,  0), ivec2(+2, -2), ivec2(-1, +3), ivec2(+3, +1), \n    ivec2(-2, -2), ivec2(-3,  0), ivec2(+3, -1), ivec2(-3, +1), \n    ivec2( 0, -3), ivec2(+2, +3), ivec2(-3, -1), ivec2(+1, -3), \n    ivec2(+3, +2), ivec2(-1, -3), ivec2(-2, +3), ivec2(-3, +2), \n    ivec2(+3, -2), ivec2( 0, +4), ivec2(+2, -3), ivec2(-3, -2), \n    ivec2(+1, +4), ivec2(-2, -3), ivec2(+4,  0), ivec2(-1, +4), \n    ivec2(+4, +1), ivec2(+3, +3), ivec2(+4, -1), ivec2(-4,  0), \n    ivec2(-3, +3), ivec2(-4, +1), ivec2(+2, +4), ivec2( 0, -4), \n    ivec2(+4, +2), ivec2(-4, -1), ivec2(-2, +4), ivec2(+1, -4), \n    ivec2(+3, -3), ivec2(-1, -4), ivec2(-4, +2), ivec2(+4, -2),\n\n    ivec2(-1,  0), ivec2( 0, -1), ivec2(-1, -1), ivec2( 0, +1), \n    ivec2(+1,  0), ivec2(-1, +1), ivec2(+1, -1), ivec2(+1, +1), \n    ivec2(-2,  0), ivec2( 0, -2), ivec2(-2, -1), ivec2(-1, -2), \n    ivec2(-2, +1), ivec2( 0, +2), ivec2(-1, +2), ivec2(+1, -2), \n    ivec2(+2,  0), ivec2(+2, -1), ivec2(+1, +2), ivec2(+2, +1), \n    ivec2(-2, -2), ivec2(-3,  0), ivec2(-2, +2), ivec2(-3, -1), \n    ivec2( 0, -3), ivec2(+2, -2), ivec2(-3, +1), ivec2(-1, -3), \n    ivec2(+2, +2), ivec2( 0, +3), ivec2(+1, -3), ivec2(-1, +3), \n    ivec2(+3,  0), ivec2(-3, -2), ivec2(-2, -3), ivec2(+1, +3), \n    ivec2(+3, -1), ivec2(+3, +1), ivec2(-3, +2), ivec2(-2, +3), \n    ivec2(+2, -3), ivec2(-4,  0), ivec2(+3, -2), ivec2(-4, -1), \n    ivec2(+2, +3), ivec2( 0, -4), ivec2(+3, +2), ivec2(-4, +1), \n    ivec2(-1, -4), ivec2(-3, -3), ivec2(+1, -4), ivec2( 0, +4), \n    ivec2(-3, +3), ivec2(-4, -2), ivec2(-1, +4), ivec2(-2, -4), \n    ivec2(+4,  0), ivec2(-4, +2), ivec2(+1, +4), ivec2(+3, -3), \n    ivec2(+4, -1), ivec2(+4, +1), ivec2(-2, +4), ivec2(+2, -4),\n\n    ivec2(+1,  0), ivec2( 0, -1), ivec2( 0, +1), ivec2(+1, -1), \n    ivec2(-1,  0), ivec2(+1, +1), ivec2(-1, -1), ivec2(-1, +1), \n    ivec2(+2,  0), ivec2( 0, -2), ivec2(+2, -1), ivec2(+1, -2), \n    ivec2(+2, +1), ivec2( 0, +2), ivec2(-2,  0), ivec2(-1, -2), \n    ivec2(+1, +2), ivec2(-2, -1), ivec2(-1, +2), ivec2(-2, +1), \n    ivec2(+2, -2), ivec2(+2, +2), ivec2(+3,  0), ivec2( 0, -3), \n    ivec2(+3, -1), ivec2(-2, -2), ivec2(+1, -3), ivec2(+3, +1), \n    ivec2(-2, +2), ivec2(-1, -3), ivec2( 0, +3), ivec2(+1, +3), \n    ivec2(-3,  0), ivec2(+3, -2), ivec2(-3, -1), ivec2(-1, +3), \n    ivec2(+2, -3), ivec2(-3, +1), ivec2(+3, +2), ivec2(+2, +3), \n    ivec2(-2, -3), ivec2(-3, -2), ivec2(+4,  0), ivec2(-2, +3), \n    ivec2(+4, -1), ivec2(-3, +2), ivec2( 0, -4), ivec2(+4, +1), \n    ivec2(+1, -4), ivec2(+3, -3), ivec2(-1, -4), ivec2( 0, +4), \n    ivec2(+3, +3), ivec2(+1, +4), ivec2(+4, -2), ivec2(-4,  0), \n    ivec2(+2, -4), ivec2(-1, +4), ivec2(+4, +2), ivec2(-4, -1), \n    ivec2(-3, -3), ivec2(-4, +1), ivec2(-2, -4), ivec2(+2, +4),\n\n    ivec2(-1,  0), ivec2( 0, +1), ivec2(-1, +1), ivec2( 0, -1), \n    ivec2(+1,  0), ivec2(-1, -1), ivec2(+1, +1), ivec2(+1, -1), \n    ivec2(-2,  0), ivec2( 0, +2), ivec2(-2, +1), ivec2(-1, +2), \n    ivec2(-2, -1), ivec2( 0, -2), ivec2(-1, -2), ivec2(+1, +2), \n    ivec2(+2,  0), ivec2(+2, +1), ivec2(+1, -2), ivec2(+2, -1), \n    ivec2(-2, +2), ivec2(-3,  0), ivec2(-2, -2), ivec2(-3, +1), \n    ivec2( 0, +3), ivec2(+2, +2), ivec2(-3, -1), ivec2(-1, +3), \n    ivec2(+2, -2), ivec2( 0, -3), ivec2(+1, +3), ivec2(-1, -3), \n    ivec2(+3,  0), ivec2(-3, +2), ivec2(-2, +3), ivec2(+1, -3), \n    ivec2(+3, +1), ivec2(+3, -1), ivec2(-3, -2), ivec2(-2, -3), \n    ivec2(+2, +3), ivec2(-4,  0), ivec2(+3, +2), ivec2(-4, +1), \n    ivec2(+2, -3), ivec2( 0, +4), ivec2(+3, -2), ivec2(-4, -1), \n    ivec2(-1, +4), ivec2(-3, +3), ivec2(+1, +4), ivec2( 0, -4), \n    ivec2(-3, -3), ivec2(-4, +2), ivec2(-1, -4), ivec2(-2, +4), \n    ivec2(+4,  0), ivec2(-4, -2), ivec2(+1, -4), ivec2(+3, +3), \n    ivec2(+4, +1), ivec2(+4, -1), ivec2(-2, -4), ivec2(+2, +4),\n\n    ivec2(+1,  0), ivec2( 0, +1), ivec2( 0, -1), ivec2(+1, +1), \n    ivec2(-1,  0), ivec2(+1, -1), ivec2(-1, +1), ivec2(-1, -1), \n    ivec2(+2,  0), ivec2( 0, +2), ivec2(+2, +1), ivec2(+1, +2), \n    ivec2(+2, -1), ivec2( 0, -2), ivec2(-2,  0), ivec2(-1, +2), \n    ivec2(+1, -2), ivec2(-2, +1), ivec2(-1, -2), ivec2(-2, -1), \n    ivec2(+2, +2), ivec2(+2, -2), ivec2(+3,  0), ivec2( 0, +3), \n    ivec2(+3, +1), ivec2(-2, +2), ivec2(+1, +3), ivec2(+3, -1), \n    ivec2(-2, -2), ivec2(-1, +3), ivec2( 0, -3), ivec2(+1, -3), \n    ivec2(-3,  0), ivec2(+3, +2), ivec2(-3, +1), ivec2(-1, -3), \n    ivec2(+2, +3), ivec2(-3, -1), ivec2(+3, -2), ivec2(+2, -3), \n    ivec2(-2, +3), ivec2(-3, +2), ivec2(+4,  0), ivec2(-2, -3), \n    ivec2(+4, +1), ivec2(-3, -2), ivec2( 0, +4), ivec2(+4, -1), \n    ivec2(+1, +4), ivec2(+3, +3), ivec2(-1, +4), ivec2( 0, -4), \n    ivec2(+3, -3), ivec2(+1, -4), ivec2(+4, +2), ivec2(-4,  0), \n    ivec2(+2, +4), ivec2(-1, -4), ivec2(+4, -2), ivec2(-4, +1), \n    ivec2(-3, +3), ivec2(-4, -1), ivec2(-2, +4), ivec2(+2, -4)\n);\n\nconst ivec2 SubsampleCoords[4*8] = ivec2[4*8] \n(\n    ivec2(0, 0), ivec2(0, 1), ivec2(1, 0), ivec2(1, 1),\n    ivec2(1, 0), ivec2(1, 1), ivec2(0, 0), ivec2(0, 1),\n    ivec2(0, 1), ivec2(0, 0), ivec2(1, 1), ivec2(1, 0),\n    ivec2(1, 1), ivec2(1, 0), ivec2(0, 1), ivec2(0, 0),\n    ivec2(0, 0), ivec2(1, 0), ivec2(0, 1), ivec2(1, 1),\n    ivec2(1, 0), ivec2(0, 0), ivec2(1, 1), ivec2(0, 1),\n    ivec2(0, 1), ivec2(1, 1), ivec2(0, 0), ivec2(1, 0),\n    ivec2(1, 1), ivec2(0, 1), ivec2(1, 0), ivec2(0, 0)\n);\n\nint GetSampleIndexOffset(vec2 testToSample)\n{\n    int index;\n    index  = testToSample.x < 0. ? (1*64) : 0;\n    index |= testToSample.y < 0. ? (2*64) : 0;\n    index |= abs(testToSample.x) > abs(testToSample.y) ? (4*64) : 0;\n    return index;\n}\n\nint GetSubsampleIndexOffset(vec2 testToSample)\n{\n    int index;\n    index  = testToSample.x < 0. ? (1*4) : 0;\n    index |= testToSample.y < 0. ? (2*4) : 0;\n    index |= abs(testToSample.x) > abs(testToSample.y) ? (4*4) : 0;\n    return index;\n}\n\n// Returns the minimum distance from\n// a given coordinate to a square whose minimum\n// is coord, and whose maximum is coord+(1,1).\nvec3 get_diff_minDistSqr(vec2 point, ivec2 coord)\n{\n    vec2 squareCenter = vec2(coord) + vec2(0.5);\n    vec2 pointToCenter = squareCenter - point;\n    vec2 minOffset = clamp(pointToCenter, vec2(-0.5), vec2(0.5));\n    vec2 pointToMin = pointToCenter - minOffset;\n    return vec3(pointToMin, lengthSqr(pointToMin));\n}\n\nstruct SubSampleArgs\n{\n    ivec3 smpCrd_mip;\n    vec3 diff_distSqr;\n    vec2 testCoord;\n};\n\n#define MIP smpCrd_mip.z\n#define SAMPLECOORD smpCrd_mip.xy\n#define TESTCOORD testCoord\n#define DIFFDISTSQR diff_distSqr\n\nvoid IncreaseDepth(inout SubSampleArgs a)\n{\n    a.diff_distSqr *= vec3(2.0,2.0,4.0);\n    a.testCoord *= vec2(2.0,2.0);\n    a.smpCrd_mip += ivec3(a.smpCrd_mip.xy, -1);      \n}\n\nSubSampleArgs GetNextArgs(in SubSampleArgs a, ivec2 coord)\n{\n    a.SAMPLECOORD = coord;\n    a.diff_distSqr *= vec3(2.0,2.0,4.0);\n    a.testCoord *= vec2(2.0,2.0);\n    a.smpCrd_mip += ivec3(a.smpCrd_mip.xy, -1);    \n    return a;\n}\n\n// Define the function in a way that recursion is easy to type.\n// Too bad multi-line macros are not supported.\n#define SSH(name) vec3 name\n#define SSA00 (\n#define SSA01     SubSampleArgs a,\n#define SSA02     in bool    testOccupied\n#define SSA03 )\n#define SSA04 {    \n    \n                  // Get the subsample coordinates sorted by distance to the sample.\n#define SSA05     int iSubOffset = GetSubsampleIndexOffset(vec2(a.SAMPLECOORD + ivec2(1)) - a.TESTCOORD);   \n    \n                 // Go through subsamples from closest to furthest.\n#define SSA06    for(int iSub = 0; iSub < 4; iSub++)\n#define SSA07    {\n#define SSA08        ivec2 subsamplingCoord = a.SAMPLECOORD + SubsampleCoords[iSub + iSubOffset];\n#define SSA09        vec3 subsampleDiffDistSqr = get_diff_minDistSqr(a.TESTCOORD, subsamplingCoord);\n        \n#define SSA10        if(!(subsampleDiffDistSqr.z < a.DIFFDISTSQR.z))\n#define SSA11            continue;\n    \n#define SSA12        if(!containsEdge(testOccupied, subsamplingCoord, a.MIP))\n#define SSA13            continue;\n\n                     // Recursive   \n#define SSR(name)    subsampleDiffDistSqr = name                     \n#define SSB00        (\n#define SSB01            GetNextArgs(a, subsamplingCoord),\n#define SSB02            testOccupied\n#define SSB03        );\n\n#define SSC00        if(a.DIFFDISTSQR.z > subsampleDiffDistSqr.z) a.DIFFDISTSQR = subsampleDiffDistSqr;\n#define SSC01     }\n    \n#define SSC02     return a.DIFFDISTSQR * vec3(0.5, 0.5, 0.25);\n#define SSC03 }\n\n// Combine all of the lines into one macro.\n#define SSA_0 SSA00 SSA01 SSA02 SSA03 SSA04 SSA05 SSA06 SSA07 SSA08 SSA09\n#define SSA_1 SSA10 SSA11 SSA12 SSA13 \n\n#define SSB_0 SSB00 SSB01 SSB02 SSB03\n\n#define SSC_0 SSC00 SSC01 SSC02 SSC03\n\n#define SS_HEADER(n)        SSH(n)\n#define SS_START            SSA_0 SSA_1\n#define SS_RECURSIONCALL(n) SSR(n)\n#define SS_RECURSIVE        SSB_0\n#define SS_END              SSC_0\n\n#define SS_DECLARE_TERMINATING(name) SS_HEADER(name) SS_START SS_END\n\n#define SS_DECLARE_RECURSIVE(name, calls) SS_HEADER(name) SS_START SS_RECURSIONCALL(calls) SS_RECURSIVE SS_END\n\n#define RECURSION_DEPTH 7\nSS_DECLARE_TERMINATING(SubSample7)\nSS_DECLARE_RECURSIVE(SubSample6, SubSample7)\nSS_DECLARE_RECURSIVE(SubSample5, SubSample6)\nSS_DECLARE_RECURSIVE(SubSample4, SubSample5)\nSS_DECLARE_RECURSIVE(SubSample3, SubSample4)\nSS_DECLARE_RECURSIVE(SubSample2, SubSample3)\nSS_DECLARE_RECURSIVE(SubSample, SubSample2)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0, 0, 0, 1);\n    \n    ivec2 maxMipSize = textureSize(iChannel0, maxMip); \n    \n    // Set up mouse coordinates.\n    vec2 mouseUV = fragCoord / iResolution.xx * 2.0;\n    vec2 mouseTestCoord = mouseUV * vec2(maxMipSize);\n    ivec2 mouseTestIntCoord = floorToInt(mouseTestCoord);\n    bool mouseIsOccupied = isOccupied(mouseUV); \n    \n    // Set up fragment coordinates.\n    vec2 fragUV = fragCoord / iResolution.xx * 2.0;\n    vec2 fragTestCoord = fragUV * vec2(maxMipSize);\n    ivec2 fragTestIntCoord = floorToInt(fragTestCoord);\n    \n    // Color the fragment.\n    {\n        float density = 0.;\n        int count = 0;\n        for(int i = maxMip-RECURSION_DEPTH; i <= maxMip; i++)\n        {\n            ivec2 mipSize = textureSize(iChannel0, i);\n            bool fragIsOccupied = containsEdge(false, ivec2(fragUV * vec2(mipSize)), i);   \n            bool fragIsOccupied2 = containsEdge(true, ivec2(fragUV * vec2(mipSize)), i);   \n\n            density += fragIsOccupied ? 1. : 0.;\n            density += !fragIsOccupied2 ? 1. : 0.;\n            count+=2;\n            \n            // Remove this to show all mip levels explored.\n            break;\n        }\n            \n        // Compress the range to 0-1\n        density /= 10. + density;\n        \n        density /= float(count) / (float(10 + count)); \n        //density = smoothstep(0., 1., density);\n        //density *= density;\n        \n        fragColor.rgb = hsv2rgb(vec3(density*density*density*density*2.0 + 0.5, 1.-density * 0.5, density* 0.5));\n    }\n    \n    vec3 diff_distSqr = vec3(4.0, 0.0, 16.0);\n\n    int iCoordOffset = GetSampleIndexOffset((vec2(mouseTestIntCoord) + vec2(0.5) - mouseTestCoord));\n    for(int iCoord = -1; iCoord < 64; iCoord++)\n    {\n        ivec2 samplingCoord = mouseTestIntCoord;// + iCoord == -1 ? SampleCoords[iCoord + iCoordOffset];\n        if(iCoord >= 0)\n        {\n            samplingCoord += SampleCoords[iCoord + iCoordOffset];\n        }\n        \n        vec3 sampleDiffDistSqr = get_diff_minDistSqr(mouseTestCoord, samplingCoord);\n        \n        // Need to add a bias for some reason.\n        if(sampleDiffDistSqr.z >= diff_distSqr.z + 1.5)\n            break;\n            \n        if(sampleDiffDistSqr.z >= diff_distSqr.z)\n            continue; \n            \n        if(samplingCoord == fragTestIntCoord)\n            fragColor += vec4(0.1, 0, 0, 0);\n            \n        if(!containsEdge(mouseIsOccupied, samplingCoord, maxMip))\n            continue;\n            \n        /*if(sampleDistSqr < distSqrToSignChange)\n        {\n            distSqrToSignChange = sampleDistSqr;\n        }*/\n            \n        SubSampleArgs a;\n        a.DIFFDISTSQR = diff_distSqr;\n        a.SAMPLECOORD = samplingCoord;\n        a.MIP = maxMip;\n        a.TESTCOORD = mouseTestCoord;\n        IncreaseDepth(a);\n        diff_distSqr = SubSample\n        (\n            a,\n            mouseIsOccupied\n        ); \n    }\n         \n    vec3 diff_dist = vec3(diff_distSqr.xy, sqrt(diff_distSqr.z) * (mouseIsOccupied ? -1.0 : 1.0));     \n         \n    drawSDF\n    (\n        diff_dist,\n        fragColor\n    );\n    \n    // Compress the range to 0-1\n    //fragColor /= vec4(0.25) + fragColor;\n    //fragColor = smoothstep(vec4(0), vec4(1), fragColor);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "///////////////////////////////////////////////\n// HELPER FUNCTIONS\n///////////////////////////////////////////////\n\nfloat dot2(vec2 a, vec2 b) { return a.x * b.x + a.y * b.y; }\nfloat dot2(vec3 a, vec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nfloat dot2(vec4 a, vec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\nint dot2(ivec2 a, ivec2 b) { return a.x * b.x + a.y * b.y; }\nint dot2(ivec3 a, ivec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nint dot2(ivec4 a, ivec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\n\n#define decl_lengthSqr(retType, type) retType lengthSqr(type a) { type t = a; return dot2(t,t); }\ndecl_lengthSqr(float, vec2)\ndecl_lengthSqr(float, vec3)\ndecl_lengthSqr(float, vec4)\ndecl_lengthSqr(int, ivec2)\ndecl_lengthSqr(int, ivec3)\ndecl_lengthSqr(int, ivec4)\n\n#define decl_distSqr(retType, type) retType distSqr(type a, type b) { type diff = a-b; return lengthSqr(diff); }\ndecl_distSqr(float, vec2)\ndecl_distSqr(float, vec3)\ndecl_distSqr(float, vec4)\ndecl_distSqr(int, ivec2)\ndecl_distSqr(int, ivec3)\ndecl_distSqr(int, ivec4)\n\n// I don't trust int(floor(x)).\n// So, for positive values:\n//\n// x = floor(x)\n//\n// Add 0.5 in case floor(x) rounded it to some floating point garbage like 23.99999\n// x += 0.5\n//\n// ix = int(x) // THEN cast to an int.\n//\n// Similar thing happens for negative values.\n#define decl_floorToInt(retType, type) retType floorToInt(type a) { return retType(floor(a) + sign(a) * type(0.5)); }\ndecl_floorToInt(int, float)\ndecl_floorToInt(ivec2, vec2)\ndecl_floorToInt(ivec3, vec3)\ndecl_floorToInt(ivec4, vec4)\n    \n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 hsv2rgb(vec3 hsv) \n{\n    vec3 h3 = mod(6.0 * hsv.x + vec3(5.0, 3.0, 1.0), 6.0);\n    h3 = min(h3, 4.0 - h3);\n    h3 = clamp(h3, 0.0, 1.0);\n    return hsv.z - hsv.z * hsv.y * h3;\n}\n\n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 palette(int i) \n{\n    float f = float(i);\n    float h =  mod(1.618033988749894848204586834 * f, 1.0);\n    float s = exp(-0.00025 * f) * 0.65 + 0.25;\n    float v = 1.0;\n    return hsv2rgb(vec3(h, s, v));\n}\n\nvec4 cubeFetch(samplerCube cube, ivec2 coord, int mip)\n{\n    vec2 uv = (vec2(coord) + vec2(0.5)) / vec2(textureSize(cube, mip));\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return textureLod(cube, ray, float(mip));\n}\n\nvec4 cubeLod(samplerCube cube, vec2 uv, float mip)\n{\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return textureLod(cube, ray, mip);\n}\n\n// Drawing helpers --------------------------------\n\nvoid blend(in vec4 src, inout vec4 dest)\n{\n    dest.rgb = mix(dest.rgb, src.rgb, src.a);\n    dest.a = mix(dest.a, 1.0, src.a);    \n}\n\nvoid drawCircle(vec2 center, vec2 frag, float radius, float lineWidth, vec4 lineColor, inout vec4 color)\n{\n    float distanceToEdge = abs(radius - distance(frag, center));\n\n    float circle = smoothstep\n    (\n        0.0, \n        1.0,\n        1.0 - (distanceToEdge / lineWidth) \n    );\n                \n    lineColor.a *= circle;\n    blend(lineColor, color);\n}\n\nvoid drawSDF(vec3 diff_dist, inout vec4 color)\n{\n    float d = diff_dist.z;\n    vec2 grad = diff_dist.xy/(d);\n    \n    vec3 c = normalize(vec3(grad,sign(d))) * 0.5 + 0.5;\n\tc *= 1. - exp2(-12. * abs(d));\n\tc *= .8 + .2 * cos(120.*d);\n\n    color.rgb = c;\n}\n\nvec3 unsignedValueToColor(float value)\n{\n    float valueLog = log2(value + 0.0625);\n    valueLog /= 16.0;\n    //value /= 1. + abs(valueLog);\n    valueLog = valueLog * 0.5 + 0.5;\n    \n    value *= 10.0;\n    value += 0.125;\n    value /= 1. + abs(value);\n    \n    return hsv2rgb(vec3(valueLog, 1, value));\n}\n\n// Font helpers ------------------------------\n#define FONTSAMPLERSIZE vec2(1024, 1024)\n#define FONTSAMPLERSIZEI ivec2(1024, 1024)\n#define FONTELEMENTCOUNT  vec2(16, 16)\n#define FONTELEMENTCOUNTI  ivec2(16, 16)\n#define FONTELEMENTSIZE  vec2(64, 64)\n#define FONTELEMENTSIZEI  ivec2(64, 64)\nvec4 sampleFontElement(sampler2D fontSampler, in vec2 fragCoord, in ivec2 element)\n{\n    vec2 samplerCoordMin = vec2(element * FONTELEMENTSIZEI); \n    vec2 samplerCoordMax = vec2(element * FONTELEMENTSIZEI + FONTELEMENTSIZEI); \n    \n    vec2 elementUV = (fragCoord - samplerCoordMin) / FONTELEMENTSIZE;\n    elementUV -= floor(elementUV);\n    \n    vec2 samplerCoord = mix(samplerCoordMin, samplerCoordMax, elementUV);\n    vec2 samplerUV = samplerCoord / FONTSAMPLERSIZE;\n    \n    return texture(fontSampler, samplerUV);\n}\n\nvec4 sampleFontElementColor(sampler2D fontSampler, in vec2 fragCoord, in ivec2 element, in vec4 color)\n{\n    float opacity = sampleFontElement(fontSampler, fragCoord, element).r;\n    \n    color.a *= opacity;\n    \n    return color;\n}\n\n\n\n///////////////////////////////////////////////\n// DATA\n///////////////////////////////////////////////\n\n#define DATA iChannel3\n\nconst int DataCompleteFrame = 4;\n\n// Sampling Order -------------------------------\n// Frame 0: Imprecise version calculated.\n// Frane 2: Precise version calculated.\n//     Depends on:\n//         - Sampling Order, Frame 0\n//         - Sampling Distance, Frame 1\n// Frame 3: Ready.\n\nconst int SamplingOrderRow = 0;\nconst int SamplingOrderCount = 101;\nconst int SamplingOrderFrameImprecise = 0;\nconst int SamplingOrderFramePrecise = 2;\n\n\nivec3 GetSamplingOrderCoord(int n, sampler2D data)\n{\n    ivec2 coord = ivec2(n, SamplingOrderRow);\n    \n    return ivec3(texelFetch(data, coord, 0));\n}\n\nvec4 DebugSamplingOrderCoord(int n, sampler2D data)\n{\n    ivec3 d = GetSamplingOrderCoord(n, data);\n    \n    \n    vec4 color = vec4\n    (\n        vec3(d.xyz) / vec3(vec2(10), 5), \n        1\n    );\n    \n    color.xyz /= (1.0 + abs(color.xyz));\n    color.xy += 0.5;\n    return color;\n}\n\n// Cached Sampling Distances -------------------------------\n// Frame 1: Calculate minimum distance between Pixel[0] and Pixel[N].\n//     Depends on:\n//         - Sampling Order, Frame 0\n// Frame 3: Recalculate distances with new precise ordering.\n//     Depends on:\n//         - Sampling Order, Frame 2\nconst int SamplingDistanceRow = 1;\nconst int SamplingDistanceFrameImprecise = 1;\nconst int SamplingDistanceFramePrecise = 3;\nfloat GetSamplingDistance(int n, sampler2D data)\n{\n    ivec2 coord = ivec2(n, SamplingDistanceRow);\n    \n    return texelFetch(data, coord, 0).x;\n}\n\nvec4 DebugSamplingDistance(int n, sampler2D data)\n{\n    float d = GetSamplingDistance(n, data);\n    \n    d *= 0.01;\n    d = d / (1.0 + d);\n    \n    vec4 color = vec4(1);\n    color.rgb = hsv2rgb(vec3(d, 1.0, 1.0));\n    return color;\n}\n\n\n\nvoid debugAllData( sampler2D dataChannel, out vec4 fragColor, in vec2 fragCoord )\n{      \n    ivec2 iCoord = floorToInt(fragCoord);\n    \n    switch(iCoord.y)\n    {\n        case SamplingOrderRow: fragColor = DebugSamplingOrderCoord(iCoord.x, dataChannel); return;\n        case SamplingDistanceRow: fragColor = DebugSamplingDistance(iCoord.x, dataChannel); return;\n    }\n    \n    fragColor = texelFetch(dataChannel, iCoord, 0);\n}\n\n/////////////////////////////////////////////////////////////\n// C# Code used to precompute coordinate lookup tables:\n/*\nusing System;\nusing System.Numerics;\nusing System.Collections.Generic;\nusing System.Linq;\n\t\t\t\t\t\npublic class Program\n{\n\tstatic void GetSubsampleCoords(int index, out int[] c0, out int[] c1, out int[] c2, out int[] c3)\n\t{\n\t\tint r = 0x1B; // 00 10 01 11;\n\n\t\tif((index & 1) != 0)\n\t\t{\n\t\t\tconst int xor = 0xAA; // 10 10 10 10\n\t\t\tr = r ^ xor;\n\t\t}\n\n\t\tif((index & 2) != 0)\n\t\t{\n\t\t\tconst int xor = 0x55; // 01 01 01 01\n\t\t\tr = r ^ xor;\n\t\t}\n\n\t\tif((index & 4) != 0)\n\t\t{\n\t\t\tconst int xor = 0x3C; // 00 11 11 00\n\t\t\tr = r ^ xor;\n\t\t}\n\n\t\tint[] c0_m = new int[2]\n\t\t{\n\t\t\t0x80, // 10 00 00 00\n\t\t\t0x40 // 01 00 00 00\n\t\t};\n\n\t\tint[] c0_s = new int[2]\n\t\t{\n\t\t\t7,\n\t\t\t6\n\t\t};\n\t\t\n\t\tint[] c1_m = new int[2]\n\t\t{\n\t\t\t0x20, // 00 10 00 00\n\t\t\t0x10  // 00 01 00 00\n\t\t};\n\n\t\tint[] c1_s = new int[2]\n\t\t{\n\t\t\t5, \n\t\t\t4 \n\t\t};\n\n\t\tint[] c2_m = new int[2]\n\t\t{\n\t\t\t0x08, // 00 00 10 00\n\t\t\t0x04  // 00 00 01 00\n\t\t};\n\n\t\tint[] c2_s = new int[2]\n\t\t{\n\t\t\t3, \n\t\t\t2\n\t\t};\n\t\t\n\t\tint[] c3_m = new int[2]\n\t\t{\n\t\t\t0x02, // 00 00 00 10\n\t\t\t0x01  // 00 00 00 01\n\t\t};\n\n\t\tint[] c3_s = new int[2]\n\t\t{\n\t\t\t1,\n\t\t\t0\n\t\t};\n\t\t\n\t\tc0 = new int[2];\t\t\n\t\tc1 = new int[2];\n\t\tc2 = new int[2];\n\t\tc3 = new int[2];\n\t\tfor(int i = 0; i < 2; i++)\n\t\t{\n\t\t\tc0[i] = (r & c0_m[i]) >> c0_s[i];\n\t\t\tc1[i] = (r & c1_m[i]) >> c1_s[i];\n\t\t\tc2[i] = (r & c2_m[i]) >> c2_s[i];\n\t\t\tc3[i] = (r & c3_m[i]) >> c3_s[i];\n\t\t}\n\t}\n\t\n\tstatic string AsString(int[] v)\n\t{\n\t\tstring s = \"ivec2(\";\n\t\t\n\t\tfor(int i = 0; i < v.Length; i++)\n\t\t{\n\t\t\tif(i > 0)\n\t\t\t{\n\t\t\t\ts = s + \", \";\n\t\t\t}\n\t\t\ts = s + v[i].ToString();\n\t\t}\n\t\t\n\t\ts += \"), \";\n\t\treturn s;\n\t}\n\t\n\tstatic Vector2 GetTestCoord(int index)\n\t{\n\t\tVector2 v = default(Vector2);\n\t\t\n\t\t// abs(x) > abs(y)?\n\t\tif((index & 4) != 0)\n\t\t{\n\t\t\tv.X = 0.25f;\n\t\t\tv.Y = 0.125f;\n\t\t}\t\n\t\telse\n\t\t{\n\t\t\tv.X = 0.125f;\n\t\t\tv.Y = 0.25f;\n\t\t}\n\t\t\n\t\t// x < 0?\n\t\tif((index & 1) != 0)\n\t\t{\n\t\t\tv.X = -v.X;\n\t\t}\n\t\t\n\t\t// y < 0?\n\t\tif((index & 2) != 0)\n\t\t{\n\t\t\tv.Y = -v.Y;\n\t\t}\n\t\t\n\t\treturn -v;\n\t}\n\t\n\tstatic string AsString(Vector2 v)\n\t{\n\t\treturn string.Format\n\t\t(\n\t\t\t\"ivec2({0}{1}, {2}{3})\", \n\t\t\t v.X < 0 ? '-' : (v.X > 0 ? '+' : ' '), \n\t\t\t Math.Abs(v.X), \n\t\t\t v.Y < 0 ? '-' : (v.Y > 0 ? '+' : ' '), \n\t\t\t Math.Abs(v.Y)\n\t     );\n\t}\n\t\n\tstatic string AsString(Vector2[] v)\n\t{\n\t\tstring s = \"\";\n\t\t\n\t\tfor(int i = 0; i < v.Length; i++)\n\t\t{\n\t\t\tif(i > 0)\n\t\t\t{\n\t\t\t\ts = s + \", \";\n\t\t\t\t\n\t\t\t\tif(i % 4 == 0)\n\t\t\t\t\ts = s + '\\n';\n\t\t\t}\n\t\t\ts = s + AsString(v[i]);//.ToString();\n\t\t}\n\t\t\n\t\ts += \",\";\n\t\treturn s;\n\t}\n\t\n\tpublic static void Main()\n\t{\n\t\tfor(int i = 0; i < 8; i++)\n\t\t{\n\t\t\tint[] a, b, c, d;\n\t\t\tGetSubsampleCoords(i, out a, out b, out c, out d);\n\t\t\t\n\t\t\t\n\t\t\tConsole.WriteLine(AsString(a) \n\t\t\t\t\t\t\t+ AsString(b)\n\t\t\t\t\t\t\t+ AsString(c)\n\t\t\t\t\t\t\t+ AsString(d));\n\t\t}\n\t\t\n\t\tConsole.WriteLine(\"________________\");\n\t\tConsole.WriteLine(\"                \");\n\t\t\n\t\tconst int radius = 4;\n\t\tconst int diameter = radius+radius+1;\n\t\tconst int capacity = diameter * diameter - 1;\n\t\tList<Vector2> pixelCoords = new List<Vector2>(capacity);\n\t\t\n\t\tconst float maxDistanceSqr = (radius + 0.5f) * (radius + 0.5f);\n\n\t\tfor(int x = -radius; x <= radius; x++)\n\t\t{\n\t\t\tfor(int y = -radius; y <= radius; y++)\n\t\t\t{\n\t\t\t\tif(x == 0 && y == 0) continue;\n\t\t\t\tpixelCoords.Add(new Vector2(x,y));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 8; i++)\n\t\t{\n\t\t\tVector2 testCoord = GetTestCoord(i);\n\t\t\t\n\t\t\tvar pixelsSorted = pixelCoords.Where(p => Vector2.DistanceSquared(p, testCoord) <= maxDistanceSqr).OrderBy(p => Vector2.DistanceSquared(p, testCoord)).ToArray();\n\t\t\t\n\t\t\t//Console.WriteLine(pixelsSorted.Length);\n\t\t\tConsole.WriteLine(AsString(pixelsSorted));\n\t\t\tConsole.WriteLine(\"\");\n\t\t}\n\t}\n}\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// This is a really stupid work-around to enforcing power-of-two buffers... but whatever.\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec2 uv = fragCoord / iChannelResolution[0].xy; \n    \n    float thresh = sin(iTime) * 0.25 + 0.5;\n    fragColor = texture(iChannel0, uv).r > thresh ? vec4(1) : vec4(0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            }
        ],
        "ver": "0.1"
    }
}