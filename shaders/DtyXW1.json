{
    "Shader": {
        "info": {
            "date": "1686060135",
            "description": "A cluster of stars in a nebula. Largely physically based but not entirely. Uses two path-tracing runs to calculate the radial density at each point along the line of sight for extinction.",
            "flags": 32,
            "hasliked": 0,
            "id": "DtyXW1",
            "likes": 10,
            "name": "Dusty Nebula",
            "published": 3,
            "tags": [
                "raymarching",
                "space",
                "nebula"
            ],
            "usePreview": 0,
            "username": "thepinkpanzer",
            "viewed": 347
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Bloom p2\n    vec4 bloom = vec4(0.0);\n    for (float n = -BLOOMSIZE; n < BLOOMSIZE+1.; n++)\n    {\n        bloom += texture(iChannel1, (fragCoord + vec2(0,1)*n)/iResolution.xy)*exp(-(4.*n*n)/(BLOOMSIZE*BLOOMSIZE));\n    }\n    bloom /= BLOOMSIZE;\n    \n    // PSF\n    vec4 psf = vec4(0.0);\n    for (float n = -PSFSIZE; n < PSFSIZE+1.; n++)\n    {\n        float falloff = (PSFSIZE-n)*(PSFSIZE+n)*(0.2*PSFSIZE/(0.2*PSFSIZE+abs(n)))/(PSFSIZE*PSFSIZE*log(PSFSIZE)*4.);\n        psf += texture(iChannel0, (fragCoord + vec2(1,0)*n)/iResolution.xy)*falloff;\n        psf += texture(iChannel0, (fragCoord + vec2(0,1)*n)/iResolution.xy)*falloff;\n    }\n    \n    // put it all together\n    fragColor = tanh(bloom*2. + psf*0.6 + 0.2*texture(iChannel0, fragCoord/iResolution.xy));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float DustDensity(vec3 pos)\n{\n    //smoothstep(0.7,0.8,\n    vec4 d1  = texture(iChannel1, pos*0.2);\n    float r1 = 2.*(d1.r+d1.g)*(1.-pow(dot(pos, pos)/(RCLOUD*RCLOUD)+1., -3.))/pow(1.+dot(pos, pos)/(1.8*RCLOUD*RCLOUD), 3.);\n    r1      *= mix((1.+dot(normalize(pos), vec3(1.,0,0))), 1., 0.9);\n    float r2 = smoothstep(0.7, 0.8, r1);\n    \n    vec4 d2  = texture(iChannel1, pos*0.5);\n    float r3 = (d2.r + d2.g + d2.b + d2.a)/(6.*RCLOUD*RCLOUD+dot(pos, pos));\n    return (0.1*r3+r2);\n}\nfloat GasDensity(vec3 pos)\n{\n    //smoothstep(0.7,0.8,\n    vec4 d1  = texture(iChannel1, pos*0.2);\n    float r1 = 2.*(d1.r+d1.g)*(1.-pow(dot(pos, pos)/(RCLOUD*RCLOUD)+1., -3.))/(1.5*RCLOUD*RCLOUD+dot(pos, pos));\n    float r2 = smoothstep(0.7, 0.8, r1);\n    \n    vec4 d2  = texture(iChannel1, pos*0.5);\n    float r3 = (d2.r + d2.g + d2.b + d2.a)/(6.*RCLOUD*RCLOUD+dot(pos, pos));\n    return (r3+0.4*r2);\n}\nvec3 StarPos(float i)\n{\n    float theta = i*3.65432345;\n    float phi   = i*10.5643213;\n    return RCLUSTER*fract(i*PI)*vec3(sin(theta)*cos(phi), cos(theta)*cos(phi), sin(phi));\n}\nvec4 StarCol(float i)\n{\n    float temp = fract(i*163.675443);\n    float lum  = fract(i*87.4345634);\n    \n    return mix(vec4(1,0.7,0.4,0), mix(vec4(1), vec4(0.4,0.7,1.,0),temp),temp)*(0.2+temp*lum)*0.5*(1.+texture(iChannel0, 0.1*(iTime+i*0.543)*vec2(1,PI)).r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float theta = (iMouse.x - iResolution.x / 2.) / iResolution.y * PI;\n    float phi   = (iMouse.y - iResolution.y / 2.) / iResolution.y * PI;\n    #ifdef STEREOGRAPHIC\n        // CAMERA\n        vec2 fc = vec2(fragCoord.x - (fragCoord.x < iResolution.x/2. ? 0. : iResolution.x/2.), fragCoord.y);\n        vec3 iCameraFwd     = vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\n        vec3 iCameraUp      = vec3(-sin(theta)*sin(phi),cos(phi),-cos(theta)*sin(phi));\n        vec3 iCameraRight   = normalize(cross(iCameraUp, iCameraFwd));\n\n        vec3 iCameraPosition= -5.*iCameraFwd + EYESEP*(fragCoord.x < iResolution.x/2. ? -iCameraRight : iCameraRight);\n\n        float m = 1.0;\n\n        vec3 iViewDirection = iCameraFwd + ((fc.x - iResolution.x/4.0) * iCameraRight + (fc.y - iResolution.y/2.0) * iCameraUp) / (iResolution.x/2.) * m;\n        iViewDirection      = normalize(iViewDirection);\n    #else\n        // CAMERA\n        vec3 iCameraFwd     = vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\n        vec3 iCameraUp      = vec3(-sin(theta)*sin(phi),cos(phi),-cos(theta)*sin(phi));\n        vec3 iCameraRight   = normalize(cross(iCameraUp, iCameraFwd));\n\n        vec3 iCameraPosition= -CAMERADIS*iCameraFwd;\n\n        float m = 1.0;\n\n        vec3 iViewDirection = iCameraFwd + ((fragCoord.x - iResolution.x/2.0) * iCameraRight + (fragCoord.y - iResolution.y/2.0) * iCameraUp) / iResolution.x * m;\n        iViewDirection      = normalize(iViewDirection);\n    #endif\n    fragColor = vec4(0);\n    \n    vec3  pos = iCameraPosition + (CAMERADIS-2.)*iViewDirection;\n    vec3  dir = iViewDirection;\n    float dis = 4./float(NSTEPS);\n    vec4  mul = vec4(1);\n    for (int n = 0; n < NSTEPS; n++)\n    {\n        pos += dir*dis;\n        vec4  lightReaching = STARCOL;\n        vec3  pos2 = vec3(0);\n        vec3  dir2 = normalize(pos);\n        float dis2 = length(pos)/float(N2STEPS);\n        for (int m = 0; m < N2STEPS; m++)\n        {\n            float gasdensity2 = GasDensity(pos2);\n            float dustdensity2= DustDensity(pos2);\n            lightReaching *= exp(-dis2*(dustdensity2*(DUSTABSORBCOL + DUSTSCATTERCOL) + gasdensity2*(GASABSORBCOL + GASSCATTERCOL)));\n            pos2 += dir2*dis2;\n        }\n        float gasdensity = GasDensity(pos);\n        float dustdensity= DustDensity(pos);\n        lightReaching /= (RCLUSTER*RCLUSTER+dot(pos, pos));\n        fragColor += mul*     lightReaching   *(gasdensity*GASSCATTERCOL + dustdensity*DUSTSCATTERCOL);\n        fragColor += mul*tanh(lightReaching.a)*(gasdensity*EMITCOL);\n        mul *= exp(-dis*(dustdensity*(DUSTABSORBCOL+DUSTSCATTERCOL)+gasdensity*(GASABSORBCOL + GASSCATTERCOL)));\n        \n        if (length(pos) < 2.*RCLUSTER)\n        {\n            for (float i = 0.; i < NSTARS; i++)\n            {\n                vec3 star = StarPos(i);\n                if (abs(dot(iViewDirection, pos-star))<dis/2.)\n                {\n                    vec3 sep = (cross(iViewDirection, pos-star));\n                    fragColor += mul*StarCol(i)*STARBRIGHTNESS/NEBULABRIGHTNESS*exp(-dot(sep, sep)/(STARRADIUS*STARRADIUS));\n                }\n            }\n        }\n    }\n    fragColor *= NEBULABRIGHTNESS;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// pi\n#define PI          3.1415927\n// number of steps in final image\n#define NSTEPS        80\n// number of steps to stars\n#define N2STEPS       10\n// camera distance from origin\n#define CAMERADIS    4.5\n// bloom width\n#define BLOOMSIZE    30.\n// point-spread function; makes stars into + shape\n#define PSFSIZE      20.\n\n#define RCLUSTER     0.4\n#define RCLOUD       1.\n\n#define STARCOL          vec4(0.4)\n#define GASABSORBCOL     vec4(0.0,0.0,0.0,2.)*3.\n#define DUSTABSORBCOL    vec4(0.4,0.6,0.8,1.0)*30.\n#define GASSCATTERCOL    vec4(0.1,0.2,0.4,0.4)*0.02\n#define DUSTSCATTERCOL   vec4(0.3,0.5,0.8,0.9)*2.\n#define EMITCOL          vec4(0.7,0.3,0.5,  0)*2.\n#define NEBULABRIGHTNESS 0.6\n#define STARBRIGHTNESS   30.\n#define STARRADIUS       0.01\n#define NSTARS           30.\n\n\n// Uncomment the next line for stereographic; two images will be displayed\n// and if you cross your eyes so they line up, it will be 3D :)\n// Also should reduce PSFSIZE and BLOOMSIZE by ~2x\n//#define STEREOGRAPHIC\n#define EYESEP           -0.3",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Bloom step 1\n    fragColor = vec4(0.0);\n    for (float n = -BLOOMSIZE; n < BLOOMSIZE+1.; n++)\n    {\n        vec4 col   = texture(iChannel0, (fragCoord + vec2(1,0)*n)/iResolution.xy);\n        fragColor += pow(col/(length(col)+0.01), vec4(1.5))*col*exp(-(4.*n*n)/(BLOOMSIZE*BLOOMSIZE));\n    }\n    fragColor /= BLOOMSIZE;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}