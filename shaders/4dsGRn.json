{
    "Shader": {
        "info": {
            "date": "1361131642",
            "description": "Your basic sphere/plane ray tracer with some volumetric shadowing thrown into the mix. Code can still be made a little more elegant I think. Nearly melted my Macbook making this.",
            "flags": 0,
            "hasliked": 0,
            "id": "4dsGRn",
            "likes": 48,
            "name": "Ray tracer with volumetric light",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "phong"
            ],
            "usePreview": 0,
            "username": "anji",
            "viewed": 7641
        },
        "renderpass": [
            {
                "code": "// Ray tracing with improvised volumetric shadows\n// Attempting to make it windows friendly by reducing loopiness.\n// Thanks to iq for fixing the sphere intersection code, sqrt(-n) is bad :)\n// Matthijs De Smedt\n// @anji_nl\n\nconst float ZMAX = 99999.0;\nconst float EPSILON = 0.001;\nconst int MAX_BOUNCES = 3; // For looping version\nconst int VOLUMETRIC_SAMPLES = 10;\n\nstruct Intersection\n{\n\tvec3 p;\n\tfloat dist;\n\t\n\tvec3 n;\n\tvec3 diffuse;\n\tvec3 specular;\n};\n\t\nstruct Ray\n{\n\tvec3 o;\n\tvec3 dir;\n};\n\t\nstruct Light\n{\n\tvec3 p;\n\tvec3 color;\n\tfloat radius;\n};\n\t\nstruct Plane\n{\n\tvec3 n;\n\tfloat d;\n};\n\t\nstruct Sphere\n{\n\tvec3 c;\n\tfloat r;\n};\n\t\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\nvec3 saturate(vec3 v)\n{\n\treturn clamp(v,vec3(0,0,0),vec3(1,1,1));\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453 + iTime);\n}\n\nIntersection RaySphere(Ray ray, Sphere sphere)\n{\n\tIntersection i;\n\ti.dist = ZMAX;\n\tvec3 c = sphere.c;\n\tfloat r = sphere.r;\n\tvec3 e = c-ray.o;\n\tfloat a = dot(e, ray.dir);\n\tfloat b = r*r - dot(e,e) + a*a;\n\tif( b>0.0 )\n\t{\n\t\tfloat f = sqrt(b);\n\t\tfloat t = a - f;\n\t\tif(t > EPSILON)\n\t\t{\n\t\t\ti.p = ray.o + ray.dir*t;\n\t\t\ti.n = normalize(i.p-c);\n\t\t\ti.dist = t;\n\t\t}\n\t}\n\treturn i;\n}\n\nIntersection RayPlane(Ray ray, Plane p)\n{\n\tIntersection i;\n\tfloat num = p.d-dot(p.n, ray.o);\n\tfloat denom = dot(p.n, ray.dir);\n\tfloat t = num/denom;\n\tif(t > EPSILON)\n\t{\n\t\ti.p = ray.o + ray.dir * t;\n\t\ti.n = p.n;\n\t\ti.dist = t;\n\t}\n\telse\n\t{\n\t\ti.dist = ZMAX;\n\t}\n\treturn i;\n}\n\nIntersection MinIntersection(Intersection a, Intersection b)\n{\n\tif(a.dist < b.dist)\n\t{\n\t\treturn a;\n\t}\n\telse\n\t{\n\t\treturn b;\n\t}\n}\n\nvec3 PlaneMaterial(Intersection i)\n{\n\tfloat d = 0.0;\n\td = mod(floor(i.p.x)+floor(i.p.z),2.0);\n\treturn vec3(d,d,d)*0.8;\n}\n\nIntersection SceneIntersection(Ray r)\n{\n\tIntersection iOut;\n\t\n\tPlane plane;\n\tplane.n = normalize(vec3(0,1,0));\n\tplane.d = -2.0;\n\tIntersection iPlane = RayPlane(r, plane);\n\tiPlane.diffuse = PlaneMaterial(iPlane);\n\tiPlane.specular = vec3(1,1,1)-iPlane.diffuse;\n\tiOut = iPlane;\n\t\n\tfor(int s = 0; s <= 3; s++)\n\t{\n\t\tfloat fs = float(s);\n\t\tfloat t = iTime*0.3+fs*2.0;\n\t\tvec3 pos;\n\t\tpos.x = sin(t*2.0)*2.0+sin(t*2.0)*3.0;\n\t\tpos.y = abs(sin(t))*2.0;\n\t\tpos.z = 6.0+cos(t)*2.0+cos(t*1.5)*2.0;\n\t\tSphere sphere;\n\t\tsphere.c = pos;\n\t\tsphere.r = 2.0;\n\t\tIntersection iSphere = RaySphere(r, sphere);\n\t\tiSphere.diffuse = vec3(0.0,0.0,0.2);\n\t\tiSphere.specular = vec3(0.2,0.2,0.6);\n\t\tiOut = MinIntersection(iOut, iSphere);\n\t}\n\t\n\treturn iOut;\n}\n\nvec3 CalcIrradiance(Light light, vec3 p)\n{\n\tfloat distA = 1.0-saturate(length(light.p-p)/light.radius);\n\treturn distA * light.color;\n}\n\nvec3 CalcLighting(Light light, Intersection i, vec3 origin)\n{\n\tvec3 n = i.n;\n\tvec3 p = i.p;\n\tvec3 l = normalize(light.p-p);\n\tvec3 v = normalize(origin-p);\n\tvec3 h = normalize(l+v);\n\tfloat NdotL = saturate(dot(n,l));\n\tfloat NdotH = saturate(dot(n,h));\n\tvec3 diffuse = NdotL*i.diffuse;\n\tvec3 spec = pow(NdotH,8.0) * i.specular;\n\tfloat distA = 1.0-saturate(length(light.p-p)/light.radius);\n\tvec3 color;\n\tcolor = (diffuse+spec) * distA * light.color;\n\t\n\tfloat shadow = 1.0;\n\tRay shadowRay;\n\tshadowRay.o = i.p;\n\tfloat lightDist = length(light.p-i.p);\n\tshadowRay.dir = (light.p-i.p)/lightDist;\n\tIntersection shadowI = SceneIntersection(shadowRay);\n\tif(shadowI.dist < lightDist)\n\t{\n\t\tshadow = 0.0;\n\t}\n\tcolor *= shadow;\n\t\n\treturn color;\n}\n\nvec3 GetLighting(Intersection i, vec3 origin)\n{\n\tvec3 color = vec3(0,0,0);\n\tLight light;\n\t\n\tlight.p = vec3(sin(iTime*0.3)*2.0,5,cos(iTime*0.3)*2.0+4.0);\n\tlight.color = vec3(1,1,1);\n\tlight.radius = 20.0;\n\tcolor += CalcLighting(light, i, origin);\n\t\n\t/*\n\tlight.p = vec3(cos(time*0.2)*2.0,5,sin(time*0.2)*2.0+8.0);\n\tlight.color = vec3(1,1,1);\n\tlight.radius = 20.0;\n\tcolor += CalcLighting(light, i, origin);\n*/\n\t\n\treturn color;\n}\n\nvec3 GetVolumetricLighting(Ray ray, float maxDist, vec2 fragCoord)\n{\n\tvec3 color = vec3(0,0,0);\n\tLight light;\n\tlight.p = vec3(sin(iTime*0.3)*2.0,5,cos(iTime*0.3)*2.0+4.0);\n\tlight.color = vec3(1,1,1);\n\tlight.radius = 20.0;\n\t\n\tfloat inscattering = maxDist/200.0;\n\tfloat volRayStep = maxDist/float(VOLUMETRIC_SAMPLES-1);\n\tfloat randomStep = rand(fragCoord.xy)*volRayStep;\n\tRay volRay;\n\tvolRay.o = ray.o + ray.dir*randomStep;\n\tfor(int v = 0; v < VOLUMETRIC_SAMPLES; v++)\n\t{\n\t\tvec3 lightVec = light.p-volRay.o;\n\t\tfloat lightDist = length(lightVec);\n\t\tvolRay.dir = lightVec/lightDist;\n\t\tIntersection i = SceneIntersection(volRay);\n\t\tif(i.dist > lightDist)\n\t\t{\n\t\t\tcolor += CalcIrradiance(light, volRay.o)*inscattering;\n\t\t}\n\t\tvolRay.o += ray.dir * volRayStep;\n\t}\n\t\n\treturn color;\n}\n\nvec3 GetColor(Ray ray, vec2 fragCoord)\n{\n\tvec3 color = vec3(0,0,0);\n\tvec3 volumetric = vec3(0,0,0);\n\tvec3 prevSpecular = vec3(1.0,1.0,1.0);\n\t/*\n\t// Loop version\n\tfor(int r = 0; r <= MAX_BOUNCES; r++)\n\t{\n\t\tIntersection i;\n\t\t// Find intersection\n\t\ti = SceneIntersection(ray);\n\t\tif(r == 0)\n\t\t{\n\t\t\tvolumetric = GetVolumetricLighting(ray, min(i.dist, 20.0));\n\t\t}\n\t\tif(i.dist >= ZMAX-EPSILON)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t// Blend color\n\t\tvec3 diffuse = GetLighting(i, ray.o);\n\t\tcolor += diffuse * prevSpecular;\n\t\tprevSpecular *= i.specular;\n\t\t// Calculate next ray\n\t\tvec3 incident = normalize(i.p-ray.o);\n\t\tray.dir = reflect(incident,i.n);\n\t\tray.o = i.p+ray.dir*EPSILON;\n\t}\n\t*/\n\t// Branch version\n\tIntersection i = SceneIntersection(ray);\n\t// Volumetrics\n\tvolumetric = GetVolumetricLighting(ray, min(i.dist, 20.0), fragCoord);\n\tvec3 specular;\n\tvec3 incident;\n\tif(i.dist < ZMAX-EPSILON)\n\t{\n\t\tcolor += GetLighting(i, ray.o);\n\t\tspecular = i.specular;\n\t\tincident = normalize(i.p-ray.o);\n\t\tray.dir = reflect(incident,i.n);\n\t\tray.o = i.p+ray.dir*EPSILON;\n\t\t// First bounce\n\t\ti = SceneIntersection(ray);\n\t\tif(i.dist < ZMAX-EPSILON)\n\t\t{\n\t\t\tcolor += GetLighting(i, ray.o) * specular;\n\t\t\tspecular *= i.specular;\n\t\t\tincident = normalize(i.p-ray.o);\n\t\t\tray.dir = reflect(incident,i.n);\n\t\t\tray.o = i.p+ray.dir*EPSILON;\n\t\t\t// Second bounce\n\t\t\ti = SceneIntersection(ray);\n\t\t\tif(i.dist < ZMAX-EPSILON)\n\t\t\t{\n\t\t\t\tcolor += GetLighting(i, ray.o) * specular;\n\t\t\t}\n\t\t}\n\t}\n\tcolor -= volumetric*0.5; // Ho ho ho.\n\tcolor += volumetric;\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = -1.0 + 2.0 * ( fragCoord.xy / iResolution.xy );\n\tvec2 posAR;\n\tposAR.x = pos.x * (iResolution.x/iResolution.y);\n\tposAR.y = pos.y;\n\tvec3 rayDir = normalize(vec3(posAR.x, posAR.y, 1.0));\n\tRay ray;\n\tray.o = vec3(sin(iTime*0.2),0,0);\n\tray.dir = rayDir;\n\t\n\tvec3 color = GetColor(ray, fragCoord);\n\tfragColor = vec4(color.x, color.y, color.z, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}