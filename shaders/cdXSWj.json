{
    "Shader": {
        "info": {
            "date": "1674816280",
            "description": "Available on music platforms! https://distrokid.com/hyperfollow/mysterypancake/thinking-glsl-remix\nLearnt how to make delays, tremolo and vibrato. Rewind for better audio sync :)",
            "flags": 8,
            "hasliked": 0,
            "id": "cdXSWj",
            "likes": 25,
            "name": "Louis Cole - Thinking Cover",
            "published": 3,
            "tags": [
                "sound",
                "music",
                "synthesis",
                "synth",
                "saw",
                "song",
                "sawtooth",
                "gpusound",
                "supersaw",
                "chords"
            ],
            "usePreview": 1,
            "username": "MysteryPancake",
            "viewed": 910
        },
        "renderpass": [
            {
                "code": "vec3 drawTrack(vec2 uv, vec2 samp, float offset, vec3 color) {\n    float glow = min(1.0, 0.03 / abs(uv.y - samp.x * 0.1 - offset));\n    float line = min(1.0, 0.003 / abs(uv.y - samp.y * 0.1 - offset));\n    return line + glow * color * 0.4;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    Song song = getSong(iTime + (uv.x - 1.0) * SPB * 0.5);\n    Song songNow = getSong(iTime);\n    float boom = 1.0 - songNow.sidechain;\n    \n    // Draw foreground\n    vec3 col = drawTrack(uv, song.drums, 0.8 + boom * 0.1, vec3(1.0, 0.0, 0.0));\n    col += drawTrack(uv, song.bass, 0.6 + boom * 0.2, vec3(1.0, 1.0, 0.0));\n    col += drawTrack(uv, song.voice, 0.4 - boom * 0.2, vec3(0.0, 1.0, 0.0));\n    col += drawTrack(uv, song.lead, 0.2 - boom * 0.1, vec3(0.0, 0.0, 1.0));\n    \n    // Draw background\n    vec2 center = uv - 0.5;\n    vec2 coolUv = fract(center / dot(center, center));\n    float dist = abs(coolUv.y - song.drums.x * 0.5 - 0.5);\n    col += min(1.0, 0.02 / dist) * 0.2;\n    \n    // Glow effects\n    col *= 1.0 + boom * 2.0;\n    col += smoothstep(0.4, 0.6, length(uv - 0.5)) * boom * 0.5;\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float BPM = 112.0;\nconst float SPB = 60.0 / BPM; // Seconds per beat\n\n// This song uses nonstandard tuning (50 cents above 440 Hertz)\nconst float TUNING = 440.0;\nconst float MIDIOFFSET = 68.5;\n\nconst float TAU = 6.28318530;\n\n// 1D hash, from https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) {\n\tp = fract(p * 0.1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\n\n// MIDI note to frequency formula\nfloat noteFreq(float note) {\n\treturn TUNING * exp2((note - MIDIOFFSET) / 12.0);\n}\n\n// Triangle waveform, see https://www.shadertoy.com/view/clXSR7\nvec2 tri(float freq, float time, vec2 phase) {\n    return abs(fract(phase + freq * time) - 0.5) * 4.0 - 1.0;\n}\n\n// Sawtooth waveform, see https://www.shadertoy.com/view/clXSR7\nvec2 saw(float freq, float time, vec2 phase) {\n\treturn fract(phase + freq * time) * 2.0 - 1.0;\n}\n\n// Basic white noise\nvec2 stereoNoise(float time) {\n    return vec2(hash(time * 2048.0), hash(time * 1024.0)) * 2.0 - 1.0;\n}\n\nvec2 noiseHit(float time, float fade) {\n\treturn stereoNoise(time) * exp(-fade * time);\n}\n\n// From https://www.shadertoy.com/view/tttfRj\nfloat noise(float s) {\n    int si = int(floor(s));\n    float sf = fract(s);\n    sf = smoothstep(0.0, 1.0, sf);\n    return mix(hash(float(si)), hash(float(si + 1)), sf) * 2.0 - 1.0;\n}\n\n// From https://www.shadertoy.com/view/sls3WM\nfloat coloredNoise(float time, float freq, float bandwidth) {\n    return sin(TAU * freq * fract(time)) * noise(time * bandwidth);\n}\n\n// Used for bass and lead synths\nvec2 timedSaw(float freq, float time, float start, float end, float seed) {\n    if (time >= start * SPB && time < end * SPB) {\n        vec2 phase = vec2(hash(seed * 1024.0));\n        // Keep bass mostly mono\n        if (freq > 45.0) {\n            phase += vec2(hash(1024.0 * seed + 2048.0 * start), hash(2048.0 * seed + 1024.0 * start));\n        }\n        return saw(noteFreq(freq), time, phase);\n    }\n    return vec2(0.0);\n}\n\n// Used for voices\nvec2 timedTri(float freq, float time, float start, float end, float seed) {\n    if (time >= start * SPB && time < end * SPB) {\n        vec2 phase = vec2(hash(1024.0 * seed + 2048.0 * start), hash(2048.0 * seed + 1024.0 * start));\n        float hertz = noteFreq(freq);\n        float timeOffset = time - start * SPB;\n        // Increase vibrato over time\n        float vibrato = sin(time * freq * 0.8) * 1.6 * timeOffset;\n        // Layer a triangle and saw wave, makes a string-like sound\n        vec2 layers = tri(hertz, time, phase + vibrato) + saw(hertz * 2.0, time, vibrato - phase) * 0.3;\n        return layers * min(0.58, timeOffset * 32.0);\n    }\n    return vec2(0.0);\n}\n\n// Seems to reduce compilation time\nvec2 sawChord(float time, float start, float a, float b, float c, float d, float e) {\n    float end = start + 0.25;\n    vec2 result = timedSaw(a, time, start, end, 0.0);\n    result += timedSaw(b, time, start, end, 1.0);\n    result += timedSaw(c, time, start, end, 2.0);\n    result += timedSaw(d, time, start, end, 3.0);\n    result += timedSaw(e, time, start, end, 4.0);\n    return result;\n}\n\n// Seems to reduce compilation time\nvec2 lead(float time, float a, float b, float c, float d, float e, float f, float g, float h, float i, float j, float k, float l, float m, float n, float o) {\n    vec2 result = vec2(0.0);\n    // 3 chord repetition, optimized\n    if (time <= SPB * 1.5) {\n        float t = mod(time, SPB * 0.5);\n        result += sawChord(t, 0.0, a, b, c, d, e);\n    }\n    \n    // 2 chord repetition, don't know how to optimize\n    result += sawChord(time, 1.75, f, g, h, i, j);\n    result += sawChord(time, 2.25, f, g, h, i, j);\n    // Same chord\n    result += sawChord(time, 3.0, f, g, h, i, j);\n    \n    // Different chord\n    result += sawChord(time, 3.5, k, l, m, n, o);\n    return result;\n}\n\n// I wrote these notes in FL Studio, then wrote a MIDI to code conversion script\nvec2 bass1(float time) {\n    vec2 result = timedSaw(33.0, time, 0.0, 0.25, 0.0);\n    result += timedSaw(33.0, time, 0.5, 0.75, 1.0);\n    result += timedSaw(33.0, time, 1.0, 1.25, 2.0);\n    result += timedSaw(35.0, time, 1.75, 2.0, 3.0);\n    result += timedSaw(35.0, time, 2.25, 2.5, 4.0);\n    result += timedSaw(35.0, time, 3.0, 3.25, 5.0);\n    result += timedSaw(39.0, time, 3.5, 3.75, 6.0);\n    result += timedSaw(40.0, time, 4.0, 4.25, 7.0);\n    result += timedSaw(47.0, time, 4.5, 4.75, 8.0);\n    result += timedSaw(40.0, time, 5.0, 5.25, 9.0);\n    result += timedSaw(38.0, time, 5.75, 6.0, 10.0);\n    result += timedSaw(40.0, time, 6.25, 6.5, 11.0);\n    result += timedSaw(33.0, time, 7.0, 7.25, 12.0);\n    result += timedSaw(35.0, time, 7.5, 7.75, 13.0);\n    result += timedSaw(33.0, time, 8.0, 8.25, 14.0);\n    result += timedSaw(33.0, time, 8.5, 8.75, 15.0);\n    result += timedSaw(33.0, time, 9.0, 9.25, 16.0);\n    result += timedSaw(35.0, time, 9.75, 10.0, 17.0);\n    result += timedSaw(35.0, time, 10.25, 10.5, 18.0);\n    result += timedSaw(35.0, time, 11.0, 11.25, 19.0);\n    result += timedSaw(36.0, time, 11.5, 11.75, 20.0);\n    result += timedSaw(37.0, time, 12.0, 12.25, 21.0);\n    result += timedSaw(44.0, time, 12.5, 12.75, 22.0);\n    result += timedSaw(37.0, time, 13.0, 13.25, 23.0);\n    result += timedSaw(40.0, time, 13.75, 14.0, 24.0);\n    result += timedSaw(42.0, time, 14.25, 14.5, 25.0);\n    result += timedSaw(35.0, time, 15.0, 15.25, 26.0);\n    result += timedSaw(42.0, time, 15.5, 15.75, 27.0);\n    return result;\n}\n\nvec2 bass2(float time) {\n    vec2 result = timedSaw(33.0, time, 0.0, 0.25, 0.0);\n    result += timedSaw(33.0, time, 0.5, 0.75, 1.0);\n    result += timedSaw(33.0, time, 1.0, 1.25, 2.0);\n    result += timedSaw(35.0, time, 1.75, 2.0, 3.0);\n    result += timedSaw(35.0, time, 2.25, 2.5, 4.0);\n    result += timedSaw(42.0, time, 2.75, 3.0, 5.0);\n    result += timedSaw(35.0, time, 3.0, 3.25, 6.0);\n    result += timedSaw(39.0, time, 3.5, 3.75, 7.0);\n    result += timedSaw(40.0, time, 4.0, 4.25, 8.0);\n    result += timedSaw(47.0, time, 4.5, 4.75, 9.0);\n    result += timedSaw(52.0, time, 5.0, 5.25, 10.0);\n    result += timedSaw(38.0, time, 5.75, 6.0, 11.0);\n    result += timedSaw(45.0, time, 6.25, 6.5, 12.0);\n    result += timedSaw(38.0, time, 6.75, 7.0, 13.0);\n    result += timedSaw(42.0, time, 7.25, 7.5, 14.0);\n    result += timedSaw(35.0, time, 7.5, 7.75, 15.0);\n    result += timedSaw(33.0, time, 8.0, 8.25, 16.0);\n    result += timedSaw(40.0, time, 8.5, 8.75, 17.0);\n    result += timedSaw(45.0, time, 9.0, 9.25, 18.0);\n    result += timedSaw(40.0, time, 9.75, 10.0, 19.0);\n    result += timedSaw(35.0, time, 10.25, 10.5, 20.0);\n    result += timedSaw(35.0, time, 11.0, 11.25, 21.0);\n    result += timedSaw(37.0, time, 11.5, 11.75, 22.0);\n    result += timedSaw(37.0, time, 12.0, 12.25, 23.0);\n    result += timedSaw(44.0, time, 12.5, 12.75, 24.0);\n    result += timedSaw(49.0, time, 13.0, 13.25, 25.0);\n    result += timedSaw(40.0, time, 13.75, 14.0, 26.0);\n    result += timedSaw(42.0, time, 14.25, 14.5, 27.0);\n    result += timedSaw(37.0, time, 14.75, 15.0, 28.0);\n    result += timedSaw(35.0, time, 15.0, 15.25, 29.0);\n    result += timedSaw(37.0, time, 15.5, 15.75, 30.0);\n    return result;\n}\n\nvec2 voice1(float time) {\n    return timedTri(76.0, time, 1.75, 2.0, 0.0) + timedTri(76.0, time, 2.25, 3.25, 1.0);\n}\n\nvec2 voice2(float time) {\n    vec2 result = timedTri(79.0, time, 0.0, 0.3, 0.0);\n    result += timedTri(79.0, time, 0.5, 0.6, 1.0);\n    result += timedTri(79.0, time, 1.0, 1.3, 2.0);\n    result += timedTri(76.0, time, 1.5, 1.75, 3.0);\n    result += timedTri(79.0, time, 1.75, 2.0, 4.0);\n    result += timedTri(78.0, time, 2.25, 3.0, 5.0);\n    result += timedTri(76.0, time, 3.0, 4.0, 6.0);\n    result += timedTri(79.0, time, 4.0, 4.2, 7.0);\n    result += timedTri(79.0, time, 4.5, 4.7, 8.0);\n    result += timedTri(79.0, time, 5.0, 5.3, 9.0);\n    result += timedTri(76.0, time, 5.5, 5.75, 10.0);\n    result += timedTri(78.0, time, 5.75, 6.0, 11.0);\n    result += timedTri(78.0, time, 6.25, 8.0, 12.0);\n    result += timedTri(79.0, time, 8.0, 8.3, 13.0);\n    result += timedTri(79.0, time, 8.5, 8.7, 14.0);\n    result += timedTri(79.0, time, 9.0, 9.3, 15.0);\n    result += timedTri(76.0, time, 9.5, 9.75, 16.0);\n    result += timedTri(79.0, time, 9.75, 10.0, 17.0);\n    result += timedTri(78.0, time, 10.25, 11.0, 18.0);\n    result += timedTri(76.0, time, 11.0, 11.5, 19.0);\n    result += timedTri(76.0, time, 11.75, 12.0, 20.0);\n    result += timedTri(83.0, time, 12.25, 12.5, 21.0);\n    result += timedTri(83.0, time, 12.75, 13.25, 22.0);\n    result += timedTri(81.0, time, 13.25, 13.75, 23.0);\n    result += timedTri(80.0, time, 13.75, 14.25, 24.0);\n    result += timedTri(78.0, time, 14.25, 14.75, 25.0);\n    result += timedTri(80.0, time, 14.75, 15.25, 26.0);\n    result += timedTri(76.0, time, 15.25, 16.0, 27.0);\n    return result;\n}\n\nvec2 voice3(float time) {\n    vec2 result = timedTri(76.0, time, 0.75, 0.95, 0.0);\n    result += timedTri(76.0, time, 1.0, 1.125, 1.0);\n    result += timedTri(76.0, time, 1.25, 1.45, 2.0);\n    result += timedTri(76.0, time, 1.5, 1.625, 3.0);\n    result += timedTri(76.0, time, 1.75, 1.95, 4.0);\n    result += timedTri(91.0, time, 2.0, 2.75, 5.0);\n    result += timedTri(88.0, time, 2.75, 3.5, 6.0);\n    result += timedTri(86.0, time, 3.725, 4.0, 7.0);\n    result += timedTri(88.0, time, 4.0, 5.5, 8.0);\n    result += timedTri(76.0, time, 5.5, 5.6, 9.0);\n    result += timedTri(76.0, time, 5.725, 6.0, 10.0);\n    result += timedTri(76.0, time, 6.0, 6.2, 11.0);\n    return result;\n}\n\n// From https://www.shadertoy.com/view/sls3WM\n// Sliding pitch sine wave, used for bass drop and kick\nfloat drop(float time, float df, float dftime, float freq) {\n    return sin(TAU * (freq * time - df * dftime * exp(-time / dftime)));\n}\n\n// From https://www.shadertoy.com/view/sls3WM\nfloat kick(float time) {\n    float body = drop(time, 512.0, 0.01, 60.0) * smoothstep(0.3, 0.0, time) * 2.0;\n    float click = coloredNoise(time, 8000.0, 2000.0) * smoothstep(0.007, 0.0, time);\n    return body + click * 2.0;\n}\n\n// From https://www.shadertoy.com/view/NddSzl\nvec2 snare(float time) {\n    vec2 snoise = stereoNoise(time) + coloredNoise(time, 600.0, 1000.0);\n    float nenv = (exp(-5.0 * time) + exp(-30.0 * time)) * smoothstep(0.2, 0.0, time) * 0.3;\n    const float speed = 20.0;\n    float phase = TAU * 180.0 * time + TAU * 80.0 / speed * (1.0 - exp(-time * speed));\n    float body = sin(phase) * smoothstep(0.0, 0.005, time) * smoothstep(0.05, 0.0, time);\n    return snoise * nenv + body * 3.8;\n}\n\n// Exponential sidechain curve\nfloat sidechain(float time, float speed) {\n    return 1.0 - exp(time * -speed);\n}\n\n// For visualisation\nstruct Song {\n    vec2 drums;\n    vec2 bass;\n    vec2 lead;\n    vec2 voice;\n    float sidechain;\n};\n\nSong getSong(float time) {\n\n    Song song;\n    song.drums = song.bass = song.voice = song.lead = vec2(0.0);\n    \n    // Initial echos on lead synth\n    int leadEchos = 4;\n    // Sidechain factor (0-1)\n    song.sidechain = 1.0;\n    // Temporary variable for sidechain\n    float t = 0.0;\n    \n    if (time >= SPB * 15.2) {\n        // Snare 1\n        t = mod(time - SPB * 3.2, SPB * 4.0);\n        song.drums += snare(t);\n        song.sidechain *= sidechain(t, 6.0);\n        // Bass drop\n        if (time < SPB * 16.0) {\n            song.bass += clamp(drop(t, 70.0, 0.2, 40.0) * 5.0, -0.7, 0.7) * song.sidechain;\n        }\n    }\n    \n    // Drum fill, surrounds snare 1\n    t = mod(time, SPB * 16.0) - SPB * 14.7;\n    if (t > 0.0) {\n        song.drums += kick(t) * 0.45;\n        song.sidechain *= sidechain(t, 8.0);\n        t -= SPB * 0.34;\n        if (t > 0.0) {\n            song.drums += kick(t) * 0.5;\n            song.sidechain *= sidechain(t, 8.0);\n        }\n        t -= SPB * 0.5;\n        if (t > 0.0) {\n            song.drums += kick(t) * 0.55;\n            song.sidechain *= sidechain(t, 8.0);\n        }\n    }\n    \n    if (time >= SPB * 16.0) {\n        // Add more delay after the intro\n        leadEchos = 7;\n        \n        // Kick\n        t = mod(time, SPB * 4.0);\n        song.drums += kick(t) * 0.7;\n        song.sidechain *= sidechain(t, 5.0);\n\n        // Snare 2\n        t = mod(time - SPB * 1.2, SPB * 4.0);\n        song.drums += snare(t);\n        song.sidechain *= sidechain(t, 6.0);\n\n        // Bass\n        for (int i = 0; i <= 2; i++) {\n            // Linear delay, repeats every 0.05 seconds\n            float delay = float(i) * 0.05;\n            // Fade echo volume linearly (1 to 0)\n            float fade = 1.0 - float(i) / 3.0;\n            // Ping-pong panning, pans each echo left then right\n            vec2 pan = i <= 0 ? vec2(1.0) : (i % 2 == 0 ? vec2(1.0, 0.5) : vec2(0.5, 1.0));\n            song.bass += bass1(mod(time - SPB * 16.0, SPB * 32.0) - delay) * song.sidechain * 0.65 * fade * pan;\n            song.bass += bass2(mod(time, SPB * 32.0) - delay) * song.sidechain * 0.65 * fade * pan;\n        }\n    }\n    \n    // Wiggle volume a bit to add variety\n    float tremolo = 1.0 - sin(time / SPB * TAU) * 0.1;\n    \n    // Lead voices\n    for (int i = 0; i <= 2; i++) {\n        // Linear delay\n        float delay = float(i) * 0.13;\n        // Fade echo volume linearly (1 to 0)\n        float fade = 1.0 - float(i) / 3.0;\n        // Ping-pong panning, pans each echo right then left\n        vec2 pan = i <= 0 ? vec2(1.0) : (i % 2 == 1 ? vec2(1.0, 0.0) : vec2(0.0, 1.0));\n        // RIP compilation time\n        if (time >= SPB * 16.0) {\n            if (mod(time - SPB * 16.0, SPB * 48.0) >= SPB * 32.0) {\n                song.voice += voice3(mod(time, SPB * 8.0) - delay) * fade * pan * song.sidechain * tremolo;\n            } else {\n                song.voice += voice2(mod(time, SPB * 16.0) - delay) * fade * pan * song.sidechain * tremolo;\n            }\n        } else if (time >= SPB * 8.0) {\n            song.voice += voice1(mod(time, SPB * 4.0) - delay) * fade * pan * song.sidechain * tremolo;\n        }\n    }\n    \n    // Cut lead delay every few bars for variety\n    if (time >= SPB * 64.0 && mod(time, SPB * 64.0) < SPB * 32.0) leadEchos = 0;\n    \n    // Lead synths\n    for (int i = 0; i <= leadEchos; i++) {\n        // Exponential delay, seems to reduce phase weirdness\n        float delay = (exp(float(i) * 0.1) - 1.0) * 0.5;\n        // Fade echo volume linearly (1 to 0)\n        float fade = 1.0 - float(i) / float(leadEchos + 1);\n        // Ping-pong panning, pans each echo left then right\n        vec2 pan = i <= 0 ? vec2(1.0) : (i % 2 == 0 ? vec2(1.0, 0.4) : vec2(0.4, 1.0));\n        \n        // First bar\n        song.lead += lead(mod(time, SPB * 8.0) - delay,\n            45.0, 52.0, 60.0, 64.0, 67.0,\n            47.0, 54.0, 57.0, 62.0, 66.0,\n            47.0, 55.0, 57.0, 62.0, 66.0\n        ) * song.sidechain * 0.2 * fade * pan * tremolo;\n        \n        // Repeats after first bar (1st time)\n        song.lead += lead(mod(time - SPB * 4.0, SPB * 16.0) - delay,\n            52.0, 59.0, 59.0, 64.0, 67.0,\n            52.0, 57.0, 57.0, 62.0, 66.0,\n            52.0, 57.0, 57.0, 62.0, 66.0\n        ) * song.sidechain * 0.2 * fade * pan * tremolo;\n        \n        // Repeats after first bar (2nd time)\n        song.lead += lead(mod(time - SPB * 12.0, SPB * 16.0) - delay,\n            49.0, 56.0, 59.0, 64.0, 68.0,\n            49.0, 56.0, 56.0, 59.0, 64.0,\n            49.0, 56.0, 57.0, 59.0, 64.0\n        ) * song.sidechain * 0.2 * fade * pan * tremolo;\n    }\n    \n    // Hats, first panned right, second panned left\n    song.drums += noiseHit(mod(time, SPB * 0.5), 36.0) * 0.45 * vec2(0.6, 1.0);\n    song.drums += noiseHit(mod(time - SPB / 6.0, SPB * 0.5), 36.0) * 0.49 * vec2(1.0, 0.6);\n    \n    // More hats, adds more high end\n    if (time > SPB * 32.75) {\n        float offset = time + SPB * 0.25;\n        t = mod(offset, SPB);\n        vec2 hat = vec2(coloredNoise(t, 13000.0, 6000.0), coloredNoise(t, 13000.0, 6200.0));\n        // Ping-pong panning, pans left then right\n        vec2 pan = mod(offset, SPB * 2.0) >= SPB ? vec2(1.0, 0.3) : vec2(0.3, 1.0);\n        song.drums += hat * exp(-5.0 * t) * pan * song.sidechain * 0.5;\n    }\n    \n    const float freq = 16000.0;\n    const float bandwidth = 10000.0;\n    \n    // Riser\n    if (time < SPB * 16.0) {\n        song.drums += coloredNoise(time, freq, bandwidth) * exp(0.8 * (time - SPB * 16.0)) * song.sidechain * 0.35;\n    }\n    // Faller\n    if (time > SPB * 16.0) {\n        song.drums += coloredNoise(time, freq, bandwidth) * exp(SPB * 16.0 - time) * song.sidechain * 0.3;\n    }\n    \n    return song;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec2 mainSound(int samp, float time) {\n    Song song = getSong(time);\n    return 0.75 * (song.drums + song.bass + song.lead + song.voice);\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}