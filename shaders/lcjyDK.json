{
    "Shader": {
        "info": {
            "date": "1723025588",
            "description": "originals https://www.shadertoy.com/view/4tyfWy https://www.shadertoy.com/view/4fSyDK https://www.shadertoy.com/view/Xf2yRt",
            "flags": 1,
            "hasliked": 0,
            "id": "lcjyDK",
            "likes": 0,
            "name": "galaxy new",
            "published": 3,
            "tags": [
                "fractal",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 178
        },
        "renderpass": [
            {
                "code": "\n\n#define iterations 13\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n\n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n#define time iTime\n\n#define PI 3.14\n\n// Random position where each coordinate is between 0 and 1.\nfloat randPos(float seed)\n{\n    return fract(sin((seed+119.) * 40.37102 + cos(seed*1.34111) * 519.2013 - fract(seed-14.32*185.7548)));\n\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; \n            p.xy*=mat2(cos(iTime*0.01),sin(iTime*0.010),-sin(iTime*0.010),cos(iTime*0.01) );// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.2-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.01,1.);\t\n}\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n uniform vec2      resolution;\n    \n  \n        uniform float     cd;\n        uniform float     cb;\n        uniform float     sr;\n        uniform float     sg;\n        uniform float     sb;\n        uniform float     shift;\n        uniform sampler2D \tuSampler;\n       \n  \n        float rand(vec2 n) {\n         return fract(cos(dot(n, vec2(2.9898, 20.1414))) * 5.5453);\n        }\n  \n        float noise(vec2 n) {\n          const vec2 d = vec2(0.0, 1.0);\n          vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.000002), fract(n));\n          return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n        }\n  \n        float fbm(vec2 n){\n           float total=0.,amplitude=2.5;\n           for(int i=0;i<18;i++){\n               total+=noise(n)*amplitude;\n                n+=n;\n                amplitude*=.45;\n           }\n\t\t  return total;\n        }\n  #define time iTime\n  #define resolution iResolution.xy\n\n\nconst float count = 12.0;\nconst float speed = .2;\n\n\nfloat Hash( vec2 p, in float s)\n{\n    vec3 p2 = vec3(p.xy,1.0 * abs(sin(s)));\n    return fract(sin(dot(p2,vec3(1.1,1.7, 1.4)))*273758.5453123);\n}\n\n\nfloat noise(in vec2 p, in float s)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f *= f * (24.0-2.0*f);\n    \n    \n    return mix(mix(Hash(i + vec2(0.,0.), s), Hash(i + vec2(1.,0.), s),f.x),\n               mix(Hash(i + vec2(0.,1.), s), Hash(i + vec2(1.,1.), s),f.x),\n               f.y) * s;\n}\n\n\nfloat fbm2(vec2 p)\n{\n    float v = - noise(p * 02., 0.25);\n    v += noise(p * 01.1, 0.5) - noise(p * 01.1, 0.25);\n    v += noise(p * 02.1, 0.25) - noise(p * 02.1, 0.125);\n    v += noise(p * 04.1, 0.125) - noise(p * 08.1, 0.0625);\n    v += noise(p * 08.1, 0.0625) - noise(p * 16., 0.03125);\n    v += noise(p * 16.1, 0.03125);\n    return v;\n}\n\nconst float count3 = 12.0;\nconst float speed3 = .2;\n #define POINTS 18.0\n#define RINGS 18.0\n#define TAU 3.141592*2.1\n\nfloat relu(float x){ return (abs(x)+x)/2.0;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\t  vec2 uv2 = fragCoord/iResolution.y;\n\n\tvec2      speed;\n    // Initialize color and texture accumulators\n    vec4 color = vec4(1.0, 2.0, 3.0, 0.0);\n    vec4 baseColor = color;\n    \n    // Initialize time and amplitude variables\nfloat worktime = (time * speed3) + 100000.0;\n    \n    vec2 uv3 = ( gl_FragCoord.xy / resolution.xy ) * 2.0 - 1.0;\n    uv.y *= resolution.y/resolution.x;\n    \n    float aspect =resolution.y/resolution.x;\n\tfloat orange = 0.0;\n\n    vec3 finalColor = vec3( 0.0, 0.0, 0.0 );\n  \n    for( float i = 1.0; i < count; i++ )\n    {\n        float t = abs(1.0 / ((uv.y + fbm2( uv + worktime / i )) * (i * 100.0)));\n        finalColor +=  t * vec3( i * 0.1, 0.20, 1.90 );\n    }\nconst vec3 c1=vec3(0.502, 0.1059, 0.1059);\n    const vec3 c2=vec3(167./255.,93./255.,110./255.);\n    const vec3 c3=vec3(0.4902, 0.5333, 0.4902);\n    const vec3 c4=vec3(0.2118, 0.3451, 0.2706);\n    const vec3 c5=vec3(0.3176, 0.2549, 0.4);\n    const vec3 c6=vec3(0.8, 0.3569, 0.3569);\n    \n    vec2 p=gl_FragCoord.xy*10./resolution.xx;\n    float t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n   \n    float q=fbm(p-time*.07);\n    vec2 r=vec2(fbm(p+q+time*speed.x-p.x-p.y),fbm(p+q-time*speed.y));\n    vec3 c=mix(c1,c2,fbm(p+r))+mix(c3,c4,r.x)-mix(c5,c6,r.y);\n    float grad=gl_FragCoord.y/resolution.y;\n   \n    float amplitude = 0.5;\n\nfloat strengthSum = 0.0f;\n    for(int i = 0; i < 512; i++)\n    {\n        float speed3 = randPos(float(i)) * 2.f + 1.6f;\n        vec2 dir = normalize(vec2(randPos(float(i)*.3452)-.5, randPos(float(i * 10)*.3452)-.5)) * randPos(float(i)*.45563);\n     \n        vec2 circleOrigin = vec2(.5*iResolution.x/iResolution.y, .5) + pow(abs(sin(iTime*.1)),.5) * dir * speed3;\n        float strength = 1./(pow(uv2.x-circleOrigin.x,2.0) + pow(uv2.y-circleOrigin.y,2.0));\n        strength *= .0002 * abs(sin(iTime + float(i))) * randPos(float(i)*.3451) + .00002;\n        strengthSum += strength;\n    }\n    \n    vec3 col = vec3(strengthSum);\n    \n    float midpoint = pow(.5,2.2);\n    float contrast = 1.0f;\n    vec3 contrastCol = (col - midpoint) * contrast + midpoint;\n    \n    col = max(log(col/6.0), 0.);\n    col = min(col, vec3(.99));\n    \n    vec3 noiseCol = texture(iChannel0, uv).rgb * 6.0;\n\n\n \n    // Final color adjustment for visual output\n    \n\tvec3 from=vec3(1.,.5,0.5);\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\n      fragColor+= vec4((col)*noiseCol*vec3(0.5,0.5,5.1)+ finalColor*vec3(0.5,0.5,5.1),1.0);\n       fragColor*=vec4(c*cos(shift*gl_FragCoord.y/resolution.y)*vec3(2.5,0.5,0.1),333.5);\n   \n\n  \n      uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    fragColor*= vec4(happy_star(uv, anim) * vec3(0.35,01.0,0.1)*1., 1.0);\n\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}