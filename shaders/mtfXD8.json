{
    "Shader": {
        "info": {
            "date": "1674660338",
            "description": "Hi",
            "flags": 0,
            "hasliked": 0,
            "id": "mtfXD8",
            "likes": 18,
            "name": "French Pharmacy",
            "published": 3,
            "tags": [
                "sdf",
                "cross",
                "french",
                "pharmacy"
            ],
            "usePreview": 0,
            "username": "rcargou",
            "viewed": 549
        },
        "renderpass": [
            {
                "code": "\nvec3 k_cross = vec3(0., .9, 0.0)*3.;\nvec3 k_screen = vec3(0.01, 0.015, 0.01);\nvec3 k_light1 = vec3(.7, 0.2, 0.3);\nvec3 k_light2 = vec3(0.3, 0.2, .7);\n//------------------------------------------------------------------\n\n//------------------------------------------------------------------\n\nvec2 getPhase() {\n   // return vec2( 3., 0. );\n    return vec2( floor( mod(iTime / 20., 4.) ),  floor( mod(iTime / 5., 2.)) );\n}\n\nfloat sdCross(vec3 p, vec2 s) {\n        vec3 dim = vec3(1.5,\n                     .6,\n                     .33123405437896355);\n                \n    vec3 dim2 = dim * vec3(1.1 + s.x , 1. + s.y + .3, dim.z);\n    \n    float s1 = sdBox(p, dim.xyz );\n    float s2 = sdBox(p, dim.yxz );\n    \n    float core_cross = opU(vec2(s1), vec2(s2)).x;\n    \n    s1 = sdBox(p, vec3( dim2.xy, dim.z * 1.1) );\n    s2 = sdBox(p, vec3( dim2.yx, dim.z * 1.1) );\n    \n    float core_anticross = opU(vec2(s1), vec2(s2)).x;\n    \n    float ret = opS(core_cross, core_anticross);\n    return ret;\n}\n\nfloat mapSphericalPill(vec3 p, out vec3 id) {\n\n\n    p.y +=1.2;\n    p.xy -= vec2(-0.2, 1.) * pow(abs( sin(iTime * 6.)), 9.) / 4.;\n    p.z -= 4.;\n    p *= rotateZ(sin( iTime  * 15.) / 2. );\n//    p *= rotateX(sin( iTime  * 15.) / 20. );\n    \n    vec3 s = vec3(1., 5., .5) * 1.2;\n    float size = .5;\n    id.x = 5.;\n    id.y = smoothstep( .7, .06, abs(p.x));\n\n    return length(p * s) - size;\n}\n\nfloat mapPill(vec3 p, out vec3 id, float in_id) {\n    p.z-=3.;\n    id.x = 1.;\n    p *= rotateZ(iTime * 10. + in_id * 21.4);\n   // p *= rotateY(iTime * 12.+ in_id * 2111.4);\n    \n    float s = sdCapsule( p, vec3(-.1, .0, 0.),vec3(.1, 0., 0.) , .09);\n    id.y = step(p.x, 0.) * in_id;\n    \n    return s;\n}\n\nfloat mapPillField(vec3 p, out vec3 id) {\n    vec3 o = vec3(.0, .0, 10.);\n    float speed = 20.;\n    vec3 tmp_id;\n  \n    if(length(p.xy) > 5.5)\n        return 1e10;\n  \n    float rep = 2.;\n    \n    vec2 u = floor(p.xy / rep);\n    float i =  hash11( u.x * fract( sin(u.x+u.y)));\n    \n    p.xy = mod(p.xy, rep) - vec2(rep / 2.);\n    float offset = i * 14.;\n    p.z -= 15. - iTime * 30.;\n    p.z = mod(p.z, 25.) - 12.5;\n    p.z+=offset;\n    float d = mapPill(p / 2., id, i );\n    return d;\n}\n\nvec3 path(float time, float z) {\n    if (getPhase().x != 0.) \n        return vec3(0.);\n    vec3 p = vec3(0.);\n    float t = length(z - 1.);\n\n    p.y += sin(t / 20.) * 2. * pow( sin(iTime * .8), 2.);\n    p.x += sin(t /20.) * 2. * pow( sin(1.+iTime * .8), 2.);\n\n    \n    //p.y -= sin(t / 10.) * 2. * pow( cos(iTime), 7.);\n   // p.x -= sin(t / 10.) * 2. * pow( cos(iTime), 3.);\n    //p*=2.;\n    return vec3(p);\n}\n\nfloat sdLights(vec3 p, out vec3 id, out float dlight2) {\n    p += path(iTime, p.z);\n    p.z-=15.;\n    float s = .3;\n    float rotSpeed = 5.;\n    float rotAmp = 5.;\n    vec3 p1 = p, p2 = p;\n    \n    p1.x += sin(iTime * rotSpeed) * rotAmp;\n    p1.z += cos(iTime * rotSpeed) * rotAmp;\n    \n    p2.z += sin(iTime * rotSpeed + .57) * rotAmp * 1.;\n    p2.x += 1.1*cos(iTime * rotSpeed + .57) * rotAmp;\n    \n    float d1 = length(p1) - s;\n    d1 = sdCross(p1 * 1.2, vec2(-.1, -0.5));\n    float d2 = length(p2) - s;\n    d2 = sdCross(p2 * 1.2, vec2(-.1, -0.5));\n\n    id.x = 4.;\n    id.y = step(d1, d2);\n    dlight2 = max(d1,d2);\n    return min(d1, d2);\n}\n\nfloat sdCross2D(vec2 uv, float s) {\n    \n    if (getPhase().x != 2.)\n        s = 1.;\n\n    vec4 dim = vec4(0.85, 0.3, 0.2, 0.1) * s;\n    vec4 dim_inside = vec4(0.85, 0.3, 0.2, 0.1) * s;\n    float smoothness = .01;\n    \n    float d1 = smoothstep(dim.x, dim.x - smoothness, abs( uv.x ) );\n    d1 *= smoothstep(dim.y, dim.y - smoothness, abs( uv.y ) );\n \n    float d2 = smoothstep(dim.y, dim.y - smoothness, abs( uv.x ) );\n    d2 *= smoothstep(dim.x, dim.x - smoothness, abs( uv.y ) );\n \n    return 1.-step(d1+d2, 0.);\n}\n\nmat2 rotate2d(float a) {\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat maze2D(vec2 uv, float t) {\n    uv.y += .5;\n    vec2 off = vec2(-0.2, 1.) * pow(abs( sin(iTime * 6.)), 9.) / 4.;\n    uv -= off / 4.;\n    uv *= rotate2d(sin(iTime * 6.) / 5.);\n    \n    uv.xy += texture(iChannel1, uv.xy * 100. + vec2(iTime)).xx / 6.;\n    float d1 = smoothstep(.7, 0.0, abs( uv.x / (uv.y) ));\n    d1 *= smoothstep(1.5, .3, uv.y);\n    d1 *= step(-.0, uv.y);\n    d1 *= min(1.,pow( texture(iChannel1, uv.xy / 2.1 + vec2(0., -iTime)).x, 1.5 ));\n    \n    return d1;\n}\n\nfloat rotatingCross2Dfield(vec2 uv, float t) {\n\n    vec2 p1 = uv + vec2 ( .54, .0 );\n    vec2 p2 = uv + vec2 ( -.54, .0 );\n    vec2 p3 = uv + vec2 ( 0, .54 );\n    vec2 p4 = uv + vec2 ( 0, -.54 );\n\n    vec2 dir1 = vec2(1., 0.);\n    vec2 dir2 = vec2(-1., 0.);\n    vec2 dir3 = vec2(0., 1.);\n    vec2 dir4 = vec2(0., -1.);\n    \n    mat2 r = rotate2d(- 8.* iTime);\n    float d1 = sdCross2D(p1 * r +dir1 * (t) * r , .25 * (1.- t*3.));\n    float d2 = sdCross2D(p2 * r+ dir2 * (t) * r, .25 * (1.- t*3.) );\n    float d3 = sdCross2D(p3 * r+ dir3 * (t) * r, .25 * (1.- t*3.));\n    float d4 = sdCross2D(p4 * r+ dir4 * (t) * r, .25 * (1.- t*3.) );\n    \n    return d1 + d2 + d3 + d4;\n}\n\n\nfloat mapCrossField(vec3 p) {\n  \n    p+=path(iTime, p.z);\n    float speed = 30.;\n\n    float l = mod( iTime * speed, 200.);\n    if (getPhase().x == 1.) {\n        l = mod(l,13.5);\n    }\n\n    if (getPhase().x >= 2.)\n    {\n        l = 11.5;\n    }\n\n    p.z+= l;\n\n    vec3 prep = p;\n    float rep_size = 5.5;\n\n    if (getPhase().x == 0.)\n       p.z = mod(p.z, rep_size) - rep_size / 2.; \n    else\n       p.z -= 15.;\n\n    return sdCross(p, vec2( -.1, -0.5 ));\n}\n\nfloat crossfield2d(vec2 uv) {\n\n    if (abs(uv.x) < .9)\n        return 0.;\n    \n    uv *= 3.;\n    uv.x += .48;\n    float rep = 1.;\n    uv.y -= iTime * 6.;\n    vec2 ids = floor(uv * rep);\n    \n    float id = hash11(ids.x);\n    uv = mod(uv, rep) - rep / 2.;\n    \n    return sdCross2D(uv * 2.5, 1.);\n}\n\nfloat glowingCross2d(vec2 uv ) {\n    return 0.;\n}\n\nvec2 map( in vec3 pos, out vec3 id )\n{\n    vec3 tmp_id;\n    vec2 res = vec2( 1e10, -42.0 );\n     float d;\n     \n    id.z = 0.;\n    if ((d = mapCrossField(pos)) < res.x) {\n        res.x = d;\n        id.x = 0.;\n        id.z = 1.;\n    }\n    if ((d = mapPillField(pos, tmp_id)) < res.x && ( getPhase().x == 1.\n    || getPhase() == vec2(3., 1.) ) ) {\n           id = tmp_id;\n           res.x = d;\n           id.z = 1.;\n    }\n    if ( ( d = sdCross(pos - vec3 ( 0., 0., 3.5), vec2(0.0, 0.0) ) ) <= res.x ) {\n     //   res.x = d;\n      //  id.x = 3.;\n       // id.z = 0.;\n    }\n    float k;\n    if ( (d = sdLights(pos, tmp_id, k)) < res.x) {\n        if (getPhase() == vec2(0., 1.)) {\n            res.x = d;\n            id = tmp_id;\n        }\n    }\n    if ( (d = mapSphericalPill(pos, tmp_id) ) < res.x ) {\n        if ( getPhase().x == 3. ) {\n           id = tmp_id;\n           res.x = d;\n        }\n    }\n\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, out vec3 id )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 0.0;\n    float tmax = 100.0;\n    int steps = 50;\n    if (getPhase().x == 0.) \n        steps = 120;\n    // raymarch primitives   \n    {\n    \n        float t = tmin;\n        for( int i=0; i<steps && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t, id );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x * 1.;\n        }\n    }\n    \n    return res;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nvec4 render( in vec3 ro, in vec3 rd , vec2 uv)\n{ \n    vec3 col = vec3(.0f);\n    vec3 id;\n    vec2 res = castRay(ro,rd, id);\n    float t = res.x;\n\tfloat m = res.y;\n    vec3 albedo = vec3(0., 0., 0.);\n    vec3 tmp_id;\n    float dLight2;\n    float dLight1 = sdLights(ro+rd*t, tmp_id, dLight2);\n    if (res.x > .0f) {\n        if (id.x == 0.) {\n            albedo = k_cross;\n        }\n        if (id.x == 1.) {\n            albedo = vec3(1.);\n            if (id.y > 0.) {\n                albedo = 15.*pow( hash13(id.y) /20., vec3(.85));//vec3(1., 0., 0.);\n            }\n        }\n        if (id.x == 3.) {\n           albedo = k_screen;\n        }\n        if (id.x == 4.) {\n            if (id.y == 0.) {\n                albedo = k_light1/.1;\n            } else { \n                albedo = k_light2/.1;           \n            }\n        }\n        if (id.x == 5.) {\n            albedo = vec3(.8) / 1.;\n            if (id.y == 1.) {\n                albedo = vec3(1) / 2.;\n            }\n        }\n    }\n    \n    float falloff = 7.0;\n    float bias = 15.5;\n    float intensity = 5.1;\n    vec3 lCol = ( intensity / pow( 1.+ dLight1 / bias, falloff)) * k_light1 +\n    ( 1. / pow( 1. + dLight2 / bias, falloff)) * k_light2;\n    if (getPhase().x == 3.) {\n        lCol = vec3( 0. );\n    }\n    vec3 a = albedo * min(1., -.3+res.x)+ lCol * step(.2, albedo.g);\n\n    if (getPhase().x == 2.) {\n        a.xyz+=vec3(sdCross2D(uv.xy, abs( pow ( sin(iTime * 4.), 5.) )) ) * k_cross;\n        a.xyz+=vec3(rotatingCross2Dfield(uv.xy, abs( pow ( sin(iTime * 4.), 5.) )) ) * k_cross;\n        \n    } else if ( getPhase().x == 3. ) {\n       a.xyz += vec3(maze2D(uv, 0.));\n       a.xyz += crossfield2d(uv) * k_cross;\n    }\n   \tvec4 ret = vec4(a.x, a.y,a.z, id.z);\n    return ret;\n}\n\nvec3 retro_filter(vec2 uv, vec3 col) {\n    float rep_size = .015;\n    vec2 uv_rep = mod(uv, vec2(rep_size)) - rep_size / 2.;\n    \n    float l = length(uv_rep);\n    float circle = smoothstep(0.5 * .015, 0.2* .015, l);\n    return circle * col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = vec2(0);//iMouse.xy/iResolution.xy;\n\tfloat time = .0f; //iTime;\n\n    // camera\t\n    vec3 ro = vec3(.0f, .0f, .0f);\n    vec3 ta = vec3( -0.5, -0.4, 0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n   \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    // ray direction\n    vec3 rd = normalize( vec3(p.xy,2.) );\n\n    // render\t\n    vec4 colid = render( ro, rd, p );\n    \n    vec3 col = colid.xyz;\n\n    col = retro_filter(p, col);\n    \n    // gamma\n    col = pow( col, vec3(0.9545) );\n    tot += col;\n\n\n\n    fragColor = vec4( tot * 1., 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat hash11( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nvec3 hash13(float n) {\n    float n1 = n;\n    float n2 = hash11(n);\n    float n3 = hash11(n2);\n    return vec3(hash11(n1),hash11(n2),hash11(n3));\n}\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r ) \n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nfloat opSs( in float d1, in float d2 )\n{\n    d1 *= -1.0;\n    return (d1 > d2) ? d1 : d2;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}