{
    "Shader": {
        "info": {
            "date": "1571764065",
            "description": "Version of CodebaseAlpha4, but with clouds and water added; created live on-stream during Ep. 69 of Codebase Alpha (https://twitch.tv/codebasealpha)",
            "flags": 0,
            "hasliked": 0,
            "id": "td3SWr",
            "likes": 19,
            "name": "CodebaseAlpha6",
            "published": 3,
            "tags": [
                "terrain"
            ],
            "usePreview": 0,
            "username": "codebasealpha",
            "viewed": 612
        },
        "renderpass": [
            {
                "code": "#define PI  3.141592654\n#define TAU (2.0*PI)\n#define TOLERANCE       0.001\n#define MAX_ITER        100\n#define MIN_DISTANCE    0.1\n#define MAX_DISTANCE    30.0\n\nconst vec3 skyCol1 = vec3(0.35, 0.45, 0.6);\nconst vec3 skyCol2 = vec3(0.4, 0.7, 1.0);\nconst vec3 skyCol3 = pow(skyCol1, vec3(0.25));\nconst vec3 sunCol1 =  vec3(1.0,0.5,0.4);\nconst vec3 sunCol2 =  vec3(1.0,0.8,0.7);\nconst float gravity = 1.0;\n\nfloat noise(vec2 p)\n{\n    return 2.0 * (texture(iChannel1, 0.01 *p + 0.5).x - 0.5);\n}\n\nvec4 cloudCol(vec2 p, float off)\n{\n    float n = 0.0;\n    p += 3.0;\n    float amp = 1.0;\n    float freq = 1.0;\n\n    for (int i = 0; i < 5; i++)\n    {\n        n += amp * noise(freq * p);\n        const float df = 0.1;\n        p += 0.0051 * iTime; // + 1.0 * vec2(cos(df * i*p.x), sin(df * i*p.y));\n        amp *= 0.4;\n        freq *= 3.0;\n    }\n\n    vec4 col = vec4(1.0, 1.0, 1.0, max(n-off, 0.0));\n    return col;\n}\n\nvoid rot(inout vec2 p, in float a)\n{\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(p.x*c + p.y*s, -p.x*s + p.y*c);\n}\n\nfloat rand(in vec2 co)\n{\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 hash(in vec2 p)\n{\n  p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n  return fract(sin(p)*18.5453);\n}\n\nvec4 voronoi(in vec2 x)\n{\n  vec2 n = floor(x);\n  vec2 f = fract(x);\n  vec4 m = vec4(8.0);\n  for(int j=-1; j<=1; j++)\n  for(int i=-1; i<=1; i++)\n  {\n    vec2  g = vec2(float(i), float(j));\n    vec2  o = hash(n + g);\n    vec2  r = g - f + o;\n    float d = dot(r, r);\n\n    if(d<m.x)\n    {\n      m = vec4(d, o.x + o.y, r);\n    }\n  }\n\n  return vec4(sqrt(m.x), m.yzw);\n}\n\nfloat globalHeight(float f, vec2 op)\n{\n    return (f *0.9 + (0.5 + 0.5 * cos(op.y *0.1)) * 0.4 - 0.3) * (0.7 + 0.3 *sin((0.5 + 0.25 * (1.0 + sin(op.y))) * op.x - 1.5));\n}\n\nfloat heightFunction(vec2 p)\n{\n    vec2 op = p;\n    p += 0.02;\n    p *= 0.0025;\n    float f = 0.0;\n    float amplitude = 1.0;\n    float period = 1.0;\n\n    for (int i = 0; i < 7; i++)\n    {\n        f += amplitude * texture(iChannel0, period * p).x;\n        rot(p, 1.0);\n        amplitude *= 0.5;\n        period *= 2.0;\n    }\n\n    return globalHeight(f, op);\n}\n\nfloat heightFunctionLo(vec2 p)\n{\n    vec2 op = p;\n    p += 0.02;\n    p *= 0.0025;\n    float f = 0.0;\n    float amplitude = 1.0;\n    float period = 1.0;\n       \n    for (int i = 0; i < 6; i++)\n    {\n        f += amplitude * texture(iChannel0, period * p).x;\n        rot(p, 1.0);\n        amplitude *= 0.5;\n        period *= 2.0;\n    }\n    \n    return globalHeight(f, op);\n}\n\nfloat heightFunctionHi(vec2 p)\n{\n    vec2 op = p;\n    p += 0.02;\n    p *= 0.0025;\n    float f = 0.0;\n    float amplitude = 1.0;\n    float period = 1.0;\n       \n    for (int i = 0; i < 11; i++)\n    {\n        f += amplitude * texture(iChannel0, period * p).x;\n        rot(p, 1.0);\n        amplitude *= 0.5;\n        period *= 2.0;\n    }\n   \n    return globalHeight(f, op);\n}\n\nvec3 getNormal(in vec2 p, in float d)\n{\n  vec2 eps = vec2(0.004*d, 0);\n  float dx = heightFunction(p - eps) - heightFunction(p + eps);\n  float dy = 2.0f*eps.x;\n  float dz = heightFunction(p - eps.yx) - heightFunction(p + eps.yx);\n  return normalize(vec3(dx, dy, dz));\n}\n\nvec3 getNormalLo(in vec2 p, in float d)\n{\n  vec2 eps = vec2(0.004*d, 0);\n  float dx = heightFunctionLo(p - eps) - heightFunctionLo(p + eps);\n  float dy = 2.0f*eps.x;\n  float dz = heightFunctionLo(p - eps.yx) - heightFunctionLo(p + eps.yx);\n  return normalize(vec3(dx, dy, dz));\n}\n\nvec3 getNormalHi(in vec2 p, in float d)\n{\n  vec2 eps = vec2(0.004*d, 0);\n  float dx = heightFunctionHi(p - eps) - heightFunctionHi(p + eps);\n  float dy = 2.0f*eps.x;\n  float dz = heightFunctionHi(p - eps.yx) - heightFunctionHi(p + eps.yx);\n  return normalize(vec3(dx, dy, dz));\n}\n\nfloat march(in vec3 ro, in vec3 rd, out int max_iter)\n{\n  float dt = 0.1;\n  float d = MIN_DISTANCE;\n  float lh = 0.0;\n  float ly = 0.0;\n \n  for (int i = 0; i < MAX_ITER; ++i)\n  {\n    vec3 p = ro + d*rd;\n    float h = heightFunction(p.xz);\n   \n    if (d > MAX_DISTANCE) \n    {\n      max_iter = i;\n      return MAX_DISTANCE;\n    }\n\n    float hd = p.y - h;\n\n    if (hd < 0.0)\n    {\n      return d - dt + dt*(lh-ly)/(p.y-ly-h+lh);\n    }\n\n    lh = h;\n    ly = p.y;\n    dt = max(hd, TOLERANCE) + 0.001*d;\n    d += dt;\n  }\n \n  max_iter = MAX_ITER;\n  return MAX_DISTANCE;\n}\n\nvec3 sunDirection()\n{\n  const vec3 sunDirection = normalize(vec3(-1.0, 0.2, -1.0));\n  vec3 sunDir = sunDirection;\n  rot(sunDir.xz, 2.0);\n  return sunDir;\n}\n\nvec3 skyColor(vec3 rd) {\n  vec3 sunDir = sunDirection();\n  float sunDot = max(dot(rd, sunDir), 0.0);\n  vec3 final = vec3(0.0);\n  float angle = atan(rd.y, length(rd.xz))*2.0/PI;\n  final += mix(mix(skyCol1, skyCol2, max(0.0, angle)), skyCol3, clamp(-angle*2.0, 0.0, 1.0));\n  final += 0.5*sunCol1*pow(sunDot, 30.0);\n  final += 1.0*sunCol2*pow(sunDot, 600.0);\n   \n  return final;\n}\n\nfloat shadow(in vec3 ro, in vec3 rd, in float ll, in float mint)\n{\n  float t = mint;\n \n  for (int i=0; i<24; ++i)\n  {\n    vec3 p = ro + t*rd;\n    float h = heightFunction(p.xz);\n    float d = (p.y - h);\n    if (d < TOLERANCE) return 0.1;\n    if (t > ll) return 1.0;\n    t += max(0.1, 0.25*h);\n  }\n \n  return 1.0;\n}\n\nfloat gravityWave(in vec2 p, float k, float h) \n{\n  float w = sqrt(gravity*k*tanh(k*h));\n  return sin(p.y*k + w* iTime);\n}\n\nfloat seaHeight(vec2 p)\n{\n  float height = 0.0;\n  float amplitude = 0.17;\n  float freq = 0.3;\n\n  for (int i = 0; i < 7; i++)\n  {  \n    height += amplitude * gravityWave(p, freq, 10.0);\n    amplitude *= 0.80;\n    freq *= 1.1;\n//    p += 10.0;\n    rot(p, 1.2);\n  }\n\n  return height;\n}\n\nvec3 seaNormal(in vec2 p, in float h) \n{\n  vec2 eps = vec2(0.001, 0.0);\n  vec3 n = vec3(\n    h*seaHeight(p + eps) - h*seaHeight(p - eps), 2.0*eps.x,\n    h*seaHeight(p + eps.yx) - h*seaHeight(p - eps.yx)\n  );\n \n  return normalize(n);\n}\n\nvec3 getColor(vec3 ro, vec3 rd)\n{\n    int max_iter;\n    float d = march(ro, rd, max_iter);\n    vec3 sandColor =  1.3 * vec3(0.68, 0.4, 0.3);\n    vec3 surfaceColor = vec3(0.0);\n    vec3 skyCol = skyColor(rd);\n   \n    if (d < MAX_DISTANCE)\n    {\n        vec3 p = ro + d * rd;\n       \n        // diffuse lighting\n        vec3 sunDir = sunDirection();\n        float seaHeight = 0.225;\n        float dsea = (seaHeight - ro.y)/rd.y;\n\n        if (d > dsea && dsea > 0.0)\n        {\n            vec3 psea = ro + dsea * rd;\n            float seaDepth = seaHeight - heightFunctionLo(psea.xz);\n            vec3 normal = seaNormal(psea.xz * 500.0, tanh(20.0*seaDepth)*(0.5 + 0.5*sin(5.0*(psea.x + psea.y))));\n            float dotProduct = max(dot(-normal, rd), 0.0);\n           \n            // specular lighting\n            vec3 refRay = reflect(rd,normal);\n            vec3 refSkyColor = skyColor(refRay);\n            float seaDist = d - dsea;\n            float seaFactor = exp(-seaDist * 50.0);\n            float shoreFactor = exp(-seaDist * 200.0);\n           \n            // Fog\n            float fogHeight = 0.3 - seaDepth;\n            float dfog = (fogHeight - ro.y)/rd.y;\n            float fogDepth = d > dfog && dfog > 0.0 ? d - dfog : 0.0;\n            float fogFactor = exp(-fogDepth);\n            float shad = shadow(psea, sunDir, 4.0, 0.04);\n            vec3 seaAmb = 0.4*mix(vec3(0.4, 1.0, 0.9), vec3(0.0), tanh(30.0*seaDepth));\n            vec3 seaFloor = mix(seaAmb, shad * 0.5*vec3(0.8, 1.0, 0.6), seaFactor);\n            vec3 breakingWaves = mix(seaFloor, vec3(0.9), shoreFactor);\n            vec3 col = mix(refSkyColor, breakingWaves, pow(dotProduct, 0.75));\n            col = mix(skyCol, col, fogFactor);\n           \n            return col;\n        }\n        else\n        {\n            // Mountain strata\n            float bandings = mix(50.0, 100.0, 0.5 + 0.5*sin(length(p.y)*10.0));\n            float bandingo = sin(length(p.xz) * 3.0);\n            float bandingf = pow(0.5 + 0.5 * sin(p.y*bandings + bandingo), 0.25);\n            float banding = mix(0.6, 1.0, bandingf);\n      \n            float heightLo = heightFunctionLo(p.xz + vec2(0.2));\n            float heightHi = heightFunctionHi(p.xz);\n            float heightRatio = heightHi / heightLo;\n           \n            vec3 normalLo = getNormalLo(p.xz, d);\n            vec3 normal = getNormal(p.xz, d);\n            vec3 normalHi = getNormalHi(p.xz, d);\n            surfaceColor = sandColor * banding;\n            float refFactor = 0.0;\n                       \n            float flatness = max(dot(normal, vec3(0.0, 1.0, 0.0)), 0.0);\n            float flatnessFactor = pow(flatness, 7.0);\n           \n            // Fog\n            float fogHeight = 0.2 + 0.2 * flatnessFactor;\n            float dfog = (fogHeight - ro.y)/rd.y;\n            float fogDepth = d > dfog && dfog > 0.0 ? d - dfog : 0.0;\n            float fogFactor = exp(-fogDepth);\n          \n            vec4 treePattern = voronoi(p.xz * 50.0);\n            vec4 patchPattern = voronoi(p.xz * 10.0);\n       \n            // Snow\n            if (p.y > 0.7 + 0.1 * sin(p.x + p.z) - 0.3 * flatnessFactor)\n            {\n                surfaceColor = vec3(1.0);\n                refFactor = 0.5;\n                normal = normalLo;\n            }\n            else if (p.y > seaHeight + 0.01 && p.y < 0.3 + 0.1 * flatnessFactor)\n            {\n                // Trees\n                surfaceColor = mix(vec3(0.2, 0.5, 0.0), vec3(0.5, 0.5, 0.0), patchPattern.y) * 1.3;\n                surfaceColor *= 1.0 - treePattern.x * 0.75;\n                vec3 normalOffset = vec3(treePattern.z, 0.0, treePattern.w);\n                normal = normalize(normalLo - normalOffset);\n            }\n            else\n            {\n                normal = normalHi;\n            }\n       \n            // specular lighting\n            vec3 refRay = reflect(rd,normal);\n            vec3 refSkyColor = skyColor(refRay);\n       \n            // shadows\n            float shad = shadow(p, sunDir, 4.0, 0.01); // Look into this\n            float dl = max(0.0, dot(normal, sunDir));\n            float grad = mix(0.2, 1.0, shad * dl);   \n            vec3 col = vec3(grad * surfaceColor +  refFactor * refSkyColor) * pow(heightRatio, 3.0);\n            col = mix(skyCol, col, fogFactor);\n            col = mix(col, skyCol, d/MAX_DISTANCE);\n       \n            return col;\n        }\n    }\n    else\n    {\n        vec3 col = skyCol;\n        float dsky = (10.0 - ro.y)/rd.y;\n       \n        if (dsky > 0.0)\n        {     \n            vec3 p = ro + dsky * rd;\n            vec4 clouds = cloudCol(p.xz * 0.003, 1.0 - 0.75 * tanh(p.z));\n            col = mix(skyCol, clouds.xyz, clouds.w * (1.0 - 1.0 * tanh(0.001 * p.z)));\n        }\n       \n        return col;\n    }\n}\n\nvec3 eyePos(float t)\n{\n    return vec3(sin(t * 0.1), 1.4-0.0, -2.0 + t * 1.0);\n}\n\nvec3 getSample(in vec2 p, in float time)\n{\n  float off = 1.0*time;\n  vec3 ro  = eyePos(time);\n  vec3 la  = eyePos(time + 0.1) + vec3(0.0, -0.02,  0.0);\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww, uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n  vec3 col = getColor(ro, rd);\n \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n  vec2 p = fragCoord/iResolution.xy - vec2(0.6,0.3);\n  p.x *= iResolution.x/iResolution.y;\n    \n  vec3 col = getSample(p, iTime);\n  fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}