{
    "Shader": {
        "info": {
            "date": "1530202383",
            "description": "Update of original with more boids; replaced some ray marching by tracing -- faster.",
            "flags": 32,
            "hasliked": 0,
            "id": "MdyBDG",
            "likes": 16,
            "name": "Boidies 2",
            "published": 3,
            "tags": [
                "dynamics",
                "bird",
                "flight",
                "swarm",
                "boid"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 671
        },
        "renderpass": [
            {
                "code": "// \"Boidies 2\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Update of original with more boids; replaced some ray marching by tracing -- faster.\n\n/*\n Real boids (everybody knows what they are) in 3D. The red boid is the leader; birds of\n the other two colors try to follow the leader and also prefer to group with others of the same\n color. The leader flies a fixed path which sometimes takes it through the square hoop. \n The region is enclosed by a hemispherical dome, and boids bounce off both the dome and the \n ground (dome size and projected path are marked on ground).\n \n The two sliders control zoom and the various interaction parameters (all lumped together for\n simplicity, red is strongest, and parameter change is initially automatic). Click on the circle\n to select the view (fixed, tracking, or attached to the red boid); mouse can also be used to\n look around.\n\n Explore...\n*/\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nmat3 QtToRMat (vec4 q);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\nconst int nBoid = 256;\nvec3 qHit, qnHit, sunDir;\nfloat dstFar, tCur, regSz, bdRad, bdLen, wnRad, wnThk, hoopSz, hoopThk, hoopHt, vuMode;\nint idBoid;\nconst float pi = 3.14159;\n\nvec4 HCylHit (vec3 ro, vec3 rd,  float rad, float len)\n{\n  vec3 s;\n  float dMin, d, a, b, w, srdy;\n  dMin = dstFar;\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - rad * rad);\n  if (w > 0.) {\n    srdy = sign (rd.y);\n    if (a > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0.) {\n        d /= a;\n        s = ro + d * rd;\n      } else s.y = len;\n    } else s.y = len;\n    if (abs (s.y) < len) {\n      dMin = d;\n      qnHit = vec3 (s.xz, 0.);\n    } else if (srdy * ro.y < - len) {\n      d = - (srdy * ro.y + len) / abs (rd.y);\n      if (d > 0.) {\n        s = ro + d * rd;\n        if (length (s.xz) < rad) {\n          dMin = d;\n          qnHit = vec3 (0., - srdy, 0.);\n        }\n      }\n    }\n  }\n  return vec4 (s, dMin);\n}\n\nvec4 CapsHit (vec3 ro, vec3 rd,  float rad, float len)\n{\n  vec3 s, sMin;\n  float dMin, d, a, b, w, drz;\n  dMin = dstFar;\n  a = dot (rd.xy, rd.xy);\n  b = dot (rd.xy, ro.xy);\n  w = b * b - a * (dot (ro.xy, ro.xy) - rad * rad);\n  if (w > 0. && a > 0.) {\n    d = - b - sqrt (w);\n    d /= a;\n    s = ro + d * rd;\n    if (d > 0. && abs (s.z) < len) {\n      dMin = d;\n      sMin = s;\n      qnHit = vec3 (s.xy, 0.);\n    } else {\n      drz = - len * sign (s.z);\n      ro.z += drz;\n      b = dot (rd, ro);\n      w = b * b - (dot (ro, ro) - rad * rad);\n      if (w > 0.) {\n        d = - b - sqrt (w);\n        if (d > 0.) {\n          s = ro + d * rd;\n          dMin = d;\n          sMin = s;\n          sMin.z -= drz;\n          qnHit = s;\n        }\n      }\n    }\n  }\n  return vec4 (sMin, dMin);\n}\n\nfloat BoidHit (vec3 ro, vec3 rd)\n{\n  mat3 bMat;\n  vec4 ds;\n  vec3 rom, rdm, qHitM, qnHitM;\n  float dMin;\n  dMin = dstFar;\n  for (int n = 0; n < nBoid; n ++) {\n    bMat = QtToRMat (Loadv4 (3 * n + 2));\n    rom = bMat * (ro - Loadv4 (3 * n).xyz);\n    rdm = bMat * rd;\n    ds = CapsHit (rom, rdm, bdRad, bdLen);\n    if (ds.w < dMin) {\n      dMin = ds.w;\n      idBoid = n;\n      qHitM = ds.xyz;\n      qnHitM = qnHit;\n    }\n    rom.z += 2. * bdLen;\n    ds = HCylHit (rom, rdm, wnRad, wnThk);\n    if (ds.w < dMin) {\n      dMin = ds.w;\n      idBoid = n;\n      qHitM = ds.xyz;\n      qHitM.z -= 2. * bdLen;\n      qnHitM = qnHit;\n    }\n  }\n  qHit = qHitM;\n  qnHit = normalize (qnHitM) * QtToRMat (Loadv4 (3 * idBoid + 2));\n  return dMin;\n}\n\nvec4 BoidCol ()\n{\n  vec3 col;\n  float s;\n  if (idBoid == 0) col = vec3 (1., 0., 0.);\n  else col = ((Loadv4 (3 * idBoid).w == 0.) ? vec3 (1., 1., 0.) : vec3 (0., 1., 1.));\n  col *= 0.9 + 0.1 * smoothstep (- bdLen, bdLen, qHit.z);\n  s = length (qHit.yz - vec2 (0.5 * bdLen, bdLen + 0.35 * bdRad));\n  if (s < 0.2 * bdRad) col = (s < 0.1 * bdRad) ? vec3 (1.) : vec3 (0.2, 0.8, 0.2);\n  if (length (qHit - vec3 (0., -0.2 * bdRad, bdRad + bdLen)) < 0.6 * bdRad) \n     col = vec3 (1.) * (1. - 0.9 * step (abs (qHit.y + 0.2 * bdRad), 0.05 * bdRad) *\n        SmoothBump (0.2, 0.8, 0.05, mod (8. * abs (qHit.x / bdRad), 1.)));\n  if (length (qHit.xz + vec2 (0., 2. * bdLen)) > 0.7 * wnRad) {\n    s = 0.25 + atan (qHit.z + 2. * bdLen, - qHit.x) / (2. * pi);\n    if (abs (s) < 0.15) col *= 0.5 + 0.5 * SmoothBump (0.1, 0.9, 0.05, mod (64. * s, 1.));\n  }\n  return vec4 (col, 0.2);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float d;\n  q = p;\n  q.y -= hoopHt;\n  d = max (PrBoxDf (q, vec3 (hoopSz, hoopSz, hoopThk)),\n     - PrBox2Df (q.xy, vec2 (hoopSz - 2. * hoopThk)));\n  q = p;\n  q.y -= 0.25 * hoopHt;\n  d = min (d, PrBoxDf (q, vec3 (hoopThk, 0.25 * hoopHt, hoopThk)));\n  return d;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 80; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0002, -0.0002);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  if (rd.y >= 0.) {\n    col = vec3 (0.1, 0.2, 0.3) + 0.2 * pow (1. - rd.y, 8.) +\n       0.35 * pow (max (dot (rd, sunDir), 0.), 6.);\n    col = mix (col, vec3 (0.9), clamp (0.1 + 0.8 * rd.y *\n       Fbm2 (5. * rd.xz / max (rd.y, 0.001)), 0., 1.));\n  } else {\n    ro -= rd * ro.y / rd.y;\n    col = mix (mix (vec3 (0.2, 0.3, 0.1), vec3 (0.3, 0.4, 0.2), Fbm2 (ro.xz)),\n       vec3 (0.3, 0.4, 0.5), pow (1. + rd.y, 32.));\n    col *= (0.1 + 0.9 * max (dot (VaryNf (ro, vec3 (0., 1., 0.),\n       2. * (1. - smoothstep (0.1, 1., length (ro.xz) / dstFar))), sunDir), 0.));\n    col = mix (col, vec3 (1., 0.6, 0.6), 0.2 * (1. - smoothstep (0.2, 0.3,\n       abs (length (ro.xz) - regSz))));\n    col = mix (col, vec3 (1., 1., 0.6), 0.2 * (1. - smoothstep (0.2, 0.3,\n       abs (length (vec2 (abs (ro.x) - 0.35 * regSz, ro.z)) - 0.35 * regSz))));\n    col =  mix (col, vec3 (0.7), 0.2 * (1. - smoothstep (0., 0.1, max (abs (ro.x) - hoopSz,\n       abs (ro.z) - hoopThk))));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstBoid, dstObj;\n  dstBoid = BoidHit (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (min (dstObj, dstBoid) < dstFar) {\n    if (dstBoid < min (dstObj, dstFar)) {\n      ro += rd * dstBoid;\n      col4 = BoidCol ();\n      vn = qnHit;\n    } else if (dstObj < dstFar) {\n      ro += rd * dstObj;\n      col4 = vec4 (0.8, 0.8, 0.9, 0.1);\n      vn = VaryNf (32. * ro, ObjNf (ro), 0.5);\n    }\n    col = col4.rgb * (0.3 + 0.7 * max (dot (vn, sunDir), 0.)) +\n       col4.a * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n  } else col = BgCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col, float zmVar, float flVar, float vuMode)\n{\n  vec4 wgBx[3];\n  vec2 ust;\n  float asp;\n  asp = canvas.x / canvas.y;\n  wgBx[0] = vec4 (0.45 * asp, -0.2, 0.023, 0.);\n  wgBx[1] = vec4 (0.43 * asp, 0.05, 0.01 * asp, 0.15);\n  wgBx[2] = vec4 (0.48 * asp, 0.05, 0.01 * asp, 0.15);\n  if (abs (length (0.5 * uv - wgBx[0].xy) - wgBx[0].z) * canvas.y < 1.5)\n     col = ((vuMode == 0.) ? vec3 (0., 1., 0.) : (vuMode == 1.) ?\n     vec3 (1., 1., 0.) : vec3 (1., 0., 0.));\n  ust = abs (0.5 * uv - wgBx[1].xy) - wgBx[1].zw;\n  if (abs (max (ust.x, ust.y)) * canvas.y < 1.) col = vec3 (0.8);\n  ust = 0.5 * uv - wgBx[1].xy;\n  ust.y -= (zmVar - 0.5) * 2. * wgBx[1].w;\n  if (length (ust) < 0.9 * wgBx[1].z) col = vec3 (0.7, 0.1, 0.7);\n  ust = abs (0.5 * uv - wgBx[2].xy) - wgBx[2].zw;\n  if (abs (max (ust.x, ust.y)) * canvas.y < 1.) col = vec3 (0.8);\n  ust = 0.5 * uv - wgBx[2].xy;\n  ust.y -= (flVar - 0.5) * 2. * wgBx[2].w;\n  if (abs (length (ust) - 0.7 * wgBx[2].z) * canvas.y < 3.) col =\n     (flVar > 0.7) ? vec3 (1., 0.1, 0.1) : ((flVar > 0.3) ?\n     vec3 (1., 1., 0.1) : vec3 (0.1, 1., 0.1));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat, flMat;\n  vec4 stDat, mPtr;\n  vec3 rd, ro, vd, rLd, vLd, col;\n  vec2 mMid[4], ut[4], mSize, canvas, uv, ori, ca, sa;\n  float tCur, el, az, zmFac, pDist, zmVar, flVar, vuCorn;\n  int wgSel;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mSize = 0.2 * vec2 (canvas.x / canvas.y, 1.);\n  mMid[0] = (1. / mSize.y - 1.) * mSize;\n  mMid[1] = mMid[0] * vec2 (1., -1.);\n  mMid[2] = mMid[0] * vec2 (-1., -1.);\n  mMid[3] = mMid[0] * vec2 (-1., 1.);\n  for (int k = 0; k < 4; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  vuCorn = 0.;\n  for (int k = 0; k < 4; k ++) {\n    if (max (ut[k].x, ut[k].y) < 0.) {\n      uv = (uv - mMid[k]) / mSize.y;\n      vuCorn = float (k + 1);\n      break;\n    }\n  }\n  stDat = Loadv4 (3 * nBoid + 0);\n  vuMode = mod (stDat.y + vuCorn, 5.);\n  zmVar = (vuCorn == 0.) ? stDat.z : 0.5;\n  regSz = stDat.w;\n  stDat = Loadv4 (3 * nBoid + 1);\n  hoopSz = stDat.x;\n  hoopThk = stDat.y;\n  hoopHt = stDat.z;\n  stDat = Loadv4 (3 * nBoid + 2);\n  el = (vuCorn == 0.) ? stDat.x : 0.;\n  az = (vuCorn == 0.) ? stDat.y : 0.;\n  flVar = stDat.z;\n  wgSel = int (stDat.w);\n  mPtr = Loadv4 (3 * nBoid + 3);\n  rLd = Loadv4 (0).xyz;\n  bdRad = 0.15;\n  bdLen = 0.1;\n  wnRad = 0.25;\n  wnThk = 0.005;\n  dstFar = 4. * regSz;\n  if (vuMode == 0.) {\n    zmFac = 2. + 8. * zmVar;\n    el = clamp (el, -0.2 * pi, 0.3 * pi);\n  } else if (vuMode == 1.) {\n    ro = vec3 (0., 2., - regSz);\n    vd = rLd - ro;\n    pDist = length (vd);\n    vd = normalize (vd);\n    zmFac = 0.7 + 4. * pDist / 50. + 25. * zmVar;\n    az = clamp (0.25 * az, -0.2 * pi, 0.2 * pi);\n    el = clamp (0.25 * el, -0.2 * pi, 0.2 * pi);\n    az += 0.5 * pi + atan (- vd.z, vd.x);\n    el += asin (vd.y);\n  } else if (vuMode >= 2.) {\n    az = clamp (az, - pi, pi);\n    el = clamp (el, -0.3 * pi, 0.3 * pi);\n    zmFac = 0.5 + 4.5 * zmVar;\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  if (vuMode == 0.) {\n    ro = vuMat * vec3 (0., 2., -2. * regSz);\n    ro.y = max (ro.y,  0.4);\n  } else if (vuMode >= 2.) {\n    flMat = QtToRMat (Loadv4 (2));\n    ro = rLd + ((vuMode == 2.) ? vec3 (0., 0., 5. * bdLen) : ((vuMode == 3.) ?\n       vec3 (0., 2. * bdRad, -15. * bdLen) : vec3 (0., 2. * bdRad, 15. * bdLen))) * flMat;\n    if (vuMode == 4.) rd.z *= -1.;\n    rd = rd * flMat;\n  }\n  sunDir = normalize (vec3 (1., 2., -1.));\n  col = ShowScene (ro, rd);\n  if (vuCorn == 0.) col = ShowWg (uv, canvas, col, zmVar, flVar, vuMode);\n  if (mPtr.z > 0. && wgSel < 0 && vuMode > 0. && max (abs (uv.x), abs (uv.y)) < 0.03 &&\n     min (abs (uv.x), abs (uv.y)) < 0.003) col = vec3 (0.8, 0.8, 0.1);\n  for (int k = 0; k < 4; k ++) {\n    if (max (ut[k].x, ut[k].y) < 0. && min (abs (ut[k].x), abs (ut[k].y)) * canvas.y < 2.)\n       col = vec3 (0.8, 0.8, 0.2);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);  \n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;  \n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Boidies 2\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 RMatToQt (mat3 m);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBoid = 256;\nvec3 rLd, vLd, aLd;\nfloat vFly, regSz, fSep, rFlok, fFlok, fAln, fLead, rAttr, nStep, dt,\n   hoopSz, hoopThk, hoopHt;\nconst float pi = 3.14159;\nconst float txRow = 128.;\n\nvoid Step (int mId, out vec3 r, out vec3 v, out vec3 a, out float grp)\n{\n  vec4 p;\n  vec3 dr, rSum, vSum;\n  float nNeb, rLen, vMag, rMarg;\n  p = Loadv4 (3 * mId);\n  r = p.xyz;\n  grp = p.w;\n  v = Loadv4 (3 * mId + 1).xyz;\n  a = vec3 (0.);\n  vSum = vec3 (0.);\n  rSum = vec3 (0.);\n  nNeb = 0.;\n  for (int n = 0; n < nBoid; n ++) {\n    if (n != mId) {\n      p = Loadv4 (3 * n);\n      dr = r - p.xyz;\n      rLen = length (dr);\n      if (rLen < 1.) a += fSep * (1. / rLen - 1.) * dr;\n      if (rLen < rFlok && grp == p.w) {\n        rSum += p.xyz;\n        vSum += Loadv4 (3 * n + 1).xyz;\n        ++ nNeb;\n      }\n    }\n  }\n  if (nNeb > 0.) a -= fFlok * (r - rSum / nNeb) + fAln * (v - vSum / nNeb);\n  dr = r - rLd;\n  rLen = length (dr);\n  if (rLen < rAttr) {\n    a += ((1. - 2. * smoothstep (2., 3., rLen)) * fLead / max (rLen * rLen, 0.001)) * dr;\n  }\n  rMarg = 1.;\n  dr = r;\n  dr.xy -= vec2 ((hoopSz - hoopThk) * sign (r.x), hoopHt);\n  dr = max (abs (dr) - vec3 (hoopThk, hoopSz, hoopThk), 0.) * sign (dr);\n  rLen = length (dr);\n  if (rLen < hoopThk + rMarg) a += fSep * ((hoopThk + rMarg) / rLen - 1.) * dr;\n  dr = r;\n  dr.y -= hoopHt + (hoopSz - hoopThk) * sign (r.y);\n  dr = max (abs (dr) - vec3 (hoopSz, hoopThk, hoopThk), 0.) * sign (dr);\n  rLen = length (dr);\n  if (rLen < hoopThk + rMarg) a += fSep * ((hoopThk + rMarg) / rLen - 1.) * dr;\n  dr = r;\n  dr.y -= 0.25 * hoopHt;\n  dr = max (abs (dr) - vec3 (hoopThk, 0.25 * hoopHt, hoopThk), 0.) * sign (dr);\n  rLen = length (dr);\n  if (rLen < hoopThk + rMarg) a += fSep * ((hoopThk + rMarg) / rLen - 1.) * dr;\n  a += 0.05 * (vFly - length (v)) * normalize (v);\n  v += dt * a;\n  r += dt * v;\n  rLen = length (r);\n  if (rLen > regSz) {\n    if (dot (r, v) > 0.) v = 0.9 * reflect (v, r / rLen);\n    r *= (regSz - 0.05) / rLen;\n  }\n  if (r.y < 0.) {\n    r.y = 0.05;\n    if (v.y < 0.) v = 0.9 * reflect (v, vec3 (0., 1., 0.));\n  }\n}\n\nvec3 TrackPos (float t)\n{\n  vec3 r;\n  float tt = mod (t, 1.);\n  r.xz = 0.35 * regSz * ((mod (t, 2.) < 1.) ? vec2 (- cos (2. * pi * tt) + 1., sin (2. * pi * tt)) :\n     vec2 (cos (2. * pi * tt) - 1., sin (2. * pi * tt)));\n  r.y = hoopHt + (hoopSz + 7. * hoopThk) * ((mod (floor (t / 2. - 0.25), 4.) > 1.) ?\n     SmoothBump (0.3, 0.7, 0.15, tt) : 1.);\n  return r;\n}\n\nvoid Init (int mId, out vec3 r, out vec3 v, out vec3 a, out float grp)\n{\n  float mIdf, w;\n  mIdf = float (mId);\n  w = mIdf / float (nBoid);\n  r = TrackPos (2. * w);\n  r.y += 1.5 * (w - 0.5);\n  v = vFly * (2. * normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3),\n     Hashff (mIdf + 0.6)) - 0.5) + 1.);\n  a = vec3 (0.);\n  grp = floor (2. * Hashff (mIdf));\n}\n\nvoid SetLead (out vec3 r, out vec3 v, out vec3 a)\n{\n  vec3 rf, rb;\n  float s, ds;\n  s = 5.5 * vFly * nStep * dt / (2. * pi * regSz);\n  ds = 0.1;\n  r = TrackPos (s);\n  rf = TrackPos (s + ds);\n  rb = TrackPos (s - ds);\n  v = (rf - rb) / (2. * ds);\n  a = (rf - 2. * r + rb) / (ds * ds);\n}\n\nvec4 EvalOri (int mId, vec3 v, vec3 a)\n{\n  vec3 va, ort, ca, sa;\n  float el, az, rl;\n  v = normalize (v);\n  va = cross (a, v);\n  el = -0.7 * asin (v.y);\n  az = atan (v.z, v.x) - 0.5 * pi;\n  rl = 0.001 * length (va) * sign (va.y);\n  ort = vec3 (el, az, rl);\n  ca = cos (ort);\n  sa = sin (ort);\n  return RMatToQt (mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n     mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP;\n  vec4 wgBx[3], stDat, p;\n  vec3 r, v, a;\n  vec2 iFrag, canvas, ust;\n  float tCur, grp, vuMode, asp, az, el, zmVar, flVar, autoVar;\n  int mId, pxId, wgSel, wgReg, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 3 * nBoid + 4) discard;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  mId = (pxId < 3 * nBoid) ? pxId / 3 : -1;\n  vFly = 1.2;\n  regSz = 40.;\n  hoopSz = 3.;\n  hoopThk = 0.5;\n  hoopHt = 5.;\n  fSep = 10.;\n  rFlok = 6.;\n  dt = 0.05;\n  wgReg = -2;\n  if (iFrame <= 5) {\n    mPtrP = mPtr;\n    vuMode = 1.;\n    zmVar = 0.5;\n    flVar = 0.6;\n    autoVar = 1.;\n    az = -0.1 * pi;\n    el = 0.;\n    wgSel = -1;\n    doInit = true;\n  } else {\n    doInit = false;\n    stDat = Loadv4 (3 * nBoid + 0);\n    nStep = stDat.x;\n    vuMode = stDat.y;\n    zmVar = stDat.z;\n    stDat = Loadv4 (3 * nBoid + 1);\n    autoVar = stDat.w;\n    stDat = Loadv4 (3 * nBoid + 2);\n    el = stDat.x;\n    az = stDat.y;\n    flVar = stDat.z;\n    if (autoVar > 0.) flVar = 0.2 + 0.8 * SmoothBump (0.1, 0.9, 0.1,\n       mod (0.1 * 5.5 * vFly * nStep * dt / (2. * pi * regSz), 1.));\n    wgSel = int (stDat.w);\n    mPtrP = Loadv4 (3 * nBoid + 3);\n    fLead = mix (1., 10., flVar);\n    rAttr = mix (3., 12., flVar);\n    fAln = mix (0., 0.04, flVar);\n    fFlok = mix (0., 0.04, flVar);\n  }\n  if (doInit) {\n    nStep = 0.;\n    if (mId >= 0) SetLead (rLd, vLd, aLd);\n    if (mId > 0) Init (mId, r, v, a, grp);\n  } else {\n    ++ nStep;\n    if (mId >= 0) SetLead (rLd, vLd, aLd);\n    if (mId > 0) Step (mId, r, v, a, grp);\n  }\n  if (mId == 0) {\n    r = rLd;\n    v = vLd;\n    a = aLd;\n    grp = 2.;\n  }\n  asp = canvas.x / canvas.y;\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (0.45 * asp, -0.2, 0.023, 0.);\n    wgBx[1] = vec4 (0.43 * asp, 0.05, 0.01 * asp, 0.15);\n    wgBx[2] = vec4 (0.48 * asp, 0.05, 0.01 * asp, 0.15);\n    if (length (mPtr.xy * vec2 (asp, 1.) - wgBx[0].xy) < wgBx[0].z) wgReg = 0;\n    ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[1].xy) - wgBx[1].zw;\n    if (max (ust.x, ust.y) < 0.) wgReg = 1;\n    ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[2].xy) - wgBx[2].zw;\n    if (max (ust.x, ust.y) < 0.) wgReg = 2;\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n    az = (vuMode == 0.) ? -0.1 * pi : 0.;\n    el = (vuMode == 0.) ? -0.04 * pi : 0.;\n  }\n  if (wgSel < 0) {\n    if (mPtr.z > 0.) {   \n      az = 2. * pi * mPtr.x;\n      el = pi * mPtr.y;\n    }\n  } else {\n    if (wgSel == 0) {\n      if (mPtrP.z <= 0.) {\n        vuMode = mod (++ vuMode, 5.);\n        zmVar = 0.5;\n        az = (vuMode == 0.) ? -0.1 * pi : 0.;\n        el = (vuMode == 0.) ? -0.04 * pi : 0.;\n      }\n    } else if (wgSel == 1) {\n      zmVar = clamp (0.5 + 0.5 * (mPtr.y - wgBx[1].y) / wgBx[1].w, 0., 1.);\n    } else if (wgSel == 2) {\n      flVar = clamp (0.5 + 0.5 * (mPtr.y - wgBx[2].y) / wgBx[2].w, 0., 1.);\n      autoVar = 0.;\n    }\n  }\n  if (pxId < 3 * nBoid) {\n    kp = 3 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (r, grp);\n    else if (pxId == kp + 1) stDat = vec4 (v, 0.);\n    else if (pxId == kp + 2) stDat = EvalOri (mId, v, a);\n  } else {\n    kp = 3 * nBoid;\n    if      (pxId == kp + 0) stDat = vec4 (nStep, vuMode, zmVar, regSz);\n    else if (pxId == kp + 1) stDat = vec4 (hoopSz, hoopThk, hoopHt, autoVar);\n    else if (pxId == kp + 2) stDat = vec4 (el, az, flVar, float (wgSel));\n    else if (pxId == kp + 3) stDat = mPtr;\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}