{
    "Shader": {
        "info": {
            "date": "1628743198",
            "description": "When I watched iq's tutorial, I find that he passed a dynamic value for a blend value of smoothmin().\nThat seemed very interesting, so I did an experiment.\nIt is very powerful!\n\nthe tut:\nhttps://www.youtube.com/watch?v=8--5LwHRhjk",
            "flags": 64,
            "hasliked": 0,
            "id": "ftBSDc",
            "likes": 16,
            "name": "Blending Experiment",
            "published": 3,
            "tags": [
                "blending",
                "smoothminimum"
            ],
            "usePreview": 0,
            "username": "iY0Yi",
            "viewed": 534
        },
        "renderpass": [
            {
                "code": "vec4 sd001(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\td = sdSphere(p+vec3(2.397, -5.01+(cos(iTime*.05)*.5+.5), -6.63), .944);\n\td = fOpUnionSmooth(sdSphere(p+vec3(-2.956*(sin(iTime*.05)*.5+.5), -11.227, 4.618), .944), d, .66);\n\tres = v4OpUnion(vec4(d, MAT_COL0_COL), res);\n\n    R(p.xz, iTime*.1);\n\td = sdBox(rot(p+vec3(-3.052, -3.359+(sin(iTime*.03)*.5+.5)*2., 5.2), vec3(0., -.24, 0.)), vec3(3.31, 3.31, .496)-0.)-0.;\n            \n\n    float cupsule0_blend;{\n\t\tvec3 q = rot(p+vec3(-3.395, -3.831, -.618), vec3(-.09, .1, -.448));\n\t\tcupsule0_blend = 5.5;\n\t\tfloat k = 12.;\n\t\tcupsule0_blend *= pow(sin(clamp(q.y*k, 2.*k, 8.*k))*.5+.5, .05)*.5+.5;\n\t}\n\td = fOpUnionSmooth(sdCapsule(rot(p+vec3(-3.395, -3.831, -.618), vec3(-.09, .1, -.448)), 0., 2.759), d, cupsule0_blend);\n\n    float cupsule1_blend;{\n\t\tvec3 q = rot(p+vec3(-.787, -3.237, -4.655), vec3(-.09, .1, -.448));\n\t\tcupsule1_blend = 5.5;\n\t\tfloat k = 12.*(cos(iTime*.05)*.5+.5);\n\t\tcupsule1_blend *= pow(sin(clamp(q.y*k+(sin(iTime*.05)*.5+.5), 2.*k, 8.*k))*.5+.5, .1)*.5+.5;\n\t}\n\td = fOpUnionSmooth(sdCapsule(rot(p+vec3(-.787, -3.237, -4.655), vec3(-.09, .1, -.448)), .278, 1.283), d, cupsule1_blend);\n\n\tres = v4OpUnionSmooth(vec4(d, MAT_COL1_COL), res, cupsule1_blend);\n\n\td = sdPlane(p);\n\tres = v4OpUnion(vec4(d, MAT_COL2_COL), res);\n\treturn res;\n}\n\nvec4 sd000(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\td = sdTorus(p+vec3(-1.11, -10.441*(cos(iTime*.05)*.5+.5), .846), vec2(4.47+sin(iTime*.08), .02));\n\tres = v4OpUnion(vec4(d, MAT_COL0_COL), res);\n\treturn res;\n}\n\nvec4 sdScene(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\n    vec3 cp = p;\n\tcp.xyz += vec3(1.93, -5.478, -.161);\n\tcp.xyz = rot(cp, vec3(2.965, 1.047, -.356));\n\n\td = sdSphere(p+vec3(2.302, -5.301, -3.858), 1.25);\n\td = fOpUnion(sdSphere(p+vec3(-5.972, -10.991, 7.07), 1.25), d);\n\td = fOpUnion(sdSphere(p+vec3(2.733, -8.5, -5.388), 1.127*(sin(iTime*.05)*.5+.5)), d);\n\tres = v4OpUnion(vec4(d, MAT_COL4_COL), res);\n\n    float sd001_blend;{\n\t\tvec3 q = p;\n\t\tsd001_blend = 5.5+(cos(iTime*.03)*.5+.5);\n\t\tfloat k = 12.;\n\t\tsd001_blend *= pow(sin(clamp(q.y*k*(cos(iTime*.025)*.5+.5), 2.*k, 8.*k))*.5+.5, .05)*.5+.5;\n\t}\n\tres = v4OpUnionSink(sd001(p), res, 1.107, 0.);\n\n    float box0_blend;{\n\t\tvec3 q = rot(cp+vec3(1.418, 3.407, -3.595), vec3(-.251, -.01, -.133));\n\t\tbox0_blend = 5.5;\n\t\tfloat k = 12.;\n\t\tbox0_blend *= pow(sin(clamp(q.y*k*(sin(iTime*.1)*.5+.5), 2.*k, 8.*k))*.5+.5, .05)*.5+.5;\n\t}\n\td = sdBox(rot(cp+vec3(1.418, 3.407, -3.595), vec3(-.251, -.01, -.133)), vec3(2.821, 2.821, 2.821)-0.)-0.;\n\tres = v4OpUnionSmooth(vec4(d, MAT_COL3_COL), res, box0_blend);\n\n\td = sdSphere(p+vec3(.229, -11.379, -2.071), 1.25);\n\td = fOpUnion(sdSphere(p+vec3(-4.138, -4.61, 5.165), 1.25), d);\n\tres = v4OpUnion(vec4(d, MAT_COL4_COL), res);\n\n\tres = v4OpUnionSmooth(sd000(rot(p+vec3(3.86, -6.739, -7.648), vec3(1.11, .278, .386))), res, 4.17);\n    \n    res+=texture(iChannel0, p*8.)*min(.001, distance(res.yzw, MAT_COL4_COL));\n\treturn res;\n}\n\nvec4 intersect(){\n\tfloat d = 1.;\n\tvec3  m = MAT_VOID;\n\tfor (int i = 0; i < ITERATION; i++){\n\t\tvec3 p = ray.origin + d * ray.direction;\n\t\tvec4 res = sdScene(p);\n\t\tm = res.yzw;\n\t\tres.x *= .5;\n\t\tif (abs(res.x) < MIN_DIST || res.x >= MAX_DIST) break;\n\t\td += res.x;\n\t\tif (d >= MAX_DIST) break;\n\t}\n\treturn vec4(d,m);\n}\n\nvec3 normal(vec3 p){\n\tfloat c=sdScene(p).x;\n\tfloat e=MIN_DIST*.1;\n\treturn normalize(vec3(\n\t\tsdScene(p+vec3(e,0.,0.)).x-c,\n\t\tsdScene(p+vec3(0.,e,0.)).x-c,\n\t\tsdScene(p+vec3(0.,0.,e)).x-c)\n\t);\n}\n\nfloat shadow(vec3 o, vec3 n){\n\tfloat mint=lit0.shadowStart;\n\tfloat maxt=lit0.shadowEnd;\n\tfloat k = lit0.shadowSoft;\n\tfloat res = 1.;\n\tfloat t=mint;\n\tfor( int i=0; i < ITERATION; i++){\n\t\tfloat h = sdScene(o + lit0.direction*t).x;\n\t\tres = min( res, k*h/t);\n\t\tt += h;\n\t\tif( res<0.001 || t>maxt ) break;\n\t}\n\treturn sat(res);\n}\n\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff ){\n\tconst int nbIte = 12;\n\tconst float nbIteInv = 1./float(nbIte);\n\tconst float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n\n\tfloat ao = 0.0;\n\n\tfor( int i=0; i<nbIte; i++ ){\n\t\tfloat l = hash11(float(i))*maxDist;\n\t\tvec3 aord = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal// for self occlusion problems!\n\t\tao += (l - max(sdScene( p + aord ).x,0.)) / maxDist * falloff;\n\t}\n\n\treturn clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\nvoid render(vec2 uv){\n\tvec4 res = intersect();\n\tvec3 p = ray.origin + res.x * ray.direction;\n\n\tif (res.x>=MAX_DIST){\n\t\trenDat.albedo = FOG_COL;\n\t\trenDat.normal = vec3(0);\n\t\trenDat.diffuse = 0.;\n\t\trenDat.specular = 0.;\n\t\trenDat.shadow = 0.;\n\t\trenDat.ao = 0.;\n\t\trenDat.depth = 1.;\n        R(uv, -PI*.125);\n\t\trenDat.result = mix(FOG_COL, FOG_COL*.025, uv.y);\n\t}\n\telse{\n\t\trenDat.albedo = res.yzw;\n\n\t\tvec3 n = normal(p);\n\n        float lamb1 = sat(dot(n, lit0.direction))*(1./PI);\n        \n\t\tfloat lamb2 = sat(dot(n, lit1.direction))*(1./PI);\n        if(distance(res.yzw, MAT_COL4_COL)<.01){\n            lamb1 = (dot(n, lit0.direction)*.5+.5)*(1./PI);\n            renDat.shadow = 1.;\n        }else{\n            renDat.shadow = shadow(p+n*.0001, n);\n        }\n\n\t\trenDat.ao =  ambientOcclusion(p+n*.0001, n, .1, 2.5);\n\t\trenDat.ao += ambientOcclusion(p+n*.0001, n, .5, 5.);\n\t\trenDat.ao += ambientOcclusion(p+n*.0001, n, 2., 3.);\n\t\trenDat.ao += ambientOcclusion(p+n*.0001, n, 4., 2.);\n\t\trenDat.ao = smoothstep(0., 4., renDat.ao);\n\n\t\trenDat.diffuse = lamb1;\n\t\trenDat.diffuse *= renDat.shadow;\n\t\t\n\n\t\tfloat shininess = .6;\n\t\tfloat shininessRef = .5;\n\t\tfloat intensity = .2;\n\t\tif(distance(MAT_COL0_COL,renDat.albedo)<.01)\n\t\t{\n\t\t\tshininess = MAT_COL0_SPEC.y;\n\t\t\tintensity = MAT_COL0_SPEC.x;\n\t\t}\n\t\tif(distance(MAT_COL1_COL,renDat.albedo)<.01)\n\t\t{\n\t\t\tshininess = MAT_COL1_SPEC.y;\n\t\t\tintensity = MAT_COL1_SPEC.x;\n\t\t}\n\t\tif(distance(MAT_COL2_COL,renDat.albedo)<.01)\n\t\t{\n\t\t\tshininess = MAT_COL2_SPEC.y;\n\t\t\tintensity = MAT_COL2_SPEC.x;\n\t\t}\n\t\tif(distance(MAT_COL3_COL,renDat.albedo)<.01)\n\t\t{\n\t\t\tshininess = MAT_COL3_SPEC.y;\n\t\t\tintensity = MAT_COL3_SPEC.x;\n\t\t}\n\t\tif(distance(MAT_COL4_COL,renDat.albedo)<.01)\n\t\t{\n\t\t\tshininess = MAT_COL4_SPEC.y;\n\t\t\tintensity = MAT_COL4_SPEC.x;\n\t\t}\n        \n        #define ggx(roughness, N, V, L) ggx(N, -V, L, roughness, .6)\n\t\tfloat ref = BlinnPhongRef(shininessRef*.9, n, ray.direction, lit0.direction);\n\t\tfloat spec = ggx(shininess, n, ray.direction, lit0.direction);\n        renDat.diffuse *= sms(-.1, .25, pow(ref, 1.25));\n        renDat.result = mix(vec3(0), lit0.color, renDat.diffuse);\n\t\trenDat.specular = spec*intensity;\n        renDat.result += mix(vec3(0), lit1.color, lamb2*renDat.ao*.25);\n\t\trenDat.result += mix(vec3(0), AMB_COL, renDat.ao*AMB_STRENGTH*.5);\n\t\trenDat.result*= renDat.albedo;\n\t\trenDat.result = mix(renDat.result, renDat.result+lit0.color, renDat.specular*renDat.shadow);\n\t\trenDat.depth = distance(ray.origin, p)/MAX_DIST;\n\t\trenDat.result = mix(renDat.result, FOG_COL, sat(pow(renDat.depth+FOG_START, FOG_POW)));\n\t}\n}\n\nvoid init(){\n    cam0.position = vec3(50.053, 3.884, 33.315);\n\tcam0.quaternion = vec4(.342, .646, .603, .319);\n\tcam0.fov = .135;\n\tcam0.orthoDist = 0.;\n\tcam0.orthoScale = 0.;\n\n\tlit0.direction = normalize(vec3(.363, .765, .532));\n\tlit0.color = vec3(1., 1., 1.);\n\tlit0.shadowStart = .05;\n\tlit0.shadowEnd = 30.;\n\tlit0.shadowSoft = 50.;\n\tlit1.direction = normalize(vec3(-.363, -.765, -.532));\n\tlit1.color = vec3(.3, .3, .3);\n\tlit1.shadowStart = .05;\n\tlit1.shadowEnd = 30.;\n\tlit1.shadowSoft = 50.;\n}\n\nvec3 quat_rotate(vec4 quat, vec3 dir){\n\treturn dir + 2.0 * cross(quat.xyz, cross(quat.xyz, dir) + quat.w * dir);\n}\nvoid camera(vec2 uv){\n\tvec3 dir = quat_rotate(cam0.quaternion, vec3(0,0,-1)).xzy;\n\tvec3 up = quat_rotate(cam0.quaternion, vec3(0,1,0)).xzy;\n\tvec3 pos = cam0.position;\n\tfloat fov = cam0.fov;\n    \n    if(mod(floor(iTime/3.),2.)==0.){\n        fov=.02;\n        float i = floor(iTime/4.);\n        pos.xy += (vec2(hash11(i+1.),hash11(i*i+2.))*.5-.5)*8.;\n    }\n    if(iTime<2.){\n        fov = cam0.fov;\n        pos = cam0.position;\n    }\n\tvec3 target = pos-dir;\n\n\tvec3 cw = normalize(target - pos);\n\tvec3 cu = normalize(cross(cw, up));\n\tvec3 cv = normalize(cross(cu, cw));\n\n\tcam0.up = up;\n\n\tmat3 camMat = mat3(cu, cv, cw);\n\tray.origin = pos;\n\tray.direction = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat ml = (min(iResolution.x, iResolution.y)==iResolution.x)?1.0:iResolution.y/iResolution.x;\n\tuv = (uv*2.-1.)*ml;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tinit();\n\tcamera(uv);\n\trender(uv);\n    fragColor = vec4(pow(renDat.result*1.25,vec3(.4545)), 1.) * smoothstep(0., 3., iTime);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 31271,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/absorb-label/e1-con-pani"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI acos(-1.)\n#define MIN_DIST .001\n#define MAX_DIST 500.0\n#define ITERATION 200\n\n#define sat(x) clamp(x, 0., 1.)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n\tR(p.xz, r.y);\n\tR(p.yx, r.z);\n\tR(p.zy, r.x);\n\treturn p;\n}\n\nstruct Ray{\n\tvec3 origin;\n\tvec3 direction;\n};\n\nstruct Camera{\n\tvec3 position;\n\tvec3 direction;\n\tvec3 target;\n\tvec4 quaternion;\n\tfloat fov;\n\tfloat orthoDist;\n\tfloat orthoScale;\n\tvec3 up;\n};\n\nstruct Light{\n\tvec3 direction;\n\tvec3 color;\n\tfloat intensity;\n\tfloat shadowStart;\n\tfloat shadowEnd;\n\tfloat shadowSoft;\n};\n\nstruct RenderData{\n\tvec3 albedo;\n\tvec3 normal;\n\tfloat diffuse;\n\tfloat specular;\n\tfloat shadow;\n\tfloat ao;\n\tfloat depth;\n\tvec3 result;\n}renDat;\n\nRay ray;\nCamera cam0;\nLight lit0;\nLight lit1;\n\n#define MAT_VOID vec3(-1)\n#define MAT_COL1_COL vec3(.8, .601, .365)\n#define MAT_COL1_SPEC vec3(.728, .242, 0.)\n#define MAT_COL4_COL vec3(0.835,0.773,0.584)\n#define MAT_COL4_SPEC vec3(.026, .295, 0.)\n#define MAT_COL3_COL vec3(.598, .855, .393)\n#define MAT_COL3_SPEC vec3(.57, .391, 0.)\n#define MAT_COL0_COL vec3(.711, .221, .017)\n#define MAT_COL0_SPEC vec3(.14, .119, 0.)\n#define MAT_COL2_COL vec3(.115, .093, .064)\n#define MAT_COL2_SPEC vec3(0., .172, 0.)\n\n#define AMB_COL vec3(.615, .615, .615)\n#define AMB_STRENGTH .14\n#define FOG_COL vec3(.22, .178, .081)\n#define FOG_START .0\n#define FOG_POW 1.0\n\n// \"hash11()\"\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p){\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\n\n\nfloat vmax(vec3 v){\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat sdPlane(in vec3 p){\n\treturn p.y;\n}\n\nfloat sdSphere(in vec3 p, float r){\n    return length(p)-r;\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r){\n\tfloat k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCapsule(vec3 p, float r, float c){\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\nfloat sdTorus( vec3 p, vec2 t ){\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nfloat sdBox(vec3 p,vec3 b){\n\tvec3 d=abs(p)-b;\n\treturn length(max(d,vec3(0)))+vmax(min(d,vec3(0.0)));\n}\n\nfloat fOpUnion(in float a,in float b){\n\treturn a<b?a:b;\n}\n\nvec4 v4OpUnion(in vec4 a,in vec4 b){\n\treturn a.x<b.x?a:b;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r){\n\tr*=1.35;\n\tfloat h = max( r-abs(a-b), 0.0 )/r;\n    return min( a, b ) - h*h*h*r*(1.0/6.0);\n}\n\nvec4 v4OpUnionSmooth(vec4 a,vec4 b,float r){\n\tfloat h=clamp(0.5+0.5*(b.x-a.x)/r,0.0,1.0);\n\tfloat res = mix(b.x,a.x,h)-r*h*(1.0-h);\n\treturn vec4(res, mix(b.yzw,a.yzw,h));\n}\n\n// Custom Boolean Example: UnionSink\nfloat fOpUnionSink(float a, float b, float r, float n) {\n\tvec2 p = vec2(a, b);\n\tfloat rad = r*sqrt(2.)/(2.+sqrt(2.));\n\tp.x -= sqrt(2.)/2.*r;\n\tp.x += rad*sqrt(2.0);\n\tp.y -= rad;\n\tfloat d = length(p+vec2(0,n)) - rad;\n\td = fOpUnionSmooth(d, b, p.x);\n\td = min(d, a);\n\treturn d;\n}\n\nvec4 v4OpUnionSink(vec4 a, vec4 b, float r, float n) {\n\tvec2 p = vec2(a.x, b.x);\n\tfloat rad = r*sqrt(2.)/(2.+sqrt(2.));\n\tp.x -= sqrt(2.)/2.*r;\n\tp.x += rad*sqrt(2.0);\n\tp.y -= rad;\n\tfloat d = length(p+vec2(0,n)) - rad;\n\td = fOpUnionSmooth(d, b.x, p.x);\n\td = min(d, a.x);\n\treturn vec4(d, (d==a.x)?a.yzw:b.yzw);\n}\n\n// Phong specular\nfloat normalizedPhong(float shininess, vec3 n, vec3 vd, vec3 ld){\n\tfloat norm_factor = (shininess+1.) / (2.*PI);\n\tvec3 reflect_light = normalize(reflect(ld, n));\n\treturn pow(max(dot(-vd, reflect_light), 0.), shininess) * norm_factor;\n}\nfloat normalizedPhongRef(float shininess, vec3 n, vec3 vd, vec3 ld){\n\treturn 1.-normalizedPhong(shininess, n, vd, ld);\n}\n\n// https://hanecci.hatenadiary.org/entry/20130505/p2\n// http://www.project-asura.com/program/d3d11/d3d11_006.html\nfloat normalizedBlinnPhong(float shininess, vec3 n, vec3 vd, vec3 ld){\n\tfloat norm_factor = (shininess+1.) / (2.*PI);\n\tvec3 h  = normalize(-vd+ld);\n\treturn pow(max(0., dot(h, n)), shininess) * norm_factor;\n}\nfloat BlinnPhongRef(float shininess, vec3 n, vec3 vd, vec3 ld){\n\tvec3 h  = normalize(-vd+ld);\n\treturn 1.-pow(max(0., dot(h, n)), shininess);\n}\n\n// https://www.shadertoy.com/view/wljSz1\n// http://filmicworlds.com/blog/optimizing-ggx-shaders-with-dotlh/\nfloat G(float dotNV, float k){\n\treturn 1.0/(dotNV*(1.0-k)+k);\n}\nfloat ggx(vec3 N, vec3 V, vec3 L, float roughness, float F0){\n\tfloat alpha = roughness*roughness;\n\n\tvec3 H = normalize(V+L);\n\n\tfloat dotNL = clamp(dot(N,L),0.,1.);\n\tfloat dotNV = clamp(dot(N,V),0.,1.);\n\tfloat dotNH = clamp(dot(N,H),0.,1.);\n\tfloat dotLH = clamp(dot(L,H),0.,1.);\n\n\tfloat F, D, vis;\n\n\tfloat alphaSqr = alpha*alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr/(pi * denom * denom);\n\n\tfloat dotLH5 = pow(1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*(dotLH5);\n\n\tfloat k = alpha * 0.5;\n\n\treturn dotNL * D * F * G(dotNL,k)*G(dotNV,k);\n}\n\n// \"Hemispherical SDF AO\" by XT95:\n// https://www.shadertoy.com/view/4sdGWN\nvec3 randomSphereDir(vec2 rnd){\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i){\n\tvec3 v = randomSphereDir( vec2(hash11(i+1.), hash11(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}