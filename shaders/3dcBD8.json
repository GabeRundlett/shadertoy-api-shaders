{
    "Shader": {
        "info": {
            "date": "1604911911",
            "description": "WIP.    Porting [url] https://henryseg.github.io/cohomology_fractals/[/url]\n\nDon't assume I understand anything :-)\nCan't recover correct parameters for now to reproduce the nice demo.",
            "flags": 0,
            "hasliked": 0,
            "id": "3dcBD8",
            "likes": 9,
            "name": "cohomology fractals",
            "published": 3,
            "tags": [
                "fractals",
                "cohomology"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 370
        },
        "renderpass": [
            {
                "code": "// https://henryseg.github.io/cohomology_fractals/\n// https://github.com/henryseg/cohomology_fractals/blob/master/shaders/fragment.glsl\n\n\n// --- trying to translate Uniform data from json presets\n// data entry \"m004\" in https://raw.githubusercontent.com/henryseg/cohomology_fractals/master/data/cohomology_data_SV_cool.json\n// for arrays. chance tuning for other parameters\n\n#define zoomFactor exp2(3.*sin(.3*iTime))\n\nfloat          fov = 1.4, // no effect ?\n    //  zoomFactor = 1.,\n    clippingRadius = 4.,\n    liftsThickness = .1,\n     currentWeight = 13.,\n           maxDist = 100.,\n     edgeThickness = 1e-3,\n          contrast = 2.;\n\nint         tetNum = 0,\n          maxSteps = 100,\n     subpixelCount = 1,  // AA\n   perspectiveType = 1,  // 0,1\n          viewMode = 0,  // 0,1,2\n   multiScreenShot = 0;\n\nmat4  currentBoost = mat4(1); // no effect ?\nbool    normalised = true;\n\n vec2 tile = vec2(1),   // no effect ?\n  numTiles = vec2(10);  // no effect ?\n\n#define N 8  \nvec4 planes[N] =    vec4[N] ( vec4( 0.866025403784438, 0.500000000000001, -0.866025403784438, 0.866025403784438), \n                              vec4( 0.8660254037844386, 0.5000000000000001, 0.8660254037844386, 0.8660254037844386), \n                              vec4( -0.8660254037844394, 0.4999999999999991, 0.0, 0.0), \n                              vec4( 0.0, -1.0, 0.0, 0.0), \n                              vec4( 0.8660254037844387, 0.5, -0.8660254037844387, 0.8660254037844387), \n                              vec4( 0.8660254037844387, 0.5, 0.8660254037844387, 0.8660254037844387), \n                              vec4( -0.8660254037844387, 0.49999999999999994, 0.0, 0.0), \n                              vec4(0.0, -1.0, 0.0, 0.0)\n                            );\nint otherTetNums[N]       = int[N] (1, 1, 1, 1, 0, 0, 0, 0);\nint entering_face_nums[N] = int[N] (0, 2, 1, 3, 0, 2, 1, 3); \nfloat weights[N]        = float[N] (0.0, -0.5, 0.0, -0.5, 0.0, 0.0, 0.5, 0.5); // ???\nmat4 SO31tsfms[N] = mat4[N] ( mat4( -0.9999999999999999, -9.436895709313829e-16, 1.5, 1.5, 9.436895709313829e-16, -0.9999999999999999, 0.8660254037844382, 0.8660254037844382, 1.4999999999999987, 0.8660254037844393, -0.4999999999999994, -1.499999999999999, -1.4999999999999987, -0.8660254037844393, 1.4999999999999998, 2.499999999999999), \n                              mat4( 1.0, 2.2204460492503104e-16, 0.4999999999999995, -0.4999999999999995, 2.2204460492503104e-16, -1.0, -0.8660254037844396, 0.8660254037844396, 0.49999999999999867, 0.8660254037844386, -0.5000000000000001, -0.49999999999999856, -0.49999999999999867, -0.8660254037844386, -0.5000000000000011, 1.4999999999999998), \n                              mat4( 2.1094237467877974e-15, -1.7320508075688767, 0.4999999999999991, 1.4999999999999991, 1.3322676295501878e-15, -0.9999999999999999, -0.866025403784439, 0.866025403784439, 0.9999999999999999, 1.3322676295501878e-15, 1.1102230246251565e-16, -1.1102230246251565e-16, 2.1094237467877974e-15, -1.7320508075688767, -1.3322676295501878e-15, 1.9999999999999996), \n                              mat4( -1.0, 0.0, 1.0, 1.0, 0.0, -1.0, 0.0, 0.0, 1.0, 0.0, 0.5, -0.5, -1.0, 0.0, 0.5, 1.5), \n                              mat4( -1.0, 1.0547118733938985e-15, 1.4999999999999987, 1.4999999999999987, -1.0547118733938985e-15, -1.0, 0.866025403784439, 0.866025403784439, 1.5000000000000002, 0.866025403784438, -0.499999999999999, -1.4999999999999996, -1.5000000000000002, -0.866025403784438, 1.4999999999999984, 2.499999999999999), \n                              mat4( 1.8873791418627653e-15, 1.2212453270876718e-15, 0.9999999999999997, -1.8873791418627653e-15, -1.732050807568877, -0.9999999999999997, 1.2212453270876718e-15, 1.732050807568877, 0.4999999999999987, -0.8660254037844392, 1.1102230246251562e-16, 1.4432899320127031e-15, -1.4999999999999998, -0.8660254037844392, 2.2204460492503123e-16, 2.0), \n                              mat4( 1.0, 1.1102230246251559e-16, 0.4999999999999988, 0.4999999999999988, 1.1102230246251559e-16, -1.0, 0.8660254037844388, 0.8660254037844388, 0.4999999999999995, -0.8660254037844398, -0.5, 0.5000000000000013, 0.4999999999999995, -0.8660254037844398, 0.4999999999999989, 1.5000000000000002), \n                              mat4( -1.0, 0.0, 1.0, 1.0, 0.0, -1.0, 0.0, 0.0, 1.0, 0.0, 0.5, -0.5, -1.0, 0.0, 0.5, 1.5)\n                            );\n\n// data entry \"m004\" from https://raw.githubusercontent.com/henryseg/cohomology_fractals/master/data/cohomology_data_SV_cool.json\n/* \"entering_face_nums\": [0, 2, 1, 3, 0, 2, 1, 3], \n\"flat_geometries\": [\n    [\"(0, 0)\", [\n        [0.866025403784438, 0.500000000000001, -0.866025403784438, 0.866025403784438], \n        [0.8660254037844386, 0.5000000000000001, 0.8660254037844386, 0.8660254037844386], \n        [-0.8660254037844394, 0.4999999999999991, 0.0, 0.0], \n        [0.0, -1.0, 0.0, 0.0], \n        [0.8660254037844387, 0.5, -0.8660254037844387, 0.8660254037844387], \n        [0.8660254037844387, 0.5, 0.8660254037844387, 0.8660254037844387], \n        [-0.8660254037844387, 0.49999999999999994, 0.0, 0.0], \n        [0.0, -1.0, 0.0, 0.0]\n    ], [\n        [-0.9999999999999999, -9.436895709313829e-16, 1.5, 1.5, 9.436895709313829e-16, -0.9999999999999999, 0.8660254037844382, 0.8660254037844382, 1.4999999999999987, 0.8660254037844393, -0.4999999999999994, -1.499999999999999, -1.4999999999999987, -0.8660254037844393, 1.4999999999999998, 2.499999999999999], \n        [1.0, 2.2204460492503104e-16, 0.4999999999999995, -0.4999999999999995, 2.2204460492503104e-16, -1.0, -0.8660254037844396, 0.8660254037844396, 0.49999999999999867, 0.8660254037844386, -0.5000000000000001, -0.49999999999999856, -0.49999999999999867, -0.8660254037844386, -0.5000000000000011, 1.4999999999999998], \n        [2.1094237467877974e-15, -1.7320508075688767, 0.4999999999999991, 1.4999999999999991, 1.3322676295501878e-15, -0.9999999999999999, -0.866025403784439, 0.866025403784439, 0.9999999999999999, 1.3322676295501878e-15, 1.1102230246251565e-16, -1.1102230246251565e-16, 2.1094237467877974e-15, -1.7320508075688767, -1.3322676295501878e-15, 1.9999999999999996], \n        [-1.0, 0.0, 1.0, 1.0, 0.0, -1.0, 0.0, 0.0, 1.0, 0.0, 0.5, -0.5, -1.0, 0.0, 0.5, 1.5], \n        [-1.0, 1.0547118733938985e-15, 1.4999999999999987, 1.4999999999999987, -1.0547118733938985e-15, -1.0, 0.866025403784439, 0.866025403784439, 1.5000000000000002, 0.866025403784438, -0.499999999999999, -1.4999999999999996, -1.5000000000000002, -0.866025403784438, 1.4999999999999984, 2.499999999999999], \n        [1.8873791418627653e-15, 1.2212453270876718e-15, 0.9999999999999997, -1.8873791418627653e-15, -1.732050807568877, -0.9999999999999997, 1.2212453270876718e-15, 1.732050807568877, 0.4999999999999987, -0.8660254037844392, 1.1102230246251562e-16, 1.4432899320127031e-15, -1.4999999999999998, -0.8660254037844392, 2.2204460492503123e-16, 2.0], \n        [1.0, 1.1102230246251559e-16, 0.4999999999999988, 0.4999999999999988, 1.1102230246251559e-16, -1.0, 0.8660254037844388, 0.8660254037844388, 0.4999999999999995, -0.8660254037844398, -0.5, 0.5000000000000013, 0.4999999999999995, -0.8660254037844398, 0.4999999999999989, 1.5000000000000002], \n        [-1.0, 0.0, 1.0, 1.0, 0.0, -1.0, 0.0, 0.0, 1.0, 0.0, 0.5, -0.5, -1.0, 0.0, 0.5, 1.5]\n]]], \n??? \"flat_cohom_classes\": [[ [-1, 0, -1, 0], \n                             [0.0, -0.5, 0.0, -0.5, 0.0, 0.0, 0.5, 0.5] ]], \n\"other_tet_nums\": [1, 1, 1, 1, 0, 0, 0, 0]\n*/\n\nfloat gradientThreshholds[5] = float[5] ( .1,.3,.6,.8, .9 );\n   const vec3 C = vec3(1,0,0);      // green red  black  blue  white\n   vec3 gradientColours[5] = vec3[5] ( C.yxz, C, C.zzz, C.yzx, C.xxx );\n// #define C(p) pow( .8*vec3(.6,.8,1), vec3(p) )\n// vec3 gradientColours[5] = vec3[5] ( C(0), C(1), C(2), C(3), C(4) );\n\n// --------------------------------------------------------------------\n\n\n\n// inf             1\n//   v0 -------- v2\n//    | `.    .' |\n//    |   `. '   |\n//    |   . `.   |\n//    | .'    `. |\n//   v3 -------- v1\n// z               0\n\nfloat R31_dot(vec4 u, vec4 v){\n  return u.x*v.x + u.y*v.y + u.z*v.z - u.w*v.w; // Lorentz Dot\n}\n\nfloat R31_norm_inv(vec4 v){\n  return inversesqrt(abs(R31_dot(v,v)));\n}\n\nvec4 R31_normalise(vec4 v){\n  return v*R31_norm_inv(v);\n}\n\nfloat geodesicParameterPlanes(vec4 samplePoint, vec4 dualPoint1, vec4 dualPoint2){\n  // \"distance\" from a geodesic defined by two (assumed perpendicular) geodesic planes, this is not quite distance, need to asinh(sqrt( result ))\n  float dot1 = -R31_dot(samplePoint, dualPoint1);\n  vec4 dualPointPerp = R31_normalise(dualPoint2 - R31_dot(dualPoint1, dualPoint2) * dualPoint1); // should be precalculated if this is a main feature\n  float dot2 = -R31_dot(samplePoint, dualPointPerp);\n  // float dot3 = -R31_dot(dualPoint1, dualPoint2);\n  return dot1*dot1 + dot2*dot2;\n  // return dot1*dot1 * (1.0 + dot3*dot3) + dot2*dot2 + 2.0*dot1*dot2*dot3;\n}\n\nfloat triangleBdryParam(vec4 samplePoint, int tetNum, int exit_face){\n  vec4 exit_dual_point = planes[4*tetNum + exit_face];\n  float smallest_p = 100000000.0;\n  for(int face=0; face<4; face++){\n      if(face != exit_face){  // find p when we hit that face\n          int index = 4*tetNum + face;\n          float new_p = geodesicParameterPlanes(samplePoint, exit_dual_point, planes[index]);\n          if(new_p < smallest_p){\n            smallest_p = new_p;\n          }   \n      }\n  }\n  return smallest_p;\n}\n\n/// --- Ray-trace code --- ///\n\n  float hyp_dist(vec4 u, vec4 v){\n    float bUV = -R31_dot(u,v);\n    if (bUV < 1.0) {return 0.0;}\n    else {return acosh(bUV);}  \n  } \n\nfloat param_to_isect_line_with_plane(vec4 line_start, vec4 line_dir, vec4 plane){\n    float denom = R31_dot(plane, line_dir);\n    if(denom == 0.0){ return 200000000.0; }  // bigger than the initial smallest_p value we will accept\n    /// solve: R31_dot(plane, line_start + p * line_dir) = 0\n    ///        R31_dot(plane, line_start) + p * R31_dot(plane, line_dir) = 0\n    return (-R31_dot(plane, line_start)) / denom;\n  }\n\nvec4 ray_trace_through_hyperboloid_tet(vec4 init_pos, vec4 init_dir, int tetNum, int entry_face, out int exit_face){\n    ///Given shape of a tet and a ray, find where the ray exits and through which face\n    float smallest_p = 100000000.0;\n    for(int face=0; face<4; face++){\n        if(face != entry_face){  // find p when we hit that face\n            int index = 4*tetNum + face;\n            if(R31_dot(init_dir, planes[index]) > 0.0){ \n                float p = param_to_isect_line_with_plane(init_pos, init_dir, planes[index]);\n                // if ((-10000.0 <= p) && (p < smallest_p)) {\n                if (p < smallest_p) {  \n                    /// negative values are ok if we have to go backwards a little to get through the face we are a little the wrong side of\n                    /// Although this can apparently get caught in infinite loops in an edge\n\n                    /// if we are on an edge then we don't in fact move as we go through this tet: t = 0.0\n                    /// also allow tiny negative values, which will come up from floating point errors. \n                    /// surface normals check should ensure that even in this case we make progress through \n                    /// the triangles around an edge\n                    smallest_p = p;\n                    exit_face = face;\n                }\n            }\n        }\n    }\n    return R31_normalise( init_pos + smallest_p * init_dir );\n}\n\nfloat ray_trace(vec4 init_pt, vec4 init_dir, float dist_to_go, int tetNum, float inputWeight){\n    int return_type = 0;\n    if(viewMode == 0){ return_type = 0; } // total_face_weight\n    else if(viewMode == 1){ return_type = 1; } // distance\n    else if(viewMode == 2){ return_type = 2; } // tet number\n    int entry_face = -1;   /// starts off with no entry face\n    int exit_face = -1;\n    float total_face_weight = inputWeight;\n    vec4 new_pt;\n    int index;\n    mat4 tsfm;\n    vec4 new_dir;\n    for(int i=0; i<maxSteps; i++){\n      new_pt = ray_trace_through_hyperboloid_tet(init_pt, init_dir, tetNum, entry_face, exit_face);\n      dist_to_go -= hyp_dist(init_pt, new_pt);\n      if (dist_to_go <= 0.0){ dist_to_go = 0.0; break; }\n      if(edgeThickness > 0.00001){\n        if(triangleBdryParam(new_pt, tetNum, exit_face) < edgeThickness){ break; }}\n        // in fact pow(sinh(radius in hyperbolic units),2.0). However, sinh^2 is monotonic for \n        // positive values so we get correct behaviour by comparing without the sinh^2. \n      index = 4*tetNum + exit_face;\n      total_face_weight += weights[ index ]; \n      if(liftsThickness > 0.0){  // here we detect and draw elevations\n        if( ( total_face_weight <= liftsThickness && liftsThickness < inputWeight ) || // see elevations from behind\n                  ( inputWeight < 0.0001          &&         0.0001 < total_face_weight ) ||  // see elevations from in front // cannot make this too close to 0.0 or we get floating point issues from different sums of weights\n            ( 0.0001 < inputWeight && inputWeight <= liftsThickness && inputWeight != total_face_weight) // see elevations from in between\n                  ) { \n          return_type = 1; \n          break; \n        } \n      }             \n      entry_face = entering_face_nums[ index ];\n      tsfm = SO31tsfms[ index ];\n      tetNum = otherTetNums[ index ];\n\n      new_dir = init_dir + R31_dot(init_dir, new_pt) * new_pt; // orthonormal decomp, no normalisation yet\n      init_pt = new_pt * tsfm;  \n      init_dir = R31_normalise( new_dir * tsfm ); \n    }\n    if(return_type == 0){ return total_face_weight; } // Cohomology\n    else if(return_type == 1){ return 0.5*maxDist - dist_to_go; } // Colour by Distance\n    else { return float(tetNum);} // Colour by tetrahedron number\n}\n\n/// --- Graph-trace code --- ///\n\nfloat amountOutsideTetrahedron(vec4 v, int tetNum, out int biggest_face) {\n  float biggest_amount = -100000.0;\n  float amount;\n  for(int i = 0; i < 4; i++){\n    amount = R31_dot( v, planes[4*tetNum + i] );\n    if( amount > biggest_amount ){\n      biggest_amount = amount;\n      biggest_face = i;\n    }\n  }\n  return biggest_amount; \n}\n\nvec4 pointOnGeodesic(vec4 pos, vec4 dir, float dist){\n  return pos*cosh(dist) + dir*sinh(dist);\n}\n\nvec4 tangentOnGeodesic(vec4 pos, vec4 dir, float dist){\n  return pos*sinh(dist) + dir*cosh(dist);\n}\n\nfloat graph_trace(inout vec4 goal_pt, inout int tetNum, out mat4 tsfm){ // tsfm is matrix to send goal_pt to its image in the tetrahedron coordinates it is in\n  // similar function to ray_trace, but different algorithm\n  float total_face_weight = 0.0;\n  int entry_face = -1;\n  int index;\n  int biggest_face;\n  tsfm = mat4(1.0);\n  for(int i=0; i<maxSteps; i++){\n      if ( amountOutsideTetrahedron(goal_pt, tetNum, biggest_face) > 0.0 && biggest_face != entry_face ){ //0.0000001\n        index = 4*tetNum + biggest_face;\n        entry_face = entering_face_nums[ index ];\n        tetNum = otherTetNums[ index ];\n        // if(viewMode == 2) { total_face_weight += abs(weights[ index ]); } // translucent surface: all weights positive\n        // else { \n        total_face_weight += weights[ index ]; \n        goal_pt *= SO31tsfms[ index ];\n        tsfm *= SO31tsfms[ index ];\n        // if (R31_dot(goal_pt, goal_pt) > -0.5){ return -1000.0; } // errors accumulate and we get junk!\n      }\n      else{ break; }\n    }\n    return total_face_weight;\n  }\n\n/// --- Colour gradient code --- ///\n\nint find_band(float t, float threshholds[5]){\n    for(int j=1;j<4;j++){\n        if(t < threshholds[j]){return j;}\n    }\n    return 4;\n}\nvec4 general_gradient(float t, float threshholds[5], vec3 colours[5]){\n    int i = find_band(t, threshholds);\n    return vec4( mix(colours[i-1], colours[i],(t - threshholds[i-1])/(threshholds[i] - threshholds[i-1]) ), 1.0);\n}\n\n/// --- Ray init pt and directions code --- ///\n\nvec4 get_ray_pos_dir_material(vec2 xy, out vec4 ray_dir){ \n    float z = 0.5/tan(radians(fov*0.5));\n    ray_dir = R31_normalise(vec4(xy,-z,0.0));\n    return vec4(0.0,0.0,0.0,1.0);\n}\n\nvec4 get_ray_pos_dir_ideal(vec2 xy, out vec4 ray_dir){ \n    float foo = 0.5*dot(xy, xy);\n    vec4 ray_pt = vec4(xy, foo, foo + 1.0);   // parabolic transformation magic by Saul\n    ray_dir = vec4(xy, foo - 1.0, foo);\n    return ray_pt;\n}\n\nvec4 get_ray_pos_dir_hyperideal(vec2 xy, out vec4 ray_dir, out bool background){ \n    vec4 ray_pt = R31_normalise(vec4(2.0 * xy,0.0,1.0));\n    if (R31_dot(ray_pt, ray_pt) < 0.0){\n      ray_dir = vec4(0.0,0.0,-1.0,0.0);\n      background = false;\n    }\n    else{\n      ray_dir = vec4(0.0,0.0,0.0,0.0);\n      ray_pt = vec4(0.0,0.0,0.0,1.0);  // avoid jank\n      background = true;\n    }\n    return ray_pt;\n}\n\n//new_dir = init_dir + R31_dot(init_dir, new_pt) * new_pt;\n\nfloat get_signed_count(vec2 xy){\n  vec4 init_pt;\n  vec4 init_dir;\n  float weight = 0.0;\n  bool background = false;\n  mat4 tsfm = mat4(1.0);\n  int currentTetNum = tetNum;  // gets modified inside graph_trace\n  if(perspectiveType == 0){ init_pt = get_ray_pos_dir_material(xy, init_dir); }\n  else if(perspectiveType == 1){ init_pt = get_ray_pos_dir_ideal(xy, init_dir); }\n  else{ init_pt = get_ray_pos_dir_hyperideal(xy, init_dir, background); }\n  init_pt *= currentBoost;\n  init_dir *= currentBoost; \n  vec4 new_init_pt = pointOnGeodesic(init_pt, init_dir, clippingRadius);\n  init_dir = tangentOnGeodesic(init_pt, init_dir, clippingRadius);\n  init_pt = new_init_pt;\n  weight = graph_trace(init_pt, currentTetNum, tsfm);  // get us to the tetrahedron containing init_pt. \n  // init_pt *= tsfm;  // the point gets moved back in graph_trace\n  init_dir *= tsfm;  // move the direction back to here\n  if (background){ return 0.0; }\n  else{ return ray_trace(init_pt, init_dir, maxDist, currentTetNum, currentWeight + weight); }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 xy = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n  xy *= zoomFactor;\n  if(multiScreenShot == 1){  // Return multiple 4096x4096 screenshots that can be combined in, e.g. Photoshop.\n    // Here screenResolution is really tileResolution;\n    xy = (xy + tile - 0.5*(numTiles - vec2(1.0,1.0))) / numTiles.x;\n  }\n\n  float total_weight = 0.0;\n  for(int i=0; i<subpixelCount; i++){\n    for(int j=0; j<subpixelCount; j++){\n      vec2 offset = ( (float(1+2*i), float(1+2*j))/float(2*subpixelCount) - vec2(0.5,0.5) ) / iResolution.x;\n      total_weight += get_signed_count(xy + offset);\n    }\n  }\n  float weight = total_weight/float(subpixelCount*subpixelCount); // average over all subpixels\n\n  if(normalised){ weight /= sqrt(maxDist); }\n\n  weight = contrast * weight;\n\n\n  // linear\n  // float minW = -31.75;\n  // float maxW = 32.25;\n\n  // float minW = -63.75;\n  // float maxW = 64.25;\n\n  // float minW = -127.75;\n  // float maxW = 128.25;\n\n  // weight = (weight - minW)/(maxW - minW);\n\n  // arctan\n  // weight = 0.5 + atan(0.3 * weight)/PI;  // between 0.0 and 1.0\n  \n  // faster than atan, similar\n  weight = 0.5 + 0.5*weight/(abs(weight) + 1.0);  \n  \n  fragColor = general_gradient(weight, gradientThreshholds, gradientColours);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}