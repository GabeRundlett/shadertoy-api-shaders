{
    "Shader": {
        "info": {
            "date": "1617748258",
            "description": "Binet formula for Fibonacci numbers interpreted on the complex plane. Uses Newton-Raphson to solve binet(z) = w. Use mouse to select starting point.",
            "flags": 0,
            "hasliked": 0,
            "id": "tlKBWd",
            "likes": 27,
            "name": "Complex​ Fibonacci",
            "published": 3,
            "tags": [
                "complex",
                "fibonacci",
                "newtonraphson"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 691
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Complex Fibonacci, Matthew Arcus, mla, 2021\n//\n// Simply by interpreting the Binet formula, fib(n) = (φⁿ - -φ⁻ⁿ)/√5 for a\n// complex parameter, we can extend the Fibonacci function to the complex plane.\n// As usual, to show this with domain colouring, we require the inverse function,\n// ie. given complex w, find z such that fib(z) = w. There doesn't seem to be a simple\n// analytic inverse, but we can find the inverse by solving fib(z)-w = 0\n// for z using Newton-Raphson. In fact, the inverse Binet function is multivalued\n// and which value we get depends critically on the starting value - and sometimes\n// we don't converge at all. The starting point z0 is set by the mouse or\n// automatically on the x+2i line.\n//\n// Grid lines for the z-plane are shown, together with the real and imaginary axes\n// (and integer points) for the w-plane. The thicker dark line is the real axis\n// in the z-plane - for z >= 0, it passes through w = 0,1(twice),2,3,5 etc. and\n// for negative z, -1,2,-3 etc.\n//\n// https://matthewarcus.wordpress.com/2012/12/22/complex-fibonacci/\n// https://www.youtube.com/watch?v=ghxQA3vvhsk\n//\n////////////////////////////////////////////////////////////////////////////////\n\n\nfloat PHI = 1.6180334;\nfloat LOGPHI = 0.481211825;\nfloat ISQRT5 = 0.447213595;\n\n// The Binet formula for fib(z)\nvec2 binet(vec2 z) {\n  return ISQRT5*(cexp(PHI,z) - cexp(-PHI,-z));\n}\n\n// Exact derivative\nvec2 dbinet(vec2 z) {\n  return ISQRT5*(LOGPHI*cexp(PHI,z) + cmul(vec2(LOGPHI,PI),cexp(-PHI,-z)));\n}\n\nvec2 dbinet0(vec2 z) {\n  // Sanity check - numeric derivative\n  float eps = 0.001;\n  return (binet(z+vec2(eps,0))-binet(z-vec2(eps,0)))/(2.0*eps);\n}\n\n// Solve: binet(z)-w = 0 with Newton-Raphson, initial guess z0\nvec2 fib(vec2 w, vec2 z0) {\n  vec2 z = z0;\n  for (int i = 0; i < 10; i++) {\n    vec2 offset = cdiv(binet(z)-w,dbinet(z));\n    z -= offset;\n    if (dot(offset,offset) < 1e-6) break;\n  }\n  return z;\n}\n\nvec3 palette(float t) {\n  // iq's excellent palette technique\n  float a = 0.4, b = 0.6, c = 1.0;\n  vec3 d = vec3(0,0.333,0.666);\n  return a+b*cos(2.0*PI*(c*t+d));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  float scale = 3.0;\n  // Initial value of x+2i gives nice results\n  vec2 z0 = vec2(4.7*sin(0.5*PI*0.125*iTime),2);\n  vec2 w = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  w *= scale;\n  if (iMouse.z > 0.0) {\n    // Initial value is at mouse position\n    z0 = scale*(2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  }\n  vec2 z = fib(w,z0);\n\n  vec3 color = palette(atan(z.y));\n  \n  // Draw grid lines etc.\n  float linedist;\n  float pfactor = 0.8*fwidth(z.x);\n  vec2 edges = fract(10.0*z);\n  edges = min(edges,1.0-edges);\n  linedist = min(edges.x,edges.y);\n  linedist /= 10.0;\n  color = mix(vec3(0),color,0.6+0.4*smoothstep(0.0025,max(0.005,pfactor),linedist)); // w grid\n  float mdist = min(abs(w.x),abs(w.y));\n  color = mix(vec3(0.8),color,0.5+0.5*smoothstep(0.0,0.03,mdist)); // z grid\n  float pdist = min(distance(abs(w),vec2(round(abs(w.x)),0)),\n                    distance(abs(w),vec2(0,round(abs(w.y)))));\n  color = mix(vec3(0.8),color,0.5+0.5*smoothstep(0.03,0.05,pdist)); // Points\n  linedist = abs(z.y);\n  color = mix(vec3(0),color,0.5+0.5*smoothstep(0.01,max(0.02,pfactor),linedist)); // Real axis\n  color *= sqrt(texture(iChannel0,0.5*w/scale).xyz);\n  color = pow(color,vec3(0.4545));\n  fragColor = vec4(color,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n// common\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n\nvec2 rotate(vec2 p, float t) {\n  vec2 r = vec2(cos(-t),sin(-t));\n  r = normalize(r);\n  return p * r.x + vec2(p.y, -p.x) * r.y;\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n  return z.x*w + vec2(-z.y,z.y)*w.yx;\n}\n\nvec2 cinv(vec2 z) {\n  float t = dot(z,z);\n  return vec2(z.x,-z.y)/t;\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n  return cmul(z,cinv(w));\n}\n\nvec2 clog(vec2 z) {\n  float r2 = dot(z,z);\n  return vec2(0.5*log(r2),atan(z.y,z.x));\n}\n\nvec2 clog(float x) {\n  return clog(vec2(x,0));\n}\n\nvec2 cexp(vec2 z) {\n  // If cos and sin were perfect we wouldn't need normalize\n  return exp(z.x)*normalize(vec2(cos(z.y),sin(z.y)));\n}\n\nvec2 cexp(float k, vec2 z) {\n  // return k^z\n  return cexp(cmul(clog(k),z));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}