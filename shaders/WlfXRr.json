{
    "Shader": {
        "info": {
            "date": "1562355096",
            "description": "I updated my stochastic ray tracer and made a cube fractal thing out of it. I like to think I have much better random numbers and better/working refraction in this version. Also a depth of field hack that's probably not very accurate. :)",
            "flags": 32,
            "hasliked": 0,
            "id": "WlfXRr",
            "likes": 29,
            "name": "Quantum Dream",
            "published": 3,
            "tags": [
                "raytrace",
                "stochastic"
            ],
            "usePreview": 1,
            "username": "otaviogood",
            "viewed": 1530
        },
        "renderpass": [
            {
                "code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^This means do anything you want with this code. Because we are programmers, not lawyers.\n\nThis is the latest iteration of my stochastic ray tracer.\nFor materials, it supports:\n- Proper reflection / refraction, with total internal reflection.\n- Filtered light rays like in the red glass.\n- Gold has rgb reflectance.\n- Emission.\n- Diffuse / specular.\n- Sub surface scattering, like in water.\n- Scattering in air or whereever for fog.\n\n- Support for ray traced and ray marched geometry in the same scene.\n- Antialiasing.\n- Depth of field\n\nRandom number generation and hashes were cleaned up and now feel pretty good.\n\n-Otavio Good\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tvec4 c=texture(iChannel0,uv);\n\tfragColor=vec4(sqrt((c.xyz*4096.0) / c.w), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^This means do anything you want with this code. Because we are programmers, not lawyers.\n\nThis is the latest iteration of my stochastic ray tracer.\nFor materials, it supports:\n- Proper reflection / refraction, with total internal reflection.\n- Filtered light rays like in the red glass.\n- Gold has rgb reflectance.\n- Emission.\n- Diffuse / specular.\n- Sub surface scattering, like in water.\n- Scattering in air or whereever for fog.\n\n- Support for ray traced and ray marched geometry in the same scene.\n- Antialiasing.\n- Depth of field\n\nRandom number generation and hashes were cleaned up and now feel pretty good.\n\n-Otavio Good\n*/\n\n// **** Set this to 3 for max detail (but also slow). ****\n// I'll set it smaller by default for people with slow GPUs.\n#define FRACTAL_RECURSIONS 2\n\n// Number of samples per pixel - bigger takes more compute\n#define NUM_SAMPLES 1\n// Number of times the ray bounces off things before terminating\n#define NUM_ITERS 7\n\n// ---- general helper functions / constants ----\n#define saturate(a) clamp(a, 0.0, 1.0)\n// Weird for loop trick so compiler doesn't unroll loop\n// By making the zero a variable instead of a constant, the compiler can't unroll the loop and\n// that speeds up compile times by a lot.\n#define ZERO_TRICK max(0, -iFrame)\nconst int BIG_INT = 2000000000;\nconst float PI = 3.14159265;\nconst float farPlane = 64.0;\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n// Find 2 perpendicular vectors to the input vector.\nmat3 MakeBasis(vec3 normal) {\n\tmat3 result;\n    result[0] = normal;\n    if (abs(normal.y) > 0.5) {\n        result[1] = normalize(cross(normal, vec3(1.0, 0.0, 0.0)));\n    } else {\n        result[1] = normalize(cross(normal, vec3(0.0, 1.0, 0.0)));\n    }\n    result[2] = normalize(cross(normal, result[1]));\n    return result;\n}\n\n\n// ---- Hash functions and random number generation ----\n// Random 32 bit primes from this site: https://asecuritysite.com/encryption/random3?val=32\n// This is the single state variable for the random number generator.\nuint randomState = 4056649889u;\n\n// 2 simple hash functions - for extra randomness, call them both\nuint SmallHashIA(uint seed) {\n    return (seed ^ 1057926937u) * 3812423987u;\n}\nuint SmallHashIB(uint seed) {\n    return (seed ^ 2156034509u) * 808515863u;\n}\n\n// Returns a random float from [0..1]\nfloat Hashf1(uint seed) {\n    seed = SmallHashIA(seed);\n    // 0xffffff is biggest 2^n-1 that 32 bit float does exactly.\n    // Check with Math.fround(0xffffff) in javascript.\n    return float(seed & 0xffffffu) / float(0xffffff);\n}\n// Reduced precision to 10 bits per component.\nvec3 Hashf3(uint seed) {\n    seed = SmallHashIA(seed);\n    return vec3((seed >> 2) & 0x3ffu,\n                (seed >> 12) & 0x3ffu,\n                seed >> 22) / float(0x3ffu);\n}\n\n// Combine random state with hash function to get a random float [0..1]\nfloat Randf1() {\n    randomState = SmallHashIA(randomState) >> 7;\n    randomState = SmallHashIB(randomState);\n    // 0xffffff is biggest 2^n-1 that 32 bit float does exactly.\n    // Check with Math.fround(0xffffff) in javascript.\n    return float(randomState & 0xffffffu) / float(0xffffff);\n}\n// Reduced precision to 16 bits per component.\nvec2 Randf2() {\n    randomState = SmallHashIA(randomState) >> 7;\n    randomState = SmallHashIB(randomState);\n    return vec2(randomState & 0xffffu,\n                randomState >> 16) / float(0xffff);\n}\n// Reduced precision to 10 bits per component.\nvec3 Randf3() {\n    randomState = SmallHashIA(randomState) >> 7;\n    randomState = SmallHashIB(randomState);\n    return vec3((randomState >> 2) & 0x3ffu,\n                (randomState >> 12) & 0x3ffu,\n                randomState >> 22) / float(0x3ffu);\n}\n\n// Set a unique (hopefully) random seed for each pixel and time.\n// Call like this: SetRandomSeed(uint(fragCoord.x), uint(fragCoord.y), uint(iFrame));\nvoid SetRandomSeed(uint a, uint b, uint c) {\n    randomState = SmallHashIA(a)>>7;\n    randomState ^= SmallHashIB(b * 3435263017u);\n    randomState += c * 7u;\n}\n\n// Returns random number sampled from a circular gaussian distribution\n// https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform\nvec2 RandGaussianCircle() {\n    vec2 u = Randf2();\n    u.x = max(u.x, 0.00000003); // We don't want log() to fail because it's 0.\n    float a = sqrt(-2.0 * log(u.x));\n    return vec2(a * cos(2.0*PI*u.y), a * sin(2.0 * PI * u.y));\n}\n// Randomly sample the lifetime of a ray moving through particles\n// p = prob. of collision with particle per unit distance traveled\nfloat RayLifetime(float p) {\n    if (p < 0.00000003) return farPlane;  // Lower than this and the math seems to fail.\n    float unif = Randf1();  // uniform(0, 1)\n    // This random shouldn't be allowed to hit 0 because log() is undefined.\n    unif = max(0.00000000000001, unif);\n    // p can't be 0 because log(1) == 0 and it divides by 0. Can't be 1 because log(0) is undefined.\n    p = min(p, .999999);\n    //float g = math.floor(math.log(unif) / math.log(1 - p))  # natural logs\n    // g = number of successes before failure\n    float g = log(unif) / log(1.0 - p);\n    return g;\n}\n\n// Random point *ON* sphere\nvec3 RandPointOnSphere() {\n    vec2 uv = Randf2();\n    float theta = 2.0 * PI * uv.x;\n    float psi = acos(2.0 * uv.y - 1.0);\n    float x = cos(theta) * sin(psi);\n    float y = sin(theta) * sin(psi);\n    float z = cos(psi);\n    return vec3(x, y, z);\n}\n// Random point *IN* sphere\n// This is biased!!! About 1/32 of the time, it will return a point in box instead of a sphere.\n/*vec3 RandPointInSphere() {\n    return RandPointOnSphere();\n    vec3 p = Randf3i1(seed) * 2.0 - 1.0;\n    if (length(p) <= 1.0) return p;\n    p = Randf3i1(seed) * 2.0 - 1.0;\n    if (length(p) <= 1.0) return p;\n    p = Randf3i1(seed) * 2.0 - 1.0;\n    if (length(p) <= 1.0) return p;\n    p = Randf3i1(seed) * 2.0 - 1.0;\n    if (length(p) <= 1.0) return p;\n    p = Randf3i1(seed) * 2.0 - 1.0;\n    if (length(p) <= 1.0) return p;\n    return p;\n}*/\n\n// ---- Environment maps - a few to choose from ----\n// Make a procedural environment map with a giant softbox light and 4 lights around the sides.\nvec3 GetEnvMap3(vec3 rayDir)\n{\n    // fade bottom to top so it looks like the softbox is casting light on a floor\n    // and it's bouncing back\n    vec3 final = vec3(1.0) * dot(rayDir, vec3(0.0, 1.0, 0.0)) * 0.5 + 0.5;\n    final *= 0.125;\n    // overhead softbox, stretched to a rectangle\n    if ((rayDir.y > abs(rayDir.x)*1.0) && (rayDir.y > abs(rayDir.z*0.25))) final = vec3(2.0)*rayDir.y;\n    // fade the softbox at the edges with a rounded rectangle.\n    float roundBox = length(max(abs(rayDir.xz/max(0.0,rayDir.y))-vec2(0.9, 4.0),0.0))-0.1;\n    final += vec3(0.8)* pow(saturate(1.0 - roundBox*0.5), 6.0);\n    // purple lights from side\n    final += vec3(8.0,6.0,7.0) * saturate(0.001/(1.0 - abs(rayDir.x)));\n    // yellow lights from side\n    final += vec3(8.0,7.0,6.0) * saturate(0.001/(1.0 - abs(rayDir.z)));\n    return vec3(final);\n}\n\n// Courtyard environment map texture with extra sky brightness for HDR look.\nvec3 GetEnvMap2(vec3 rayDir) {\n    vec3 tex = texture(iChannel1, rayDir).xyz;\n    tex = tex * tex;  // gamma correct\n    vec3 light = vec3(0.0);\n    // overhead softbox, stretched to a rectangle\n    if ((rayDir.y > abs(rayDir.x+0.6)*0.29) && (rayDir.y > abs(rayDir.z*2.5))) light = vec3(2.0)*rayDir.y;\n    vec3 texp = pow(tex, vec3(14.0));\n    light *= texp;  // Masked into the existing texture's sky\n    return (tex + light*3.0);\n}\n\nvec3 GetEnvMap(vec3 rayDir) {\n    return vec3(0.0);\n    //return vec3(rayDir.y*0.5+0.5);\n}\n\n// ---- Ray intersection functions and data structures ----\nstruct Ray\n{\n    vec3 p0, dirNormalized;\n    int outside;  // 1 ray is outside, -1 ray is inside, 0 terminate ray tracing iteration\n};\nstruct SceneHit\n{\n    vec3 hitPos;\n    vec3 hitNormal;\n    float pt;  // parametric t variable - how far along the ray vector is the intersection\n    int objIndex;  // unique index per object - used for material tricks like hashing colors\n    int materialIndex;  // Which material are we using\n};\n\n// As the ray bounces, it records hits in these vars.\nstruct ColorHit {\n    vec3 diffuse;\n    vec3 emission;\n};\nColorHit colorHits[NUM_ITERS];\nint colorHitIndex;\nvoid ResetColorHitList() {\n    colorHitIndex = 0;\n    for (int i = 0; i < NUM_ITERS; i++) {\n        colorHits[i].emission.x = -1.0;\n    }\n}\nvoid SaveHit(in vec3 diffuse, in vec3 emission) {\n    colorHits[colorHitIndex] = ColorHit(diffuse, emission);\n    colorHitIndex++;\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad)\n{\n    vec3 radialVec = pos - spherePos;\n    float b = dot(radialVec, dirVecPLZNormalizeMeFirst);\n    float c = dot(radialVec, radialVec) - rad * rad;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\n// Return value is normal in xyz, t in w.\n// outside is 1 to intersect from the outside of the sphere, -1 to intersect from inside of sphere.\nvec4 SphereIntersect3(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad, int outside)\n{\n    vec4 rh = vec4(farPlane);\n    vec3 delta = spherePos - pos;\n    float projdist = dot(delta, dirVecPLZNormalizeMeFirst);\n    vec3 proj = dirVecPLZNormalizeMeFirst * projdist;\n    vec3 bv = proj - delta;\n    float b2 = dot(bv, bv);\n    if (b2 > rad*rad) return rh;  // Ray missed the sphere\n    float x = sqrt(rad*rad - b2);\n    rh.w = projdist - (x * float(outside));\n    vec3 hitPos = pos + dirVecPLZNormalizeMeFirst * rh.w;\n    rh.xyz = normalize(hitPos - spherePos);//*float(outside);//??HACK>>>??  // Normal still points outwards if collision from inside.\n    return rh;\n}\n\n// https://tavianator.com/fast-branchless-raybounding-box-intersections/\n// Return value is normal in xyz, t in w.\n// **** rayInv is 1.0 / direction vector ****\nvec4 BoxIntersect(vec3 pos, vec3 rayInv, vec3 boxPos, vec3 rad, int outside)\n{\n    vec3 bmin = boxPos - rad;\n    vec3 bmax = boxPos + rad;\n//    vec3 rayInv = 1.0 / dirVecPLZNormalizeMeFirst;\n\n    vec3 t1 = (bmin - pos) * rayInv;\n    vec3 t2 = (bmax - pos) * rayInv;\n\n    vec3 vmin = min(t1, t2);\n    vec3 vmax = max(t1, t2);\n\n    float tNear = max(vmin.z, max(vmin.x, vmin.y));\n    float tFar = min(vmax.z, min(vmax.x, vmax.y));\n\n    vec4 rh = vec4(0,1,0,farPlane);\n    if ((tFar < tNear)) return rh;\n    if (outside > 0) {\n        if ((tNear <= 0.0)) return rh;\n\t    rh.w = tNear;\n    } else if (outside < 0) {\n        if ((tFar <= 0.0)) return rh;\n\t    rh.w = tFar;\n    }\n\n    // optimize me!\n    if (t1.x == rh.w) rh.xyz = vec3(-1.0, 0.0, 0.0);\n    else if (t2.x == rh.w) rh.xyz = vec3(1.0, 0.0, 0.0);\n    else if (t1.y == rh.w) rh.xyz = vec3(0.0, -1.0, 0.0);\n    else if (t2.y == rh.w) rh.xyz = vec3(0.0, 1.0, 0.0);\n    else if (t1.z == rh.w) rh.xyz = vec3(0.0, 0.0, -1.0);\n    else if (t2.z == rh.w) rh.xyz = vec3(0.0, 0.0, 1.0);\n //\trh.xyz = rh.xyz * float(outside);  // Use this for normal to point inside if hit from inside\n    return rh;\n}\n\n// ---- Scattering (fog) vars ----\n// Scattering needs a stack because it's all about what you're moving through.\n// So if you move through fog and then through glass, when you come out of the glass,\n// you're back into the fog.\n\n// This is the scatter var for the outer-most place. RGB fog diffuse, fog density.\n// **** Set fog here ****\nconst vec4 globalScatter = vec4(0.76, 0.77, 0.8, 0.2);\n// Scatter stack\nvec4 scatterStack[NUM_ITERS*2];  // Size correct?\nint scatterStackIndex;\nvoid PushScatter(in vec4 s) {\n    scatterStack[scatterStackIndex] = s;\n    scatterStackIndex++;\n}\nvec4 PopScatter() {\n    scatterStackIndex--;\n    return scatterStack[scatterStackIndex];\n}\nvec4 PeekScatter() {\n    return scatterStack[scatterStackIndex-1];\n}\nvoid InitScatterStack(in vec4 s) {\n    scatterStackIndex = 0;\n    PushScatter(s);\n}\n\n// ---- Materials ----\n\n// List of refraction values for different materials\n// Linear reflectance values from http://blog.selfshadow.com/publications/s2012-shading-course/hoffman/s2012_pbs_physics_math_notes.pdf\n// In w, refrective index - https://en.wikipedia.org/wiki/List_of_refractive_indices\n// These can be calculated from each other: https://en.wikipedia.org/wiki/Schlick%27s_approximation\nconst vec4 refDebug = vec4(1.0,1.0,1.0, 1.005);\nconst vec4 refNone = vec4(0.0,0.0,0.0, 1.0);\nconst vec4 refWater = vec4(0.02,0.02,0.02, 1.330);\nconst vec4 refPlasticGlassLow = vec4(0.03,0.03,0.03, 1.42);\nconst vec4 refGlassWindow = vec4(0.043,0.043,0.043,1.52);\nconst vec4 refPlasticHigh = vec4(0.05,0.05,0.05, 1.58);\nconst vec4 refGlassHigh = vec4(0.08,0.08,0.08,1.79);  // Ruby\nconst vec4 refDiamond = vec4(0.172,0.172,0.172,2.417);\n// Metals - refractive index is placeholder and shouldn't be used I guess\nconst vec4 refIron = vec4(0.56,0.57,0.58,1.0);\nconst vec4 refCopper = vec4(0.95,0.64,0.54,1.0);\nconst vec4 refGold = vec4(1.0, 0.71, 0.29,1.0);\nconst vec4 refAluminum = vec4(0.91,0.92,0.92,1.0);\nconst vec4 refSilver = vec4(0.95,0.93,0.88,1.0);\n\nstruct Material {\n\tvec4 reflectRefract;\n    float refMult;\n    bool doRefraction;\n    vec3 diffuse;\n    vec3 emission;\n    vec3 filterDiffuseDensity;  // This is like a cheap scatter. Not sure I like it.\n    vec4 scatter;  // Diffuse in xyz, scatter probability in w.\n};\nconst int defaultMaterialIndex = 3;\nconst int NUM_MATERIALS = 7;\nMaterial materials[NUM_MATERIALS] = Material[NUM_MATERIALS](\n    // water\n    Material(refWater, 1.0, true, vec3(1.0), vec3(0.0), vec3(1.0), vec4(0.3, 0.6, 0.6, 0.3)),\n    // ruby\n    Material(refGlassHigh, 1.0, true, vec3(0.0), vec3(0.0), vec3(0.99, 0.2, 0.05), vec4(0.0)),\n    // gold\n    Material(refGold, 1.0, false, vec3(0.0), vec3(0.0), vec3(0.0), vec4(0.0)),\n    // colored plastic\n    Material(refPlasticGlassLow, 1.0, false, vec3(0.1, 0.2, 0.3), vec3(0.0), vec3(0.0), vec4(0.0)),\n    // non-shiny whatever\n    Material(refPlasticGlassLow, 0.0, false, vec3(1.0), vec3(0.0), vec3(0.0), vec4(0.0)),\n    // light\n    Material(refNone, 1.0, false, vec3(0.0), vec3(14.0, 12.0, 7.0)*2.0, vec3(0.0), vec4(0.0)),\n    // mirrored aluminum\n    Material(refAluminum, 1.0, false, vec3(0.0), vec3(0.0), vec3(0.0), vec4(0.0))\n);\n\n// Cube-fractal params\nconst float border = 0.43;\nconst float subcutoff = 0.5;\nconst float solidprob = 0.15;\n\n// Cube fractal recursive function duplicated because shaders don't do recursion.\nvoid IntersectBoxes4(vec4 posSize, vec3 rayP, vec3 rayD, int rayOutside, inout SceneHit result, int oldi) {\n    vec3 rayInv = 1.0 / rayD;\n    vec4 sA;\n    sA.w = border;\n    sA.w *= posSize.w*0.6666;\n    for (int i = ZERO_TRICK; i < 27; i++) {  // Weird for loop trick so compiler doesn't unroll loop\n        sA.x = float(i % 3);\n        sA.y = float((i / 3) % 3);\n        sA.z = float((i / 9) % 3);\n        sA.xyz -= vec3(1.0);\n        sA.xyz *= posSize.w*0.6666;\n        sA.xyz += posSize.xyz;\n        //if (length(sA.xyz) > 1.0) continue;\n        vec4 rh = BoxIntersect(rayP, rayInv, sA.xyz, vec3(sA.w, sA.w, sA.w), rayOutside);\n        if ((rh.w > 0.0) && (rh.w < result.pt) && (Hashf1(uint(i + oldi))>solidprob)) {\n            float subdivide = Hashf1(uint((i + oldi)*101));\n            if (subdivide < subcutoff) {\n                result.objIndex = i + oldi;\n                result.materialIndex = int(SmallHashIA(uint(i + oldi)))%5+0;\n                result.pt = rh.w;\n\t\t        result.hitPos = rayP + rayD * rh.w;\n                result.hitNormal = rh.xyz;\n            } else {\n\t\t\t    //IntersectBoxes5(vec4(sA.xyz,sA.w), rayP, rayD, rayOutside, result, i * 37);\n            }\n        }\n    }\n}\n\nvoid IntersectBoxes3(vec4 posSize, vec3 rayP, vec3 rayD, int rayOutside, inout SceneHit result, int oldi) {\n    vec3 rayInv = 1.0 / rayD;\n    vec4 sA;\n    sA.w = border;\n    sA.w *= posSize.w*0.6666;\n    for (int i = ZERO_TRICK; i < 27; i++) {  // Weird for loop trick so compiler doesn't unroll loop\n        sA.x = float(i % 3);\n        sA.y = float((i / 3) % 3);\n        sA.z = float((i / 9) % 3);\n        sA.xyz -= vec3(1.0);\n        sA.xyz *= posSize.w*0.6666;\n        sA.xyz += posSize.xyz;\n        //if (length(sA.xyz) > 1.0) continue;\n        vec4 rh = BoxIntersect(rayP, rayInv, sA.xyz, vec3(sA.w, sA.w, sA.w), rayOutside);\n        if ((rh.w > 0.0) && (rh.w < result.pt) && (Hashf1(uint(i + oldi))>solidprob)) {\n            float subdivide = Hashf1(uint((i + oldi)*101));\n            if (subdivide < subcutoff) {\n                result.objIndex = i + oldi;\n                result.materialIndex = int(SmallHashIA(uint(i + oldi)))%5+0;\n                result.pt = rh.w;\n\t\t        result.hitPos = rayP + rayD * rh.w;\n                result.hitNormal = rh.xyz;\n            } else {\n#if FRACTAL_RECURSIONS >= 3\n\t\t\t    IntersectBoxes4(vec4(sA.xyz,sA.w), rayP, rayD, rayOutside, result, i * 37);\n#endif\n            }\n        }\n    }\n}\n\nvoid IntersectBoxes2(vec4 posSize, vec3 rayP, vec3 rayD, int rayOutside, inout SceneHit result, int oldi) {\n    vec3 rayInv = 1.0 / rayD;\n    vec4 sA;\n    sA.w = border;\n    sA.w *= posSize.w*0.6666;\n    for (int i = ZERO_TRICK; i < 27; i++) {  // Weird for loop trick so compiler doesn't unroll loop\n        sA.x = float(i % 3);\n        sA.y = float((i / 3) % 3);\n        sA.z = float((i / 9) % 3);\n        sA.xyz -= vec3(1.0);\n        sA.xyz *= posSize.w*0.6666;\n        sA.xyz += posSize.xyz;\n        //if (length(sA.xyz) > 1.0) continue;\n        vec4 rh = BoxIntersect(rayP, rayInv, sA.xyz, vec3(sA.w, sA.w, sA.w), rayOutside);\n        if ((rh.w > 0.0) && (rh.w < result.pt) && (Hashf1(uint(i + oldi))>solidprob)) {\n            float subdivide = Hashf1(uint((i + oldi)*101));\n            if (subdivide < subcutoff) {\n                result.objIndex = i + oldi;\n                if (abs(rh.z) > 0.9)\n\t                result.materialIndex = int(SmallHashIA(uint(i + oldi)))%7+0;\n                else\n\t                result.materialIndex = int(SmallHashIA(uint(i + oldi)))%3+2;\n                //result.materialIndex = int(SmallHashIA(uint(i + oldi)))%5+0;\n                result.pt = rh.w;\n\t\t        result.hitPos = rayP + rayD * rh.w;\n                result.hitNormal = rh.xyz;\n            } else {\n#if FRACTAL_RECURSIONS >= 2\n\t\t\t    IntersectBoxes3(vec4(sA.xyz,sA.w), rayP, rayD, rayOutside, result, i * 37);\n#endif\n            }\n        }\n    }\n}\n\nvoid IntersectBoxes(vec4 posSize, vec3 rayP, vec3 rayD, int rayOutside, inout SceneHit result, int oldi) {\n    vec3 rayInv = 1.0 / rayD;\n    vec4 sA;\n    sA.w = border;\n    sA.w *= posSize.w*0.6666;\n    for (int i = ZERO_TRICK; i < 27; i++) {  // Weird for loop trick so compiler doesn't unroll loop\n        sA.x = float(i % 3);\n        sA.y = float((i / 3) % 3);\n        sA.z = float((i / 9) % 3);\n        sA.xyz -= vec3(1.0);\n        sA.xyz *= posSize.w*0.6666;\n        sA.xyz += posSize.xyz;\n        vec4 rh = BoxIntersect(rayP, rayInv, sA.xyz, vec3(sA.w, sA.w, sA.w), rayOutside);\n        if ((rh.w > 0.0) && (rh.w < result.pt) && (Hashf1(uint(i + oldi))>solidprob)) {\n            float subdivide = Hashf1(uint(i + oldi)*7u);\n            if (subdivide > subcutoff*1.9) {\n            //if (i==13){\n                result.objIndex = i + oldi;\n                if (abs(rh.z) > 0.9)\n\t                result.materialIndex =5;// int(SmallHashIA(uint(i + oldi)))%4+2;\n                else\n\t                result.materialIndex = int(SmallHashIA(uint(i + oldi)))%3+2;\n                //result.materialIndex = int(SmallHashIA(uint(i + oldi)))%3+2;\n                result.pt = rh.w;\n\t\t        result.hitPos = rayP + rayD * rh.w;\n                result.hitNormal = rh.xyz;\n            } else {\n#if FRACTAL_RECURSIONS >= 1\n\t\t\t    IntersectBoxes2(vec4(sA.xyz,sA.w), rayP, rayD, rayOutside, result, i * 37);\n#endif\n            }\n        }\n    }\n}\n\n// ---- Intersect the ray with the scene, ray-trace style ----\nSceneHit SceneIntersect(const in Ray ray) {\n    SceneHit result;\n    result.hitNormal = vec3(0.0);\n    result.pt = farPlane;\n    result.objIndex = BIG_INT;\n    result.materialIndex = defaultMaterialIndex;\n    /*vec3 rayInv = 1.0 / ray.dirNormalized;\n    vec4 sA = vec4(0.0, 0.0, 0.75, 1.5);\n    for (int i = ZERO_TRICK; i < 8; i++) {\n        sA.xyz = (Hashf3(uint(i+5)) - 0.5) * 12.0;\n        sA.y *= 0.5;\n        //sA.y += 0.5;\n        //sA.xyz += Randf1i1(uint(float(i)+iTime*60.0)) * sA.xyz * 0.93;\n        sA.w = (Hashf1(uint(i+23)) + 0.75) * 0.8251;\n        float tall = 1.25;\n        //if ((i & 7) == 0) {\n        //    sA.y += 2.0;\n        //    sA.w *= 0.152;\n        //    tall = 8.0*Hashf1i1(uint(i+23));\n        //}\n        vec4 rh = SphereIntersect3(ray.p0, ray.dirNormalized, sA.xyz, sA.w, ray.outside);\n\t\t//vec4 rh = BoxIntersect(ray.p0, rayInv, sA.xyz, vec3(sA.w, sA.w*tall, sA.w), ray.outside);\n        if ((rh.w > 0.0) && (rh.w < result.pt)) {\n            result.objIndex = i+27;//3;// i&3;\n\t\t    result.materialIndex =i+1;//(i&1)*4+1;\n            //if ((i & 7) == 0) result.objIndex =4 + ((i/8)&1);\n            result.pt = rh.w;\n            result.hitPos = ray.p0 + ray.dirNormalized * rh.w;\n            result.hitNormal = rh.xyz;\n        }\n    }\n    vec4 rh = BoxIntersect(ray.p0, rayInv, vec3(0,-5,0), vec3(8.0, 0.5, 8.0), ray.outside);\n    if ((rh.w > 0.0) && (rh.w < result.pt)) {\n        result.objIndex = 1234;\n        result.materialIndex =4;// (i&1)*4+1;\n        //if ((i & 7) == 0) result.objIndex =4 + ((i/8)&1);\n        result.pt = rh.w;\n        result.hitPos = ray.p0 + ray.dirNormalized * rh.w;\n        result.hitNormal = rh.xyz;\n    }\n    rh = BoxIntersect(ray.p0, rayInv, vec3(2,-3.6,-6), vec3(1.0, 0.5, 1.0), ray.outside);\n    if ((rh.w > 0.0) && (rh.w < result.pt)) {\n        result.objIndex = 1235;\n        result.materialIndex = 0;// (i&1)*4+1;\n        //if ((i & 7) == 0) result.objIndex =4 + ((i/8)&1);\n        result.pt = rh.w;\n        result.hitPos = ray.p0 + ray.dirNormalized * rh.w;\n        result.hitNormal = rh.xyz;\n    }*/\n    IntersectBoxes(vec4(0.0,0.0,0.0,1.0), ray.p0, ray.dirNormalized, ray.outside, result, 0);\n\n    return result;\n}\n\n// ---- Also support ray marching, not just ray tracing. ----\n// k should be negative. -4.0 works nicely.\n// smooth blending function\nfloat smin(float a, float b, float k)\n{\n\treturn log2(exp2(k*a)+exp2(k*b))/k;\n}\n// min function that supports materials in the y component\nvec2 matmin(vec2 a, vec2 b)\n{\n    if (a.x < b.x) return a;\n    else return b;\n}\nvec2 matmax(vec2 a, vec2 b)\n{\n    if (a.x > b.x) return a;\n    else return b;\n}\n// signed box distance field\nfloat sdBox(vec3 p, vec3 radius)\n{\n  vec3 dist = abs(p) - radius;\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\n}\n\n// Noise generator from https://otaviogood.github.io/noisegen/\n// Params: 2D, Seed 1, Waves 6, Octaves 3, Smooth 1.25\nfloat NoiseGen(vec2 p) {\n    // This is a bit faster if we use 2 accumulators instead of 1.\n    // Timed on Linux/Chrome/TitanX Pascal\n    float wave0 = 0.0;\n    float wave1 = 0.0;\n    wave0 += sin(dot(p, vec2(-1.699, -1.719))) * 0.2639797486;\n    wave1 += sin(dot(p, vec2(3.196, -0.147))) * 0.1524620373;\n    wave0 += sin(dot(p, vec2(3.654, 3.161))) * 0.0761552832;\n    wave1 += sin(dot(p, vec2(1.047, 4.757))) * 0.0751807404;\n    wave0 += sin(dot(p, vec2(-4.889, 0.548))) * 0.0740187224;\n    wave1 += sin(dot(p, vec2(-5.403, -4.576))) * 0.0427534381;\n    return wave0+wave1;\n}\n\n// This is the distance function that defines the ray marched scene's geometry.\n// The input is a position in space.\n// outside is 1 if the ray is intersecting with the outside of objects, -1 for insides (backface)\n// The output is the distance to the nearest surface, and a material index\nvec2 DistanceToObject(vec3 p, int outside)\n{\n    //float dist = p.y;\n    //dist = length(p) - 1.4;\n    //dist = smin(dist, length(p + vec3(2.25, -4.0, -4.0)) - 2.95, -0.95);\n    float dist = 1000000.0;\n    float noise = NoiseGen(p.xz*2.0)*0.1;\n\n    vec2 water = vec2(dist, 5.0);\n    //water = matmin(water, vec2(length(p.xz + vec2(7.0, -5.0))-0.5, 3.0));\n    float cyl = length(vec2(p.y,abs(p.x)) + vec2(-5.5, -6.0)) - 0.5;\n    cyl = max(cyl, abs(p.z)-18.0);\n    //water = matmin(water, vec2(cyl, 6.0));\n    float rad = length(p.xz)*4.0;\n    // Make water radial waves (computationally expensive)\n    noise = noise*0.4 -sin(rad)/rad;\n    float waterBox = sdBox(p + vec3(0.0, 5.1+noise, 0.0), vec3(6.0, 0.5, 6.5));\n    waterBox = smin(waterBox, length(p+vec3(0.0,2.95,0.0))-0.6, -3.95);\n//    water = matmin(water, vec2(waterBox, 0.0));\n    float pool = sdBox(p + vec3(3.0, 5., 0.0), vec3(3.0, 0.5, 6.5));\n    //pool = max(pool, -(length(p.xz) - 4.0));\n    //water = matmin(water, vec2(pool, 5.0));\n    //water = matmin(water, vec2(sdBox(p + vec3(1.0, -6.1, 0.0), vec3(0.6, 0.1, 8.04)), 6.0));\n    //water = matmin(water, vec2(sdBox(p + vec3(1.0, -6.15, 0.0), vec3(0.8, 0.1, 8.4)), 3.0));\n    \n    float room = -sdBox(p + vec3(0.0, 0.0, 0.0), vec3(18.0, 18.5, 18.0));\n    //water = matmin(water, vec2(room,2.0));\n\n    //water = matmin(water, vec2(length(p+vec3(0.0,2.5,0.0))-0.5, 1.0));\n    //water = matmin(water, vec2(length(p+vec3(2.0,3.6,6.0))-1.0, 0.0));\n\n    float test = sdBox(p + vec3(2.0,3.6,6.0), vec3(1.0, 0.5, 1.0))+noise*2.0;\n    water = matmin(water, vec2(test, 0.0));\n\n    vec3 p2 = RotateX(p, -0.25) + vec3(4.5, 0.0, 4.0);\n    float d = sdBox(p2, vec3(4.0,1.5,4.0));\n    d = max(d, (p2.y+(p2.x * p2.x + p2.z*p2.z) * 0.3)*0.25);\n    water = matmin(water, vec2(d, 1.0));\n\n    //float prism = sdTriPrism(p + vec3(0.0, 3.0, 0.0), vec2(1.0, 6.0));\n    //water = matmin(water, vec2(prism, 0.0));\n\n    return water * vec2(float(outside), 1.0);\n}\n\nSceneHit SceneMarch(const in Ray ray) {\n    SceneHit result;\n    result.hitNormal = vec3(0.0);\n    //result.pt = farPlane;\n    result.objIndex = BIG_INT;\n    result.materialIndex = defaultMaterialIndex;\n    vec2 distAndMat = vec2(0.0, -1.0);  // Distance and material\n\t// ----------------------------- Ray march the scene ------------------------------\n\tconst float maxDepth = 48.0; // farthest distance rays will travel\n    const float smallVal = 0.0625*0.125;\n\tresult.pt = 0.0;\n    const float safety =1.0;// 0.975;\n    // First, escape if we are touching a surface already.\n    // Get the ray out of the negative part of the distance field. (rough hack)\n    float jump = smallVal;\n    for (int i = ZERO_TRICK; i < 16; i++) {  // Weird for loop trick so compiler doesn't unroll loop\n        // Step along the ray.\n        result.hitPos = (ray.p0 + ray.dirNormalized * result.pt);\n        distAndMat = DistanceToObject(result.hitPos, ray.outside);\n\n        if (abs(distAndMat.x) >= smallVal) break;\n        // move down the ray a safe amount\n        result.pt += jump;//safety;//* float(ray.outside);\n        //result.pt += distAndMat.x*2.0;//safety;//* float(ray.outside);\n        jump *= 2.0;  // This is not super good. Fix me eventually.\n        if (result.pt > maxDepth) break;\n    }\n\t// ray marching time\n    for (int i = 200; i >= 0; i--)\t// This is the count of the max times the ray actually marches.\n    {\n        // Step along the ray.\n        result.hitPos = (ray.p0 + ray.dirNormalized * result.pt);\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry. The idea is that the\n        // distance field returns the distance to the closest object, and then\n        // we know we are safe to \"march\" along the ray by that much distance\n        // without hitting anything. We repeat this until we get really close\n        // and then break because we have effectively hit the object.\n        distAndMat = DistanceToObject(result.hitPos, ray.outside);\n\n        // If we are very close to the object, let's call it a hit and exit this loop.\n        if (abs(distAndMat.x) < smallVal) break;\n        // move down the ray a safe amount\n        result.pt += distAndMat.x*safety;\n        if (i == 0) result.pt = maxDepth+0.01;\n        if (result.pt > maxDepth) break;\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// If a ray hit an object, calculate the normal and save the hit info.\n    if ((result.pt <= maxDepth) && (result.pt > 0.0))\n\t{\n        float dist = distAndMat.x;\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(smallVal, 0, 0);\n        // Normals still point out even if we're on the inside.\n        //float mid = DistanceToObject(result.hitPos, 1).x;\n        //vec3 normalU = vec3(mid - DistanceToObject(result.hitPos - smallVec.xyy, 1).x,\n        //                   mid - DistanceToObject(result.hitPos - smallVec.yxy, 1).x,\n        //                   mid - DistanceToObject(result.hitPos - smallVec.yyx, 1).x);\n        vec3 normalU = vec3(0.0);\n        for( int i=min(0,iFrame); i<4; i++ )\n        {\n            vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n            normalU += e*DistanceToObject(result.hitPos+smallVal*e, 1).x;\n        }\n        result.hitNormal = normalize(normalU);\n        result.objIndex = int(distAndMat.y);\n        result.materialIndex = int(distAndMat.y);\n\t}\n    else\n    {\n        // Our ray trace hit nothing. Set object index to big int.\n        result.hitNormal = vec3(0.0);\n        result.pt = farPlane;\n        result.objIndex = BIG_INT;\n        result.materialIndex = BIG_INT;\n    }\n    return result;\n}\n\n// ---- Main ray trace function ----\n// Trace a ray, hit, apply material, save hit, and return the bounced ray\nRay TraceOneRay(const in Ray ray) {\n    vec3 diffuse = vec3(1.0);\n    vec3 emission = vec3(0.0);\n\n    // Send a ray out into the scene. Combine both ray marching and ray tracing.\n    Ray newRay;\n    newRay.outside = ray.outside;\n    SceneHit resultA = SceneIntersect(ray);\n    SceneHit resultB = SceneMarch(ray);\n    SceneHit result;\n    // Take closest hit.\n    if (resultA.pt < resultB.pt) {\n        result = resultA;\n    } else {\n        result = resultB;\n    }\n    result = resultA;// ***** HACK GOT RID OF RAY MARCHING... *****\n\n    vec4 currentScatter = PeekScatter();\n    Material material = materials[result.materialIndex % materials.length()];\n    // Calculate how far the ray goes before hitting a random scattering particle.\n    float lifetime = RayLifetime(currentScatter.w);\n    // If we hit an object instead of a scatter-particle or the far-plane...\n    if (result.pt < min(farPlane, lifetime)) {\n\n        // Debug normal visualization\n        //emission = result.hitNormal * 0.5 + 0.5;\n        //newRay.outside = 0;\n        //SaveHit(diffuse, emission);\n        //return newRay;\n\n        //mat3 basis = MakeBasis(result.hitNormal);\n        newRay.p0 = result.hitPos;\n\n        vec4 refMaterial = material.reflectRefract;\n        float reflectance = material.refMult;\n        float fresnel = refMaterial.z;\n        // If reflectance is different for different wavelengths, then let's change from\n        // rgb to r, g, or b stochastically while not losing energy. So we will end up\n        // tracing a ray representing a single wavelength of light.\n        // This can be done unconditionally because if xyz are the same, it doesn't matter anyway.\n        float choice = Randf1();\n        if ((refMaterial.x != refMaterial.y) || (refMaterial.y != refMaterial.z)) {\n            // If we have already split to single wavelength, don't do it again.\n            if ( ((refMaterial.x == 0.0) && (refMaterial.y == 0.0)) ||\n                ((refMaterial.y == 0.0) && (refMaterial.z == 0.0)) ||\n                ((refMaterial.z == 0.0) && (refMaterial.x == 0.0)) ) {\n                // Take the non-zero component as the fresnel value.\n                fresnel = dot(refMaterial.xyz, vec3(1.0));\n            } else {\n                // .333 chance of switching to each single channel - r, g, or b.\n                if (choice < 0.33333) {\n                    fresnel = refMaterial.x;\n                    diffuse *= vec3(1.0, 0.0, 0.0);\n                } else if (choice < 0.66666) {\n                    fresnel = refMaterial.y;\n                    diffuse *= vec3(0.0, 1.0, 0.0);\n                } else diffuse *= vec3(0.0, 0.0, 1.0);\n                diffuse *= 3.0;  // To make up for stochastically dropping 2 out of 3 channels\n            }\n        }\n        // Figure out if we should reflect, or if the ray should go into the object (diffuse or refraction)\n        // Schlick's approximation\n        float oneMinusCos = 1.0 - saturate(dot(ray.dirNormalized, -result.hitNormal* float(ray.outside)));\n        float reflectProb = fresnel + (1.0-fresnel) * pow(oneMinusCos, 5.0);\n        reflectProb *= reflectance;\n        if (Randf1() < reflectProb) {\n            // reflect\n\t        vec3 reflection = reflect(ray.dirNormalized, result.hitNormal);// * float(ray.outside));\n            newRay.dirNormalized = normalize(reflection);\n            // Already did the probability of reflection before, so no need to multiply anything.\n            //diffuse *= vec3(1.0);\n        } else {\n            if (material.doRefraction) {\n                // refract\n                float refractionIndex = 1.0 / refMaterial.w;  // 1.33 is water, 1.5 is glass.\n                if (ray.outside == -1) refractionIndex = 1.0 / refractionIndex;\n\n                vec3 refraction = refract(ray.dirNormalized, result.hitNormal * float(ray.outside), refractionIndex);\n                if (dot(refraction, refraction) > 0.0) {\n                    // Standard refraction\n\t                newRay.dirNormalized = normalize(refraction);\n                } else {\n                    // Special case - total internal reflection.\n                    // This is where at glancing angles, the surface will act like a mirror.\n                    // It's what makes fiber optics work. :D\n                    vec3 reflection = reflect(ray.dirNormalized, result.hitNormal * float(ray.outside));\n                    newRay.dirNormalized = normalize(reflection);\n                }\n                if (ray.outside == 1) {\n                    PushScatter(material.scatter);\n                } else {\n                    PopScatter();\n                }\n                newRay.outside = -ray.outside;\n            } else {\n                // Diffuse light\n                // Get a random vector in the hemisphere pointing along the normal.\n\t            vec3 rand = RandPointOnSphere();\n                vec3 bounce = rand * sign(dot(result.hitNormal, rand));\n                newRay.dirNormalized = bounce;\n                // Lambert shading model\n                //float intensity = dot(bounce, result.hitNormal);\n                diffuse *= material.diffuse;// * intensity;\n                emission = material.emission;\n                // hack to colorize things randomly\n                if (result.materialIndex == 5) {\n\t            \t//diffuse = Hashf3(uint(result.objIndex*17));\n\t            \temission *= max(vec3(0.1), Hashf3(uint(result.objIndex+37)));\n                    //float grid = pow(abs(fract(result.hitPos.x*8.0)-0.5)*2.0, 2.3);\n                    //grid = min(grid, max(0.0, sin(result.hitPos.y*96.0)));\n                    //emission *= grid*3.0;\n                }\n                if (result.materialIndex == 4) {\n                    // checkerboard because it's a ray tracer. :)\n                    //diffuse *= float((int(newRay.p0.x+8.0) & 1) ^ (int(newRay.p0.y+8.0) & 1) ^ (int(newRay.p0.z+8.0) & 1) ) * 0.2 + 0.8;\n                }\n            }\n\n        }\n    } else {\n        if (lifetime < farPlane) {\n            // Scattering (fog)\n            newRay.p0 = ray.p0 + ray.dirNormalized * lifetime;\n            newRay.dirNormalized = RandPointOnSphere();\n            diffuse *= currentScatter.xyz;\n            //emission = material.emission;\n        } else {\n            // Hit the background image. Let's be done ray tracing.\n            emission = GetEnvMap(ray.dirNormalized);\n            newRay.outside = 0;  // This terminates the ray.\n        }\n    }\n    // Filtering\n    // Filter proportional to how long the ray moves inside the object\n    // This can also be done with scattering, but this should converge quicker.\n    if (ray.outside == -1) {\n        vec3 internal = material.filterDiffuseDensity.xyz;\n        diffuse *= pow(internal, vec3(abs(result.pt)));\n        emission = material.emission * pow(internal, vec3(abs(result.pt)));\n    }\n\n    // Save the ray hit in a list so we can calculate color of the pixel later on.\n    SaveHit(diffuse, emission);\n    return newRay;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    SetRandomSeed(uint(fragCoord.x), uint(fragCoord.y), uint(iFrame));\n    vec2 position = (gl_FragCoord.xy / iResolution.xy);\n    // read original buffer so we can accumulate pixel values into back it.\n\tvec4 backpixel = texture(iChannel0, position);\n    // If we use the mouse to change the view, reset the pixel accumulation buffer\n    if (iMouse.z > 0.0) backpixel = vec4(0.0);\n\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv_orig = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n    float zoom = 1.7;\n    vec2 uv = uv_orig / zoom;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tvec3 camLookat=vec3(0,0.1,0);\n\n    // camera orbit with mouse movement\n    float mx=iMouse.x/iResolution.x*PI*2.0-0.7;\n\tfloat my=-iMouse.y/iResolution.y*10.0;\n\tvec3 camPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(3.2);\n    // If mouse is in bottom left corner, then use pre-set camera angle.\n    if ((dot(iMouse.xy, vec2(1.0)) <= 64.0)) camPos = vec3(-1.05, -0.6, 2.7);\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\n    // Depth of field hack... I think the math is all wrong.\n    const float depthOfFieldAmount = 0.02;\n    vec2 rg = RandGaussianCircle()*depthOfFieldAmount;\n    camPos += sideNorm * rg.x;\n    camPos += upNorm * rg.y;\n    camVec=normalize(camLookat - camPos);\n    sideNorm=normalize(cross(upNorm, camVec));\n    upNorm=cross(camVec, sideNorm);\n\n    // More camera setup\n    vec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\t// --------------------------------------------------------------------------------\n    vec3 colorSum = vec3(0.0);\n    // Loop through for a few samples and average the pixel colors from ray tracing.\n    for (int s = ZERO_TRICK; s < NUM_SAMPLES; s++) {  // Weird for loop trick so compiler doesn't unroll loop\n        InitScatterStack(globalScatter);\n        ResetColorHitList();\n        Ray ray;\n        ray.outside = 1;\n        ray.p0 = camPos;\n        // Anti-aliasing: Randomly jitter the ray direction by a gaussian distribution.\n        vec2 gauss = RandGaussianCircle();\n        float antialias = dFdx(uv.xy).x/1.5;\n        ray.dirNormalized = normalize(rayVec +\n                                      sideNorm*gauss.x*antialias +\n                                      upNorm * gauss.y*antialias);\n\n        // Trace a ray from the camera outwards, bounce the ray off objects and keep\n        // tracing until NUM_ITERS or until it hits the background.\n        for (int i = ZERO_TRICK; i < NUM_ITERS; i++) {\n            if (i == (NUM_ITERS-1)) break;\n            ray = TraceOneRay(ray);\n            if (ray.outside == 0) break;\n        }\n        /*int i = 0;\n        do {\n            ray = TraceOneRay(ray);\n            i++;\n        } while ((ray.outside != 0) && (i < NUM_ITERS-1));*/\n\n        // Once we're done iterating through rays from the camera outwards, we have a\n        // list of hits. Now we can go from the light source toward the camera and apply\n        // the color filters and emissions as we go.\n\t    vec4 finalColor = vec4(0.0, 0.0, 0.0, 0.0);\n        for (int i = NUM_ITERS-1; i >= ZERO_TRICK; i--) {\n            if (colorHits[i].emission.x != -1.0) {\n                finalColor.xyz *= colorHits[i].diffuse;\n                finalColor.xyz += colorHits[i].emission;\n                //finalColor.xyzw = finalColor.yzwx;  // Debug ray depth\n            }\n        }\n        colorSum += finalColor.xyz;\n    }\n    colorSum /= float(NUM_SAMPLES);\n\n    // output the final color\n\tfragColor = vec4(saturate(colorSum/4096.0),1.0) + backpixel;\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}