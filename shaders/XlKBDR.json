{
    "Shader": {
        "info": {
            "date": "1542217286",
            "description": "Quick doodling yesterday, train session for the GROW's shader showdown.",
            "flags": 0,
            "hasliked": 0,
            "id": "XlKBDR",
            "likes": 12,
            "name": "Doodling #8: Penumbra",
            "published": 3,
            "tags": [
                "tunnel",
                "raymarch",
                "doodling"
            ],
            "usePreview": 0,
            "username": "lsdlive",
            "viewed": 924
        },
        "renderpass": [
            {
                "code": "// @lsdlive\n// CC-BY-NC-SA\n\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n// Tunnel pattern studied from shane & shau\n// i.e. https://www.shadertoy.com/view/4tKXzV\nvec2 path(float t) {\n\tfloat a = sin(t*.2 + 1.5), b = sin(t*.2);\n\treturn vec2(a*2., a*b);\n}\n\n// http://mercury.sexy/hg_sdf/\n// hglib mirrorOctant\nvoid mo(inout vec2 p, vec2 d) {\n\tp = abs(p) - d;\n\tif (p.y > p.x)p = p.yx;\n}\n\n// hglib pMod1\nfloat re(float p, float d) {\n\treturn mod(p - d * .5, d) - d * .5;\n}\n\n// hglib pModPolar\nvoid amod(inout vec2 p, float d) {\n\tfloat a = re(atan(p.x, p.y), d);\n\tp = vec2(cos(a), sin(a)) * length(p);\n}\n\n// iq's signed cross sc() - https://iquilezles.org/articles/menger\nfloat sc(vec3 p, float d) {\n\tp = abs(p);\n\tp = max(p, p.yzx);\n\treturn min(p.x, min(p.y, p.z)) - d;\n}\n\nfloat g = 0.;\nfloat de(vec3 p) {\n\n\tp.xy -= path(p.z);\n\n\tp.xy *= r2d(p.z*.05);\n\n\tvec3 q = p;\n\n    // cylinder section\n\tamod(q.xy, 6.28 / 7.);\n\tmo(q.xy, vec2(1, .6));\n\tq.xy *= r2d(q.z*.5);\n\tmo(q.xy, vec2(.1, .2));\n\tamod(q.xy, 6.28 / 3.);\n\tfloat cyl2 = length(q.xy) - .05;\n\n    p.z = re(p.z, .4);\n    \n    // cross structure section\n\tamod(p.xy, .785*2.);\n\tmo(p.xz, vec2(3, .01));\n\tamod(p.xy, .785*.5);\n\tp.x = abs(p.x) - 2.1;\n\tmo(p.xy, vec2(.4, 2));\n\tfloat d = sc(p, .02);\n    \n\tg += .008 / (.01 + d * d);// glow trick from balkhan https://www.shadertoy.com/view/4t2yW1\n\td = min(d, cyl2); // outside of the glow computation for cool effect & better contrast\n    \n\treturn d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = (fragCoord - .5*iResolution.xy) / iResolution.y;\n\n\tfloat dt = iTime * 3.;\n\tvec3 ro = vec3(0, 0, -3. + dt);\n\tvec3 ta = vec3(0, 0, dt);\n\n\tro.xy += path(ro.z);\n\tta.xy += path(ta.z);\n\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 right = normalize(cross(fwd, vec3(0, 1, 0)));\n\tvec3 up = normalize(cross(right, fwd));\n\tvec3 rd = normalize(fwd + right * uv.x + up * uv.y);\n\n\tvec3 p;\n\tfloat t = 0., ri;\n\tfor (float i = 0.; i < 1.; i += .02) {\n\t\tri = i;\n\t\tp = ro + rd * t;\n\t\tfloat d = de(p);\n\t\td = max(abs(d), .002);// phantom mode trick from aiekick https://www.shadertoy.com/view/MtScWW\n\t\tt += d * .8;\n\t}\n\n\tvec3 c = mix(vec3(.5, .4, .3), vec3(.2, .1, .2), uv.x + ri);\n\tc += g * .034;// glow trick from balkhan https://www.shadertoy.com/view/4t2yW1\n\n\tfragColor = vec4(c, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}