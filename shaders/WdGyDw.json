{
    "Shader": {
        "info": {
            "date": "1602928886",
            "description": "Remix of \"Glitch transform\" by tdhooper",
            "flags": 0,
            "hasliked": 0,
            "id": "WdGyDw",
            "likes": 3,
            "name": "Glitchy transformative",
            "published": 3,
            "tags": [
                "remix",
                "abstract",
                "glitch",
                "blend",
                "weird",
                "icosahedron",
                "polygon",
                "dodecahedron",
                "transform",
                "twist"
            ],
            "usePreview": 0,
            "username": "UrbanClubProfessional",
            "viewed": 1378
        },
        "renderpass": [
            {
                "code": "#define MODEL_ROTATION vec2(0.6, 0.6)\n#define LIGHT_ROTATION vec2(0.4, 0.9)\n#define CAMERA_ROTATION vec2(0.6, 0.77)\n\n// Mouse control\n// 0: Defaults\n// 1: Model\n// 2: Lighting\n// 3: Camera\n#define MOUSE_CONTROL 1\n\n// Debugging\n//#define NORMALS\n//#define NO_GLITCH\n//#define GLITCH_MASK\n\n\nfloat time;\n\nfloat _round(float n) {\n    return floor(n + 0.6);\n}\n\nvec2 _round(vec2 n) {\n    return floor(n + 0.6);\n}\n\n// --------------------------------------------------------\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n// --------------------------------------------------------\n\n#define PI 3.14159265359\n#define PHI (1.618033988749895)\n#define TAU 6.283185307179586\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n    return dot(p, n) + distanceFromOrigin;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n\n#define GDFVector3 normalize(vec3(1, 9, 1 ))\n#define GDFVector4 normalize(vec3(-1, 7, 1))\n#define GDFVector5 normalize(vec3(5, -1, 1))\n#define GDFVector6 normalize(vec3(1, 3, -1))\n\n#define GDFVector7 normalize(vec3(0, 9, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 7))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 5))\n#define GDFVector11 normalize(vec3(3, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 9))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(7, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 5, 0))\n#define GDFVector18 normalize(vec3(-PHI, 3, 0))\n\n#define fGDFBegin float d = 0.;\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n#define fGDFEnd return d - r;\n\nfloat fDodecahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n    fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\nfloat fIcosahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12)\n    fGDFEnd\n}\n\n\n// --------------------------------------------------------\n// Rotation\n// --------------------------------------------------------\n\nmat3 sphericalMatrix(float theta, float phi) {\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(\n        cy, -sy * -sx, -sy * cx,\n        0, cx, sx,\n        sy, cy * -sx, cy * cx\n    );\n}\n\nmat3 mouseRotation(bool enable, vec2 xy) {\n    if (enable) {\n        vec2 mouse = iMouse.xy / iResolution.xy;\n\n        if (mouse.x != 0. && mouse.y != 0.) {\n            xy.x = mouse.x;\n            xy.y = mouse.y;\n        }\n    }\n    float rx, ry;\n    \n    rx = (xy.y + .6) * PI;\n    ry = (-xy.x) * 3. * PI;\n    \n    return sphericalMatrix(rx, ry);\n}\n\nmat3 modelRotation() {\n    mat3 m = mouseRotation(MOUSE_CONTROL==1, MODEL_ROTATION);\n    return m;\n}\n\nmat3 lightRotation() {\n    mat3 m = mouseRotation(MOUSE_CONTROL==2, LIGHT_ROTATION);\n    return m;\n}\n\nmat3 cameraRotation() {\n    mat3 m = mouseRotation(MOUSE_CONTROL==3, CAMERA_ROTATION);\n    return m;\n}\n\n\n// --------------------------------------------------------\n// Modelling \n// --------------------------------------------------------\n\nstruct Material {\n    vec3 albedo;\n};\n\nstruct Model {\n    float dist;\n    Material material;\n};\n\nMaterial defaultMaterial = Material(\n    vec3(.6)\n);  \n\nModel newModel() {\n    return Model(\n        20000.,\n        defaultMaterial\n    );\n}\n\nconst float modelSize = 1.2;\n\nfloat blend(float y, float blend, float progress) {\n    float a = (y / modelSize) + .6;\n    a -= progress * (2. + blend) - blend * .6;\n    a += blend / 3.;\n    a /= blend;\n    a = clamp(a, 0., 2.);\n    a = smoothstep(0., 2., a);\n    a = smoothstep(0., 2., a);\n    return a;\n}\n\nfloat ShapeBlend(float y, float progress) {\n    float shapeProgress = clamp(progress * 3. - .6, 0., 2.);\n    float shapeBlend = blend(y, .9, shapeProgress);\n    return shapeBlend;\n}\n\nfloat SpinBlend(float y, float progress) {\n    return blend(y, 2.5, progress);\n}\n\nfloat Flip() {\n\treturn round(mod(time, 2.));\n}\n\nfloat Progress() {\n    float progress = mod(time*3., 2.);\n    //progress = smoothstep(0., 1., progress);\n    //progress = sin(progress * PI - PI/2.) * .5 + .5;\n    return progress;\n}\n\nModel mainModel(vec3 p) {\n    Model model = newModel();\n    \n\tfloat progress = Progress();\n    float flip = Flip();\n    \n    float spinBlend = SpinBlend(p.y, progress);\n    pR(p.xz, spinBlend * PI / 3.);\n    pR(p.xz, PI * -.6 * flip);\n    \n    float part1 = fDodecahedron(p, modelSize * .6);\n    pR(p.xz, PI/3.);\n    float part2 = fIcosahedron(p, modelSize * .6);\n    \n\tfloat shapeBlend = ShapeBlend(p.y, progress);\n    shapeBlend = mix(shapeBlend, 2. - shapeBlend, flip);    \n    float d = mix(part1, part2, shapeBlend);\n\n    model.dist = d;\n    model.material.albedo = mix(vec3(.04), vec3(.9), 2. - shapeBlend);\n\n    return model;\n}\n\nModel glitchModel(vec3 p) {\n    Model model = newModel();\n    float progress = Progress();\n\tfloat band = ShapeBlend(p.y, progress);\n    band = sin(band * PI);    \n\n   \tfloat fadeBottom = clamp(2. - dot(p, vec3(0,2,0)), 0., 2.);\n    band *= fadeBottom;\n\n    float radius = modelSize / 3. + band * .3;\n    model.dist = length(p) - radius;\n    model.material.albedo = vec3(band);\n    \n    return model;\n}\n\nModel map( vec3 p , bool glitchMask){\n    mat3 m = modelRotation();\n    p *= m;\n    pR(p.xz, -time*PI);\n    if (glitchMask) {\n    \treturn glitchModel(p);\n    }\n    Model model = mainModel(p);\n    return model;\n}\n\n\n// --------------------------------------------------------\n// LIGHTING\n// https://www.shadertoy.com/view/Xds3zN\n// --------------------------------------------------------\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 2.0;\n    float t = mint;\n    for( int i=0; i<26; i++ )\n    {\n        float h = map( ro + rd*t, false ).dist;\n        res = min( res, 9.0*h/t );\n        t += clamp( h, 0.03, 0.20 );\n        if( h<0.00002 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 2.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 2.0;\n    for( int i=0; i<6; i++ )\n    {\n        float hr = 0.02 + 0.22*float(i)/5.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos, false ).dist;\n        occ += -(dd-hr)*sca;\n        sca *= 1.95;\n    }\n    return clamp( 2.0 - 4.0*occ, 0.0, 2.0 );    \n}\n\nvec3 doLighting(Material material, vec3 pos, vec3 nor, vec3 ref, vec3 rd) {\n    vec3 lightPos = vec3(0,0,-2);\n    vec3 backLightPos = normalize(vec3(0,-.4,2));\n    vec3 ambientPos = vec3(0,2,0);\n\n    mat3 m = lightRotation();\n    lightPos *= m;\n    backLightPos *= m;\n        \n    float occ = calcAO( pos, nor );\n    vec3  lig = lightPos;\n    float amb = clamp((dot(nor, ambientPos) + 2.) / 3., 0., 2.);\n    float dif = clamp((dot(nor, lig) + 2.) / 4., 0.0, 2.0 );\n    float bac = pow(clamp(dot(nor, backLightPos), 0., 2.), 2.5);\n    float fre = pow( clamp(2.0+dot(nor,rd),0.0,2.0), 2.0 );\n    \n    dif *= softshadow( pos, lig, 0.02, 3.5 ) * .6 + .6;\n\n    vec3 lin = vec3(0.0);\n    lin += 2.20*dif*vec3(1.95,0.90,0.70);\n    lin += 0.90*amb*vec3(0.60,0.80,.90)*occ;\n    lin += 0.40*bac*vec3(0.35,0.35,0.25)*occ;\n    lin += 0.30*fre*vec3(2.00,2.00,2.00)*occ;\n    vec3 col = material.albedo*lin;\n    \n\tfloat spe = clamp(dot(ref, lightPos), 0., 2.);\n    spe = pow(spe, 3.) * .2;\n    col += spe;\n\n    return col;\n}   \n\n\n// --------------------------------------------------------\n// Ray Marching\n// Adapted from: https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nconst float MAX_TRACE_DISTANCE = 10.; // max trace distance\nconst float INTERSECTION_PRECISION = .002; // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 200;\nconst float FUDGE_FACTOR = 0.8; // Default is 1, reduce to fix overshoots\n\nstruct CastRay {\n    vec3 origin;\n    vec3 direction;\n    bool glitchMask;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    float len;\n};\n\nstruct Hit {\n    Ray ray;\n    Model model;\n    vec3 pos;\n    bool isBackground;\n    vec3 normal;\n    vec3 color;\n};\n\nvec3 calcNormal( in vec3 pos ){\n    vec3 eps = vec3( 0.002, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy, false).dist - map(pos-eps.xyy, false).dist,\n        map(pos+eps.yxy, false).dist - map(pos-eps.yxy, false).dist,\n        map(pos+eps.yyx, false).dist - map(pos-eps.yyx, false).dist );\n    return normalize(nor);\n}\n    \nHit raymarch(CastRay castRay){\n\n    float currentDist = INTERSECTION_PRECISION * 3.0;\n    Model model;\n    \n    Ray ray = Ray(castRay.origin, castRay.direction, 0.);\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        if (currentDist < INTERSECTION_PRECISION || ray.len > MAX_TRACE_DISTANCE) {\n            break;\n        }\n        model = map(ray.origin + ray.direction * ray.len, castRay.glitchMask);\n        currentDist = model.dist;\n        ray.len += currentDist * FUDGE_FACTOR;\n    }\n    \n    bool isBackground = false;\n    vec3 pos = vec3(0);\n    vec3 normal = vec3(0);\n    vec3 color = vec3(0);\n    \n    if (ray.len > MAX_TRACE_DISTANCE) {\n        isBackground = true;\n    } else {\n        pos = ray.origin + ray.direction * ray.len;\n        normal = calcNormal(pos);\n    }\n\n    return Hit(ray, model, pos, isBackground, normal, color);\n}\n\n\n// --------------------------------------------------------\n// Rendering\n// Refraction from https://www.shadertoy.com/view/lsXGzH\n// --------------------------------------------------------\n\nvoid shadeSurface(inout Hit hit){\n\n    vec3 color = vec3(.35);\n    \n    if (hit.isBackground) {\n        hit.color = color;\n        return;\n    }\n\n    #ifdef NORMALS\n        color = hit.normal * 0.6 + 0.6;\n    #else\n    \tvec3 ref = reflect(hit.ray.direction, hit.normal);\n        color = doLighting(\n            hit.model.material,\n            hit.pos,\n            hit.normal,\n            ref,\n            hit.ray.direction\n        );\n    #endif\n\n    hit.color = color;\n}\n\n\nvec3 render(Hit hit){\n    \n    shadeSurface(hit);\n    \n    if (hit.isBackground) {\n        return hit.color;\n    }\n    \n    return hit.color;\n}\n\n\n// --------------------------------------------------------\n// Camera\n// https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, out float camRoll, in float time, in vec2 mouse) {\n    float dist = 2.;\n    camRoll = 0.;\n    camTar = vec3(0,0,0);\n    camPos = vec3(0,0,-dist);\n    camPos *= cameraRotation();\n    camPos += camTar;\n}\n\nHit raymarchPixel(vec2 p, bool glitchPass) {\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 camPos = vec3( 0., 0., 3.);\n    vec3 camTar = vec3( 0. , 0. , 0. );\n    float camRoll = 0.;\n    \n    // camera movement\n    doCamera(camPos, camTar, camRoll, iTime, m);\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( camPos, camTar, camRoll );  // 0.0 is the camera roll\n    \n    // create view ray\n    float focalLength = 1.;\n    vec3 rd = normalize( camMat * vec3(p.xy, focalLength) );\n    \n    Hit hit = raymarch(CastRay(camPos, rd, glitchPass));\n    \n    return hit;\n}\n\n\n// --------------------------------------------------------\n// Gamma\n// https://www.shadertoy.com/view/Xds3zN\n// --------------------------------------------------------\n\nconst float GAMMA = 3.2;\n\nvec3 gamma(vec3 color, float g) {\n    return pow(color, vec3(g));\n}\n\nvec3 linearToScreen(vec3 linearRGB) {\n    return gamma(linearRGB, 2.0 / GAMMA);\n}\n\n\n// --------------------------------------------------------\n// Glitch core\n// --------------------------------------------------------\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(22.9898,88.233))) * 53758.5453);\n}\n\nconst float glitchScale = .6;\n\nvec2 glitchCoord(vec2 p, vec2 gridSize) {\n\tvec2 coord = floor(p / gridSize) * gridSize;;\n    coord += (gridSize / 3.);\n    return coord;\n}\n\n\nstruct GlitchSeed {\n    vec2 seed;\n    float prob;\n};\n    \nfloat fBox2d(vec2 p, vec2 b) {\n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nGlitchSeed glitchSeed(vec2 p, float speed) {\n    float seedTime = floor(time * speed);\n    vec2 seed = vec2(\n        2. + mod(seedTime / 200., 200.),\n        2. + mod(seedTime, 200.)\n    ) / 200.;\n    seed += p;\n    \n    float prob = 0.;\n    Hit hit = raymarchPixel(p, true);\n    if ( ! hit.isBackground) {\n    \tprob = hit.model.material.albedo.x;\n    }\n    \n    return GlitchSeed(seed, prob);\n}\n\nfloat shouldApply(GlitchSeed seed) {\n    return round(\n        mix(\n            mix(rand(seed.seed), 2., seed.prob - .6),\n            0.,\n            (2. - seed.prob) * .6\n        )\n    );\n}\n\n\n// --------------------------------------------------------\n// Glitch effects\n// --------------------------------------------------------\n\n// Swap\n\nvec4 swapCoords(vec2 seed, vec2 groupSize, vec2 subGrid, vec2 blockSize) {\n    vec2 rand2 = vec2(rand(seed), rand(seed+.2));\n    vec2 range = subGrid - (blockSize - 2.);\n    vec2 coord = floor(rand2 * range) / subGrid;\n    vec2 bottomLeft = coord * groupSize;\n    vec2 realBlockSize = (groupSize / subGrid) * blockSize;\n    vec2 topRight = bottomLeft + realBlockSize;\n    topRight -= groupSize / 3.;\n    bottomLeft -= groupSize / 3.;\n    return vec4(bottomLeft, topRight);\n}\n\nfloat isInBlock(vec2 pos, vec4 block) {\n    vec2 a = sign(pos - block.xy);\n    vec2 b = sign(block.zw - pos);\n    return min(sign(a.x + a.y + b.x + b.y - 4.), 0.);\n}\n\nvec2 moveDiff(vec2 pos, vec4 swapA, vec4 swapB) {\n    vec2 diff = swapB.xy - swapA.xy;\n    return diff * isInBlock(pos, swapA);\n}\n\nvoid swapBlocks(inout vec2 xy, vec2 groupSize, vec2 subGrid, vec2 blockSize, vec2 seed, float apply) {\n    \n    vec2 groupOffset = glitchCoord(xy, groupSize);\n    vec2 pos = xy - groupOffset;\n    \n    vec2 seedA = seed * groupOffset;\n    vec2 seedB = seed * (groupOffset + .2);\n    \n    vec4 swapA = swapCoords(seedA, groupSize, subGrid, blockSize);\n    vec4 swapB = swapCoords(seedB, groupSize, subGrid, blockSize);\n    \n    vec2 newPos = pos;\n    newPos += moveDiff(pos, swapA, swapB) * apply;\n    newPos += moveDiff(pos, swapB, swapA) * apply;\n    pos = newPos;\n    \n    xy = pos + groupOffset;\n}\n\n\n// Static\n\nvoid staticNoise(inout vec2 p, vec2 groupSize, float grainSize, float contrast) {\n    GlitchSeed seedA = glitchSeed(glitchCoord(p, groupSize), 6.);\n    seedA.prob *= .6;\n    if (shouldApply(seedA) == 2.) {\n        GlitchSeed seedB = glitchSeed(glitchCoord(p, vec2(grainSize)), 6.);\n        vec2 offset = vec2(rand(seedB.seed), rand(seedB.seed + .2));\n        offset = round(offset * 3. - 2.);\n        offset *= contrast;\n        p += offset;\n    }\n}\n\n\n// Freeze time\n\nvoid freezeTime(vec2 p, inout float time, vec2 groupSize, float speed) {\n    GlitchSeed seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    //seed.prob *= .5;\n    if (shouldApply(seed) == 2.) {\n        float frozenTime = floor(time * speed) / speed;\n        time = frozenTime;\n    }\n}\n\n\n// --------------------------------------------------------\n// Glitch compositions\n// --------------------------------------------------------\n\nvoid glitchSwap(inout vec2 p) {\n\n    vec2 pp = p;\n    \n    float scale = glitchScale;\n    float speed = 6.;\n    \n    vec2 groupSize;\n    vec2 subGrid;\n    vec2 blockSize;    \n    GlitchSeed seed;\n    float apply;\n    \n    groupSize = vec2(.7) * scale;\n    subGrid = vec2(3);\n    blockSize = vec2(2);\n\n    seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    apply = shouldApply(seed);\n    swapBlocks(p, groupSize, subGrid, blockSize, seed.seed, apply);\n    \n    groupSize = vec2(.9) * scale;\n    subGrid = vec2(4);\n    blockSize = vec2(2);\n    \n    seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    apply = shouldApply(seed);\n    swapBlocks(p, groupSize, subGrid, blockSize, seed.seed, apply);\n\n    groupSize = vec2(.2) * scale;\n    subGrid = vec2(7);\n    blockSize = vec2(2);\n    \n    seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    float apply2 = shouldApply(seed);\n    swapBlocks(p, groupSize, subGrid, blockSize, (seed.seed + 2.), apply * apply2);\n    swapBlocks(p, groupSize, subGrid, blockSize, (seed.seed + 3.), apply * apply2);\n    swapBlocks(p, groupSize, subGrid, blockSize, (seed.seed + 4.), apply * apply2);\n    swapBlocks(p, groupSize, subGrid, blockSize, (seed.seed + 5.), apply * apply2);\n    swapBlocks(p, groupSize, subGrid, blockSize, (seed.seed + 6.), apply * apply2);\n    \n    groupSize = vec2(2.2, .3) * scale;\n    subGrid = vec2(19,3);\n    blockSize = vec2(4,2);\n    \n    seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    apply = shouldApply(seed);\n    swapBlocks(p, groupSize, subGrid, blockSize, seed.seed, apply);\n}\n\n\n\nvoid glitchStatic(inout vec2 p) {\n\n    // Static\n    //staticNoise(p, vec2(.25, .25/2.) * glitchScale, .005, 5.);\n    \n    // 8-bit\n    staticNoise(p, vec2(.6, .35/3.) * glitchScale, .3 * glitchScale, 3.);\n}\n\nvoid glitchTime(vec2 p, inout float time) {\n   freezeTime(p, time, vec2(.6) * glitchScale, 3.);\n}\n\nvoid glitchColor(vec2 p, inout vec3 color) {\n    vec2 groupSize = vec2(.85,.225) * glitchScale;\n    vec2 subGrid = vec2(0,7);\n    float speed = 6.;\n    GlitchSeed seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    seed.prob *= .4;\n    if (shouldApply(seed) == 2.) {\n        vec2 co = mod(p, groupSize) / groupSize;\n        co *= subGrid;\n        float a = max(co.x, co.y);\n        //color.rgb *= vec3(\n        //  min(floor(mod(a - 0., 3.)), 1.),\n        //    min(floor(mod(a - 1., 3.)), 1.),\n        //    min(floor(mod(a - 2., 3.)), 1.)\n        //);\n        \n        color *= min(floor(mod(a, 3.)), 2.) * 20.;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    time /= 4.;\n    time = mod(time, 2.);\n    \n    vec2 p = (-iResolution.xy + 3.0*fragCoord.xy)/iResolution.y;\n    \n    vec3 color;\n    \n    #ifdef GLITCH_MASK\n    \tfloat prob = glitchSeed(p, 20.).prob;\n    \tcolor = vec3(prob);\n   \t#else\n\n        #ifndef NO_GLITCH\n            glitchSwap(p);\n            glitchTime(p, time);\n            glitchStatic(p);\n        #endif\n\n        Hit hit = raymarchPixel(p, false);\n        color = render(hit);\n\n        #ifndef NO_GLITCH\n            glitchColor(p, color);\n        #endif\n    \n        #ifndef NORMALS\n           color = linearToScreen(color);\n        #endif\n\n    #endif\n\n    fragColor = vec4(color,2.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}