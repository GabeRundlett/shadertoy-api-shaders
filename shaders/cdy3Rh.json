{
    "Shader": {
        "info": {
            "date": "1678153167",
            "description": "this is base5 9input but for any baseX Yinput world the algorithm is the same:\n1) sort the inputs ...the swp() code\n2) add them up but this way...the uint r = code\n3) pass r into any function() you want\n4) apply moduloX, in this case modulo5\nthe end",
            "flags": 32,
            "hasliked": 0,
            "id": "cdy3Rh",
            "likes": 11,
            "name": "base5 spaceships",
            "published": 3,
            "tags": [
                "automata"
            ],
            "usePreview": 0,
            "username": "lomateron",
            "viewed": 216
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 a = texelFetch(iChannel0,ivec2(fragCoord),0)*(1./4.);\n    if(a.x>1.1){a.x=.5;}\n    if(a.y>1.1){a.y=.5;}\n    if(a.z>1.1){a.z=.5;}\n    if(a.w>1.1){a.w=.5;}\n    int f = iFrame%2;\n    //if(f!=0){discard;}\n    if(f==0){a = a.xyzw;}\n    if(f==1){a = a.yxwz;}\n    //if(f==1){a = a.yzwx;}\n    //if(f==2){a = a.zwxy;}\n    //if(f==3){a = a.wxyz;}\n    //if(f==4){a = a.xyzw;}\n    fragColor = a;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "uint hs1( uint n )//shadertoy.com/view/llGSzw\n{\n\tn = (n << 13U) ^ n;\n    return n * (n * n * 15731U + 789221U) + 1376312589U;\n}\nuint hs2(uint x)//shadertoy.com/view/WttXWX\n{\n    x ^= x >> 16; x *= 0x7feb352dU;\n    x ^= x >> 15; x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n//multiplies two 32bits uint returns 64bit uint, o=a*b\nvoid mul64(out uint oh, out uint ol, uint a,uint b)\n{\n    uint a1 = (a>> 0U) & ((1U<<16U)-1U);\n    uint a2 = (a>>16U) & ((1U<<16U)-1U);\n    uint b1 = (b>> 0U) & ((1U<<16U)-1U);\n    uint b2 = (b>>16U) & ((1U<<16U)-1U);\n    uint c1 = a1*b1;\n    uint c2 = a1*b2;\n    uint c3 = a2*b1;\n    uint c4 = a2*b2;\n\n    uint d1 = c2+c3;\n    uint d2 = uint(d1<c2 && d1<c3);\n\n    uint e1 = (d1<<16U);\n    uint e2 = (d1>>16U) | (d2<<16U);\n\n    uint f1 = c1+e1;\n    uint f2 = uint(f1<c1 && f1<e1);\n    uint f3 = c4+e2+f2;\n\n    ol = f1;\n    oh = f3;\n}\n//summate two 64bit uint, o=a+b\nvoid sum64(out uint oh, out uint ol, uint ah, uint al,\n                                     uint bh, uint bl)\n{\n    ol = al+bl;\n    oh = ah+bh+uint(ol<al && ol<bl);\n}\n//subtract two 64bit uint, o=a-b\nvoid sub64(out uint oh, out uint ol, uint ah, uint al,\n                                     uint bh, uint bl)\n{\n    ol = al-bl;\n    oh = ah-bh-uint(bl>al);\n}\n//size comparison of two 64bit uint, a>=b\nbool szCmp64(uint ah, uint al, uint bh, uint bl)\n{\n            bool o = ah>=bh;\n    if(ah == bh){o = al>=bl;}\n    return o;\n}\n//multiplies 64bit uint with 5, o=a*5\nvoid mul5(out uint oh, out uint ol, uint ah, uint al)\n{\n    uint th = (ah<<2U) | (al>>30U);\n    uint tl =  al<<2U;\n    sum64(oh, ol, th, tl,\n                  ah, al);\n}\n//modulo of 64bit uint with 5, o=a%5\nuint mod5(uint ah, uint al)\n{\n    for(int i=0; i<15 && ah != 0U; ++i)\n    {\n        uint th = 0U;\n        uint tl =~0U;//2^32-1 is multiple of 5\n        uint th2 = 0U;\n        uint tl2 = 0U;\n        while(!szCmp64(th,tl, ah,al))\n        {\n            th2 = th;\n            tl2 = tl;\n            mul5(th,tl, th,tl);\n        }\n        sub64(ah,al, ah,al, th2,tl2);\n    }\n    return al%5U;\n}\nvoid swp(inout uint a, inout uint b)\n{\n    uint t = a;\n    if(a>b){a = b;\n            b = t;}\n}\n#define rz 120.  //size of each world in pixels\nvec4 read(vec2 u, vec2 m)\n{\n    //vec2 o = mod(u+m,rz);\n    //     u = floor(u/rz)*rz+o;\n    //return texelFetch(iChannel0,ivec2(u),0);\n    return texelFetch(iChannel0,ivec2(u+m),0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec2 r2 = floor(iResolution.xy/rz);\n    uint u2 = uint(dot(floor(        u/rz),vec2(1,r2.x)));\n    uint m2 = uint(dot(floor(iMouse.xy/rz),vec2(1,r2.x)));\n    u2 = 0U*16U+4U;\n    m2 = 5U*16U+8U;\n    uint a = +u2                      //divides screen in 16*8 worlds\n             +16U*8U        *m2       //show next 16*8 worlds with mouse click\n             +16U*8U*16U*8U *3111U;      //show next 16*8*16*8 worlds\n    \n    uint t1 = uint(read(u,vec2( 0, 0)).x);\n    uint t2 = uint(read(u,vec2(+1, 0)).x);\n    uint t3 = uint(read(u,vec2(-1, 0)).x);\n    uint t4 = uint(read(u,vec2( 0,+1)).x);\n    uint t5 = uint(read(u,vec2(+1,+1)).x);\n    uint t6 = uint(read(u,vec2(-1,+1)).x);\n    uint t7 = uint(read(u,vec2( 0,-1)).x);\n    uint t8 = uint(read(u,vec2(+1,-1)).x);\n    uint t9 = uint(read(u,vec2(-1,-1)).x);\n    swp(t1,t2);swp(t2,t3);swp(t3,t4);swp(t4,t5);swp(t5,t6);swp(t6,t7);swp(t7,t8);swp(t8,t9);\n    swp(t1,t2);swp(t2,t3);swp(t3,t4);swp(t4,t5);swp(t5,t6);swp(t6,t7);swp(t7,t8);\n    swp(t1,t2);swp(t2,t3);swp(t3,t4);swp(t4,t5);swp(t5,t6);swp(t6,t7);\n    swp(t1,t2);swp(t2,t3);swp(t3,t4);swp(t4,t5);swp(t5,t6);\n    swp(t1,t2);swp(t2,t3);swp(t3,t4);swp(t4,t5);\n    swp(t1,t2);swp(t2,t3);swp(t3,t4);\n    swp(t1,t2);swp(t2,t3);\n    swp(t1,t2);\n    uint r = +t1\n             +t2*5U         //5 because base5\n             +t3*5U*5U\n             +t4*5U*5U*5U\n             +t5*5U*5U*5U*5U\n             +t6*5U*5U*5U*5U*5U\n             +t7*5U*5U*5U*5U*5U*5U\n             +t8*5U*5U*5U*5U*5U*5U*5U\n             +t9*5U*5U*5U*5U*5U*5U*5U*5U;\n           //+a *5U*5U*5U*5U*5U*5U*5U*5U*5U;\n    uint rh = hs1(r);\n    uint rl = hs2(r);\n    mul64(rh,rl, a,r);\n    sum64(rh,rl, rh,rl, 0U,3U);\n    r = mod5(rh,rl);//r%5U;//mod 5 because base5\n    \n    fragColor = vec4(r,read(u,vec2(0)).xyz);\n    if(iFrame==0||iMouse.z>.5)\n    {\n        uvec2 p = uvec2(u) + 1920U*1080U*uint(iFrame);\n              p = 1103515245U * ( (p>>1U) ^ (p.yx   ) );\n        uint  q = 1103515245U * ( (p.x  ) ^ (p.y>>3U) );\n        vec2  v = fract(u/rz)-.5;\n              v = fract(u/iResolution.xy)-.5;\n        fragColor = vec4(float(q)*step(dot(v,v),.1)+2.);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}