{
    "Shader": {
        "info": {
            "date": "1542791479",
            "description": "Gear On Descrates",
            "flags": 0,
            "hasliked": 0,
            "id": "4lKBWm",
            "likes": 1,
            "name": "GearDescrates",
            "published": 3,
            "tags": [
                "2d",
                "circle",
                "gear",
                "descrates"
            ],
            "usePreview": 0,
            "username": "zhimo",
            "viewed": 446
        },
        "renderpass": [
            {
                "code": "// Author: 185202204@qq.com\n\n//base on:https://www.shadertoy.com/view/XtKBDD\n//coding by unity shader,github:\n//https://github.com/zhimo1997/ShaderToy\n//more details on my blog :\n//https://blog.csdn.net/qq_36383623/article/details/84237042\n\n\n\n//if uv is in Circle or not\nfloat IsInCircle(vec2 uv,vec2 center,float radius) {\n\tfloat r = distance(uv,center);\n\tif (r < radius) {\n\t\treturn r / radius;\n\t}\n\treturn -1.0;\n}\n\nfloat CaculateAngle(vec2 v1, vec2 v2) {\n\tfloat magnitude1 = sqrt(v1.x*v1.x + v1.y*v1.y);\n\tfloat magnitude2 = sqrt(v2.x*v2.x + v2.y*v2.y);\n\tfloat cosValue = dot(v1, v2) / (magnitude1*magnitude2);\n\tfloat finalAngle = acos(cosValue);\n\tfinalAngle = degrees(finalAngle);\n\n\tvec3 dir = cross(vec3(v1, 0), vec3(v2, 0));\n\tif (dir.z >= 0.0) {\n\t\treturn finalAngle;\n\t}\n\telse{\n\t\treturn 360.0 - finalAngle;\n\t}\n}\n\n//计算点到直线的距离，offset用于平行线\nfloat CaculatePointToAxis(vec2 uv, vec2 center, float slope, float offset) {\n\tfloat val = abs(slope*(uv.x - center.x) + offset - (uv.y - center.y)) / sqrt(1.0 + slope * slope);\n\treturn val;\n}\n\nfloat IsInRect(vec2 uv, vec2 center, float angle, float width, float height) {\n\n\t\tif (angle == 90.0 || angle == 270.0) {\n\t\t\tfloat val1 = abs(uv.x + width * 0.5 - center.x);\n\t\t\tfloat val2 = abs(uv.x - width * 0.5 - center.x);\n\t\t\tfloat val3 = abs(uv.y + height * 0.5 - center.x);\n\t\t\tfloat val4 = abs(uv.y - height * 0.5 - center.x);\n\n\t\t\tif (val1 + val2 <= width + 0.001 && val3 + val4 <= height + 0.001) {\n\t\t\t\treturn 1.0;\n\t\t\t}\n\t\t\treturn 0.0;\n\t\t}\n\t\tif (angle == 0.0 || angle == 180.0) {\n\t\t\tfloat val1 = abs(uv.x + height * 0.5 - center.x);\n\t\t\tfloat val2 = abs(uv.x - height * 0.5 - center.x);\n\t\t\tfloat val3 = abs(uv.y + width * 0.5 - center.x);\n\t\t\tfloat val4 = abs(uv.y - width * 0.5 - center.x);\n\n\t\t\tif (val1 + val2 <= height + 0.001 && val3 + val4 <= width + 0.001) {\n\t\t\t\treturn 1.0;\n\t\t\t}\n\t\t\treturn 0.0;\n\t\t}\n\t\tangle = radians(angle);\n\t\tfloat slope = tan(angle);\n\t\tfloat offset1 = width * 0.5 * sqrt(1.0 + slope * slope);\n\t\tfloat val1 = CaculatePointToAxis(uv, center, slope, offset1);\n\t\tfloat val2 = CaculatePointToAxis(uv, center, slope, -offset1);\n\n\t\tslope = -1.0 / slope;\n\t\tfloat offset2 = height * 0.5 * sqrt(1.0 + slope * slope);\n\t\tfloat val3 = CaculatePointToAxis(uv, center, slope, offset2);\n\t\tfloat val4 = CaculatePointToAxis(uv, center, slope, -offset2);\n\n\t\tif (val1 + val2 <= width + 0.001 && val3 + val4 <= height + 0.001) {\n\t\t\treturn 1.0;\n\t\t}\n\t\treturn 0.0;\n\t}\n\nfloat CalculateRadius(float r1,float r2,float r4) {\n\tfloat k1 = 1.0/ r1;\n\tfloat k2 = 1.0/ r2;\n\tfloat k4 = 1.0/ r4;\n\n\tfloat t1 = k1 + k2 - k4;\n\tfloat t2 = k1 * k1 + k2 * k2 + k4 * k4;\n\t\t\n\tfloat a = 1.0;\n\tfloat b = -2.0*t1;\n\tfloat c = 2.0 * t2 - t1 * t1;\n\tfloat delta = b * b - 4.0 * a*c;\n\tif (delta < 0.0) {\n\t\treturn -1.0;\n\t}\n\tfloat d1 =( -b + sqrt(delta))/(2.0*a);\n\t//float d2 =（ -b - sqrt(delta)）/(2.0*a);\n\treturn 1.0/d1;\n}\n\nvec4 CaculateFourthCircleCenter(vec2 center1,vec2 center2,float r1,float r2) {\n\tfloat m = -(center2.x-center1.x)/(center2.y-center1.y);\n\tfloat n = 0.5*((r2*r2-r1*r1)/(center1.y-center2.y)+center2.y+center1.y+(center1.x*center1.x-center2.x*center2.x)/(center1.y-center2.y));\n\tfloat a = 1.0 + m * m;\n\tfloat b = 2.0 * m*(n - center1.y) - 2.0*center1.x;\n\tfloat c = center1.x*center1.x + (n-center1.y)*(n-center1.y) - r1 * r1;\n\tfloat x1 = (-b + sqrt(b*b-4.0*a*c))/(2.0*a);\n\tfloat y1 = m * x1 + n;\n\tfloat x2 = (-b - sqrt(b*b - 4.0 * a*c)) / (2.0 * a);\n\tfloat y2 = m * x2 + n;\n\n\tvec3 v0 = vec3(center1.x-center2.x,center1.y-center2.y,0.0);\n\tvec3 v1 = vec3(center1.x-x1,center1.y-y1,0.0);\n\tvec3 t = cross(v0, v1);\n\tif ( t.z>= 0.0) {\n\t\treturn vec4(x1,y1,x2,y2);\n\t}\n\treturn vec4(x2,y2,x1,y1);\n\t\t\n}\n\nvec4 DrawCircle(vec2 uv,vec2 center,float radius,vec4 centerColor,vec4 contourCol) {\n    float aspect = distance(uv,center)/radius;\n    float alpha = aspect;\n\tfloat angle = CaculateAngle(vec2(1,0),uv-center);\n    float ColorRotateSpeed=10.0;\n\tangle = mod(angle+ColorRotateSpeed*iTime,360.0);\n\tfloat index =floor(angle/20.0);\n\t//alpha = index * alpha;\n\talpha *= abs(0.5-index / 18.0);\n\treturn mix(centerColor,contourCol,alpha);\n}\n\n//return the background color\nvec4 DrawBg(vec2 uv){\n    \n    float aspect1=iResolution.x/iResolution.y;\n    vec2 center=vec2(0.5*aspect1,0.5);\n   \n    float angle = CaculateAngle(vec2(1,0),uv-center);\n    float ColorRotateSpeed=-80.0;\n\tangle = mod(angle+ColorRotateSpeed*iTime,360.0);\n\tfloat index =floor(angle/15.0);\n\t//alpha = index * alpha;\n\t//float alpha *= abs(0.5-index / 18.0);\n\t\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)*index);\n    return vec4(col,1);\n}\n\nfloat IsInGear(vec2 uv, vec2 center, float radius, vec4 centerColor, vec4 contourColor, float toothWidth, float toothDepth, float rearSpeed) {\n\tfloat aspect1=iResolution.x/iResolution.y;\n    float centerOffsetScale =0.07;\n\tcenter = center + centerOffsetScale * (vec2(0.5*aspect1,0.5)-center);\n\tfloat offsetDepth = 0.05;\n    offsetDepth=offsetDepth*radius;\n\tradius -= offsetDepth;\n\tif (IsInCircle(uv, center, radius) < 0.0) {\n\t\t//return DrawBg();\n\t\treturn 0.0;\n\t}\n\tfloat rectWidth = toothWidth * radius;\n\tfloat rectHeight = (radius) * 2.0;\n\tradius = radius - toothDepth * radius;\n\t\t\n    float aspect = IsInCircle(uv, center, radius);\n\n\tif (aspect >= 0.0) {\n\t\t//return DrawCircle(uv, center, aspect, centerColor, contourColor);\n\t\treturn 1.0;\n\t}\n\t\t\n\trearSpeed *= (1.0 / radius);\n\t//float angle = _RotateSpeed * _Time.y;\n\tfor (int j = 0; j < 12; j++) {\n\t\tfloat angle = float(j) * 15.0;\n\t\t\t\n\t\tangle += rearSpeed;\n\t\tif (IsInRect(uv, center, angle, rectWidth, rectHeight) > 0.5) {\n\t\t\treturn 1.0;\n\t\t}\n\t}\n\n\t\treturn 0.0;\n\t}\n\n\tfloat IsInGearContour(vec2 uv, vec2 center, float radius, vec4 centerColor, vec4 contourColor, float toothWidth, float toothDepth, float contourDepth, float rearSpeed) {\n\t\tfloat rectHeight = (radius - contourDepth) * 2.0;\n\t\tfloat rectWidth = toothWidth * radius;\n\t\tif (IsInCircle(uv, center, radius) < 0.0) {\n\t\t\t//return DrawBg();\n\t\t\treturn 0.0;\n\t\t}\n\t\tradius = (radius - (toothDepth + contourDepth) * radius);\n\t\tfloat aspect = IsInCircle(uv, center, radius);\n\t\tif (aspect >= 0.0) {\n\t\t\t//return DrawCircle(uv, center, aspect, centerColor, contourColor);\n\t\t\treturn 0.0;\n\t\t}\n\n\n\n\t\t//float angle = _RotateSpeed * _Time.y;\n\t\trearSpeed *= (1.0 / radius);\n\t\tfor (int j = 0; j < 18; j++) {\n\t\t\tfloat angle = float(j) * 10.0;\n\n\t\t\tangle += rearSpeed;\n\t\t\tif (IsInRect(uv, center, angle, rectWidth, rectHeight) > 0.5) {\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t}\n\n\t\treturn 1.0;\n\t}\n\n//draw the shape of Descrates\nvec4 DrawDescrates(vec2 uv){\n    float aspect=iResolution.x/iResolution.y;\n    \n    float rearSpeed =15.0;\n    rearSpeed*= iTime;\n    float ToothWidth=0.1;\n    float ToothDepth=0.05;\n    \n    float ContourDepth=0.02;\n    float ContourToothWidth=0.07;\n    float ContourToothDepth=0.06;\n    \n    float RotateSpeed=0.001;\n    float angle = RotateSpeed * iTime;\n    float ScaleChangeSpeed=0.0;\n\tfloat scale = 0.1*(sin(ScaleChangeSpeed*iTime));\n    float CenterX=0.5;\n    float CenterY=0.5;\n\tvec2 center = vec2(CenterX,CenterY);\n    center.x*=aspect;\n\tfloat radius = 0.5;\n\tfloat R[5];\n\tvec2 CircleCenter[5];\n\t//计算各个圆的半径及圆心\n\tint Amount = 5;\n\tR[0] = radius;\n\tCircleCenter[0] = vec2(CenterX, CenterY);\n    CircleCenter[0].x*=aspect;\n\n    float radius2=0.35;\n\tR[1] = radius2+scale;\n\t//CircleCenter[1].x = CircleCenter[0].x - (R[0] - R[1]);\n\t//CircleCenter[1].y = CircleCenter[0].y;\n\tCircleCenter[1].x = CircleCenter[0].x - (R[0] - R[1])*cos(angle);\n\tCircleCenter[1].y = CircleCenter[0].y + (R[0] - R[1])*sin(angle);\n\t\t\n\tR[2] = R[0] - R[1]-0.0001;\n\tfloat l = (R[0]-R[1]) / (R[1]+R[2]);\n\tCircleCenter[2] = CircleCenter[1]-(1.0/l)*(CircleCenter[1]-CircleCenter[0]);\n\n\tvec4 CenterColor = vec4(0.7,0.9,0.9,1.0);\n\tvec4 ContourColor = vec4(0.8,0,0.4,1.0);\n\n\tvec4 centerColor;\n    vec4 contourColor;\n    \n   \n    \n    \n\t//第一个内圆\n\t//float flag = IsInCircle(uv, CircleCenter[1], R[1]);\n\tif (IsInGear(uv, CircleCenter[1], R[1], centerColor, contourColor, ToothWidth, ToothDepth,  -rearSpeed) >= 0.5) {\n\t\tcenterColor = mix(CenterColor, ContourColor, 0.7);\n\t\tcontourColor = mix(ContourColor, CenterColor, 0.7);\n\t\treturn DrawCircle(uv, CircleCenter[1],R[1], centerColor, contourColor);\n\t}\n    \n\t//第二个内圆\n\t//flag = IsInCircle(uv, CircleCenter[2], R[2]);\n\tif (IsInGear(uv, CircleCenter[2], R[2], centerColor, contourColor, ToothWidth, ToothDepth,  -rearSpeed) >= 0.5) {\n\t\tcenterColor = mix(CenterColor, ContourColor, 0.3);\n\t\tcontourColor = mix(ContourColor, CenterColor, 0.3);\n\t\treturn DrawCircle(uv, CircleCenter[2],R[2], centerColor, contourColor);\n\t}\n\t\n\t//第三个内圆\n\tfloat r = CalculateRadius(R[1], R[2], R[0]);\n\n\tif (r < 0.0) {\n\t\treturn vec4(0, 0, 0, 1);\n\t}\n\n\tvec4 center4 = CaculateFourthCircleCenter(CircleCenter[1], CircleCenter[2], R[1] + r, R[2] + r);\n\t//center4.x*=aspect;\n    //center4.z*=aspect;\n    //float2 center4 = CaculateFourthCircleCenter(CircleCenter[0],float2(0.35,0.5), float2(0.85, 0.5), R[0], R[1] + r, R[2] + r);\n\t//flag = IsInCircle(uv, center4.xy, r);\n\tif (IsInGear(uv, center4.xy, r, centerColor, contourColor, ToothWidth, ToothDepth, -rearSpeed) >= 0.5) {\n\t\t//return fixed4(0,0,0,1);\n\t\tcenterColor = mix(CenterColor, ContourColor, 0.4);\n\t\tcontourColor = mix(ContourColor, CenterColor, 0.4);\n\t\treturn DrawCircle(uv, center4.xy,r, centerColor, contourColor);\n\t}\n    //return vec4(1,0,0.5,1);\n\t\t//flag = IsInCircle(uv, center4.zw, r);\n\t\tif (IsInGear(uv, center4.zw, r, centerColor, contourColor, ToothWidth, ToothDepth, -rearSpeed) >= 0.5) {\n\t\t\t//return fixed4(0,0,0,1);\n\t\t\tcenterColor = mix(CenterColor, ContourColor, 0.4);\n\t\t\tcontourColor = mix(ContourColor, CenterColor, 0.4);\n\t\t\treturn DrawCircle(uv, center4.zw,r, centerColor, contourColor);\n\t\t}\n\n\t\tCircleCenter[3] = center4.xy;\n\t\tR[3] = r;\n\n\t\tCircleCenter[4] = center4.zw;\n\t\tR[4] = r;\n\n\t\tint amount = 6;\n\t\tfor (int j = 0; j < amount; j++) {\n\t\t\tr = CalculateRadius(R[1],R[3],R[0]);\n\t\t\tcenter4 = CaculateFourthCircleCenter(CircleCenter[1], CircleCenter[3], R[1] + r, R[3] + r);\n\t\t\t//flag = IsInCircle(uv, center4.xy, r);\n\t\t\tif (IsInGear(uv, center4.xy, r, centerColor, contourColor, ToothWidth, ToothDepth, -rearSpeed) >= 0.5) {\n\t\t\t\t//return fixed4(1,1,1,1);\n\t\t\t\tcenterColor = mix(CenterColor, ContourColor, 0.5+float(j)*0.1);\n\t\t\t\tcontourColor = mix(ContourColor, CenterColor, 0.5+float(j)*0.1);\n\t\t\t\treturn DrawCircle(uv, center4.xy,r, centerColor, contourColor);\n\t\t\t}\n\t\t\tCircleCenter[3] = center4.xy;\n\t\t\tR[3] = r;\n\t\t}\n\n\t\tfor (int j = 0; j < amount; j++) {\n\t\t\tr = CalculateRadius(R[1], R[4], R[0]);\n\t\t\tcenter4 = CaculateFourthCircleCenter(CircleCenter[1], CircleCenter[4], R[1] + r, R[4] + r);\n\t\t\t//flag = IsInCircle(uv, center4.zw, r);\n\t\t\tif (IsInGear(uv, center4.zw, r, centerColor, contourColor, ToothWidth, ToothDepth, -rearSpeed) >= 0.5) {\n\t\t\t\t//return fixed4(0,0,0,1);\n\t\t\t\tcenterColor = mix(CenterColor, ContourColor, 0.5 + float(j) * 0.1);\n\t\t\t\tcontourColor = mix(ContourColor, CenterColor, 0.5 + float(j) * 0.1);\n\t\t\t\treturn DrawCircle(uv, center4.zw,r, centerColor, contourColor);\n\t\t\t}\n\t\t\tCircleCenter[4] = center4.zw;\n\t\t\tR[4] = r;\n\t\t}\n\t\t\n\t\t//contourColor=vec4(0.7,0.9,0.9,1);\n\t\t//flag = IsInCircle(uv, CircleCenter[0], R[0]);\n\t\tif (IsInGearContour(uv, CircleCenter[0], R[0], centerColor, contourColor, ContourToothWidth, ContourToothDepth,ContourDepth, -rearSpeed) >= 0.5) {\n\t\t\tcenterColor = mix(CenterColor, ContourColor, 0.0);\n\t\t\tcontourColor = mix(ContourColor, CenterColor, 0.0);\n\t\t\treturn DrawCircle(uv, CircleCenter[0],R[0], centerColor, contourColor);\n\t\t}\n\n\t\treturn DrawBg(uv);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect=iResolution.x/iResolution.y;\n    uv.x=uv.x*aspect;\n\n   fragColor=DrawDescrates(uv);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}