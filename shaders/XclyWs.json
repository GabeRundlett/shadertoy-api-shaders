{
    "Shader": {
        "info": {
            "date": "1726861361",
            "description": "CIE 1931 xy chromaticity diagram, displayed in sRGB. Chromaticities outside of the sRGB gamut are desaturated to the edge of gamut. The spectral locus uses an approximation of the XYZ color matching functions, and has considerable inaccuracies.",
            "flags": 0,
            "hasliked": 0,
            "id": "XclyWs",
            "likes": 4,
            "name": "xy Chromaticity Diagram",
            "published": 3,
            "tags": [
                "color",
                "rgb",
                "perception",
                "colorspace",
                "srgb",
                "gamut",
                "cie",
                "chromaticity"
            ],
            "usePreview": 0,
            "username": "SpinningCube",
            "viewed": 74
        },
        "renderpass": [
            {
                "code": "/*\n * xy Chromaticity Diagram\n * https://www.shadertoy.com/view/XclyWs\n * by SpinningCube\n *\n * CIE 1931 xy chromaticity diagram, displayed in sRGB. The\n * spectral locus and the boundary of the sRGB gamut are shown.\n * Chromaticities outside of the sRGB gamut are desaturated to the\n * edge of gamut. Thus, the colors inside the triangle are the most\n * accurate, while the colors outside the triangle are less accurate,\n * preserving hue but not saturation. The spectral locus uses an\n * approximation of the XYZ color matching functions, and, while it\n * gives a good general shape, has considerable inaccuracies.\n */\n\n// Triangle SDF by iq\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n// Segment SDF by iq\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec3 segmentIntersection(vec2 a1, vec2 a2, vec2 b1, vec2 b2) {\n    vec2 deltaA = a2 - a1;\n    vec2 deltaB = b2 - b1;\n    \n    float t = (deltaA.x * (b1.y - a1.y) - deltaA.y * (b1.x - a1.x))/(deltaA.y * deltaB.x - deltaA.x * deltaB.y);\n    return vec3(b1 + t * deltaB, t);\n}\n\nfloat g(float x, float peak, float falloffLeft, float falloffRight) {\n    float value = x - peak;\n    value = -0.5 * (value * value);\n    if (x < peak) {\n        return exp(falloffLeft * falloffLeft * value);\n    } else {\n        return exp(falloffRight * falloffRight * value);\n    }\n}\n\nvec3 wavelengthToXYZ(float wavelength) {\n    // Approximation of CIE 1931 color matching functions, from Wikipedia\n    return vec3(\n        1.056 * g(wavelength, 599.8, 0.0264, 0.0323) + 0.362 * g(wavelength, 442.0, 0.0624, 0.0374) - 0.065 * g(wavelength, 501.1, 0.0490, 0.0382),\n        0.821 * g(wavelength, 568.8, 0.0213, 0.0247) + 0.286 * g(wavelength, 530.9, 0.0613, 0.0322),\n        1.217 * g(wavelength, 437.0, 0.0845, 0.0278) + 0.681 * g(wavelength, 459.0, 0.0385, 0.0725)\n    );\n}\n\nfloat distToWavelengths(vec2 uv) {\n    float dist = 10.0;\n    float wavelength = 440.0;\n    vec3 XYZ = wavelengthToXYZ(wavelength);\n    vec2 prev_xy = XYZ.xy/(XYZ.x + XYZ.y + XYZ.z);\n    for (; wavelength < 648.0; wavelength += 2.0) {\n        vec3 XYZ = wavelengthToXYZ(wavelength);\n        vec2 xy = XYZ.xy/(XYZ.x + XYZ.y + XYZ.z);\n        dist = min(dist, sdSegment(uv, xy, prev_xy));\n        prev_xy = xy;\n    }\n    XYZ = wavelengthToXYZ(440.0);\n    dist = min(dist, sdSegment(uv, XYZ.xy/(XYZ.x + XYZ.y + XYZ.z), prev_xy));\n    return dist;\n}\n\nmat3 XYZtoCIERGB = mat3(2.3646, -0.5152,  0.0052,\n                       -0.8965,  1.4264, -0.0144,\n                       -0.4681,  0.0888,  1.0092);\n\nmat3 XYZtoSRGB = mat3(3.2406, -0.9689,  0.0557,\n                     -1.5372,  1.8758, -0.2040,\n                     -0.4986,  0.0415,  1.0570);\n\nvec2 sRGB_red = vec2(0.64, 0.33);\nvec2 sRGB_green = vec2(0.3, 0.6);\nvec2 sRGB_blue = vec2(0.15, 0.06);\nvec2 D65_whitepoint = vec2(0.31272, 0.32903);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // xy coordinates\n    vec2 xy = (fragCoord - vec2(0.5, 0) * iResolution.xy)/iResolution.y + vec2(0.5, 0.0);\n    float px = 1.0/iResolution.y;\n    \n    float distTriangle = sdTriangle(xy, sRGB_red, sRGB_green, sRGB_blue);\n    float distToWavelengths = distToWavelengths(xy);\n    \n    vec3 col = vec3(0.0);\n    if (xy.x >= 0.0 && xy.x <= 1.0) {\n        \n        if (distTriangle > 0.0) {\n            // If out of gamut, desaturate chromaticity to the edge of gamut\n            vec3 i1 = segmentIntersection(D65_whitepoint, xy, sRGB_red, sRGB_green);\n            vec3 i2 = segmentIntersection(D65_whitepoint, xy, sRGB_red, sRGB_blue);\n            vec3 i3 = segmentIntersection(D65_whitepoint, xy, sRGB_green, sRGB_blue);\n            \n            vec2 closestXY = vec2(2.0);\n            float minDist = 10.0;\n            \n            float dist = distance(xy, i1.xy);\n            if (i1.z >= 0.0 && i1.z <= 1.0 && dist < minDist) {\n                closestXY = i1.xy;\n                minDist = dist;\n            }\n            \n            dist = distance(xy, i2.xy);\n            if (i2.z >= 0.0 && i2.z <= 1.0 && dist < minDist) {\n                closestXY = i2.xy;\n                minDist = dist;\n            }\n            \n            dist = distance(xy, i3.xy);\n            if (i3.z >= 0.0 && i3.z <= 1.0 && dist < minDist) {\n                closestXY = i3.xy;\n                minDist = dist;\n            }\n            \n            xy = closestXY;\n        }\n        \n        float Y = 1.0;\n        float y_ratio = Y / xy.y;\n        vec3 XYZ = vec3(xy.x * y_ratio, Y, (1.0 - xy.x - xy.y) * y_ratio);\n        \n        col = XYZtoSRGB * XYZ;\n        //col /= 13.9; // darken for equal luminance display\n        //col /= max(col.r, max(col.g, col.b)); // maximize brightness\n        col = normalize(col); // euclidean normalization\n        //col = vec3(xy, 0.0);\n    }\n    \n    float edgeDist = abs(distTriangle) - 0.0007;\n    \n    #if 0\n        // Show only sRGB gamut\n        col *= 1.0 - clamp(distTriangle/px, 0.0, 1.0);\n    #else\n        // sRGB gamut outline\n        col = mix(vec3(0.0), col, clamp(edgeDist/px, 0.0, 1.0));\n    #endif\n    \n    col = mix(vec3(0.0), col, clamp((distToWavelengths - 0.0007)/px, 0.0, 1.0));\n    //col = vec3(distToWavelengths);\n    \n    col = pow(col, vec3(1.0/2.2));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}