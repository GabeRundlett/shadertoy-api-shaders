{
    "Shader": {
        "info": {
            "date": "1673932269",
            "description": "Extruded 2D kifs on a wobbly refractive plane, a bit untamed and rough around the edges but I like the look :)\n\nTips and criticism more than welcome! (particularly when it comes to performance, I'm guessing it could be a lot better)",
            "flags": 0,
            "hasliked": 0,
            "id": "mlS3DV",
            "likes": 87,
            "name": "kifs walls ",
            "published": 3,
            "tags": [
                "raymarching",
                "refraction",
                "kifs"
            ],
            "usePreview": 0,
            "username": "dsa8",
            "viewed": 7498
        },
        "renderpass": [
            {
                "code": "\n#define PI 3.14159265359\n#define FLT_MAX 3.402823466e+38\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\n\n\nmat2 rot(float a) {\n    float ca =cos(a);\n    float sa=sin(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\n//------------------\n\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n// https://www.shadertoy.com/view/wlyBWm\nvec2 smoothrepeat_asin_sin(vec2 p,float smooth_size,float size){\n    p/=size;\n    p=asin(sin(p)*(1.0-smooth_size));\n    return p*size;\n}\n\n//--------------\n\n// don't remember were i took this from but I think I started from here \n// https://www.researchgate.net/publication/300124211_Interactive_Procedural_Building_Generation_Using_Kaleidoscopic_Iterated_Function_Systems\nvec2 dKifs(vec2 p, vec2 c, float s, float t1, float t2) {\n    float r2 = p.x*p.x+p.y*p.y;\n    float i;\n    for (i=0.;i<6. && r2 < 1000.; i++) {\n        p *= rot(t1);\n        \n        p = abs(p);\n        if (p.x - p.y < 0.) {\n            float x1=p.y;\n            p.y = p.x;\n            p.x = x1;\n        }\n        \n        p *= rot(t2);\n        \n        p.x = s*p.x-c.x*(s-1.);\n        p.y=s*p.y;\n        if(p.y>0.5*c.y*(s-1.)) p.y-=c.y*(s-1.);\n      \n        p.y += .1 *s;\n        p.y*=p.y*.45;\n        p.x -= .2 *s;\n        \n        r2 = p.x*p.x+p.y*p.y;\n    }\n    \n    return vec2( (sqrt(r2)-2.)*pow(s,-i), i);\n}\n\nvec3 camPos;\nvec2 map( in vec3 p ) {\n    float d = FLT_MAX;\n    float mat = -1.;\n    \n    vec2 f;\n    // extruded fractal\n    {\n    vec3 q = p;\n    q.xy = smoothrepeat_asin_sin(p.xy,.04, 4.0);\n    float c = 15.;\n    float zId = ceil((q.z+.5*c) / c);\n    q.z = mod(q.z+.5*c, c)-.5*c;\n\n    float r1 = 0.2 + hash(zId*1234.)*.75 + smoothstep(0., .2, sin((camPos.z+1.5)*PI / 15.)) *.15 ;\n    float r2 = mix(0.2, 0.5, hash(zId*4312.));\n    f = dKifs( q.xy*.2, vec2(1.), 3., r1, r2);\n    \n    if ( f.x < d ) mat = 0.;\n    d = min(d,opExtrussion( q, f.x, .5) ) - 0.002;\n    }\n\n    \n    // plane\n    {\n    vec3 q = p;\n    float c = 15.;\n    q.z = mod(q.z+.5*c, c)-.5*c;\n    \n    q.xy *= .5;\n    float s = 1.0;\n\tfloat t = 0.0;\n\tfor( int i=0; i<2; i++ )\n\t{\n        t += s*.5*(cos(6.2831*q.x+iTime*5.) + cos(6.2831*q.y+iTime*2.));;\n\t\ts *= 0.5 + 0.1*t;\n        q.xy = 0.97*mat2(1.6,-1.2,1.2,1.6)*q.xy + (t-0.5)*0.2;\n\t}\n    \n    float dP = abs(q.z  - 0.01 - (cos(q.x*4.+iTime)*.5+.5)*.02 );\n    if (dP-.3 < d) mat = 1.;\n    d = sminCubic( d,  dP, .6 );\n    }\n    \n    return vec2(d, mat);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ).x );\n}\n \n// https://www.shadertoy.com/view/MdS3Rw\nfloat ao( vec3 v, vec3 n ) {\n\tfloat sum = 0.0;\n\tfloat att = 3.0;\n    float aoStep = .1;\n    float aoScale = .3;\n\tfloat len = aoStep;\n\tfor ( int i = 0; i < 4; i++ ) {\n\t\tsum += ( len - map( v + n * len ).x ) * att;\n\t\t\n\t\tlen += aoStep;\n\t\t\n\t\tatt *= 0.5;\n\t}\n\t\n\treturn max( 1.0 - sum * aoScale, 0.0 );\n}\n\n// https://www.shadertoy.com/view/flGyDd\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\nvec3 aces_approx(vec3 v)\n{\n    v = max(v, 0.0);\n    v *= 0.6f;\n    float a = 2.51f;\n    a = 2.;\n    float b = 0.03f;\n    float c = 2.43f;\n    c = 1.;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nvec3 postProcess(vec3 col) {\n    col -= .1;\n    col += col*col*.4;\n    col = aces_approx(col);\n    col = sRGB(col);\n    return col;\n}\n\nvec2 march(vec3 ro, vec3 rd, float tmax, inout float t, int iMax, float e, float hStep) {\n    vec2 h;\n    for( int i=0; i<iMax; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        h = map(pos);\n        if( h.x<e || t>tmax ) break;\n        t += h.x*hStep;\n    }\n    return h;\n}\n\nvec3 shade(vec3 pos, vec3 nor, vec3 ro, vec3 rd, float t) {\n    vec3 col = vec3(0.15,0.25,0.4);\n    float m = mod(pos.z, 15.);\n    col *= pow(1.-mod(pos.z, 15.)/15., 80.)*6.5;\n    \n    float fractal = 1.-step(m, .1);\n    vec3 lDir = vec3(0.57703);\n    lDir = normalize(vec3(0.3, .6, .6));\n    float dif = clamp( dot(nor, lDir), 0.0, 1.0 );\n    vec3  ref   = reflect(rd, nor);\n    float spec  = max(dot(ref, lDir), 0.0);\n    col += (spec*.5 + dif * vec3(.1, .15, .25)*.5) * fractal *.8;\n    \n    float plane = step(m, .3);\n    col = clamp(col + -.2 * plane, 0., 1.);\n    col += plane * col * col * .7;\n    \n    return col;\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ro = vec3(0., 0., 15. - iTime*2.5);\n    camPos = ro;\n    vec3 ta = vec3( 0.0, 0., 0.0 - iTime*2.5 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    \n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        rd.xy *= rot(sin(iTime*PI/7.5)*.4);\n        rd.xz *= rot(sin(iTime*PI/7.5 * 2.)*.15);\n        \n        // raymarch\n        float tmax = 40.0;\n        float t = 0.0;\n        vec2 h = march(ro, rd, tmax, t, 40, 0.005, .8);\n    \n        // shading/lighting\t\n        vec3 col = vec3(0.);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            col = shade(pos, nor, ro, rd, t);\n\n            float ao = clamp(pow(ao(pos,nor),5.)*3., 0., 1.);\n            col = vec3(ao) * col;\n            // thin layer transparent material or something \n            if ( h.y == 1.) {\n               vec3 ro2 = pos - nor * .5;\n               // interpolation suggest by alro ty :)\n               float ior = mix(1.2, 1., smoothstep(0.9, 1., cos(ro.z*PI / 7.5 - .3) ) );\n               vec3 rd2 = refract(rd, nor, ior);\n               // raymarch again\n               tmax = 60.;\n               t = 0.;\n               vec2 h2 = march(ro2, rd2, tmax, t, 50, 0.01, 1.);\n               // shade again\n               vec3 col2 = vec3(0.);\n               if (t<tmax) {\n                   vec3 pos2 = ro2 + t*rd2;\n                   vec3 nor2 = calcNormal(pos2);\n                   col2 = shade(pos2, nor2, ro2, rd2, t);\n               }\n               col = mix(col, col2, .5);\n            }\n        }\n        \n        col = postProcess(col); // doing it here reduces some artifacts\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n    \n    //tot = postProcess(tot);\n\n\tfragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}