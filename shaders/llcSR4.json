{
    "Shader": {
        "info": {
            "date": "1478367785",
            "description": "Lengyel-Epstein reaction-diffusion test, using almost the same code as my [url=https://www.shadertoy.com/view/XdG3WG]Gray-Scott RD demo[/url]. After some time, spirals form.\nEDIT 6.11.2016: added mouse control",
            "flags": 32,
            "hasliked": 0,
            "id": "llcSR4",
            "likes": 11,
            "name": "Lengyel-Epstein",
            "published": 3,
            "tags": [
                "2d",
                "diffusion",
                "reactiondiffusion",
                "reaction",
                "lengyelepstein"
            ],
            "usePreview": 0,
            "username": "piotrekli",
            "viewed": 765
        },
        "renderpass": [
            {
                "code": "float sampleLightY(sampler2D channel, vec2 fragCoord)\n{\n    float light = 0.0;\n#   define S(DX, DY, WEIGHT) light += texture(channel, (fragCoord+vec2(DX, DY))/iResolution.xy).y*WEIGHT;\n    S( 0,  1, -0.2)\n    S( 0, -1,  0.2)\n    S( 1,  0,  0.2)\n    S(-1,  0, -0.2)\n#   undef S\n    return light;\n}\n\nvec3 hsv2rgb(vec3 hsv)\n{\n    vec3 rgb;\n    float h = mod(hsv.x * 6.0, 6.0);\n    float q = h-float(int(h));\n    if      (h < 1.0) rgb = vec3( 1.0,    q,  0.0);\n    else if (h < 2.0) rgb = vec3(1.-q,  1.0,  0.0);\n    else if (h < 3.0) rgb = vec3( 0.0,  1.0,    q);\n    else if (h < 4.0) rgb = vec3( 0.0, 1.-q,  1.0);\n    else if (h < 5.0) rgb = vec3(   q,  0.0,  1.0);\n    else if (h < 6.0) rgb = vec3( 1.0,  0.0, 1.-q);\n    rgb = hsv.z*(1.0-hsv.y*(1.0-rgb));\n    return rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float uValue = texture(iChannel0, uv).x/3.0+0.87;\n    float light = sampleLightY(iChannel0, fragCoord)*3.0;\n\tfragColor = vec4(hsv2rgb(vec3(1.0-uValue*0.8-0.16,\n                                  light > 0.0 ? 1.-light : 1.,\n                                  light > 0.0 ? 1. : 1.+light)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define DX 0.75 /* scale */\n#define DY 0.1 /* scale */\n#define k1 0.4\n#define k2 0.08\n#define k3 0.04\n#define u  0.2\n#define SPEED 0.25 /* timestep */\n\n/* Source:\nLengyel, István; Epstein, Irving R. (1991), \"Modeling of Turing Structures in the Chlorite—Iodide—Malonic Acid—Starch\n                                             Reaction System\", Science vol. 251 issue 4994 pp. 650-652*/\n\nvec2 random(vec2 uv)\n{\n    return texture(iChannel3, uv).xy;\n}\n\n// function from http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment\n/*float segmentDistance(vec2 v, vec2 w, vec2 p)\n{\n    float l2 = dot(w-v, w-v);\n    if (l2 == 0.0) return distance(p, v);\n    float t = max(0.0, min(1.0, dot(p-v, w-v)/l2));\n    vec2 projection = v + t*(w-v);\n    return distance(p, projection);\n}*/\n\nvec2 cr(vec2 xy)\n{\n    return mod(xy, iResolution.xy);\n}\n\n#define S(DX, DY, WEIGHT) laplacian += texture(channel, cr(fragCoord+vec2(DX, DY))/iResolution.xy).xy*WEIGHT;\nvec2 laplacian(sampler2D channel, vec2 fragCoord)\n{\n    vec2 laplacian = vec2(0.0);\n    S( 0,  0, -1.0)\n    S( 0,  1,  0.2)\n    S( 0, -1,  0.2)\n    S( 1,  0,  0.2)\n    S(-1,  0,  0.2)\n    S( 1,  1,  0.05)\n    S( 1, -1,  0.05)\n    S(-1,  1,  0.05)\n    S(-1, -1,  0.05)\n    return laplacian;\n}\n#undef S\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 prevColor = texture(iChannel0, uv);\n    float x = prevColor.x;\n    float y = prevColor.y;\n    if (iFrame < 10 || iTime < 1.0)\n    {\n        vec2 rand = pow(random(uv), vec2(3.0));\n        x = rand.x*2.0;\n        y = rand.y*3.0+2.0;\n    }\n    else\n    {\n        float rate1 = k2*x;\n        float rate2 = k3*x*y/(u+x*x);\n        vec2 diffusion = laplacian(iChannel0, fragCoord);\n        float deltaX = diffusion.x*DX - rate1 - 4.0*rate2 + k1;\n        float deltaY = diffusion.y*DY + rate1 - rate2;\n        /*float g = // mouse\n            2.0 - segmentDistance(texture(iChannel1, vec2(0.0)).xy,\n                                  texture(iChannel1, vec2(1.0)).xy, fragCoord)*0.1;\n        g = pow(g, 0.4)*5.0;\n        //float g = (iMouse.w > 0.0 ? 0.0 : length(iMouse.xy-fragCoord) < 30.0 ? 5.0 : 0.0);\n        if (g > y) y = g;*/\n        if (iMouse.z > 0.0)\n        {\n            float g = // mouse\n                length(iMouse.xy-fragCoord)*0.1 + 0.25;\n            if (g < y) y = g;\n        }\n        float dt = SPEED;\n        x += deltaX * dt;\n        y += deltaY * dt;\n    }\n    fragColor = vec4(x, y, 0.0, 0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define DX 0.75 /* scale */\n#define DY 0.1 /* scale */\n#define k1 0.4\n#define k2 0.08\n#define k3 0.04\n#define u  0.2\n#define SPEED 0.25 /* timestep */\n\n/* Source:\nLengyel, István; Epstein, Irving R. (1991), \"Modeling of Turing Structures in the Chlorite—Iodide—Malonic Acid—Starch\n                                             Reaction System\", Science vol. 251 issue 4994 pp. 650-652*/\n\nvec2 random(vec2 uv)\n{\n    return texture(iChannel3, uv).xy;\n}\n\n// function from http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment\n/*float segmentDistance(vec2 v, vec2 w, vec2 p)\n{\n    float l2 = dot(w-v, w-v);\n    if (l2 == 0.0) return distance(p, v);\n    float t = max(0.0, min(1.0, dot(p-v, w-v)/l2));\n    vec2 projection = v + t*(w-v);\n    return distance(p, projection);\n}*/\n\nvec2 cr(vec2 xy)\n{\n    return mod(xy, iResolution.xy);\n}\n\n#define S(DX, DY, WEIGHT) laplacian += texture(channel, cr(fragCoord+vec2(DX, DY))/iResolution.xy).xy*WEIGHT;\nvec2 laplacian(sampler2D channel, vec2 fragCoord)\n{\n    vec2 laplacian = vec2(0.0);\n    S( 0,  0, -1.0)\n    S( 0,  1,  0.2)\n    S( 0, -1,  0.2)\n    S( 1,  0,  0.2)\n    S(-1,  0,  0.2)\n    S( 1,  1,  0.05)\n    S( 1, -1,  0.05)\n    S(-1,  1,  0.05)\n    S(-1, -1,  0.05)\n    return laplacian;\n}\n#undef S\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 prevColor = texture(iChannel0, uv);\n    float x = prevColor.x;\n    float y = prevColor.y;\n    if (iFrame < 10 || iTime < 1.0)\n    {\n        vec2 rand = pow(random(uv), vec2(3.0));\n        x = rand.x*2.0;\n        y = rand.y*3.0+2.0;\n    }\n    else\n    {\n        float rate1 = k2*x;\n        float rate2 = k3*x*y/(u+x*x);\n        vec2 diffusion = laplacian(iChannel0, fragCoord);\n        float deltaX = diffusion.x*DX - rate1 - 4.0*rate2 + k1;\n        float deltaY = diffusion.y*DY + rate1 - rate2;\n        /*float g = // mouse\n            2.0 - segmentDistance(texture(iChannel1, vec2(0.0)).xy,\n                                  texture(iChannel1, vec2(1.0)).xy, fragCoord)*0.1;\n        g = pow(g, 0.4)*5.0;\n        //float g = (iMouse.w > 0.0 ? 0.0 : length(iMouse.xy-fragCoord) < 30.0 ? 5.0 : 0.0);\n        if (g > y) y = g;*/\n        float dt = SPEED;\n        x += deltaX * dt;\n        y += deltaY * dt;\n    }\n    fragColor = vec4(x, y, 0.0, 0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define DX 0.75 /* scale */\n#define DY 0.1 /* scale */\n#define k1 0.4\n#define k2 0.08\n#define k3 0.04\n#define u  0.2\n#define SPEED 0.25 /* timestep */\n\n/* Source:\nLengyel, István; Epstein, Irving R. (1991), \"Modeling of Turing Structures in the Chlorite—Iodide—Malonic Acid—Starch\n                                             Reaction System\", Science vol. 251 issue 4994 pp. 650-652*/\n\nvec2 random(vec2 uv)\n{\n    return texture(iChannel3, uv).xy;\n}\n\n// function from http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment\n/*float segmentDistance(vec2 v, vec2 w, vec2 p)\n{\n    float l2 = dot(w-v, w-v);\n    if (l2 == 0.0) return distance(p, v);\n    float t = max(0.0, min(1.0, dot(p-v, w-v)/l2));\n    vec2 projection = v + t*(w-v);\n    return distance(p, projection);\n}*/\n\nvec2 cr(vec2 xy)\n{\n    return mod(xy, iResolution.xy);\n}\n\n#define S(DX, DY, WEIGHT) laplacian += texture(channel, cr(fragCoord+vec2(DX, DY))/iResolution.xy).xy*WEIGHT;\nvec2 laplacian(sampler2D channel, vec2 fragCoord)\n{\n    vec2 laplacian = vec2(0.0);\n    S( 0,  0, -1.0)\n    S( 0,  1,  0.2)\n    S( 0, -1,  0.2)\n    S( 1,  0,  0.2)\n    S(-1,  0,  0.2)\n    S( 1,  1,  0.05)\n    S( 1, -1,  0.05)\n    S(-1,  1,  0.05)\n    S(-1, -1,  0.05)\n    return laplacian;\n}\n#undef S\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 prevColor = texture(iChannel0, uv);\n    float x = prevColor.x;\n    float y = prevColor.y;\n    if (iFrame < 10 || iTime < 1.0)\n    {\n        vec2 rand = pow(random(uv), vec2(3.0));\n        x = rand.x*2.0;\n        y = rand.y*3.0+2.0;\n    }\n    else\n    {\n        float rate1 = k2*x;\n        float rate2 = k3*x*y/(u+x*x);\n        vec2 diffusion = laplacian(iChannel0, fragCoord);\n        float deltaX = diffusion.x*DX - rate1 - 4.0*rate2 + k1;\n        float deltaY = diffusion.y*DY + rate1 - rate2;\n        /*float g = // mouse\n            2.0 - segmentDistance(texture(iChannel1, vec2(0.0)).xy,\n                                  texture(iChannel1, vec2(1.0)).xy, fragCoord)*0.1;\n        g = pow(g, 0.4)*5.0;\n        //float g = (iMouse.w > 0.0 ? 0.0 : length(iMouse.xy-fragCoord) < 30.0 ? 5.0 : 0.0);\n        if (g > y) y = g;*/\n        float dt = SPEED;\n        x += deltaX * dt;\n        y += deltaY * dt;\n    }\n    fragColor = vec4(x, y, 0.0, 0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define DX 0.75 /* scale */\n#define DY 0.1 /* scale */\n#define k1 0.4\n#define k2 0.08\n#define k3 0.04\n#define u  0.2\n#define SPEED 0.25 /* timestep */\n\n/* Source:\nLengyel, István; Epstein, Irving R. (1991), \"Modeling of Turing Structures in the Chlorite—Iodide—Malonic Acid—Starch\n                                             Reaction System\", Science vol. 251 issue 4994 pp. 650-652*/\n\nvec2 random(vec2 uv)\n{\n    return texture(iChannel3, uv).xy;\n}\n\n// function from http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment\n/*float segmentDistance(vec2 v, vec2 w, vec2 p)\n{\n    float l2 = dot(w-v, w-v);\n    if (l2 == 0.0) return distance(p, v);\n    float t = max(0.0, min(1.0, dot(p-v, w-v)/l2));\n    vec2 projection = v + t*(w-v);\n    return distance(p, projection);\n}*/\n\nvec2 cr(vec2 xy)\n{\n    return mod(xy, iResolution.xy);\n}\n\n#define S(DX, DY, WEIGHT) laplacian += texture(channel, cr(fragCoord+vec2(DX, DY))/iResolution.xy).xy*WEIGHT;\nvec2 laplacian(sampler2D channel, vec2 fragCoord)\n{\n    vec2 laplacian = vec2(0.0);\n    S( 0,  0, -1.0)\n    S( 0,  1,  0.2)\n    S( 0, -1,  0.2)\n    S( 1,  0,  0.2)\n    S(-1,  0,  0.2)\n    S( 1,  1,  0.05)\n    S( 1, -1,  0.05)\n    S(-1,  1,  0.05)\n    S(-1, -1,  0.05)\n    return laplacian;\n}\n#undef S\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 prevColor = texture(iChannel0, uv);\n    float x = prevColor.x;\n    float y = prevColor.y;\n    if (iFrame < 10 || iTime < 1.0)\n    {\n        vec2 rand = pow(random(uv), vec2(3.0));\n        x = rand.x*2.0;\n        y = rand.y*3.0+2.0;\n    }\n    else\n    {\n        float rate1 = k2*x;\n        float rate2 = k3*x*y/(u+x*x);\n        vec2 diffusion = laplacian(iChannel0, fragCoord);\n        float deltaX = diffusion.x*DX - rate1 - 4.0*rate2 + k1;\n        float deltaY = diffusion.y*DY + rate1 - rate2;\n        /*float g = // mouse\n            2.0 - segmentDistance(texture(iChannel1, vec2(0.0)).xy,\n                                  texture(iChannel1, vec2(1.0)).xy, fragCoord)*0.1;\n        g = pow(g, 0.4)*5.0;\n        //float g = (iMouse.w > 0.0 ? 0.0 : length(iMouse.xy-fragCoord) < 30.0 ? 5.0 : 0.0);\n        if (g > y) y = g;*/\n        float dt = SPEED;\n        x += deltaX * dt;\n        y += deltaY * dt;\n    }\n    fragColor = vec4(x, y, 0.0, 0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}