{
    "Shader": {
        "info": {
            "date": "1611438679",
            "description": "My annotations to Art of Code's KIFS Koch snowflake tutorial @ https://youtu.be/il_Qg9AqQkE .\n\nText code adapted from ttoinou's 'YAS³': https://www.shadertoy.com/view/Xd2fzK\nKIFS code adapted from BigWings' tutorial: https://www.shadertoy.com/view/tdcGDj",
            "flags": 32,
            "hasliked": 0,
            "id": "wtcyRN",
            "likes": 8,
            "name": "Annotated Koch KIFS tutorial",
            "published": 3,
            "tags": [
                "tutorial",
                "kifs",
                "koch",
                "bigwings",
                "artofcode"
            ],
            "usePreview": 0,
            "username": "mkennan",
            "viewed": 422
        },
        "renderpass": [
            {
                "code": "/***********************************************************************\n\n  Annotations for BigWings/Art of Code's KIFS Koch curve tutorial\n\n    @ https://youtu.be/il_Qg9AqQkE\n    & https://www.shadertoy.com/view/tdcGDj\n\n  Near the bottom of the page are the two lines that draw our Koch\n  curve. Right now they test pixels to see how close they are to a\n  notional line segment from x=0.0 to x=1.0; if the pixel is close\n  enough, the color white is assigned to that pixel.\n\n  By the time we are done we will have a full Koch snowflake, and \n  those lines will *still* just draw a white line from x=0 to x=1.\n  Much like an actual kaleidoscope, we will have mapped all of the\n  other parts of the canvas that should be part of the snowflake\n  back onto this little line segment.\n  \n  Each new section below is commented out with '/*' on the left.\n  Remove the '/*' (or nullify it like so: '//*') and recompile\n  the sketch (ALT-Enter, or click the button) to see what each new\n  section adds.\n\n  - MK, January 2021\n  \n************************************************************************/\n\n// some variables we will need later\nfloat PI = 3.14159;\nfloat scale = 1.0;\nfloat angle;\nfloat d; // distance\nvec2  n; // normal vector\n\n\n// Step 0: start the tutorial by setting this to 1 and re-compiling\n\n#if 0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n   \n  // As we start, the uv coordinates are mapped to the red and green\n  // color channels so we can see how our efforts change the shape of \n  // space. Later we will disable this, first to make small details \n  // easier to see, then to sample a texture.\n  \n  // I'm commenting out the original uv declaration, so we can\n  // see how and why space changes when we change uv. The original\n  // code normalizes the uv space, centers the origin, and accounts\n  // for the aspect ratio in one line:\n  //\n  //   vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n  //\n  // we'll do those things one at a time to see how it all works.\n\n  // uv is our tool for navigating space.\n  vec2 uv;\n\n  // fragCoord is the current pixel; iResolution is the canvas\n  // dimensions [width, height]. Dividing fragCoord by the canvas\n  // resolution makes x and y go from 0.0 to 1.0, abstracting away\n  // the details of whatever hardware the shader is running on.\n  \n  // (The resolution, despite being declared as a vec2, sometimes\n  // has a third component that contains the pixel aspect ratio...\n  // if you get an error about wrong dimensions in the line that\n  // has fragCoord and iResolution in it, explicitly restrict the\n  // affected variables to x and y using the suffix '.xy'.)\n  uv = fragCoord.xy / iResolution.xy;\n\n/*\n  // Subtracting 0.5 moves (0,0) to the center. The bottom-left\n  // quadrant turns black, and the red and green colors become\n  // dimmer, because RGB values must be in the range [0..1] and\n  // their 'zero' is now the center of the canvas.\n  // Note that modifying a vector this way changes each vector\n  // component individually, i.e the following lines are all\n  // equivalent:\n  //\n  //   uv = uv - vec2(0.5, 0.5);\n  //   uv -= vec2(0.5, 0.5);\n  //   uv -= vec2(0.5);\n  //   uv -= 0.5;\n  uv -= 0.5;\n\n/*\n  // x & y now go from -0.5 to 0.5, but if the canvas is not\n  // square our uv elements are not square either. We need to\n  // account for this so we are working with consistent distances\n  // in both axes, by multiplying uv by the canvas aspect ratio:\n  uv.x *= iResolution.x / iResolution.y;\n  \n  // You can uncomment this copy of the original code to verify\n  // that what we have done is identical:\n  //uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n  // We need to keep track of how much we shrink uv space, or our\n  // line will become too thin to see:\n  scale = 1.0;\n  \n/*\n  // The Koch curve is bilaterally symmetric, so our first \n  // 'mirror' is also our easiest. abs(x) maps points from\n  // -x to their reflection at +x.\n  uv.x = abs(uv.x);\n\n/*\n  // Multiplying uv by 3 is useful because it changes the scale\n  // at which we interact with features in the curve: every\n  // recursive step divides an existing line segment into thirds,\n  // then the middle section is raised to make a peak.\n  // In the video he multiplies uv by 3, and likewise multiplies\n  // scale to keep track of these changes:\n  uv    *= 3.0;\n  scale *= 3.0;\n  \n  // Then he \"moves the origin\", and this is where my intuition\n  // fell apart: I think if the length of the line segment is\n  // now 3, we'd need to move uv.x 1 to the right. If the length\n  // of the line segment is still 1, we'd need to move uv.x 1/3\n  // to the right. But the next line he adds is:\n  //\n  //  uv.x -= 0.5;\n  //\n  // W.T.F.?\n  //\n  // It took a while, but eventually it clicked:\n  // The line segment is still where it has always been, from \n  // x=0 to x=1. He speaks of 'bending' the line, and it is\n  // really easy to fall into the trap of thinking we are \n  // 'rotating' the line, but we aren't actually doing *anything*\n  // to the line. We're just positioning our 'mirrors' to map\n  // uv points across a line of reflection so they can be \n  // tested for their distance from the line segment.\n  \n  // So instead of a line with 3 parts, one of which we 'bend'\n  // or 'rotate' upward to create the bottom half of the peak (a),\n  // we need a line of length 2/3rds, *reflected* to create the\n  // entire peak (b):\n  //           (The vertical lines are the y-axis.)\n  //\n  //       |            |               |            |\\  / <- line of reflection\n  //  (a): | _ _ _  ->  | \\ _ _    (b): |   _ _  ->  | \\ _ _\n  //       |            |               |            | /\n  // \n  // And that is what he did: he moved 0.5 to the *left*. This\n  // makes the distance from uv to the far end of the line be\n  // 1.5, with the first third being blank and the other two\n  // thirds being our length=1 line segment: we moved uv so\n  // our line segment *became* the 2/3rds we needed, without\n  // changing anything else. This is the key to understanding\n  // this uv weirdness: since uv is all that we have, we move it\n  // and resize it until elements that are outside of our control,\n  // like our little white line segment, appear to be where we\n  // want them to be.\n  uv.x -= 0.5;\n  \n  // (The middle of the line segment will seem to disappear for\n  // a bit, since we aren't actually reflecting anything yet.\n  // What we are seeing is our line segment of length 1, moved\n  // 0.5 to the right, while the left half of the canvas 'reflects'\n  // everything on the right side.)\n  \n  // Now we need to fold space again, to 'reflect' the points\n  // that will become the peak in the center. But how do we \n  // reflect across an arbitrary vector?\n  \n  // We'll have to reproduce the details and behavior of the\n  // 'mirror' we used before, abs(x):\n  //\n  // abs(x):\n  //  * had a line of reflection, the y-axis.\n  //  * had a normal (perpendicular) vector, the x-axis\n  //  * took points that were some distance -x from the \n  //    line of reflection, and mapped them a distance of 2x\n  //    along along the normal vector to reach the target\n  //\n  // We need to do each of those things, adjusted for the angle:\n  \n  //  * we want our reflected section to be 120º around from the\n  //    line, so our line of reflection will be angled at half \n  //    of that: 60º, or π/3 radians.\n  //  * our normal vector n will be perpendicular to the line of\n  //    reflection, pointing in the π/3 - π/2 = -π/6 radians\n  //    direction. (60º - 90º = -30º)\n  // \n  // So our angle and normal vector are:\n  angle = -PI / 6.0;\n  n = vec2(cos(angle), sin(angle));\n  \n  // At this point in the video he writes:\n  //  angle = 2.0 * π / 3.0;           // which looked wrong, and\n  //  n = vec2(sin(angle), cos(angle)); // which looked backwards\n  //\n  // He was mapping the angle from 0.0 with the mouse at the left\n  // edge and the line 'unbent' (it was actually open by 180º)\n  // to π with the mouse at the right edge with the line 'folded\n  // back along itself', (i.e. actually open 0º). This made visual\n  // sense - and fit the rest of his code - but is the opposite of\n  // how angles work geometrically. Substituting (π - mouse.x)\n  // into his numbers results in angle of 60º, which is the \n  // complement of 30º.\n  //\n  // But:\n  //\n  //   sin(-π/6) = cos(2*π/3) = -0.500, and\n  //   cos(-π/6) = sin(2*π/3) = +0.866\n  //\n  // And sine waves have many symmetries and many identities:\n  // sin() and cos() mirror each other across π/4 (45º), which\n  // is equidistant to both of our angles. You can uncomment his\n  // numbers above to verify that the results are the same.\n  \n  // Now we need to find the perpendicular distance from a point to\n  // the line of refection.\n\n  // The dot() product is used to tell the extent to which one\n  // vector is aligned to another. If we take the dot product of\n  // a point and our normal vector, it will tell us the perpendicular\n  // distance to/from the line of reflection along the normal vactor:\n  d = dot(uv,n);\n\n  // Our mirrors only have one side. Squash any points that are\n  // on the wrong side of the line of reflection, so they\n  // don't reflect back and whack points we like.\n  d = min(0.0, d);\n\n/*\n  // With our tools constructed, we add the second 'mirror': points\n  // above the line reflect back d * 2.0 units in direction n to\n  // reach the matching point on the white line.\n  uv -= 2.0 * d * n;\n  \n  // we should now have a peak in the middle third of the line.\n\n  // video @ 15:48, https://youtu.be/il_Qg9AqQkE?t=948\n\n  /**************************************************************/\n\n/*\n  // Now we want to add a layer of recursion, replacing the center\n  // of each segment in the Koch curve with a peak. Our first\n  // mirror copied everything we do on the right to the left, and\n  // our second mirror copied everything we do on the original\n  // line segment to the upper peak, so to change all four lines\n  // we only need to change the original segment, on the right.\n  \n  // At this point in the video he says we need to \"reset uv\".\n  // Hopefully it is clear that is what we have been doing all\n  // along - note that after the initial setup we never declare\n  // that uv *equals* something, we always modify it to 'move\n  // the mirrors' of our kaleidoscope. So before we repeat what\n  // we have done above, we need to do this to get reoriented:\n  uv.x  -= 0.5; // we move one-third to the right\n  uv    *= 3.0; // we 'zoom in' by another factor of 3\n  scale *= 3.0; // ... and keep track of that, for later\n  \n  // we then repeat the process from before:\n  uv.x  = abs(uv.x);                     // mirror the two sides\n  uv.x -= 0.5;                           // move the origin\n  uv   -= n * min(0.0, dot(uv,n)) * 2.0; // reflect and step\n\n  // video @ 18:04, https://youtu.be/il_Qg9AqQkE?t=1084\n\n  /**************************************************************/\n\n/*\n  // ... and we can copy/paste those 6 lines to add another\n  // layer of recursion:\n  uv.x  -= 0.5;       // move origin\n  uv    *= 3.0;       // scale\n  scale *= 3.0;       // keep track\n  uv.x   = abs(uv.x); // mirror\n  uv.x  -= 0.5;       // move to point of rotation/reflection\n  uv    -= n * min(0.0, dot(uv,n)) * 2.0; // reflect and step\n\n  // video @ 18:44, https://youtu.be/il_Qg9AqQkE?t=1124\n\n  /**************************************************************/\n\n  // At this point in the video, the recursion steps above are\n  // refactored and changes are made all the way back up to near\n  // the beginning. To keep things linear I am going to reset\n  // some variables here, without comment except where things\n  // change, and continue down the page\n/*\n  // reset\n  scale = 1.0;\n  uv    = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n  uv.x  = abs(uv.x);\n  \n  // To reflect to the other sides of the snowflake, we need to\n  // position a new mirror. We do this first so everything we do\n  // later will automatically be reflected. The mirror goes half-\n  // way between the 0º top and the 60º side, at 30º or π/6.\n  // The normal vector will thus be 30º - 90º = -60º, or -π/3:\n  angle = -PI / 3.0;\n  n = vec2(cos(angle), sin(angle));\n  \n  // (In the video he once again uses the mouse method to get a\n  // different angle and swaps sin() and cos(), but it once\n  // again equals what we get from analyzing the geometry.)\n  \n  // We have been working on the line centered vertically in the\n  // canvas. We need to shrink space, and raise everything, to\n  // fit the entire snowflake pattern in the canvas:\n  uv *= 1.25;\n  uv.y += 1.0 / tan(-PI / 3.0) * 0.5;\n  \n  // In the video he takes the tangent of a different angle, but\n  // he once again has the angles defined backwards. Analytically\n  // this distance is proportional to the cotangent of -π/3; there\n  // is no cot() function in GLSL, but cot() = 1 / tan().\n\n/*\n  // Move uv such that the normal vector touches the right corner\n  // and map points across the line. This mirror reflects the other\n  // way, so we use max(), instead of min(), to whack unwanted\n  // re-reflections.\n  d = dot(uv - vec2(0.5,0.0),n);\n  d *= 2.0;\n  d = max(0.0, d);\n  uv -= d * n;\n  \n  // Now that uv is properly set up, we can once again use abs() to\n  // map the points across the mirror and complete our triangle.\n  // Very little changes, because the other mirrors are already doing\n  // their jobs.\n  uv.x  = abs(uv.x);\n\n  /**************************************************************/\n  \n/*\n  // To make the first outward 'bend' we first reset uv:\n  uv.x += 0.5;\n\n  // ... and reset the angle:\n  angle = -PI / 6.0;\n  n = vec2(cos(angle), sin(angle));\n  \n  // ... and we're back to what we did before:\n  uv    *= 3.0;       // scale\n  scale *= 3.0;       // track\n  uv.x  -= 1.5;       // move origin\n  uv.x   = abs(uv.x); // mirror\n  uv.x  -= 0.5;       // move to point of rotation/reflection\n  uv    -= n * min(0.0, dot(uv,n)) * 2.0; // reflect and step\n\n/*\n  // Add another layer of recursion:\n  uv    *= 3.0;       // scale\n  scale *= 3.0;       // track\n  uv.x  -= 1.5;       // move origin\n  uv.x   = abs(uv.x); // mirror\n  uv.x  -= 0.5;       // move to point of rotation/reflection\n  uv    -= n * min(0.0, dot(uv,n)) * 2.0; // reflect and step\n  \n  // ... etc. //*/\n  \n/*\n  // Additional levels can loop through those 6 lines as many\n  // times as you want.\n  int t = 5;            // play with different values of t\n  for(int i = 0; i < t; i++) {\n    uv    *= 3.0;       // scale\n    scale *= 3.0;       // track\n    uv.x  -= 1.5;       // move origin\n    uv.x   = abs(uv.x); // mirror\n    uv.x  -= 0.5;       // move to point of rotation/reflection\n    uv    -= n * min(0.0, dot(uv,n)) * 2.0; // reflect and step\n  }\n\n  /**************************************************************/\n\n  // Now we actually *do* something with what we have wrought:\n  \n  // 'col' is the color that will be assigned to fragColor in\n  // the final line of the shader:\n  vec4 col = vec4(0.0);\n\n  // color the background to help visualize how space changes\n  col = vec4(uv, 0.0, 1.0);\n  \n  // .. unless you no longer want the colors, in which case you\n  // can uncomment the next line\n  //col = vec4(0.0);\n\n  // find the distance from uv to our little white line segment\n  float dist = length(uv - vec2(clamp(uv.x, 0.0, 1.0), 0.0));\n\n  // Note that the original code clamped uv.x to [-1.0,1.0].\n  // I removed the left half because we only needed the right\n  // half, *and* we explicitly blocked the left half with min().\n  // You can uncomment this to see that nothing changed:\n  //dist = length(uv - vec2(clamp(uv.x, -1.0, 1.0), 0.0));\n\n  // This is the only line that actually draws anything, assigning\n  // a color of white to any uv that is within a small distance from\n  // our line segment. Every other part of the Koch curve is being\n  // filled in by the 'mirrors' we added.\n  // Here we finally use 'scale' to account for line thinning.\n  col += smoothstep(1.0 / iResolution.y, 0.00, dist / scale);\n  \n/*\n  // It's time to get our kaleidoscope on, to see what all of\n  // our reflections did to the shape of uv space. To do this, \n  // we'll sample a texture image.\n  \n  // First we must renormalize uv so we're sampling the texture\n  // into the largest scale, so our mirrors can do their job of \n  // kaleidoscoping everything. (Without renormalizing, we'd be\n  // copying the sample into the *smallest* feature, which just\n  // looks like pixel soup.) Adding a sine wave to uv samples\n  // the image at different places, to make out kaliedoscope\n  // move:\n  uv /= scale;\n  col += texture(iChannel1, uv - sin(iTime * 0.1)); //*/\n  \n  // you can change the sampled texture by clicking on iChannel1,\n  // below. There are 3 pages of images. I like 'Organic 1' and\n  // 'Organic 2' the best, but if nyancat is your thing, go for it.\n\n  // apply col to the pixel\n  fragColor = vec4(col.rgb, 1.0);\n}\n\n/**************************************************************/\n\n// this just shows the splash screen at the beginning\n#else\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  fragColor = texture(iChannel0, uv);\n}\n#endif\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/******************************************************\n\n  For this tutorial you can ignore buffer A, it just\n  adds the splash screen at the beginning.\n \n*******************************************************\n\n  Credits:\n\n    Text code adapted from ttoinou's 'YAS³':\n        \n      https://www.shadertoy.com/view/Xd2fzK\n        \n    KIFS code adapted from BigWings' tutorial:\n  \n      https://www.shadertoy.com/view/tdcGDj\n      \n    Everything else: Michael Kennan, January 2021\n\n*******************************************************/\n\n/*\n * Char Map, chars written with \"0xab\" a is X coord b is Y coord\n * (this is reverse-endian from most ASCII tables)\n * \n *    0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n * 3  0  1  2  3  4  5  6  7  8  9 \n * 4  @  A  B  C  D  E  F  G  H  I  J  K  L  M  N  O\n * 5  P  Q  R  S  T  U  V  W  X  Y  Z  [  \\  ]  ^  _\n * 6     a  b  c  d  e  f  g  h  i  j  k  l  m  n  o\n * 7  p  q  r  s  t  u  v  w  x  y  z\n *\n * One uvec4 => 16 characters\n */\n#define SPACE_CHAR (0x02U)\n#define STOP_CHAR  (0x0AU)\n\nfloat fontSize;\nfloat fontSpacing;\nvec4 fontCol;\nvec4 fontColor;\nvec4 fontBorder;\nvec4 fontBuffer;\nvec2 fontStart;\nvec2 fontUV;\n\nvoid drawStr4(uint str) {\n  while (str < 0x1000000U)\n    str = str * 0x100U + SPACE_CHAR;\n  \n  for (int i = 0; i < 4; i++) {\n    uint xy = (str >> 8 * (3 - i)) % 256U;\n    if (xy != SPACE_CHAR) {\n      vec2 K = (fontUV - fontStart) / fontSize;\n      if (length(K) < 0.6) { /* lookup skipping : avoid useless font texture lookup */\n        vec4 Q = texture(\n          iChannel1,\n          (K + vec2(float(xy/16U) + 0.5, 16.0 - float(xy%16U) - 0.5)) / 16.0\n        );\n        fontBuffer.rgb += Q.rgb * smoothstep(0.6, 0.4, length(K));\n\n        if (max(abs(K.x), abs(K.y)) < 0.5) {\n          fontBuffer.a = min(Q.a, fontBuffer.a);\n        }\n      }\n    }\n    if (xy != STOP_CHAR) fontStart.x += fontSpacing * fontSize;\n  }\n}\n\nvec2 N(float angle) {\n  return vec2(sin(angle), cos(angle));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 N1  = vec2(sin(2.618), cos(2.618));\n  vec2 N2  = vec2(sin(2.094), cos(2.094));\n  vec4 col = vec4(0.0);\n\n  // draw the background\n  vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n  \n  uv   *= 1.25;\n  uv.x  = abs(uv.x);\n  uv.y += tan(2.618) * 0.5;\n  uv   -= max(0.0, dot(uv - vec2(0.5, 0.0), N1)) * N1 * 2.0;\n\n  uv.x  = abs(uv.x);\n  uv   *= 3.0;\n  uv.x -= 0.5;\n  uv   -= N2 * min(0.0, dot(uv,N2) * 2.0);\n  \n  float dist  = 0.0;\n  float scale = 1.0;\n  \n  // left: map red and green to background\n  if (fragCoord.x / iResolution.x < 0.33) {\n    col = vec4(fragCoord.xy / iResolution.xy, 0.0, 1.0);\n  }\n  \n  // center: Koch curve outline\n  //col  = vec4(0.0);//\n  //if (fragCoord.x / iResolution.x > 0.33) {\n    for(int i = 0; i < 2; i++) {\n      uv   *= 3.0; scale *= 3.0;\n      uv.x  = abs(uv.x - 1.5) - 0.5;\n      uv   -= N2 * min(0.0, dot(uv,N2)) * 2.0;\n    }\n    dist = length(uv - vec2(clamp(uv.x, 0.0, 1.0), 0.0));\n    col += smoothstep(0.01, 0.00, dist/scale);\n  //}\n  \n  // right: Koch KIFS\n  if (fragCoord.x / iResolution.x > 0.66) {\n    for(int i = 0; i < 10; i++) {\n      uv    *= 3.0;\n      scale *= 3.0;\n      uv.x = abs(uv.x - 1.5) - 0.5;\n      uv -= N2 * min(0.0, dot(uv,N2)) * 2.0;\n    }\n    col += texture(iChannel0, uv/scale - sin(iTime*0.3));\n  }\n\n  // add the text\n  fontUV      = fragCoord.xy / iResolution.xy - 0.5;\n  fontUV.x   *= iResolution.x / iResolution.y;\n  fontColor   = vec4(1.0);\n  fontBorder  = vec4(0.0);\n  fontSpacing = 0.45;\n  \n  fontSize    = 0.25;\n  fontStart   = vec2(-8.0 * fontSpacing * fontSize / 2.0, +0.15);\n  fontBuffer  = vec4(0.0,0.0,0.0,1.0);\n  drawStr4(uint(0xB4F43484)); // 'KOCH'\n  \n  fontStart   = vec2(2.0 * fontSpacing * fontSize / 2.0, +0.15);\n  drawStr4(uint(0xB4946435)); // 'KI*FS'\n  \n  fontSize    = 0.20;\n  fontStart   = vec2(-11.0 * fontSpacing * fontSize / 2.0, -0.15);\n  drawStr4(uint(0x35475607)); // 'Step'\n  drawStr4(uint(0x02249702)); // ' By '\n  drawStr4(uint(0x35475607)); // 'Step'\n  \n  float a = smoothstep(1.0, 0.0, smoothstep(.55,.58,fontBuffer.a));\n  float b = smoothstep(0.0, 1.0, smoothstep(.45,.55,fontBuffer.a));\n  fontCol   = mix(fontColor, fontBorder, b);\n  fragColor = mix(col, fontCol, a);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}