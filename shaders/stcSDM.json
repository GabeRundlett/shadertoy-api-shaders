{
    "Shader": {
        "info": {
            "date": "1639209656",
            "description": "Shoutout tdhooper, you are God Tier\nnoise is shit as usual",
            "flags": 32,
            "hasliked": 0,
            "id": "stcSDM",
            "likes": 14,
            "name": "TDF Shader Showdown Quarterfinal",
            "published": 3,
            "tags": [
                "shadershowdown",
                "tdf",
                "tokyodemofest"
            ],
            "usePreview": 0,
            "username": "sp4ghet",
            "viewed": 384
        },
        "renderpass": [
            {
                "code": "#define time iTime\n#define v2Resolution iResolution\n#define saturate(x) clamp((x), 0.,1.)\nconst vec3 up = vec3(0,1,0);\nconst float PI = acos(-1.);\nconst float TAU = 2. * PI;\n\nmat3 ortho(vec3 z, vec3 up){\n  vec3 cu = normalize(cross(z, up));\n  vec3 cv = cross(cu, z);\n  return mat3(cu,cv, z);\n}\n\nfloat box(vec3 p, vec3 b){\n  p = abs(p) - b;\n  return length(max(p, 0.)) + min(0., max(p.x, max(p.y, p.z)));\n}\n\nvoid chmin(inout vec4 a, in vec4 b){\n  a = a.x < b.x ? a : b;\n}\n\nvec4 to(vec3 p){\n  float s = 2. / (1. + dot(p,p));\n  return vec4(s*p, s-1.);\n}\n\nvec3 from(vec4 p){\n  float s = 1. / (1. + p.w);\n  return s * p.xyz;\n}\n\nmat2 r2d(float t){\nfloat c = cos(t), s = sin(t);\nreturn mat2(c,s,-s,c);\n}\n\nvec4 map(vec3 q){\n  vec4 d = vec4(1000, 0,0,0);\n  vec3 p = q;\n  float f = length(p);\n  vec4 p4 = to(p);\n  float t = time * .2;\n  p4.zw *= r2d(-t);\n  p4.yw *= r2d(3.*t);\n  p = from(p4);\n  float e = length(p);\n  float cor = max(1., f) * min(1., 1./e);\n\n  float bx = box(p, vec3(1.1));\n  bx = max(bx, -box(p, vec3(1)));\n  bx = max(bx, -box(p, vec3(2, .5, .5)));\n  bx = max(bx, -box(p, vec3(.5, 2, .5)));\n  bx = max(bx, -box(p, vec3(.5, .5, 2)));\n  bx = max(bx, -box(vec3(abs(p.yz)-1., p.x).zxy, vec3(.5, .3, .3)));\n  bx = max(bx, -box(vec3(abs(p.xz)-1., p.y).xzy, vec3(.3, .5, .3)));\n  bx = max(bx, -box(vec3(abs(p.xy)-1., p.z).xyz, vec3(.3, .3, .5)));\n  bx *= cor * .5;\n  chmin(d, vec4(bx, 1,0,0));\n\n  bx = box(p, vec3(2.1));\n  bx = max(bx, -box(p, vec3(2)));\n  bx = max(bx, -box(p, vec3(3, 1, 1)));\n  bx = max(bx, -box(p, vec3(1, 3, 1)));\n  bx = max(bx, -box(p, vec3(1, 1, 3)));\n  bx = max(bx, -box(vec3(abs(p.yz)-2., p.x).zxy, vec3(1, .5, .5)));\n  bx = max(bx, -box(vec3(abs(p.xz)-2., p.y).xzy, vec3(.5, 1, .5)));\n  bx = max(bx, -box(vec3(abs(p.xy)-2., p.z).xyz, vec3(.5, .5, 1)));\n  bx *= cor * .5;\n  chmin(d, vec4(bx, 1,0,0));\n\n  vec2 xy = vec2(length(p.xz) - .5, p.y);\n  float thk = length(xy);\n  float th = atan(p.x, p.z);\n  float ph = atan(xy.y, xy.x);\n  vec3 pp = vec3(mod(24. * th, TAU) - PI, thk - .2, mod(12. * ph, TAU) - PI);\n  pp.xz /= TAU;\n  float tr = box(pp, vec3(.3, .01, .45));\n  tr *= cor * .5;\n  chmin(d, vec4(tr, 2, 0,0));\n\n  return d;\n}\n\nvec3 normal(vec3 p, vec2 e){\n return normalize(vec3(\n  map(p + e.xyy).x - map(p - e.xyy).x,\n  map(p + e.yxy).x - map(p - e.yxy).x,\n  map(p + e.yyx).x - map(p - e.yyx).x\n  ));\n}\n\nfloat rnd(int n){\n  n = (n << 13) ^ n;\n  return 1.0 - float((n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff) / pow(2.,30.);\n}\n\nconst vec3 l = normalize(vec3(.2, 1, .2));\nvec3 bg(vec3 n){\n  float qq = dot(l,n) * .5 + .5;\n  float q = qq + pow(qq, 16.) * 2.;\n  vec3 p = ortho(l, up) * n;\n  vec2 tp = vec2(atan(p.z, length(p.xy)), atan(p.y, p.x)) / TAU;\n  q += texture(iChannel0, fract(tp*5. + time*.2)).x;\n\n  return vec3(1) * q;\n}\n\nvoid mainImage( out vec4 out_color, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(fragCoord.x / v2Resolution.x, fragCoord.y / v2Resolution.y);\n\tvec2 pt = uv - 0.5;\n\tpt/= vec2(v2Resolution.y / v2Resolution.x, 1);\n\n\tvec3 c = vec3(0);\n  vec3 ro = vec3(0,1.7, 8);\n  vec3 fo = vec3(0);\n  float ct = time * 2.;\n  float pre = rnd(int(ct));\n  float now = rnd(int(ct) + 1);\n  ct = 0.5 + 0.5 * cos(PI * exp(-5. * fract(ct)));\n  pt *= r2d(PI * .2 *  mix(pre, now, ct));\n  vec3 rd = ortho(normalize(fo-ro), up) * normalize(vec3(pt, 1));\n\n  vec3 p = ro;\n  float t = 0.;\n  vec4 d;\n  for(int i=0; i<256; i++){\n    p = ro + rd*t;\n    d = map(p);\n    t += d.x;\n    if(abs(d.x) < 0.001 || t > 50.){break;}\n  }\n\n  if(abs(d.x) < .001){\n    vec3 n = normal(p, vec2(.01,0));\n    vec3 h = normalize(l-rd);\n    vec3 re = reflect(rd, n);\n    vec3 al = d.y == 1. ? vec3(.99, .2, .1) : vec3(.2, .7, .8);\n    float fre = pow(1. - saturate(dot(n,-rd)), 5.);\n    float nh = saturate(dot(n,h));\n    c += fre * vec3(.1, .7, .3);\n    c += (.1 + pow(nh, 20.)) * al;\n    c += saturate(dot(n,l)) * al;\n    c += al * bg(re);\n\n    float ao = 0.;\n    for(int i=1; i<=20; i++){\n      ao += saturate(map(p + n * .1 * float(i)).x / (.1 * float(i)));\n    }\n    c *= ao / 20.;\n  }else{\n    c = bg(rd);\n  }\n\n  c = pow(c, vec3(.4545));\n  c *= 1. - dot(pt,pt);\n  out_color = vec4(c,0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// From Dave Hoskins: https://www.shadertoy.com/view/4djSRW.\nfloat hoskins_hash(vec3 p3){\n    p3 = fract(p3 * 0.1031);\n    p3 += dot(p3,p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// https://www.shadertoy.com/view/4sfGzS\nfloat value_noise(vec3 x){\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(mix(hoskins_hash(i+vec3(0, 0, 0)),\n                       hoskins_hash(i+vec3(1, 0, 0)),f.x),\n                   mix(hoskins_hash(i+vec3(0, 1, 0)),\n                       hoskins_hash(i+vec3(1, 1, 0)),f.x),f.y),\n               mix(mix(hoskins_hash(i+vec3(0, 0, 1)),\n                       hoskins_hash(i+vec3(1, 0, 1)),f.x),\n                   mix(hoskins_hash(i+vec3(0, 1, 1)),\n                       hoskins_hash(i+vec3(1, 1, 1)),f.x),f.y),f.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(value_noise(vec3(fragCoord / 20., 0.)));\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}