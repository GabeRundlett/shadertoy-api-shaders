{
    "Shader": {
        "info": {
            "date": "1618245772",
            "description": "Practice on reflection + fractal like structure",
            "flags": 0,
            "hasliked": 0,
            "id": "fdfSz8",
            "likes": 5,
            "name": "大龙猫 - Quicky#051",
            "published": 3,
            "tags": [
                "quicky"
            ],
            "usePreview": 0,
            "username": "totetmatt",
            "viewed": 271
        },
        "renderpass": [
            {
                "code": "#define fGlobalTime iTime\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat ball(vec3 p,float l){\n    return length(p)-l;\n}\n\nvec2 mmin(vec2 a,vec2 b){return a.x < b.x ? a:b;}\nfloat box(vec3 p,vec3 a){\n  vec3 q = abs(p)-a;\n   return length(max(vec3(0.),q)+min(0.,max(q.z,max(q.x,q.y))));\n  }\nvec2 ball1(vec3 p){ \n \n  vec2 d = vec2(10000.,-1.);\n   float c = 6.;\n  for(float i=0.;i<=c;i++){ \n       p= abs(p)-.200*i;\n        p.xz = p.x > p.z ? p.xz:p.zx;\n\n        p.xy *=rot(.754*i);      \n\n       p.xy = p.x > p.y ? p.xy:p.xy;\n        if(mod(i,2.)==1.){\n        d = mmin(d, vec2(ball(p+vec3(1.5*(1.+i/c),0.,.0),1.)/2.5,mod(i,2.)+1.0));\n        } else {\n          d = mmin(d, vec2(box(p+vec3(1.8+p.y*(1.+i/c),-0.5,.0),vec3(0.5,0.5,.6))/1.5,mod(i,2.)+1.0));\n          }\n     \n      \n    }\n    return d;\n\n}\nvec2 sdf(vec3 p){\n  p.zy *=rot(sin(fGlobalTime*.3)*.5);\n    p.xy *=rot(fGlobalTime*.1);\n  vec2 b1 = ball1(p);\n // p.zy *=rot(3.141591/4.+fGlobalTime);\n  p.y = abs(p.y)-.5;\n   p.x = abs(p.x)-.5;\n  vec2 aa =p.xy *rot(p.z*4.);\n  vec2 bb =p.xy *rot(p.z*8.);\n  \n    p.xy = mix(aa,bb,-1.5);\n    \n  for(float j=0.;j<=2.;j++) { p.yxz = abs(p.zyx)-.2; p.yx *=rot(1.3*j);};\n    \n     p.yz = p.z > p.y ? p.yz:p.yx;\n  vec2 b2 = vec2(box(p,vec3(.151)+vec3(.4,.0,.0))/4.9,3.);\n  return mmin(b1,b2);\n}\n  \n vec2 nv= vec2(.001,.0);\n  vec3 norm(vec3 p){\n      return normalize(vec3(sdf(p+nv.xyy).x-sdf(p-nv.xyy).x,sdf(p+nv.yxy).x-sdf(p-nv.yxy).x,sdf(p+nv.yyx).x-sdf(p-nv.yyx).x));\n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\nvec3 col = vec3(.1);\n  vec3 ro = vec3(.0001,.0001,-2.1);\n  vec3 rd = normalize(vec3(uv,.6));\n  vec3 rp = ro;\n  float td =0.;\n  vec3 light = vec3(.01,.02,.03);\n  for(float i=0.;i<=69.*3.;i++){\n        vec2 d = sdf(rp);\n        rp += rd*d.x*.8;\n        td += d.x;\n        if(d.x<= 0.000001){\n           vec3 n = norm(rp);\n          float ld = length(light-rp);\n          if(d.y == 1.0){  \n           \n            col += vec3(0.2,.5,.5)*dot(normalize(light),n)*2./ld;\n            break;\n          } else if(d.y == 2.){\n              rd = reflect(rd,n);\n              rp += rd*0.01;\n            col +=vec3(.1,0.,0.);\n            }\n          else if(d.y == 3.){\n              rd = reflect(rd,n);\n              rp += rd*0.00001;\n            col +=vec3(.3,0.2,0.1);\n            }\n          }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}