{
    "Shader": {
        "info": {
            "date": "1611108434",
            "description": "Based in The Universe Within, from Martijn Steinrucken.\n(https://www.shadertoy.com/view/lscczl)\n\nSpent a lot of time implementing mouse picking on triangles, and it looks awful :)",
            "flags": 0,
            "hasliked": 0,
            "id": "WtyyDm",
            "likes": 9,
            "name": "Shining Vertices",
            "published": 3,
            "tags": [
                "voronoi",
                "lines",
                "stars",
                "points"
            ],
            "usePreview": 0,
            "username": "avinitzca",
            "viewed": 614
        },
        "renderpass": [
            {
                "code": "\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat invLerp(float from, float to, float value){\n  return (value - from) / (to - from);\n}\n\n\n\nfloat saturate(float value)\n{\n    return clamp(value, 0.0, 1.0);\n}\n\n\nvec3 saturate(vec3 value)\n{\n    return clamp(value, vec3(0.0), vec3(1.0));\n}\n\nfloat point(vec2 current, vec2 target)\n{    \n    return smoothstep(0.0, 1.4, 0.01 / distance(current, target));\n}\n\nfloat pointInLine(vec2 current, vec2 target)\n{    \n    return smoothstep(0.0, 1.6, 0.01 / distance(current, target));\n}\n\nfloat line(vec2 point, vec2 a, vec2 b)\n{\n    float lineDistance = abs(sdSegment(point, a, b));    \n    float lineLength = smoothstep(2.0, 0.2, distance(a, b));\n    return saturate(smoothstep(0.01, 0.0, lineDistance) * lineLength);\n}\n\nfloat lineNoDistanceFade(vec2 point, vec2 a, vec2 b)\n{    \n    float lineDistance = abs(sdSegment(point, a, b));    \n    return saturate(smoothstep(0.005, 0.0, lineDistance));\n}\n\nvec4 positionsForTime(float time, float scale)\n{\n    float offseted = time + 0.05;\n    \n    vec4 positions;\n    positions.xy = random2(vec2(time, time));       \n    positions.zw = random2(vec2(offseted, offseted));    \n    \n    positions *= scale;\n    \n    positions.zw *= 1.2;\n    return positions;\n}\n\nconst int indexPerDifference[] = int[8]\n(\n    0,\n    1,\n    2,\n    3,\n    4,\n    5,\n    6,\n    7\n);\n\nint indexFromDifference(vec2 difference)\n{\n    float preIndex = difference.x * 3.0 + difference.y;\n    \n    preIndex -= max(sign(preIndex), 0.0);\n    int index = int(preIndex) + 4;        \n    \n    return indexPerDifference[index];\n}\n\n\n\n\nint inLine(vec2 start, vec2 end, vec2 position, int head, out vec4 positions)\n{\n    int x = int(start.x);\n    int y = int(start.y);\n    \n    int dx = abs(x - int(end.x));\n    int dy = abs(y - int(end.y));\n    \n    int sx = start.x < end.x ? 1 : -1;\n    int sy = start.y < end.y ? 1 : -1;\n    \n    int err = (dx > dy ? dx : -dy) / 2;\n    \n    \n    int index = head+1;\n    while(index > 0)\n    {   \n        positions.xy = vec2(x, y);\n        int e2 = err;\n        \n        if (e2 > -dx)\n        {\n            err -= dy;\n            x += sx;\n        }\n        \n        if (e2 < dy)\n        {\n            err += dx;\n            y += sy;\n        }\n        index--;\n    }\n    \n    positions.zw = vec2(x, y);\n    vec2 difference = abs(positions.zw - position);\n    vec2 difference2 = abs(positions.xy - position);\n    vec2 add = difference2 + difference;\n    \n    if(difference.x == 0.0 && difference.y == 0.0)\n        return 1;\n    else if(difference2.x == 0.0 && difference2.y == 0.0)\n        return 3;\n    else if(add == vec2(1.0, 1.0))\n        return 2;\n    else\n        return 0;\n}\n\nvec3 flashLines(in vec2 cell, in vec2 cellInner, in vec2 positions[8], float scale, vec2 cellInnerCoordinates)\n{    \n    float timeScaled = iTime * 1.1;\n    float floorTime = floor(timeScaled);    \n    \n    \n    if(random2(vec2(floorTime, floorTime)).x > 0.2)\n        return vec3(0.0);\n    \n    float time = fract(timeScaled);\n    \n    vec4 headCells;\n    \n    vec4 timedPositions = positionsForTime(floorTime, scale);\n    timedPositions.yw += iTime * 0.15;\n    \n    vec4 flooredPositions = floor(timedPositions);    \n    float distanceBetweenPositions = distance(flooredPositions.xy, flooredPositions.zw);    \n    vec2 difference = abs(flooredPositions.zw - flooredPositions.xy);\n    float amount = max(difference.x, difference.y);\n    float ti = amount * time;\n    \n    int result = inLine(timedPositions.xy, timedPositions.zw, cell, int(ti), headCells);\n    \n    if(result == 0)\n        return vec3(0.0);\n    else\n    {\n        vec2 positionA;\n        vec2 positionB;\n        vec3 pointAndLine;\n        \n        if(result == 1)\n        {\n            \n            positionA = positions[indexFromDifference(headCells.xy - cell)];                        \n            positionB = cellInner;\n            pointAndLine.x = point(cellInnerCoordinates, cellInner); \n        }\n        else if (result == 2)\n        {   \n            headCells -= cell.xyxy;\n            \n            positionA = positions[indexFromDifference(headCells.xy)];\n            positionB = positions[indexFromDifference(headCells.zw)];    \n        }\n        else if(result == 3)\n        {           \n            positionB = positions[indexFromDifference(headCells.zw - cell)]; \n            positionA = cellInner;              \n            pointAndLine.x = point(cellInnerCoordinates, cellInner);                                    \n        }\n    \n        pointAndLine.y = lineNoDistanceFade(cellInnerCoordinates, positionA, positionB);    \n        vec2 mid = mix(positionA, positionB, fract(ti));\n        pointAndLine.z = pointInLine(cellInnerCoordinates, mid);    \n        return pointAndLine;\n    }         \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xx;\n    \n    float scale = 10.0;\n\n    uv *= scale;\n    uv.y += iTime * 0.15;\n    \n    vec2 cellNumber = floor(uv);\n    vec2 cellInnerCoordinates = fract(uv);\n    \n    vec2 actualCell, randomPoint;\n    vec2 addedCell;    \n    \n    float points = 0.0;\n    float lines = 0.0;\n    \n    vec2 centeredPoint = random2(cellNumber);    \n    centeredPoint = 0.5 + 0.5*sin(iTime + 6.2831*centeredPoint );\n    \n    vec2 pointPositions[8];\n    vec2 actualPositions[8];\n    \n    int index = 0;\n    \n    for(int x = -1; x <= 1; x++)\n        for(int y = -1; y <= 1; y++)\n        {                \n            if(x == 0 && y == 0)\n                continue;\n            addedCell = vec2(float(x), float(y));            \n            actualCell = cellNumber + addedCell;\n            randomPoint = random2(actualCell);            \n            randomPoint = 0.5 + 0.5 * sin(iTime + 6.2831 * randomPoint);\n            pointPositions[index] = addedCell + randomPoint;\n            actualPositions[index] = actualCell;\n            index++;\n        }\n    \n    for(index = 0; index < 8; index++)\n    {\n        vec2 randomPoint = pointPositions[index];                    \n        lines += line(cellInnerCoordinates, centeredPoint, randomPoint);\n        points += point(randomPoint, cellInnerCoordinates);      \n    }\n    \n    points += point(centeredPoint, cellInnerCoordinates);        \n      \n    vec2 top = pointPositions[1];\n    vec2 left = pointPositions[3];\n    vec2 right = pointPositions[4];  \n    vec2 bottom = pointPositions[6];\n    \n    // Left top    \n    lines += line(cellInnerCoordinates, left, top);    \n   \n    // Left bottom    \n    lines += line(cellInnerCoordinates, left, bottom);\n    \n    // Right top      \n    lines += line(cellInnerCoordinates, right, top);\n    \n    // Right bottom    \n    lines += line(cellInnerCoordinates, right, bottom);\n    \n    \n    //vec3 color = vec3(0.015 / minimumDistance);\n    vec3 color;\n    \n    vec3 flash = flashLines(cellNumber, centeredPoint, pointPositions, scale, cellInnerCoordinates);    \n       \n    vec3 co = vec3(0.83, 0.15, 0.455);\n   \n    color.rgb += points;\n    color.rgb += vec3(0.0, 0.45, 0.9) * lines;\n    \n    \n    color.rgb = mix(vec3(0.0), vec3(0.0, 0.45, 0.9), lines);\n    \n    color.rgb = mix(color.rgb, co, flash.x + flash.y * 0.35 + flash.z * .5); \n    color.rgb = mix(color.rgb, vec3(1.0), saturate(flash.x * 1.05 - .4) +  saturate(flash.y * 0.35 * 1.5 - 0.625) + saturate(flash.z * 1.05 - 0.625) + points);\n    \n    // Draw grid\n    //color.r += step(cellInnerCoordinates.x, 0.02) + step(cellInnerCoordinates.y, 0.02);\n  \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}