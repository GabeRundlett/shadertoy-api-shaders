{
    "Shader": {
        "info": {
            "date": "1725906365",
            "description": "A snake with googly eyes that moves throughout the screen while pulsating colors",
            "flags": 0,
            "hasliked": 0,
            "id": "MXfcRN",
            "likes": 8,
            "name": "Silly Little Guy",
            "published": 3,
            "tags": [
                "funny",
                "comedy"
            ],
            "usePreview": 0,
            "username": "Bagdaja",
            "viewed": 81
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{ \n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y; \n    const int segments = 16;\n    \n    vec2 cArr[segments]; \n    \n    //setting the color as black\n    fragColor.xyz=vec3(0.);\n    \n    \n    //Getting the centers of all the segments of the snake\n    for(int i; i<segments; i++){ \n        cArr[i] = vec2(sin((iTime-float(i)*0.1)*1.9),sin((iTime-float(i)*0.1)*1.4)); \n    } \n    \n    //Using the derivative of the sin function to get a vector pointing forward\n    vec2 cEyeDir = 0.1*normalize(vec2(1.9*cos(iTime*1.9),1.4*cos(iTime*1.4)));\n    \n    //Taking the perpendicular of cEyeDir to correctly position the eyes\n    vec2 cEyePerp = vec2(cEyeDir.y,-cEyeDir.x); \n    \n    vec2 cEye1 = cArr[0] + cEyeDir \n    + cEyePerp;\n    \n    vec2 cEye2 = cArr[0] + cEyeDir \n    - cEyePerp; \n    \n    //Drawing the pupils of the eyes, adding a cos and a sin to make them move constantly in a weird pattern\n    if(distance(uv+vec2(cos(iTime*2.)*0.015,sin(iTime*2.34)*0.015),cEye1)<0.025 || distance(uv+vec2(cos(iTime*1.8)*0.02,sin(iTime*2.14)*0.017),cEye2)<0.025){ \n        fragColor.xyz=vec3(0.); \n        return; \n    } \n    \n    //Drawing the white of the eyes\n    if(distance(uv,cEye1)<0.05 || distance(uv,cEye2)<0.05){\n        fragColor.xyz=vec3(1.); \n        return; \n    } \n    \n    //The distance to the segment\n    float d;\n    \n    for(int i; i<segments; i++){ \n        d = distance(uv,cArr[i]);\n        \n        //Drawing the segment's red taking the max only so they don't overlap\n        fragColor.x = max(fragColor.x, smoothstep(0.6,1.,1.-d));\n        \n        //Same thing with the blue but the further segments get more blue\n        fragColor.z = max(fragColor.z, (float(i)/float(segments))*0.3+0.4*smoothstep(0.6,1.,1.-d)); \n        \n        //The green is colored depending on a sine wave by time, making it pulse\n        fragColor.y = max(fragColor.y,(1.0+sin(iTime*0.8))*smoothstep(0.0,1.0,0.4-d)); \n    } \n    \n    //We overwrite the last segments green pulse with a way higher one as to simulate a lightbug kinda thing\n    fragColor.y = max(fragColor.y,(1.0+sin(iTime))*0.5*smoothstep(0.0,1.0,0.7-d)); \n    \n    \n}\n\n/*\n    Notes:  this is my first shader :), using the derivative to get cEyeDir is probably overkill, I could have just taken the \n            distance from segment 0 and segment 1 and normalized it, but I found the idea of using derivatives funny, and probably\n            useful in other applications regarding shaders. Probably a lot of the math here is redundant and I could extract a lot\n            of different calculations but well, I'm just too lazy. Hoped you enjoyed it and hope to make a lot of cooler shaders \n            because this is fun, lol.\n*/\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}