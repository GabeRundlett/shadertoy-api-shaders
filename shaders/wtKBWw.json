{
    "Shader": {
        "info": {
            "date": "1614656005",
            "description": "I worked out the distance to a parabola!",
            "flags": 0,
            "hasliked": 0,
            "id": "wtKBWw",
            "likes": 2,
            "name": "Distance to Parabola",
            "published": 3,
            "tags": [
                "2d",
                "sdf",
                "distance",
                "cubic",
                "parabola"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 162
        },
        "renderpass": [
            {
                "code": "/*\nThe idea is to find the x coordinate on the parabola that minimizes the\ndistance between the point and the parabola.\n\nFirst set up the distance-for-x-coordinate function:\nd(x) = (x - p.x)^2 + (hx^2 - p.y)^2\n\nNow we need to minimize it! How though?\nWe can't answer that directly, but we can narrow it down to a finite\ncollection of points and then test each one.\n\nThe idea behind how to figure out where potential minimums are is\nto realize that if it IS a minimum, then the function must be increasing\naway it, other wise there has to be something smaller. If its increasing away\nfrom it, then coming in from the left, the function must be decreasing, and\ngoing out on the right, the function must be increasing. Somewhere in between,\nit must not be increasing or decreasing at all.\n\nTo figure out how much a function is increasing and decreasing we need\ncalculus. Specifically, the derivative. Then, knowing that we have simply\nto solve for where its derivative is zero (the function is not increasing\nor decreasing).\n\nSo I'll wrap up the maths (d'(x) means derivative of d(x)):\nd'(x) = 2(x - p.x) + 4(hx^2 - p.y)hx\n\nd'(x) = 0\n2(x - p.x) + 4(hx^2 - p.y)hx = 0\n2h^2x^3 + (1 - 2p.yh)x - p.x = 0\n\nWhich is a cubic equation, one of whose roots is the minimum.\n*/\n\n#define eta 1.0471975512 // pi/3\nfloat sdParabola(in vec2 p, in float h) {\n    if (abs(h) < 1e-3) return p.y;\n    p.x = abs(p.x);\n\n    float d0 = (1.5 / h - 3.0 * p.y) / h, d1 = 13.5 * p.x / (h * h);\n    float q = d1 * d1 + 4.0 * d0 * d0 * d0, j = sqrt(abs(q));\n\n    vec2 c = vec2(step(0.0, q) * j - d1, step(0.0, -q) * j);\n    if (abs(c.x) + abs(c.y) < 1e-3) c = vec2(-j - d1, 0.0);\n    float t = atan(c.y, c.x) / 3.0, r = pow(0.25 * dot(c, c), 1.0 / 6.0);\n\n    float w = d0 / r - r;\n    float x = max(w * cos(t), -w * cos(t - eta)) / 3.0;\n    return length(p - vec2(x, h * x * x)) * sign(h * p.x * p.x - p.y) * sign(h);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n\n    float a = sin(0.25 * iTime) * 16.0;\n    float b = cos(0.25 * iTime);\n    float c = 0.25 * sin(0.5 * iTime);\n\n    float d = sdParabola(uv + vec2(0.5 * b / a, 0.25 * b * b / a - c), a);\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}