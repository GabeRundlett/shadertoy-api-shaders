{
    "Shader": {
        "info": {
            "date": "1570525133",
            "description": "ray marching, wavy torus with phong shading, disco lighting, uv and glow, AA",
            "flags": 0,
            "hasliked": 0,
            "id": "3sy3zK",
            "likes": 4,
            "name": "TorusPhong",
            "published": 3,
            "tags": [
                "torusphong"
            ],
            "usePreview": 0,
            "username": "JennySchub",
            "viewed": 543
        },
        "renderpass": [
            {
                "code": "\n#define AA 1.\n#define distThresh .001\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotate(vec3 vector, vec3 axis, float angle){\n    return (vec4(vector, 1.)*rotationMatrix(axis, angle)).xyz;\n}\n\nfloat DistToLine(vec3 pt1, vec3 pt2, vec3 testPt)\n{\n    return length(cross(pt1-pt2, pt2-testPt));\n}\n\nfloat color(float offset){\n    return min(.5,max(0.,abs(-(abs(mod(offset,1.))-.5))*2.-.3333))*2.;\n}\n\nfloat getDistance(vec3 p, float distMul, float bigR, float smallR){\n \treturn length(vec2(length(p.xz)*distMul-bigR, p.y))-smallR;\n}\nvec3 raymarch(int steps, \n              vec3 ro, \n              vec3 rd, \n              float bigR, \n              float smallR, \n              out float distMul, \n              out float distOrigin, \n              out float distSurface,\n              out vec2 tex,\n              out float minDist,\n              out float minLocked){\n    vec3 p=ro;\n    tex;\n    distOrigin=0.;\n    for(int i=0; i<steps; i++){\n        \n        tex.x = atan(p.x, p.z);\n        tex.y = atan(p.y, (length(p.xz)-bigR)/smallR);\n        distMul = sin(iTime)*sin(tex.x*15.)*sin(tex.y*10.)*.2+1.;\n        \n        //distMul=sin(a*6.)*sin(iTime)*.1+.8;\n        distSurface = getDistance(p, distMul, bigR, smallR);\n        if(distSurface<minDist) minDist=distSurface;\n        else minLocked = minDist+.04*minDist/distSurface;\n        p+=rd*distSurface*.5;\n        distOrigin+=distSurface*.5;\n        if(distOrigin>15. || distSurface<distThresh){\n            break;\n        }\n    }\n\treturn p;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouz = iMouse.xy;\n    if(mouz.x<.01){\n        mouz.x=100.;\n        mouz.y=100.;\n    }\n    float zoom = (mouz.x+10.)/iResolution.x;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 col = vec3(0.);\n    vec2 uvAA = uv;\n    float lightColorSpeed = .1;\n    vec3  cam = vec3(0., -((mouz.y+.01)/iResolution.y*10.-5.), 3.),\n        //light = vec3(sin(iTime)*3., abs(sin(iTime*5.))*1., cos(iTime)*3.),\n        //lightColor = vec3(color(iTime*lightColorSpeed), color(iTime*lightColorSpeed+.3333), color(iTime*lightColorSpeed+.6666)),\n        lightDir, normal,\n        lookat = vec3(0.),\n        fwd = normalize(lookat-cam),\n        r = normalize(cross(fwd, vec3(0.,1.,0.))),\n        u = cross(fwd, r),\n        c = cam + fwd*zoom;\n    \n    vec3[2] lights;\n    lights[0] = vec3(sin(iTime)*3., abs(sin(iTime*5.))*1., cos(iTime)*3.);\n    lights[1] = vec3(1.);\n    vec3[2] lightColors;\n    lightColors[0]=vec3(color(iTime*lightColorSpeed), color(iTime*lightColorSpeed+.3333), color(iTime*lightColorSpeed+.6666));\n    lightColors[1]=.5*vec3(color(iTime*lightColorSpeed+.5), color(iTime*lightColorSpeed+.3333+.5), color(iTime*lightColorSpeed+.6666+.5));\n    \n    float bigR = sin(iTime)*.1+1.1;\n    float smallR = -cos(iTime)*.2+.5;\n    vec2 tex;\n    \n    for(float aaX=0.; aaX<AA;aaX++){\n    \tuvAA.y = uv.y;\n        uvAA.x+=1./(AA*iResolution.y);\n        for(float aaY=0.; aaY<AA;aaY++){\n            uvAA.y+=1./(AA*iResolution.y);\n            vec3 i = c+r*uvAA.x-u*uvAA.y,\n                ray = normalize(i-cam);\n                //ray = rotate(rotate(fwd, r, uvAA.y/zoom),u, uvAA.x/zoom);\n\n\n            float distSur, distOrigin=0., minDist=100., minLocked=100., distMul;\n            vec3 p = cam;\n            /*for(int i=0; i<1000; i++){\n                float a=atan(p.x,p.z);\n                distMul=sin(a*6.)*sin(iTime)*.1+.8;\n                distSur = getDistance(p, distMul, bigR, smallR);\n                if(distSur<0.0001||distOrigin>15.) break;\n                \n                if(distSur<minDist) minDist=distSur;\n                else minLocked = minDist+.04*minDist/distSur;\n                \n                p+=ray * distSur;\n                distOrigin+=distSur;\n            }*/\n            p=raymarch(1000, p, ray, bigR, smallR, distMul, distOrigin, distSur, tex, minDist, minLocked);\n\n            for(int l=0; l<lights.length(); l++){\n                vec3 light = lights[l];\n                vec3 lightColor = vec3(.5)+lightColors[l];\n                \n                if(distSur<distThresh){\n                    col+=0.01;\n                    lightDir = -normalize(p-light);\n                    \n\t\t\t\t\t//normal = normalize(p-bigR*normalize(vec3(p.x,0.,p.z)));\n                    float epsilon = 0.001; // arbitrary â€” should be smaller than any surface detail in your distance function, but not so small as to get lost in float precision\n                    float centerDistance = getDistance(p, distMul, bigR, smallR);\n                    float xDistance = getDistance(p + vec3(epsilon, 0, 0), distMul, bigR, smallR);\n                    float yDistance = getDistance(p + vec3(0, epsilon, 0), distMul, bigR, smallR);\n                    float zDistance = getDistance(p + vec3(0, 0, epsilon), distMul, bigR, smallR);\n                    normal = normalize((vec3(xDistance, yDistance, zDistance) - centerDistance) / epsilon);\n                    \n                    //tex.x = atan(p.x,p.z);\n                    //tex.y = length(p.xz)*distMul-bigR;\n                    float omit;\n                    vec2 omit2;\n                    float shadow = length(raymarch(20, light, normalize(p-light), bigR, smallR, omit, omit, omit, omit2, omit, omit)-p);\n                    float lightInt = 2./length(p-light) - shadow;\n                    \n                    // diffuse\n                    col+=lightColor*(clamp(dot(normal, lightDir),0.,1.)*lightInt);\n                    col.gb*=1.-.1*abs(sin(tex.x*10.+tex.y*10.));\n                    //col.r+=.1*(1.-abs(sin(tex.x*10.+tex.y*10.)));\n                    \n                    //specular\n                    float sharpness=pow(2.,6.);\n                    float specInt = 5.;\n                    col+=lightColor*specInt*(.6*pow(max(0.,dot(-ray, reflect(-lightDir, normal))),sharpness)*lightInt);\n                }\n                else{\n                    // light dots\n                    col+=lightColor*pow(.1/DistToLine(cam, cam+ray, light),1.1);\n                }\n            }\n            // glow\n            col+=sin(iTime*2.3)*1.*clamp(lightColors[0].yzx*pow(.01/minLocked,.7),0.,1.);\n        }\n    }\n    \n    col/=AA*AA;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}