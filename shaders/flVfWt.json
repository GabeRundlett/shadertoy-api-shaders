{
    "Shader": {
        "info": {
            "date": "1665466727",
            "description": "Persistent orbit controls like in Three.js.\nDrag with the mouse, and the position you dragged to will be saved.",
            "flags": 32,
            "hasliked": 0,
            "id": "flVfWt",
            "likes": 2,
            "name": "Orbit Controls",
            "published": 3,
            "tags": [
                "3d",
                "simple",
                "mouse",
                "orbit",
                "buffer",
                "navigation",
                "pan",
                "persistent"
            ],
            "usePreview": 0,
            "username": "mmnz",
            "viewed": 188
        },
        "renderpass": [
            {
                "code": "// Persistent orbit controls like in Three.js.\n// Mouse position is saved to Buffer A.\n// There are probably better raymarching and lighting methods -\n// the extent of my knowledge so far comes from the\n// first hour or two of Happy Jumping (youtu.be/Cfe5UQ-1L9Q).\n\n// Returns distance, material\nvec2 map(in vec3 position) {\n    float sphere = length(position) - 0.25;\n    float terrain = position.y + 0.25;\n    return (sphere < terrain) ? vec2(sphere, 1.0) : vec2(terrain, 2.0);\n}\n\n// Returns t, material shadow\nvec3 castRay(in vec3 rayOrigin, in vec3 rayDirection) {\n    float t = 0.0;\n    float material = -1.0;\n    float shadow = 1.0;\n    float mint = 0.001;\n    float maxt = 20.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 position = rayOrigin + t * rayDirection;\n        vec2 h = map(position);\n        material = h.y;\n        shadow = min(shadow, 8.0 * h.x / t);\n        if (h.x < mint) { break; }\n        t += h.x;\n        if (t > maxt) { break; }\n    }\n    if (t > maxt) { t = material = -1.0; }\n    shadow = clamp(shadow, 0.0, 1.0);\n    return vec3(t, material, shadow);\n}\n\n// Returns normal\nvec3 calcNormal(in vec3 position) {\n    vec2 e = vec2(1, -1) * inversesqrt(12000000.0);\n    return normalize(\n        e.xyy * map(position + e.xyy).x + \n\t\te.yyx * map(position + e.yyx).x + \n\t\te.yxy * map(position + e.yxy).x + \n\t\te.xxx * map(position + e.xxx).x\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float pi = acos(-1.0);\n    // Customisable\n    float thetaOffset = 0.1 * iTime; // Extra rotation\n    float ymin = 0.1; // 0.0 = 0deg, facing the horizon\n    float ymax = 0.9; // 1.0 = 90deg, facing the ground\n    float orbitRadius = 1.0; // Distance from center\n    // Always the same\n    vec2 storedMouse = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    float theta = -2.0 * pi * storedMouse.x + thetaOffset;\n    float phi = 0.5 * pi * (1.0 - storedMouse.y) * (ymax - ymin) + ymin;\n    vec3 rayOrigin = orbitRadius * vec3(sin(theta)*cos(phi), sin(phi), cos(theta)*cos(phi));\n    // Standard camera stuff\n    vec3 target = vec3(0);\n    float focalLength = 1.5;\n    vec3 ww = normalize(target - rayOrigin);\n    vec3 uu = normalize(cross(ww, vec3(0, 1, 0)));\n    vec3 vv = normalize(cross(uu, ww));\n    vec3 rayDirection = normalize(p.x * uu + p.y * vv + focalLength * ww);\n\n    // Sky colour, fading to grey at the horizon\n    vec3 color = vec3(0.4, 0.7, 1.0) - 0.7 * rayDirection.y;\n    color = mix(color, vec3(0.7, 0.75, 0.8), clamp(exp(-10.0 * rayDirection.y), 0.0, 1.0));\n    \n    vec3 ray = castRay(rayOrigin, rayDirection);\n    \n    if (ray.y > 0.0) {\n        vec3 position = rayOrigin + ray.x * rayDirection;\n        vec3 normal = calcNormal(position);\n        \n        // Material colour\n        vec3 material = vec3(0);\n        if (ray.y < 1.5) {\n            material = vec3(0.18); // Sphere: grey\n        } else {\n            material = vec3(0.05, 0.1, 0.02); // Terrain: green checkerboard\n            material += 0.05 * smoothstep(-0.1, 0.1, sin(18.0 * position.x) + cos(18.0 * position.z));\n        }\n        \n        // Lighting colours\n        vec3 sun_direction = normalize(vec3(0.8, 0.4, 0.2));\n        float sun_diffuse = clamp(dot(normal, sun_direction), 0.0, 1.0);\n        float sun_shadow = castRay(position + normal * 0.001, sun_direction).z;\n        float sky_diffuse = clamp(0.5 + 0.5 * dot(normal, vec3(0, 1, 0)), 0.0, 1.0);\n        float ground_diffuse = clamp(0.5 + 0.5 * dot(normal, vec3(0, -1, 0)), 0.0, 1.0);\n        color  = material * vec3(7.0, 4.5, 3.0) * sun_diffuse * sun_shadow;\n        color += material * vec3(0.5, 0.8, 0.9) * sky_diffuse;\n        color += material * vec3(0.7, 0.3, 0.2) * ground_diffuse;\n    }\n    \n    fragColor = vec4(pow(color, vec3(0.4545)), 1.0);\n    \n    // Test first 2px of Buffer A:\n    // fragColor = texture(iChannel0, (2.0 * fragCoord - iResolution.xy) / iResolution.y);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Initialise buffer to white (buffer is unused if alpha is empty).\n    if (texelFetch(iChannel0, ivec2(0,0), 0).a < 1.0) {\n        fragColor = vec4(1);\n        return;\n    }\n\n    // Fetch old values\n    vec2 current = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    vec2 previous = texelFetch(iChannel0, ivec2(1, 0), 0).xy;\n    vec4 mouse = iMouse / iResolution.xyxy;\n    \n    // Fix for Shadertoy ignoring mouseup outside canvas. Reset previous on click.\n    // Fix removed because it breaks things on iOS (where iMouse.w is positive until mouseup).\n    // if (mouse.w > 0.0) {\n    //     previous = current;\n    // }\n    \n    // When mouse down, add the mouse position to the previous position minus starting offset.\n    // Otherwise, save the current position to be used for the next time the mouse is dragged.\n    if (mouse.z > 0.0) {\n        vec2 next = previous + mouse.xy - abs(mouse.zw);\n        current = vec2(fract(next.x), clamp(next.y, 0.0, 1.0)); // wrap x, clamp y\n    } else {\n        previous = current;\n    }\n    \n    // Save current to (0,0) and previous to (1,0)\n    fragColor = vec4(fragCoord.x < 1.0 ? current : previous, 0.0, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}