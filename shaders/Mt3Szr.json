{
    "Shader": {
        "info": {
            "date": "1477709167",
            "description": "trying to reverse engineer [url]https://www.shadertoy.com/view/XlX3Rj[/url] by looking at it, click and drag to scroll",
            "flags": 0,
            "hasliked": 0,
            "id": "Mt3Szr",
            "likes": 57,
            "name": "Fractal Thingy",
            "published": 3,
            "tags": [
                "2d",
                "fractal",
                "fold"
            ],
            "usePreview": 0,
            "username": "Klems",
            "viewed": 1813
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n#define PHI 1.61803398875\n\n// fabrice's rotation matrix\nvec2 V;\n#define rot(a) mat2( V= sin(vec2(1.57, 0) + a), -V.y, V.x)\n\n// iq's HSV\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb);\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// hexagonal distance\nfloat hexDist(vec2 p) {\n    #define MULT1 (1.0/tan(PI/3.0))\n\t#define MULT2 (1.0/sin(PI/3.0))\n\tfloat dx = abs(p.x);\n\tfloat dy = abs(p.y);\n\treturn max(dx+dy*MULT1, max(dx, dy*MULT2));\n}\n\nvec4 fractal( in vec2 p ) {\n    \n    // keep current scale\n    float scale = 1.0;\n    \n    // used to smoothstep\n    float aliasBase = 1.0 / iResolution.y;\n    \n    // accumulated alpha\n    float alpha = 0.0;\n    // accumulated color\n    vec3 color = vec3(0.0);\n  \n    #define LEVELS 10\n    for (int i = 0 ; i < LEVELS ; i++) {\n        \n        // scale\n        float s = 2.0;\n\t\t\n        // repeat axis according to scale ala TEXTURE_ADDRESS_MIRROR\n        p = 1.0 - abs(s*fract(p-0.5)-s*0.5);\n        \n        // fold\n        float theta = float(i) * PI * 0.125;\n        //theta = iTime*0.02 * float(i); // try this one\n        p *= rot(theta);\n        \n        // update scale\n        scale *= s;\n        \n        // jump first steps cause they're less interesting\n        if (i < 4) continue;\n        \n        // texture\n        \n        // borders\n        vec2 uv = abs(p);\n        float delt1 = abs((hexDist(uv)-0.6)-0.1);\n        float delt2 = min(length(uv)-0.2, min(uv.x, uv.y));\n        float m = min(delt1, delt2);\n        float alias = aliasBase*0.5*scale;\n        float f = smoothstep(0.10+alias, 0.10, m)*0.4 + smoothstep(0.22, 0.11, m)*0.6;\n        \n        // pulse\n        float r = length(uv)/0.707106;\n        float t = mod(iTime*1.5, float(LEVELS-4)*2.0) - float(i);\n        r = (r + 1.0 - t)*step(r*0.5, 1.0);\n        r = smoothstep(0.0, 0.8, r) - smoothstep(0.9, 1.0, r);\n        \n        // mix colors\n        vec3 c = vec3(smoothstep(0.06+alias, 0.06, m));\n        vec3 hue = hsv2rgb( vec3(iTime*0.03+float(i)*0.08, 0.5, 1.0) );\n        c = c*hue;\n        c += c*r*1.5;\n        \n        // front to back compositing\n        color = (1.0-alpha)*c+color;\n        alpha = (1.0-alpha)*f+alpha;\n        \n    }\n    \n    return vec4(color, alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    vec2 p = uv;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    if (iMouse.z < 0.5)\n    \tuv += vec2(0.4487, 0.17567)*(iTime+10.3312);\n    else\n        uv -= (iMouse.xy-iResolution.xy*0.5)*0.015;\n    \n\tuv *= 0.07;\n    \n    vec4 frac = fractal(uv);\n    \n    // mix fractal with a grey background\n    fragColor.rgb = mix(vec3(0.5), frac.rgb, frac.a);\n    // vignette\n    fragColor.rgb = mix(fragColor.rgb, vec3(0), dot(p, p)*0.5);\n    \n    fragColor.a = 1.0;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}