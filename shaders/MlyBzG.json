{
    "Shader": {
        "info": {
            "date": "1542912037",
            "description": "raymarching using intersections instead of distance fields. finding the normal is quite tricky.",
            "flags": 0,
            "hasliked": 0,
            "id": "MlyBzG",
            "likes": 12,
            "name": "low-step raymarching",
            "published": 3,
            "tags": [
                "3d",
                "raymarching"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 665
        },
        "renderpass": [
            {
                "code": "#define maxdist 20.0\n#define steps 5\n#define antialiasing 1\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n//random function by romasm\n//https://www.shadertoy.com/view/4scfz4\nfloat seed = 0.0;\nvec2 fragUV = vec2(0.0);\nfloat rand() \n{\n\tfloat r = fract(sin(dot(fragUV, vec2(12.9898, 78.233)) + seed) * 43758.5453);\n\tseed++;\n    return r;    \n}\n\n//a sphere intersection function from iq\n//https://www.shadertoy.com/view/4djSDy\nvec2 sphIntersect( in vec3 ro, in vec3 rd, float size)\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro )-size*size;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(99999);\n\treturn vec2(-b-sqrt(h),-b+sqrt(h));\n}\n\n//same function but i changed vec3 with vec2\nvec2 sphIntersect( in vec2 ro, in vec2 rd, float size)\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro )-size*size;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(99999);\n\treturn vec2(-b-sqrt(h),-b+sqrt(h));\n}\n\nvec3 texture2(vec3 p, vec3 n) {\n    vec3 c = cos(p*3.0-n);\n    vec3 s = sin(p*3.0+n*3.0);\n    \n    vec3 col = s*c.yzx*0.5+0.5;\n    col *= dot(n,normalize(vec3(-1)))*0.5+0.5;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragUV = fragCoord / iResolution.xy;\n    seed = iTime;\n    \n    vec3 acc = vec3(0);\n    for (int aa = 0; aa < antialiasing; aa++) {\n#if antialiasing==1\n        vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n#else\n        vec2 uv = ((fragCoord+vec2(rand(),rand()))*2.0-iResolution.xy)/iResolution.y;\n#endif\n\n        vec3 rd = normalize(vec3(uv,1));\n        vec3 ro = vec3(0.5,0.5,iTime);\n        \n        if (length(iMouse.xy) > 40.0) {\n            rd.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n            rd.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }\n        \n        vec3 ird = 1.0/vec3(length(rd.yz),length(rd.xz),length(rd.xy));\n\n        float dist = 0.0;\n        vec3 n = vec3(0,0,-1);\n        for (int i = 0; i < steps; i++) {\n            vec3 p = fract(ro+rd*dist)-0.5;\n\n            vec2 a = vec2(-1,1);\n            float l = 0.0;\n\n            //for cylinder normals\n            vec3 mask = vec3(1);\n\n            vec2 d = sphIntersect(p,rd,0.58);\n            if (d.x < 0.0) {\n                l = d.y;\n            }\n\n            d = sphIntersect(p.yz,rd.yz*ird.x,0.4)*ird.x;\n            if (d.x < 0.0 && d.y > l) {\n                mask = vec3(0,1,1);\n                l = d.y;\n            }\n\n            d = sphIntersect(p.xz,rd.xz*ird.y,0.4)*ird.y;\n            if (d.x < 0.0 && d.y > l) {\n                mask = vec3(1,0,1);\n                l = d.y;\n            }\n\n            d = sphIntersect(p.xy,rd.xy*ird.z,0.4)*ird.z;\n            if (d.x < 0.0 && d.y > l) {\n                mask = vec3(1,1,0);\n                l = d.y;\n            }\n\n            if (l > 0.0) {\n                dist += l;\n                p += rd*l;\n                n = -p*mask;\n            } else {\n                break;\n            }\n        }\n\n        vec3 background = vec3(0.2);\n        vec3 col = background;\n\n        if (dist < maxdist) {\n            vec3 p = ro+rd*dist;\n\n            n = normalize(n);\n\t\t\t\n            col = texture2(p, n);\n\n            col = mix(col,background,sqrt(dist/maxdist));\n        }\n        acc += col;\n    }\n    \n    \n    \n    fragColor = vec4(sqrt(acc/float(antialiasing)),1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}