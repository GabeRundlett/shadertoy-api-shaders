{
    "Shader": {
        "info": {
            "date": "1631768030",
            "description": "Beautiful math produce beautiful images. This program draws 2d sections of 3d Boyd-Maxwell ball packings.",
            "flags": 0,
            "hasliked": 0,
            "id": "NdK3zy",
            "likes": 26,
            "name": "Boyd-Maxwell ball packings",
            "published": 3,
            "tags": [
                "2d",
                "coxeter",
                "hyperbolic",
                "circlepacking"
            ],
            "usePreview": 0,
            "username": "neozhaoliang",
            "viewed": 1136
        },
        "renderpass": [
            {
                "code": "/*\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n2d slices of 3D Boyd-Maxwell Ball packings\n\nauthors: Chen Hao: https://num.math.uni-goettingen.de/~hchen/\n         Zhao Liang: https://twitter.com/neozhaoliang\n\nReference: see Hao's Ph.D thesis:\n\n    https://refubium.fu-berlin.de/bitstream/handle/fub188/1147/diss_haochen.pdf?sequence=1&isAllowed=y\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe name may sound unfamiliar to most people, but basically this is a kind of\nkaleidoscope structure in 4D hyperbolic space, we just draw their 2d slices here.\n\nFor a Coxeter group of rank 5 and level 2, the complement of its limit set form a dense\nball packing of the ideal boundary of hyperbolic 4-space, hence a ball packing of the\nEuclidean 3-space. We use z=c or y=c planes with varying c to see the circle packing patterns\non these slices.\n\n \nIn Hao's paper he listed out all Coxeter groups of level 2, the diagrams that\nhave 5 vertices with none of them surrounded by a blue box are all valid inputs for this program.\n\nUsage:\n\n1. Select a configuration below and uncomment it, or you can input one manually\n2. In common.frag, use `#define DrawLimitSet` to switch between the limit set view and circle packing view\n3. In common.frag, change `ZOOM` to zoom in/out.\n4. When drawing circle packings, use the bvec4 param 'isRealBall' to add/remove circles (explained below).\n5. In common.frag, use `#define DrawVerticalSections` to show vertical sections (suggested by @mla)\n\nExample:\n\nThis is a rank 5 group of level 2:\n     \n     v2\n     x\n       \\   5\n     |  o --- o --- x\n     | / v4   v1    v0\n     x\n     v3\n     \nEach vertex in the diagram represents a 'virtual mirror' in 3d space (a plane or a sphere),\nthe labels on the edges indicate the angles between the mirrors.\n\nA vertex drawn by `x` means it has a `real ball` correspondes to it,\nA vertex drawn by `o` means it does not have a real ball correspondes to it.\nThere are always 5 virtual balls and at least one real ball.\n\nIf we iteratively reflect the real balls across the virual balls, we will eventually get a dense packing of\nthe 3d space.\n\nThe set of virtual balls are called coclusters, the set of real balls are called clusters.\n\nYou can see there is a Euclidean triangle (333) in the diagram, this holds for almost all groups of rank 5 and level 2.\n\nThe input data requires you specify:\n\nparam 1:\n\nThe type of the Euclidean triangle, must be one of 244, 236 or 333. In this example it's 333.\nThese virual mirrors are labelled as v2, v3, v4.\n\n| For the remaining two vertices, at least one must be 'x', choose such one as v0. If both two are 'x',\n| choose either of them as v0, the remaining one is labelled v1.\n\nparam 2:\n\nThe labels between v0 and (v2, v3, v4), in this example it's (2, 2, 2) (in a Coxeter diagram\ndisjoint mirrors are orthogonal with each other, hence has dihedral angle PI/2, hence label 2)\n\nparam 3:\n\nThe labels between v1 and (v2, v3, v4), in this example it's (2, 2, 5). Note v1 and v4 are connected\nby an edge of label 5.\n\nparam 4:\n\nThe label between v0 and v1, in this example it's 3 (edges with labels 3 are represented by an unlabelled line)\n\nparam 5:\n\nFour bools indicate those virtual mirrors in (v1, v2, v3, v4) that have real balls corresponde to them.\nIn this example v2, v3 are represented by 'x', v1, v4 are represented by 'o', hence v2, v3 have real balls,\nwhile v1, v4 do not. So the four bools should be (false, true, true, false). Note by our choice v0 is\nalways 'x', so v0 has a real ball correspondes to it. This real ball is always the z=0 plane.\n\nSo the above diagram gives input\n\ninit(333, vec3(2, 2, 2), vec3(2, 2, 5), 3, bvec4(0, 1, 1, 0))\n\n\n!important:\n\nFor the 333 triangle, you can arbitrarily order them as (v2, v3, v4), it doesn't matter.\n\nBut for the 236 triangle, the ordering is fixed, you must label them as\n\n  6   3\n*---*---*\nv2  v3  v4\n\nAlso for the 244 triangle, the ordering must be\n\n  4   4\n*---*---*\nv2  v3  v4\n\n\nI have included ~60 examples below, a complete list would contain around ~180+ diagrams,\naccording to Hao's enumeration. You can find other diagrams in his thesis paper.\n\nNote: \n\n1. Some diagrams may give equivalent packings, though the visual effects are different.\n2. The bvec param 'isRealBall' does not take effect in the 'limit set' view in most times,\nit's mainly used for adding/removing circles in the circle packing view. You can change some\n1's in it to 0 to remove the corresponding real balls, hence produce holes in the pattern.\n*/\n\n\n#define TT (iTime+1.)\n//#define MS iMouse\n#define MS ((2.0*iMouse.xyz-iResolution.xyz)/iResolution.y)\n\n//*****************************************************************************\n\n//#define config init(236, vec3(2, 2, 2), vec3(3, 2, 2), 5., bvec4(0))\n//#define config init(236, vec3(2, 2, 2), vec3(2, 2, 5), 3., bvec4(0, 0, 0, 0))\n//#define config init(236, vec3(2, 2, 2), vec3(3, 2, 2), 4., bvec4(0, 0, 0, 1))\n//#define config init(333, vec3(3, 3, 3), vec3(3, 3, 3), 3., bvec4(1, 1, 1, 1))\n//#define config init(333, vec3(3, 3, 2), vec3(2, 3, 3), 3., bvec4(1, 1, 0, 1))\n//#define config init(333, vec3(3, 2, 2), vec3(2, 3, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(333, vec3(4, 2, 2), vec3(2, 3, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(333, vec3(5, 2, 2), vec3(2, 3, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(333, vec3(2, 2, 5), vec3(2, 3, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(333, vec3(3, 2, 3), vec3(2, 3, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 5), vec3(2, 3, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 3), vec3(3, 3, 2), 5., bvec4(1, 1, 1, 1))\n//#define config init(333, vec3(2, 2, 3), vec3(3, 3, 2), 6., bvec4(1, 1, 1, 1))\n//#define config init(333, vec3(2, 3, 3), vec3(2, 3, 3), 2., bvec4(0, 0, 0, 1))\n//#define config init(244, vec3(2, 2, 2), vec3(2, 3, 2), 3., bvec4(0, 0, 0, 0))\n//#define config init(244, vec3(2, 3, 2), vec3(2, 4, 2), 2., bvec4(1, 1, 0, 1))\n//#define config init(244, vec3(2, 2, 2), vec3(2, 3, 2), 4., bvec4(0, 0, 0, 0))\n//#define config init(244, vec3(2, 2, 2), vec3(2, 3, 2), 5., bvec4(0, 1, 0, 1))\n//#define config init(236, vec3(2, 2, 2), vec3(2, 2, 3), 5., bvec4(0, 0, 0, 0))\n//#define config init(236, vec3(2, 2, 2), vec3(2, 2, 3), 6., bvec4(0, 1, 0, 0))\n//#define config init(244, vec3(3, 2, 2), vec3(2, 2, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(236, vec3(2, 2, 2), vec3(2, 3, 2), 4., bvec4(0, 0, 0, 1))\n//#define config init(333, vec3(3, 2, 2), vec3(2, 2, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(333, vec3(6, 2, 2), vec3(2, 2, 4), 2., bvec4(1, 0, 1, 0))\n//#define config init(333, vec3(2, 2, 4), vec3(2, 2, 4), 2., bvec4(1, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 5), vec3(2, 2, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 6), vec3(2, 2, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 4), vec3(2, 2, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(333, vec3(2, 2, 3), vec3(2, 2, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(333, vec3(6, 2, 2), vec3(2, 2, 4), 2., bvec4(1, 0, 1, 0))\n//#define config init(333, vec3(5, 2, 2), vec3(2, 2, 4), 2., bvec4(1, 0, 1, 0))\n//#define config init(333, vec3(4, 2, 2), vec3(2, 2, 4), 2., bvec4(1, 0, 1, 0))\n//#define config init(333, vec3(6, 2, 2), vec3(2, 2, 3), 2., bvec4(1, 0, 1, 0))\n//#define config init(333, vec3(6, 2, 2), vec3(2, 2, 4), 2., bvec4(1, 0, 1, 0))\n//#define config init(333, vec3(2, 2, 2), vec3(2, 2, 6), 3., bvec4(0, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 2), vec3(2, 2, 5), 3., bvec4(0, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 2), vec3(2, 2, 4), 4., bvec4(0, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 2), vec3(2, 2, 4), 3., bvec4(0, 0, 0, 0))\n//#define config init(236, vec3(2, 2, 3), vec3(3, 2, 6), 2., bvec4(1, 1, 1, 0))\n//#define config init(244, vec3(2, 2, 4), vec3(4, 2, 4), 2., bvec4(1, 1, 1, 0))\n//#define config init(244, vec3(2, 2, 3), vec3(4, 2, 4), 2., bvec4(1, 1, 1, 0))\n//#define config init(236, vec3(2, 2, 3), vec3(3, 2, 5), 2., bvec4(1, 1, 1, 0))\n//#define config init(236, vec3(2, 2, 4), vec3(3, 2, 4), 2., bvec4(1, 1, 1, 0))\n//#define config init(244, vec3(2, 2, 3), vec3(2, 3, 2), 5., bvec4(1, 1, 0, 1))\n//#define config init(244, vec3(2, 2, 2), vec3(3, 2, 4), 4., bvec4(0, 1, 1, 0))\n//#define config init(244, vec3(2, 4, 2), vec3(3, 2, 3), 2., bvec4(1, 1, 0, 1))\n//#define config init(236, vec3(2, 2, 6), vec3(3, 2, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(236, vec3(2, 2, 5), vec3(3, 2, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(236, vec3(3, 2, 2), vec3(2, 2, 6), 3., bvec4(1, 1, 1, 1))\n//#define config init(236, vec3(3, 2, 2), vec3(2, 2, 5), 3., bvec4(1, 1, 0, 1))\n//#define config init(236, vec3(3, 2, 2), vec3(2, 2, 4), 3., bvec4(1, 0, 0, 1))\n//#define config init(244, vec3(3, 2, 2), vec3(2, 2, 3), 5., bvec4(1, 1, 1, 1))\n//#define config init(244, vec3(4, 2, 2), vec3(2, 2, 4), 4., bvec4(1, 1, 1, 1))\n//#define config init(244, vec3(3, 2, 2), vec3(2, 2, 3), 5., bvec4(1, 1, 1, 1))\n//#define config init(333, vec3(5, 2, 2), vec3(2, 2, 6), 3., bvec4(1, 1, 1, 1))\n//#define config init(244, vec3(4, 2, 4), vec3(4, 2, 4), 2., bvec4(1, 1, 1, 1))\n//#define config init(244, vec3(4, 2, 2), vec3(2, 2, 4), 4., bvec4(1, 1, 1, 1))\n//#define config init(236, vec3(2, 3, 2), vec3(3, 2, 4), 3., bvec4(1, 1, 0, 1))\n//#define config init(244, vec3(2, 2, 2), vec3(3, 2, 3), 4., bvec4(0))\n//#define config init(244, vec3(4, 2, 2), vec3(2, 2, 4), 4., bvec4(1, 1, 1, 1))\n//#define config init(236, vec3(2, 2, 2), vec3(2, 3, 2), 5., bvec4(0, 0, 0, 1))\n#define config init(244, vec3(3, 2, 2), vec3(2, 2, 3), 3., bvec4(1, 0, 0, 0))\n\n\n//*****************************************************************************\n\nfloat map(vec2 p, inout int index) {\n    vec2 mouse = MS.xy;\n    float k = 1.0;\n    if (MS.z > 0.0) {\n        p -= mouse;\n        k = dot(p,p);\n        p /= k;\n        p += mouse;\n    }\n    const float strong_factor = 4.;\n#ifdef DrawVerticalSections\n    vec3 q = vec3(p.x, TT*0.1, p.y + 1.);\n#else\n    vec3 q = vec3(p, mod(TT*0.2 - 0.01, SECTION_HEIGHT - 0.02) + 0.01);\n#endif\n    return k*DE(q, index) * strong_factor;\n    \n}\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 post_process(vec3 col, vec2 uv) {\n  col = pow(clamp(col, 0., 1.), vec3(1.0/2.2)); \n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *= 0.5 + 0.5*pow(19.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.7);\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    config;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 p = 2. * uv - 1.;\n    p.x *= iResolution.x / iResolution.y;\n    p *= ZOOM;\n    float aa  = 2.0 / clamp(iResolution.y, 400., 800.);\n\n    int index, cid;\n    \n    float d = map(p, index);\n    cid = index;\n    \n    \n    float b = -0.4;\n    float t = 10.0;\n    const float lh = 2.;\n    const vec3 lp = vec3(2.5, 2.5, lh);\n    \n    vec3 ro = vec3(0, 0, t);\n    vec3 pp = vec3(p, 0);\n    \n    vec3 rd = normalize(pp - ro);\n\n    vec3 ld = normalize(lp - pp);\n    \n    float bt = -(t-b)/rd.z;\n  \n    vec3  bp   = ro + bt*rd;\n    vec3  srd = normalize(lp - bp);\n    float bl = L2(lp - bp);\n\n    float st = (0.0-b)/srd.z;\n    vec3  sp = bp + srd*st;\n\n    float bd = map(bp.xy, index);\n    float sd = map(sp.xy, index);\n\n    vec3 col = vec3(0);\n    const float ss = 15.0;\n    col       += vec3(1.)  * (1.0 - exp(-ss*(max(sd, 0.0)))) / bl;\n    float l   = length(p);\n#ifdef DrawLimitSet\n    float hue = fract(0.75*l-0.3*TT) + .45;\n#else\n    float hue = fract(0.15*l-0.3*TT) + .5;\n#endif\n    float sat = .9*tanh(4.*l);\n    vec3 hsv  = vec3(hue, sat, 1.0);\n    vec3 bcol = hsv2rgb(hsv);\n    \n    col       *= (1.0-clamp(tanh(0.75*l), 0., .1)) * 1.3;\n\n#ifdef DrawLimitSet\n    col       = mix(col, vec3(1), smoothstep(-aa, aa, -d));\n#else\n    col       = mix(col, bcol, 1. - step(-d, aa));\n#endif\n    col       += 0.5*sqrt(bcol.zxy)*(exp(-(10.0+100.0*tanh(l))*max(d, 0.0)));\n    \n    col = post_process(col, uv);\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MAX_ITER         30\n#define PI               3.141592653\n#define L2(x)            dot(x, x)\n#define ZOOM             4.\n#define inf              -1.\n\n// comment out this to show the circles\n#define DrawLimitSet\n\n\n// uncomment this to show the vertice sections\n//#define DrawVerticalSections\n\nfloat dihedral(float x) {\n    return x == inf ? 1. : cos(PI / x);\n}\n\nvec3 dihedral(vec3 v) {\n    return vec3(dihedral(v.x), dihedral(v.y), dihedral(v.z));\n}\n\nfloat SECTION_HEIGHT;\n\n// For spheres n is the center, r is the radius\n// For planes n is the normal vector, r is the distance between the plane and the origin\n// if invert is true then the inside/outside of the sphere is interchanged (not used in this program)\n// if hasRealBall is true then this virtual ball has a real ball correspondes to it\nstruct Ball {\n    bool isplane;\n    vec3 n;\n    float r;\n    bool invert;\n    bool isRealBall;\n};\n\n// coclusters are mirror balls, they corresponde to root vectors (space-like)\nBall[5] coclusters;\n// clusters are real balls, they corresponde to space-like weight vectors\nBall[5] clusters;\n\n\n// create a ball. by default it's the z=0 plane with normal points to the negative half\nBall defaultBall() {\n    return Ball(false, vec3(0, 0, -1), 0., false, false);\n}\n\n// Distance from a point to a ball\nfloat sdistanceToBall(vec3 p, Ball B) {\n    if (B.isplane) {\n        float k = dot(vec4(p, 1), vec4(B.n, B.r));\n        return k;\n    }\n    else\n        return length(p - B.n) - B.r;\n}\n\nBall from_plane(vec3 n, float d) {\n    return Ball(true, n, d, false, false);\n}\n\nBall from_sphere(vec3 cen, float r) {\n    return Ball(false, cen, r, false, false);\n}\n\nvoid invertBall(inout Ball B) {\n    B.invert = !B.invert;\n}\n\n// try to reflect a point p to the positive half space bounded by a ball\n// if we are already in the positive half space, do nothing and return true,\n// else reflect about the ball and return false\n// if B is a sphere we try to reflect p into the interior of B\nbool try_reflect(inout vec3 p, Ball B, inout float scale) {\n    if (B.isplane) {\n        float k = dot(vec4(p, 1), vec4(B.n, B.r));\n        if (k >= 0.)\n            return true;\n        p -= 2. * k  * B.n;\n        return false;\n    }\n    else {\n        vec3 cen = B.n;\n        float r = B.r;\n        vec3 q = p - cen;\n        float d2 = dot(q, q);\n        float k = (r * r) / d2;\n        if ( (k < 1.0 && B.invert) || (k > 1. && !B.invert) )\n            return true;\n        p = k * q + cen;\n        scale *= k;\n        return false;\n    }\n}\n\n// return distance to the scene, and get the index of the real ball hitted\nfloat DE(vec3 p, inout int index) {\n    float scale = 3.;\n    for (int i = 0; i < MAX_ITER; i++) {\n        bool cond = true;\n        for (int k = 0; k < 5; k++) {\n            cond = try_reflect(p, coclusters[k], scale) && cond;\n        }\n\n        if (cond)\n            break;\n    }\n    index = 0;\n#ifdef DrawLimitSet\n    float d = abs(p.z);\n    for (int j = 1; j < 5; j++) {\n        if (clusters[j].isRealBall) {\n            float d1 = abs(sdistanceToBall(p, clusters[j]));\n            if (d1 < d) { d = d1; index = j; }\n        }\n    }\n#else\n    float d = p.z;\n    for (int j = 1; j < 5; j++) {\n        if (clusters[j].isRealBall) {\n            float d1 = sdistanceToBall(p, clusters[j]);\n            if (d1 < d) { d = d1; index = j; }\n        }\n    }\n    \n#endif\n    return d / scale;\n}\n\n// solve M*v = b, where v = (x, y, r) is the xy-coordinate of the center of the ball,\n// r is the radius of the ball.\nBall solveBall(mat3 M, vec3 b) {\n    vec3 p = b * inverse(M);\n    return from_sphere(vec3(p.xy, 0.), p.z);\n}\n\n// Solve a ball with its center has xy-coordinates P, and is orthogonal to other two Balls B0, B1.\n// Here B0 may be either a sphere or a plane, B1 is always a sphere. \nBall solveBall(vec2 P, Ball B0, Ball B1) {\n    if (B0.isplane) {\n        float z = B0.r;\n        vec3 cen = vec3(P, z);\n        float R = sqrt(L2(cen - B1.n) - B1.r*B1.r);\n        return from_sphere(cen, R);\n    }\n    else {\n        float r1 = B1.r;\n        float r0 = B0.r;\n        float z0 = B0.n.z;\n        float k0 = L2(P - B0.n.xy);\n        float k1 = L2(P - B1.n.xy);\n        float z = (r1*r1 - r0*r0 + z0*z0 + k0 - k1) / (2.*z0);\n        float R = sqrt(k1 + z*z - r1*r1);\n        return from_sphere(vec3(P, z), R);\n    }\n    \n}\n\n// triangleType: must be one of 236, 244 or 333\n// dihedralAngles0: labels of the edges between v0 and (v2, v3, v4)\n// dihedralAngles1: labels of the edges between v1 and (v2, v3, v4)\n// dihedralAngles0_1: label of the edge between (v0, v1)\n// isRealBall: specify which of (v1, v2, v3, v4) has real balls\nvoid init(int triangleType,\n          vec3 dihedralAngles0,\n          vec3 dihedralAngles1,\n          float dihedralAngle0_1,\n          bvec4 isRealBall) {\n    const float s2 = sqrt(2.);\n    const float s3 = sqrt(3.);\n    mat3 M0, M1;\n    vec3 b;\n    Ball B0, B1, B2, B3, B4;\n    vec3 t0 = dihedral(dihedralAngles0);\n    vec3 t1 = dihedral(dihedralAngles1);\n    float t01 = dihedral(dihedralAngle0_1);\n    // A, B, C are the vertices of the triangle formed by mirror plane v2, v3, v4 and z=0 plane\n    vec2 A, B, C;\n\n    // the 236 case\n    if (triangleType == 236) {\n        A = vec2(0, 0), B = vec2(0, s3), C = vec2(1, 0);\n        B2 = from_plane(vec3(1, 0, 0), 0.);\n        B3 = from_plane(vec3(-s3/2., -0.5, 0), s3/2.);\n        B4 = from_plane(vec3(0, 1, 0), 0.);\n        M1 = mat3(vec3(1, 0, -t1.x), vec3(s3/2., 0.5, t1.y), vec3(0, 1, -t1.z));\n        M0 = mat3(vec3(1, 0, -t0.x), vec3(s3/2., 0.5, t0.y), vec3(0, 1, -t0.z));\n        b = vec3(0, s3/2., 0);\n    }\n    \n    // the 244 case\n    else if (triangleType == 244) {\n        A = vec2(0, 0), B = vec2(0, 1), C = vec2(1, 0);\n        B2 = from_plane(vec3(1, 0, 0), 0.);\n        B3 = from_plane(vec3(-s2/2., -s2/2., 0), s2/2.);\n        B4 = from_plane(vec3(0, 1, 0), 0.);\n        M1 = mat3(vec3(1, 0, -t1.x), vec3(1./s2, 1./s2, t1.y), vec3(0, 1, -t1.z));\n        M0 = mat3(vec3(1, 0, -t0.x), vec3(1./s2, 1./s2, t0.y), vec3(0, 1, -t0.z));\n        b = vec3(0, s2/2., 0);\n    }\n    \n    // the 333 case\n    else {\n        A = vec2(-1, 0), B = vec2(0, s3), C = vec2(1, 0);\n        B2 = from_plane(vec3(s3/2., -.5, 0), s3/2.);\n        B3 = from_plane(vec3(-s3/2., -.5, 0), s3/2.);\n        B4 = from_plane(vec3(0, 1, 0), 0.);\n        M1 = mat3(vec3(-s3/2., 0.5, t1.x), vec3(s3/2., .5, t1.y), vec3(0, 1, -t1.z));\n        M0 = mat3(vec3(-s3/2., 0.5, t0.x), vec3(s3/2., .5, t0.y), vec3(0, 1, -t0.z));\n        b = vec3(s3, s3, 0)/2.;\n    }\n    \n    // now we solve the virtual ball B1, this can't be a plane\n    B1 = solveBall(M1, b);\n    invertBall(B1);\n    \n    // now we solve the virtual ball B0, this can be either a plane or a sphere\n    // this depends on if all entries in dihedralAngles0 are all 2\n    if (dot(dihedralAngles0, vec3(1)) == 6.) {\n        B0 = from_plane(vec3(0, 0, -1), B1.r*t01);\n    }\n    else {\n        B0 = solveBall(M0, b);\n        float r1 = B1.r, r0 = B0.r;\n        B0.n.z = sqrt(r0*r0 + r1*r1 + 2.*r0*r1*t01 - L2(B1.n.xy - B0.n.xy));\n        invertBall(B0);\n    }\n    coclusters = Ball[5] (B0, B1, B2, B3, B4);\n    \n    SECTION_HEIGHT = B0.isplane ? 2.*B0.r : B0.n.z;\n    \n    //now we process the real balls\n    for (int k = 0; k < 5; k++)\n        clusters[k] = defaultBall();\n        \n    if (isRealBall.x) {\n        clusters[1] = from_plane(vec3(0, 0, -1.), B0.n.z);\n        clusters[1].isRealBall = true;\n    }\n    if (isRealBall.y) {\n        clusters[2] = solveBall(C, B0, B1);\n        clusters[2].isRealBall = true;\n    }\n    if (isRealBall.z) {\n        clusters[3] = solveBall(A, B0, B1);\n        clusters[3].isRealBall = true;\n    }\n   \n    if (isRealBall.w) {\n        clusters[4] = solveBall(B, B0, B1);\n        clusters[4].isRealBall = true;\n    }\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}