{
    "Shader": {
        "info": {
            "date": "1715134165",
            "description": "Another thing I've been wanting to do for ages. This has been done before, known as Julia Revolute. If anyone can figure out a better way to figure out the normals to allow rendering of a higher detail julia, feel free to comment or fork the solution.",
            "flags": 32,
            "hasliked": 0,
            "id": "MfVXW1",
            "likes": 1,
            "name": "mÃ¶bius julia",
            "published": 3,
            "tags": [
                "experiment",
                "thing"
            ],
            "usePreview": 0,
            "username": "01000001",
            "viewed": 63
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 O, vec2 U ){\n\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n    O = texture(iChannel0, uv);\n    \n    O = vec4(O.x*O.x, sqrt(O.x), O.x, 1.);\n        \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n} //hash by IQ https://www.shadertoy.com/view/XlXcW4\n\nmat2 rot(float t){\n    return mat2(cos(t), sin(t), -sin(t), cos(t));\n}\n\nfloat juliaDE(vec2 z, vec2 o, int detail){\n    float i = 0.;\n    for (; i < float(detail); i++){\n        z = vec2(\n            z.x * z.x - z.y * z.y,\n            2.* z.x * z.y\n        ) + o;\n        \n        if (z.x*z.x + z.y*z.y > 4.) break;\n    }\n    \n    float base = 1. + length(z)*.1;\n    return base/(float(i)+1.) - base/(float(detail) + 1.);\n}\n\n#define n(x) m = min(m, x);\nfloat df(vec3 p, float prevD){\n    float m = 1e9;\n\n    n(p.z+2.);\n    \n    float r = atan(p.z, p.x);\n    p.xz *= rot(r);\n    p -= vec3(1, 0, 0);\n    p.xy *= rot(r);\n    \n    vec2 offset = vec2(.5) + vec2(sin(r), cos(r))*.1;\n    \n    n(juliaDE(p.xy*4., offset, int(max(5., .01/prevD))));\n        \n    return m;\n}\n\nfloat df(vec3 p){\n    return df(p, 1e-9);\n}\n\nvec3 normal(vec3 p, float e){\n    float c = df(p);\n    return normalize(vec3(\n        c - df(p - vec3(e, 0, 0)),\n        c - df(p - vec3(0, e, 0)),\n        c - df(p - vec3(0, 0, e))\n    ));\n}\n\nvoid mainImage( out vec4 O, vec2 U ){\n\n    if (iFrame < 10){\n        O = vec4(0,0,0,1);\n        return;\n    }\n    O = texelFetch(iChannel0, ivec2(U), 0);\n\n    U.xy += hash(uvec3(U, iFrame)).xy - .5;\n\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    vec2 cuv = (2.*U-r)/r.y;\n    vec2 muv = //iMouse.z > 0.?\n        (2.*iMouse.xy-r)/r.y\n        //:vec2(iTime/2., -.1)\n        ;\n    \n    vec3 o = vec3(0);\n    vec3 dir = vec3(sin(muv.x)*cos(muv.y), cos(muv.x)*cos(muv.y), sin(muv.y));\n    o -= dir*4.;\n    vec3 right = normalize(cross(dir, vec3(0, 0, 1)));\n    vec3 up = cross(right, dir);\n    \n    vec2 camUV = cuv * .5;\n    vec3 dirV = vec3(sin(camUV.x)*cos(camUV.y), cos(camUV.x)*cos(camUV.y), sin(camUV.y));\n    dirV = normalize(dir * dirV.y + right * dirV.x + up * dirV.z);\n    \n\n    /*\n    vec2 offset = vec2(.5);\n    \n    O = vec4(juliaDE(cuv, offset, 8));\n    \n    if (O == vec4(0)) O = vec4(1);\n    return;\n    //*/\n\n    vec3 p = o;\n    float d, t = 0.;\n    for (int i = 512; i-->0;){\n        p = o + dirV * t;\n        d = df(p, d);\n        t += d*d*.1;\n        if (d < 0.) i--;\n    }\n    \n    O = vec4(\n        mix(O.x, exp(-t/4. + .5) * max(0., dot(normal(p, 1e-3), normalize(vec3(1)))), 1./O.w),\n        0,0,\n        iMouse.z > 0.?1.:O.w + 1.\n    );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}