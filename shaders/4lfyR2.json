{
    "Shader": {
        "info": {
            "date": "1505584905",
            "description": "Example of four raymarching outline approaches on a custom shader ball model. Use mouse to drag dividers.\n\nUL: SDF near-miss.\nUR: SDF offset differences.\nBL: Edge detection.\nBR: Surface ID difference.",
            "flags": 0,
            "hasliked": 0,
            "id": "4lfyR2",
            "likes": 39,
            "name": "SDF Outline Comparison",
            "published": 3,
            "tags": [
                "sdf",
                "edge",
                "outline"
            ],
            "usePreview": 0,
            "username": "ssell",
            "viewed": 3825
        },
        "renderpass": [
            {
                "code": "/**\n * -----------------------------------------------------------\n * - SDF Outline Comparison\n * - Created by Steven Sell (ssell) / 2017\n * - License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * - https://www.shadertoy.com/view/4lfyR2\n * -----------------------------------------------------------\n * \n * Comparison of four different approaches for SDF outlining.\n * Use the mouse to drag the screen dividers.\n *\n *     Upper Left:  SDF Near-Miss\n *     Upper Right: SDF Offset Differences\n *     Lower Left:  Edge Detection\n *     Lower Right: Surface ID Differences\n *\n * -----------------------------------------------------------\n * - SDF Near-Miss\n * - Outline_NearMiss()\n * -----------------------------------------------------------\n * \n * The outline is calculated based off of near-misses during raymarching,\n * where the ray comes within a threshold of the scene geometry but does\n * not make a direct hit.\n *\n * The outline/border thickness is calculated in world-units and thus will\n * vary in size based on depth. \n *\n * This approach does not produce internal outlines, but that may be desireable.\n *\n * Pros:\n *\n *     - Cheap, minor modification to raymarching loop to keep track of nearest passes.\n *     - No additional scene sampling.\n *     - Only approach with smooth external outline edges.\n *\n * Cons:\n *\n *     - Have to modify raymarch routine.\n *     - Only approach without internal edge outlining.\n *     - Jagged internal outline.\n *\n * -----------------------------------------------------------\n * - SDF Offset Differences\n * - Outline_OffsetDifference()\n * -----------------------------------------------------------\n *\n * Calculates the difference between a raymarch sample and two offset samples.\n * If the difference in depth between the samples is within a threshold, then\n * it is part of an outline.\n *\n * This approach requires an additional two samples of the scene, which may\n * be expensive depending on the shader. It is also has controls for outline \n * appearance in both UV-space (pixel may be used, but UV produces a smoother \n * result) and world-space.\n *\n * Pros:\n *\n *     - Partial internal edge outlining.\n *     - Some internal outline edges are smooth.\n *     - Requires no modification of existing raymarch routine.\n *\n * Cons:\n *\n *     - Potentially trickier to calibrate for a given scene\n *     - Requires two additional scene marches.\n *\n * -----------------------------------------------------------\n * - SDF Edge Detection\n * - Outline_EdgeDetection()\n * -----------------------------------------------------------\n *\n * Detects SDF edges by keeping track of previous SDF values. If the ray\n * is moving away from a surface and it passed within a threshold of that\n * surface, then it is an outline.\n *\n * The controls for this outline are solely in world-space units (edge threshold).\n *\n * Both this approach and Offset Difference produce a partial internal outlining\n * that give a stroke/pen appearance that may be desired.\n *\n * Pros:\n *\n *     - Partial internal edge outlining.\n *     - Cheap, no additional samples or calculations outside of the march.\n *\n * Cons:\n *\n *     - Have to modify raymarch routine.\n *     - Jagged outline.\n *\n * -----------------------------------------------------------\n * - Surface ID Difference\n * - Outline_SurfaceIDDifference()\n * -----------------------------------------------------------\n *\n * The only approach that is not based on SDF values but instead on surface/material IDs. \n * While defining the scene, must provide each surface/subset with a unique ID. During\n * the outlining, offsets into the scene are sampled. If the offsets have different IDs\n * then an outline edge is found.\n *\n * While this does not require modification to the raymarch itself, and the outline \n * calculation is similar to SDF Offset Differences, it does potentially require a lot\n * of changes to the scene definition. But if you are already defining your scene with\n * material/surface IDs then no work may need to be done.\n *\n * Pros:\n *\n *     - Nearly full control over edge definitions.\n *     - Provides full external and internal outlining.\n *\n * Cons:\n *\n *     - Have to manually define surfaces.\n *     - Jagged edges.\n * \n * -----------------------------------------------------------\n * - References\n * -----------------------------------------------------------\n * \n * While I know that these different approaches are used in other ShaderToys,\n * the only one that was directly referenced/sourced was:\n *\n *     'Bender' - iq\n *      https://www.shadertoy.com/view/4slSWf\n *\n *      I initially thought that 'SDF Offset Differences' was being used in this shader,\n *      but after experimentation I saw it was completely different approach which\n *      is  called 'Surface ID Differences' in this shader for lack of a proper name.\n */\n\n#define NearClip          0.0\n#define Epsilon           0.01\n#define FarClip           10.0\n#define MaxSteps          100\n#define PI                3.14159265\n#define NearMissThreshold 0.045     // Used in SDF Near-Miss. World-Space.\n#define EdgeThresold      0.03      // Used in SDF Edge Detection. World-Space.\n#define UVOffset          0.003     // Used in SDF Offset Differences and Surface ID Differences. UV-Space.\n\n      vec3 CamOrigin       = vec3(0.0);\nconst vec3 CamLookAt       = vec3(0.0, 1.05, 0.0);\nconst vec3 BackgroundColor = vec3(0.0, 0.335, 0.582);\nconst vec3 SunDir          = normalize(vec3(0.5, 2.5, 1.25));\nconst vec3 SunColor        = vec3(1.0, 1.0, 0.7);\nconst vec3 SkyDir          = normalize(vec3(0.0, 1.0, 0.0));\nconst vec3 SkyColor        = vec3(0.0, 0.0, 1.0);\nconst vec3 AmbDir          = normalize(SunDir * vec3(-1.0, 0.0, -1.0));\nconst vec3 AmbColor        = vec3(1.0, 1.0, 1.0);\n\n//------------------------------------------------------------------------------------------\n// Ray / Camera\n//------------------------------------------------------------------------------------------\n\nstruct Ray\n{\n\tvec3 o;\n    vec3 d;\n};\n\nRay Ray_LookAt(in vec2 uv, in vec3 o, in vec3 d)\n{\n    vec3 forward = normalize(d - o);\n    vec3 right   = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up      = normalize(cross(right, forward));\n\n    uv    = (uv * 2.0) - 1.0;\n    uv.x *= (iResolution.x / iResolution.y);\n\n    Ray ray;\n    ray.o = o;\n    ray.d = normalize((uv.x * right) + (uv.y * up) + (forward * 2.0));\n\n    return ray;\n}\n\n//------------------------------------------------------------------------\n// Scene\n//------------------------------------------------------------------------\n\nvec3  RotX(in vec3 p, float a)        { float s = sin(a); float c = cos(a); return vec3(p.x, (c * p.y) - (s * p.z), (s * p.y) + (c * p.z)); }\nvec3  Repeat(vec3 p, vec3 c)          { return mod(p, c) - (0.5 * c); }\nfloat smin(float a, float b, float k) { float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0); return mix(b, a, h) - k*h*(1.0 - h); }\nfloat Box(vec3 p, vec3 b)             { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); }\nfloat Sphere(vec3 p, float r)         { return length(p) - r; }\nfloat Cylinder(vec3 p, vec2 h)        { vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nvec2  U(vec2 a, vec2 b)               { return (a.x < b.x) ? a : b; }\nvec2  S(vec2 d2, vec2  d1 )           { return (-d1.x>d2.x)?-d1:d2; }\n\n/**\n * Returns (SDF value, Surface ID)\n */\nvec2 ShaderBall(vec3 pos)\n{\n    vec3 spos = pos - vec3(0.0, 1.5, 0.0);\n    \n    vec2 ts   = vec2(max(Sphere(spos, 1.0), -Sphere(spos, 0.8)), 9.0);                // Hollow top sphere\n    vec2 tsi  = vec2(Sphere(spos, 0.725), 2.0);                                       // Inner sphere core\n    vec2 tsc  = vec2(Sphere(spos - vec3(0.0, 0.4, 0.8), 0.55), 3.0);                  // Cut into side of top sphere\n    vec2 rc   = vec2(Box(RotX(spos, PI * 0.15), vec3(2.0, 0.05, 2.0)), 4.0);          // Ring cut into top sphere\n    \n    vec2 st   = vec2(Cylinder(pos - vec3(0.0, 0.1, 0.0), vec2(mix(0.8, 0.3, clamp(pos.y - 0.125, 0.0, 1.0)), 0.2)), 5.0);  // Stand wide base      \n    vec2 stc  = vec2(Cylinder(Repeat(pos, vec3(0.5, 0.0, 0.5)), vec2(0.125, 1.0)), 6.0);                                   // Stand ridge cuts\n    vec2 stm  = vec2(Cylinder(pos - vec3(0.0, 0.35, 0.0), vec2(0.5, 0.35)), 5.0); // Thinner stand middle\n    \n    st   = S(st, stc);\n    st.x = smin(st.x, stm.x, 0.2);                         \n    \n    vec2 b    = vec2(Cylinder(pos - vec3(0.0, 0.025, 0.0), vec2(1.0, 0.025)), 8.0);    // Base\n       \n    vec2 result = S(ts, tsc);\n         result = S(result, rc);\n         result = U(result, tsi);\n         result = U(result, st);\n         result = U(result, b);\n    \n    return result;\n}\n\n/*float ShaderBall(vec3 pos)   // Version of shader ball that only returns SDF value, no IDs\n{\n    vec3  spos = pos - vec3(0.0, 1.5, 0.0);\n    float ts   = max(Sphere(spos, 1.0), -Sphere(spos, 0.8));                // Hollow top sphere\n    float tsi  = Sphere(spos, 0.725);                                       // Inner sphere core\n    float tsc  = Sphere(spos - vec3(0.0, 0.4, 0.8), 0.55);                  // Cut into side of top sphere\n    float rc   = Box(RotX(spos, PI * 0.15), vec3(2.0, 0.05, 2.0));          // Ring cut into top sphere\n    \n    float st   = Cylinder(pos - vec3(0.0, 0.1, 0.0), vec2(mix(0.8, 0.3, clamp(pos.y - 0.125, 0.0, 1.0)), 0.2));  // Stand wide base      \n    float stc  = Cylinder(Repeat(pos, vec3(0.5, 0.0, 0.5)), vec2(0.125, 1.0));                                   // Stand ridge cuts\n          st   = max(st, -stc);\n          st   = smin(st, Cylinder(pos - vec3(0.0, 0.3, 0.0), vec2(0.5, 0.3)), 0.2);                             // Thinner stand middle\n    \n    float b    = Cylinder(pos - vec3(0.0, 0.025, 0.0), vec2(1.0, 0.025));    // Base\n               \n    float result = min(FarClip, max(ts, -tsc));\n          result = max(result, -rc);\n          result = min(result, tsi);\n          result = smin(result, st, 0.1);\n          result = min(result, b);\n    \n    return result;\n}*/\n\nvec2 Scene(vec3 pos)\n{\n\treturn vec2(ShaderBall(pos));\n}\n\n/**\n * Modified raymarch that supports all of the outline approaches.\n * Returns (depth, nearest pass, edge, id).\n */\nvec4 RayMarch(in Ray ray)\n{\n    float depth   = NearClip;\n    float nearest = FarClip;          // Keeps track of nearest pass for SDF Near-Miss outline\n    float edge    = 0.0;              // Keeps track of if edge for SDF Edge outline\n    float lastSDF = FarClip;          // Keeps track of last SDF value for SDF Edge outline\n    \n    for(int i = 0; i < MaxSteps; ++i)\n    {\n    \tvec3 pos = ray.o + (ray.d * depth);\n        vec2 sdf = Scene(pos);\n        \n        nearest = min(sdf.x, nearest);\n        \n        if((lastSDF < EdgeThresold) && (sdf.x > lastSDF))\n        {\n            edge = 1.0;\n        }\n        \n        if(sdf.x < Epsilon)\n        {\n            return vec4(clamp(depth, NearClip, FarClip), nearest, edge, sdf.y);\n        }\n        \n        depth  += sdf.x * 0.35;        // Note: Modifying the '* 0.35' affects the outlines in subtle ways.\n        lastSDF = sdf.x;\n    }\n    \n    return vec4(FarClip, nearest, edge, 0.0);\n}\n\nvec3 SceneNormal(in vec3 pos, in float depth)\n{\n    vec2 eps = vec2(0.001 * depth, 0.0);\n    return normalize(vec3(Scene(pos + eps.xyy).x - Scene(pos - eps.xyy).x,\n                          Scene(pos + eps.yxy).x - Scene(pos - eps.yxy).x,\n                          Scene(pos + eps.yyx).x - Scene(pos - eps.yyx).x));\n}\n\n//------------------------------------------------------------------------\n// Outline UL - SDF Near Miss\n//------------------------------------------------------------------------\n\nfloat Outline_NearMiss(in vec4 march)\n{\n    float a = step(FarClip, march.x);                        // a == 1.0 if the depth >= FarClip, aka a miss\n    float b = clamp(march.y / NearMissThreshold, 0.0, 1.0);  // denominator is the border width in world units\n    \n    return (1.0 - pow(b, 8.0)) * a;                          // pow value controls edge darkness and smooth fade\n}\n\n//------------------------------------------------------------------------\n// Outline UR - SDF Offset Difference\n//------------------------------------------------------------------------\n\nfloat Outline_OffsetDifference(in vec2 uv, float depth)\n{\n    // 0.003 is the offset size, and thus outline thickness, in uv\n    vec2 offset = vec2(UVOffset, 0.0);              \n    \n    vec4 marchA = RayMarch(Ray_LookAt(uv + offset.xy, CamOrigin, CamLookAt));\n    vec4 marchB = RayMarch(Ray_LookAt(uv - offset.yx, CamOrigin, CamLookAt));\n    \n    // 0.07 is the depth threshold is world units, and thus is dependent on scene geometry for a proper value.\n    float diff = clamp(max(abs(depth - marchA.x), abs(depth - marchB.x)) / 0.07, 0.0, 1.0);\n    \n    // 0.6 is a control value for outline stroke thickness, and 8.0 is stroke strength.\n    return 1.0 - smoothstep(0.6, -0.001, pow(diff, 8.0));\n}\n\n//------------------------------------------------------------------------\n// Outline LL - Edge Detection\n//------------------------------------------------------------------------\n\nfloat Outline_EdgeDetection(in vec4 march)\n{\n    return march.z;\n}\n\n//------------------------------------------------------------------------\n// Outline LR - Surface ID Difference\n//------------------------------------------------------------------------\n\nfloat Outline_SurfaceIDDifference(in vec2 uv, float id)\n{\n    vec2 offset = vec2(0.004, 0.0);\n    \n    float idA = RayMarch(Ray_LookAt(uv + offset.xy, CamOrigin, CamLookAt)).w;\n    float idB = RayMarch(Ray_LookAt(uv - offset.yx, CamOrigin, CamLookAt)).w;\n    \n    float e = clamp(max(abs(id - idA), abs(id - idB)), 0.0, 1.0);\n                    \n    return e;\n}\n\n//------------------------------------------------------------------------\n// Render\n//------------------------------------------------------------------------\n\nvec3 Lighting(in vec3 albedo, in vec3 norm, in vec3 rd)\n{\n\tfloat shadow = 1.0;\n    float direct = max(0.1, dot(norm, SunDir));\n    \n    vec3 sunLight  = SunColor * direct * 1.5 * shadow;\n    vec3 skyLight  = SkyColor * clamp(0.5 + (0.5 * norm.y), 0.0, 1.0) * 0.1;\n    vec3 ambLight  = AmbColor * clamp(dot(norm, AmbDir), 0.0, 1.0) * 0.3;\n  \tvec3 diffLight = (sunLight + skyLight + ambLight) * albedo;\n    \n    vec3 reflVec   = reflect(-SunDir, norm);\n    float specIntens = pow(max(0.0, dot(rd, -reflVec)), 16.0);\n    vec3 specLight = specIntens * vec3(0.35) * shadow;\n    \n    return (diffLight + specLight);\n}\n\nvec4 Render(in Ray ray, in vec2 fragCoord, in vec2 uv, int section)\n{\n\tvec4 color = vec4(BackgroundColor, 0.0);\n    vec4 march = RayMarch(ray);\n    \n    if(march.x < FarClip)\n    {\n        vec3 pos  = ray.o + (ray.d * march.x);\n        vec3 norm = SceneNormal(pos, march.x);\n        \n       \tcolor.rgb = (int(march.w) == 2) ? vec3(1.0, 0.184314, 0.0309804) : vec3(0.9);\n        color.rgb = Lighting(color.rgb, norm, ray.d);\n        \n        color.a = 1.0;\n    }\n    \n    if(section == 1) { color.rgb = mix(color.rgb, vec3(0.0), Outline_NearMiss(march)); }\n    if(section == 2) { color.rgb = mix(color.rgb, vec3(0.0), Outline_OffsetDifference(uv, march.x)); }\n    if(section == 3) { color.rgb = mix(color.rgb, vec3(0.0), Outline_EdgeDetection(march)); }\n    if(section == 4) { color.rgb = mix(color.rgb, vec3(0.0), Outline_SurfaceIDDifference(uv, march.w)); }\n    \n    return color;\n}\n\n//------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------\n\nvec3 OrbitAround(vec3 origin, float radius, float rate)\n{\n    float time = iTime - 4.5f;\n  \treturn vec3((origin.x + (radius * cos(time * rate))), (origin.y), (origin.z + (radius * sin(time * rate))));\n}\n\nint ScreenSection(in vec2 fragCoord)\n{\n    vec2 mouse = iMouse.xy;\n    \n    if(mouse.xy == vec2(0.0))\n    {\n        mouse.xy = iResolution.xy * 0.5;\n    }\n    \n    vec2 diff = fragCoord - mouse.xy;\n    \n    if(abs(fragCoord.y - mouse.y) < 1.0 || abs(fragCoord.x - mouse.x) < 1.0) { return 0; }\n    if(diff.x < 0.0 && diff.y > 0.0) { return 1; }\n    if(diff.x > 0.0 && diff.y > 0.0) { return 2; }\n    if(diff.x < 0.0 && diff.y < 0.0) { return 3; }\n    \n    return 4;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    CamOrigin = OrbitAround(vec3(0.0, 2.0, 0.0), 3.5, -0.5);\n    \n    vec2 uv = (fragCoord / iResolution.xy);\n    Ray ray = Ray_LookAt(uv, CamOrigin, CamLookAt);\n    \n    int section = ScreenSection(fragCoord);\n    \n    vec4 color = Render(ray, fragCoord, uv, section);\n    \n    if(section == 0)\n    {\n        color.rgb *= max(0.65, color.a);\n    }\n    \n    fragColor = vec4(pow(color.rgb, vec3(1.0 / 2.2)), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}