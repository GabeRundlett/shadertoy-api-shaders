{
    "Shader": {
        "info": {
            "date": "1614299396",
            "description": "Every other cell is mirrored so that none symmetric SDFs are valid when repeated\n-Left is limited repeat, requires symmetric shape \n-Right is limited mirror repeat, can handle any shape ",
            "flags": 0,
            "hasliked": 0,
            "id": "3tyBDW",
            "likes": 7,
            "name": "Limited Mirrored Repetition SDF",
            "published": 3,
            "tags": [
                "2d",
                "sdf",
                "repetition",
                "mirror"
            ],
            "usePreview": 0,
            "username": "Dain",
            "viewed": 519
        },
        "renderpass": [
            {
                "code": "//Most of this besides the mirror repeat is from IQ Limited Repetition SDF https://www.shadertoy.com/view/3syGzz\n\n/*\nEvery other cell is mirrored so that none symmetric SDFs are valid when repeated\n-Left is limited repeat, requires symmetric shape \n-Right is limited mirror repeat, can handle any shape \n*/\n\n//Limited mirrored repetition\nvec2 opMirrorLim( in vec2 p, in float s, in vec2 lima, in vec2 limb )\n{\n    //This part is same as IQ's limited repeat\n    //The limits should be integers\n    vec2 c = clamp( round(p/s),lima,limb);\n    vec2 o= p-s*c;\n    \n    //Now adjust for mirroring\n    //flip in every other cell\n    if((int(c.x)&1) == 1){\n         o.x = -o.x;\n    }\n    \n     if((int(c.y)&1) == 1){\n         o.y = -o.y;\n     }\n    \n    return o;\n}\n\n\n// Create multiple copies of an object - https://iquilezles.org/articles/distfunctions\nvec2 opRepLim( in vec2 p, in float s, in vec2 lima, in vec2 limb )\n{\n    return p-s*clamp(round(p/s),lima,limb);\n}\n\n// Create infinite copies of an object -  https://iquilezles.org/articles/distfunctions\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p) - b;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n//SDF that is not symetric goes here\nfloat NotSymmetricShape(vec2 r){\n  float d = sdBox( r+vec2(0.0, -.3), vec2(0.4,0.2) ) -  0.1;\n  d= min(d,sdBox( r+vec2(0.41,0.1), vec2(0.1,0.7) ) -  0.061);\n  return d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\t\n    float scale = abs(sin(iTime*.5))*2.0+.5;\n    float cellX = round(2.0*abs(cos(iTime*.5)));\n    float cellY = round(2.0*abs(sin(iTime*.5+.25)));\n    // sdf\n    float d;\n    if( p.x<0.0 ) // standard repetition, only works if SDF is symmetric \n    {\n    \tvec2 q = p*6.0 + vec2(5.0,0.0);\n        vec2 r = opRepLim(q,scale,vec2(-cellX,-1),vec2(cellX,cellY));\n        d = NotSymmetricShape(r);\n    }\n    else         // mirrored repitition, works for anything\n    {\n      \tvec2 q = p*6.0 - vec2(5.0,0.0);\n        vec2 r = opMirrorLim(q,scale,vec2(-cellX,-1),vec2(cellX,cellY));\n        d = NotSymmetricShape(r);\n    }\n\n    // colorize\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(40.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.05,abs(d)) );\n\n    col *= smoothstep(0.005,0.010,abs(p.x));\n    \n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}