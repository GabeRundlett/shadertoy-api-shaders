{
    "Shader": {
        "info": {
            "date": "1689868329",
            "description": "Not sure I would jump in :)\n\nMouse x zooms",
            "flags": 48,
            "hasliked": 0,
            "id": "cdjfzy",
            "likes": 2,
            "name": "Water or no water?",
            "published": 3,
            "tags": [
                "2d",
                "simulation",
                "automata",
                "life",
                "conway",
                "gameoflife",
                "multipass"
            ],
            "usePreview": 0,
            "username": "misol101",
            "viewed": 202
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ix = texelFetch(iChannel1, ivec2(0,0), 0 ).x;\n    int mono = int(texelFetch(iChannel1, ivec2(3,0), 0 ).x);\n    int showtext = int(texelFetch(iChannel1, ivec2(4,0), 0 ).x);\n    int aa = 1-int(texelFetch(iChannel1, ivec2(5,0), 0 ).x);\n\n    float mx= iMouse.x / iResolution.x;\n    vec2 mid = iResolution.xy / 2.;\n    float mmul = 1.-mx;\n    fragCoord = mid - (mid*mmul-fragCoord*mmul);\n\n    vec4 val = vec4(0.);\n    int am=aa, ap=aa, j=0;\n    for (int j = -am; j <= ap; j++)\n        for (int i = -am; i <= ap; i++) {\n            vec4 v1= texelFetch( iChannel0, ivec2(int(fragCoord.x)+i,int(fragCoord.y)+j), 0 );\n            vec4 v2= vec4(0.03+0.1,0.29+0.1,0.35+0.1,1.0)- texelFetch( iChannel2, ivec2(int(fragCoord.x*0.25)+i,int(fragCoord.y*0.25)+j), 0 );\n            if (v1.x > 0.03+0.4  && v1.y > 0.29+0.4 && v1.z > 0.35+0.4)\n                val += v1; else val+= v2*0.1+v1*0.85;\n         }\n    float n=float((am+ap+1));\n    if (am+ap > 0) val /= n*n-3.5;\n    \n    if (aa == 0) val/=0.6;\n    \n    if (mono == 0) {\n        fragColor = val;\n    } else {\n        float v=(1./liveval)*val.w;\n        fragColor = vec4( v*0.9, v*0.95, v, 1.0 );\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Cellular automata buffer\n\nconst int KEY_SPACE = 32;\nconst int KEY_ENTER = 13;\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\n\nbool readKey( int key )\n{\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nint cell( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    float val = texelFetch(iChannel0, p, 0 ).w;\n    return ( val == liveval ) ? 1 : 0;\n}\nvec4 cellval( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n}\n\nfloat randpix(vec2 fragCoord) {\n    float rn = hash1(iTime+fragCoord.x*13.0+hash1(fragCoord.y*71.1));\n    return clamp(step(1.01-density/100., rn), 0., 1.) * (liveval);\n}\n\nfloat restart(vec2 fragCoord, int method, bool preserve) {\n    if (method == 0)\n        return randpix(fragCoord);\n\n    vec2 mid = iResolution.xy / 2.; \n    float w=100., h=100., radius=452., rradius=25.;\n    if (iResolution.y < 1000.) radius=182.;\n    float xrad=569.,yrad=453.;\n    float thick=2., wl=w-thick, hl=h-thick;\n\n    if (method == 1) {\n        if (length(fragCoord-mid)< radius && length(fragCoord-mid) > (radius-thick))\n            return liveval;//randpix(fragCoord);\n    }\n    if (method == 2) {\n        if (((fragCoord.x > mid.x - w && fragCoord.x < mid.x - wl) || (fragCoord.x > mid.x + wl && fragCoord.x < mid.x + w))\n            && fragCoord.y > mid.y - h && fragCoord.y < mid.y + h)\n            return liveval;//randpix(fragCoord);\n        if (((fragCoord.y > mid.y - h && fragCoord.y < mid.y - hl) || (fragCoord.y > mid.y + hl && fragCoord.y < mid.y + h))\n            && fragCoord.x > mid.x - w && fragCoord.x < mid.x + w)\n            return liveval;//randpix(fragCoord);\n    }\n    if (method == 3) {\n//        if (length(fragCoord-mid)< radius)\n        if (length(vec2((fragCoord.x-mid.x)*0.793,(fragCoord.y-mid.y)*1.0))< radius) // ellipse\n            return liveval;//randpix(fragCoord);\n    }\n    if (method == 4) {\n        float xmul=1.; if (iResolution.y < 1000.) xmul=1.75;\n        if (fragCoord.x > mid.x - rradius*xmul && fragCoord.x < mid.x + rradius*xmul+1. && fragCoord.y > mid.y - rradius && fragCoord.y < mid.y + rradius +1.)\n            return liveval;//randpix(fragCoord);\n    }\n    return preserve? -1. : 0.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ix = texelFetch(iChannel2, ivec2(0,0), 0 ).x;\n    float xres = texelFetch(iChannel2, ivec2(0,1), 0 ).x;\n    int method = int(texelFetch(iChannel2, ivec2(1,0), 0 ).x);\n    int speed = 2+int(texelFetch(iChannel2, ivec2(2,0), 0 ).x);\n    int mono = int(texelFetch(iChannel2, ivec2(3,0), 0 ).x);\n    int usecolor = 1-int(texelFetch(iChannel2, ivec2(6,0), 0 ).x);\n    int usewrap = 1-int(texelFetch(iChannel2, ivec2(7,0), 0 ).x);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(-3.5*sin((iTime-10.)*0.012), 3.5*sin(iTime*0.0105), 3.5*sin(iTime*0.02));\n    if (usecolor == 0) col = vec3(0.);\n    col = vec3(0.);\n\n    setRules(int(ix*10.), col);\n    uv+=0.05;\n    uv-=iTime*0.005;\n    float axx = sin((uv.x*5.+uv.y)-0.8)*cos(uv.y*2.+2.1)*12.5+12.5;\n    axx=clamp(axx, 2.0, 12.0);\n\n    float axx2 = sin((uv.x*8.+uv.y*1.4)-0.8)*cos(uv.y*2.+2.1+uv.y*2.)*12.5+abs((uv.x-0.5)*2.)+12.5;\n    axx2=clamp(axx2, 2.0, 12.0);\n    axx=min(axx,axx2);\n\n    rm/=axx;\n    gm/=axx;\n    bm/=axx;\n\n    wrap = usewrap;\n\n    ivec2 px = ivec2( fragCoord );\n    vec4 curr = cellval(px);\n    float ev = curr.w;\n\n    if (wrap == 0 && (fragCoord.y < 2. || fragCoord.x < 2.) ) {\n        fragColor = vec4( 0.0, 0.0, 0.0, 0.);\n        return;\n    }\n\n    if( iFrame==0 || readKey(KEY_SPACE) || readKey(KEY_UP) || readKey(KEY_DOWN) || int(xres) != int(iResolution.x)  ) {\n        fragColor = vec4( 0.0, 0.0, 0.0, restart(fragCoord, setmethod, false));\n        return;\n    }\n\n    if( readKey(KEY_1) || readKey(KEY_2) || readKey(KEY_3) || readKey(KEY_4) || readKey(KEY_5) ) {\n        fragColor = vec4( 0.0, 0.0, 0.0, restart(fragCoord, method, false));\n        return;\n    }\n\n    if (iFrame % (speed+1) > 0) {\n        fragColor = curr;\n        return;\n    }\n  \n    int k=0;\n    \n    if (nh == 0) {\n        // ..X..\n        // .X.X.\n        // X.*.X\n        // .X.X.\n        // ..X..\n        k =   cell(px+ivec2(0,-2)) + cell(px+ivec2(-1,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-2, 0))                        + cell(px+ivec2(2, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(1, 1)) + cell(px+ivec2(0, 2));\n    } else if (nh == 5) {\n        // XXXXX\n        // XXXXX\n        // XX*XX\n        // XXXXX\n        // XXXXX\n        k =   cell(px+ivec2(-1,-1)) + cell(px+ivec2(0,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-1, 0))                        + cell(px+ivec2(1, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(0, 1)) + cell(px+ivec2(1, 1))\n            + cell(px+ivec2(-1, 2)) + cell(px+ivec2(0, 2)) + cell(px+ivec2(1, 2))\n            + cell(px+ivec2(-1, -2)) + cell(px+ivec2(0, -2)) + cell(px+ivec2(1, -2))\n            + cell(px+ivec2(-2, -2)) + cell(px+ivec2(-2, -1)) + cell(px+ivec2(-2, 0))\n            + cell(px+ivec2(-2, 1)) + cell(px+ivec2(-2, 2))\n            + cell(px+ivec2(2, -2)) + cell(px+ivec2(2, -1)) + cell(px+ivec2(2, 0))\n            + cell(px+ivec2(2, 1)) + cell(px+ivec2(2, 2));\n    } else if (nh == 10) {\n        // XXXXX\n        // ..X..\n        // ..*..\n        // ..X..\n        // XXXXX    \n        k =   cell(px+ivec2(0,-1)) + cell(px+ivec2(0,1)) +\n            + cell(px+ivec2(-2, -2)) + cell(px+ivec2(-1, -2)) + cell(px+ivec2(0, -2)) + cell(px+ivec2(1, -2)) + cell(px+ivec2(2, -2))\n            + cell(px+ivec2(-2, 2)) + cell(px+ivec2(-1, 2)) + cell(px+ivec2(0, 2)) + cell(px+ivec2(1, 2)) + cell(px+ivec2(2, 2));\n    } else if (nh == 13) {\n        // XXXXX\n        // ....X\n        // XX*.X\n        // X...X\n        // XXXXX            \n        k =   \n            cell(px+ivec2(-1, 2)) + cell(px+ivec2(0, 2)) + cell(px+ivec2(1, 2))\n            + cell(px+ivec2(-1, -2)) + cell(px+ivec2(0, -2)) + cell(px+ivec2(1, -2))\n            + cell(px+ivec2(-2, -2)) + cell(px+ivec2(-1, 0)) + cell(px+ivec2(-2, 0))\n            + cell(px+ivec2(-2, 1)) + cell(px+ivec2(-2, 2))\n            + cell(px+ivec2(2, -2)) + cell(px+ivec2(2, -1)) + cell(px+ivec2(2, 0))\n            + cell(px+ivec2(2, 1)) + cell(px+ivec2(2, 2));\n            \n    } else {\n        // XXX\n        // X*X\n        // XXX\n        k =   cell(px+ivec2(-1,-1)) + cell(px+ivec2(0,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-1, 0))                        + cell(px+ivec2(1, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(0, 1)) + cell(px+ivec2(1, 1));\n    }\n    \n    float ff = 0.;\n    if (ev > 0.5) {\n        if (decimate > 0.) ff = ev-decimate; //clamp(ev-decimate, 0., 1000.);\n        if ((stayset & (1<<(k-1))) > 0 ) { ff = float(k); if (clampstay && ff > liveval) ff = liveval; }\n    }\n    else {\n        ff = (bornset & (1<<(k-1))) > 0 ? liveval : 0.;\n    }\n\n    if (mono == 0) {\n        if (ff >= 1.0) {\n            int st = int(ff);\n\n            float mulbase = float(k);\n            if (colch == 1) mulbase = ff;\n            else if (colch == 2) mulbase = 1.;\n            else if (colch == 3) mulbase = float(k^st);\n            \n            if ((st & ra) > 0) curr.x -= cstep*mulbase*rp;\n            if ((st & ga) > 0) curr.y -= cstep*mulbase*gp;\n            if ((st & ba) > 0) curr.z -= cstep*mulbase*bp;\n            \n            if (staypatt == 5 || staypatt == 6) curr.z=curr.y=curr.x;\n            \n        } else {\n            float stayt = cstep * stayval;\n            \n            if (staypatt == 0 || staypatt > 5) {\n                curr.x += cstep*rm;\n                curr.y += cstep*gm;\n                curr.z += cstep*bm;\n            }\n            else if (staypatt == 1) {\n                if(curr.x > cstep) {\n                    curr.x += cstep*rm;\n                    curr.y += cstep*gm;\n                    curr.z += cstep*bm;\n                }\n            }\n            else if (staypatt == 2) {\n                if(curr.y > cstep) {\n                    curr.x += cstep*rm;\n                    curr.y += cstep*gm;\n                    curr.z += cstep*bm;\n                }\n            }\n            else if (staypatt == 3) {\n                if(curr.z > cstep) {\n                    curr.x += cstep*rm;\n                    curr.y += cstep*gm;\n                    curr.z += cstep*bm;\n                }\n            }\n            else if (staypatt == 4) {\n                if(curr.z > cstep) {\n                    curr.x += cstep*rm;\n                    curr.y += cstep*gm;\n                }\n                if(curr.x > cstep) curr.z -= cstep*bm;\n            }\n            else if (staypatt == 5) {\n                curr.x += cstep*rm;\n                curr.z=curr.y=curr.x;\n            }\n        }\n\n        curr.x = clamp(curr.x, 0.03, 4000.0);\n        curr.y = clamp(curr.y, 0.29, 4000.0);\n        curr.z = clamp(curr.z, 0.35, 4000.0);\n\n}\n\n\tfragColor = vec4( clamp(curr.xyz,0.,1.), ff );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float LAST_PATT = 0.;\nconst float cstep=1./256.;\n\nfloat density=50.;\nfloat liveval = 2.0;\nint newmethod = 0;\nfloat decimate = 0.;\nfloat rp,gp,bp, rm,gm,bm, stayval;\nint colch, staypatt;\nint ra,ga,ba;\nbool clampstay;\nint setmethod;\nint stayset, bornset;\nint nh;\nint wrap;\n\nvoid setRules(int index, vec3 col) {\n    int v1, v2;\n    decimate = 1.;liveval=2.;\n\n    rp=4.,gp=3.,bp=10., rm=2.,gm=2.,bm=8., ra=7,ga=7,ba=7,staypatt=1,stayval=1.,colch=0, clampstay=false, setmethod=0; nh=10, wrap=0;\n\n    index = 0;\n    if (index == 0) {wrap=1; nh=13; v1 = 64863, v2=21948; setmethod=0, density=14., liveval=4., decimate=1.0, colch=0, staypatt=0, rp=5.5, gp=4.8, bp=4.6, rm=45., gm=61.,bm=61.,  ra=7,ga=7,ba=7; }\n\n    rp=rp+col.x; gp=gp+col.y; bp=bp+col.z;\n    stayset = v1; bornset = v2;\n}\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Persistive Keyboard Input buffer & resolution change check\n\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\nconst int KEY_7     = 55;\nconst int KEY_8     = 56;\nconst int KEY_9     = 57;\nconst int KEY_A     = 65;\nconst int KEY_C     = 67;\nconst int KEY_H     = 72;\nconst int KEY_M     = 77;\nconst int KEY_W     = 87;\n\nbool readKey( int key ) {\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nvec4 keyStep(int ix, int iy, int key, float delta, float maxval) {\n    vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n    float kx=keystate.x;\n    float ky=keystate.y;\n    if( readKey(key) ) {\n        if (ky == 0.) {\n            kx+=1.;\n            if (kx >= maxval) kx=0.;\n            if (kx < 0.) kx=maxval-delta;\n        }\n        ky+=0.01;\n        if (ky >= 1.0) ky=0.;\n    }\n    else {\n        ky = 0.;\n    }\n    return vec4(kx,ky,0.,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int ix = int(fragCoord.x), iy = int(fragCoord.y);\n\n    if (ix == 0 && iy == 0) {\n        vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n        float kx=keystate.x;\n        float ky=keystate.y;\n        if( readKey(KEY_UP)||readKey(KEY_DOWN)||readKey(KEY_LEFT)||readKey(KEY_RIGHT) ) {\n            if (ky == 0.) {\n                if (readKey(KEY_DOWN) || readKey(KEY_RIGHT)) {\n                    kx+=0.1;\n                    if (kx > LAST_PATT*0.1+0.05) kx=0.05;\n                } else {\n                    kx-=0.1;\n                    if (kx < 0.) kx=LAST_PATT*0.1+0.05;\n                }\n            }\n            ky+=0.01;\n            if (ky >= 1.0) ky=0.;\n        }\n        else {\n            ky = 0.;\n        }\n        fragColor = vec4(kx,ky,0.,0.);\n        return;\n    }\n\n    if (ix == 1 && iy == 0) {\n        float method = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_1)) method = 0.5;\n        if( readKey(KEY_2)) method = 1.5;\n        if( readKey(KEY_3)) method = 2.5;\n        if( readKey(KEY_4)) method = 3.5;\n        if( readKey(KEY_5)) method = 4.5;\n        fragColor = vec4(method,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 2 && iy == 0) {\n        float speed = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_7)) speed = 0.;\n        if( readKey(KEY_8)) speed = 1.;\n        if( readKey(KEY_9)) speed = 5.;\n        fragColor = vec4(speed,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 3 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_M, 1., 2.);\n        return;\n    }\n\n    if (ix == 4 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_H, 1., 2.);\n        return;\n    }\n\n    if (ix == 5 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_A, 1., 2.);\n        return;\n    }\n\n    if (ix == 6 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_C, 1., 2.);\n        return;\n    }\n\n    if (ix == 7 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_W, 1., 2.);\n        return;\n    }\n\n\n    if (ix == 0 && iy == 1) {\n        fragColor = vec4(iResolution.x,0.,0.,0.);\n        return;\n    }\n\n    fragColor = vec4(0.,0.,0.,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Cellular automata buffer\n\nconst int KEY_SPACE = 32;\nconst int KEY_ENTER = 13;\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\n\nbool readKey( int key )\n{\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nint cell( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    float val = texelFetch(iChannel0, p, 0 ).w;\n    return ( val == liveval ) ? 1 : 0;\n}\nvec4 cellval( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n}\n\nfloat randpix(vec2 fragCoord) {\n    float rn = hash1(1.0+iTime+fragCoord.x*13.0+hash1(fragCoord.y*71.1));\n    return clamp(step(1.01-density/100., rn), 0., 1.) * (liveval);\n}\n\nfloat restart(vec2 fragCoord, int method, bool preserve) {\n    if (method == 0)\n        return randpix(fragCoord);\n\n    vec2 mid = iResolution.xy / 2.; \n    float w=100., h=100., radius=452., rradius=25.;\n    if (iResolution.y < 1000.) radius=182.;\n    float xrad=569.,yrad=453.;\n    float thick=2., wl=w-thick, hl=h-thick;\n\n    if (method == 1) {\n        if (length(fragCoord-mid)< radius && length(fragCoord-mid) > (radius-thick))\n            return liveval;//randpix(fragCoord);\n    }\n    if (method == 2) {\n        if (((fragCoord.x > mid.x - w && fragCoord.x < mid.x - wl) || (fragCoord.x > mid.x + wl && fragCoord.x < mid.x + w))\n            && fragCoord.y > mid.y - h && fragCoord.y < mid.y + h)\n            return liveval;//randpix(fragCoord);\n        if (((fragCoord.y > mid.y - h && fragCoord.y < mid.y - hl) || (fragCoord.y > mid.y + hl && fragCoord.y < mid.y + h))\n            && fragCoord.x > mid.x - w && fragCoord.x < mid.x + w)\n            return liveval;//randpix(fragCoord);\n    }\n    if (method == 3) {\n//        if (length(fragCoord-mid)< radius)\n        if (length(vec2((fragCoord.x-mid.x)*0.793,(fragCoord.y-mid.y)*1.0))< radius) // ellipse\n            return liveval;//randpix(fragCoord);\n    }\n    if (method == 4) {\n        float xmul=1.; if (iResolution.y < 1000.) xmul=1.75;\n        if (fragCoord.x > mid.x - rradius*xmul && fragCoord.x < mid.x + rradius*xmul+1. && fragCoord.y > mid.y - rradius && fragCoord.y < mid.y + rradius +1.)\n            return liveval;//randpix(fragCoord);\n    }\n    return preserve? -1. : 0.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ix = texelFetch(iChannel2, ivec2(0,0), 0 ).x;\n    float xres = texelFetch(iChannel2, ivec2(0,1), 0 ).x;\n    int method = int(texelFetch(iChannel2, ivec2(1,0), 0 ).x);\n    int speed = 4+int(texelFetch(iChannel2, ivec2(2,0), 0 ).x);\n    int mono = int(texelFetch(iChannel2, ivec2(3,0), 0 ).x);\n    int usecolor = 1-int(texelFetch(iChannel2, ivec2(6,0), 0 ).x);\n    int usewrap = 1-int(texelFetch(iChannel2, ivec2(7,0), 0 ).x);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(-3.5*sin((iTime-10.)*0.012), 3.5*sin(iTime*0.0105), 3.5*sin(iTime*0.02));\n    if (usecolor == 0) col = vec3(0.);\n    col = vec3(0.);\n\n    setRules(int(ix*10.), col);\n    uv.x-=0.4;\n    float axx = sin((uv.x*5.+uv.y)-0.8)*cos(uv.y*2.+2.1)*12.5+12.5;\n    axx=clamp(axx, 1.0, 5.0);\n\n    rm/=axx;\n    gm/=axx;\n    bm/=axx;\n    bp*=0.15;\n    gp*=0.15;\n    rp*=0.15;\n\n    wrap = usewrap;\n\n    ivec2 px = ivec2( fragCoord );\n    vec4 curr = cellval(px);\n    float ev = curr.w;\n\n    if (wrap == 0 && (fragCoord.y < 2. || fragCoord.x < 2.) ) {\n        fragColor = vec4( 0.0, 0.0, 0.0, 0.);\n        return;\n    }\n\n    if( iFrame==0 || readKey(KEY_SPACE) || readKey(KEY_UP) || readKey(KEY_DOWN) || int(xres) != int(iResolution.x)  ) {\n        fragColor = vec4( 0.0, 0.0, 0.0, restart(fragCoord, setmethod, false));\n        return;\n    }\n\n    if( readKey(KEY_1) || readKey(KEY_2) || readKey(KEY_3) || readKey(KEY_4) || readKey(KEY_5) ) {\n        fragColor = vec4( 0.0, 0.0, 0.0, restart(fragCoord, method, false));\n        return;\n    }\n\n    if (iFrame % (speed+1) > 0) {\n        fragColor = curr;\n        return;\n    }\n  \n    int k=0;\n    \n    if (nh == 0) {\n        // ..X..\n        // .X.X.\n        // X.*.X\n        // .X.X.\n        // ..X..\n        k =   cell(px+ivec2(0,-2)) + cell(px+ivec2(-1,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-2, 0))                        + cell(px+ivec2(2, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(1, 1)) + cell(px+ivec2(0, 2));\n    } else if (nh == 5) {\n        // XXXXX\n        // XXXXX\n        // XX*XX\n        // XXXXX\n        // XXXXX\n        k =   cell(px+ivec2(-1,-1)) + cell(px+ivec2(0,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-1, 0))                        + cell(px+ivec2(1, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(0, 1)) + cell(px+ivec2(1, 1))\n            + cell(px+ivec2(-1, 2)) + cell(px+ivec2(0, 2)) + cell(px+ivec2(1, 2))\n            + cell(px+ivec2(-1, -2)) + cell(px+ivec2(0, -2)) + cell(px+ivec2(1, -2))\n            + cell(px+ivec2(-2, -2)) + cell(px+ivec2(-2, -1)) + cell(px+ivec2(-2, 0))\n            + cell(px+ivec2(-2, 1)) + cell(px+ivec2(-2, 2))\n            + cell(px+ivec2(2, -2)) + cell(px+ivec2(2, -1)) + cell(px+ivec2(2, 0))\n            + cell(px+ivec2(2, 1)) + cell(px+ivec2(2, 2));\n    } else if (nh == 10) {\n        // XXXXX\n        // ..X..\n        // ..*..\n        // ..X..\n        // XXXXX    \n        k =   cell(px+ivec2(0,-1)) + cell(px+ivec2(0,1)) +\n            + cell(px+ivec2(-2, -2)) + cell(px+ivec2(-1, -2)) + cell(px+ivec2(0, -2)) + cell(px+ivec2(1, -2)) + cell(px+ivec2(2, -2))\n            + cell(px+ivec2(-2, 2)) + cell(px+ivec2(-1, 2)) + cell(px+ivec2(0, 2)) + cell(px+ivec2(1, 2)) + cell(px+ivec2(2, 2));\n    } else if (nh == 13) {\n        // XXXXX\n        // ....X\n        // XX*.X\n        // X...X\n        // XXXXX            \n        k =   \n            cell(px+ivec2(-1, 2)) + cell(px+ivec2(0, 2)) + cell(px+ivec2(1, 2))\n            + cell(px+ivec2(-1, -2)) + cell(px+ivec2(0, -2)) + cell(px+ivec2(1, -2))\n            + cell(px+ivec2(-2, -2)) + cell(px+ivec2(-1, 0)) + cell(px+ivec2(-2, 0))\n            + cell(px+ivec2(-2, 1)) + cell(px+ivec2(-2, 2))\n            + cell(px+ivec2(2, -2)) + cell(px+ivec2(2, -1)) + cell(px+ivec2(2, 0))\n            + cell(px+ivec2(2, 1)) + cell(px+ivec2(2, 2));\n            \n    } else {\n        // XXX\n        // X*X\n        // XXX\n        k =   cell(px+ivec2(-1,-1)) + cell(px+ivec2(0,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-1, 0))                        + cell(px+ivec2(1, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(0, 1)) + cell(px+ivec2(1, 1));\n    }\n    \n    float ff = 0.;\n    if (ev > 0.5) {\n        if (decimate > 0.) ff = ev-decimate; //clamp(ev-decimate, 0., 1000.);\n        if ((stayset & (1<<(k-1))) > 0 ) { ff = float(k); if (clampstay && ff > liveval) ff = liveval; }\n    }\n    else {\n        ff = (bornset & (1<<(k-1))) > 0 ? liveval : 0.;\n    }\n\n    if (mono == 0) {\n        if (ff >= 1.0) {\n            int st = int(ff);\n\n            float mulbase = float(k);\n            if (colch == 1) mulbase = ff;\n            else if (colch == 2) mulbase = 1.;\n            else if (colch == 3) mulbase = float(k^st);\n            \n            if ((st & ra) > 0) curr.x -= cstep*mulbase*rp;\n            if ((st & ga) > 0) curr.y -= cstep*mulbase*gp;\n            if ((st & ba) > 0) curr.z -= cstep*mulbase*bp;\n            \n            if (staypatt == 5 || staypatt == 6) curr.z=curr.y=curr.x;\n            \n        } else {\n            float stayt = cstep * stayval;\n            \n            if (staypatt == 0 || staypatt > 5) {\n                curr.x += cstep*rm;\n                curr.y += cstep*gm;\n                curr.z += cstep*bm;\n            }\n            else if (staypatt == 1) {\n                if(curr.x > cstep) {\n                    curr.x += cstep*rm;\n                    curr.y += cstep*gm;\n                    curr.z += cstep*bm;\n                }\n            }\n            else if (staypatt == 2) {\n                if(curr.y > cstep) {\n                    curr.x += cstep*rm;\n                    curr.y += cstep*gm;\n                    curr.z += cstep*bm;\n                }\n            }\n            else if (staypatt == 3) {\n                if(curr.z > cstep) {\n                    curr.x += cstep*rm;\n                    curr.y += cstep*gm;\n                    curr.z += cstep*bm;\n                }\n            }\n            else if (staypatt == 4) {\n                if(curr.z > cstep) {\n                    curr.x += cstep*rm;\n                    curr.y += cstep*gm;\n                }\n                if(curr.x > cstep) curr.z -= cstep*bm;\n            }\n            else if (staypatt == 5) {\n                curr.x += cstep*rm;\n                curr.z=curr.y=curr.x;\n            }\n        }\n\n        curr.x = clamp(curr.x, 0.03, 4000.0);\n        curr.y = clamp(curr.y, 0.29, 4000.0);\n        curr.z = clamp(curr.z, 0.35, 4000.0);\n\n}\n\n\tfragColor = vec4( clamp(curr.xyz,0.,1.), ff );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}