{
    "Shader": {
        "info": {
            "date": "1535576796",
            "description": "Coded live on twitch stream in Bonzomatic, and tidied/ported to shadertoy.\nUnedited Bonzomatic shader here: [url]https://gist.github.com/willkirkby/d13449b7857e40c81642a6c64386a058[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "llKyRw",
            "likes": 29,
            "name": "[twitch] Gilded Cage",
            "published": 3,
            "tags": [
                "gold",
                "cage"
            ],
            "usePreview": 0,
            "username": "yx",
            "viewed": 1063
        },
        "renderpass": [
            {
                "code": "vec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat scene(vec3 p)\n{\n    vec3 sp = p + vec3(1,3,2);\n\n    return min(\n        max(\n            max(\n                sdBox(p, vec3(1.)),\n                -sdBox(p,vec3(.9))\n            ),\n            abs(mod(length(sp)-iTime*.2,.2)-.1)-.01\n        ),\n        length(p)-.8\n    );\n}\n\nfloat sceneWithFloor(vec3 p)\n{\n    return min(\n        scene(p),\n        1.+p.y\n    );\n}\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n    vec3 accum = vec3(1);\n   \t// 20 maybe overkill?\n    for (int bounce = 0; bounce < 20; bounce++)\n    {\n        float tfloor = (cam.y + 1.)/-dir.y;\n        float t = 0.;\n        float k = 0.;\n        for(int i = 0; i < 100; i++)\n        {\n            k = scene(cam + t * dir);\n            t += k;\n            if (k < 0.001 || (tfloor > 0. && t > tfloor))\n                break;\n        }\n        if (tfloor > 0.)\n            t = min(t, tfloor);\n\n        vec3 h = cam + t * dir;\n\n        vec2 o = vec2(.005, 0);\n        vec3 n = normalize(vec3(\n            sceneWithFloor(h+o.xyy)-sceneWithFloor(h-o.xyy),\n            sceneWithFloor(h+o.yxy)-sceneWithFloor(h-o.yxy),\n            sceneWithFloor(h+o.yyx)-sceneWithFloor(h-o.yyx)\n        ));\n\n        if (h.y < -.999)\n        {\n            // floor\n            float A = .5;\n            float B = max(0.,sceneWithFloor(h+n*A));\n            float w = clamp(1.-length(h.xz) * .01, 0., 1.);\n            w = w * .2 + .8;\n            return accum * vec3(pow(B/A,.7)*.6+.4) * w;\n        }\n        else if (length(h) < .85)\n        {\n            // ball\n            float fresnel = mix(.001,1.,pow(1.-dot(-dir, n),5.));\n            accum *= fresnel;\n            cam = h + n * .01;\n            dir = reflect(dir, n);\n        }\n        else if (length(h) < 2.) // ew yucky hack\n        {\n            // cube\n            accum *= vec3(.72,.576,.288);\n            cam = h + n * .01;\n            dir = reflect(dir, n);\n        }\n        else\n        {\n            // sky\n            return accum * vec3(.8);\n        }\n    }\n    return vec3(0);\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 cam = vec3(0,0,-4);\n    vec3 dir = normalize(vec3(uv, 1));\n\n    cam.yz = rotate(cam.yz, sin(iTime*.1)*.25+.25);\n    dir.yz = rotate(dir.yz, sin(iTime*.1)*.25+.25);\n\n    cam.xz = rotate(cam.xz, iTime*.3);\n    dir.xz = rotate(dir.xz, iTime*.3);\n\n    out_color = vec4(pow(trace(cam,dir),vec3(.45)),1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}