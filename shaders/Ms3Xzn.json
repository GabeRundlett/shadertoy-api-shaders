{
    "Shader": {
        "info": {
            "date": "1457309827",
            "description": "Camera rail visualization",
            "flags": 0,
            "hasliked": 0,
            "id": "Ms3Xzn",
            "likes": 20,
            "name": "Camera Rail",
            "published": 3,
            "tags": [
                "camera",
                "spline"
            ],
            "usePreview": 0,
            "username": "Bers",
            "viewed": 949
        },
        "renderpass": [
            {
                "code": "// Author : SÃ©bastien BÃ©rubÃ©\n// Created : Oct 2014\n// Modified : Jan 2016\n//\n// 2 looping splines, implemented for testing camera animation.\n// Red spline could be camera position, green one could be camera target.\n//\n// Here, processing the camera position and target is quite cheap.\n// Drawing the path, however, is not really suited for a distance field shader, and is therefore expensive.\n// (Spline segments should indeed be passed as vertices instead of being drawn the way they are here).\n//\n// License : Creative Commons Non-commercial (NC) license\n\nconst int POINT_COUNT = 8;\nstruct CtrlPts\n{\n    vec2 p[POINT_COUNT];\n};\nvec2 PointArray(int i, CtrlPts ctrlPts)\n{\n    if(i==0 || i==POINT_COUNT  ) return ctrlPts.p[0];\n    if(i==1 || i==POINT_COUNT+1) return ctrlPts.p[1];\n    if(i==2 || i==POINT_COUNT+2) return ctrlPts.p[2];\n    if(i==3) return ctrlPts.p[3];\n    if(i==4) return ctrlPts.p[4];\n    if(i==5) return ctrlPts.p[5];\n    if(i==6) return ctrlPts.p[6];\n    if(i==7) return ctrlPts.p[7];\n    return vec2(0);\n}\n\nvec2 catmullRom(float fTime, CtrlPts ctrlPts)\n{\n    float t = fTime;\n    const float n = float(POINT_COUNT);\n    \n    int idxOffset = int(t*n);\n    vec2 p1 = PointArray(idxOffset,ctrlPts);\n    vec2 p2 = PointArray(idxOffset+1,ctrlPts);\n    vec2 p3 = PointArray(idxOffset+2,ctrlPts);\n    vec2 p4 = PointArray(idxOffset+3,ctrlPts);\n    \n    //For some reason, fract(t*n) returns garbage on my machine with small values of t.\n    //return fract(n*t);\n    //Using this below yields the same results, minus the glitches.\n    t *= n;\n    t = (t-float(int(t)));\n    \n    //A classic catmull-rom\n    //e.g.\n    //http://steve.hollasch.net/cgindex/curves/catmull-rom.html\n    //http://www.lighthouse3d.com/tutorials/maths/catmull-rom-spline/\n    vec2 val = 0.5 * ((-p1 + 3.*p2 -3.*p3 + p4)*t*t*t\n               + (2.*p1 -5.*p2 + 4.*p3 - p4)*t*t\n               + (-p1+p3)*t\n               + 2.*p2);\n    return val;\n}\n\n//Simple utility function which returns the distance from point \"p\" to a given line segment defined by 2 points [a,b]\nfloat debugDistanceToLineSeg(vec2 p, vec2 a, vec2 b)\n{\n    //e = capped [0,1] orthogonal projection of ap on ab\n    //       p\n    //      /\n    //     /\n    //    a--e-------b\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    vec2 e = a+clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0)*ab;\n    return length(p-e);\n}\n\nvec2 debugDistanceField(vec2 uv, CtrlPts ctrlPts)\n{\n    //This is just to illustrate the resulting spline. A Spline distance field should not be computed this way.\n    //If the real intent was to show a distance field, something like this perhaps should be used:\n    //https://www.shadertoy.com/view/XsX3zf\n    const float MAX_DIST = 10000.0;\n    float bestX = 0.0;\n    \n    //Primary (rough) estimate : decent results with 2 lines per control point (faint blue lines)\n    const int iter = POINT_COUNT*2+1;\n    //const int iter = POINT_COUNT*1+1; //<-Faster\n    //const int iter = POINT_COUNT*3+1; //<-Nicer\n    float primarySegLength = 1.0/float(iter-1);\n    vec2 pA = catmullRom(0., ctrlPts);\n    float minRoughDist = MAX_DIST;\n    float x = 0.0;\n    for(int i=0; i < iter; ++i)\n    {\n        vec2 pB = catmullRom(x, ctrlPts);\n        \n        float d = debugDistanceToLineSeg(uv, pA, pB);\n        pA = pB;\n        if(d<minRoughDist)\n        {\n            bestX = x;\n            minRoughDist = d;\n        }\n         \n        x += primarySegLength;\n        x = min(x,0.99999); //<1 To prevent artifacts at the end.\n    }\n    \n    //Secondary (smooth) estimate : refine (red curve)\n    const int iter2 = 8;\n    x = max(bestX-1.01*primarySegLength,0.0); //Starting 25% back on previous seg (50% overlap total)\n    float minDist = MAX_DIST;\n    pA = catmullRom(x, ctrlPts);\n    for(int i=0; i < iter2; ++i)\n    {\n        vec2 pB = catmullRom(x, ctrlPts);\n        float d = debugDistanceToLineSeg(uv, pA, pB);\n        pA = pB;\n        \n        if(d<minDist)\n        {\n            bestX = x;\n            minDist = d;\n        }\n         \n        //Covering 1.25x primarySegLength (50% overlap with prev, next seg)\n        x += 1.25/float(iter2-1)*primarySegLength;\n        x = min(x,0.99999); //<1 To prevent artifacts at the end.\n    }\n    \n    return vec2(minDist,minRoughDist);\n}\n\nvec2 getUV(vec2 px)\n{\n    vec2 uv = px / iResolution.xy;\n    uv.y *= iResolution.y/iResolution.x;\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CtrlPts ctrlPtsA;\n\tctrlPtsA.p[0] = vec2(0.10,0.25);\n    ctrlPtsA.p[1] = vec2(0.2,0.1);\n    ctrlPtsA.p[2] = vec2(0.6,0.35);\n    ctrlPtsA.p[3] = vec2(0.4,0.1);\n    ctrlPtsA.p[4] = vec2(0.8,0.35);\n    ctrlPtsA.p[5] = vec2(0.6,0.55);\n    ctrlPtsA.p[6] = vec2(0.5,0.45);\n    ctrlPtsA.p[7] = vec2(0.3,0.49);\n    \n    CtrlPts ctrlPtsB;\n\tctrlPtsB.p[0] = 0.95*vec2(0.146,0.241);\n    ctrlPtsB.p[1] = 0.95*vec2(0.275,0.172);\n    ctrlPtsB.p[2] = 0.95*vec2(0.472,0.222);\n    ctrlPtsB.p[3] = 0.95*vec2(0.485,0.152);\n    ctrlPtsB.p[4] = 0.95*vec2(0.764,0.367); \n    ctrlPtsB.p[5] = 0.95*vec2(0.692,0.525);\n    ctrlPtsB.p[6] = 0.95*vec2(0.531,0.509);\n    ctrlPtsB.p[7] = 0.95*vec2(0.363,0.503);\n    \n    vec2 pDebug = vec2(1,0);\n    if(iMouse.z > 0.1)\n    {\n        vec2 pMouse = getUV(iMouse.xy);\n        \n        int minIndex = 0;\n        float fMinDist = 10000.0;\n        for(int i=0; i < POINT_COUNT; ++i)\n        {\n            vec2 ctrl_pt = ctrlPtsB.p[i];\n            float d = length(ctrl_pt-pMouse);\n            if(d<fMinDist)\n            {\n                minIndex = i;\n                fMinDist = d;\n                pDebug = pMouse/0.95;\n            }\n        }\n        for(int i=0; i < POINT_COUNT; ++i)\n        {\n            if(minIndex==i)\n            {\n                ctrlPtsB.p[i] = pMouse;\n            }\n        }\n\t}\n    \n    vec2 uv = getUV(fragCoord.xy);\n    vec3 c = vec3(0);\n    \n    //<Draw spline A>\n    {\n        vec2 dSeg = debugDistanceField(uv, ctrlPtsA);\n        c = mix(vec3(0.7,0  ,0.0),c,smoothstep(0.0,0.0025,dSeg.x));\n        float minDistP = 10000.0;\n        for(int i=0; i < POINT_COUNT; ++i)\n        {\n            vec2 ctrl_pt = PointArray(i,ctrlPtsA);\n            minDistP = min(length(uv-ctrl_pt),minDistP);\n        }\n        c = mix(vec3(1,0.6,0.6),c,smoothstep(0.004,0.006,minDistP));\n    }\n    //</Draw spline A>\n    \n\t//<Draw spline B>\n    {\n        vec2 dSeg = debugDistanceField(uv, ctrlPtsB);\n        c = mix(vec3(0.5,0.7,0),c,smoothstep(0.0,0.0025,dSeg.x));\n        float minDistP = 10000.0;\n        for(int i=0; i < POINT_COUNT; ++i)\n        {\n            vec2 ctrl_pt = PointArray(i,ctrlPtsB);\n            minDistP = min(length(uv-ctrl_pt),minDistP);\n        }\n        c = mix(vec3(0.8,1,0.6),c,smoothstep(0.004,0.006,minDistP));\n    }\n    //</Draw spline B>\n    \n    float fTime = iTime*0.15;\n    vec2 pA = catmullRom(fract(fTime), ctrlPtsA);\n    vec2 pB = catmullRom(fract(fTime+0.035), ctrlPtsB);\n    \n    //Draw moving points\n    c = mix(vec3(1,0.0,0),c,smoothstep(0.006,0.009,length(uv-pA)));\n    c = mix(vec3(0,0.7,0),c,smoothstep(0.006,0.009,length(uv-pB)));\n    \n    float dCamDir = debugDistanceToLineSeg(uv, pA, pB);\n\tc = mix(vec3(1.0,1.0,1.0),c,smoothstep(0.001,0.003,dCamDir));\n\t\n\tfragColor = vec4(c,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}