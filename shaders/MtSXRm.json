{
    "Shader": {
        "info": {
            "date": "1442421176",
            "description": "Using my custom \"Box Divide\" formula to tile a square tunnel. Normal wrapping is used to give the tiles a cheap, fake, subsurface luminescent glow. As a minor point of interest, the tunnel is rendered using a cheap raytracing trick.",
            "flags": 0,
            "hasliked": 0,
            "id": "MtSXRm",
            "likes": 25,
            "name": "Luminescent Tiles",
            "published": 3,
            "tags": [
                "tunnel",
                "normal",
                "wrap",
                "luminescence"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 5013
        },
        "renderpass": [
            {
                "code": "/*\n\n\tUsing my custom \"Box Divide\" formula to tile a square tunnel. Normal wrapping is \n\tused to give the tiles a cheap, fake, subsurface, luminescent glow. As a minor point of \n\tinterest, the tunnel is rendered using a cheap raytracing trick. There's no raymarching\n\tinvolved.\n\n\tFor anyone interested, the \"texCol\" function contains some cylindrical mapping examples.\n\n\tThere looks like there's more code here than there is. Most of it is optional 2D functions.\n\tIf you keep only the stuff you want, there's not much code at all.\n\n\tBox Divide ID - Shane\n\thttps://www.shadertoy.com/view/WlsSRs\n\n*/\n\n\n\n// 2D rotation. Always handy.\nmat2 rot(float th){ float cs = cos(th), si = sin(th); return mat2(cs, -si, si, cs); }\n\n\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(41, 289)))* 43758.5453);}\n\n/*\n// Box Divide\n// 2015 BeyondTheStatic\n// Original function: https://www.shadertoy.com/view/Xl2XRh\n// Function with changes applied: https://www.shadertoy.com/view/4l2XR1\nvec3 boxDivide(in vec2 p) {\n    \n    vec2 ip = floor(p);\n    \n    p -= ip;\n    \n    vec2 l = vec2(1);\n\n    bool flip=false;\n    \n    for(int i=0; i<8; i++) {\n \n        float r = hash21(l + ip)*0.5 + 0.25;\n        \n        if(l.x>l.y) { p=p.yx; l=l.yx; flip=true; }\n        \n        if(p.x<r) { l.x /= r; p.x /= r; }\n        else { l.x /= (1.-r); p.x = (p.x-r)/(1.-r); }\n        \n        if(flip){ p=p.yx; l=l.yx; flip=false; }\n        \n    }\n    \n    p = clamp(p, 0., 1.);\n    \n    // Making a basic rounded box.\n    //float f = max(1.- dot(pow(abs(p - .5), vec2(6)), vec2(64)), 0.);\n   \n    float f = pow(16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y), 0.5);\n    \n    //float f = pow(abs(sin(p.x*3.14159)*sin(p.y*3.14159)), 0.3);\n    \n    //return vec3(min(p*f*1.5, 1.), f);\n    return vec3(f);\n}\n*/\n\n// IQ's signed box formula.\nfloat sBox(vec2 p, vec2 b, float r){\n  \n  // Just outside lines.\n  //p = max(abs(p) - b + r, 0.);\n  //return length(p) - r;\n\n  // Inside and outside lines.\n  vec2 d = abs(p) - b + r;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - r;\n}\n\n\n#define VERT_OFFSET\n//#define SHOW_GRID\n\nvec3 boxDivide(in vec2 p) {\n    \n    \n    // Scaling factor. If changing this, you may need to change a few settings\n    // here and there to suit your needs.\n    const vec2 sc = vec2(1, 1)/3.; // See square tube scale.\n    \n   \n    p *= sc;\n   \n    p.xy += .5;\n    \n    // Basid grid tile ID. This will be further split into subtiles, which will\n    // each have their own ID based on postion.\n    vec2 ip = floor(p); \n   \n    // If using the vertical offset option, update the position and ID accordingly.\n    #ifdef VERT_OFFSET\n    if(mod(ip.x, 2.)>.5){\n        p.y -= 1./2.;\n        ip = floor(p);\n    }\n    #endif\n   \n    p -= ip + .5; // The original grid tile's base local coordinates.\n    \n    \n    #ifdef SHOW_GRID\n    float grid = abs(max(abs(p.x), abs(p.y)) - .5) - .005;\n    #endif\n    \n    // Block dimension. Every time there's a random split, it'll be factored down\n    // according to the random split factor.\n    vec2 l = vec2(1, 1);  \n    \n    // The starting point, which represents the bottom left corner (or is it the top left corner?)\n    // of the grid cell. With every split, it will be moved to the new split position.\n    vec2 s = vec2(-.5);    \n    \n    // Split number.\n    const int iNum = 6;\n\n    \n    //float r = hash21(ip);\n    //float r2 = hash21(ip + .35);\n    \n    float count = 0.;\n    \n    \n    // Create a box, divide it randomly, then do the same with the \n    // divided portions. Ad infinitum...\n    for(int i=0; i<iNum; i++) {\n \n        float r = hash21(ip + l + float(i)/float(iNum))*.3 + (1.-.3)/2.;\n        // Forcing a vertical to horizontal split (and vice versa) every\n        // iteration. It's not necessary, but I think it looks nicer.\n        float r2 = mod(float(i), 2.)>.5? 0. : 1.;\n        \n        // Alternate, more randomized sequence.\n        //float r2 = hash21(ip + 113.5 + l.yx + float(i)/float(iNum));\n        // Alternate heuristic, for aesthetics purposes, to ensure at least one split.\n        //if(i==iNum-1 && count<1.5) r2 = 1.;\n\t\t//if(i==iNum-1 && count>float(iNum) - 2.5) r2 = 0.;\n \n        \n        // Alternate way to randomize things. How this is achieved is up to the user.\n        //r = hash21(l + r + float(i)/float(iNum))*.3 + (1.-.3)/2.;\n        //r2 = hash21(l.yx + r + r2 + float(i)/float(iNum));\n        \n         \n        //r2 = mod(float(i), 2.)>.5? 0. : 1.;\n        //if(r2<.5) { p = p.yx; l = l.yx; s = s.yx; }\n        \n        // If the second random number is above a certain threshold, split \n        // vertically. Otherwise, split horizontally.\n        if(r2>.5){ \n            \n            // Counter for heuristics above. Uncomment if using them.\n            // count++;\n            \n            // This line splits the current cell down the middle, in accordance with\n            // the random factor, \"r,\" and the cell width \"l.x.\" \n            if(p.x>s.x + l.x*r) {\n\n                s.x += l.x*r; // Advance the position to the right of the split.\n                l.x *= (1. - r); // Reduce the width by a factor of \"1 - r.\"\n            }\n            else l.x *= r; // No need to advance position, but we need to reduce the width.\n        \n        }\n        else {\n            \n              // This line splits the current cell horizontally, in accordance with\n             // the random factor, \"r,\" and the cell height \"l.y.\" \n             if(p.y>s.y + l.y*r) {\n\n                s.y += l.y*r; // Advance the position above (or below?) the split.\n                l.y *= (1. - r); // Reduce the height by a factor of \"1 - r.\"\n\n             }\n             else l.y *= r; // No need to advance position, but we need to reduce the height.\n            \n        }\n\n    }\n    \n    \n    // Constructing the box itself: Actually, once you have the box coordinates, you can \n    // do whatever you want with them.\n    //\n    // Rounding factor: This depends on the look you're after. It could be a constant, \n    // or you could choose to have no rounding at all. After experimentingn, I decided \n    // to make the roundedness of the tile dependent on the minimum side length.\n    float rf = min(l.x, l.y); \n    float d = sBox(p - s - l/2., l/2., .08*sqrt(rf));\n    \n   \n    \n    // Smoothing factor.\n    float sf = 8./iResolution.y*sc.x;\n    \n    // Individual, position-based tile ID. Note that it'll read into the texture\n    // at the correct position.\n    vec2 id = ip + s + l/2.;\n    \n    // If using the vertical offset, the ID needs to follow suit.\n    #ifdef VERT_OFFSET\n    if(mod(ip.x, 2.)>.5){\n        id.y += .5;\n    }\n    #endif\n    \n    \n    \n    // Using the ID to color the individual tile.\n    \n    \n    // Textured version. Note that this is not an overlay -- Each tile has \n    // a uniform color.\n    vec3 tx = texture(iChannel0, id/sc/1.5).xyz; tx *= tx;\n    vec3 pCol = 1. - tx;\n    \n    // Original random colored version.\n    //vec3 pCol = vec3(1, hash21(id), hash21(id*57. + .5));\n    \n    // 2D noise, etc.\n    //float c =  n2D(id*2. + iTime);\n    //vec3 pCol = min(vec3(c*.1 + .9, c + .05, c*c*.7), 1.); \n\n    \n   \n    \n    vec3 col = vec3(.5);\n    float sh = clamp(.5 - d*5./length(l), 0., 1.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, d)); // Rounded pavers.\n    col = mix(col, pCol*sh, 1. - smoothstep(0., sf, d + .02*sc.x)); \n    //col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(d + .03*sc.x) - .001*sc.x)); \n    // More decoration, if so desired.\n    //col = mix(col, mix(pCol*1.5, vec3(1), .35), 1. - smoothstep(0., sf, d + .02*sc.x)); \n    //col = mix(col, vec3(0), (1. - smoothstep(0., sf, d + .034*sc.x))*.9); \n    //col = mix(col, pCol*sh, 1. - smoothstep(0., sf, d + .042*sc.x)); \n \n    \n    // Center, space preserving dots.\n    \n    // Just the center dot.\n    //float d2 = length(p - s - l/2.) - .015/sc;\n    \n    /*\n    // Splitting space to produce four rivot-looking dots.\n    p = abs(p - s - l/2.) - l/2. + .0225;\n    float d2 = length(p) - .002/sc.x;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, d2)); // Rounded pavers.\n    col = mix(col, vec3(2), 1. - smoothstep(0., sf, d2 + .007)); // Rounded pavers.\n    */\n    \n    #ifdef SHOW_GRID\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf*2., grid - .005)); \n    col = mix(col, vec3(1, .8, .2), 1. - smoothstep(0., sf, grid)); \n    #endif\n \n \n    \n    return col;\n    \n}\n\nfloat tiles(in vec2 p){\n\n    float c = abs(sin(p.x*3.14159) * cos(p.y*3.14159));\n    \n    return pow(c*0.5, 0.125)*clamp( 1. + hash21(floor(p*16.))*0.05-0.025, 0., 1.);\n\n}\n\nfloat tiles2(vec2 p){\n\t\n\n    p = fract(p);\n    \n    //p*=p;\n    \n    float s = pow( 16.*p.x*p.y*(1.0-p.x)*(1.0-p.y), 0.25);\n    float s2 = (sin(p.x*3.14159)*sin(p.y*3.14159)*0.5+0.5);\n    \n    s = (s - s2*0.5)*2.;\n    \n    return clamp(s, 0., 1.);//*c;\n\n}\n\nvec3 texCol( in vec3 p, in vec3 n){\n    \n    // Cylindrical mapping. Note the divide by 8. It's an arbitrary value,\n    // and controls the stretch in the z-direction.\n    //vec2 uv = vec2(atan(p.y, p.x)/6.2832, p.z/8.);\n    \n    // Using box mapping (I made that up) for this particular example.\n    vec2 uv = (p.xz*n.y + p.yz*n.x);\n    \n    vec3 col = boxDivide(uv);\n    vec3 tex = 1.-texture(iChannel0, uv/2.).zyx;\n    return tex*tex*col;\n    \n    //float c = tiles2(uv*10.); \n    //return (texture(iChannel0, uv*2.).xyz*0.5+0.5)*c;    \n    \n    // Cylindrical texture mapping.\n    //return texture(iChannel0, uv*3.).xyz;\n    \n    //float c = tiles2(uv*24.); \n    //return texture(iChannel0, uv*4.).xyz*c; \n    \n    // etc.\n}\n\nfloat texShade(vec3 p, in vec3 n){\n    \n    vec3 col = texCol(p, n);\n    return dot(col, vec3(0.299, 0.587, 0.114));\n}\n\nvec3 blackbodyPalette(float t){\n\n    t = t*2200.; // Temperature. Hardcoded to 4000, in this case.\n    \n\n    float cx = (0.860117757 + 1.54118254e-4*t + 1.28641212e-7*t*t)/(1.0 + 8.42420235e-4*t + 7.08145163e-7*t*t);\n    float cy = (0.317398726 + 4.22806245e-5*t + 4.20481691e-8*t*t)/(1.0 - 2.89741816e-5*t + 1.61456053e-7*t*t);\n    \n    // Converting the chromacity coordinates to XYZ tristimulus color space.\n    float d = (2.*cx - 8.*cy + 4.);\n    vec3 XYZ = vec3(3.*cx/d, 2.*cy/d, 1. - (3.*cx + 2.*cy)/d);\n    \n    vec3 RGB = mat3(3.240479, -0.969256, 0.055648, \n                    -1.537150, 1.875992, -0.204043, \n                    -0.498535, 0.041556, 1.057311) * vec3(1./XYZ.y*XYZ.x, 1., 1./XYZ.y*XYZ.z);\n\n    return max(RGB, 0.)*pow(t*0.0004, 4.); \n}\n\nvec3 firePalette(float i){\n\n    float T = 1400. + 1300.*i; // Temperature range (in Kelvin).\n    vec3 L = vec3(7.4, 5.6, 4.4); // Red, green, blue wavelengths (in hundreds of nanometers).\n    L = pow(L,vec3(5.0)) * (exp(1.43876719683e5/(T*L))-1.0);\n    L = (1.0-exp(-5e8/L)); // Exposure level. Set to \"50.\" For \"70,\" change the \"5\" to a \"7,\" etc.\n    \n    return (L.xyy + L.xzz)*0.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Screen coordinates, plus some movement about the center.\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y + vec2(0.5*cos(iTime*0.5), 0.25*sin(iTime*0.5));\n    \n    // Camera turbulence.\n    //uv.x += smoothstep(0.4, 0.7, sin(iTime*2.)*0.5+0.5)*cos(iTime*48.)*.003;\n    //uv.y += smoothstep(0.4, 0.7, cos(iTime*2.)*0.5+0.5)*sin(iTime*64.)*.003;\n    \n    // Unit direction ray.\n    vec3 rd = normalize(vec3(uv, 1.));\n    //rd.xy *= rot(sin(iTime*0.25)*0.5); // Very subtle look around, just to show it's a 3D effect.\n    //rd.xz *= rot(sin(iTime*0.25)*0.5);\n    \n \n    rd.xy *= rot(smoothstep(0.0, 1., sin(iTime*0.5)*0.5+0.5)*3.14159); // Look around, just to show it's a 3D effect.\n    rd.xz *= rot(smoothstep(0.2, 0.8, sin(iTime*0.25)*0.5+0.5)*3.14159);    \n    \n    \n    // Screen color. Initialized to black.\n    vec3 col = vec3(0);\n    \n    /*\n    // Ray intersection of a cylinder (radius one) - centered at the origin - from a ray-origin that has XY coordinates \n    // also centered at the origin.    \n    float sDist = max(dot(rd.xy, rd.xy), 1e-16); // Analogous to the surface function.\n    sDist = 1.4142/sqrt(sDist); // Ray origin to surface distance.\n\t*/\n    \n    /*\n    // Same as above, but using a Minkowski distance and scaling factor.\n    vec2 scale = vec2(1., 1.);\n    float power = 6.;\n    float sDist = max(dot( pow(abs(rd.xy)*scale, vec2(power)), vec2(1.) ), 1e-16); // Analogous to the surface function.\n    sDist = 1./pow( sDist, 1./power ); // Ray origin to surface distance.\n\t*/\n    \n    \n    // Square tube.\n    vec2 scale = vec2(0.75, 1.);\n    float sDist = max(max(abs(rd.x)*scale.x, abs(rd.y)*scale.y), 1e-16); // Analogous to the surface function.\n    sDist = 1./(sDist); // Ray origin to surface distance.\n\t\n    \n    //if(sDist>1e-8){\n        \n        // Surface position.\n        vec3 sp = vec3(0.0, 0.0, iTime*4.) + rd*sDist;\n \n        // Surface normal.\n        //vec3 sn = normalize(vec3(-sp.xy, 0.)); // Cylinder normal.\n        //vec3 sn = normalize(-sign(sp)*vec3(pow(abs(sp.xy)*scale, vec2(power-1.)), 0.)); // Minkowski normal.\n    \tvec3 sn =  normalize(-sign(sp)*vec3(abs(rd.x*scale.x)>abs(rd.y*scale.y) ? vec2(1., 0.) : vec2(0., 1.), 0.)); // Square normal.\n    \t\n    \n        // Coloring the surface.\n        vec3 objCol = texCol(sp, sn);\n        \n        // Bump mapping.\n        \n        const vec2 eps = vec2(0.015, 0.);\n        float c = dot(objCol, vec3(0.299, 0.587, 0.114)); // Base value. Saving an extra lookup.\n        //float c = texShade(sp); // Base value. Used below to color the surface.\n        // 3D gradient vector... of sorts. Based on the bump function. In this case, Voronoi.                \n        vec3 gr = (vec3(texShade(sp-eps.xyy, sn), texShade(sp-eps.yxy, sn), texShade(sp-eps.yyx, sn))-c)/eps.x;\n        gr -= sn*dot(sn, gr); // There's a reason for this... but I need more room. :)\n        sn = normalize(sn + gr*0.15); // Combining the bump gradient vector with the object surface normal.\n\n    \n    \tfloat wrap = 0.2;\n        float scatWidth = 0.35;\n        // Lighting.\n        //\n    \t// Light 1\n        //\n        // The light is hovering just in front of the viewer.\n        vec3 lp = vec3(0.0, 0.0, iTime*4. + 2.5);\n        vec3 ld = lp - sp; // Light direction.\n        float dist = max(length(ld), 0.001); // Distance from light to the surface.\n        ld /= dist; // Use the distance to normalize \"ld.\"\n\n        // Light attenuation, based on the distance above.\n        float atten = min(1.0/max(0.75 + dist*.5 + dist*dist*0.2, 0.001), 1.0);\n        \n       \n        float diff = max((dot(sn, ld) + wrap)/((1.+wrap)), 0.); // Diffuse light value.\n        float spec = pow(max(dot(reflect(-ld, sn), -rd), 0.), 16.); // Specular highlighting.\n    \n    \tfloat scatter = smoothstep(0.0, scatWidth, diff) * smoothstep(scatWidth * 2.0, scatWidth, diff);\n        scatter = pow(scatter, 1.);\n\n    \t// Light 2\n        //        \n        // The light is hovering just beind the viewer.\n        vec3 lp2 = vec3(0.0, 0.0, iTime*4. - 2.5);\n        vec3 ld2 = lp2 - sp; // Light direction.\n        float dist2 = max(length(ld2), 0.001); // Distance from light to the surface.\n        ld2 /= dist2; // Use the distance to normalize \"ld.\"\n\n        // Light attenuation, based on the distance above.\n        float atten2 = min(1.0/max(0.75 + dist2*.5 + dist2*dist2*0.2, 0.001), 1.0);\n        \n       \n        float diff2 = max((dot(sn, ld2) + wrap)/((1.+wrap)), 0.); // Diffuse light value.\n        float spec2 = pow(max(dot(reflect(-ld2, sn), -rd), 0.), 16.); // Specular highlighting.\n    \n    \tfloat scatter2 = smoothstep(0.0, scatWidth, diff2) * smoothstep(scatWidth * 2.0, scatWidth, diff2);\n    \tscatter2 = pow(scatter2, 1.);\n    \n\n\n        // Using the values above to produce the final color.\n    \tcol += (objCol*(diff*0.5 + 0.05 + firePalette(scatter/1.5)*1.5) + spec*vec3(0.5, 0.85, 1.))*atten;\n   \t    col += (objCol*(diff2*0.5 + 0.05 + firePalette(scatter2/1.5)*1.5) + spec2*vec3(0.5, 0.85, 1.))*atten2;\n        \n        \n    //}\n    \n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n}\n\n    ",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}