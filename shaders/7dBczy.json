{
    "Shader": {
        "info": {
            "date": "1643684414",
            "description": "shapes",
            "flags": 0,
            "hasliked": 0,
            "id": "7dBczy",
            "likes": 4,
            "name": "shaping01",
            "published": 3,
            "tags": [
                "shapes"
            ],
            "usePreview": 0,
            "username": "Del",
            "viewed": 201
        },
        "renderpass": [
            {
                "code": "// playing with some shaping ideas 01/02/2022\n\nvec2 gm;\n\nvec2 smoothRot(vec2 p,float s,float m,float c,float d)\n{\n  s*=0.5;\n  float k=length(p);\n  float x=asin(sin(atan(p.x,p.y)*s)*(1.0-m))*k;\n  float ds=k*s;\n  float y=mix(ds,2.0*ds-sqrt(x*x+ds*ds),c);\n  return vec2(x/s,y/s-d);\n}\n\nfloat wedge(vec3 position, float halfWidth, float halfHeight, float halfDepth)\n{\n    vec2 end = vec2(halfWidth, -halfHeight);\n    vec2 d1 = vec2(-halfWidth - position.x, max(abs(position.y) - halfHeight, 0.0));\n    vec2 d2 = position.xy - end * clamp(dot(position.xy, end) / dot(end, end), -1.0, 1.0);\n    vec2 d3 = vec2(max(abs(position.x) - halfWidth, 0.0), -halfHeight - position.y); \n    float d4 = sqrt(min(min(dot(d1, d1), dot(d2, d2)), dot(d3, d3))) * sign(max(max(max(d1.x, d2.x), d2.y), d3.y));\n    float d5 = abs(position.z) - halfDepth;\n    return length(max(vec2(d4, d5), 0.0)) + min(max(d4, d5), 0.0);\n}\n\nmat2 rot(float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat map( in vec3 p )\n{\n    \n    float sides = 10.0;\n    if (iMouse.z>0.5)\n    {\n        if (gm.y>0.5)\n            p.y = abs(p.y);\n    \n        sides=6.0;\n    }\n    float h = 1.5+sin(iTime)*0.25;\n\n    vec3 pos = p;\n    pos.xz *= rot(iTime*0.5);\n    pos.zx = smoothRot(pos.xz,sides,0.0,2.0,1.0);\n    float d1 = wedge(pos, 1.0, h, 4.0);\n\n    pos = p+vec3(5.0,0.0,0.0);\n    pos.xz *= rot(iTime*0.5);\n    pos.zx = smoothRot(pos.xz,sides,0.0,1.0,1.0);\n    float d2 = wedge(pos, 1.0, h, 4.0);\n\n    pos = p-vec3(5.0,0.0,0.0);\n    pos.xz *= rot(iTime*0.5);\n    pos.zx = smoothRot(pos.xz,sides,0.05,1.0,1.0);\n    float d3 = wedge(pos, 1.0, h, 4.0);\n\n\n    d1 = min(d1,d2);\n    d1 = min(d1,d3);\n    \n    return d1*0.9;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#define AA 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    gm = (-iResolution.xy + 2.0*iMouse.xy)/iResolution.y;    \n\n     // camera movement\t\n\tfloat an = 3.14*0.5;//0.5*iTime;\n\tvec3 ro = vec3( 8.0*cos(an), 0.0+(sin(iTime*0.25)*3.0), 8.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n        // raymarch\n        const float tmax = 50.0;\n        float t = 0.0;\n        for( int i=0; i<128; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\n        float v = 1.0-abs(p.y);\n        vec3 col = vec3(v*0.1);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.7,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}