{
    "Shader": {
        "info": {
            "date": "1644038535",
            "description": "I was curious if the observed speed of the Peripheral Drift illusion, (the Rotating Snakes illusion) can be canceled out by a very slight drift. \nFor me, it appears to move at ~0.002.5 rads/sec.\n\nTunable parameters can be found at line 94.",
            "flags": 0,
            "hasliked": 0,
            "id": "ssjyDG",
            "likes": 11,
            "name": "Peripheral Drift Inverse",
            "published": 3,
            "tags": [
                "math",
                "torus",
                "illusion"
            ],
            "usePreview": 0,
            "username": "copperbotte",
            "viewed": 345
        },
        "renderpass": [
            {
                "code": "\n// The classical optical illusion. Blue background, orange center. +v is +x.\n// UV space is (0,1) in both axes.\nvec3 optical_illusion(in vec2 uv)\n{\n    const vec3 color_bg = vec3(1,0.5,0);\n    const vec3 color_fg = vec3(0,0,1);\n    const vec3 color_forw = vec3(0);\n    const vec3 color_back = vec3(1);\n    const float r_o = 0.9;\n    const float r_i = 0.7;\n    \n    vec2 xy = mod(uv, 1.0) * 2.0 - 1.0;\n    float r2 = dot(xy, xy);\n    float r_o2 = r_o*r_o;\n    float r_i2 = r_i*r_i;\n    \n    // Smoothly interpolate the ifs to prevent branching\n    // Thanks Fabrice!\n    const float dx = 0.05;\n    float r2smooth_out = smoothstep(r_o2-dx, r_o2+dx, r2);\n    float r2smooth_in = smoothstep(r_i2-dx, r_i2+dx, r2);\n\n    float xsmooth = smoothstep(-dx, dx, xy.x);\n    \n    vec3 xcolor = mix(color_back, color_forw, xsmooth);\n    vec3 forecolor = mix(color_fg, xcolor, r2smooth_in);\n    return mix(forecolor, color_bg, r2smooth_out);\n}\n\n// Generate a ray to march\nvoid generate_ray(in vec2 xy, out vec3 rPos, out vec3 rDir)\n{\n    rPos = vec3(0,0,2); // 2 from the center of the torus, right handed coordinates.\n    \n    vec3 dir = vec3(xy, -1);\n    rDir = normalize(dir);\n}\n\n// The torus sdf SHOULD BE the closest point on the tangencial ring?\n// Inputs in world position\nfloat Sdf(in vec3 wPos, in float inner_rad, in float outer_rad)\n{   \n    // Align the world position to the inner ring\n    vec2 rPos = vec2(length(wPos.xz), wPos.y);\n    \n    // Compute the offset from the outer ring\n    rPos -= vec2(outer_rad, 0);\n    \n    //SDF is this distance, offset from inner_rad\n    float sdf = length(rPos) - inner_rad;\n    \n    return sdf;\n}\n\n\n// SDF Raymarch\nvec3 raymarch(in vec3 rPos, in vec3 rDir, in float inner_rad, in float outer_rad)\n{\n    vec3 sPos = rPos;\n    \n    float dir = sign(Sdf(sPos, inner_rad, outer_rad));\n    \n    for(int i=0; i<1000; ++i)\n    {\n        float sdf = Sdf(sPos, inner_rad, outer_rad);\n        sPos += rDir * dir * sdf;\n        if(abs(sdf) < 1e-4)\n            return sPos;\n    }\n    \n    return sPos;\n}\n\n\n// Color each world position according to the location on the torus\nvec3 color_wpos(in vec3 wPos, in float inner_rad, in float outer_rad, in float speed, in vec2 scale)\n{\n    // get the torus angles\n    float phi = atan(wPos.z, wPos.x);\n    float r = length(wPos.xz);\n    float theta = atan(wPos.y, r - outer_rad);\n    \n    phi = phi - speed*iTime;\n    \n    return optical_illusion(scale*vec2(phi, theta)/3.141592);\n}\n\n// Seperate sample function for integration\nvec3 sample_image( in vec2 uv )\n{\n    // Correct for aspect ratio, convert so 0 is the center\n    vec2 xy = uv * 2.0 - 1.0;\n    xy.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0);\n\n    /***************************************/\n    /*         Tunable Parameters          */\n    /***************************************/\n    float inner_rad = 0.75;//0.5;//abs(0.9*sin(iTime) + 1.0);//\n    float outer_rad = 2.1 - inner_rad;\n    float speed = 2.5e-3; // radians per second\n    vec2 scale = vec2(25.0, 10.0);\n    \n    vec3 rPos, rDir;\n    generate_ray(xy, rPos, rDir);\n    vec3 sPos = raymarch(rPos, rDir, inner_rad, outer_rad);\n    \n    if(abs(Sdf(sPos, inner_rad, outer_rad)) < 0.01)\n        //col = vec3(length(sPos - rPos)/10.0);\n        col = color_wpos(sPos, inner_rad, outer_rad, speed, scale);\n    \n    // Output to screen\n    return col;\n}\n\n// random number generator **\n// taken from iq :)\nfloat seed;    //seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n \n    const int samples = 4;\n    const float s_f = float(samples);\n \n    for(int i=0; i<samples; ++i)\n    {\n        vec2 rng = vec2(rnd(), rnd()) - 0.5;\n        //vec2 rng = vec2(0);\n    \n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = (fragCoord+rng)/iResolution.xy;\n        vec3 C = sample_image(uv);\n        C = pow(C, vec3(2.2));\n        col += C;\n    \n    }\n    \n    col /= s_f;\n    \n    // adjust for srgb color space\n    // rough approx\n    col = pow(col, vec3(1.0/2.2));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}