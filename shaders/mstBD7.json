{
    "Shader": {
        "info": {
            "date": "1697276897",
            "description": "Store noise in a 3D texture and sample it once!",
            "flags": 32,
            "hasliked": 0,
            "id": "mstBD7",
            "likes": 1,
            "name": "1 sample Bi-linear 3D noise tex",
            "published": 3,
            "tags": [
                "3d",
                "cloud",
                "texture",
                "volumetric"
            ],
            "usePreview": 0,
            "username": "El_Sargo",
            "viewed": 230
        },
        "renderpass": [
            {
                "code": "// Read 3D noise values with filtering and only one texture lookup!\n// This is achieved through spliting the buffer into slices\n// and storing three layers in each slice.\n// The red and alpha channels are shared across slice boundaries\n// to allow linear interpolation without a second lookup\n//\n// Noise code is from https://www.shadertoy.com/view/mtjfzW\n// which is what i'm hoping to imporve on.\n// \n// Change settings in common\nvoid mainImage( out vec4 O, in vec2 I ) {\n    vec2 uv = I/iResolution.y;\n    float horizontal_slices = floor( iResolution.x / SIZE );\n    #if 1\n    //uv *= 0.15;\n    vec3 p = vec3(uv.x,iTime*0.1,uv.y);\n    float V=0.,W=0.,s=1.,a=1.,k=0.;\n    float vs = 0.5;\n    int m = int(uv.x*3.)+1;\n    for (int i=0;i<m;i++){\n        if (uv.y < 1./3.) {\n            W += a*sample_tex(\n                p*s,\n                iChannel0,\n                horizontal_slices,\n                iResolution.xy\n            );\n            V += a;\n        } else if (uv.y < 2./3.){\n            V += a*t3x(iChannel1,p*s*vs).x;\n            W += a;\n        } else {\n                W += a*sample_tex(\n                p*s,\n                iChannel0,\n                horizontal_slices,\n                iResolution.xy\n            );\n            V += a*t3x(iChannel1,p*s*vs).x;\n        }\n        k+=a;s*=2.;a*=0.5;\n    }\n    O = vec4(sqrt( (V*(W))/k) );\n    #else\n    vec4 data = texture(iChannel0,uv);\n    //vec3 p = vec3(fc_to_slice_coord(I),0.);\n    //float v = PeriodicalCellularNoise(p,4.,vec3(1.));\n    O = vec4(sqrt(data.rrrr));\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 O, in vec2 I ) {\n    vec2 uv = I/iResolution.xy;\n    if (iFrame==0){\n        float horizontal_slices = floor( iResolution.x / SIZE );\n        float vertical_slices = floor( iResolution.y / SIZE );\n        vec2 slice_coord = fc_to_slice_coord(I);\n        slice_coord -= 1./SIZE;\n        slice_coord /= SIZE/(SIZE+2.0);\n        float slice_base_layer = id_to_slice_layer(fc_to_slice_id(I),horizontal_slices);\n        vec3 repetition = vec3(1.0);\n        float r = PeriodicalCellularNoise(\n            vec3(slice_coord,slice_base_layer),\n            SCALE,repetition\n         );\n        float g = PeriodicalCellularNoise(\n            vec3(slice_coord,slice_base_layer+1./SIZE),\n            SCALE,repetition\n         );\n        float b = PeriodicalCellularNoise(\n            vec3(slice_coord,slice_base_layer+2./SIZE),\n            SCALE,repetition\n         );\n         float a = PeriodicalCellularNoise(\n            vec3(slice_coord,slice_base_layer+3./SIZE),\n            SCALE,repetition\n         );\n            \n        O = vec4( r,g,b,a );\n        \n    } else {\n        O = texture(iChannel0,I/iResolution.xy);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define ACTUAL_SIZE 64.0\n#define SIZE (ACTUAL_SIZE+2.0)\n#define SCALE 10.\nvec2 layer_to_slice_id( float z_layer, float horizontal_slices ) {\n    z_layer = floor( z_layer / 3.0 );\n    float x_offset = mod( z_layer, horizontal_slices );\n    float y_offset = ( z_layer - x_offset ) / horizontal_slices;\n    return vec2( x_offset, y_offset );\n}\n\nfloat id_to_slice_layer( vec2 slice_id, float horizontal_slices ){\n    return ( slice_id.y * horizontal_slices + slice_id.x ) * 3. /SIZE ;\n}\n\nvec2 fc_to_slice_coord( vec2 fc ) {\n    return mod( fc, SIZE ) / SIZE;\n}\n\nvec4 t3x( sampler3D sam, vec3 uv ) {\n    float textureResolution = float(textureSize(sam,0).x);\n    uv = uv*textureResolution + 0.5;\n    vec3 iuv = floor( uv );\n    vec3 fuv = fract( uv );\n    uv = iuv + fuv*fuv*(3.0-2.0*fuv);\n    uv = (uv - 0.5)/textureResolution;\n    return texture( sam, uv );\n}\n\nvec2 fc_to_slice_id( vec2 fc ) {\n    return ( fc - mod( fc, SIZE ) ) / SIZE;\n}\n\nfloat sample_tex( vec3 p, sampler2D sam, float horizontal_slices, vec2 res) {\n    vec3 s = mod( p, 1.0 );\n    float z = s.y * SIZE;\n    vec2 w = fwidth(p.xz)*2.;\n    s.xz *= SIZE/(SIZE+2.0);\n    s.xz += 1./SIZE;\n    \n    float blend = mod( z, 3.0 );\n    int blend_id = int( blend );\n    float blend_factor = fract( blend );\n    vec2 id = layer_to_slice_id( z, horizontal_slices );\n    vec2 fc = ( id + s.xz ) * SIZE;\n    vec2 uv = fc / res;\n    vec4 data = texture(sam, uv);\n    float a,b;\n    if ( blend_id == 0 ) {\n        a = data.r;\n        b = data.g;\n    } else if ( blend_id == 1 ) {\n        a = data.g;\n        b = data.b;\n        \n    } else if ( blend_id == 2 ) {\n        a = data.b;\n        b = data.a;\n    }\n    return mix(a,b,blend_factor);\n}\n\n/////////////////////////////////////////////////////////\n// Noise                                               //\n/////////////////////////////////////////////////////////\n\n\n#define wrap(x, _min, _max) (_min + mod(_max - _min + mod(x - _min, _max - _min), _max - _min))\n\nfloat Repeat(float t, float len)\n{\n    //return wrap(t, 0., len);\n    return clamp(t - floor(t / len) * len, 0., len);\n}\nvec2 Repeat(vec2 t, vec2 size)\n{\n    return vec2(Repeat(t.x, size.x), Repeat(t.y, size.y));\n}\n\nvec3 Repeat(vec3 t, vec3 size)\n{\n    return vec3(\n        Repeat(t.x, size.x),\n        Repeat(t.y, size.y),\n        Repeat(t.z, size.z)\n    );\n}\n\n// RNG\nuint WangHash(uint n)\n{\n    // https://gist.github.com/badboy/6267743#hash-function-construction-principles\n    // Wang hash: this has the property that none of the outputs will\n    // collide with each other, which is important for the purposes of\n    // seeding a random number generator.  This was verified empirically\n    // by checking all 2^32 uints.\n    n = (n ^ 61u) ^ (n >> 16);\n    n *= 9u;\n    n = n ^ (n >> 4);\n    n *= 0x27d4eb2du;\n    n = n ^ (n >> 15);\n\n    return n;\n}\n\nuint NextState(uint state)\n{\n    state ^= state << 13;\n    state ^= state >> 17;\n    state ^= state << 5;\n    return state;\n}\n\nfloat NextFloat(inout uint state)\n{\n    state = NextState(state);\n    int n = int(state % 1000u);\n    float t = float(n) / 1000.;   \n    return t;\n}\n\nvec3 NextVec3(inout uint state)\n{\n    float x = NextFloat(state);\n    float y = NextFloat(state);\n    float z = NextFloat(state);\n\n    return vec3(x, y, z);\n}\n\n\n//Convert functions based on https://www.shadertoy.com/view/XddXW7\n\nfloat Convert2DTo1D(vec2 p, vec2 s) \n{\n    //p = Repeat(p, s);\n    p = mod(p, s);\n    return floor(p.y) * s.x + p.x;\n}\n\nvec2 Convert1DTo2D(float p, vec2 size)\n{\n    float x = mod(p, size.x);\n    float y = (p - x) / size.x + 0.5;\n    return vec2(x, y);\n}\n\nfloat Convert3DTo1D(vec3 p, vec3 size)\n{\n    //p = Repeat(p, size);\n    p = mod(p, size);\n    return floor(p.z) * size.x * size.y + floor(p.y) * size.x + p.x;\n}\n\nvec3 Convert1DTo3D(float p, vec3 size)\n{\n    float x = mod(p, size.x);\n    float y = mod((p - x) / size.x, size.y);\n    float z = (p - x - floor(y) * size.x) / (size.x * size.y);\n    return vec3(x, y + 0.5, z + 0.5);\n}\n\n\n//\nfloat PeriodicalCellularNoise(vec3 p, float scale, vec3 size)\n{\n    p *= scale;\n    vec3 mainCell = floor(p);\n\n    float minDist = 999999.;\n\n    for (int x = -1; x <= 1; x++)\n    for (int y = -1; y <= 1; y++)\n    for (int z = -1; z <= 1; z++)\n    {\n        vec3 cellIndex = mainCell + vec3(x, y, z);\n        \n        vec3 repeatCellIndex = Repeat(cellIndex, size * scale);\n        uint seed = uint(137. + repeatCellIndex.x * 11. + repeatCellIndex.y * 17. + repeatCellIndex.z * 13.);\n        uint state = WangHash(seed);\n        \n        vec3 cellPoint = cellIndex + NextVec3(state);\n        vec3 diff = p - cellPoint;\n        float dist = dot(diff,diff);\n        minDist = min(minDist, dist);\n    }\n\n    return exp(-4.0*minDist);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}