{
    "Shader": {
        "info": {
            "date": "1675348037",
            "description": "Try some tiling techniques",
            "flags": 0,
            "hasliked": 0,
            "id": "DlXSRs",
            "likes": 18,
            "name": "SimplexTiledSierpinski",
            "published": 3,
            "tags": [
                "fractal",
                "simplex",
                "tiling",
                "sierpinski"
            ],
            "usePreview": 0,
            "username": "EvilRyu",
            "viewed": 247
        },
        "renderpass": [
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n#define sqrt3 1.732050808\n\nbool reverse = false;\nfloat rnd = 0.;\n\nfloat hash12(vec2 p)\n{\n    p = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n    return fract(p.x * p.y * 95.4337);\n}\n\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp(0.5 + 0.5 *(b - a) / k, 0.0, 1.0);\n\treturn mix(b, a, h) - k *h *(1.0 - h);\n}\n\n// distance to equilateral triangle\n// Equilateral triangle is defined by\n// max(-2y, y-x*sqrt3, y+x*sqrt3) = R\n// R is the circumradius\nfloat tri(vec2 p, float r)\n{\n    return abs(max(-2.*p.y, max(p.y-sqrt3*p.x, p.y+sqrt3*p.x))-r);\n}\n\nfloat noise(vec2 p)\n{\n    if(reverse) p.y = -p.y;\n    return abs(tri(p+.55*tri(p.yx*2., 0.5+.5*rnd), 0.1));\n}\n\nvec3 drawTri(vec2 p, float r)\n{    \n    return 1.-smoothstep(0.0, 0.015, abs(tri(p, r))-0.03 + 0.02 * noise(p)) * vec3(1.); \n}\n\nvec2 symm(float a, float b, float c, vec2 p)\n{\n    float x = ((b*b-a*a)*p.x-2.0*a*b*p.y-2.0*a*c) / (a*a+b*b);\n    float y = ((a*a-b*b)*p.y-2.0*a*b*p.x-2.0*b*c) / (a*a+b*b);\n    return vec2(x,y);\n}\n\n// distance of p to the line segment of p1, p2\nfloat distToEdge(vec2 p1, vec2 p2, vec2 p)\n{\n    vec2 d = p2 - p1;\n    vec2 v = vec2(1,-1);\n    return abs(dot(d.yx*v, p) + dot(d*v, p1.yx)) / length(d);\n}\n\nvec2 p0, p1, p2;\n\nfloat distToEdges(vec2 p)\n{\n    float d = distToEdge(p0, p2, p);\n    float d2 = distToEdge(p0, p1, p);\n    float d3 = distToEdge(p1, p2, p);\n    return smin(d,smin(d2,d3,.05),.05);\n}\n\n\n// use the distance to the edges as height, for calculating normal\nfloat height(vec2 p)\n{\n    float d = min(0.13, distToEdges(p));\n    return min(d, 0.03 * noise(p) + 0.1);\n}\n\nvec3 getNormal(vec2 p)\n{\n    vec2 eps=vec2(0.03,0.0);\n    vec3 n=vec3(height(p-eps.xy)-height(p+eps.xy),\n                height(p-eps.yx)-height(p+eps.yx),\n                2.0*eps.x);\n  \n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y;\n    //p*=1.2;\n    p.x += iTime * 0.1;\n    \n    // simplex tiling\n    vec2 i = floor(p + vec2(0.5*p.y, 0.)); \n    vec2 a = p - i + vec2(0.5*i.y, 0.); \n    \n    // check which triangle the current pixel is in\n    float m = step(a.y, 2. * a.x); \n    vec2 o = vec2(m, 1. - m);\n      \n    // the coord of the three vertices\n    p0 = vec2(0);\n    p1 = o - vec2(.5 * (1. - m), 0.);\n    p2 = vec2(.5, 1.);\n    \n    vec2 center = (p0 + p1 + p2) / 3.;\n    \n    p0 -= center;\n    p1 -= center;\n    p2 -= center;\n    a -= center;\n    \n    // min distance to the 3 edges of the triangle\n    float d = distToEdges(a);\n\n    vec3 col = vec3(1);\n    \n    reverse = m > 0.;\n    rnd = hash12(i);\n    \n    d = smoothstep(0., 0.1, d);\n    vec3 n = getNormal(a), ld = normalize(vec3(1.,1.,2.)); \n    \n    // shading\n    col *= 1.1*max(0., dot(n, ld)) * vec3(1., .8, 0.5) + \n            pow(max(0.0,dot(reflect(normalize(vec3(3,0,-1.)),n),ld)),32.);\n    col *= .5 + .5 * cos(6.28318 * (vec3(6) * d + vec3(0.23,0.2,0.15)));\n    \n    // darken the edge between triangles\n    col *= smoothstep(.0,0.1,d);\n\n\n    // drawing the sierpinski\n    if(reverse) a.y = -a.y;\n\n    p = a*vec2(2.5, 2.2) * 1.35;\n    float s=1.0;\n\n    float iter = mod(floor(iTime),9.0);\n    for(int i = 0; i < 4; ++i)\n    {\n        if(i < int(iter+0.5))\n        {\n            s*=0.5;\n            col += drawTri(p,s) * .1;\n\n            if(p.y+sqrt3*p.x>s)// Bottom right triangle\n                p=symm(sqrt3/3., 1.0, 0., p);// Folding along y+1/3*x\n\n            if(p.y-sqrt3*p.x>s)// Bottom left triangle\n                p=symm(-sqrt3/3., 1.0, 0., p);// Folding along y-1/3*x\n\n            p.y+=s;\n        }\n        else\n        {\n            // The animation\n            float a=-2.0*fract(iTime);\n            col+=drawTri(vec2(p.x*cos(a)-p.y*sin(a), p.y*cos(a)+p.x*sin(a)),\n                     fract(iTime)*s*0.5) * .05;\n        }\n    }\n    col*=pow(16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1);\n    fragColor.xyz = col;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}