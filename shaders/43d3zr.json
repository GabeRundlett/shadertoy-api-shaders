{
    "Shader": {
        "info": {
            "date": "1716009832",
            "description": "Decided I'd experiment with some fractals. This uses ray casting, so it's kinda real 3D? I haven't really looked at other fractal shaders, so if my logic seems incomprehensible that's why.",
            "flags": 0,
            "hasliked": 0,
            "id": "43d3zr",
            "likes": 6,
            "name": "Fractal Hallways",
            "published": 3,
            "tags": [
                "3d",
                "fractal"
            ],
            "usePreview": 0,
            "username": "triggthediscovery",
            "viewed": 139
        },
        "renderpass": [
            {
                "code": "// A Fractal shader.\n// Use if you want, CC0? Is that legal? Provided under CC0 license. \n\n// This checks for an intersection in a single axis, since\n// all axis share that behavior.\n//\n// The behavior is nonstandard. it returns the color if there's\n// a hit, but the coordinates for the next level if it's a miss.\n// This is communicated with the w component, which is the distance\n// but is posiitve on hit and negative on miss. \nvec4 cast_ray_1d(vec3 vector_pos, vec3 vector_dir, int mdim, int dim2, int dim3) {\n    float closest_wall = 1000.0;\n    vec3 norm = vec3(0);\n    bool flip = false;\n    \n    // Flipping the direction if negative simplifies this code.\n    if (vector_dir[mdim] < 0.0) {\n        vector_dir *= -1.0;\n        vector_pos *= -1.0;\n        flip = true;\n    }\n    \n    if (vector_pos[mdim] < 1.0) {\n        float dist_n = (1.0 - vector_pos[mdim])/vector_dir[mdim];\n        \n        vec3 hit_pos = vector_pos + (vector_dir * dist_n);\n        \n        if (abs(hit_pos[dim2])<=1.0 && abs(hit_pos[dim3])<=1.0) {\n            float dist = distance(hit_pos, vector_pos);\n            \n            if (dist < closest_wall) {\n                closest_wall = dist;\n                norm[mdim] = 0.5;\n                \n                // Check if a hit.\n                if (abs(hit_pos[dim2])<=0.5 && abs(hit_pos[dim3])<=0.5) {\n                    // This is a miss, so you calculate the location of \n                    // the ray for the next iteration.\n                    if (flip) {\n                        hit_pos *= -1.0;\n                    }\n                    norm = vec3(hit_pos)*2.0;\n                    norm[mdim] = -1.0;\n                    if (flip) {\n                        norm[mdim] = 1.0;\n                    }\n                    return vec4(norm, -closest_wall);\n                } else {\n                    // Color the sides to imply some lighting.\n                    if (mdim == 0) {\n                        norm = vec3(0.4);\n                    } else if (mdim == 1) {\n                        norm = vec3(0.5);\n                    } else if (mdim == 2) {\n                        norm = vec3(0.6);\n                    }\n                    \n                    // This is to add a border for looks.\n                    if ((abs(hit_pos[dim2])<=0.6 && abs(hit_pos[dim3])<=0.6) ||\n                        (abs(hit_pos[dim2])>=0.9 || abs(hit_pos[dim3])>=0.9) ) {\n                        norm *= 0.8;\n                    }\n                }\n            }\n        }\n    }\n    \n    return vec4(norm, closest_wall);\n}\n\nvec3 cast_ray(vec3 vector_pos, vec3 vector_dir) {\n    vec4 ret = vec4(0); \n    float dist = 0.0;\n\n    // pseudo-recursive loop for the fractal.\n    for (int i=0; i<8; i++) {  \n        // Check each axis.\n        vec4 x_int = cast_ray_1d(vector_pos, vector_dir, 0, 1, 2); \n        vec4 y_int = cast_ray_1d(vector_pos, vector_dir, 1, 0, 2); \n        vec4 z_int = cast_ray_1d(vector_pos, vector_dir, 2, 0, 1); \n\n        // Find the closest hit. This works despite the potentially\n        // flipped x because it only flipps if it's a miss inside\n        // the wall, misses which miss the wall entirely are set\n        // to distance 1000.\n        if (x_int.w < y_int.w) {\n            if (x_int.w < z_int.w) { \n                ret = x_int; \n            } else { \n                ret = z_int; \n            } \n        } else { \n            if (y_int.w < z_int.w) { \n                ret = y_int; \n            } else { \n                ret = z_int; \n            } \n        } \n        \n        // This is for fog.\n        dist += pow(abs(ret.w/2.0),2.0);\n\n        if (ret.w < 0.0) { \n            vector_pos = ret.xyz;\n        } else {\n            // Apply fog if a hit.\n            return ret.xyz * (1.0-(dist/6.0));\n        }\n        \n    }\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.x -= 0.5;\n    uv.y -= 0.5;\n\n    // Direction of the ray.\n    vec3 in_vec_d = vec3(sin(iTime/5.0),0,cos(iTime/5.0));\n    \n    // Position of the ray, this has a modulo to simiulate\n    // infinite movement.\n    vec3 in_vec_p = vec3(0, 0, ((pow(mod(iTime*-0.3501, 1.0), (1.0+(in_vec_d.z/-5.0))) * 2.0)-1.0));\n\n    float fov = 1.0;\n    vec3 in_vec_d_hold = in_vec_d;\n\n    in_vec_d.x += (in_vec_d_hold.z*(uv.x*fov));\n    in_vec_d.z -= (in_vec_d_hold.x*(uv.x*fov));\n    \n    in_vec_d.y += uv.y*fov/1.8;\n\n    vec3 norm = cast_ray(in_vec_p, in_vec_d);\n\n    vec3 col = norm;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}