{
    "Shader": {
        "info": {
            "date": "1523563231",
            "description": "A visualizer of raymarched spheres. Inspired by https://www.shadertoy.com/view/Ms3SWr",
            "flags": 64,
            "hasliked": 0,
            "id": "ldKyWV",
            "likes": 3,
            "name": "Visualizer #1",
            "published": 3,
            "tags": [
                "raymarching",
                "sound",
                "sphere"
            ],
            "usePreview": 0,
            "username": "cwrawls",
            "viewed": 6720
        },
        "renderpass": [
            {
                "code": "/*\nInspired by Sound Blob : https://www.shadertoy.com/view/Ms3SWr\n*/\n//rotation & color\n#define TWOPI 6.28318530718\n#define PI \t3.14159265\n#define SPEED 0.05\n\n//ray marching\n#define MAX_STEPS 32.0\n#define EPSILON 0.002\n#define MIN_STEP_SIZE 0.001\n#define MIN_DISTANCE 0.0\n\n//modify to change number of spheres\n#define NumSpheres 6\n//modify to change spread of spheres\n#define MAX_ORBIT_DIST 1.0\n\n#define CAMZ -2.0\n\n\nvec3 getColor(float amt) {\n\tfloat colDeg = amt * TWOPI;\n    float x = 1.0 - abs(mod(colDeg/radians(60.0), 2.0) -1.0);\n    if(colDeg < radians(60.00)){return vec3(1.0,\tx, \t\t0.0);}\n    if(colDeg < radians(120.0)){return vec3(x,\t\t1.0, \t0.0);}\n    if(colDeg < radians(180.0)){return vec3(0.0, \t1.0, \tx);}\n    if(colDeg < radians(240.0)){return vec3(0.0, \tx, \t\t1.0);}\n    if(colDeg < radians(300.0)){return vec3(x, \t\t0.0, \t1.0);}\n    return vec3(1.0, 0.0, x);\n}\n\nmat2 rotate(float deg) {return mat2(cos(deg), sin(deg), -sin(deg), cos(deg));}\n\n//rotate about y-axis\nvec3 getRay(vec3 rayDir, float rot) {\n\trayDir = normalize(rayDir);\n    float cosVal = cos(rot);\n    float sinVal = sin(rot);    \n    return vec3((rayDir.x * cosVal) + (rayDir.z * sinVal), rayDir.y, (rayDir.z * cosVal) - (rayDir.x * sinVal));\n}\n\nfloat sdfSphere(vec3 center, vec3 pos, float rad) {\n\tfloat dist = length(center - pos) - rad;\n    \n    return dist;\n}\n\nfloat smin(float dist0, float dist1, float scaleFactor) {\n\tfloat mixVal = clamp(0.5 + 0.5 * (dist1 - dist0) / scaleFactor, 0.0, 1.0);\n    return mix(dist1, dist0, mixVal) - scaleFactor * mixVal * (1.0 - mixVal);\n}\n\nvec2 map(in vec3 pos, out float rad) {\n\n    \n    float minDist = 10000000.0;\n    float xStep = MAX_ORBIT_DIST / float(NumSpheres);\n    float maxRadius = (xStep * 2.0 / 2.0);\n    float zPos = 3.0;\n    float yPos = 0.0;\n    \n    float distFromCenter = length(pos.xy);\n    \n    //if(distFromCenter > MAX_ORBIT_DIST + maxRadius) {distFromCenter = MAX_ORBIT_DIST;}\n    \n    float sphereNum = distFromCenter / xStep;\n    \n    //optimizations, no loops, only calculate nearest 2 spheres\n    //distinct orbits should keep there from ever being 3 all in mutual contact\n    \n    //get the closest two spheres by radius from origin\n    float sphere0 = floor(sphereNum);\n    if(sphere0 > float(NumSpheres) ) {sphere0 = float(NumSpheres);}\n    float sphere1 = ceil(sphereNum);\n    if(sphere1 > float(NumSpheres) ) {sphere1 = float(NumSpheres);}\n    \n    //get relevant info about each sphere\n    float rotDir0 = mod(sphere0, 2.0);\n    float rotDeg0 = fract( (sphere0 + 1.0) * SPEED * iTime) * TWOPI;\n    mat2  rotAmt0 = rotate(rotDeg0);\n\tfloat sampX0  = sphere0 / float(NumSpheres);\n    float amp0    = texture(iChannel0, vec2(sampX0, 0.25)).x;\n    float xDist0   = sphere0 * xStep + 0.01;\n    if(rotDir0 == 1.0) {xDist0 = -xDist0;}\n    vec3 spherePos0 = vec3(vec2(0. + xDist0, yPos) * rotAmt0, zPos);\n    float rad0  = amp0 * pow(1.01,sphere0)* maxRadius + 0.01;\n    float dist0 = sdfSphere(spherePos0, pos, rad0);\n    \n    float rotDir1 = mod(sphere1, 2.0);\n    float rotDeg1 = fract( (sphere1 + 1.0) * SPEED * iTime) * TWOPI;\n    mat2  rotAmt1 = rotate(rotDeg1);\n\tfloat sampX1  = sphere1 / float(NumSpheres);\n    float amp1    = texture(iChannel0, vec2(sampX1, 0.25)).x;\n    float xDist1  = sphere1 * xStep + 0.01;\n    if(rotDir1 == 1.0) {xDist1 = -xDist1;}\n    vec3 spherePos1 = vec3(vec2(0. + xDist1, yPos) * rotAmt1, zPos);\n    float rad1 =  amp1 * pow(1.01,sphere1)* maxRadius + 0.01;\n    float dist1 = sdfSphere(spherePos1, pos, rad1);\n    \n    rad = rad0 / maxRadius;\n    \n    minDist = smin(minDist, dist0, 0.04);\n    \n    if(dist1 < minDist) {rad = rad1 / maxRadius;}\n    minDist = smin(minDist, dist1, 0.04);\n    \n    \n    /*\n    for(int i = 0; i < NumSpheres; i++) {\n        float rotDir = mod(float(i), 2.0);\n        float rotDeg =fract( (float(i) + 1.0) * SPEED * iTime) * TWOPI;\n        //rotDeg = rotDeg + (TWOPI / float(NumSpheres));\n        //if(rotDir == 1.0) {rotDeg = -rotDeg;}\n        mat2 rotAmt = rotate(rotDeg);\n        float xDist = float(i) * xStep + 0.01;\n        if(rotDir == 1.0) {xDist = -xDist;}\n        vec3 spherePos = vec3(vec2(0. + xDist, yPos) * rotAmt, zPos);\n\t\tfloat sampX = float(i) / float(NumSpheres);\n        float amp = texture(iChannel0, vec2(sampX, 0.25)).x;\n        float dist = sdfSphere(spherePos, pos, amp * pow(1.01,float(i))* maxRadius + 0.01);\n        if(dist < minDist) { rad = (amp * pow(1.01,float(i))* maxRadius + 0.01) / maxRadius;}\n        minDist = smin(minDist, dist, 0.04);\n    }\n    */\n    return vec2(1.0, minDist);\n}\n \nvec3 getNormal(vec3 pos, float epsilon) {\n    float rad = 0.0;\n\tvec3 e = vec3(epsilon, 0.0, 0.0);\n    vec3 normal = vec3(map(pos + e.xyy, rad).y - map(pos - e.xyy,rad).y,\n                       map(pos + e.yxy,rad).y - map(pos - e.yxy,rad).y,\n                       map(pos + e.yyx,rad).y - map(pos - e.yyx,rad).y);\n    return normalize(normal);\n}\n                       \nvec3 marchIt(vec3 origin, vec3 dir) {\n\n    float rad = 0.0;\n    float traveled = 0.0;\n    for(float i = 0.0; i < MAX_STEPS; i += 1.0) {\n        vec3 pos = origin + (dir * traveled);\n        vec2 result = map(pos, rad);\n        \n        if(traveled > MIN_DISTANCE && result.y < EPSILON) {\n\t\t\treturn vec3(traveled, i / MAX_STEPS, rad);\n        }\n        \n        traveled += max(MIN_STEP_SIZE, result.y);\n    }\n    \n    return vec3(0.0,1.0,0.0);\n}\n    \n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xx) -vec2( 0.5,0.5*iResolution.y/iResolution.x);\n\n    vec3 camPos = vec3(0.0, 0.0, CAMZ);\n    vec3 rayDir = normalize(vec3(uv, 1.0));\n       \n    vec3 result = marchIt(camPos, rayDir);\n    \n    vec3 col = vec3(0.0);\n    \n    if(result.x > 0.0) {\n        \n        vec3 surfPos = camPos + (rayDir * result.x);\n        vec3 normal = getNormal(surfPos, 0.001);\n        vec3 light = normalize(vec3(-1.0, 1.0, -0.5));\n        vec3 reflection = reflect(rayDir, normal);\n        float diffuse = dot(normal, light);\n        float specular = pow(clamp(dot(reflection, light), 0.0, 1.0), 20.0);\n        \n        col += vec3(specular * diffuse) * vec3(1.) + vec3(diffuse*0.4+0.6)* getColor(result.z);//vec3(0.9,0.5-(result.y)*0.5,(1.0/result.x)*0.1);\n    }\n                               \n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 14284,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/illeniumofficial/kaskade-disarm-you-illenium-remix-1"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}