{
    "Shader": {
        "info": {
            "date": "1711051990",
            "description": "an improved and simplified version of my old one\nControls:\nQ, E - Zoom\nWASD - Move the camera\nMouse + space - Show orbit tracking",
            "flags": 48,
            "hasliked": 0,
            "id": "4XSSDK",
            "likes": 1,
            "name": "Fork RR's Compl Rennen_Rig 924",
            "published": 3,
            "tags": [
                "fractal",
                "mandelbrot"
            ],
            "usePreview": 0,
            "username": "Rennen_Rig",
            "viewed": 162
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    bool vec_colouring = true;\n    \n    vec2 centerPos = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    float pixelOffset = texelFetch(iChannel0, ivec2(0, 0), 0).z;\n    vec2 startPos = (centerPos + ((2. * fragCoord) - iResolution.xy) * pixelOffset);\n    \n    //vec2 startPos = screen_corner_lerp(screen_pos_a, screen_pos_b, uv);\n    vec2 currentPos = startPos;\n    vec2 prevPos = currentPos;\n    vec2 offset_tracker = vec2(0.);\n    \n    //vec2 mouseStart = (centerPos + ((2. * iMouse.xy) - iResolution.xy) * pixelOffset);\n    vec2 mouseStart = texelFetch(iChannel0, ivec2(0, 1), 0).xy;\n    vec2 currentMouse = mouseStart;\n    vec2 prevMouse = mouseStart;\n    \n    float cutoff = 10000000.;\n    \n    //vec2 currentPos = vec2(0., 0.);\n    \n    vec2 mouse_uv = ((iMouse.xy / iResolution.xy) * 2. - vec2(1.)) * 3.;\n    \n    int iterations = 700;\n    int c = 0;\n    \n    int mouse_iterations = 150;\n    int m = 0;\n    \n    bool in_line = false;\n    float stroke = pixelOffset;\n    \n    bool render_line = false;\n    \n    if (render_line)\n    {\n        while (!in_line && ((m < mouse_iterations) && (m == 0 || (distance(currentMouse, prevMouse) < cutoff && currentMouse != prevMouse))))\n        {\n            prevMouse = currentMouse;\n            currentMouse = iterate(currentMouse, mouseStart, mouse_uv);\n            in_line = (sdCapsule(startPos, prevMouse, currentMouse, stroke) < 0.);\n            m++;\n        }\n    }\n    \n    if (in_line)\n    {\n        fragColor = vec4(vec3(1. - (float(m) / float(mouse_iterations))) , 1.);\n    }\n    else\n    {\n        while ((c < iterations) && (c == 0 || (distance(currentPos, prevPos) < cutoff && currentPos != prevPos)))\n        {\n            prevPos = currentPos;\n            currentPos = iterate(currentPos, startPos, mouse_uv);\n            offset_tracker += normalize(currentPos - prevPos);\n            c++;\n        }\n\n        vec3 col;\n\n        bool outside_set = (distance(currentPos, prevPos) < cutoff);\n        \n        \n        if (vec_colouring) {\n        \n            //col = hsv2rgb(vec3(get_angle(currentPos - prevPos), 1. , 1.));\n            //col = hsv2rgb(final_pos_to_hsv((currentPos - startPos)));\n            //col = hsv2rgb(vec3(get_angle((startPos - currentPos)), 1. , 1.));\n            //col = hsv2rgb(final_pos_to_hsv(currentPos - prevPos));\n            \n            //col = final_pos_t(currentPos - prevPos);\n            col = hsv2rgb(final_pos_to_hsv(normalize(offset_tracker)));\n            \n            //col = vec3(abs(normalize(currentPos - prevPos)), .4 / length(currentPos - prevPos));\n            //if (length(currentPos - prevPos) == 0.) col.z = 1.;\n        }\n        \n        \n        \n        else {\n        \n            if (outside_set)\n            {\n                //col = normalize(hsv2rgb(vec3(vec2_to_fractangle(currentPos - startPos), 1., 1.)));\n                col = vec3(0.);\n            }\n            else\n            {\n                col = normalize(hsv2rgb(vec3(log(float(c)) , 1. , 1.)));\n            }\n        }\n\n\n\n\n        // Output to screen\n        //fragColor = vec4(pow(3., 1./3.) * normalize(col),1.0);\n        \n        fragColor = vec4(col, float(outside_set));\n        \n        //fragColor = vec4(vec3((col.x * col.y * col.z)), float(outside_set));\n        //fragColor = vec4(vec3(atan(4. * atan(.05 * col.z))), float(outside_set));\n        //fragColor *= vec4(final_pos_t(currentPos - prevPos) , 1.);\n        \n        //fragColor *= fragColor.w;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define TWO_PI 6.283185307\n#define PI 3.1415926535\n\n\n\nvec2 Exp(vec2 a)\n{\n    return exp(a.x)*vec2(cos(a.y),sin(a.y));\n}\nvec2 Log(vec2 a)\n{\n    return vec2(log(dot(a,a))/2.0,atan(a.y,a.x));\n}\n\n\n\nvec2 complexMul(in vec2 a, in vec2 b)\n{\n    return vec2(((a.x*b.x)-(a.y*b.y)),((a.x*b.y)+(a.y*b.x)));\n}\n\n\nvec2 complexSquare(in vec2 a)\n{\n    return complexMul(a,a);\n}\n\n\nvec2 complex_divide(in vec2 a, in vec2 b)\n{\n    return vec2((a.x * b.x + a.y * b.y) / (b.x * b.x + b.y * b.y),\n        (a.y * b.x - a.x * b.y) / (b.x * b.x + b.y * b.y));\n}\n\n\nvec2 complex_int_power(in vec2 a, in int p)\n{\n    vec2 current = vec2(1., 0.);\n    if (p > 0)\n    {\n        for (int i = 0; i < p; i++)\n        {\n            current = complexMul(current,a);\n        }\n    }\n    else if (p < 0)\n    {\n        for (int i = 0; i < abs(p); i++)\n        {\n            current = complex_divide(current,a);\n        }\n    }\n    return current;\n}\n\n\n\n\nvec2 iterate(in vec2 a, in vec2 b, vec2 c)\n{\n    //return complex_int_power(a,2) + vec2(-0.6, -0.42);\n    //return complex_int_power(a * log2((b)), 5) + (b);\n    //return complex_int_power(abs(a), 2) - b;\n    \n    //return a - complex_int_power(a,6) - complex_int_power(a, 9) + complex_int_power(a, 3) - complex_int_power(a, 7) - complex_int_power(a, 5);\n    //return complex_int_power(a,3)/b - b; // this one is an angel\n    \n    //return complex_int_power(a, 2) + vec2(-.74, -.125); // + vec2(-.74, -.125) // vec2(.25, -.499);\n    //return complex_int_power(a, -4) + complex_int_power(a,2) + b; //+ vec2(-2., .1);\n    //return 10.1 * complex_divide(a, b) + .01 * complex_int_power(a, -1);\n    //return Exp(complex_divide(Log(2.*b),vec2(3.0, 0.)));\n\n    //return complex_int_power(a, -2) + complex_divide(a, b);// + b;\n    //return complex_int_power(a, -1) + complex_divide(a, b) + vec2(-15.23, 4.1);\n    \n    //return complex_int_power(a,2) + vec2(-0.7, 0.28);\n    \n    return complex_int_power(a, -3) + b;\n    \n    //return complex_int_power(a, -1) + 1.1 * complex_int_power(a, 1) + (vec2(.31, .547) * c);\n}\n\n\n\n\nvec3 hsv2rgb( in vec3 a )\n{\n    vec3 c = vec3(a.x, min(a.y , 1.) , a.z);\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nfloat vec2_to_fractangle(in vec2 v)\n{\n    return (atan(-v.x, -v.y) / TWO_PI) + 0.5;\n}\n\n\nfloat sdCapsule( vec2 p, vec2 a, vec2 b, float r )\n{\n  vec2 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n\nfloat get_angle(in vec2 v) {\n    return atan(v.x,v.y) / TWO_PI;\n}\n\n\nvec2 lerp_vec2(in vec2 a, in vec2 b, in float c) {\n    float p = clamp(c, 0., 1.);\n    return (1. - p) * a + p * b;\n}\n\n\n/*\nvec3 final_pos_to_hsv(in vec2 pos)\n{\n    return vec3(fract(1. * get_angle(pos)), 1. ,0.5 + 0.5 * sign(5. - log(length(pos))));\n}\n*/\n\n\nvec3 final_pos_to_hsv(in vec2 pos)\n{\n    return vec3(fract(4. * get_angle(pos)), 1. ,1);\n}\n\n\nvec3 final_pos_t(in vec2 pos) {\n/*\n    if (length(pos) > 10.) {\n        //return hsv2rgb(vec3(.1 * (log2(length(pos))), 1., 1.));\n        return vec3(0.);\n    }\n*/\n    int c = int(floor(abs(mod((6. * fract(1. * get_angle(pos))) - 3., 6.) - 3.)));\n    \n    \n    \n    switch (c) {\n        case 0: return vec3(0.357,0.808,0.98);\n        case 1: return vec3(0.961,0.663,0.722);\n        case 2: return vec3(1., 1., 1.);\n        default: return vec3(1., 0., 0.);\n    }\n\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iPos = ivec2(fragCoord);\n    if (iPos == ivec2(0, 0))\n    {\n        if (iFrame < 5)\n        {\n            fragColor = vec4(0., 0., 0.003, 1.);  //vec4(-1.169, 0., 0.0001, 1.);\n        }\n        else\n        {\n            fragColor = texelFetch(iChannel0, iPos, 0);\n            fragColor += 20. * fragColor.z * vec4(texelFetch( iChannel3, ivec2(68,0),0 ).x\n            - texelFetch( iChannel3, ivec2(65,0),0 ).x,\n            texelFetch( iChannel3, ivec2(87,0),0 ).x\n            - texelFetch( iChannel3, ivec2(83,0),0 ).x,\n            0., 0.);\n\n            fragColor.z *= (texelFetch( iChannel3, ivec2(81,0),0 ).x\n            - texelFetch( iChannel3, ivec2(69,0),0 ).x) * .05 + 1.;\n        }\n    }\n    \n    else if (iPos == ivec2(0, 1))\n    {\n        if (texelFetch(iChannel3, ivec2(32, 0), 0).x == 1.)\n        {\n            fragColor = vec4(texelFetch(iChannel0, ivec2(0, 0), 0).xy + ((2. * iMouse.xy) - iResolution.xy) * texelFetch(iChannel0, ivec2(0, 0), 0).z,0., 1.);\n        }\n        else\n        {\n            fragColor = texelFetch(iChannel0, iPos, 0);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}