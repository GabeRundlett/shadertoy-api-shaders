{
    "Shader": {
        "info": {
            "date": "1460343804",
            "description": "Creating a Voronoi feel with minimal instructions by way of a tileable cellular texture.",
            "flags": 0,
            "hasliked": 0,
            "id": "4scXz2",
            "likes": 38,
            "name": "Cellular Tiling",
            "published": 3,
            "tags": [
                "2d",
                "voronoi",
                "cellular",
                "cell",
                "tile",
                "bio"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 3141
        },
        "renderpass": [
            {
                "code": "/*\n\n\tCellular Tiling\n\t---------------\n\n    Creating a Voronoi feel with minimal instructions by way of a tileable texture constructed \n\tvia a simplistic cellular pattern algorithm... That description was a bit verbose, but the \n\tmethod is really easy to understand. This is the 2D version, but I have a simple 3D example \n\tthat I'll put up pretty soon.\n\n\tThere's an old texture generation routine that involves drawing a bunch of random gradient \n\tcircles (or other shapes) onto a texture using the darken (min(src, dst)) blend. The result \n\tis a cellular looking texture reminiscent of Voronoi, which is hardly surprising, given the\n\tsimilar methods of construction.\n\n\tBy applying various colors, shapes and sizes, you can make some really cool looking images, \n\tbut it's not particularly suitable for realtime generative purposes, due to the fact that \n\tyou need to draw a lot of shapes (normally circles) to cover the area, etc.\n\n\tAnyway, I figured I could cheapen the process by doing it in repeatable tile form, since a\n\tsmaller area requires fewer circles for coverage, etc. I had the idea after working with \n\tTruchet tiles. It worked pretty well, so then I got to wondering how few operations I could \n\tget away with without it looking too repetitive. As it turns out, very few. In fact, it can \n\tbe a particularly cheap process.\n\n\tNaturally, there are a few restrictions. The obvious one is that small repeatable tiles look \n\tvery repetitive when you zoom out, so that has to be considered. The upside was the entire\n    point of doing this, which is that it requires virtually no extra effort to produce 3D tiles. \n\tThat means quasi 3D celluar surfaces that are fast enough to include in a distance \n\tfunction... under certain restrictions, of course.\n\n\tThe code in this particular example comprises mostly bumping and lighting, which I added out \n\tof sheer boredom, so you'll probably only want to look it if you're equally bored. :) The \n\t\"cellTex\" routine and the accompanying \"drawShape\" function are all that are required, for \n\tanyone interested. Both\tcontain just a few self explanatory lines.\n    \n    \n    \n    Related Examples:\n    \n    \n    // A 3D application.\n    3D Cellular Tiling - Shane\n    https://www.shadertoy.com/view/ld3Szs\n    \n    // Taking minimal instructions to the extreme. :)\n    One Tweet Cellular Pattern - Shane\n    https://www.shadertoy.com/view/MdKXDD\n\n*/\n\n// Layer rotation: For the cost of an extra 2x2 matrix by vec2 multiply, you can drastically \n// increase the randomness. I came up with this when experimenting. The idea can be extended\n// to the 3D version as well.\n#define LAYER_ROTATION\n\n\n// This is a rewrite of IQ's original. It's self contained, which makes it much\n// easier to copy and paste. I've also tried my best to minimize the amount of \n// operations to lessen the work the GPU has to do, but I think there's room for\n// improvement.\n//\nfloat noise3D(vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(1, 113, 57);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\n////////\n\n// The cellular tile routine. Draw a few gradient shapes (eight circles, in this case) using \n// the darken (min(src, dst)) blend at various locations on a tile. Make the tile wrappable by \n// ensuring the shapes wrap around the edges. That's it.\n//\n// Believe it or not, you can get away with as few as four circles. Of course, there is 4-tap \n// Voronoi, which has the benefit of scalability, and so forth, but if you sum the total \n// instruction count here, you'll see that it's lower overall. Not requiring a hash function\n// provides the biggest benefit, but there is also less setup.\n// \n// However, the main reason you'd bother in the first place is the ability to extrapolate\n// to a 3D setting (swap circles for spheres) for virtually no extra cost. The result isn't\n// perfect, but 3D cellular tiles can enable you to put a Voronoi looking surface layer on a \n// lot of 3D objects for little cost. In fact, it's fast enough to raymarch.\n//\nfloat drawShape(in vec2 p){\n    \n    // Wrappable circle distance. The squared distance, to be more precise.\n    p = fract(p) - .5;    \n    return dot(p, p);\n    \n    // Other distance metrics.\n    \n    //p = abs(fract(p) - .5);\n    //p = pow(p, vec2(8));\n    //return pow(p.x+p.y, .125)*.25;\n    \n    //p = abs(fract(p) - .5);\n    //p *= p;\n    //return max(p.x, p.y);\n    \n    //p = fract(p) - .5;\n    //float n = max(abs(p.x)*.866 + p.y*.5, -p.y);\n    //return n*n;\n    \n}\n\n// Draw some cirlcles on a repeatable tile. The offsets were partly based on science, but\n// for the most part, you could choose any combinations you want.\n//\nfloat cellTex(in vec2 p){   \n    \n \n    float c = .25; // Set the maximum, bearing in mind that it is multiplied by 4.\n    \n    // Draw four overlapping shapes (circles, in this case) using the darken blend \n    // at various positions on the tile.\n    c = min(c, drawShape(p - vec2(.80, .62)));\n    c = min(c, drawShape(p - vec2(.38, .20)));\n    \n    #ifdef LAYER_ROTATION\n    // Rotate the layer (coordinates) by 120 degrees. Layer rotation \n    // drastically improves randomness, for very little extra cost.\n    p = mat2(.5, -.866, .866, .5)*(p - .5); // \n    #endif\n    \n    c = min(c, drawShape(p - vec2(.60, .24)));\n    c = min(c, drawShape(p - vec2(.18, .82)));\n\n\n    // Draw four smaller circles at various positions on the tile.\n    // By the way, when using rotation, decreasing the size is optional.\n    p *= 1.4142;  \n    //p = p.yx; // Extra option, or addition.\n    \n    \n    c = min(c, drawShape(p - vec2(.46, .30)));\n    c = min(c, drawShape(p - vec2(.04, .88))); \n\n    #ifdef LAYER_ROTATION\n    // Rotate the layer (coordinates) by 120 degrees. \n    p = mat2(.5, -.866, .866, .5)*(p - .5);\n    #endif\n    \n    // More shapes produce a more convincing pattern, but you could cut\n    // these two out and still produce a decent image.\n    c = min(c, drawShape(p - vec2(.06, .54)));\n    c = min(c, drawShape(p - vec2(.64, .12)));  \n    \n    return sqrt(c*4.);\n    \n}\n///////////\n\n// Colored cellular texture.\n//\nvec3 tex2D(vec2 p){\n    \n    float c = cellTex(p*2.)*.95 + .05;\n\tvec3 col = vec3(c*c*.7, c, c*c*.2) + (cellTex(p*6.))*.05 - .025; // Bio green.\n    //vec3 col = vec3(c*c, c*sqrt(c), c) + (cellTex(p*3.))*.05 - .025; // Blueish.\n    col = clamp(col, 0., 1.);\n    // Sinusoidally mixing in a complimentary color, of sorts, for a bit of variance.\n    return mix(col, col.yzx, dot(sin(p*12. - sin(p.yx*12. + c*6.283)), vec2(.5))*.15 + .2);\n    \n}\n\n// Bump mapping function. Put whatever you want here. In this case, we're returning \n// some combined cellular texture values that coincide with the texture value above.\n//\nfloat bumpFunc(vec2 p){ \n\n    \n\treturn cellTex(p*2.)*.95 + (cellTex(p*6.))*.05; // Range: [0, 1]\n\t\n    // Grayscale version of the colored function.\n\t//return dot(tex2D(p), vec3(.299, .587, .114)); // Range: [0, 1]\n\n\n}\n\n// Standard bump function.\n//\nvec3 bump(vec3 sp, vec3 sn, float bumpFactor){\n    \n    // BUMP MAPPING - PERTURBING THE NORMAL\n    //\n    // Setting up the bump mapping variables. Normally, you'd amalgamate a lot of the following,\n    // and roll it into a single function, but I wanted to show the workings.\n    //\n    // f - Function value\n    // fx - Change in \"f\" in in the X-direction.\n    // fy - Change in \"f\" in in the Y-direction.\n    vec2 eps = vec2(4./iResolution.y, 0.);\n    \n    float f = bumpFunc(sp.xy); // Sample value multiplied by the amplitude.\n    float fx = bumpFunc(sp.xy-eps.xy); // Same for the nearby sample in the X-direction.\n    float fy = bumpFunc(sp.xy-eps.yx); // Same for the nearby sample in the Y-direction.\n   \n \t\n    \n    // Using the above to determine the dx and dy function gradients.\n    fx = (fx-f)/eps.x; // Change in X\n    fy = (fy-f)/eps.x; // Change in Y.\n    // Using the gradient vector, \"vec3(fx, fy, 0),\" to perturb the XY plane normal \",vec3(0, 0, -1).\"\n    // By the way, there's a redundant step I'm skipping in this particular case, on account of the \n    // normal only having a Z-component. Normally, though, you'd need the commented stuff below.\n    //vec3 grad = vec3(fx, fy, 0);\n    //grad -= sn*dot(sn, grad);\n    //sn = normalize( sn + grad*bumpFactor ); \n    sn = normalize( sn + vec3(fx, fy, 0)*bumpFactor ); \n    \n    return sn;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;  \n    \n    // uv *= iResolution.y/450.; // Maintaining cellular size.\n\n    // VECTOR SETUP - surface postion, ray origin, unit direction vector, and light postion.\n    //\n    // Setup: I find 2D bump mapping more intuitive to pretend I'm raytracing, then lighting a \n    // bump mapped plane. \n    vec3 ro = vec3(vec2(iTime*.2, sin(iTime*.025)*2.), -1);\n    vec3 sp = vec3(uv + ro.xy, 0.); // Surface posion. Hit point, if you prefer.\n    vec3 rd = normalize(sp - ro); // Unit direction vector. From the origin to the screen plane.\n    vec3 lp = ro + vec3(cos(iTime)*.66, sin(iTime)*.33, -1); // Light position - Back from the screen.\n\tvec3 sn = vec3(0, 0, -1); // Plane normal. Z pointing toward the viewer.\n     \n  \n    // Bump mapping. Perturbing the normal.\n    sn = bump(sp, sn, .05);\n    \n    // LIGHTING\n    //\n\t// Determine the light direction vector, calculate its distance, then normalize it.\n\tvec3 ld = lp - sp;\n\tfloat lDist = max(length(ld), 0.001);\n\tld /= lDist;\n\n    // Light attenuation.    \n    float atten = min(1./(.75 + lDist*0.15 + lDist*lDist*0.05), 1.);\n\t//float atten = min(1./(lDist*lDist*1.), 1.);\n\n\t\n\n\t// Diffuse value.\n\tfloat diff = max(dot(sn, ld), 0.);  \n    // Enhancing the diffuse value a bit. Made up.\n    //diff = pow(diff, 2.)*0.66 + pow(diff, 4.)*0.34; \n    // Specular highlighting.\n    float spec = pow(max(dot( reflect(-ld, sn), -rd), 0.), 64.);\n    //float fre = clamp(dot(sn, rd) + 1., .0, 1.); // Fake fresnel, for the glow.\n\n    \n\t\n    // TEXTURE COLOR\n    //\n\t// Using the position to index into the texture.\n    vec3 texCol = tex2D(sp.xy);\n    \n    \n    \n    // Applying some unrealistic refraction.\n    vec3 ref = sp + refract(rd, sn, 1./1.425)*.15;\n    float b = bumpFunc(ref.xy);\n    ref = vec3(.5, .05, .1)*b;\n    \n    // Equally unrealistic, cloudy reflection. Just for fun. Not important.\n    vec3 rfl = sp + reflect(rd, sn)*2.;\n    b = noise3D(rfl)*.66 + noise3D(rfl*2.)*.34;\n    b = smoothstep(.3, 1., b);\n    ref += mix(vec3(.125, .2, .25), vec3(1, .8, 1), b*b)*.25;\n    ref *= ref;\n\n\n\n\n    \n    // FINAL COLOR\n    // Using the values above to produce the final color.   \n    vec3 col = texCol*(diff + .5) + ref +  texCol.zxy*spec*.5;// + vec3(.5, .8, 1)*fre*fre*2.;\n    col *= atten;\n    \n    \n    // Apply a vignette. The point light already does this, but this sets off the\n    // edges a little more.\n    //uv = fragCoord/iResolution.xy; \n    //col *= pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) , .125/2.);\n\n    // Done. \n\tfragColor = vec4(sqrt(max(col, 0.)), 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}