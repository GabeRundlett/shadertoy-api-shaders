{
    "Shader": {
        "info": {
            "date": "1701675850",
            "description": "rewrote some older code that turns 3D raytraced scenes into anamorphic illusion from scratch\n// using this as a late excuse for Genuary Day 26 \"Perspective\" submission",
            "flags": 0,
            "hasliked": 0,
            "id": "7dSyWm",
            "likes": 6,
            "name": "Anamorphic Illusion cmarangu",
            "published": 3,
            "tags": [
                "illusion",
                "perspective",
                "anamorphic"
            ],
            "usePreview": 0,
            "username": "cmarangu",
            "viewed": 354
        },
        "renderpass": [
            {
                "code": "// 2023 12 04 2:44am ET Note: I made this code in Spring 2022.\n// I'm just setting this to un- unlisted today.\n//\n// Title: Anamorphic Illusion WIP\n// Started: 2022 January 29th\n// Tags: anamorphic, perspective, illusion\n// Description: rewrote some older code that turns 3D raytraced scenes into anamorphic illusion from scratch\n// using this as a late excuse for Genuary Day 26 \"Perspective\" submission\n\n//\n// universal constants\n// (I know 300+ digits PI)\n//\n#define PI 3.14159265358979323846264\n#define TAU 6.283185307\n\n\n\n//\n// optional settings\n//\n#define cam_mouse 1\n#define cam_perspective 1\n\n//\n// more settings\n#define ana_w 5.\n#define ana_off vec3(20., 0., 0.)\n\n// 0 - webcam\n// 1 - scene with a little sphere\n#define scene 1\n\n\n//\n// cube map\n//\nvec3 sky_map (vec3 d) {\n    //return vec3(0.);\n    //return vec3(.0, .0, 100./255.);\n    //return vec3(0., 1., 0.);\n\t//\n    /*#if 0\n    d.y = -d.y;\n\tfloat phi = asin(d.y);\n\tfloat th = mod(atan(d.x, d.z)+TAU*9.+PI*.25*.05, TAU);\n\treturn texture(\n\t  iChannel2,\n\t  vec2(th/TAU, ( phi/(PI*.5) )*-.5+.5 )\n\t).rgb;\n    #endif*/\n    return texture(iChannel2, d).rgb;\n}\n\n\n\n//\n// inter_sky is used when no intersection with a shape exists\n//\nvec4 inter_sky = vec4(0., 0., 0., 1e6);\n\n\n//\n// ray intersection with sphere.\n//\nvec4 inter_sphere (vec3 p, vec3 d, float r) {\n    bool insideout = length(p) < r+.001;\n    //\n\tvec3 camp = p;\n\tfloat SDFp = length(p)-r;\n\tp += d*abs(SDFp)*.2;\n\tint hits = 0;\n\tfor (int mrch=0; mrch<260; ++mrch) {\n\t\tSDFp = length(p)-r;\n\t\tif (mrch > 5 && SDFp > 10.) {\n\t\t\tbreak;\n\t\t}\n\t\tif (abs(SDFp) < 1e-3) {\n\t\t\tif (insideout && hits < 1) {\n\t\t\t\thits++;\n\t\t\t\tp += d*SDFp;\n\t\t\t\tp += d*1e-2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn vec4(\n\t\t\t\t\tnormalize(p),\n\t\t\t\t\tlength(p-camp)//*sign(length(p-c)-r)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tp += d*abs(SDFp)*.99;\n\t}\n\treturn inter_sky;\n}\n\n\n//\n// Signed/Spherical Distance Function/Field for a plane. point p, plane normal n.\n//\n#define SDF_plane(p, n) ( dot(normalize(p), n)*length(p) )\n//\n// ray intersection with plane. ray origin p, ray direction d, plane normal n\n//\n#define inter_plane_short(p, d, n) (\\\n    dot(-n, d) > 1e-6 ? vec4(n, dot(-p, -n)/dot(-n, d)) : inter_sky\\\n)\nvec4 inter_plane (vec3 p, vec3 d, vec3 n) {\n    vec4 inter_plane1;\n    inter_plane1 = inter_plane_short(p, d, n);\n    if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n        return inter_plane1;\n    }\n    inter_plane1 = inter_plane_short(p, d, -n);\n    if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n        return inter_plane1;\n    }\n    return inter_sky;\n}\n\n//\n// ray intersection with weird quadrilateral thing\n//\nvec4 inter_squad (vec3 p, vec3 d, vec3 n) {\n    vec4 inter_current = inter_plane(p, d, n);\n    if (inter_current.w >= inter_sky.w) {\n        return inter_sky;\n    }\n    p += d*inter_current.w;\n    if (max(abs(p.x), abs(p.z)) >= ana_w && p.y >= 0.) {\n        return inter_sky;\n    }\n    return inter_current;\n}\n\n\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    //\n    // screen coordinates. For this one I am doing a \"splitscreen\"\n    //\n    // //\n    //\n    // The trick is to first make regular screen coordinates, with y from -1 to 1 and x scaled to aspect ratio\n    //\n    //\n    vec2 screen = (fragCoord - iResolution.xy/2.)/(iResolution.y/2.);\n    vec2 mouse  = (iMouse.xy - iResolution.xy/2.)/(iResolution.y/2.);\n    //\n    // then decide which \"screen_number\" we are in\n    //\n    int screen_number = 0;\n    if (screen.x > 0.) { screen_number = 1; }\n    //\n    // then center each mini screen's coordinates\n    //\n    if (screen_number == 0) {\n        screen.xy *= iResolution.y/(iResolution.x/2.);\n        screen.x += 1.;\n        mouse.xy *= iResolution.y/(iResolution.x/2.);\n        mouse.x += 1.;\n    }\n    else {\n        screen.xy *= iResolution.y/(iResolution.x/2.);\n        screen.x -= 1.;\n        mouse.xy *= iResolution.y/(iResolution.x/2.);\n        mouse.x -= 1.;\n    }\n    //\n    // set initial color to 0,0,0. Will add color for each intersection/reflection/refraction\n    //\n    fragColor = vec4(0., 0., 0., 1.);\n    //\n    // set the transparency of the screen to 100%\n    //\n    float shiny = 1.;\n    //\n    // set the initial ray origin p, direction d.\n    // rotate by angles theta and phi.\n    //\n    vec3 p; vec3 d; vec3 bestp;\n    float theta = 0.; float phi = 0.;\n    mat2 azimuth; mat2 zenith;\n    if (true) {\n        //\n        // camera ray origin/direction for the right-side screen\n        //\n        #if cam_perspective\n        p = vec3(screen.x, screen.y, 0.);\n        // subtract the point on the screen minus the viewer's head position to get the ray direction\n        d = normalize(p-vec3(0., 0., -2.));\n        //p = vec3(0.);\n        //d = normalize(vec3(screen.x, screen.y, 2.));\n        #else\n        // orthogonal camera\n        p = vec3(screen.x, screen.y, 0.)*14.;\n        d = normalize(vec3(0., 0., 1.));\n        #endif\n        //\n        // (optional) move the camera back from the center of the 3D scene\n        //\n        p += vec3(0., 0., -16.);\n        //\n        // (optional) rotate theta and phi based on mouse coords\n        //\n        #if cam_mouse\n        theta += mouse.x*PI;\n        phi   += mouse.y*PI;\n        #endif\n        //\n        // create the rotation matricies from the angles\n        //\n        azimuth = transpose(mat2(\n            cos(theta), cos(PI*.5+theta),\n            sin(theta), sin(PI*.5+theta)\n        ));\n        zenith = transpose(mat2(\n            cos(phi), cos(PI*.5+phi),\n            sin(phi), sin(PI*.5+phi)\n        ));\n        //\n        // appply rotation matricies to camera ray position and direction\n        //\n        p.yz = zenith*p.yz;\n        d.yz = zenith*d.yz;\n        p.xz = azimuth*p.xz;\n        d.xz = azimuth*d.xz;\n        //\n        // (optional) move the camera back and up from the center of the 3D scene\n        //\n        //p += vec3(0., 4., -3.);\n        //p += vec3(0., 1., -3.);\n        //\n        #if 0\n        //\n        // (optional) center the camera around both the square and the anamorphic portal\n        //\n        p *= 2.;\n        p.xy += ana_off.xz/2.;\n        //mouse *= 2.;\n        //mouse.xy += ana_off.xz/2.;\n        #elif 1\n        //\n        // (optional) center the camera around the anamorphic portal\n        //\n        p.xy += ana_off.xz;\n        //mouse.xy += ana_off.xz;\n        #endif\n    }\n    //\n    // store that as bestp, the point from which the illusion works best\n    // bestp will be used later, to compute the anamorphic illusion on both screens and to be the\n    // camera position on the right side screen\n    //\n    bestp = p;\n    if (screen_number == 0) {\n        //\n        // camera ray origin/direction for the left-side screen\n        //\n        //p = vec3(screen.x*6., 0., screen.y*6.);\n        //d = normalize(p-vec3(0., 2., 0.));\n        //p = vec3(0., 6.1, 0.);\n        p = vec3(0., ana_w+.01, 0.);\n        d = normalize(vec3(screen.x, -1., screen.y));\n        p += vec3(0., 0.001, 0.);\n        //p -= d*6.;\n        //\n        #if 1\n        //\n        // (optional) center the camera around both the square and the anamorphic portal\n        //\n        p *= 2.;\n        p.xy += ana_off.xz/2.;\n        p.y += 6.;\n        //mouse *= 2.;\n        //mouse.xy += ana_off.xz/2.;\n        #elif 1\n        //\n        // (optional) center the camera around the anamorphic portal\n        //\n        p.xy += ana_off.xz;\n        //mouse.xy += ana_off.xz;\n        #endif\n    }\n    //\n    // start the loop of reflections/refractions\n    //\n    for (float bounces=0.; bounces<30.; ++bounces) {\n    //for (float bounces=0.; bounces<3.; ++bounces) {\n        //\n        // if the last-hit object is effectively opaque, end the ray's journey\n        //\n        if (shiny < .1) { break; }\n        //\n        // inter_closest is the closest object. inter_current is the current checked object\n        //\n        vec4 inter_closest = inter_sky; vec4 inter_current;\n        #if scene == 1\n        inter_current = inter_sphere(p-vec3(0., 0., 0.), d, 1.);\n        if (inter_current.w < inter_closest.w) { inter_closest = inter_current; }\n        #endif\n        inter_current = inter_plane(p-vec3(0., 0., 0.), d, normalize(vec3(0., 1., 0.)) );\n        if (inter_current.w < inter_closest.w) { inter_closest = inter_current; }\n        #if scene == 0\n        inter_current = inter_squad(p-vec3(0., 0., 0.), d, normalize(ana_off-bestp) );\n        if (inter_current.w < inter_closest.w) { inter_closest = inter_current; }\n        #endif\n        //\n        // now shading\n        //\n        p += d*inter_closest.w;\n        if (inter_closest.w < inter_sky.w) {\n            if (abs(p.y) < .0001) {\n                //\n                // hits ground\n                //\n                if (max(abs(p.x-ana_off.x), abs(p.z-ana_off.z)) < ana_w) {\n                    //\n                    // hits anamorphic portal\n                    //\n                    /*if (screen_number == 1) {\n                        p.xyz -= ana_off.xyz;\n                        p -= d*30.;\n                    }*/\n                    d = normalize(p-bestp);\n                    p.xyz -= ana_off.xyz;\n                    p -= d*30.;\n                }\n                else if (max(abs(p.x), abs(p.z)) < ana_w) { \n                    //\n                    // hits ground inside normal scene\n                    //\n                    vec3 texcolor;\n                    texcolor = vec3(0.);\n                    //texcolor = vec3(0., 1., 1.);\n                    //texcolor = .1*vec3(0., 1., 1.);\n                    /*#define tiny .0001\n                    texcolor = mix(\n                      texcolor,\n                      vec3(1.)*mod(floor(p.x+tiny)+floor(p.y+tiny)+floor(p.z+tiny), 2.),\n                      .1\n                    );\n                    #undef tiny*/\n                    fragColor.rgb += shiny*texcolor;\n                    //\n                    // amount reflected/transmitted varies 0-1 based on how much is absorbed\n                    //\n                    //shiny *= .99;\n                    shiny *= 1.;\n                    //\n                    // update ray position based on surface properties\n                    //\n                    //d = reflect(d, inter_closest.xyz);\n                    p += d*1e-3;\n                }\n                else {\n                    //\n                    // hits ordinary plain\n                    // fake diffuse with texture map\n                    //\n                    vec3 texcolor;\n                    texcolor = vec3(0.);\n                    #define tiny .0001\n                    texcolor = mix(\n                        texcolor,\n                        vec3(1.)*mod(floor(p.x+tiny)+floor(p.y+tiny)+floor(p.z+tiny), 2.),\n                        .5\n                    );\n                    #undef tiny\n                    fragColor.rgb += shiny*texcolor;\n                    //\n                    // amount reflected/transmitted varies 0-1 based on how much is absorbed\n                    //\n                    shiny *= .2;\n                    //\n                    // update ray position based on surface properties\n                    //\n                    d = reflect(d, inter_closest.xyz);\n                    p += d*1e-3;\n                }\n            }\n            #if scene == 1\n            else if (abs(length(p)-1.) <= .01) {\n                //\n                // hits sphere\n                //\n                // //\n                //\n                // fake diffuse with texture map\n                //\n                vec3 texcolor;\n                //texcolor = vec3(1., 0., 0.);\n                texcolor = vec3(abs(inter_closest.xyz));\n                //texcolor = clamp(.5+.5*inter_closest.xyz, 0., 1.);\n                fragColor.rgb += shiny*texcolor;\n                //\n                // amount reflected/transmitted varies 0-1 based on how much is absorbed\n                //\n                shiny *= .2;\n                //\n                // update ray position based on surface properties\n                //\n                d = reflect(d, inter_closest.xyz);\n                p += d*1e-3;\n            }\n            #endif\n            else {\n                //\n                // hits image plane quadrilateral thing\n                //\n                // //\n                //\n                // fake diffuse with texture map\n                //\n                vec3 texcolor;\n                //texcolor = vec3(1., 0., 0.);\n                texcolor = vec3(abs(inter_closest.xyz));\n                //texcolor = clamp(.5+.5*inter_closest.xyz, 0., 1.);\n                /*#define tiny .0001\n                #define tmp1 6.\n                texcolor = mix(\n                    texcolor,\n                    vec3(1.)*mod(floor(p.x*tmp1+tiny)+floor(p.y*tmp1+tiny)+floor(p.z*tmp1+tiny), 2.),\n                    .5\n                );\n                #undef tmp1\n                #undef tiny*/\n                vec3 p2 = p;\n                p2.xz = inverse(azimuth)*p2.xz;\n                p2.yz = inverse(zenith)*p2.yz;\n                texcolor = texture(iChannel1, (p2.xy/ana_w/2.)*vec2(1., iResolution.x/iResolution.y)+.5).rgb;\n                fragColor.rgb += shiny*texcolor;\n                //\n                // amount reflected/transmitted varies 0-1 based on how much is absorbed\n                //\n                shiny *= .0;\n                //\n                // update ray position based on surface properties\n                //\n                //d = reflect(d, inter_closest.xyz);\n                p += d*1e-3;\n            }\n        }\n       \n    }\n    //\n    // optional: if this is a camera ray and not a reflected ray, use blue background instead of actual cube map\n    //\n    if (shiny == 1.) {\n        fragColor.rgb = vec3(0., 0., 100./255.);\n        shiny = 0.;\n    }\n    //\n    // add the cube map\n    //\n    fragColor.rgb += shiny*sky_map(d);\n    shiny *= 0.;\n    //\n    // fix fragColor\n    //\n    fragColor.rgb = clamp(fragColor.rgb, 0., 1.);\n    fragColor.a = 1.;\n}\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}