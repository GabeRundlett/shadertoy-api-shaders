{
    "Shader": {
        "info": {
            "date": "1528584664",
            "description": "Click and drag to rotate camera",
            "flags": 0,
            "hasliked": 0,
            "id": "XdyBW1",
            "likes": 1,
            "name": "Trench Stairs",
            "published": 3,
            "tags": [
                "pathtracing",
                "stairs"
            ],
            "usePreview": 0,
            "username": "ChrisK",
            "viewed": 443
        },
        "renderpass": [
            {
                "code": "// An infinite corridor with infinitely high stairs on both sides.\n\n// The sky is filled in analytically based on the angle of the camera ray,\n// so no rays are wasted on the sky and the horizon is in the correct spot\n// regardless of pathtracing distance or detail.\n\n// I am using blue noise to randomly jitter the position of the camera for each pixel.\n// This does a decent job of hiding aliasing in motion and I think it also works well\n// for simulating the slightly fuzzy effect of mesoptic (low-light) vision.\n// To turn the effect off, disable CAMERA_JITTER.\n\n\n//quick hack to loop every 20 seconds (fix problems when shader runs for a long time)\n#define iTime mod(iTime, 20.0)\n\n#define PI\t\t\t3.14159265359\n#define HALF_PI\t\t1.57079632679\n#define TAU     \t6.28318530718\n\n#define FOV\t\t\t\t\t\tPI*0.5\n#define CAMERA_HEIGHT\t\t\t1.0\n#define CAMERA_SPEED\t\t\t2.0\n#define CAMERA_JITTER\n\n#define LIGHT_POSITION\t\t\tro+vec3(0.5, -0.75, 0.0)\n#define SHADOW_HARDNESS\t\t\t250.0\n#define NORMAL_MAPPING\n\n#define MAX_STEPS_PER_RAY   \t100\n#define MAX_RAY_LENGTH     \t\t200.0\n#define EPSILON\t\t\t\t\t0.00005\t\t//error tolerance for ray-object collision\n#define SHADOW_ERROR\t\t\t0.01\n\n//#define DEBUG\n\n\n///////////////////////////////////////////////////////////////////////////////////////\n//\tMODEL\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t\t \t\t //\n///////////////////////////////////////////////////////////////////////////////////////\n\n//displacements (use in place of 'p' in distance function)\nvec3 repeat ( vec3 p, vec3 d ) { return mod(p+d*0.5,d)-d*0.5; }\n\nvec3 xrotate (vec3 p, float r) { return vec3( p.x, p.y*cos(r)-p.z*sin(r), p.y*sin(r)+p.z*cos(r) ); }\nvec3 yrotate (vec3 p, float r) { return vec3( p.x*cos(r)+p.z*sin(r), p.y, -p.x*sin(r)+p.z*cos(r) ); }\nvec3 zrotate (vec3 p, float r) { return vec3( p.x*cos(r)-p.y*sin(r), p.x*sin(r)+p.y*cos(r), p.z ); }\n\n//primatives\nfloat plane ( vec3 p ) { return abs(p.y); }\nfloat sphere ( vec3 p, float r ) { return length(p)-r; }\nfloat cube ( vec3 p, float l ) { vec3 d=abs(p)-l; return min(max(d.x,max(d.y,d.z)),0.0)+length(max(d,0.0)); }\nfloat box ( vec3 p, vec3 l ) { vec3 d=abs(p)-l; return min(max(d.x,max(d.y,d.z)),0.0)+length(max(d,0.0)); }\nfloat ubox ( vec3 p, vec3 l ) { return length(max(abs(p)-l,0.0)); }\n\nfloat xbar ( vec3 p, vec2 l ) { vec2 d=abs(p.yz)-l; return min(max(d.x,d.y),0.0)+length(max(d,0.0)); }\nfloat ybar ( vec3 p, vec2 l ) { vec2 d=abs(p.xz)-l; return min(max(d.x,d.y),0.0)+length(max(d,0.0)); }\nfloat zbar ( vec3 p, vec2 l ) { vec2 d=abs(p.xy)-l; return min(max(d.x,d.y),0.0)+length(max(d,0.0)); }\n\nfloat xcylinder ( vec3 p, float r ) { return length(p.yz)-r; }\nfloat ycylinder ( vec3 p, float r ) { return length(p.xz)-r; }\nfloat zcylinder ( vec3 p, float r ) { return length(p.xy)-r; }\n\nfloat xcylinder ( vec3 p, float r, float l ) { return max(length(p.yz)-r,abs(p.x)-l); }\nfloat ycylinder ( vec3 p, float r, float l ) { return max(length(p.xz)-r,abs(p.y)-l); }\nfloat zcylinder ( vec3 p, float r, float l ) { return max(length(p.xy)-r,abs(p.z)-l); }\n\nfloat torus ( vec3 p, float ra, float rb ) { return length(vec2(length(p.xz)-ra, p.y))-rb; }\nfloat cone ( vec3 p, float m ) { return dot(normalize(vec2(m, 1.0)), vec2(length(p.xz), p.y)); }\n\n\nfloat model ( vec3 p ) {\n    float stepsize = 0.5;\n    float stairwidth = 1.0;\n    float stairrepeat = 10.0;\n    float railheight = 3.0;\n    float wallwidth = 15.0;\n    float trenchwidth = 5.0;\n    \n    float ground = p.y+2.0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//ground plane\n    //ground = max( ground, -zbar(p, vec2(trenchwidth, 5.0)) );\t\t\t\t\t\t\t//cut trench\n    \n    p.x = abs(p.x);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//mirror horizontally\n    vec3 sp = zrotate(p-vec3(wallwidth,0.0,5.0), -PI*0.25);\t\t\t\t\t\t\t\t//rotate space to match wall angle\n    float wall = sp.y-1.25;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//wall\n    \n    sp = repeat( sp, vec3(0.0,0.0,stairrepeat) );\t\t\t\t\t\t\t\t\t\t//repeat space along z-axis\n    float stepsides = xbar(sp, vec2(1.5, stairwidth+0.25 ));\t\t\t\t\t\t\t//slopes up side of stairs\n    wall = max( wall, -stepsides );\t\t\t\t\t\t\t\t\t\t\t\t\t\t//cut groove in wall for staircase\n    stepsides = max( stepsides, -xbar(sp, vec2(2.0, stairwidth )) );\t\t\t\t\t//cut space for steps\n    \n    float railing = \t\tycylinder( repeat(p+vec3(0.5,0.0,15.0-stairwidth-0.125), vec3(1.0, 0.0, stairrepeat)), 0.05);\n    railing = min( railing, ycylinder( repeat(p+vec3(0.5,0.0,15.0+stairwidth+0.125), vec3(1.0, 0.0, stairrepeat)), 0.05) );\n    railing = max( railing, sp.y-railheight );\t\t\t\t\t\t\t\t\t\t\t//cut balustrade above handrail\n    railing = min( railing, xcylinder(sp-vec3(0.0, railheight, stairwidth+0.125), 0.075 ) );\t//handrail #1\n    railing = min( railing, xcylinder(sp-vec3(0.0, railheight,-stairwidth-0.125), 0.075 ) );\t//handrail #2\n    \n    sp = repeat( sp, vec3(stepsize,0.0,0.0) );\t\t\t\t\t\t\t\t\t\t\t//repeat space along stair run\n    sp = zrotate(sp, PI*0.25);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//rotate space back to normal axes\n    float steps = ubox( sp, vec3(1.0,1.0,stairwidth) )-0.01;\t\t\t\t\t\t\t//staircase steps\n    float stairs = min( steps, stepsides );\t\t\t\t\t\t\t\t\t\t\t\t//combine steps with staircase sides\n    stairs = min( stairs, railing );\t\t\t\t\t\t\t\t\t\t\t\t\t//combine stairs with railings\n    stairs = max( stairs, wallwidth-p.x-4.0 );\t\t\t\t\t\t\t\t\t\t\t//cut stairs at bottom\n    \n    float trh = sqrt(2.0*railheight*railheight);\n    float trenchrail = ycylinder( repeat(p-vec3(trenchwidth+0.1, -2.0, 0.0), vec3(0.0, 0.0, 1.0)), 0.05, trh*0.5);\t//trenchside balustrade\n    trenchrail = min(trenchrail, zcylinder(p-vec3(trenchwidth+0.1, trh*0.5-2.0, 0.0), 0.075 ) );\t\t\t\t\t//trenchside handrails\n    \n    float d = min( wall, stairs );\t\t\t\t\t\t\t\t\t\t\t\t\t\t//combine wall and stairs\n    d = min( d, ground );\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//combine with ground\n    d = min( d, trenchrail );\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//combine with trench railing\n    d = max( d, -zbar(p, vec2(trenchwidth, 5.0)) );\t\t\t\t\t\t\t\t\t\t//cut trench\n    \n\treturn d;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n//\tMATH\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat calcintersection ( vec3 ro, vec3 rd ) {\n\t//use sphere tracing to advance along ray\n\tfloat h = 100.0;\n\tfloat d = 0.0;\n    for ( int i=0; i<MAX_STEPS_PER_RAY && h>EPSILON && d<MAX_RAY_LENGTH; i++ ) {\n\t\th = model( ro+rd*d );\n        d += h;\n\t}\n\treturn d<MAX_RAY_LENGTH ? d : -1.0;\n}\n\n\nfloat softshadow( vec3 ro, vec3 rd, float ldist ) {  \n    float res = 1.0;\n    float dmin = SHADOW_ERROR;\n    for( float t=dmin; t<ldist-dmin; ) {\n        float h = model(ro + rd*t);\n        if( h<SHADOW_ERROR*0.001 )\n            return 0.0;\t\t\t\t//full shadow - break early\n        res = min( res, SHADOW_HARDNESS*h/t );\n        t += h;\n    }\n    return res*res*(3.0-2.0*res);\t//adjust penumbra falloff for smoother results\n}\n\n\nvec3 getdata ( vec3 ro, vec3 rd ) {\n\t//use sphere tracing to advance along ray\n\tfloat h = 100.0;\n\tfloat d = 0.0;\n    int steps = 0;\n    while ( steps<MAX_STEPS_PER_RAY && h>EPSILON && d<MAX_RAY_LENGTH ) {\n\t\th = model( ro+rd*d );\n        d += h;\n        steps++;\n\t}\n\treturn vec3(d<MAX_RAY_LENGTH ? d : -1.0, steps, h);\n}\n\n\nvec3 getnormal ( vec3 p ) {\n\tconst float e = EPSILON*100.0;\n\tvec3 nor = vec3( model( p - vec3(e,0.0,0.0) ),\n\t\t\t\t\t model( p - vec3(0.0,e,0.0) ),\n\t\t\t\t\t model( p - vec3(0.0,0.0,e) ) );\n    nor = normalize( vec3(model(p)) - nor );\n    \n    #ifdef NORMAL_MAPPING\n    vec3 bump = texture( iChannel1, mix(p.xz,p.yz,abs(nor.x))*0.05 ).rgb - 0.5;\n    nor += bump*0.3;\n    nor = normalize(nor);\n    #endif\n    \n    return nor;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n//\tRENDERING\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 getrendersample ( vec3 ro, vec3 rd ) {\n    if( (rd.x-rd.y)<0.0 && (rd.x+rd.y)>0.0 ) {\n    \t//ray hit sky\n        return vec3(0.0,0.002,0.01)*(1.1-rd.y);\n    }\n        \n    float rl = calcintersection( ro, rd );\n    if ( rl > -0.5 ) {\n        //draw object\n\t\tvec3 xyz = ro + rd*rl;\n\t\tvec3 nor = getnormal( xyz );\n        \n        vec3 ld = normalize(LIGHT_POSITION-xyz);\t\t\t\t\t\t\t\t//direction to light\n        float ldist = distance(xyz,LIGHT_POSITION);\t\t\t\t\t\t\t\t//distance to light\n        vec3 lcol = vec3(0.75,0.7,0.5);\t\t\t\t\t\t\t\t\t\t\t//light colour\n        float li = 20.0/(ldist*ldist);\t\t\t\t\t\t\t\t\t\t\t//distance falloff\n        float shad = softshadow(xyz, ld, ldist);\t\t\t\t\t\t\t\t//soft shadows\n        \n        //float tex = texture( iChannel1, mix(xyz.xz,xyz.yz,abs(nor.x))*0.05 ).r;\n        \n        float diff = max(dot(ld, nor), 0.0);\t\t\t\t\t\t\t\t\t//Lambertian diffuse\n        \n        vec3 hv = normalize(ld-rd);\n        float m = 0.2;\n        float a = acos(dot(nor,hv));\n        float ta = tan(a);\n        float ca = cos(a);\n        float spec = exp(-(ta*ta)/(m*m))/(PI*m*m*ca*ca*ca*ca);\t\t\t\t\t//Beckmann specular\n        \n        vec3 c = mix( diff*lcol, vec3(spec), 0.15) * li*shad;\n        c += lcol*lcol*2.0/pow(distance(xyz,LIGHT_POSITION),2.0);\t\t\t\t//bounce light approximation\n        c *= 1.0 - clamp( (rl-50.0)/(MAX_RAY_LENGTH-50.0), 0.0, 1.0);\t\t\t//black fog to better hide render limit\n        return c;\n\t} else {\n\t\treturn vec3(0.0);\n\t}\n}\n\n\nvec3 getheatmap ( vec3 ro, vec3 rd ) {\n    //ray hit sky\n    if( (rd.x-rd.y)<0.0 && (rd.x+rd.y)>0.0 ) return vec3(0.0);\n    \n    vec3 gd = getdata(ro, rd);\n    \n    float steps = gd.y/float(MAX_STEPS_PER_RAY);\n    \n    if ( gd.x > -0.5 ) {\n\t\tvec3 xyz = ro + rd*gd.x;\n        vec3 ld = normalize( LIGHT_POSITION-xyz );\n        vec3 ldata = getdata( LIGHT_POSITION, -ld );\n        \n        float lightsteps = ldata.y/float(MAX_STEPS_PER_RAY);\n        float error = float(gd.z>EPSILON) + float(ldata.z>EPSILON);\n        return vec3( steps, error*0.5, lightsteps );\n\t} else {\n\t\treturn vec3( steps, 0.0, 0.0 );\n\t}\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy/iResolution.xy*2.0 - 1.0;\t//camera-space position (-1 => 1)\n    \n    vec3 campos = vec3(0.0,CAMERA_HEIGHT,iTime*CAMERA_SPEED);\n    //campos = vec3( iTime, iTime, 0.0 )*CAMERA_SPEED;\t\t\t//stair climbing camera\n    \n    vec3 noise = texelFetch(iChannel0, ivec2(mod(fragCoord+float(iFrame)*30.0,1024.0)), 0).rgb-0.5;\n    \n    #ifdef CAMERA_JITTER\n    uv += noise.xy / iResolution.xy * (iResolution.x*0.002); \t\t\t\t//positional noise\n    //uv += noise.xy / iResolution.xy * (iResolution.x*0.01) * dot(uv,uv);\n    #endif\n    \n    uv.y *= iResolution.y/iResolution.x;\n    \n    float d = 1.0/tan(FOV/2.0);\t\t\t\t\t\t//distance from aperture/lens to picture plane\n    vec3 camray = normalize( vec3(uv,d) );\n    \n    if (iMouse.z>0.0) {\n    \tcamray = xrotate(camray, HALF_PI-iMouse.y/iResolution.y*PI);\n    \tcamray = yrotate(camray, PI+iMouse.x/iResolution.x*TAU);\n    }\n\n    vec3 col;\n    \n    #ifdef DEBUG\n    \n    col = getheatmap( campos, camray );\n    \n    #else\n    \n    col = getrendersample( campos, camray );\n    col *= 1.0-dot(uv,uv)*0.5;\t\t\t\t\t\t//vignette\n    col /= col+1.0;\t\t\t\t\t\t\t\t\t//Reinhard tonemapping\n    col = pow( col, vec3(0.45) );\t\t\t\t\t//gamma adjustment\n    col += noise/20.0;\t\t\t\t\t\t\t\t//noise\n    \n    #endif\n    \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}