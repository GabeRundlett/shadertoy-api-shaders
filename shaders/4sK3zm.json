{
    "Shader": {
        "info": {
            "date": "1454077386",
            "description": "This is an attempt to simulate liquid in 2D, using particles.\n- Mouse: draw colliders;\n- LEFT & RIGHT: rotate the gravity;\n- SPACE: invert the gravity;\n- R: reset the scene.",
            "flags": 48,
            "hasliked": 0,
            "id": "4sK3zm",
            "likes": 65,
            "name": "Liquid stuff",
            "published": 3,
            "tags": [
                "fluid",
                "liquid",
                "physics"
            ],
            "usePreview": 0,
            "username": "Nrx",
            "viewed": 2068
        },
        "renderpass": [
            {
                "code": "// Display particles and colliders\n\n#define RADIUS_PARTICLE\t\t\t1.5\n//#define GLOW_THICKNESS\t\t1.0 // Choose either GLOW_THICKNESS *or* PARTICLE_COUNT_MIN\n#define PARTICLE_COUNT_MIN\t\t2.0\n#define VELOCITY_COLOR_FACTOR\t0.02\n\n#define FLOOR(x) float (int (x)) // To workaround a bug with Firefox on Windows...\n\nfloat rand (in vec2 seed) {\n\treturn fract (sin (dot (seed, vec2 (12.9898, 78.233))) * 137.5453);\n}\n\nvec3 hsv2rgb (in vec3 hsv) {\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n}\n\nfloat segDist (in vec2 p, in vec2 a, in vec2 b) {\n\tp -= a;\n\tb -= a;\n\treturn length (p - b * clamp (dot (p, b) / dot (b, b), 0.0, 1.0));\n}\n\nvec3 particleColor (in float particleVelocity) {\n\treturn mix (vec3 (0.5, 0.5, 1.0), vec3 (1.0), particleVelocity * VELOCITY_COLOR_FACTOR);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Check whether there is a collider here\n\tvec4 data = texture (iChannel1, fragCoord / iResolution.xy);\n\tvec3 color;\n\tif (data.a > 0.5) {\n\n\t\t// Collider (wood)\n\t\tvec2 uv = 0.02 * fragCoord;\n\t\tuv = uv.y * 13.0 + sin (uv * 17.0) * sin (uv.yx * 7.0) * sin (iTime * 0.2 + uv);\n\t\tcolor = vec3 (0.8, 0.6, 0.4) * (1.0 - 0.5 * length (fract (uv) - 0.5));\n\t} else {\n\n\t\t// Background (light squares)\n\t\tvec2 uv = 0.05 * fragCoord;\n\t\tuv += 0.5 * cos (uv.yx + iTime);\n\t\tfloat angle = rand (floor (uv)) * 3.14159;\n\t\tvec3 hsv = vec3 (0.6 + 0.1 * cos (angle), 1.0, 0.2 + 0.1 * cos (angle * iTime));\n\t\tcolor = hsv2rgb (hsv) * smoothstep (1.0, 0.2, length (fract (uv) - 0.5));\n\n\t\t// Check whether there is a particle here\n\t\tfloat particleVelocity = data.b;\n\t\tif (particleVelocity >= 0.0) {\n\t\t\tcolor += particleColor (particleVelocity);\n\t\t} else {\n\n\t\t\t// Look around (spiral loop from the current position)\n\t\t\tvec2 offset = vec2 (0.0);\n\t\t\tvec2 direction = vec2 (1.0, 0.0);\n#if defined (GLOW_THICKNESS) && !defined (PARTICLE_COUNT_MIN)\n\t\t\tconst float radiusGlow = FLOOR (RADIUS_PARTICLE + GLOW_THICKNESS);\n\t\t\tfor (float n = 1.0; n < (2.0 * radiusGlow + 1.0) * (2.0 * radiusGlow + 1.0); ++n) {\n\t\t\t\toffset += direction;\n\t\t\t\tif (offset.x == offset.y || (offset.x < 0.0 && offset.x == -offset.y) || (offset.x > 0.0 && offset.x == 1.0 - offset.y)) {\n\t\t\t\t\tdirection = vec2 (-direction.y, direction.x);\n\t\t\t\t}\n\t\t\t\tparticleVelocity = texture (iChannel1, (fragCoord + offset) / iResolution.xy).b;\n\t\t\t\tif (particleVelocity >= 0.0) {\n\t\t\t\t\tcolor += particleColor (particleVelocity) * smoothstep (RADIUS_PARTICLE + GLOW_THICKNESS, RADIUS_PARTICLE, length (offset));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n#elif !defined (GLOW_THICKNESS) && defined (PARTICLE_COUNT_MIN)\n\t\t\tfloat count = 0.0;\n\t\t\tfor (float n = 1.0; n < (2.0 * FLOOR (RADIUS_PARTICLE) + 1.0) * (2.0 * FLOOR (RADIUS_PARTICLE) + 1.0); ++n) {\n\t\t\t\toffset += direction;\n\t\t\t\tif (offset.x == offset.y || (offset.x < 0.0 && offset.x == -offset.y) || (offset.x > 0.0 && offset.x == 1.0 - offset.y)) {\n\t\t\t\t\tdirection = vec2 (-direction.y, direction.x);\n\t\t\t\t}\n\t\t\t\tif (dot (offset, offset) <= RADIUS_PARTICLE * RADIUS_PARTICLE) {\n\t\t\t\t\tparticleVelocity = texture (iChannel1, (fragCoord + offset) / iResolution.xy).b;\n\t\t\t\t\tif (particleVelocity >= 0.0 && ++count >= PARTICLE_COUNT_MIN) {\n\t\t\t\t\t\tcolor += particleColor (particleVelocity);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\t// Display the direction of the gravity\n\tdata = texture (iChannel2, vec2 (1.5, 0.5) / iResolution.xy);\n\tfloat gravityTimer = data.g;\n\tif (gravityTimer > 0.0) {\n\t\tfloat gravityDirection = data.r;\n\t\tvec2 frag = fragCoord - 0.5 * iResolution.xy;\n\t\tvec2 direction = vec2 (cos (gravityDirection), sin (gravityDirection));\n\t\tvec2 pointA = 25.0 * direction;\n\t\tvec2 pointB = 15.0 * direction;\n\t\tvec2 offset = 10.0 * vec2 (direction.y, -direction.x);\n\t\tfloat dist = segDist (frag, -pointA, pointA);\n\t\tdist = min (dist, segDist (frag, pointA, pointB + offset));\n\t\tdist = min (dist, segDist (frag, pointA, pointB - offset));\n\t\tcolor = mix (color, vec3 (smoothstep (4.0, 3.0, dist)), gravityTimer * smoothstep (6.0, 5.0, dist));\n\t}\n\n\t// Set the fragment color\n\tfragColor = vec4 (color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Update the velocity and position of each particle\n\n#define COLLISION_SPRING_STIFFNESS_COLLIDER\t5000.0\n#define COLLISION_SPRING_STIFFNESS_PARTICLE\t1500.0\n#define COLLISION_SPRING_DAMPING\t\t\t10.0\n#define RADIUS_COLLIDER\t\t\t\t\t\t0.5\n#define RADIUS_PARTICLE\t\t\t\t\t\t1.0\n#define PACKED\n#define GRAVITY\t\t\t\t\t\t\t\t10.0\n#define TIME_STEP_MAX\t\t\t\t\t\t0.01\n#define VELOCITY_MAX\t\t\t\t\t\t1.0\n#define SPAWN_VELOCITY\t\t\t\t\t\tvec2 (-200.0, 0.0)\n#define SPAWN_POSITION\t\t\t\t\t\tiResolution.xy - 12.5\n#define SQRT3\t\t\t\t\t\t\t\t1.732\n\n#define CEIL(x) float (int (x + 0.9999)) // To workaround a bug with Firefox on Windows...\n\nvec2 particleVelocity;\nvec2 particlePosition;\nvec2 particleForce;\nvec2 particleIdCheck;\n\nvoid collide (in vec2 offset) {\n\n\t// Get the position of the cell\n\tvec2 cellPosition = floor (particlePosition + offset) + 0.5;\n\n\t// Get the particle ID and the collider\n\tvec4 data = texture (iChannel1, cellPosition / iResolution.xy);\n\tvec2 particleId = data.rg;\n\tfloat collider = data.a;\n\n\t// Check whether there is a particle here\n\tif (offset == vec2 (0.0)) {\n\n\t\t// This is the current particle\n\t\tparticleIdCheck = particleId;\n\t}\n\telse if (particleId.x > 0.0) {\n\n\t\t// Get the velocity and position of this other particle\n\t\tdata = texture (iChannel0, particleId / iResolution.xy);\n\t\tvec2 otherParticleVelocity = data.rg;\n\t\tvec2 otherParticlePosition = data.ba;\n\n\t\t// Compute the distance between these 2 particles\n\t\tvec2 direction = otherParticlePosition - particlePosition;\n\t\tfloat distSquared = dot (direction, direction);\n\n\t\t// Check whether these 2 particles touch each other\n\t\tif (distSquared < 4.0 * RADIUS_PARTICLE * RADIUS_PARTICLE) {\n\n\t\t\t// Normalize the direction\n\t\t\tfloat dist = sqrt (distSquared);\n\t\t\tdirection /= dist;\n\n\t\t\t// Apply the collision force (spring)\n\t\t\tfloat compression = 2.0 * RADIUS_PARTICLE - dist;\n\t\t\tparticleForce -= direction * (compression * COLLISION_SPRING_STIFFNESS_PARTICLE - dot (otherParticleVelocity - particleVelocity, direction) * COLLISION_SPRING_DAMPING);\n\t\t}\n\t}\n\n\t// Collision with a collider?\n\tif (collider > 0.5) {\n\n\t\t// Compute the distance between the center of the particle and the collider\n\t\tvec2 direction = cellPosition - particlePosition;\n\t\tvec2 distCollider = max (abs (direction) - RADIUS_COLLIDER, 0.0);\n\t\tfloat distSquared = dot (distCollider, distCollider);\n\n\t\t// Check whether the particle touches the collider\n\t\tif (distSquared < RADIUS_PARTICLE * RADIUS_PARTICLE) {\n\n\t\t\t// Normalize the direction\n\t\t\tfloat dist = sqrt (distSquared);\n\t\t\tdirection = sign (direction) * distCollider / dist;\n\n\t\t\t// Apply the collision force (spring)\n\t\t\tfloat compression = RADIUS_PARTICLE - dist;\n\t\t\tparticleForce -= direction * (compression * COLLISION_SPRING_STIFFNESS_COLLIDER + dot (particleVelocity, direction) * COLLISION_SPRING_DAMPING);\n\t\t}\n\t}\n}\n\nvec2 rand (in float seed) {\n\tvec2 n = seed * vec2 (12.9898, 78.233);\n\treturn fract (n.yx * fract (n));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Check for a reset\n\tbool reset = iFrame == 0 || texture (iChannel2, vec2 (0.5) / iResolution.xy).a > 0.5;\n\n\t// Define the particle data\n\tif (reset) {\n\n\t\t// Define the particle spawning area\n\t\tfloat liquid =\n\t\t\tstep (abs (fragCoord.x - iResolution.x * 0.5), iResolution.x * 0.5 - 5.0 - RADIUS_PARTICLE)\n\t\t\t* step (iResolution.y * 0.5, fragCoord.y)\n\t\t\t* step (fragCoord.y, iResolution.y - 5.0 - RADIUS_PARTICLE)\n#ifndef PACKED\n\t\t\t* step (mod (fragCoord.x + SQRT3 * fragCoord.y, ceil (2.0 * RADIUS_PARTICLE)), 1.0)\n\t\t\t* step (mod (fragCoord.y, ceil (SQRT3 * RADIUS_PARTICLE)), 1.0);\n#else\n\t\t\t* step (mod (fragCoord.x + fragCoord.y, 2.0), 0.5);\n#endif\n\t\tfloat rand = 0.01 * cos (fragCoord.x * 13.37 + fragCoord.y * 17.73);\n\n\t\t// Initialize the particle\n\t\tparticleVelocity = vec2 (0.0);\n\t\tparticlePosition = liquid > 0.5 ? fragCoord + rand: vec2 (-1.0);\n\t} else {\n\n\t\t// Get the particle data\n\t\tvec4 data = texture (iChannel0, fragCoord / iResolution.xy);\n\t\tparticleVelocity = data.rg;\n\t\tparticlePosition = data.ba;\n\t\tif (particlePosition.x > 0.0) {\n\n\t\t\t// Get the gravity\n\t\t\tfloat gravityDirection = texture (iChannel2, vec2 (1.5, 0.5) / iResolution.xy).r;\n\t\t\tparticleForce = GRAVITY * vec2 (cos (gravityDirection), sin (gravityDirection));\n\n\t\t\t// Check for collisions with nearby particles and colliders\n\t\t\tconst float collisionRadius = CEIL (RADIUS_PARTICLE * 2.0);\n\t\t\tfor (float i = -collisionRadius; i <= collisionRadius; ++i) {\n\t\t\t\tfor (float j = -collisionRadius; j <= collisionRadius; ++j) {\n\t\t\t\t\tcollide (vec2 (i, j));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Make sure the particle is still tracked\n\t\t\tif (particleIdCheck != fragCoord) {\n\n\t\t\t\t// The particle is lost...\n\t\t\t\tparticlePosition = vec2 (-1.0);\n\t\t\t} else {\n\n\t\t\t\t// Limit the time step\n\t\t\t\tfloat timeStep = min (iTimeDelta, TIME_STEP_MAX);\n\n\t\t\t\t// Update the velocity of the particle\n\t\t\t\tparticleVelocity += particleForce * timeStep;\n\n\t\t\t\t// Limit the velocity (to avoid losing track of the particle)\n\t\t\t\tvec2 delta = particleVelocity * timeStep;\n\t\t\t\tfloat dist = length (delta);\n\t\t\t\tif (dist > VELOCITY_MAX) {\n\t\t\t\t\tparticleVelocity *= VELOCITY_MAX / dist;\n\t\t\t\t}\n\n\t\t\t\t// Update the position of the particle\n\t\t\t\tparticlePosition += particleVelocity * timeStep;\n\t\t\t}\n\t\t} else {\n\n\t\t\t// Spawn a new particle?\n\t\t\tvec2 particleId = 0.5 + floor (iResolution.xy * rand (iTime));\n\t\t\tif (fragCoord == particleId) {\n\t\t\t\tparticleVelocity = SPAWN_VELOCITY;\n\t\t\t\tparticlePosition = SPAWN_POSITION;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Update the fragment\n\tfragColor = vec4 (particleVelocity, particlePosition);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Track the particles\n\n#define VELOCITY_MAX\t1.0\n#define SPAWN_POSITION\tiResolution.xy - 12.5\n\n#define CEIL(x) float (int (x + 0.9999)) // To workaround a bug with Firefox on Windows...\n\nbool reset;\nvec2 particleIdFound;\nfloat particleVelocity;\n\nfloat track (in vec2 fragCoord, in vec2 offset) {\n\n\t// Get the particle ID and collider\n\tvec2 cellPosition = fragCoord + offset;\n\tvec4 data;\n\tif (reset) {\n\n\t\t// Define the colliders\n\t\tvec2 midScreen = 0.5 * iResolution.xy;\n\t\tvec2 dist = abs (fragCoord - midScreen);\n\t\tvec2 container = step (midScreen - 5.0, dist);\n\t\tcontainer.y *= step (iResolution.y * 0.03, dist.x);\n\t\tfloat obstacle = step (length (fragCoord - iResolution.xy * vec2 (0.5, 0.3)), iResolution.y * 0.1);\n\n\t\t// Set the initial data\n\t\tdata = vec4 (cellPosition, 0.0, container.x + container.y + obstacle);\n\t} else {\n\n\t\t// Get the exisiting data\n\t\tdata = texture (iChannel1, cellPosition / iResolution.xy);\n\t}\n\tvec2 particleId = data.rg;\n\tfloat collider = data.a;\n\n\t// Get the position of this particle\n\tif (particleId.x > 0.0) {\n\t\tdata = texture (iChannel0, particleId / iResolution.xy);\n\t\tvec2 particlePosition = data.ba;\n\n\t\t// Check whether this particle is the one to track\n\t\tvec2 delta = floor (particlePosition - fragCoord + 0.5);\n\t\tif (delta == vec2 (0.0)) {\n\n\t\t\t// Take note of the particle ID and its velocity\n\t\t\tparticleIdFound = particleId;\n\t\t\tparticleVelocity = length (data.rg);\n\t\t}\n\t}\n\n\t// Return the collider\n\treturn collider;\n}\n\nvec2 rand (in float seed) {\n\tvec2 n = seed * vec2 (12.9898, 78.233);\n\treturn fract (n.yx * fract (n));\n}\n\nfloat segDist (in vec2 p, in vec2 a, in vec2 b) {\n\tp -= a;\n\tb -= a;\n\treturn length (p - b * clamp (dot (p, b) / dot (b, b), 0.0, 1.0));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Initialization\n\tparticleIdFound = vec2 (-1.0);\n\tparticleVelocity = -1.0;\n\tfloat collider = 0.0;\n\n\t// Check the player inputs\n\tvec4 data = texture (iChannel2, vec2 (0.5) / iResolution.xy);\n\n\t// Allow to add colliders (removing particles)\n\tif (iMouse.z > 0.5) {\n\t\tfloat dist;\n\t\tif (data.b < 0.5) {\n\t\t\tdist = length (fragCoord - iMouse.xy);\n\t\t} else {\n\t\t\tdist = segDist (fragCoord, data.rg, iMouse.xy);\n\t\t}\n\t\tcollider = step (dist, 3.0);\n\t}\n\tif (collider < 0.5) {\n\n\t\t// Check the current position\n\t\treset = iFrame == 0 || data.a > 0.5;\n\t\tvec2 offset = vec2 (0.0);\n\t\tcollider = track (fragCoord, offset);\n\n\t\t// Track the particle (spiral loop from the current position)\n\t\tvec2 direction = vec2 (1.0, 0.0);\n\t\tfor (float n = 1.0; n < (2.0 * CEIL (VELOCITY_MAX) + 1.0) * (2.0 * CEIL (VELOCITY_MAX) + 1.0); ++n) {\n\t\t\tif (particleIdFound.x > 0.0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\toffset += direction;\n\t\t\ttrack (fragCoord, offset);\n\t\t\tif (offset.x == offset.y || (offset.x < 0.0 && offset.x == -offset.y) || (offset.x > 0.0 && offset.x == 1.0 - offset.y)) {\n\t\t\t\tdirection = vec2 (-direction.y, direction.x);\n\t\t\t}\n\t\t}\n\n\t\t// Spawn a new particle?\n\t\tif (particleIdFound.x < 0.0 && fragCoord == SPAWN_POSITION) {\n\t\t\tvec2 particleId = 0.5 + floor (iResolution.xy * rand (iTime));\n\t\t\tvec2 particlePosition = texture (iChannel0, particleId / iResolution.xy).ba;\n\t\t\tif (particlePosition == fragCoord) {\n\t\t\t\tparticleIdFound = particleId;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Update the fragment\n\tfragColor = vec4 (particleIdFound, particleVelocity, collider);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Handle player inputs\n\n#define KEY_R\t\t(vec2 (82.5, 0.5) / 256.0)\n#define KEY_LEFT\t(vec2 (37.5, 0.5) / 256.0)\n#define KEY_RIGHT\t(vec2 (39.5, 0.5) / 256.0)\n#define KEY_SPACE\t(vec2 (32.5, 0.5) / 256.0)\n#define PI\t\t\t3.14159265359\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Don't waste time\n\tif (fragCoord.x > 2.0 || fragCoord.y > 1.0) {\n\t\tdiscard;\n\t}\n\n\t// Get the status of the reset (R) key\n\tfloat reset = texture (iChannel3, KEY_R).r;\n\n\t// Check what to do\n\tif (fragCoord.x < 1.0) {\n\n\t\t// Update the fragment\n\t\tfragColor = vec4 (iMouse.xyz, reset);\n\t} else {\n\n\t\t// Set the direction of the gravity\n\t\tfloat gravityDirection;\n\t\tfloat gravityTimer;\n\t\tif (iFrame == 0 || reset > 0.5) {\n\n\t\t\t// Reset the gravity\n\t\t\tgravityDirection = -PI * 0.5;\n\t\t\tgravityTimer = 0.0;\n\t\t} else {\n\n\t\t\t// Get the current values\n\t\t\tvec2 data = texture (iChannel2, fragCoord / iResolution.xy).rg;\n\t\t\tgravityDirection = data.r;\n\t\t\tgravityTimer = data.g;\n\n\t\t\t// Get the status of the left, right and space keys\n\t\t\tfloat keyLeft = texture (iChannel3, KEY_LEFT).r;\n\t\t\tfloat keyRight = texture (iChannel3, KEY_RIGHT).r;\n\t\t\tfloat keySpace = texture (iChannel3, KEY_SPACE).r;\n\t\t\tif (keyLeft + keyRight + keySpace < 0.5) {\n\t\t\t\tgravityTimer = max (0.0, gravityTimer - iTimeDelta * 5.0);\n\t\t\t} else {\n\t\t\t\tif (keyLeft > 0.5) {\n\t\t\t\t\tgravityDirection -= PI * 0.5 * iTimeDelta;\n\t\t\t\t} else if (keyRight > 0.5) {\n\t\t\t\t\tgravityDirection += PI * 0.5 * iTimeDelta;\n\t\t\t\t} else if (gravityTimer == 0.0) {\n\t\t\t\t\tgravityDirection += PI;\n\t\t\t\t}\n\t\t\t\tgravityTimer = 1.0;\n\t\t\t}\n\t\t}\n\n\t\t// Update the fragment\n\t\tfragColor = vec4 (gravityDirection, gravityTimer, 0.0, 0.0);\n\t}\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}