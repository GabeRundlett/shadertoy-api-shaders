{
    "Shader": {
        "info": {
            "date": "1701945544",
            "description": "Pan Tilt",
            "flags": 0,
            "hasliked": 0,
            "id": "clVBzm",
            "likes": 2,
            "name": "Pan Tilt toward a Point",
            "published": 3,
            "tags": [
                "pantilt"
            ],
            "usePreview": 0,
            "username": "rubioh",
            "viewed": 99
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    \n    vec3 ro = vec3(0.,.0, 0.);\n    vec3 rd = normalize(vec3(uv, .5));\n    \n    vec3 N = vec3(0.);\n    vec2 bI = boxIntersection(ro, rd, vec3(2,1,4), N, vec3(0, 0, 0));\n    vec3 p = ro +rd * bI.x;\n    vec3 ld = normalize(p-vec3(0.,.3,0.));\n    float dotLN = clamp(dot(ld, N), 0., 1.);\n    vec4 col = vec4(.3,.3,.3, .0)*dotLN;\n        \n        \n        \n    vec3 target = vec3(0., -.2, 4.);\n    target += vec3(2.*cos(iTime*.9+3.), .8*cos(iTime*.2+3.), 2.*sin(iTime*.7+3.));\n    N = vec3(0.);\n    bI = boxIntersection(ro, rd, vec3(.2,.2,.2), N, target);\n    p = ro + rd * bI.x;\n    ld = normalize(p-vec3(0.,.3,0.));\n    dotLN = clamp(dot(-ld, N), 0., 1.);\n    if (bI != vec2(-1)){\n        col.rgb = vec3(.7,.1,.7)*dotLN;\n    }\n    /*    \n    N = vec3(0.);\n    bI = boxIntersection(ro, rd, vec3(.08,.08,.08*100.), N, target);\n    p = ro + rd * bI.x;\n    ld = normalize(p-vec3(0.,.3,0.));\n    dotLN = clamp(dot(-ld, N), 0., 1.);\n    if (bI != vec2(-1))\n        col += vec3(.3,.3,.7)*dotLN;\n    N = vec3(0.);\n    bI = boxIntersection(ro, rd, vec3(.08*100.,.08,.08), N, target);\n    p = ro + rd * bI.x;\n    ld = normalize(p-vec3(0.,.3,0.));\n    dotLN = clamp(dot(-ld, N), 0., 1.);\n    if (bI != vec2(-1))\n        col += vec3(.3,.3,.7)*dotLN;\n    N = vec3(0.);\n    bI = boxIntersection(ro, rd, vec3(.08,.08*100.,.08), N, target);\n    p = ro + rd * bI.x;\n    ld = normalize(p-vec3(0.,.3,0.));\n    dotLN = clamp(dot(-ld, N), 0., 1.);\n    if (bI != vec2(-1))\n        col += vec3(.3,.3,.7)*dotLN;\n    */\n    \n    //Obj pos\n    vec3 pos = vec3(.5,.5,2.5); \n    //pos +=  vec3(.3*sin(iTime),cos(iTime)*.5,cos(iTime*1.7));\n    float pan = .0;  // Angle pour la rotation Pan autour de l'axe y\n    float tilt = .0;        // Angle pour la rotation Tilt autour de l'axe x\n    panTiltAngles(pos, vec3(0,1,0), target, pan, tilt);\n    N = vec3(0.);\n    bI = boxIntersectionRot(ro, rd, vec3(.08,.13,.08), pos, N,  pan, tilt);\n    p = ro + rd * bI.x;\n    ld = normalize(p-vec3(0.,.3,0.));\n    dotLN = clamp(dot(-ld, N), 0., 1.);\n    if (bI != vec2(-1)){\n        col.rgb = vec3(.2,.4,.3)*dotLN;\n    }\n        \n    float goLine = rayMarchLine(ro, rd, pos, target, pan, tilt, 3.14159/16.);\n    vec3 colLine = goLine*vec3(1.,0.,0.);\n    col.rgb += colLine;\n    \n    // Output to screen\n    fragColor = vec4(col);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159\n\n\nmat3 rot3D(float t, float phi, float psi, float theta){\n    float ca = cos(phi+t);\n    float sa = sin(phi+t);\n    float cb = cos(psi+t);\n    float sb = sin(psi+t);\n    float cg = cos(theta+t);\n    float sg = sin(theta+t);\n\n    return mat3(cb*cg, sa*sb*cg-ca*sg, ca*sb*cg+sa*sg,\n                cb*sg, sa*sb*sg+ca*cg, ca*sb*sg-sa*cg,\n                -sb,   sa*cb,           ca*cb);\n}\nvec2 boxIntersectionRot( in vec3 ro, in vec3 rd, vec3 boxSize, vec3 pos, out vec3 outNormal, float pan, float tilt)\n{\n\n    ro -= pos;\n\n    float zoom = 0.;\n    mat3 txx = rot3D(0., tilt,pan,zoom);\n    mat3 txi = inverse(txx);\n\n    ro = txx*ro;\n    rd = txx*rd;\n\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = (tN>0.0) ? step(vec3(tN),t1) : // ro ouside the box\n                           step(t2,vec3(tF));  // ro inside the box\n    outNormal *= -sign(rd);\n    outNormal = txi*outNormal;\n    return vec2( tN, tF );\n}\n\n\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal, vec3 pos) \n{\n    ro -= pos;\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = (tN>0.0) ? step(vec3(tN),t1) : // ro ouside the box\n                           step(t2,vec3(tF));  // ro inside the box\n    outNormal *= -sign(rd);\n    return vec2( tN, tF );\n}\n\n\nvoid panTiltAngles(vec3 P, vec3 v, vec3 T, out float pan, out float tilt) {\n    // Calculer le vecteur direction vers T dans l'espace local de P -> (T-P) - P\n    vec3 directionToT = normalize(T - 2.*P);\n    vec3 vLocal = normalize(v);\n    // Calculer l'angle de rotation autour de l'axe y (pan)\n    pan = atan(directionToT.x, directionToT.z)- atan(vLocal.x, vLocal.z);\n    tilt = -asin(directionToT.y)+ asin(vLocal.y);\n}\n\n\n\n\nfloat sdLine(vec3 p, float pan, float tilt)\n{\n    // c is the sin/cos of the angle\n    vec3 c = vec3(0.);\n    c.z = .01;\n    mat3 txx = rot3D(0., tilt,pan,0.);\n    p = txx*p;\n    return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat mapBox(vec3 p, vec3 pos, vec3 target, float pan, float tilt){\n    vec3 p1 = p-pos;\n    p1 = rot3D(0., tilt,pan,0.)*p1;\n    float d = sdBox(p1, vec3(.08,.13,.08));\n   \n    vec3 p2 = p-target;\n    d = min(d,sdBox(p2, vec3(.2,.2,.2)));\n    return d;\n}\n\n\nfloat rayMarchLine(vec3 ro, vec3 rd, vec3 pos, vec3 target, float pan, float tilt, float angle){\n    float depth = 0.;\n    float hit = 0.;\n    vec3 pL = vec3(0.);\n    vec3 pB = vec3(0.);\n    for (int i = 0; i<20; i++){\n        pL = ro + rd*depth;\n        if (abs(pL.y) > 1. || abs(pL.z)>4. || abs(pL.x)>2.) break;\n        float d = sdLine(pL-pos, pan, tilt);\n        if (d<.001){\n            hit = 1.;\n            break;\n        }\n        depth += d;\n    }\n    if (hit == 1.){\n        for (int i = 0; i<20; i++){\n            pB = ro + rd*depth;\n            float d = mapBox(pB, pos, target, pan, tilt);\n            if (d<.001){\n                if (pB.z < pL.z){\n                    hit = 0.;\n                    break;\n                }\n            }\n            depth += d;\n        }\n    }\n    return hit;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}