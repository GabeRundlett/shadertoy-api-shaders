{
    "Shader": {
        "info": {
            "date": "1654762344",
            "description": "One way that I've developed to compute the square and cube root of a number without using sqrt(), pow() or exp(log(x)/n). Grey,: hardware implementation. Colored: the technique here.",
            "flags": 0,
            "hasliked": 0,
            "id": "ssyyDh",
            "likes": 23,
            "name": "Cube and Square Root",
            "published": 3,
            "tags": [
                "2d",
                "cube",
                "newton",
                "exponent",
                "root",
                "cbrt",
                "cuberoot",
                "7544"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 1186
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// One way to compute roots without using sqrt(), pow()\n// or exp(log(x)/n). I'm not claiming this is the fastest \n// (in modern hardware) nor the best method.\n//\n// I based it on extracing the exponent of the number and\n// dividing it by 2 or 3 and then applying two Newton-Raphson\n// iterations. As mla pointed out in the comments, you can do\n// this to the whole number, not just the exponent.\n//\n// 709973695 and 532545536 minimize the error in the\n// interval 0 to 1000. I found them by looking in the\n// neigborhood of (127-127/3)*(2^23) and (127-127/2)*(2^23),\n// which are the adjustment to the exponent bias needed\n// after the raw division by 3 and 2 respectivelly.\n\nfloat my_cbrt( float x )\n{\n    float y = uintBitsToFloat(709973695u+floatBitsToUint(x)/3u);\n    y = y*(2.0/3.0) + (1.0/3.0)*x/(y*y);\n    y = y*(2.0/3.0) + (1.0/3.0)*x/(y*y);\n    return y;\n}\n\nfloat my_sqrt( float x )\n{\n    float y = uintBitsToFloat(532545536u+(floatBitsToUint(x)>>1));\n    y = 0.5*(y+x/y);\n    y = 0.5*(y+x/y);\n    return y;\n}\n\n// exactly the same as above, but with a single division\nfloat my_sqrt_single_division( float x )\n{\n    float y = uintBitsToFloat(532545536u+(floatBitsToUint(x)>>1));\n    float y2 = y*y, x2=x*x;\n    return (y2*(y2+6.0*x)+x2) / (4.0*y*(y2+x));\n}\n\n//------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2  p  = 4.0*fragCoord/iResolution.x;\n    float px = 4.0/iResolution.x;\n\n    float al = smoothstep(-0.1,0.1,sin(6.283185*iTime));\n\n    vec3 col = vec3( 0.1 + 0.05*mod(floor(p.x)+floor(p.y),2.0) );\n    \n    // hardware pow()\n    {\n    float y = pow( p.x, 1.0/3.0 );\n    float d = abs(p.y-y)/sqrt(1.0+pow(p.x,-4.0/3.0)/9.0 ); // https://iquilezles.org/articles/distance/\n    col = mix( col, vec3(0.5,0.5,0.5), 1.0-smoothstep(0.0,1.5*px,d) );\n    }\n    // my implementation\n    {\n    float y = my_cbrt( p.x );\n    float d = abs(p.y-y)/sqrt( 1.0+pow(p.x,-4.0/3.0)/9.0 ); // https://iquilezles.org/articles/distance/\n    col = mix( col, vec3(1.0,1.0,0.0), al*(1.0-smoothstep(0.0,1.5*px,d)) );\n    }    \n    // hardware sqrt()\n    {\n    float y = sqrt( p.x );\n    float d = abs(p.y-y)/sqrt(1.0+1.0/(4.0*p.x) ); // https://iquilezles.org/articles/distance/\n    col = mix( col, vec3(0.5,0.5,0.5), 1.0-smoothstep(0.0,1.5*px,d) );\n    }\n    // my implementation\n    {\n    float y = my_sqrt( p.x );\n    float d = abs(p.y-y)/sqrt(1.0+1.0/(4.0*p.x) ); // https://iquilezles.org/articles/distance/\n    col = mix( col, vec3(0.0,1.0,1.0), al*(1.0-smoothstep(0.0,1.5*px,d)) );\n    }    \n    \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}