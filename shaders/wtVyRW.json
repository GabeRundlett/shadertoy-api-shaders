{
    "Shader": {
        "info": {
            "date": "1610648909",
            "description": "reference:  image from Tyler Hobbs Art \n[img]https://i.imgur.com/uiKQAeR.png[/img]\nmore: [url]https://tylerxhobbs.com/essays/2020/flow-fields[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "wtVyRW",
            "likes": 23,
            "name": "field art",
            "published": 3,
            "tags": [
                "flow",
                "field",
                "lic",
                "reproduction"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 772
        },
        "renderpass": [
            {
                "code": "// sampling inspired from https://www.shadertoy.com/view/lljczz\n\n#define srnd(p,s) ( 2.* fract( 4e4* sin( 1e3* mat2(1,7.1,-5.1,2.3) * (p) + 1e3*s )) -1. )\n#define SQR(x)    ( (x)*(x) )\n\n#define f(U) sin( vec2(5,3)*(U) + cos( (U)*mat2(3,10,-4,1) ) )\n//#define f(U) sin( mat2(5,1,3,2)*U + cos( U*mat2(3,10,-4,1) ) )\n\nvoid mainImage( out vec4 O,  vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = (2.*u-R)/R.y, p, P, X,V, x;\n    O-=O;\n         \n    float v, n =   11., // R.y/32., // 11.                // number of cells (optim)\n          l = .08,                                        // stokes length\n          d = min( 90.*pow((1.-U.y)/2.,1.7)*R.y/360., 2e2);   // strokes density\n    int N = 3; // int(3.*R.y/360.);                       // Neighborhood size = NxN . goes with l\n\n    p = floor(U*n+.5) / n;                                // cell center (NB: we should deffered /n )\n\n    for( int i=0; i<N*N; i++)                             // Worley optim. allows overflow to neighbor cell\n      for( float j=0.; j<d; j++) {                        // density loop\n        P = p + vec2( i%N -N/2, i/N -N/2 ) / n;           // cell coordinate in neighborhood\n        P +=     .5* srnd( round(P*n) , j) / n;           // jittering (round: for precision issues)\n        X = U-P,                                          // local coordinate\n        V =  f(.5*U);    // f(.5*P)                       // local field. f(U): curvy f(P): tangent \n     // V = vec2( -dFdy(V.x),dFdx(V.x) ) * R.y;           // divergence-free  (WIP)  \n#if 1\n        v = dot ( X , V );                                // distance to segment\n     // v /= fwidth(v);\n        v /= length(V) * 2.5/R.y;\n        O += (1.-O)*                                      // blend ( comment out for add )\n             .5*   max( 0., 1. - 1.3*abs(v) )             // draw segment of dir V and length .04\n               * clamp( ( l - length(X) ) *R.y ,0.,1.);\n#else                                                     // trying thinner AA (WIP)\n        x = 2.*(n*X)-0.;\n     // v = 2.*sqrt( max(0.,  1. - dot(x,x) + SQR(dot(x,V))/dot(V,V) ) );  \n        float b = dot(x,V)/length(V),c=dot(x,x)-1., d = b*b-c, m,M;  // |X+kV/V|Â²=1 , clamped to [-l,l]\n        v = d>0. ? min(l*2.*n,-b+sqrt(d)) - max(-l*2.*n,-b-sqrt(d)) : 0.; // segment - pixel-disk intersection length\n        O += v*40./R.y;\n#endif\n}\n    \n    O -=  max(0., length(U)-.8 ) *R.y;                    // white out of circle\n    O = sqrt(1.-O);                                       // reverse + to sRGB\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}