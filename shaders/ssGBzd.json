{
    "Shader": {
        "info": {
            "date": "1658877308",
            "description": "Forked from gcgac's 4D and 5D raymarchers. Shows a 3D cross section of an nD scene where n is an arbitrary number. The balls are not changing size; only the camera position is changing. Hold mouse 1: X is -30 to 30 on 4th axis, Y is -30 to 30 on 5th axis.",
            "flags": 0,
            "hasliked": 0,
            "id": "ssGBzd",
            "likes": 1,
            "name": "n-dimensional raymarcher",
            "published": 3,
            "tags": [
                "raymarching",
                "raymarcher",
                "4d",
                "5d"
            ],
            "usePreview": 0,
            "username": "u004fu0077u004f",
            "viewed": 237
        },
        "renderpass": [
            {
                "code": "// [vvv] TRY CHANGING THIS [vvv]\n#define DIMENSIONS 6\n// [^^^] TRY CHANGING THIS [^^^]\n#define vecn float[DIMENSIONS]\nvecn vecn_add(vecn a, vecn b) {\n    vecn c;\n    for (int i=0; i<DIMENSIONS; ++i) c[i] = a[i]+b[i];\n    return c;\n}\nvecn vecn_sub(vecn a, vecn b) {\n    vecn c;\n    for (int i=0; i<DIMENSIONS; ++i) c[i] = a[i]-b[i];\n    return c;\n}\nvecn vecn_sub(vecn a, float b) {\n    vecn c;\n    for (int i=0; i<DIMENSIONS; ++i) c[i] = a[i]-b;\n    return c;\n}\nvecn vecn_mul(vecn a, float b) {\n    vecn c;\n    for (int i=0; i<DIMENSIONS; ++i) c[i] = a[i]*b;\n    return c;\n}\nfloat vecn_length(vecn a) {\n    float len = 0.;\n    for (int i=0; i<DIMENSIONS; ++i) len += a[i]*a[i];\n    return sqrt(len);\n}\nvecn vecn_normalize(vecn a) {\n    float len = 0.;\n    for (int i=0; i<DIMENSIONS; ++i) len += a[i]*a[i];\n    len = sqrt(len);\n    vecn c;\n    for (int i=0; i<DIMENSIONS; ++i) c[i] = a[i]/len;\n    return c;\n}\nfloat vecn_distance(vecn a, vecn b) {\n    float dist = 0.;\n    for (int i=0; i<DIMENSIONS; ++i) {\n        float c = abs(a[i]-b[i]);\n        dist += c*c;\n    }\n    return sqrt(dist);\n}\nconst int rand_w = 64;\nint rand_i;\nfloat rand() {\n    vec4 texel = texelFetch(iChannel0, ivec2(rand_i%rand_w, rand_i/rand_w), 0);\n    switch ((rand_i++)%4) {\n        case 0:\n            return texel.r;\n        case 1:\n            return texel.g;\n        case 2:\n            return texel.b;\n        default:\n            return texel.a;\n    }\n}\nvec3 rgb;\nfloat sde;\nvecn pos;\nconst float maxl = 10000.0;\nfloat t;\nfloat sphere_sde(vecn ray, vecn position, float radius, vec3 col) {\n    float d = vecn_distance(position, ray)-radius;\n    if (d < sde) {\n        rgb = col;\n        sde = d;\n    }\n    return d;\n}\nfloat calc_sdf(vecn ray) {\n    sde = maxl;\n    #if DIMENSIONS == 4\n        float d1 = sphere_sde(ray, vecn(-20.0,  0.0, 70.0,  10.0), 20.0, vec3(1, 0, 0));\n        float d2 = sphere_sde(ray, vecn(  0.0,  0.0, 70.0, -20.0), 20.0, vec3(0, 0, 1));\n        float d3 = sphere_sde(ray, vecn(-10.0, 15.0, 75.0,  30.0), 30.0, vec3(0, 1, .5));\n    #else\n        rand_i = 0;\n        for (int i=0; i<DIMENSIONS; ++i) {\n            vecn position;\n            position[0] = (rand()*2.-1.)*20.;\n            position[1] = (rand()*2.-1.)*10.;\n            position[2] = (rand()*2.-1.)*5.+70.;\n            for (int i=3; i<DIMENSIONS; ++i) position[i] = (rand()*2.-1.)*30.;;\n            float radius = rand()*10.+20.;\n            vec3 col = vec3(rand(), rand(), rand());\n            sphere_sde(ray, position, radius, col);\n        }\n    #endif\n    return sde;\n}\nvec4 raycol(vecn orig, vecn dir, float ml) {\n    float len = 0.0;\n    float sde = ml;\n    float steps = 0.0;\n    pos = orig;\n    while (len < ml && sde > 0.1) {\n        sde = calc_sdf(pos);\n        pos = vecn_add(pos, vecn_mul(dir, sde));\n        len += sde;\n        steps += 1.0;\n    }\n    return vec4(rgb, steps);\n}\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vecn pos;\n    pos[0] = 0.;\n    pos[1] = 0.;\n    pos[2] = -11.;\n    for (int i=3; i<DIMENSIONS; ++i) {\n        pos[i] = cos((float(i)/float(DIMENSIONS)+1.)*iTime)*20.;\n    }\n    #if DIMENSIONS >= 4\n        if (iMouse.z > 0.) {\n            pos[3] = (iMouse.x/iResolution.x*2.-1.)*30.;\n            #if DIMENSIONS >= 5\n                pos[4] = (iMouse.y/iResolution.y*2.-1.)*30.;\n            #endif\n        }\n    #endif\n    vecn direction;\n    direction[0] = uv.x;\n    direction[1] = uv.y;\n    direction[2] = 1.;\n    for (int i=3; i<DIMENSIONS; ++i) direction[i] = 0.; // \"aRrAy CoNsTrUcToR nEeDs OnE aRgUmEnT pEr ArRaY eLeMeNt\"\n    direction = vecn_normalize(direction);\n    vec4 o;\n    float steps;\n    o = raycol(pos, direction, 1000.0);\n    if (sde <= 0.1) {\n        steps = o.w;\n        rgb = o.xyz;\n        rgb /= steps/2.0;\n        fragColor = vec4(rgb, 1.0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}