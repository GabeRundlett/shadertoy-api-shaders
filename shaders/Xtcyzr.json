{
    "Shader": {
        "info": {
            "date": "1531299144",
            "description": "Influence of environmental variation on a large-scale ecological model. Vegetation (green) growth rate varies with time, prey (blue) birthrate increases along y-axis, and predator (red) effectiveness along x-axis.",
            "flags": 32,
            "hasliked": 0,
            "id": "Xtcyzr",
            "likes": 29,
            "name": "Lotka-Volterra diffusion",
            "published": 3,
            "tags": [
                "simulation",
                "diffusion",
                "reaction",
                "predator",
                "prey",
                "ecology",
                "population"
            ],
            "usePreview": 0,
            "username": "davidar",
            "viewed": 60686
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float vege = buf(fragCoord).x;\n    float prey = buf(fragCoord).y * 2.;\n    float pred = buf(fragCoord).z;\n\n    fragColor = vec4(0,0,0,1);\n    fragColor = mix(fragColor, vec4(0., 1., 0.1, 1), smoothstep(0., 10., vege - prey - pred));\n    fragColor = mix(fragColor, vec4(0., 0.5, 1., 1), smoothstep(0., 10., prey - pred));\n    fragColor = mix(fragColor, vec4(0.5, 0., 0., 1), smoothstep(0., 10., pred));\n\n    float plant_growth = 0.75 - 0.25 * cos(2.*PI * iTime / 60.);\n    if (iTime < 30.) plant_growth = 1.;\n\n    vec2 uv = fragCoord / iResolution.xy;\n    if (uv.y < 0.02) fragColor = vec4(0,0,0,1);\n    if (uv.y < 0.01 && uv.x < plant_growth) fragColor = vec4(0., 1., 0.1, 1);\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(1./2.2));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (iFrame < 10) {\n        fragColor.xyz = hash32(fragCoord) * vec3(0.5, 1., 2.);\n        return;\n    }\n\n    vec4 c = buf(fragCoord);\n    vec4 n = buf(fragCoord + N);\n    vec4 e = buf(fragCoord + E);\n    vec4 s = buf(fragCoord + S);\n    vec4 w = buf(fragCoord + W);\n\n    float plant_growth = 0.75 - 0.25 * cos(2.*PI * iTime / 60.);\n    if (iTime < 30.) plant_growth = 1.;\n    float reproduction = 2. * fragCoord.y / iResolution.y;\n    float predation = 0.9 + 1.1 * fragCoord.x / iResolution.x;\n\n    // generalised Lotka-Volterra equations\n    float dx = plant_growth - c.y;\n    float dy = reproduction * c.x - predation * c.z - 1.;\n    float dz = predation * c.y - 1.;\n    float dt = 0.1;\n    c.xyz += dt * c.xyz * vec3(dx, dy, dz);\n    c = clamp(c, 0.01, 10.);\n\n    // diffusion\n    c.xyz += dt * (n + e + s + w - 4. * c).xyz * vec3(0.25, 0.5, 1.);\n\n    fragColor = c;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define buf(p) texture(iChannel0,(p)/iResolution.xy)\n\n#define N vec2( 0, 1)\n#define E vec2( 1, 0)\n#define S vec2( 0,-1)\n#define W vec2(-1, 0)\n\n#define PI 3.14159265359\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n// https://www.shadertoy.com/view/4djSRW\n// Trying to find a Hash function that is the same on ALL systens\n// and doesn't rely on trigonometry functions that change accuracy \n// depending on GPU. \n// New one on the left, sine function on the right.\n// It appears to be the same speed, but I suppose that depends.\n\n// * Note. It still goes wrong eventually!\n// * Try full-screen paused to see details.\n\n\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n//#define HASHSCALE1 443.8975\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n        vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n        vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n        p3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n        vec3 p3 = fract(vec3(p) * HASHSCALE3);\n        p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n        vec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n        vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n        vec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n        p4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}