{
    "Shader": {
        "info": {
            "date": "1640316072",
            "description": "bum chack bum chack chack",
            "flags": 8,
            "hasliked": 0,
            "id": "NlySRw",
            "likes": 12,
            "name": "testing fdn stuff",
            "published": 3,
            "tags": [
                "sound",
                "reverberation",
                "fnd"
            ],
            "usePreview": 0,
            "username": "nabr",
            "viewed": 395
        },
        "renderpass": [
            {
                "code": "// char by FabriceNeyret2\n#define char(_p,_C)(((_p.x<0.||_p.x>1.||_p.y<0.||_p.y>1.))?vec4(0,0,0,1e5):textureGrad(iChannel3,_p/16.+fract(vec2(_C,15-_C/16)/16.),dFdx(_p/16.),dFdy(_p/16.)))\n\n\n#define T iTime\n#define R iResolution.xy\n\nfloat f(vec3 p){return 6.-(length(smoothstep(-.3,.3,pow(fract(.8*vec3(p.xy,T+p.z)),vec3(cos(T)+1., sin(T)*.7+.7, .5))))+max(p.x,1.+p.y));}\nvoid mainImage(out vec4 O,in vec2 U)\n{\n    //tunnel\n    vec2 u=(U-.5*R)/min(R.x,R.y),e=vec2(.001,-.001);\n    vec3 p,n;float t;\n    for(int i=0;i<32;i++)\n    O=vec4(.7*max(dot(normalize(vec3(2,.5,fract(T)*5.)-p),\n    float((t+=.5*f(p=vec3(abs(u),.2)*t))>1.)\n    *normalize(e.yxx*f(p+e.yxx)+e.xxy*f(p+e.xxy)+e.xyx*f(p+e.xyx)+e.yyy*f(p+e.yyy)))\n    -(cos(t*.3+T)*.5+.5)*vec3(.1,.7,0.65),0.),1);\n    \n     //print char sound in\n     u = vec2(.5+sin(2.*u.y+2.*T), -1.5)+u*(6.+T);\n     for(int i = 0; i < 7; ++i){\n     O += char(u,int[](83, 111, 117, 110, 100, 105, 110)[i]).x*max(0., 1.-T*.2);\n     u.x -= 1.5;\n     u*= mat2(0.6,-.8,.8, .6);\n     }\n     \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// Minimalist implantation of the idea behind a Feedback Delay Network\n// Usually it is sampel-based, works on the Time Domain, Circular Buffer. Good use for Compute-shader design.\n// I adopted the idea for my personal GPU-Sound workflow.\n// I wrote some commentes: when i say original scemata i mean \n// https://ccrma.stanford.edu/~jos/pasp/Feedback_Delay_Networks_FDN.html\n// some code in C https://github.com/bmFicg/audioexp/blob/master/fdn/main.c\n\n// License - CC0 or use as you wish\n\n\n\n\n//=====================  music sequencer by gaz\n// https://www.shadertoy.com/view/ftdXzs\n\n// sound source\n#define PI acos(-1.)\n#define PIH (PI * .5)\n#define TAU (PI * 2.)\n#define osc_sin(x) sin((x) * TAU)\n#define osc_saw(x) (1. - fract(x) * 2.)\n#define osc_sqr(x) sign(.5 - fract(x))\n#define osc_tri(x) (asin(sin((x) * PI)) / PIH)\n \nfloat noize(float t,  float a, float b){\n    float g = fract(cos(t * exp2(a)) * exp2(b)) + 6.;\n    return exp(-.08 * g * g) * 40. - 1.;\n}\n\nfloat kick(float t)\n{\n    return clamp(1.5 * asin(cos(320. * t -30.0 * exp(-40. * t))),\n                   -1.,\n                    1.\n                 ) * exp(-4. * t);\n}\n\nfloat snare(float t){\n    float n = noize(t, 10., 10.) * exp(-t * 10.);\n    float f = t * 160.;\n    float a = .3 * osc_tri(1.2 * f) * exp(-t * 3.);\n    float b = .05 * osc_sin(10. * f + a) * exp(-t * 3.);\n    float c = osc_sin(f + b) * exp(-t * 15.);\n    return n + c;\n}\n\nfloat hihat(float t){\n    return noize(t, 10., 18.) * exp(-t * 15.);\n}\n\nfloat OFFSET;\nint TMP, POS, IDX;\n#define EXTRACT(m, a)\\\n{\\\n    TIME = mod(TIME, barTime);\\\n    IDX = -1;\\\n    float b, c;\\\n    for(int i = 0; i < m; i++){\\\n        b = barTime / float(m);\\\n        c = float(int[]a[i % int[]a.length()]);\\\n        if(c > 0.) OFFSET = 0.;\\\n        if(TIME < b) break;\\\n        IDX += int(c);\\\n        TIME -= b;\\\n        OFFSET += b / max(1., c);\\\n    }\\\n    if(c > 0.)IDX += int(TIME / b * c) + 1;\\\n    TIME = mod(TIME, b / max(1., c));\\\n    TIME += OFFSET;\\\n}\n    \n// Rhythm( beat<Number of divisions per bar> , Array of beat divisions )\n// Arrays are enclosed in `()`\n// I'm using a trick on the macro to free the array size\n// If it is the same array, it will be repeated even if it is omitted.\n#define Rhythm(m, a)\\\n    TMP++;\\\n    if(POS == TMP) EXTRACT(m, a)\n// Info( Array of int information )\n// Arrays are enclosed in `()`\n// I'm using a trick on the macro to free the array size\n// If it is the same array, it will be repeated even if it is omitted.\n#define Info(a)\\\n    if(POS == TMP) INF = int[]a[IDX % int[]a.length()];\n\n// Reset every time you change the information.\n#define Reset \\\n    OFFSET = 100.;\\\n    TIME = time;\\\n    TMP = -1;\\\n    POS = int(time / barTime);\n// Loop( Number of measures to repeat )\n#define Loop(n)\\\n    TIME = mod(TIME, barTime * float(n));\\\n    POS %= n;\n\nvec2 mSound(float time ){\n    float bpm = 120.;\n    // One bar time\n    float barTime = 240. / bpm;\n    // Time to input to the sound source\n    float TIME;\n    // Current information\n    int INF;\n    float gain = 0.;\n\n    Reset;\n    Loop(1)\n    Rhythm(2, (1))\n    gain = .6 * kick(TIME);\n\n    Reset;\n    Loop(1)\n    Rhythm(4, (0, 1, 0, 2)) \n    gain += .5 * snare(TIME);\n      \n    return .5 * clamp(1.5 * vec2(gain), -1., 1.);\n}\n\n\n//=====================   major7_chord by lil_chickehh\n// https://www.shadertoy.com/view/ftdSDB\n// Intervals:\nconst float intrvls[12] =float[12](1.0, 1.059463094, 1.122462048, 1.189207115, 1.259921049,1.334839854, 1.414213562, 1.498307076, 1.587401051, 1.681792830,1.781797436, 1.887748625);\n\n\n\n//===================== FEEDBACK DELAY NETWORK\nvoid bfdn(inout vec4 s, const in mat4 M, in uint i) \n{\n    i = i % 4u;\n    s += (s[0] * M[0][i] + s[1] * M[i][i] + s[2] * M[i][i] + s[3] * M[i][i]);\n         //original scemata can be simplified to a dot function\n         //(s[0] * M[i][0] + s[1] * M[i][1] + s[2] * M[i][2] + s[3] * M[i][3]); \n}\n\n\n#define _f(_x)(fract(_x))\n#define cs(_s, _r)(sin(_s)*_r+_r)\nfloat inst(in float t, const in uint i) \n{\n    float y = 0., f1 = 0., f0a = 0., f2 = 0., f3 = 0.;\n    float ft1 = _f(2. * t), ft0 = _f(3. * t);\n    \n    float n = (t * 214013.);//noise\n    \n    int p0 = mod(t, 6.) > 4. ? 2 : 0;\n    int p1 = mod(t, 2.) > 1. ? 4 : mod(t, 3.) > 2. ? 6 : 9;\n    ivec4 itv = ivec4(p0, p1, 7, 11);\n    \n    f1 = sin(TAU * intrvls[itv[i % 4u]] * 120. * t);\n    f1 *= min(1., 10. * ft1) * max(0., 1. - ft1);\n    \n    //original scemata has comp filters replaced with some phase shift funtion\n    f2 = cos(4. * f1) / (1.751225 + sin(f1 + .5 * _f(n * _f(t + n))));\n    \n    f2 *= 20. * mix(1.99994, 1., cs(t, .5));\n    f2 *= min(1., 30. * ft0) * max(0., 1. - ft0);\n    \n    y = clamp(cs(t, .255) * f1 + .7 * (.5 + f2), -.3, .3);\n    \n    return t<6.?mSound(t).x : .9 * mSound( t).x  +(.25 * f1 + y);\n}\n\nvec2 mainSound(in int samp, float time) \n{\n    vec2 r = vec2(1e-6);\n    float y = 0., y1 = 0., y3 = 0., y2 = 0., y4 = 0.;\n   \n    mat4 A = mat4(0, -1., 1., 0, 1., 0, 0, 1., 1., 0, 0, -1., 0, -1., -1., 0) * (1. / sqrt(2.)); //hadamard matrix, transposed to collum wise\n    vec4 dt = vec4(577, 601, 641, 661);//primes to-do: bigger kernel size\n    \n    float mt = float(samp) * (1./iSampleRate);\n    float dlt = mt;\n    \n    //phaser helps with resonnance howling tone, original scemata has comp filters \n    float vt = mt;\n    vec4 ehp = 1e-4 * vec4(17. * cos(vt), -15. * sin(vt), 12. * sin(vt),11. * cos(vt)) ;\n    \n    //gain coefficient - room size\n    float g1 = .0001 * mix(3., 9.125, step(mod(time, 12.), 6.));\n    \n    \n    const uint sz = 12u;\n    for (uint j = 0u; j < 3u; j++) //inc. or decrease density\n        for (uint i = 0u; i < sz; ++i) \n        {\n            \n            {\n                y1 = inst((dlt + (ehp.x + ehp.z)), i);\n                y2 = inst((dlt + (ehp.y + ehp.w)), i);\n                y3 = inst(dlt, i);\n                y4 = inst(dlt, i);\n                \n                //multi channel split\n                float v[sz]; //unroll for some mobile\n                //v = float[](y2, y3, y3, y2, y1, y4, y4, y1, y4, y3, y1, y2);\n                 v[0]=y2;v[1]=y3;v[2]=y3;v[3]=y2;v[4]=y1;v[5]=y4;v[6]=y4;v[7]=y1;v[8]=y4;v[9]=y3;v[10]=y1;v[11]=y2;\n                (i % 2u == 0u) ? (r.x += v[i % sz]) : (r.y += v[i % sz]);\n                \n                // stacking, advance delay line\n                bfdn(dt, A, (i + 0u));\n                bfdn(dt, A, (i + 1u));\n                bfdn(dt, A, (i + 2u));\n                bfdn(dt, A, (i + 3u));\n                \n                \n                dlt += (dt.x + dt.y + dt.z + dt.w) / float(18) //decay dump oversampled-late delays\n                                                      * g1;   \n                }\n        }\n \n    //dry\n    for(uint h = 0u; h < 3u; h++)y += .25 * inst(dlt, h);\n    \n    //out\n    return y + (r /= 12.);\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}