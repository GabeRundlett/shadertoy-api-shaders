{
    "Shader": {
        "info": {
            "date": "1680621107",
            "description": "A proof of concept. I use Cubemap A to generate and store a 128x128x128 cube of PBR materials; this can be generated in frame 0 and stored indefinitely. I then march rays through and use some linear interpolation to find edges, which are then rendered.",
            "flags": 32,
            "hasliked": 0,
            "id": "mstSWS",
            "likes": 4,
            "name": "Voxel Mosque",
            "published": 3,
            "tags": [
                "cube",
                "voxel",
                "cubemap",
                "cubemapa"
            ],
            "usePreview": 0,
            "username": "thepinkpanzer",
            "viewed": 369
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 raw   = texture(iChannel0, fragCoord/iResolution.xy);\n    vec4 bloom = texture(iChannel1, fragCoord/iResolution.xy)/BLOOMRADIUS; //(Division is to normalize the Gaussians)\n    // Combining. I use the tanh() to soften high-brightness regions; it's all down to taste here.\n    fragColor = (tanh(0.8*pow(raw,vec4(1.2)) + 0.4*bloom));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Random generation functions.\nvoid Vines(vec3 pos, vec3 scale, float density, inout Material material)\n{\n    float fill = (texture(iChannel1, fract(pos*32.))-0.5).r\n                +(texture(iChannel1, fract(pos*21.))-0.5).g*2.;\n                +(texture(iChannel1, fract(pos*43.))-0.5).b*0.5;\n    fill = fill - (length((pos.xyz-vec3(0,0.5,0))*scale)) + density;\n    if (pos.y < 0.)\n    {\n        if (fill > 0.)\n        {\n            material = Material(fill, vec3(0.4,0.9,0.2), vec3(0), 0.7, 0.3);\n        }\n        else\n        {\n            material.fill = max(material.fill, fill);\n        }\n    }\n}\nfloat Random(float seed)\n{\n    seed *= (952.453-seed);\n    seed  = fract(seed);\n    seed *= (152.453-seed);\n    seed  = fract(seed);\n    return seed;\n}\nvoid Rock(float fill, vec3 worldPos, inout Material material)\n{\n    float seed = texture(iChannel1, fract(worldPos)).r;\n    if (fill > 0.)\n    {\n        fill*= 1.-0.2*Random(seed);\n    }\n    material = Material(fill, vec3(0.8, 0.6, 0.45)+(2.*Random(seed+1.)-1.)*vec3(0.1,0.08,0.04)+(2.*Random(seed+2.)-1.)*vec3(0.03,-0.01,0.), vec3(0.), 0.1, 0.1);\n}\nvoid Rock2(float fill, vec3 worldPos, inout Material material)\n{\n    float seed = texture(iChannel1, fract(worldPos)).r;\n    if (fill > 0.)\n    {\n        fill*= 1.-0.1*Random(seed);\n    }\n    material = Material(fill, vec3(1.0, 0.9, 0.75)+(2.*Random(seed+1.)-1.)*vec3(0.06,0.05,0.04)+(2.*Random(seed+2.)-1.)*vec3(0.03,-0.01,0.), vec3(0.), 0.1, 0.1);\n}\nvoid Orange(float fill, inout Material material)\n{\n    material = Material(fill, vec3(1.0, 0.35, 0.15), vec3(0.), 0.1, 0.1);\n}\nvoid Blue(float fill, inout Material material)\n{\n    material = Material(fill, vec3(0.2, 0.3, 1.0), vec3(0.), 0.1, 0.1);\n}\nvoid Gold(float fill, inout Material material)\n{\n    material = Material(fill, vec3(1.0,0.7,0.16), vec3(0.), 0.5,0.9);\n}\nMaterial BuildWorld(vec3 worldPos)\n{\n    /*\n    Returns the material as a function of position. Building the universe!\n    \n    Remember that the Material constructor is:\n    Material(fill, vec3(albedo), vec3(emission), smoothness, metallic)\n    \n    This only should run once, so you can make it as horrifically complicated as you want :)\n    */    \n    Material material = Material(-10., vec3(0), vec3(0), 0., 0.);\n    \n    float fill = -10.;\n    float newFill;\n    \n    // Background\n    float bumpFill = -min(worldPos.x+0.4, worldPos.z+0.4)*200.;\n    bumpFill+=  sin(worldPos.x*30.+10.)*sin(worldPos.z*30.+18.)*sin(worldPos.y*0.4+43.)*5.;\n    bumpFill+=  sin(worldPos.x*80.+62.)*sin(worldPos.z*80.+30.)*sin(worldPos.y*20.+25.)*2.0;\n    bumpFill+=  sin(worldPos.x*70.+25.)*sin(worldPos.z*70.+60.)*sin(worldPos.y*12.+58.)*1.6;\n    bumpFill+=  sin(worldPos.x*40.+41.)*sin(worldPos.z*40.+80.)*sin(worldPos.y*8.+46.)*1.2;\n    \n    float smoothFill = length(pow((0.5-worldPos), vec3(5.,0.1,5.)));\n    \n    newFill = (smoothFill-0.6)*(1.-smoothstep(-0.4, 0.1,worldPos.y));\n    newFill+= bumpFill        *(   smoothstep(-0.4, 0.1,worldPos.y))*(1.-smoothstep(0.1,0.5,worldPos.y));\n    newFill+= (smoothFill-0.9)*(   smoothstep(0.1,0.5,worldPos.y));\n    if (newFill > fill)\n    {\n        fill = newFill;\n        Rock(fill, worldPos, material);\n    }\n    \n    // Mosque main block\n    vec3 deltaPos = worldPos - vec3(0.05,-0.4,0.05);\n    deltaPos     /= vec3(0.3, 0.25, 0.3);\n    deltaPos      = abs(deltaPos);\n    newFill = 0.8-max(deltaPos.x, max(deltaPos.y, deltaPos.z));\n    if (newFill > fill)\n    {\n        fill = newFill;\n        Rock2(fill, worldPos, material);\n    }\n    \n    // Mosque main dome\n    deltaPos = worldPos - vec3(0.05,-0.18,0.05);\n    newFill = 0.15-length(deltaPos);\n    if (newFill > fill)\n    {\n        fill = newFill;\n        Gold(fill, material);\n    }\n\n    // Mosque main dome top orb\n    deltaPos = worldPos - vec3(0.05,-0.02,0.05);\n    newFill = 0.03-length(deltaPos);\n    if (newFill > fill)\n    {\n        fill = newFill;\n        Gold(fill, material);\n    }\n    \n    // Mosque spire\n    deltaPos = worldPos - vec3(0.05,0.15,0.05);\n    newFill  = deltaPos.y < 0. ? 0.03+length(deltaPos.xz)/deltaPos.y : -10.;\n    if (newFill > fill)\n    {\n        fill = newFill;\n        Gold(fill, material);\n    }\n    \n    // Mosque side blocks\n    deltaPos = worldPos - vec3(0.05,-0.4,0.05);\n    deltaPos      = abs(deltaPos);\n    deltaPos     -= vec3(0.22,0,0.22);\n    deltaPos     *= vec3(10., 4., 10.);\n    deltaPos      = abs(deltaPos);\n    newFill = 1.-max(deltaPos.x, max(deltaPos.y, deltaPos.z));\n    if (newFill > fill)\n    {\n        fill = newFill;\n        Rock2(fill, worldPos, material);\n    }\n    \n    // Mosque side domes\n    deltaPos = worldPos - vec3(0.05,-0.15,0.05);\n    deltaPos      = abs(deltaPos);\n    deltaPos     -= vec3(0.22,0,0.22);\n    newFill = 0.08-length(deltaPos);\n    if (newFill > fill)\n    {\n        fill = newFill;\n        Gold(fill, material);\n    }\n    \n    // Mosque blue stripes\n    deltaPos      = worldPos - vec3(0.05,-0.4,0.05);\n    deltaPos      = abs(deltaPos);\n    deltaPos     -= vec3(0.22,0,0.22);\n    deltaPos     *= vec3(10., 4., 10.);\n    deltaPos      = abs(deltaPos);\n    deltaPos     -= vec3(0.6, 0, 0);\n    deltaPos     *= vec3(10., 1.4, 0.9);\n    deltaPos      = abs(deltaPos);\n    newFill       = 1.-max(deltaPos.x, max(deltaPos.y, deltaPos.z));\n    \n    deltaPos      = worldPos - vec3(0.05,-0.4,0.05);\n    deltaPos      = abs(deltaPos);\n    deltaPos     -= vec3(0.22,0,0.22);\n    deltaPos     *= vec3(10., 4., 10.);\n    deltaPos      = abs(deltaPos.zyx);\n    deltaPos     -= vec3(0.5, 0, 0);\n    deltaPos     *= vec3(10., 1.4, 0.9);\n    deltaPos      = abs(deltaPos);\n    newFill       = max(newFill, 1.-max(deltaPos.x, max(deltaPos.y, deltaPos.z)));\n    if (newFill > fill)\n    {\n        fill = newFill;\n        Blue(fill, material);\n    }\n    \n    // Mosque orange blocks\n    deltaPos = worldPos - vec3(0.05,-0.4,0.05);\n    deltaPos      = abs(deltaPos);\n    deltaPos     -= vec3(0,0,0.22);\n    deltaPos     *= vec3(16., 7., 40.);\n    deltaPos      = abs(deltaPos);\n    newFill = 1.-max(deltaPos.x, max(deltaPos.y, deltaPos.z));\n    \n    deltaPos = worldPos - vec3(0.05,-0.4,0.05);\n    deltaPos      = abs(deltaPos.zyx);\n    deltaPos     -= vec3(0,0,0.22);\n    deltaPos     *= vec3(16., 7., 40.);\n    deltaPos      = abs(deltaPos);\n    newFill = max(newFill, 1.-max(deltaPos.x, max(deltaPos.y, deltaPos.z)));\n    if (newFill > fill)\n    {\n        fill = newFill;\n        Orange(fill, material);\n    }\n    \n    // Vines\n    Vines(worldPos+vec3(0.4,-0.5,0.2),   vec3(0.8,0.04 ,0.3), 0.04, material); \n    Vines(worldPos+vec3(0.4,-0.5,-0.2),  vec3(0.8,0.035,0.2), 0.04, material); \n    Vines(worldPos+vec3(-0.25,-0.5,0.4), vec3(0.3,0.04 ,0.8), 0.04, material); \n    Vines(worldPos+vec3( 0.1,-0.5,0.4),  vec3(0.2,0.03 ,0.8), 0.04, material); \n    \n    return material;\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    /*\n    Finds the current voxel, finds what material it should be, generates said material, then stores it.\n    Not much to it.\n    */\n    if (iFrame == 0)\n    {\n        int page;\n        vec3 worldPos     = WorldPosFromCube(fragCoord, rayDir, page);\n        Material material = BuildWorld(worldPos);\n        if      (page == 1)\n        {\n            fragColor     = vec4(material.albedo, material.fill);\n        }\n        else if (page == 2)\n        {\n            fragColor     = vec4(material.emission, material.smoothness);\n        }\n        else if (page == 3)\n        {\n            fragColor     = vec4(vec3(0), material.metallic);\n        }\n    }\n    else\n    {\n        fragColor = texture(iChannel0, rayDir);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            },
            {
                "code": "/*\nSTEPDIST is the Buffer A (final rendering) step distance. The cubemap resolution is\n128x128x128, so ideally you want STEPDIST < 128 for fine details, but for most stuff\nyou can do lower resolution. Might encounter issues with normals though.\n\nSHADSTEPDIST is the Buffer B (shadow) step distance. Don't need very good resolution,\nbut it only runs once (in frame 1) so it's not affecting performance much.\n\nMAINLIGHTDIR is the main light (sun) direction.\n\nBLOOMRADIUS is the radius of the Gaussian blur used for bloom (Buffers C+D)\n\nBLOOMSKIP is how many pixels the Gaussian blur skips over (for performance). The total \nnumber of calculations is ~BLOOMRADIUS/BLOOMSKIP.\n\nFeel free to use anything here for whatever you want.\n*/\n#define STEPDIST    1./256.\n#define SHADSTEPDIST 1./64.\n#define MAINLIGHTDIR normalize(vec3(1.2,2.7,1))\n#define BLOOMRADIUS 40.\n#define BLOOMSKIP 2.\n\nvec3 WorldPosFromCube(vec2 fragCoord, vec3 rayDir, out int dataPage)\n{\n    /*\n    Function to be used (primarily) in Cube A. Converts the fragCoord and ray direction\n    into world position, while storing the Data Page on the side.\n    \n    Note that while the cubemap has 6 faces, there are only 3 data pages as two faces\n    are required to fill out the 128x128x128 cube.\n    */\n    vec3 ard = abs(rayDir);\n    float m  = max(ard.x, max(ard.y, ard.z));\n    int bigCoord = int(fragCoord.x) + 1024*int(fragCoord.y);\n    if      (m ==  rayDir.x)\n    {\n        dataPage = 1;\n    }\n    else if (m ==  rayDir.y)\n    {\n        dataPage = 2;\n    }\n    else if (m ==  rayDir.z)\n    {\n        dataPage = 3;\n    }\n    else if (m == -rayDir.x)\n    {\n        dataPage = 1;\n        bigCoord+= 1024*1024;\n    }\n    else if (m == -rayDir.y)\n    {\n        dataPage = 2;\n        bigCoord+= 1024*1024;\n    }\n    else if (m == -rayDir.z)\n    {\n        dataPage = 3;\n        bigCoord+= 1024*1024;\n    }\n    int x = (bigCoord        )%128;\n    int y = (bigCoord/128    )%128;\n    int z = (bigCoord/128/128)%128; // % is unnecessary but why not\n    return (vec3(x,y,z)+0.5)/128.-0.5;\n}\nvec3 RoundWorldPos(vec3 worldPos)\n{\n    worldPos += 0.5;\n    worldPos *= 128.;\n    worldPos  = round(worldPos);\n    return worldPos;\n}\nvec3 CubeFromWorldPos(vec3 worldPos, int dataPage)\n{\n    /*\n    The inverse of WorldPosFromCube (well, kind of). Converts world position into the\n    ray direction needed to read that voxel (on that Data Page). Not exactly the inverse \n    of WorldPosFromCube in that WPFC uses the frag coords as primary input, while CFWP\n    spits out the ray direction.\n    \n    Note: worldPos is the **ROUNDED** world position.\n    */\n    if (worldPos.x > 127. || worldPos.y > 127. || worldPos.z > 127.\n     || worldPos.x < 0.   || worldPos.y < 0.   || worldPos.z < 0.  )\n    {\n        return vec3(0);\n    }\n    else\n    {\n        int bigCoord = ((int(worldPos.z)*128+int(worldPos.y))*128+int(worldPos.x));\n        bigCoord -= int(worldPos.z+1.) > 64 ?   1024*1024 : 0;\n        dataPage += int(worldPos.z+1.) > 64 ?           3 : 0;\n        dataPage -= 1;\n        vec3 rgVex[6] = vec3[6](vec3( 0, 0,-1),vec3( 1, 0, 0),vec3( 1, 0, 0),vec3( 0, 0, 1),vec3( 1, 0, 0),vec3(-1, 0, 0));\n        vec3 upVex[6] = vec3[6](vec3( 0,-1, 0),vec3( 0, 0, 1),vec3( 0,-1, 0),vec3( 0,-1, 0),vec3( 0, 0,-1),vec3( 0,-1, 0));\n        vec3 fwVex[6] = vec3[6](vec3( 1, 0, 0),vec3( 0, 1, 0),vec3( 0, 0, 1),vec3(-1, 0, 0),vec3( 0,-1, 0),vec3( 0, 0,-1));\n        vec2 uvs      = (vec2(bigCoord % 1024, (bigCoord/1024)%1024) + 0.5)/1024.;\n        uvs           = 2.*uvs - 1.;\n        vec3 rayDir   = (rgVex[dataPage]*uvs.x + upVex[dataPage]*uvs.y);\n        rayDir       += (fwVex[dataPage]);\n        return normalize(rayDir);\n    }\n}\nstruct Material\n{\n    /*\n    Struct to store material data, describing how light reflects (or doesn't) \n    or is emitted by a given material.\n    \n    Stored as follows:\n    Page 1: vec4(albedo,               fill)\n    Page 2: vec4(emission,       smoothness)\n    Page 3: vec4(<free space>,     metallic)\n    \n    That free space could be used for encoding other material properties. Haven't\n    decided what to do with it yet, if anything.\n    */\n    float fill;      // Will probably be 1 or 0 for now, might improve in time.\n    vec3  albedo;    // Reflected color of material (<1)\n    vec3  emission;  // Emitted color of material (can be >1)\n    float smoothness;// How smooth the material appears\n    float metallic;  // How 'metallic' the material appears\n};\n\nvec4 PBR(Material material, vec3 normal, vec3 viewDir, float shadowAttenuation)\n{\n    /*\n    How to render a material to a color!\n    Can mess around as needed; this is just what I found works.\n    */\n    \n    // Lighting\n    vec4 mainLightCol = vec4(1.2,1.1,0.9,0.)*1.5;\n    vec4 skyCol       = vec4(0.4,0.5,0.8,0.)*0.8;\n    \n    // Converting stuff to vec4\n    vec4 albedo       = vec4(material.albedo,0);\n    vec4 emission     = vec4(material.emission,0);\n    \n    vec4 total        = emission;\n    \n    // Specular Power (-> inf as smoothness -> 1.)\n    float sp          = 10.*(1./(1.-material.smoothness)-1.);\n    \n    // Fresnel (boosts specular towards edges)\n    float fresnel     = sqrt(0.6+0.4*pow(1.-abs(dot(normal,      viewDir)),5.));\n    float sunFresnel  = sqrt(0.6+0.4*pow(1.-abs(dot(normal, MAINLIGHTDIR)),5.));\n    \n    // Light Strength (light intensity per unit area)\n    float ls          = max(0., dot(normal, MAINLIGHTDIR));\n    \n    // Reflection proximity (goes from 0 to -2)\n    float rp          = dot(reflect(viewDir, normal), MAINLIGHTDIR)-1.;\n    \n    vec4 diffuse      = (1.-material.smoothness*fresnel*material.smoothness*sunFresnel)\n                        *albedo*ls;\n    diffuse          *= mainLightCol*shadowAttenuation;\n    diffuse          +=  albedo*(1.+normal.y)*skyCol;\n    vec4 specular_nm  = (   material.smoothness*fresnel*material.smoothness*sunFresnel)\n                        *sqrt(sp/(1.+(rp*rp*sp*sp))) * vec4(1.)*ls;\n    specular_nm      *= mainLightCol*shadowAttenuation;\n    vec4 specular_met =  sqrt(sp/(1.+(rp*rp*sp*sp))) * albedo * sunFresnel*fresnel*3.*ls;\n    specular_met     *= mainLightCol*shadowAttenuation;\n    specular_met     += albedo * sunFresnel*fresnel*2.*(1.+normal.y)*skyCol;\n    \n    vec4 lightingComb = mix(diffuse + specular_nm, specular_met, material.metallic);\n    \n    total            += lightingComb;\n    return total;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define PI 3.1415926\n\nMaterial GetMaterial(vec3 worldPos)\n{\n    /*\n    Simple function to get the material of a particular voxel. Used for GetFill.\n    */\n    vec3 cubePos1 = CubeFromWorldPos(worldPos, 1);\n    vec3 cubePos2 = CubeFromWorldPos(worldPos, 2);\n    vec3 cubePos3 = CubeFromWorldPos(worldPos, 3);\n    vec4 p1, p2, p3;\n    if (length(cubePos1) >= 0.5)\n    {\n        p1  = texture(iChannel0, cubePos1);\n        p2  = texture(iChannel0, cubePos2);\n        p3  = texture(iChannel0, cubePos3);\n    }\n    else\n    {\n        p1 = vec4(0);\n        p2 = vec4(0);\n        p3 = vec4(0);\n    }\n    return Material(p1.a, p1.xyz, p2.xyz, p2.a, p3.a);\n}\n\nfloat GetFill(vec3 worldPos, out Material material, out vec3 fillGradient)\n{\n    /*\n    Gets the fill level of the current voxel, the gradient, and the material.\n    The fill level is calculated by finding the four nearest voxels, and interpolating\n    between them. The fill gradient is used as a proxy for the normal vector.\n    \n    The material is determined by finding which voxel of the four nearest ones the normal\n    is pointing most away from. If the current position is 'full', this voxel will \n    necessarily itself be full, so there can be no funny business with accidentally finding\n    empty voxels.\n    */\n    worldPos += 0.5;\n    worldPos *= 128.;\n    vec3 roundedWorldPos = round(worldPos);\n    vec3 deltaWorldPos   = worldPos - roundedWorldPos;\n    vec3 deltaNormalized = sign(sign(deltaWorldPos)+0.01); // Returns positive if zero (don't like 0)\n    \n    Material M0 = GetMaterial(roundedWorldPos);\n    Material Mx = GetMaterial(roundedWorldPos + deltaNormalized*vec3(1,0,0));\n    Material My = GetMaterial(roundedWorldPos + deltaNormalized*vec3(0,1,0));\n    Material Mz = GetMaterial(roundedWorldPos + deltaNormalized*vec3(0,0,1));\n    \n    fillGradient = vec3((Mx.fill-M0.fill), (My.fill-M0.fill), (Mz.fill-M0.fill))*deltaNormalized;\n    float fill   = M0.fill + dot(fillGradient, deltaWorldPos);\n    fillGradient/= 128.;\n    \n    vec3  g      = fillGradient*deltaNormalized;\n    float m      = max(0.,max(g.x, max(g.y, g.z)));\n    if      (g.x == m)\n    {\n        material = Mx;\n    }\n    else if (g.y == m)\n    {\n        material = My;\n    }\n    else if (g.z == m)\n    {\n        material = Mz;\n    }\n    else\n    {\n        material = M0;\n    }\n    \n    return fill;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*\n    Main rendering. \n    First, I set up the camera stuff, determine the total depth through the cube, if I hit it \n    (that's what sorting the faces is for). \n    Next: the big loop! March through, if I land in a full voxel, I break.\n    I tried adding some binary searching to refine it more but it just ended up crashing everything\n    when I tried to compile :/\n    Once the loop is done, if it's hit something, it does the shadow check and PBR rendering.\n    Could make smooth shadows by sampling surrounding pixels in the texture, but I didn't.\n    */\n    float theta = (iMouse.x - iResolution.x / 2.) / iResolution.y * PI  / 2. + 2.5*PI/2.;\n    float phi   = (iMouse.y  - iResolution.y) / iResolution.y * PI / 2.;\n\n    // CAMERA\n    vec3 iCameraFwd     = vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\n    vec3 iCameraUp      = vec3(-sin(theta)*sin(phi),cos(phi),-cos(theta)*sin(phi));\n    vec3 iCameraRight   = normalize(cross(iCameraUp, iCameraFwd));\n    \n    vec3 iCameraPosition      = -2.*iCameraFwd;\n    \n    float m = 1.2;\n    \n    vec3 iViewDirection = iCameraFwd + ((fragCoord.x - iResolution.x/2.0) * iCameraRight + (fragCoord.y - iResolution.y/2.0) * iCameraUp) / iResolution.x * m;\n    iViewDirection      = normalize(iViewDirection);\n    \n    // SORTING FACES\n    float distXP =  (0.5-iCameraPosition.x)/iViewDirection.x;\n    float distYP =  (0.5-iCameraPosition.y)/iViewDirection.y;\n    float distZP =  (0.5-iCameraPosition.z)/iViewDirection.z;\n    \n    float distXM = (-0.5-iCameraPosition.x)/iViewDirection.x;\n    float distYM = (-0.5-iCameraPosition.y)/iViewDirection.y;\n    float distZM = (-0.5-iCameraPosition.z)/iViewDirection.z;\n    \n    vec3 faceList[6] = vec3[6]( vec3(1,0,0), vec3(0,1,0), vec3(0,0,1),\n                                vec3(-1,0,0),vec3(0,-1,0),vec3(0,0,-1));\n\n    float distList[6] = float[6]( distXP, distYP, distZP,\n                                  distXM, distYM, distZM);\n    \n    for (int n = 0; n < 5; n++)\n    {\n        for (int i = 0; i < 5; i++)\n        {\n            if (distList[i] > distList[i+1])\n            {\n                vec3 c        = faceList[i];\n                faceList[i]   = faceList[i+1];\n                faceList[i+1] = c;\n                \n                float r       = distList[i];\n                distList[i]   = distList[i+1];\n                distList[i+1] = r;\n            }\n        }\n    }\n    \n    // PREP\n    fragColor = vec4(0.);\n    Material material;\n    vec3 fillGradient;\n    \n    bool hit = false;\n    vec3 hitPos = vec3(0);\n    \n    // MARCHING\n    if (length(faceList[0]+faceList[1]+faceList[2]) >= sqrt(3.))\n    {\n        float oldFill       = 0.;\n        vec3 startPosition  = iCameraPosition + distList[2]*iViewDirection;\n        float newFill;\n        for (float d = 0.; d < distList[3] - distList[2]; d+= STEPDIST)\n        {\n            vec3 position = startPosition + iViewDirection*d;\n            newFill       = GetFill(position, material, fillGradient);\n            if (newFill > 0. && oldFill <= 0.)\n            {\n                hit = true;\n                #ifdef BINSTEPS\n                    float delta = 0.;\n                    for (float n = 1.; n < BINSTEPS; n--)\n                    {\n                        if (newFill > 0.)\n                        {\n                            delta -= 1./pow(2., n);\n                        }\n                        else\n                        {\n                            delta += 1./pow(2., n);\n                        }\n                        newFill = GetFill(position + delta*iViewDirection, material, fillGradient);\n                    }\n                    newFill = GetFill(position + (delta+pow(2., -BINSTEPS))*iViewDirection, material, fillGradient);\n                #endif\n                hitPos = position;\n                break;\n            }\n            oldFill       = newFill;\n        }\n    }\n    if (hit)\n    {\n        // SHADOWS\n        vec3 sCameraRight    = -normalize(cross( vec3(0,1,0), MAINLIGHTDIR));\n        vec3 sCameraUp       =  normalize(cross(sCameraRight, MAINLIGHTDIR));\n        vec2 shadowCoord     = vec2(dot(sCameraRight, hitPos), dot(sCameraUp, hitPos));\n        shadowCoord          = (shadowCoord/2.)+0.5;\n        float shadowDepth    = texture(iChannel1, shadowCoord).r;\n        vec3 sViewDirection  = -MAINLIGHTDIR;\n        float shadowBias     = 0.01;\n        float shadowAttenuation;\n        if (dot(sViewDirection, hitPos) < shadowDepth + shadowBias)\n        {\n            shadowAttenuation = 1.;\n        }\n        else\n        {\n            shadowAttenuation = 0.;\n        }\n        // PBR\n        fragColor     = PBR(material, normalize(-fillGradient), iViewDirection, shadowAttenuation);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "float GetFill(vec3 worldPos)\n{\n    // Simple version because shadows aren't very fancy, nobody needs e.g. normals.\n    worldPos += 0.5;\n    worldPos *= 128.;\n    worldPos = round(worldPos);\n    vec3 cubePos1 = CubeFromWorldPos(worldPos, 1);\n    if (length(cubePos1) >= 0.1)\n    {\n        return texture(iChannel0, cubePos1).a;\n    }\n    else\n    {\n        return 0.;\n    }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*\n    Same as rendering in Buffer A, but shadows are done in frame 1 once the cubemap is finished.\n    Shadows don't need to be redone because the Sun isn't changing direction. Shadows are done \n    using an orthographic perspective, and then stored as a depth map. Overall, a bit simpler\n    than the main rendering.\n    Geometry is then calculated in Buffer A to determine whether the surface is in shadow or not.\n    */\n    if (iFrame == 1)\n    {\n        vec3 iCameraRight    = -normalize(cross( vec3(0,1,0), MAINLIGHTDIR));\n        vec3 iCameraUp       =  normalize(cross(iCameraRight, MAINLIGHTDIR));\n        vec2 screenCoord     = (fragCoord/iResolution.xy-0.5)*2.;\n        vec3 iCameraPosition = screenCoord.x*iCameraRight + screenCoord.y*iCameraUp;\n        vec3 iViewDirection  = -MAINLIGHTDIR;\n\n        // SORTING FACES\n        float distXP =  (0.5-iCameraPosition.x)/iViewDirection.x;\n        float distYP =  (0.5-iCameraPosition.y)/iViewDirection.y;\n        float distZP =  (0.5-iCameraPosition.z)/iViewDirection.z;\n\n        float distXM = (-0.5-iCameraPosition.x)/iViewDirection.x;\n        float distYM = (-0.5-iCameraPosition.y)/iViewDirection.y;\n        float distZM = (-0.5-iCameraPosition.z)/iViewDirection.z;\n\n        vec3 faceList[6] = vec3[6]( vec3(1,0,0), vec3(0,1,0), vec3(0,0,1),\n                                    vec3(-1,0,0),vec3(0,-1,0),vec3(0,0,-1));\n\n        float distList[6] = float[6]( distXP, distYP, distZP,\n                                      distXM, distYM, distZM);\n\n        for (int n = 0; n < 5; n++)\n        {\n            for (int i = 0; i < 5; i++)\n            {\n                if (distList[i] > distList[i+1])\n                {\n                    vec3 c        = faceList[i];\n                    faceList[i]   = faceList[i+1];\n                    faceList[i+1] = c;\n\n                    float r       = distList[i];\n                    distList[i]   = distList[i+1];\n                    distList[i+1] = r;\n                }\n            }\n        }\n\n        fragColor = vec4(10.);\n        Material material;\n        vec3 fillGradient;\n\n        bool hit = false;\n        if (length(faceList[0]+faceList[1]+faceList[2]) >= sqrt(3.))\n        {\n            float oldFill       = 0.;\n            vec3 startPosition  = iCameraPosition + distList[2]*iViewDirection;\n            float newFill;\n            for (float d = 0.; d < distList[3] - distList[2]; d+= SHADSTEPDIST)\n            {\n                vec3 position = startPosition + iViewDirection*d;\n                newFill       = GetFill(position);\n                if (newFill > 0.)\n                {\n                    fragColor = vec4((dot(position, iViewDirection)));\n                    break;\n                }\n                oldFill       = newFill;\n            }\n        }\n    }\n    else\n    {\n        fragColor = texture(iChannel1, fragCoord/iResolution.xy);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // BLOOM (Gaussian blur in x)\n    fragColor = vec4(0);\n    for (float x = -BLOOMRADIUS-0.5; x < BLOOMRADIUS+1.5; x+= BLOOMSKIP)\n    {\n        fragColor += exp(-(4.*x*x)/(BLOOMRADIUS*BLOOMRADIUS))*pow(texture(iChannel0, (fragCoord+vec2(1,0)*x)/iResolution.xy),vec4(2.));\n    }\n    fragColor /= sqrt(BLOOMRADIUS);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // BLOOM (Gaussian blur in y)\n    fragColor = vec4(0);\n    for (float x = -BLOOMRADIUS-0.5; x < BLOOMRADIUS+1.5; x+= BLOOMSKIP)\n    {\n        fragColor += exp(-(4.*x*x)/(BLOOMRADIUS*BLOOMRADIUS))*texture(iChannel0, (fragCoord+vec2(0,1)*x)/iResolution.xy);\n    }\n    fragColor /= sqrt(BLOOMRADIUS);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}