{
    "Shader": {
        "info": {
            "date": "1636403389",
            "description": "Using Circle-Ray intersection and segment-segment intersection. Very brute force but it works.\nI can already see a way more efficient method.",
            "flags": 0,
            "hasliked": 0,
            "id": "flcGzX",
            "likes": 15,
            "name": "Polar DDA Experiment #1",
            "published": 3,
            "tags": [
                "dda",
                "polar"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 340
        },
        "renderpass": [
            {
                "code": "\n/*\n  at every step, calculate intersection with two circles\n  and intersection with two lines\n  \n  \n  My thoughts/approach while preparing to code this.\n  Some of it might have changed as I worked on it:\n  \n\n          //we will hit either inner or outer circle\n          //circles centered at origin\n          // ict = inner circle  (rad=uvFL.y)\n          // oct = outer circle  (rad=uvCL.y)\n\n          //after each hit, move to that hitpoint and start a new\n          //segment in the same direction but starting just \n          //beyond the hit, so we always find the next hit that \n          //intersects with the new segment\n\n          //we MAY hit either upper or lower line, \n          //but possibly neither, and never both\n\n          // lines(not segments rotated aaround 0,0 at 0rads\n          // llt = lower line rot(uvFL.x)\n          // ult = upper line rot(uvCL.x)\n\n          //this will be our min t, the distance to the closest\n          //hit point.\n          // float t = min(min(llt,ult),min(ict,oct));\n          //and ofcourse if we don't even hit a line, it's\n          //t value will be inf or something\n\n          //so we ust move to that location and in the example\n          //we'll just draw a point there to.\n\n          //check if angle \n  \n  This experiment is just a rudimentary brute-force \n  intersection algorithm.\n  \n\n*/\n\n#define pi acos(-1.)\n#define eps 1./iResolution.y\n#define mattzGreen vec3(0.6, 0.75, 0.6)*0.7\n#define polarColor vec3(1.,0.,.6)*0.8\n#define lengthColor vec3(1.,0.,0.)*0.8\n\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n  return mat2(c,-s,s,c);\n}\n\nfloat intersectCircle(vec2 ro, vec2 rd, float r){\n\n    vec2 O_C = ro;\n    float a = dot(rd,rd);\n    float b = 2.*dot(rd,O_C);\n    float c = dot(O_C,O_C) - r*r;\n    \n    float disc = b*b-4.*a*c;\n    \n    if(disc < 0.) return 100000.;\n    \n    float t1 = (-b - sqrt(disc))/(2.*a); \n    float t2 = (-b + sqrt(disc))/(2.*a);\n    \n    if(t1 >= 0.){return t1;}\n    else if(t2 >= 0.){return t2;}\n    else return 10000.;\n}\n\nfloat ssRing(vec2 p, float r){\n  \n    return smoothstep(r-eps,r+eps,abs(length(p)-0.014));\n}\n\nfloat ssCircle(vec2 p, float r){\n  \n    return smoothstep(r-eps,r+eps,length(p)-0.003);\n}\n\nfloat distToLine(vec2 A, vec2 B, vec2 p){\n    \n    vec2 PA = p - A;\n    vec2 BA = B - A;\n    float d = dot(PA,BA);\n    float t = clamp(d/(length(BA)*length(BA)),0., 1.);//Vektorprodukt\n    vec2 normal = PA - BA*t;\n    return length(normal);\n}\n\n\nfloat segSeg(vec2 A1, vec2 B1, vec2 A2, vec2 B2){\n    float B = B2.x-A2.x;\n    float A = B1.x-A1.x;\n    \n    float E = B2.y-A2.y;\n    float D = B1.y-A1.y;\n    \n    float C = A1.x-A2.x;\n    float F = A1.y-A2.y;\n  \n    float s = (B*F-C*E)/(A*E-D*B);\n    float t = (A*F-D*C)/(A*E-D*B);\n  \n   //it really can't be s here lol\n    return t;\n}\n\n\n/*\n\n//I was experimenting with another line intersection\n//method\n\nfloat intersectLine( vec2 P, vec2 rd, vec2 B){\n    vec2 A = vec2(0.);\n\n    vec2 AP = P-A;\n    vec2 BA = B-A;\n    \n    float t = clamp(dot(AP,BA)/\n                    dot(BA,BA), \n                    0., 1.);\n                    \n    vec2 P3 = A + t*BA;\n    vec2 P3P = P-P3;\n  \n    float adj = length(P3P);\n    float P3PAngle = acos(dot(rd,normalize(P3P)));\n    float h = adj/dot(normalize(P3P), rd);\n\n    return h;\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n  \n  vec3 col = vec3(1, 0.97, .87);\n  \n      \n      ////////////////////////////////////////////\n      //                                       //\n////////          SETUP (HACKY)              //\n      //                                   //\n      /////////////////////////////////////\n        \n    \n    \n  float scale = 10.;\n  float circleDrawRadius = 0.004;\n  vec2 uvP = vec2(atan(uv.y,uv.x)/pi, length(uv));\n  uvP *= scale;\n  \n  vec2 uvFR = fract(uvP.xy);\n  vec2 uvFL = floor(uvP.xy);\n  vec2 uvCL = ceil(uvP.xy);\n  \n  col = mix(col,mattzGreen,smoothstep(0.48,0.49, abs(fract(uvP.yyy)-0.5)));\n  //col *= (1.-smoothstep(0.42,0.46,abs(fract(uvP.xxx)-0.5)));\n  vec2 ro = vec2(-2.9,0.2)/scale;\n  vec2 oldRo= ro;\n  vec2 rd = vec2(1.,0.)*rot(iTime/2.);\n  if(iMouse.z > 0.5) \n        rd = normalize((iMouse.xy*2.-iResolution.xy)/iResolution.y - ro);\n    \n  col = mix(col,vec3(.5,0.,0.),1.-ssCircle(uv-ro,circleDrawRadius));\n  \n  float ray = 1.0-smoothstep(0.002,.009,\n              abs(distToLine(ro, ro+rd * 100., uv)));\n                \n  col = mix(col, vec3(0.), ray);\n  \n  //we do need to extend the ray to inf in one direction\n  float ict,oct,llt,ult,t;\n  vec2 baseA = vec2(-1000.,0.);\n  vec2 baseLine = vec2(1000.,0.);\n      \n      \n       \n      ////////////////////////////////////////////\n      //                                       //\n////////          CHECK LINE HITS            //\n      //                                   //\n      /////////////////////////////////////\n        \n\n  \n  float polar_step = pi/(scale);\n  for(float i=0.; i<pi*2.; i+=polar_step){\n    \n    baseLine *= rot(polar_step);\n    float f = 1.0-smoothstep(0.00,0.003,\n                abs(distToLine(vec2(0.), baseLine, uv)));\n    \n    vec2 A1 = vec2(0.);\n    vec2 B1 = baseLine;\n    \n    vec2 A2 = ro;\n    vec2 B2 = (ro+rd*100.);\n    \n    col = mix(col, mattzGreen, f);\n    t = segSeg(A1,B1,A2,B2);\n    \n    if(t >= 0. && t <= 1.){\n        vec2 pol2 = vec2(A2.x + t*(B2.x-A2.x), A2.y + t*(B2.y-A2.y));\n        col = mix(col,polarColor, 1. - ssRing(uv-pol2,circleDrawRadius) );\n        col = mix(col,polarColor, 1. - ssCircle(uv-pol2,circleDrawRadius) );\n    }\n    \n  }\n\n      \n      ////////////////////////////////////////////\n      //                                       //\n////////          CHECK CIRCLE HITS          //\n      //                                   //\n      /////////////////////////////////////\n  ro = oldRo;     \n    \n    \n  for(int i = 0; i < 10; i++){\n     uvFL = floor(uvP.xy);\n     uvCL = ceil(uvP.xy);\n    \n     ict = intersectCircle(ro, rd, uvFL.y/scale);\n     oct = intersectCircle(ro, rd, uvCL.y/scale);\n     t = min(ict,oct);\n    \n    //a \"Travelling ro\" \n     ro += rd*t;\n     col = mix(col,lengthColor,1. - ssRing(uv-ro,circleDrawRadius) );\n     col = mix(col,lengthColor,1. - ssCircle(uv-ro,circleDrawRadius) );\n    //push a it beyond the line\n     ro += rd*eps;\n  }\n \n\n      ////////////////////////////////////////////\n      //                                       //\n////////          POST PROCESSING            //\n      //                                   //\n      /////////////////////////////////////\n        \n    \n    //vignett from mattz\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );       \n    col *= 0.9 + 0.1*texture(iChannel0, fragCoord.xy/256.).x;\n    col *= 0.9 + 0.1*texture(iChannel0, fragCoord.xy/256.).x;\n    col = pow(col, vec3(1.0/2.2));\n  fragColor = vec4(col, 1);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}