{
    "Shader": {
        "info": {
            "date": "1501860689",
            "description": "kookoons",
            "flags": 0,
            "hasliked": 0,
            "id": "4dBBWG",
            "likes": 4,
            "name": "kookoons",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "mikatalk",
            "viewed": 573
        },
        "renderpass": [
            {
                "code": "// Forked from https://www.shadertoy.com/view/4dSfzt\n\n#define Pi 3.1415926\n#define Pi2 1.5707963\n\nvoid Rotate( inout vec3 vector, vec2 angle )\n{\n\tvector.yz = cos(angle.y)*vector.yz\n\t\t\t\t+sin(angle.y)*vec2(-1,1)*vector.zy;\n\tvector.xz = cos(angle.x)*vector.xz\n\t\t\t\t+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\nvoid Rotate2( inout vec3 vector, vec2 angle )\n{\n\tvector.zy = cos(angle.x)*vector.zy\n\t\t\t\t+sin(angle.x)*vec2(-1,1)*vector.yz;\n\tvector.xy = cos(angle.y)*vector.xy\n\t\t\t\t+sin(angle.y)*vec2(-1,1)*vector.yx;\n}\nfloat Sphere( vec3 centre, float radius, vec3 pos )\n{\n    return length(centre-pos)-radius;\n}\n\nfloat Torus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat Ellipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\nfloat smin2( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smin3( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\nvec2 Blend(  vec2 a, vec2 b)//, vec3 p )\n{\n//    return vec2(smin( a.x, b.x, 4.1 ), a.y);\n//    return vec2(smin2( a.x, b.x, .7 ), a.y);\n    return vec2(smin2( a.x, b.x, 1.0 ), a.y);\n}\nvec2 Blend2(  vec2 a, vec2 b)//, vec3 p )\n{\n//    return vec2(smin( a.x, b.x, 4.1 ), a.y);\n//    return vec2(smin2( a.x, b.x, .7 ), a.y);\n    return vec2(smin2( a.x, b.x, .5 ), a.y);\n}\nvec2 Sub( vec2 a, vec2 b )\n{\n    return abs(a.x) > b.x ? a : b;\n}\n\nfloat BoxUn( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\nfloat Cone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\nvec2 Union( vec2 a, vec2 b )\n{\n    return a.x < b.x ? a : b;\n}\nvec2 Intersection( vec2 a, vec2 b )\n{\n    return a.x > b.x ? a : b;\n}\nfloat CappedCylinder( vec3 p, vec2 h )\n{\n  \tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nvec2 BaloonSided( vec3 pos, vec3 size, float shapeIndex ) {\n   \tvec2 f = vec2( Ellipsoid(pos+vec3(0.,0.,.25), size), shapeIndex );\n   \tvec2 sdf = vec2( BoxUn(pos+vec3(0.,0.,.5), vec3(1.0, 1.2, 1.0)*size), shapeIndex );\n\treturn Blend( Sub(sdf, f), f);   \n}\nvec2 Baloon( vec3 pos, vec3 size, float shapeIndex ) {\n   \tvec2 f = vec2( Ellipsoid(pos+vec3(0.,0.,.25), size), shapeIndex );\n\treturn f;\n}\n\nvec2 Scene( vec3 pos )\n{\n\tvec2 angle = vec2(-iTime,0);\n    Rotate(pos,angle);\n    angle = vec2(0., sin(iTime*.5)*.33);\n    Rotate2(pos,angle);\n\n    float shapeIndex = 0.;\n    vec3 tmp = pos;\n    \n    vec2 f = vec2(.0);\n    \n    Rotate2(tmp.xyz, vec2(0., Pi2)); \n    Rotate2(tmp.xyz, vec2(0., -.3));\n    Rotate(tmp.xyz, vec2(.05, 0.0));\n    f = BaloonSided(tmp.xyz+vec3(-1.8,-1.,.3), vec3(1., .35, .4), shapeIndex);\n    \n    tmp = pos;\n    Rotate2(tmp.xyz, vec2(0., Pi2));\n    Rotate2(tmp.xyz, vec2(0., -.3));\n    Rotate(tmp.xyz,vec2(Pi,0.0));\n    Rotate(tmp.xyz, vec2(-.05, 0.0));\n    f = Union(f, BaloonSided(tmp.xyz+vec3(1.8,-1.,.3), vec3(1., .35, .4), shapeIndex));\n    \n    tmp = pos;\n    Rotate2(tmp.xyz, vec2(0., Pi2));\n    Rotate2(tmp.xyz, vec2(0., .3));\n    Rotate(tmp.xyz, vec2(.1, 0.0));\n  \tf = Union(f, BaloonSided(tmp.xyz+vec3(-1.8,1.,.33), vec3(1., .4, .5), shapeIndex));\n\n    tmp = pos;\n    Rotate2(tmp.xyz, vec2(0., Pi2));\n    Rotate2(tmp.xyz, vec2(0., .3));\n    Rotate(tmp.xyz,vec2(Pi,0.0));\n    Rotate(tmp.xyz, vec2(-.1, 0.0));    \n    f = Union(f, BaloonSided(tmp.xyz+vec3(1.8,1.,.33), vec3(1., .4, .5), shapeIndex));\n\n    tmp = pos;\n    f = Union(f, Baloon(tmp.xyz+vec3(0.,0.,-.33), vec3(1.2, .6, .6), shapeIndex));\n \n    tmp = pos;\n    Rotate2(tmp.xyz, vec2(0., -2.));\n    f = Union(f, Baloon(tmp.xyz+vec3(-1.,-1.,-.33), vec3(.9, .45, .45), shapeIndex));\n \n    tmp = pos;\n    Rotate2(tmp.xyz, vec2(0., -2.));\n    f = Union(f, Baloon(tmp.xyz+vec3(-2.,-1.,-.33), vec3(.6, .12, .12), shapeIndex));\n \n    tmp = pos;\n    Rotate2(tmp.xyz, vec2(0., 2.));\n    f = Union(f, Baloon(tmp.xyz+vec3(1.,-1.,-.33), vec3(.8, .45, .45), shapeIndex));\n   \n    tmp = pos;\n    Rotate2(tmp.xyz, vec2(0., -Pi2));\n    Rotate2(tmp.xyz, vec2(0., -.1));\n    Rotate(tmp.xyz, vec2(.1, 0.0));\n  \tf = Union(f, BaloonSided(tmp.xyz+vec3(-1.9,1.7,.0), vec3(.7, .3, .4), shapeIndex));\n\n    tmp = pos;\n    Rotate2(tmp.xyz, vec2(0., -Pi2));\n    Rotate2(tmp.xyz, vec2(0., -.1));\n    Rotate(tmp.xyz,vec2(Pi,0.0));\n    Rotate(tmp.xyz, vec2(-.1, 0.0));    \n    f = Union(f, BaloonSided(tmp.xyz+vec3(1.9,1.7,.1), vec3(.7, .3, .4), shapeIndex));\n     \n    tmp = pos;\n    Rotate2(tmp.xyz, vec2(0., 3.3));\n    f = Union(f, Baloon(tmp.xyz+vec3(2.4,1.4,-.33), vec3(.9, .5, .5), shapeIndex));\n  \n //    tmp = pos;\n //   Rotate2(tmp.xyz, vec2(0., 3.3));\n //   f = Union(f, vec2(Cone(tmp.xyz+vec3(0.0), vec2(.4, .4)), shapeIndex));\n  \n    \n     f = Blend2(f, f);\n    \n    return f;\n}\n\nfloat SDF( vec3 pos )\n{\n    return Scene(pos).x;\n}\n\nfloat GetShapeIndex( vec3 pos )\n{\n    return Scene(pos).y;\n}\n\n// material parameters, per shape\nconst vec3 albedo[] = vec3[](\n    vec3(.01)\n);\nconst vec3 fresnelColour[] = vec3[](\n //   vec3(.02, .01, .8)\n    vec3(0.01, 0.08, 0.68)\n);\nconst float roughness[] = float[](\n   .99f\n);\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ray = normalize( vec3(\n\t\t\t\t(fragCoord-iResolution.xy*.5)/iResolution.x, // pixel pos on screen\n\t\t\t\t1 ) ); // place screen 1 unit in front of eye\n    vec3 pos = vec3(0,.4,-15); // move eye\n\tvec2 angle = vec2(Pi*4.,Pi*4.);\n\tif ( iMouse.z > .0 ) angle *= (iMouse.xy/iResolution.xy-.5);\n\tRotate(pos,angle);\n\tRotate(ray,angle);\n\n    // draw back grid\n    vec2 st = fragCoord.xy / iResolution.xy;\n\tfloat size = .02;\n\tvec2 num = vec2(ivec2( size * iResolution.xy ));\n\n\tvec2 uv = floor(st*num);\n\n\tvec4 bg = vec4( mix( vec3(.02, 0.3, .80), \n                       vec3(0.4, 0.4, 0.9), \n                        mod(uv.x+uv.y,2.770) ), 1.0 );\n    \n    fragColor = 4.*pow(bg,vec4(2.2));\n    for ( int i=0; i < 50; i++ )\n    {\n        float h = SDF(pos);\n        if ( h < .01 )\n        {\n            fragColor = vec4(0);\n            break;\n        }\n        pos += ray*h;\n    }\n\n    if ( SDF(pos) < .01 )\n    {\n        vec3 normal;\n        normal.x = SDF(pos+vec3(.01,0,0)) - SDF(pos-vec3(.01,0,0));\n        normal.y = SDF(pos+vec3(0,.01,0)) - SDF(pos-vec3(0,.01,0));\n        normal.z = SDF(pos+vec3(0,0,.01)) - SDF(pos-vec3(0,0,.01));\n        normal = normalize(normal);\n\n        vec3 lightSource = vec3(0., 5., .0);\n\t\tfloat light = max(.0,dot(normal,normalize(lightSource-pos)));\n      //  light *= ShadowMarch( pos, lightSource );\n\n        vec3 ambient = mix( vec3(.07), vec3(.05,.1,.15), normal.y*.5+.5 ); // looks better than a flat colour\n        vec3 lightCol = vec3(.5,.3,.6);\n        vec3 lighting = light*lightCol + ambient;\n\n        // material\n        int shapeIndex = int(GetShapeIndex(pos));\n        \n        fragColor.rgb = albedo[shapeIndex] * lighting;\n        \n        // specular highlight\n        \n        // reflection mapping\n        vec3 reflection = reflect(ray,normal);      \n        vec3 refMap = 4.*pow(texture(iChannel0,reflection).rgb,vec3(2.2));\n        vec3 fresnel = mix( fresnelColour[shapeIndex], vec3(1.-roughness[shapeIndex]), pow(dot(normal,ray)+1.,5.) );\n        fragColor.rgb = mix( fragColor.rgb, refMap, fresnel );\n    }\n    \n    fragColor.rgb = pow( fragColor.rgb, vec3(1.0/2.2) );\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}