{
    "Shader": {
        "info": {
            "date": "1513719673",
            "description": "Mouse enable.\n\nMusic: Carbon Based Lifeform",
            "flags": 72,
            "hasliked": 0,
            "id": "MllfDX",
            "likes": 87,
            "name": "Hope",
            "published": 3,
            "tags": [
                "grid",
                "reflexion",
                "voxel",
                "planet",
                "raytrace",
                "galaxy",
                "stars",
                "moon",
                "city",
                "lensflare",
                "multiscale",
                "milkyway"
            ],
            "usePreview": 0,
            "username": "ocb",
            "viewed": 4392
        },
        "renderpass": [
            {
                "code": "// Author: ocb\n// Title: Hope \n\n/***********************************************************************\nTrying another algorithm to generate city.\nHere I am using what I may call \"variable size voxels\".\nIn this shader the voxels are 2d as horizontal grid\nI am using 3 grids with 3 differents sizes (sizes are not multiples)\nwith a little shift.\nSo the interconnection of these grids generates infinite lower-sized squares.\n\nThe algorithm is in the 3 first functions.\n\nThe trace function goes from square to square.\nThe map return the height of the square\nthe getNextPlan function return the closest \"square wall\".\n\n\n************************************************************************/\n\n#define PI 3.141592653589793\n#define PIdiv2 1.57079632679489\n#define TwoPI 6.283185307179586\n#define INFINI 1000000.\n#define MAXSTEP 127\n#define TOP_SURFACE 2.81\n\n#define SKY 1\n#define BLOC 2\n#define WIN 3\n#define SIDE 4\n\n\n#define moonCtr vec3(.10644925908247,.266123147706175,.958043331742229)\n#define moonShad vec3(-.633724250524478,.443606975367135,.633724250524478)\n#define moonRefl vec3(.477784395284944,.179169148231854,.8600119115129)\n\nint hitObj = SKY;\nfloat hitScale = 1.;\n\nfloat Hsh(in float v) { \t\t\t\t\t\t\n    return fract(sin(v) * 437585.);\n}\n\n\nfloat Hsh2(in vec2 st) { \t\t\t\t\t\t\n    return fract(sin(dot(st,vec2(12.9898,8.233))) * 43758.5453123);\n}\n\n// thanks IQ\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n/*\nthis function return the closest side of a squared defined by 3 overlapping grids.\nThe scales are .13, .21, .47 so they almost never match together generating smaller\nsquares between their intersections.\nNot necessary, but here I add a shift (-.7) and (-.3) to shift the grids from the other.\nFrom a position inside a square, the distance to the previous side is fract() and the distance\nto the next side is 1-fract. Next and previous depend on the direction of the ray vector\n(here v).\nSo d (depending on the sign of v),represent 1 in case of 1-fract()\nThe whole is divided by the ray to obtain the t parameter to reach the side.\n\nThis is done for the 3 grids.\nThen selecting the smallest one (closest) in both direction (xz)\nand finally keeping the smallest one.\n\nNormal is returned too.\n*/\n\nvec4 getNextPlan(in vec2 xz, in vec2 v, in float t){\n    vec2 s = sign(v);\n    vec2 d = step(0.,s);\n\tvec2 dtp = (d-fract(xz*.13))/.13/v;\n    vec2 dtq = (d-fract((xz-.7)*.21))/.21/v;\n    vec2 dtr = (d-fract((xz-.3)*.47))/.47/v;\n\n    vec2 dmin = min(min(dtp,dtq),dtr);\n    float tmin = min(dmin.x, dmin.y);\n    \n    s *= -step(dmin,vec2(tmin));\n    \n    return vec4(vec3(s.x,0.,s.y),tmin);\n}\n\n\n/*\nmap() function generates the 3 grids.\nA random height is found for each square of each grid Hp, Hq, Hr\nPp Pq and Pr are the probability for a square to have a non-null/null value.\n\nThe final height of the sub square is a weighted sum of each of the 3 grid square.\n*/\n\nfloat map(in vec2 xz)\n{\n    vec2 p = floor(xz*.13)/.13;\n    vec2 q = floor((xz-.7)*.21)/.21;\n    vec2 r = floor((xz-.3)*.47)/.47;\n    \n    float Hp = Hsh2(p), Hq = Hsh2(q), Hr = Hsh2(r);\n    float Pp = step(.6,Hp), Pq = step(.6,Hq), Pr = step(.5,Hr);\n    \n    float tex = 1.*Hp*Pp + .5*Hq*Pq +.3*Hr*Pr;\t  \n    hitScale = Pp + 2.5*Pq + 5.*Pr;\n    \n    return tex;\n    \n}\n\n\n\n/*\nTrace() is the raytracing function.\nFirst of all, find the entry point on the Top surface. Top surface represents the highest\nvalue for the bulding. So we do not cross dozen of voxels when there is no chance\nto hit the \"floor\" of a voxel (building).\n\nWhen under the top surface the ray will navigate from a voxel to another using the \ngetNextPlan() function.\n\np is the position reached.\n\nwe mesure the distance of p from the floor (map(p)) and from the closest \"voxel wall\" getNextPlan(p)\nif map(p) is the closest, the ray hit the floor in this voxel, break.\nif wall is the closest, go to the next voxel.\n\nWhen entering a new voxel, check if below the floor.\nif below the floor, so you hit a building wall, return wall info, break.\n\nNot sure to be clear...\n*/\n\nvec4 trace(in vec3 pos, in vec3 ray)\n{\n    float dh = 0.;\n    float t = 0.;\n    if(pos.y > TOP_SURFACE){\n        if(ray.y >= 0.) return vec4(vec3(0.),INFINI);\n\t\tt = (TOP_SURFACE - pos.y)/ray.y + 0.00001;\n    }\n    \n    vec4 wall = vec4(0.);\n    \n    for(int i = 0;i<MAXSTEP;i++){\n        \n        vec3 p = pos+t*ray;\n        if(p.y > TOP_SURFACE) break;\n        \n        float dh = p.y - map(p.xz);\n        if(dh<.0) return vec4(wall.xyz,t-.00001);\n        \n        wall = getNextPlan(p.xz,ray.xz,t);\n        float tt = 0.;\n        if(ray.y < 0.){\n        \tfloat th = dh/(-ray.y);\n            tt = min(wall.w,th);\n            if(tt==th) return vec4(0.,1.,0.,t+tt);\n        }\n        else tt = wall.w;\n        \n        t+= tt+.00001;\n        if(t>250.) break;\n    }\n    \n    \n    return vec4(0.,0.,0.,INFINI);\n}\n\n\nvec4 boxImpact( in vec3 pos, in vec3 ray, in vec3 ctr, in vec3 dim) \n{\n    vec3 m = 1.0/ray;\n    vec3 n = m*(ctr-pos);\n    vec3 k = abs(m)*dim;\n\t\n    vec3 t1 = n - k;\n    vec3 t2 = n + k;\n\n\tfloat tmax = max( max( t1.x, t1.y ), t1.z );\n\tfloat tmin = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tmax > tmin || tmin < 0.0) return vec4(vec3(0.),INFINI);\n\n    vec3 norm = -sign(ray)*step(t2, vec3(tmin));\n    return vec4(norm, tmin);\n    \n}\n\n\nbool checkWindow(in vec3 ctr){\n    float hash = Hsh2(ctr.xz+ctr.yy);\n    float a = step(.3,hash)*step(mod(ctr.y,10.),0.);\n    float b = step(.6,hash)*step(mod(ctr.y-1.,10.),0.);\n    return bool(a+b);\n}\n\nvec4 traceWindow(in vec3 pos, in vec3 ray, in float t, in vec3 norm){\n    vec3 p = pos + t*ray;\n    vec4 info = vec4(norm,t);\n\n    vec3 boxDim = vec3(.25,.025,.25);\n\tvec3 boxCtr;\n    \n    for(int i=0; i<5; i++){\n    \tboxCtr = vec3(floor(p.x*2.),floor(p.y*20.),floor(p.z*2.));\n        if(checkWindow(boxCtr)){\n            hitObj = SIDE;\n            float tf = t + .1/dot(ray,-norm);\n            info = boxImpact(pos, ray, (boxCtr+.5)*vec3(.5,.05,.5), boxDim);\n            if(tf < info.w){\n                hitObj = WIN;\n                info = vec4(norm,tf);\n                break;\n            } \n            p = pos + (info.w+.001)*ray;\n        }\n        else break;\n    }\n    return info;\n}\n\nvec3 moonGlow(in vec3 ray){\n    float a = dot(moonCtr, ray);\n    float dl = dot(moonRefl,ray);\n    float moon = smoothstep(.9,.902,a);\n    float shad = 1.-smoothstep(.4,.7,dot(moonShad, ray));\n    float refl = .7*smoothstep(.99,1.,dl);\n\tfloat clouds = min(1.,2.*texture(iChannel1,vec2(2.,-2.)*ray.xy-vec2(.2,.3)).r);\n    vec3 col = .8*(vec3(0.,.3,.6)+(1.-clouds))*moon+refl;\n    col += vec3(.3,.5,.8)*smoothstep(.88,.90,a)*(1.-smoothstep(.89,.95,a))*(dl-.9)*15.;\n\tcol *= shad;\n    col -= vec3(.1,.3,.5)*(1.-moon*shad);\n    col = clamp(col,0.,1.);\n    return col;\n}\n\nvec3 stars(in vec3 ray){\n    vec3 col = vec3(0.);\n    float az = atan(.5*ray.z,-.5*ray.x)/PIdiv2;\n    vec2 a = vec2(az,ray.y);\n    \n    float gr = .5+a.x+a.y;\n    float milky = 1.-smoothstep(0.,1.2,abs(gr));\n\tfloat nebu = 1.-smoothstep(0.,.7,abs(gr));\n\n    vec3 tex = texture(iChannel3,a+.3).rgb;\n    vec3 tex2 = texture(iChannel3,a*.1).rgb;\n\tvec3 tex3 = texture(iChannel3,a*5.).rgb;\n\tfloat dark = 1.-smoothstep(0.,.3*tex.r,abs(gr));\n    \n    vec2 dty =a*12.;\n    col += step(.85,Hsh2(floor(dty)))*(tex+vec3(.0,.1,.1))*max(0.,(.01/length(fract(dty)-.5)-.05));\n    \n    dty =a*30.;\n    col += step(.8,Hsh2(floor(dty)))*tex*max(0.,(.01/length(fract(dty)-.5)-.05))*milky;\n    \n    dty =a*1000.;\n    col += max(0.,Hsh2(floor(dty))-.9)*3.*tex3*milky;\n    \n    col += (.075+.7*smoothstep(.1,1.,(tex+vec3(.15,0.,0.))*.3))*nebu;\n    col += .5*smoothstep(0.,1.,(tex2+vec3(0.,.2,.2))*.2)*milky;\n\tcol -= .15*(tex3 * dark);\n    \n    return col;\n}\n\nvec3 fewStars(in vec3 ray){\n\tvec3 col = vec3(0.);\n    float az = atan(.5*ray.z,-.5*ray.x)/PIdiv2;\n    vec2 a = vec2(az,ray.y);\n    \n    vec3 tex = texture(iChannel3,a+.3).rgb;\n    vec2 dty =a*14.;\n    col += step(.85,Hsh2(floor(dty)))*(tex+vec3(.0,.1,.1))*max(0.,(.01/length(fract(dty)-.5)-.05));\n\n    return col*(1.-smoothstep(.6,.9,dot(moonCtr,ray)));\n}\n\n\nbool shadTrace(in vec3 pos, in vec3 v){\n\tfloat dh = 0.;\n    float t = 0.;\n    vec4 wall = vec4(0.);\n    \n    for(int i = 0;i<10;i++){       \n        vec3 p = pos + t*v;\n        if(p.y > TOP_SURFACE) break;       \n        float dh = p.y - map(p.xz);\n        if(dh<.0) return true;       \n        wall = getNextPlan(p.xz,v.xz,t);       \n        t+= wall.w + .0001 ;\n    }   \n    return false;   \n}\n\nfloat shadow(in vec3 p){\n    p += .00001*moonRefl;\n    if(shadTrace(p,moonRefl)) return .2;\n    else return 1.;\n}\n\nvec3 winGlow(in vec2 uv){\n    uv.x *= .2;\n    uv.y *= .5;\n    vec2 k1 = (uv-.05*sin(uv*10.))*10.,\n         k2 = (uv-.02*sin(uv*25.))*25.,\n         k3 = (uv-.01*sin(uv*50.))*50.;\n    \n    \n    vec2 p = floor(k1)/10.,\n         q = floor(k2)/25.,\n    \t s = floor(k3)/50.;\n    \n    vec2 bp = abs(fract(k1)-.5)\n    \t\t+ abs(fract(k2)-.5)\n    \t\t+ abs(fract(k3)-.5);\n    bp /= 1.5;\n    bp*=bp*bp;\n    \n    vec3 tex = texture(iChannel2,p).rgb\n    \t\t + texture(iChannel2,q).rgb\n    \t\t + texture(iChannel2,s).rgb;\n    \n    tex += .5*(bp.x+bp.y);\n    tex *= smoothstep(1.,2.8,tex.r);\n    \n\treturn tex;\n}\n\n\nfloat metalPlate(in vec2 st){\n    float coef = 0.;\n    \n    vec2 p = floor(st);\n    float hp = Hsh2(p*0.543234); hp *= step(.2,abs(hp-.5));\n    vec2 fp = fract(st)-.5;\n    vec2 sfp = smoothstep(.475,.5,abs(fp));\n    \n    st *= vec2(.5,1.);\n    vec2 q = floor(st*4.-.25);\n    float hq = Hsh2(q*0.890976); hq *= step(.35,abs(hq-.5));\n    vec2 fq = fract(st*4.-.25)-.5;\n    vec2 sfq = smoothstep(.45,.5,abs(fq));\n\t\n    st *= vec2(5.,.1);\n    vec2 r = floor(st*8.-.25);\n    float hr = Hsh2(r*0.123456); hr *= step(.47,abs(hr-.5));\n    vec2 fr = fract(st*8.-.25)-.5;\n    vec2 sfr = smoothstep(.4,.5,abs(fr));\n    \n    float h = max(max(hp,hq),hr);\n    if(bool(h)){\n        vec2 plate =    step(h,hp)*sfp*sign(fp)\n                      + step(h,hq)*sfq*sign(fq) \n                      + step(h,hr)*sfr*sign(fr);\n        \n        coef += .2*h+.8;\n        coef += .5*min(1.,plate.x+plate.y);\n    }\n    else coef = 1.;\n    \n    return coef;\n}\n\n\nfloat lightPath(in vec2 uv){    \n    return step(.965,Hsh(floor(uv.x*10.)))+step(.965,Hsh(floor(uv.y*10.)));\n}\n\nvec3 groundLight(in vec3 pos, in vec3 ray, in float t){\n    vec3 col = vec3(0.);\n   \tfloat ty = (.00001-pos.y)/ray.y;\n    ty += step(ty,0.)*INFINI;\n    pos += ty*ray;\n    if(ty<t) col += (.05/length(pos.xz*20. - vec2(floor(pos.xz*20.)+.5))-.08)\n        \t\t\t* lightPath(pos.xz);\n    return col;\n}\n\n\nfloat flare(in vec3 s, in vec3 ctr){\n    float c = 0.;\n\ts = normalize(s);\n    float sc = dot(s,-moonRefl);\n    c += .5*smoothstep(.99,1.,sc);\n    \n    s = normalize(s+.9*ctr);\n    sc = dot(s,-moonRefl);\n    c += .3*smoothstep(.9,.91,sc);\n    \n    s = normalize(s-.6*ctr);\n    sc = dot(s,-moonRefl);\n    c += smoothstep(.99,1.,sc);\n    \n    return c;\n}\n\n\nvec3 lensflare3D(in vec3 ray, in vec3 ctr)\n{\n    vec3 red = vec3(1.,.6,.3);\n    vec3 green = vec3(.3,1.,.6);\n    vec3 blue = vec3(.6,.3,1.);\n\tvec3 col = vec3(0.);\n    vec3 ref = reflect(ray,ctr);\n\n    col += red*flare(ref,ctr);\n    col += green*flare(ref-.15*ctr,ctr);\n    col += blue*flare(ref-.3*ctr,ctr);\n    \n    ref = reflect(ctr,ray);\n    col += red*flare(ref,ctr);\n    col += green*flare(ref+.15*ctr,ctr);\n    col += blue*flare(ref+.3*ctr,ctr);\n    \n    float d = dot(ctr,moonRefl);\n\treturn .4*col*max(0.,d*d*d*d*d);\n}\n\n\n\nvec3 getCamPos(in vec3 camTarget){\n    float \trau = 15.,\n            alpha = iMouse.x/iResolution.x*4.*PI,\n            theta = iMouse.y/iResolution.y*PI+(PI/2.0001);\t\n    \t\t\n            // to start shader\n    \t\tif (iMouse.xy == vec2(0.)){\n                float ts = smoothstep(18.,22.,iTime)*(iTime-20.);\n                float tc = smin( iTime, 30., 3. );\n                alpha = -2.-ts*.05;\n                theta = 1.5-tc*.05;\n            }\n    return rau*vec3(-cos(theta)*sin(alpha),sin(theta),cos(theta)*cos(alpha))+camTarget;\n}\n\nvec3 getRay(in vec2 st, in vec3 pos, in vec3 camTarget){\n    float \tfocal = 1.;\n    vec3 ww = normalize( camTarget - pos);\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0)) ) ;\n    vec3 vv = cross(uu,ww);\n\t// create view ray\n\treturn normalize( st.x*uu + st.y*vv + focal*ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = ( fragCoord.xy\n               // here below, shifting a little even coordinates (H and V).\n               // Do not really manage aliasing, but reduce strongly flickering due to aliasing\n               // Far from a good job, but it is absolutly costless!!\n               // comment the line below to compare\n               -.5*vec2(mod(fragCoord.y,2.),mod(fragCoord.x,2.))\n               - .5*iResolution.xy ) / iResolution.y; \n    float ti = iTime*.02;\n    \n    // camera def\n    vec3 camTarget = vec3(-50.*sin(2.*ti),2.1,-30.*cos(3.*ti));\n    //vec3 camTarget = vec3(0.);\n       \n    vec3 pos = getCamPos(camTarget);\n    pos.y = max(pos.y,map(pos.xz)+.1);\n    \n    vec3 ray = getRay(st, pos,camTarget);\n\t\n    bool moonside = bool(step(0.,dot(ray,moonRefl)));\n\t\n    vec3 color = vec3(.0);\n    float t = 0.;\n    vec3 norm = vec3(0.);\n\n    vec4 info = trace(pos, ray);\n    float sc = hitScale;\n    t = info.w;\n    norm = info.xyz;\n    \n    float shadow = shadow(pos+t*ray);\n    \n    if(t==INFINI){\n        if(moonside){\n            color += moonGlow(ray);\n            color += fewStars(ray);\n        }\n        else color += stars(ray);\n    }\n    else{\n        if(!bool(norm.y)) {\n            info = traceWindow(pos ,ray, t, norm);\n            if(bool(info.w)) {\n                norm = info.xyz;\n                t = info.w;\n            }\n        }\n        \n        vec3 p = pos + t*ray;\n\n        if(hitObj == WIN){\n            vec3 window = winGlow( ((p.xy+p.z)*norm.z + (p.zy+p.x)*norm.x))*(1.-norm.y);\n            vec3 refl = reflect(ray,norm);\n            color += smoothstep(.95,1.,dot(moonRefl,refl))*norm.z*step(1.,shadow);\n            color += window*min(1., 30./t);\n        }\n        \n        else{\n            vec2 side = .1*p.xz*norm.y + .5*p.xy*norm.z + .5*p.zy*norm.x;\n            color += texture(iChannel0,side).rgb;\n            color *= metalPlate(4.*side);\n            color += .015*vec3(.5*sc,abs(sc-4.),8.-sc) * min(1.,10./t);\n\n            color *= clamp(dot(norm, moonRefl)+.2,.3,1.);\n            if(hitObj == SIDE) color += vec3(.1,.05,.0);\n            else color *= shadow;\n            \n            vec3 refl = reflect(ray,norm);\n            color += .3*smoothstep(.9,1.,dot(moonRefl,refl))*norm.z*step(1.,shadow);;\n\n            color += texture(iChannel2,p.xz*.1).rgb*groundLight(pos, ray, t);\n            color -= 2.*texture(iChannel2,p.xz*.2).rgb*(norm.x+norm.z)*lightPath(p.xz)*step(.001,p.y)*step(p.y,.08);\n        \tcolor = clamp(color,0.,1.);\n        }\n        color *= min(1., 80./t);\n    }\n     if(moonside)\n    \tif(!shadTrace(pos,moonRefl))\n    \t\tcolor += lensflare3D(ray, getRay(vec2(0.), pos,camTarget));\n    \n\tfragColor = vec4(color,1.);\n}\n    \n    ",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec2 mainSound( in int samp, float time )\n{\n    return vec2(0.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 12827,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/carbonbasedlifeforms/accede"
                    }
                ],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}