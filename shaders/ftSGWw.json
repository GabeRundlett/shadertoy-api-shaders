{
    "Shader": {
        "info": {
            "date": "1623959109",
            "description": "model of the generation of snowflakes in nature\nyou can play with settings in the common and the bigger the screen the more the snowflake grows and the more complex it get",
            "flags": 32,
            "hasliked": 0,
            "id": "ftSGWw",
            "likes": 7,
            "name": "snowflake_",
            "published": 3,
            "tags": [
                "cellular",
                "snowflake",
                "nature",
                "generation"
            ],
            "usePreview": 0,
            "username": "mdb",
            "viewed": 363
        },
        "renderpass": [
            {
                "code": "/*\nsee in common for variables on the snowflake grow\n\nsee buffer A for the actual algo\n\n\n*/\n\nvec2 hexagon( vec2 p )\n{\n    // get the hexagonal coord from the cartesian coord system\n    // from https://www.shadertoy.com/view/Xd2GR3\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\t\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(pi.x + pi.y, 3.0);\n\n\tfloat ca = step(1.0, v);\n\tfloat cb = step(2.0, v);\n\tvec2  ma = step(pf.xy, pf.yx);\n\t\n\treturn vec2( pi + ca - cb * ma);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //hexagonal coordinate of the fragCoord\n    vec2 co = hexagon(fragCoord);\n    \n    //normalize the coordinate on the x axis\n    co /= iResolution.xy;\n    \n    //get the value of the cell\n    // cell.x <=> steam amount in the cell\n    // cell.y <=> 1 if cell is frozen else 0\n    vec2 cell = texture(iChannel0, co*0.5).xy;\n    \n    // color stuff\n    vec3 col = vec3(0.0, 0.5, 0.7);\n    col += cell.x - cell.y;\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// frame delay if you want to go full screen you need to do it before the cells init\n// else the snowflake will not be centered and might be corrupted\n// so make it something like 120 to give you 2sec before the end of the initialisation\n#define frameDelay 0\n\n//3 variables of the simulation\n\nconst float a = 0.6; // a < 1, initial amount of steam\nconst float b = 0.9; // a < 1, how much steam diffuse at each iteration from on cell to it's neighbors \nconst float c = 0.001; // steam generated at each iteration by the frozen cells\n\n/* \nfeel free to experiment with those 3 settings\n\ngood settings:\na,    b,    c\n0.6   0.4   0.001\n0.6   0.9   0.001\n0.6   0.99  0.0001\n0.6   0.9   0.004\n*/\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//sore the state of each cell and update it for the next gen\n\n// directions of neighbors on the exagonal grid\nconst vec2 dir[6] = vec2[](vec2(1.0, 0.0),\n                           vec2(-1.0, 0.0),\n                           vec2(0.0, 1.0),\n                           vec2(0.0, -1.0),\n                           vec2(1.0, 1.0),\n                           vec2(-1.0, -1.0));\n\nint type(vec2 cell){\n    //test if the cell is frozen\n    if(texture(iChannel0, cell/iResolution.xy).y > 0.5) return 1;\n    \n    for(int i = 0; i < 6; i++){ // for all neighbors\n        vec2 data = texture(iChannel0, (cell + dir[i])/iResolution.xy).xy;\n        if(data.y > 0.5)return 1;//a neighbors is frozen\n    }\n    return 2;  // no neighbor is frozen\n}\n           \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    //initialisation of all cells in the start\n    if(iFrame - frameDelay < 3){\n        float frozen = 0.0;\n        if(ivec2(fragCoord) - ivec2(iResolution.xy*vec2(0.28, 0.5)) == ivec2(0))frozen = 1.0;\n        fragColor = vec4(a, frozen, 0.0, 1.0);\n        return;\n    }\n    \n    // there is 2 type of cell, \n    // type 1: frozen cells or neighbor to a frozen cell\n    // type 2: others\n    // cells data is stored as vec2(steam density, float(is frosen))\n    \n    // each iteration is composed of 2 step\n    vec2 self = texture(iChannel0, uv).xy;\n    int selfType = type(fragCoord);\n    \n    // first, diffusion of steam \n    // type 2 cells give a part of their steam to neighbors\n    if(selfType == 2) self.x *= (1.0 - b);\n    \n    // get steam from all type 2 neighbors\n    for(int i = 0; i < 6; i++){\n        vec2 neighbor = texture(iChannel0, (fragCoord + dir[i])/iResolution.xy).xy;\n        if(type(fragCoord + dir[i]) == 2){\n            self.x += b / 6.0 * neighbor.x;\n        }\n    }\n    // then each type 1 cells get additional steam and if their steam amount >=1, they froze\n    if(selfType == 1){\n        self.x += c;\n        if(self.x >= 1.0) self.y = 1.0;\n    }\n    \n    \n    fragColor = vec4(self, 0.0, 1.0);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}