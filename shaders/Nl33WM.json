{
    "Shader": {
        "info": {
            "date": "1636170657",
            "description": "This is an illustration of the stratificational nexus of a welfare state regime. The darker patches are all equally poor, aided by government funding. The lighter patches are unevenly wealthy.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "Nl33WM",
            "likes": 24,
            "name": "Simplex Experiment #3b",
            "published": 3,
            "tags": [
                "triangles",
                "simplex"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 447
        },
        "renderpass": [
            {
                "code": "\n/*\nThis is an illustration of the stratificational nexus \nof a welfare state regime. The darker patches are all \nequally poor, aided by government funding. \n\nThe lighter patches are unevenly wealthy.\n\nThis is all bullshit btw lol.\n------------------------------------------------------\n\nThe magic of this shader is the movement \naided by the smoothmin function and a hacked together\nanimation sequence.\n*/\n\n//barycentric\n#define eps 8./iResolution.y\n#define S smoothstep\n\n//#define cross2D(a,b) a.y*b.x-a.x*b.y\n#define cross2D(a,b) (a).y*(b).x-(a).x*(b).y\n//skew matrix often written as \n//mat2 skew = mat2(1.1547, 0., 1.1547/2., 1.);\nmat2 skew = mat2(2./sqrt(3.), 0., 1./sqrt(3.), 1.); \n\n//This hash is pretty bad\nfloat badHash(vec2 x){\n    return fract(sin(dot(vec2(23.,72.),x)*134.)*43143.);\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n// based on comments from FabriceNeyret2\n// https://www.shadertoy.com/view/7d3SDS\n// super elegant\nvec2 bary(vec2 A, vec2 B, vec2 C, vec2 P,float smoothID){\n    \n    //We want areas for the three triangles created\n    //with out point P and the 3 sides\n    //we get a triangle with vectors AtoB and AtoP\n    //Repeat with B and C\n    vec3 tri = vec3(length(cross2D(B-A,P-A)),\n                    length(cross2D(C-B,P-B)),\n                    length(cross2D(A-C,P-C))\n                    );\n    //If P is in the middle, all areas are equal\n    //If P lays between two sub triangles, those areas\n    //will be equal and there will be one other area\n    \n    \n    //chill sort to find the smallest area triangle\n   \n    //id which we will swap simultenously\n    vec3 id = vec3(1.,2.,3.);\n   \n    //swap to get minumum at x\n    //swap remaining two to get minumum at y\n    if(tri.z < tri.y) tri = tri.xzy, id = id.xzy;\n    if(tri.y < tri.x) tri = tri.yxz, id = id.yxz;\n    if(tri.z < tri.y) tri = tri.xzy, id = id.xzy;\n    //with tri sorted, can do smoothstep without abs\n    \n    \n    //Those areas become a coordinate system because together \n    //they tell us relatively how close P is to any of \n    //the three sides.\n    \n    //so \"borders\" are like with uv.x-uv.y but now 3d \n    //border of area1 and area2 like (uv.y-uv.x)\n    float f1 = tri.y-tri.x - 0.04;\n    //border of area1 and area3 (uv.z-uv.y)\n    float f2 = tri.z-tri.x - 0.04;\n    return vec2(id.x, smin(f1,f2,smoothID*0.9));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 3.*(fragCoord*2.-iResolution.xy)/iResolution.y;\n    uv.x += iTime/4.;\n    \n    \n    uv *= skew;\n    vec2 uvFL = floor(uv);\n    uv = fract(uv);\n    vec2 f = 1.0 - S(0., eps, abs(uv-0.5)-0.47 );\n    float fd =  S(0., eps, abs(uv.x-uv.y)-0.02 );\n    float side = sign(uv.x-uv.y);\n    \n    \n    //the cool stuff\n    float smoothSeed = badHash(uvFL+float(side>0.)*0.5)*80.;\n    float smoothID = sin(smoothSeed +iTime\n    *4.)*0.5+0.5;\n    float closed = smoothstep(0.,0.5,sin(iTime/2.+smoothSeed)*0.5+0.5);\n    smoothID *= closed;\n\n\n    vec3 col;\n    \n    //get stuff from barycentric function\n    //stuff.x = the sub triangle id (1 to 3), stuff.y are outlines\n    vec2 stuff = bary(vec2(0.), \n                       vec2(1.,side<0.), \n                       vec2(side>0.,1.),\n                       uv,\n                       smoothID); //<--smoothID is for open/close anim\n    \n    //initial coloring\n    col = 0.6 + 0.3*cos(vec3(1.,2.,4.)/3. + \n          badHash(uvFL+side*0.5 + stuff.x/3.)*80. + iTime );\n  \n  \n    //do all the coloring(outlines, color when closed/not closed, etc)\n    col = mix(col, vec3(0.2), 1.-closed);\n    col += vec3(1.,0.,0.)*closed*0.18;\n    col *= f.x;\n    col *= f.y;\n    col *= fd;\n    col -= S(0.8,1.,(abs(sin(stuff.y*30.+2.))))*0.5;\n    col -= floor(stuff.y*30.)/24.;\n    col *= S(0.,eps,stuff.y);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}