{
    "Shader": {
        "info": {
            "date": "1635170614",
            "description": "Closed form fog integral of eight trilinearly interpolated colors. The solution actually integrates a linear interpolation, so can also easily be adapted for barycentric interpolation as well i.e. any tetrahedron.",
            "flags": 0,
            "hasliked": 0,
            "id": "NdySWG",
            "likes": 29,
            "name": "Constant Alpha Trilinear Fog",
            "published": 3,
            "tags": [
                "blending",
                "trilinear",
                "interpolation",
                "alpha"
            ],
            "usePreview": 0,
            "username": "paniq",
            "viewed": 794
        },
        "renderpass": [
            {
                "code": "\n// calculates the definite line integral of alphablending two colors through a fog volume\n// T is the logarithmic transmittance (0 .. -inf)\n// d is the distance of the ray\n// x is the end of the integral (0..1); pass 1 here if not sure\n// returns color mixing factors and alpha\nvec3 color_fog_mix_coeffs(float T, float d, float x) {\n    float Td = T*d; // scale transmittance by ray length\n    float acc_alpha = exp(Td*x); // occlusion accumulated along integral    \n    // integrated alpha\n    float w = 1.0 - acc_alpha;\n    // integrated color\n    float v = x * acc_alpha / (acc_alpha - 1.0) - 1.0 / Td;\n    float u = 1.0 - v;\n    return vec3(u, v, w);\n}\n\n/////////\n\nbool cube(vec3 org, vec3 dir, out float near, out float far) {\n    vec3 p = -org/dir;\n    vec3 q = 0.5/abs(dir);\n\tvec3 tmin = p - q;\n\tvec3 tmax = p + q;\n    near = max(tmin.x,max(tmin.y,tmin.z));\n\tfar = min(tmax.x,min(tmax.y,tmax.z));\n\treturn near < far && far > 0.0;\n}\n\n\nvoid transformray (vec3 ro, vec3 rd, mat2 rotationY, vec3 offset, out vec3 outro, out vec3 outrd)\n{\n\toutro = ro + offset;\n\toutro = vec3(rotationY * outro.xz, outro.y).xzy;\n\toutrd = vec3(rotationY * rd.xz, rd.y).xzy;\n}\n\n// alpha channel is unused\nconst float A = 0.0;\nconst float B = 0.0;\nvec4 C[8] = vec4[](\n#if 1\n    vec4(0,0,0,B),\n    vec4(1,0,0,A),\n    vec4(0,1,0,A),\n    vec4(1,1,0,B),\n    vec4(0,0,1,A),\n    vec4(1,0,1,B),\n    vec4(0,1,1,B),\n    vec4(1,1,1,A)\n#elif 0\n    vec4(1,1,1,A),\n    vec4(1,1,1,A),\n    vec4(1,1,1,A),\n    vec4(1,1,1,A),\n    vec4(1,1,1,B),\n    vec4(1,1,1,B),\n    vec4(1,1,1,B),\n    vec4(1,1,1,B)\n#elif 1\n    vec4(0,0,0,B),\n    vec4(1,0,0,B),\n    vec4(0,1,0,B),\n    vec4(1,1,0,B),\n    vec4(0,0,1,A),\n    vec4(1,0,1,A),\n    vec4(0,1,1,A),\n    vec4(1,1,1,A)\n#else\n    vec4(0,0,0,B),\n    vec4(1,0,0,A),\n    vec4(0,1,0,A),\n    vec4(1,1,0,A),\n    vec4(0,0,1,A),\n    vec4(1,0,1,A),\n    vec4(0,1,1,A),\n    vec4(1,1,1,B)\n#endif\n);\n\n// smallest non-inf number: exp(-103.9) or exp2(-149.99999)\n\nvec4 tf(vec4 s) {\n    return s;\n}\n\nvec4 tfinv(vec4 s) {\n    return s;\n}\n\nvec4 map(vec3 p) {\n    vec4 c00 = mix(tf(C[0]), tf(C[1]), p.x);\n    vec4 c01 = mix(tf(C[2]), tf(C[3]), p.x);\n    vec4 c10 = mix(tf(C[4]), tf(C[5]), p.x);\n    vec4 c11 = mix(tf(C[6]), tf(C[7]), p.x);\n    vec4 c0 = mix(c00, c01, p.y);\n    vec4 c1 = mix(c10, c11, p.y);\n    vec4 c = mix(c0, c1, p.z);    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// camera\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 p = -1.0 + 2.0 * q;\n\tp.x *= iResolution.x/iResolution.y;\n    p *= 0.55; // move camera closer\n\tvec3 camro = normalize(vec3(1.0, -0.1 + sin(iTime)*0.5+0.5, 0.0));\n\tvec3 w = -camro;\n\tcamro *= 2.5;\n\tvec3 u = normalize(cross( vec3(0.0, 1.0, 0.0), w ));\n\tvec3 v = normalize(cross(w,u));\n\tvec3 camrd = normalize(p.x * u + p.y * v + 1.5 * w);\n\tfragColor = vec4(0.0);\n\t\n\t// rotation\n\tfloat angle = 5.0 * iMouse.x / iResolution.x;\n\tif( iMouse.z < 0.5 )\n\t\tangle = iTime + 4.7;\n\tfloat ca = cos(angle);\n\tfloat sa = sin(angle);\n\tmat2  m = mat2(ca, -sa, sa, ca);\n\t\n\tfloat far, near;\n\tvec3 ro, rd;\n\t\n    vec3 c = vec3(0.0);\n    float k = 0.0;\n\t// cube\n\ttransformray(camro, camrd, m, vec3(0.0), ro, rd );\n    if (cube (ro, rd, near, far)) {\n        float d = (far - near);\n        vec3 p0 = (ro + rd * near)+0.5;\n        vec3 p1 = (ro + rd * far)+0.5;       \n        \n        vec4 c0 = map(p0);\n        vec4 c1 = map(p1);\n        \n        float alpha = mix(0.25,1.0,cos(iTime*0.25)*0.5+0.5);\n        vec3 a = tfinv(map(p0)).rgb; // source color\n        vec3 b = tfinv(map(p1)).rgb; // target color\n        float T = 1.0 - 1.0 / (1.0 - alpha); // convert to logarithmic transmittance\n        vec3 fog = color_fog_mix_coeffs(T*sqrt(2.0), d, 1.0);\n        k = fog.z;\n        c = fog.s * a + fog.t * b;\n    }\n    \n    // alpha blend\n    c = c*k + (texture(iChannel0, p*2.0).rrr * 0.2 + 0.2)*(1.0 - k);\n    \n    fragColor = vec4(pow(c, vec3(1.0/2.2)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}