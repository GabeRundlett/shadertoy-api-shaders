{
    "Shader": {
        "info": {
            "date": "1617028470",
            "description": "Here is a shader approximating Gerstner Waves... Based on https://catlikecoding.com/unity/tutorials/flow/waves/\nEnjoy!",
            "flags": 0,
            "hasliked": 0,
            "id": "7djGRR",
            "likes": 15,
            "name": "Gerstner Wave Approximation",
            "published": 3,
            "tags": [
                "waves",
                "water",
                "approximation",
                "gerstner"
            ],
            "usePreview": 0,
            "username": "Tech_",
            "viewed": 1314
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 120\n#define MAX_DIST 100.\n#define SURF_DIST .0001\n\n#define S smoothstep\n#define T iTime\n\n#define PI 3.1415\n#define SPEED 1.0\n\nstruct RayMarchObject \n{\n    int materialID;\n    float dist;\n};\n\n// Material struct currently only consists of an albedo color, but\n// can easily be extended\nstruct Material \n{\n    vec3 albedo;\n};\n\nMaterial[1] materials = Material[1](\n    Material(vec3(0.0, 0.35, 1.0))\n);\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 GerstnerWave(vec2 coord, float wavelength, float steepness, vec2 direction) \n{\n    const float gravitationalConst = 9.81;\n    \n    vec3 gerstner;\n    float k = 2.0 * PI / wavelength;\n    float c = sqrt(gravitationalConst / k);\n    float a = steepness / k;\n    vec2 dir = normalize(direction);\n    float f = k * (dot(dir, coord.xy) - c * iTime * SPEED);\n    \n    gerstner.x += dir.x * (a * cos(f));\n    gerstner.y = a * sin(f);\n    gerstner.z += dir.y * (a * cos(f));\n    \n    return gerstner;\n}\n\nRayMarchObject GetScene(vec3 p) \n{\n    vec3 waves;\n    waves += GerstnerWave(p.xz * 880.0, 60.0, 1.0, vec2(1, 1));\n    waves += GerstnerWave(p.xz * 880.0, 31.0, 1.0, vec2(1, 0.6));\n    waves += GerstnerWave(p.xz * 880.0, 18.0, 1.0, vec2(1, 1.3));\n    waves += GerstnerWave(p.xz * 880.0, 26.0, 1.0, vec2(0.7, 1.0));\n    waves += GerstnerWave(p.xz * 880.0, 22.0, 1.0, vec2(0.8, 0.6));\n    \n    waves *= 0.02;\n\n    float distGround = sdBox(p - waves * 0.01, vec3(0.1, 0.01, 0.1));\n    RayMarchObject ground = RayMarchObject(1, distGround);\n    \n    const int objectCount = 1;\n    RayMarchObject[objectCount] allObjects = RayMarchObject[objectCount](\n        ground\n    );\n    \n    //////////////////////////////////////////\n    \n    RayMarchObject finalObject = allObjects[0];\n    \n    for (int i = 0; i < objectCount - 1; i++) {\n        RayMarchObject currentObj = allObjects[i + 1];\n        if(currentObj.dist < finalObject.dist) finalObject = currentObj;\n    }\n    \n    return finalObject;\n}\n\nRayMarchObject RayMarch(vec3 ro, vec3 rd) \n{\n\tfloat dO=0.;\n    int materialID;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        RayMarchObject object = GetScene(p);\n        float dS = object.dist;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) {\n            materialID = object.materialID;\n            break;\n        }\n    }\n    \n    return RayMarchObject(materialID, dO);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetScene(p).dist;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetScene(p - e.xyy).dist,\n        GetScene(p - e.yxy).dist,\n        GetScene(p - e.yyx).dist);\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0.1, -0.05, -0.15);\n    \n    if(m.xy == vec2(0.0)) {\n        m = vec2(0.56, 0.6);\n    }\n       \n    ro.yz *= Rot(m.y + 0.2);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n   \n    RayMarchObject scene = RayMarch(ro, rd);\n\n    if(scene.dist < MAX_DIST) \n    {\n        vec3 p = ro + rd * scene.dist;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec3 cubeMap = textureLod(iChannel0, r, 2.0).rgb;\n        col = cubeMap;\n    } else \n    {\n        col = vec3(0.025, 0.02, 0.025);\n    }\n    \n    vec2 st = fragCoord / iResolution.xy;\n    col *= mix(sin(st.x * PI) * sin(st.y * PI), 1.0, 0.2);\n    \n    col = pow(col, vec3(.4545));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}