{
    "Shader": {
        "info": {
            "date": "1640537926",
            "description": "2D shader to play with distance functions, geometric shapes and color, also because it's cool :)\n\nIf it's slow, change AA to 1 (AA 2 is computing 4 samples per pixel).",
            "flags": 0,
            "hasliked": 0,
            "id": "7tGSzm",
            "likes": 21,
            "name": "Synthwave sunset logo",
            "published": 3,
            "tags": [
                "retro",
                "synthwave"
            ],
            "usePreview": 0,
            "username": "nyri0",
            "viewed": 868
        },
        "renderpass": [
            {
                "code": "#define AA 2\n#define NH 4\n#define NV 12\n#define PI 3.14159265\n\nfloat prm(float a, float b, float x) {\n    return clamp((x - a) / (b - a) , 0.0, 1.0);\n}\n\nfloat par(float x) {\n    return 1.0 - pow(2.0 * x - 1.0, 2.0);\n}\n\nfloat length_sq(vec2 x) {\n    return dot(x, x);\n}\n\nfloat segment_df(vec2 uv, vec2 p0, vec2 p1) {\n  float l2 = length_sq(p1 - p0);\n  float t = clamp(dot(uv - p0, p1 - p0) / l2, 0.0, 1.0);\n  vec2 projection = p0 + t * (p1 - p0);\n  return distance(uv, projection);\n}\n\n// https://stackoverflow.com/a/2049593/8259873\nfloat segment_side(vec2 p0, vec2 p1, vec2 p2)\n{\n    return (p0.x - p2.x) * (p1.y - p2.y) - (p1.x - p2.x) * (p0.y - p2.y);\n}\n\nbool triangle_in(vec2 uv, vec2 p0, vec2 p1, vec2 p2)\n{\n    float d0 = segment_side(uv, p0, p1);\n    float d1 = segment_side(uv, p1, p2);\n    float d2 = segment_side(uv, p2, p0);\n\n    bool has_neg = (d0 < 0.0) || (d1 < 0.0) || (d2 < 0.0);\n    bool has_pos = (d0 > 0.0) || (d1 > 0.0) || (d2 > 0.0);\n\n    return !(has_neg && has_pos);\n}\n\nfloat triangle_sdf(vec2 uv, vec2 p0, vec2 p1, vec2 p2) {\n    float p0p1 = segment_df(uv, p0, p1);\n    float p1p2 = segment_df(uv, p1, p2);\n    float p2p0 = segment_df(uv, p2, p0);\n    float abs_diff = min(p0p1, min(p1p2, p2p0));\n    return triangle_in(uv, p0, p1, p2) ? -abs_diff : abs_diff;\n}\n\nfloat sun_sdf(vec2 uv) {\n    bool is_in = true;\n    float t = mod(iTime, 4.0) / 4.0;\n    float lo[7] = float[7](0.2, 0.03, -0.14, -0.31, -0.48, -0.65, -0.8);\n    float hi[7] = float[7](0.2, 0.05, -0.1, -0.25, -0.4, -0.55, -0.7);\n    float bands_sdf = 10.0;\n    for(int i = 0; i < 6; i++) {\n        float low = mix(lo[i+1], lo[i], t);\n        float high = mix(hi[i+1], hi[i], t);\n        float band_sdf = max(uv.y-high, low-uv.y);\n        bands_sdf = min(bands_sdf, band_sdf);\n    }\n    float circle_sdf = length(uv) - 0.7;\n    return max(circle_sdf, -bands_sdf);\n}\n\nfloat sq(float x) {\n    return x * x;\n}\n\nbool palm_in(vec2 uv) {\n    const float ah[NH] = float[NH](0.1, 0.25, 1.5, 2.5);\n    const float bh[NH] = float[NH](0.2, 0.75, -0.37, -0.17);\n    const float ch[NH] = float[NH](-0.17, 0.07, -0.147, 0.255);\n    const float dh[NH] = float[NH](-0.8, -0.8, 0.3, 0.1);\n    const float eh[NH] = float[NH](0.3, 0.1, 0.57, 0.37);\n    const float fh[NH] = float[NH](-1.7, -1.7, 0.3, 0.1);\n    const float gh[NH] = float[NH](0.3, 0.1, 0.57, 0.37);\n    const float th0[NH] = float[NH](0.01, 0.01, 0.005, 0.005);\n    const float th1[NH] = float[NH](0.03, 0.03, 0.03, 0.03);\n\n    bool h_in = false;\n    for(int i = 0; i < NH; i++) {\n        float h_dist = abs(uv.x - (ah[i] * sq(uv.y + bh[i]) + ch[i]));\n        h_in = h_in || h_dist < mix(th0[i], th1[i], par(prm(fh[i], gh[i], uv.y)))\n            && uv.y > dh[i] && uv.y < eh[i];\n    }\n    \n    const float av[NV] = float[NV](-2.7, -1.6, -3.5, -3.5, -2.0, -2.5,\n                                   -2.0, -1.6, -3.0, -3.5, -2.5, -3.0);\n    const float bv[NV] = float[NV](0.17, 0.3, 0.35, -0.095, -0.02, 0.2,\n                                   -0.225, -0.095, -0.045, -0.495, -0.4, -0.248);\n    const float cv[NV] = float[NV](0.3, 0.35, 0.46, 0.5, 0.35, 0.31,\n                                   0.1, 0.15, 0.25, 0.3, 0.15, 0.1);\n    const float dv[NV] = float[NV](-0.5, -0.65, -0.5, -0.15, -0.15, -0.15,\n                                   -0.155, -0.255, -0.1, 0.26, 0.26, 0.25);\n    const float ev[NV] = float[NV](-0.14, -0.14, -0.14, 0.15, 0.25, 0.15,\n                                   0.255, 0.255, 0.255, 0.57, 0.645, 0.545);\n\n    bool v_in = false;\n    for(int i = 0; i < NV; i++) {\n        float v_dist = abs(uv.y - (av[i] * sq(uv.x + bv[i]) + cv[i]));\n        v_in = v_in || v_dist < mix(0.005, 0.04, par(prm(dv[i], ev[i], uv.x)))\n            && uv.x > dv[i] && uv.x < ev[i];\n    }\n\n    return h_in || v_in;\n}\n\nmat2 rotation_mat(float alpha) {\n    float c = cos(alpha);\n    float s = sin(alpha);\n    return mat2(c, s, -s, c);\n}\n\nvec4 sampleColor(in vec2 sampleCoord)\n{\n    // uv is centered and such that the vertical values are between -1\n    // and 1 while preserving the aspect ratio.\n    vec2 uv = 2.0* (sampleCoord - iResolution.xy / 2.0) / iResolution.y;\n\n    const vec3 BG = vec3(0.1, 0.1, 0.2);\n    vec3 cyan = vec3(0.3, 0.85, 1);\n    vec3 magenta = vec3(1, 0.1, 1);\n    float t = sin(0.3 * cos(0.2 * iTime) * uv.x + uv.y + 1.0 + 0.15 * cos(0.3 * iTime));\n    vec3 cm = mix(cyan, magenta, t*t);\n    vec3 mc = mix(magenta, cyan, t*t);\n    \n    vec2 a = vec2(0, -0.9);\n    vec2 b = vec2(-1.0, 0.4);\n    vec2 c = vec2(1.1, 0.6);\n    \n    float alpha = 0.25 * cos(0.5 * iTime);\n    float gamma = -0.1 + 0.2 * cos(PI + 0.5 * iTime);\n    float beta = (alpha + gamma) / 2.0;\n    mat2 alpha_mat = rotation_mat(alpha);\n    mat2 beta_mat = rotation_mat(beta);\n    mat2 gamma_mat = rotation_mat(gamma);\n\n    vec2 t0a = alpha_mat * a;\n    vec2 t0b = alpha_mat * b;\n    vec2 t0c = alpha_mat * c;\n    vec2 t1b = mix(t0a, t0b, 3.0);\n    vec2 t1c = mix(t0a, t0c, 3.0);\n    vec2 t2a = beta_mat * a;\n    vec2 t2b = beta_mat * b;\n    vec2 t2c = beta_mat * c;\n    vec2 t3a = gamma_mat * a;\n    vec2 t3b = gamma_mat * b;\n    vec2 t3c = gamma_mat * c;\n    \n    float sun = sun_sdf(uv);\n    bool palm = palm_in(uv);\n    float tri0_sdf = triangle_sdf(uv, t0a, t0b, t0c);\n    float tri1_sdf = triangle_sdf(uv, t0a, t1b, t1c);\n    float tri2_sdf = triangle_sdf(uv, t2a, t2b, t2c);\n    float tri3_sdf = triangle_sdf(uv, t3a, t3b, t3c);\n    \n    vec3 col = BG;\n    \n    if(tri3_sdf < 0.0) col = vec3(0);\n    else if(tri3_sdf < 0.01) col = mc;\n    if(tri2_sdf < 0.0) col = mc;\n    if(tri0_sdf < 0.0) col = vec3(0);\n    else if(tri0_sdf < 0.01) col = mc;\n    if(tri1_sdf < 0.0) col = mix(cm, col, smoothstep(0.0, 0.01, sun));\n    if(tri1_sdf < 0.0 && palm) col = vec3(0);\n\n    return vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 colSum = vec4(0);\n    for(int i = 0; i < AA; i++) {\n        for(int j = 0; j < AA; j++) {\n            colSum += sampleColor(fragCoord + vec2(float(i) / float(AA), float(j) / float(AA)));\n        }\n    }\n    fragColor = colSum / colSum.w;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}