{
    "Shader": {
        "info": {
            "date": "1610165607",
            "description": "WASD/Arrows and mouse to move camera. Q/E regulate camera speed. Press P/L to set light 1/2 position around camera.",
            "flags": 48,
            "hasliked": 0,
            "id": "wttyDX",
            "likes": 87,
            "name": "Mandelcloud explorer",
            "published": 3,
            "tags": [
                "fractal",
                "interactive",
                "mandelbulb",
                "volumetric",
                "pathtracing",
                "importance"
            ],
            "usePreview": 0,
            "username": "michael0884",
            "viewed": 2404
        },
        "renderpass": [
            {
                "code": "//Volumetric fractal explorer \n\n//MIT License\n//Copyright 2020 Mykhailo Moroz\n\n//Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n//assume as \"Do whatever you want\" License\n\n//Features:\n//Multiple light sources(importance sampled)\n//Anisotripic scatteringw\n//Multibounce scattering\n//Camera controls\n//Light position control\n//Approximate volumetric reprojection for temporal denoising\n\n//Instructions\n//WASD/Arrows and mouse to move camera. Q/E regulate camera speed. \n//Press P/L to set light 1/2 position around camera.\n//Change parameters in Common tab\n//TAA regulates denoising\n//Set AMBIENT_FOG to 0.0 to disable fog(improves performace)\n//comment LOW_QUALITY for longer light paths\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    vec4 data = texture(iChannel0, p/iResolution.xy);\n    c = 1.07*tanh(pow(data/data.w, vec4(0.6)));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define LOW_QUALITY\n\n//short or long light paths\n#ifdef LOW_QUALITY\n    #define MAX_STEPS 20\n    #define SCALING 0.1\n    #define DITHER 0.5\n    #define TRACE_STEPS 8\n    //potato mode\n    //#define TRACE_STEPS 3\n    #define ERROR_THRESHOLD 0.8\n    //the probability of scattering into a shadow direction, i.e. inverse scattering strength \n    #define SHADOW_SCATTER_P 0.75\n    //temporal denoiser\n    #define TAA 0.98\n#else\n    #define MAX_STEPS 32\n    #define SCALING 0.1\n    #define DITHER 0.5\n    #define TRACE_STEPS 32\n    #define ERROR_THRESHOLD 0.3\n    #define SHADOW_SCATTER_P 0.99\n    #define TAA 0.999\n#endif\n\n#define MAX_DIST 10.0\n#define ABSORPSION 0.78\n#define SCATTERING 1.0\n\n#define ANISOTROPY 0.3\n\n#define AMBIENT_FOG 0.16\n#define LIGHT_RAD 0.02\n#define LIGHT_BRIGHTNESS 250.0\n\n\n#define SCATTER_K 100.\n\n//cloud sharpness\n#define sharpness 0.00001\n#define DENSITY 16.0\n\n//standard constants\n#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n\n#define N 10\n\n#define MOUSE_ 0\n#define CAM_ANGLE_ 1\n#define CAM_POS_ 2\n#define CAM_VEL_ 3\n#define CAM_MAX_VEL_ 4\n#define LIGHT_POS1_ 5\n#define LIGHT_POS2_ 6\n#define PCAM_ANGLE_ 7\n#define PCAM_POS_ 8\n#define PRESOLUTION_ 9\n\n#define GET_DATA(i) texelFetch(iChannel2, ivec2(i, 0), 0)\n\n//CAMERA stuff\n#define FOV 1.0\n\nmat3 get_cam(float phi, float theta)\n{\n    vec3 x_dir = vec3(cos(phi)*sin(theta), sin(phi)*sin(theta), cos(theta));\n    vec3 y_dir = normalize(cross(x_dir, vec3(0,0,1)));\n    vec3 z_dir = normalize(cross(x_dir, y_dir));\n    return mat3(x_dir, y_dir, z_dir);\n}\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nfloat rand()\n{\n    pcg4d(s0); return float(s0.x)/float(0xffffffffu);\n}\n\nvec2 rand2()\n{\n    pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);\n}\n\nvec3 rand3()\n{\n    pcg4d(s0); return vec3(s0.xyz)/float(0xffffffffu);\n}\n\nvec4 rand4()\n{\n    pcg4d(s0); return vec4(s0)/float(0xffffffffu);\n}\n\n//random blue noise sampling pos\nivec2 shift2()\n{\n    pcg4d(s1); \n    return (pixel + ivec2(s1.xy%0x0fffffffu))%1024;\n}\n\n//uniformly spherically distributed\nvec3 udir(vec2 rng)\n{\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n\nfloat HenyeyGreenstein(float g, float costh)\n{\n    return (1.0 - g * g) / (4.0 * PI * pow(1.0 + g * g - 2.0 * g * costh, 3.0/2.0));\n}\n\n \nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nmat2 rot(float ang)\n{\n    return mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n}\n\n//Keyboard constants\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\n\n//from https://www.shadertoy.com/view/XsSXDy\nvec4 powers( float x ) { return vec4(x*x*x, x*x, x, 1.0); }\n\nconst vec4 ca = vec4(   3.0,  -5.0,   0.0,  2.0 ) /  2.0;\nconst vec4 cb = vec4(  -1.0,   5.0,  -8.0,  4.0 ) /  2.0;\n\nvec4 spline( float x, vec4 c0, vec4 c1, vec4 c2, vec4 c3 )\n{\n    // We could expand the powers and build a matrix instead (twice as many coefficients\n    // would need to be stored, but it could be faster.\n    return c0 * dot( cb, powers(x + 1.0)) + \n           c1 * dot( ca, powers(x      )) +\n           c2 * dot( ca, powers(1.0 - x)) +\n           c3 * dot( cb, powers(2.0 - x));\n}\n\n\n#define SAM(a,b)  texture(tex, (i+vec2(float(a),float(b))+0.5)/res, -99.0)\n\nvec4 texture_Bicubic( sampler2D tex, vec2 t )\n{\n    vec2 res = vec2(textureSize(tex,0));\n    vec2 p = res*t - 0.5;\n    vec2 f = fract(p);\n    vec2 i = floor(p);\n\n    return spline( f.y, spline( f.x, SAM(-1,-1), SAM( 0,-1), SAM( 1,-1), SAM( 2,-1)),\n                        spline( f.x, SAM(-1, 0), SAM( 0, 0), SAM( 1, 0), SAM( 2, 0)),\n                        spline( f.x, SAM(-1, 1), SAM( 0, 1), SAM( 1, 1), SAM( 2, 1)),\n                        spline( f.x, SAM(-1, 2), SAM( 0, 2), SAM( 1, 2), SAM( 2, 2)));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "float min_step;\n\n//light positions\nvec3 lpos1, lpos2;\n\n//blue noise\nvec4 rand4blue()\n{\n    return texelFetch(iChannel1, shift2(), 0);\n}\n\nvec4 mandelbulb_fog(vec3 p, float K) {\n    vec3 w = p;\n    float m = dot(w, w);\n    vec3 orbitTrap = vec3(1.);\n\tfloat dz = 1.0;\n    for(int i = 0; i < 5; i++){\n        if(m > 1.2) break;\n        float m2 = m*m;\n        float m4 = m2*m2;\n\t\tdz = 8.0*sqrt(m4*m2*m)*dz + 1.0;\n        float x = w.x; float x2 = x*x; float x4 = x2*x2;\n        float y = w.y; float y2 = y*y; float y4 = y2*y2;\n        float z = w.z; float z2 = z*z; float z4 = z2*z2;\n        float k3 = x2 + z2;\n        float k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );\n        float k1 = x4 + y4 + z4 - 6.0*y2*z2 - 6.0*x2*y2 + 2.0*z2*x2;\n        float k4 = x2 - y2 + z2;\n        w.x = p.x +  64.0*x*y*z*(x2-z2)*k4*(x4-6.0*x2*z2+z4)*k1*k2;\n        w.y = p.y + -16.0*y2*k3*k4*k4 + k1*k1;\n        w.z = p.z +  -8.0*y*k4*(x4*x4 - 28.0*x4*x2*z2 + 70.0*x4*z4 - 28.0*x2*z2*z4 + z4*z4)*k1*k2;\n        m = dot(w, w);\n        orbitTrap = min(abs(w)*1.2, orbitTrap);\n    }\n    float sdf = 0.25*log(m)*sqrt(m)/dz;\n    vec3 col = max(1. - orbitTrap, 0.0)*smoothstep(K,0.0,sdf);\n    return vec4(DENSITY*col, sdf);\n}\n\nvec4 box_fog(vec3 p, vec3 b, float k)\n{\n    vec3 refl = normalize(vec3(0.4,0.6,0.9));\n    float sc = 1.0;\n    for(int i = 0; i < 6; i++)\n    {\n        refl.xy = rot(1.6)*refl.xy;\n        p -= 2.*max(dot(refl, p), 0.)*refl;\n        refl.yz = rot(2.1)*refl.yz;\n        p += 0.015*sin(10.*dot(refl,p) + sin(p.x*p.y));\n    }\n    float sdf = sdBox(p,b)/sc;\n    return vec4(DENSITY*(vec3(.3, .6, .9)* + (0.5 + 0.5*sin(40.*vec3(0.392,0.580,1.000)*p.x)))*smoothstep(k,-k,sdf), sdf);\n}\n\nvec4 density(vec3 p){\n    vec4 box = mandelbulb_fog(p, sharpness);//box_fog(p, vec3(0.7,0.3,0.2), sharpness); \n    float shells = min(MAX_DIST + 5.0 - length(p), min(distance(p, lpos1),distance(p, lpos2))); //light source and background\n    return vec4(box.xyz + vec3(0.141,0.439,1.000)*AMBIENT_FOG, min(box.w, shells));\n}\n\n\nvec4 choose_light(vec3 p, float r)\n{\n    float t1 = distance(lpos1, p);\n    float t2 = distance(lpos2, p);\n    float prob = t1*t1/(t1*t1+t2*t2);\n    return (r > prob)?vec4(lpos1, 1.-prob):vec4(lpos2, prob);\n}\n\n//trace a multibounce light path to the lights\nvec3 trace(vec3 ro, vec3 id, float dither)\n{\n    //cumulative opacity\n    vec3 k = vec3(1.0);\n    //cumulative scattering\n    vec3 sk = vec3(1.0);\n  \n    float step_size;\n    float td = 0.;\n    \n    vec3 pdf = vec3(1.0);\n   \n    //light importance sampling   \n    vec4 l = choose_light(ro, rand());\n  \n    //light choise pdf\n    pdf*=l.w;\n    vec3 rd = id;\n    float dist = MAX_DIST;\n    \n    int i = 0;\n    \n    dist = distance(l.xyz, ro)+2e-2;\n   \n    pdf*= 4.*PI*dist*dist;\n     dist = MAX_DIST;\n    bool shadowray = false;\n    for(; i < TRACE_STEPS; i++)\n    { \n        vec4 rho = density(ro);\n        step_size = (1.0 - DITHER*dither)*max(rho.w,max(max(min_step,SCALING*td),5e-5*length(rho)));\n        \n        vec3 absorption = exp(-step_size*rho.xyz*ABSORPSION); \n        \n        //accumulate\n        k *= absorption; \n        \n        vec4 r = rand4();\n        td += step_size;\n        //do a scatter\n        if(!shadowray)\n        {\n            //total scattering probability \n            sk *= exp(-step_size*rho.xyz*SCATTERING);\n            \n            //shoot shadow ray \n            if(r.w < SHADOW_SCATTER_P) \n            {\n                pdf*=SHADOW_SCATTER_P/0.5;\n                shadowray = true;\n                vec3 prd = rd;\n                dist = distance(l.xyz, ro)+2e-2;\n                rd = (l.xyz - ro)/dist;\n                \n                //anisotropic scattering \n                pdf/= HenyeyGreenstein(ANISOTROPY, dot(prd, rd));\n                pdf/= (1. - sk);\n            }\n            else //else do normal scattering\n            {\n               \n                rd = normalize(mix(udir(r.yz),rd,exp(-step_size*rho.xyz*SCATTER_K*SCATTERING*(1. - ANISOTROPY))));\n            }\n            td = 0.;\n        }\n\n        \n        if(length(k) < 0.07 || distance(ro, vec3(0)) > 2.0 || td > dist) break;\n        //step ray\n        ro += rd*step_size;\n\n       \n    }\n    return smoothstep(ERROR_THRESHOLD, 0.0, dist - td)*LIGHT_BRIGHTNESS*k*smoothstep(0.068,0.07,length(k))/pdf;\n}\n\n//use previous camera matrix and camera position to reproject a point onto previous frame\nvec3 reproject(mat3 pcam_mat, vec3 pcam_pos, vec2 iRes, vec3 p)\n{\n    float td = distance(pcam_pos, p);\n    vec3 dir = (p - pcam_pos)/td;\n    vec3 screen = inverse(pcam_mat)*dir;\n    return vec3(screen.yz*iRes.y/(FOV*screen.x) + 0.5*iRes.xy, td);\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    rng_initialize(p, iFrame);\n    min_step = 1.25/DENSITY;\n    vec2 uv = (p - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec2 angles = GET_DATA(CAM_ANGLE_).xy;\n    mat3 cam = get_cam(angles.x, angles.y);\n \n    vec3 campos = GET_DATA(CAM_POS_).xyz; \n    vec3 ro = campos;\n    vec3 rd = normalize(cam*vec3(1.0, FOV*uv));\n    \n    lpos1 = GET_DATA(LIGHT_POS1_).xyz;\n    lpos2 = GET_DATA(LIGHT_POS2_).xyz;\n    \n    vec4 brand = rand4blue();\n    \n    float dither = brand.x;\n    //cumulative opacity\n    vec3 k = vec3(1.0);\n    \n    //accumulated incoming light to the camera\n    vec3 col = vec3(0.); \n    int L = 0;\n    \n    //main camera ray\n    float step_size;\n    \n    float td = 0.;\n    vec4 maxl_p = vec4(0.);\n    \n    int i = 0;\n    for(; i < MAX_STEPS; i++)\n    {\n        vec4 rho = density(ro);\n\n        step_size = (1.0 - DITHER*dither)*max(rho.w,max(max(min_step,SCALING*td),2e-5*length(rho)));\n        \n        vec2 ldis = vec2(distance(lpos1, ro),distance(lpos2, ro));\n        \n        vec3 absorption = exp(-(ABSORPSION + SCATTERING)*step_size*rho.xyz); \n       \n        col += vec3(LIGHT_BRIGHTNESS/10.)*k.xyz*(step(ldis.x,LIGHT_RAD) + step(ldis.y,LIGHT_RAD));\n        \n        if((rho.z > 0.005 && i%4 == 0) || (rho.z > 4.0))\n        {\n            vec3 incoming = trace(ro, rd, brand.z);\n            float pdf = (rho.z > 0.005 && rho.z < 4.0)?0.25:1.0;\n            col += k.xyz*incoming/pdf; \n        }\n       \n        //accumulate\n        k *= absorption;\n        \n        td += step_size;\n        ro += step_size*rd;\n    \n         \n        if(length(k) < 0.2 || distance(ro, vec3(0)) > MAX_DIST) break;\n    }\n    \n    //col = vec3(distance(maxl_p.xyz, campos)/3.);\n    \n    vec2 pcam_angles = GET_DATA(PCAM_ANGLE_).xy;\n    mat3 pcam = get_cam(pcam_angles.x, pcam_angles.y);\n    vec3 pcam_pos = GET_DATA(PCAM_POS_).xyz;\n    \n    vec2 prev_iResolution = GET_DATA(PRESOLUTION_).xy;\n    \n    //reproject\n    vec3 reprj = reproject(pcam, pcam_pos, prev_iResolution, ro);\n    vec2 puv = reprj.xy/iResolution.xy;\n    vec2 dpuv = abs(puv - vec2(0.5));\n    \n    float accumulation = TAA //max accumulation\n                         *mix(1.0, 0.85, smoothstep(0.0, 0.01, distance(campos,pcam_pos))) //reduce accumulation if moving \n                         *step(dpuv.x, 0.5)*step(dpuv.y, 0.5); //outside prev frame\n    //sample prev point\n    // vec4 prev = texture(iChannel0, puv);\n    vec4 prev = texture_Bicubic(iChannel0, puv);\n    \n    prev *= accumulation; //remove samples\n   \n    \n    c = vec4(col,1.0) + prev;\n    \n    if(iFrame < 2) c = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Controller\n\n#define CAMERA_SPEED 3./60.\n#define MOUSE_SENSITIVITY 0.2/60.\n\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    ivec2 pi = ivec2(p);\n    if(pi.x < N && pi.y < 1)\n    {\n        c = GET_DATA(pi.x);\n        \n        vec4 mouse = GET_DATA(MOUSE_);\n        vec2 mousespeed = mouse.xy;\n        vec4 angles = GET_DATA(CAM_ANGLE_);\n        mat3 camera = get_cam(angles.x, angles.y);\n        vec4 pos = GET_DATA(CAM_POS_);\n        vec4 vel = GET_DATA(CAM_VEL_);\n        vec4 speed = GET_DATA(CAM_MAX_VEL_);\n     \n        switch(pi.x)\n        {\n        case MOUSE_:  //mouse speed calculation \n            if(length(iMouse.zw - iMouse.xy) > 10.)\n  \t\t    {\n   \t\t\t\tc.xy = iMouse.xy - c.zw; // mouse delta\n                if(iFrame < 1)\n                {\n                    c.xy = vec2(0.);\n                }\n            }\n            else\n            {\n\t\t\t\tc.xy = vec2(0.); // mouse delta\n            }\n    \t\tc.zw = iMouse.xy; // mouse pos\n            break;\n            \n        case CAM_ANGLE_:  //angle computation\n           \n   \t\t\tc.xy = c.xy + c.zw*MOUSE_SENSITIVITY; // angle delta\n            c.y = clamp(c.y, PI*0.01, PI*0.99);\n    \t\tc.zw += vec2(-1.0, 1.0)*mouse.xy; // mouse pos\n            c.zw *= 0.6;\n            if(iFrame < 1)\n            {\n                c.xy = vec2(-PI*0.27,PI*0.5);\n            }\n            break;\n            \n        case CAM_POS_:  //position\n            if(pos.w > 0.) {c.xyz += 0.05*vec3(sin(iTime), cos(iTime), 0.)*speed.x; c.w = pos.w;}\n            c.xyz += vel.xyz*speed.x;\n            if(length(vel.xyz)>0.1) c.w = 0.;\n   \t\t\tif(iFrame < 1)\n            {\n                c = vec4(-1.5,1.5,0.0,1.0);\n            }\n            \n            break;\n         case CAM_VEL_:  //velocity\n          \n            c.w++;\n            if(length(mousespeed) >0. || isKeyPressed(KEY_Z))\n            {\n                c.w = 0.;\n            }\n            if(isKeyPressed(KEY_UP) || isKeyPressed(KEY_W))\n   \t   \t\t{\n   \t\t\t\tc.xyz += camera[0]*speed.x;\n                c.w = 0.;\n            }\n            if(isKeyPressed(KEY_DOWN) || isKeyPressed(KEY_S))\n   \t   \t\t{\n   \t\t\t\tc.xyz -= camera[0]*speed.x;\n                c.w = 0.;\n            }\n            if(isKeyPressed(KEY_RIGHT) || isKeyPressed(KEY_D))\n   \t   \t\t{\n   \t\t\t\tc.xyz += camera[1]*speed.x;\n                c.w = 0.;\n            }\n            if(isKeyPressed(KEY_LEFT) || isKeyPressed(KEY_A))\n   \t   \t\t{\n   \t\t\t\tc.xyz -= camera[1]*speed.x;\n                c.w = 0.;\n            }\n            c.xyz *= 0.8; //slowing down\n            \n            break;\n          case CAM_MAX_VEL_: //camera max speed\n            if(isKeyPressed(KEY_Q))\n   \t   \t\t{\n   \t\t\t\tc.x *= 1.01;\n            }\n            if(isKeyPressed(KEY_E))\n   \t   \t\t{\n   \t\t\t\tc.x *= 0.99;\n            }\n            if(iFrame < 1)\n            {\n                c.x = CAMERA_SPEED;\n            }\n            break; \n          case LIGHT_POS1_:\n            if(isKeyPressed(KEY_P))\n   \t   \t\t{\n                c.xyz = pos.xyz+camera[0]*vec3(LIGHT_RAD*40.);\n            }\n            if(iFrame < 1)\n            {\n                c.xyz = vec3(0.2, 1.0, -0.4);\n            }\n            break;\n          case LIGHT_POS2_:\n            if(isKeyPressed(KEY_L))\n   \t   \t\t{\n                c.xyz = pos.xyz+camera[0]*vec3(LIGHT_RAD*40.);\n            }\n            if(iFrame < 1)\n            {\n                c.xyz = vec3(-0.8, 0., 0.);\n            }\n            break;\n          case PCAM_ANGLE_:\n            c = angles;\n            break;\n          case PCAM_POS_:\n            c = pos;\n            break;\n          case PRESOLUTION_:\n            c.xy = iResolution.xy;\n            break;\n        }   \n    } else discard;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}