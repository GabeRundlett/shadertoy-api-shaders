{
    "Shader": {
        "info": {
            "date": "1567686028",
            "description": "Mouse - move light\nQ - regenerate everything\nW - regenerate cliff layer\nE - regenerate shadow masks",
            "flags": 48,
            "hasliked": 0,
            "id": "tsd3Rn",
            "likes": 2,
            "name": "tile shadows",
            "published": 3,
            "tags": [
                "shadow"
            ],
            "usePreview": 0,
            "username": "elementbound",
            "viewed": 402
        },
        "renderpass": [
            {
                "code": "#define DATA_BUFFER iChannel2\n\n#define SHADOW_SAMPLES 128\n\n// #define UMBRA_ENABLED\n#define UMBRA_SAMPLES 8\n#define UMBRA_SIZE 16.0\n\nfloat checkLight(vec2 a, vec2 b, sampler2D mask) {\n    float value = 1.0;\n    \n    for(int i = 0; i < SHADOW_SAMPLES; i++) {\n        float f = random(vec4(b, iTime, i));\n        vec2 p = mix(a, b, f);\n        \n        value = min(value, texelFetch(mask, ivec2(p), 0).r);\n        // value = min(value, texture(mask, p / iResolution.xy).r);\n    }\n    \n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 lightPos = getValue(DATA_BUFFER, 0).xy;\n    \n    float lightFactor = 0.0;\n    \n    #ifdef UMBRA_ENABLED\n        for(int i = 0; i < UMBRA_SAMPLES; i++) {\n            float dir = random(vec4(fragCoord, iTime, i)) * 6.283;\n            float dst = random(vec4(fragCoord, iTime, i * 17));\n                               \n            vec2 offset = vec2(cos(dir), sin(dir)) * dst * UMBRA_SIZE;\n            \n            lightFactor += checkLight(lightPos + offset, fragCoord, iChannel1);\n        }\n    \n    \tlightFactor /= float(UMBRA_SAMPLES);\n    #else\n    \tlightFactor = checkLight(lightPos, fragCoord, iChannel1);\n    #endif\n    \n    fragColor = texture(iChannel0, uv) * max(lightFactor, 0.375);\n    fragColor *= max(texture(iChannel1, uv).r, 0.5);\n    //fragColor = texture(iChannel1, uv); // Shadow mask\n    //fragColor = vec4(texture(iChannel3, uv).a); // Cliff layer\n    //fragColor = vec4(lightFactor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Data buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    if(iFrame == START_FRAME) {\n        // Light starts in the middle of space\n        if(isIndex(0, fragCoord)) {\n\t\t\tfragColor = vec4(0.5, 0.5, 0.0, 0.0);\n        }\n        \n        if(isIndex(1, fragCoord)) {\n            fragColor = vec4(iResolution, 0);\n        }\n        \n        if(isIndex(2, fragCoord)) {\n            fragColor = vec4(0);\n        }\n    } else {\n        if(iMouse.z > 0.5 && isIndex(0, fragCoord)) {\n            fragColor = vec4(iMouse.xy, 0.0, 0.0);\n        }\n        \n        if(getValue(iChannel0, 2) != vec4(0)) {\n            if(isIndex(1, fragCoord)) {\n            \tfragColor = vec4(iResolution, 0);\n            }\n            \n            if(isIndex(2, fragCoord)) {\n            \tfragColor = vec4(0);\n            }\n        }\n        \n        if(getValue(iChannel0, 1).xyz != iResolution && isIndex(2, fragCoord)) {\n            fragColor = vec4(1);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Source:\n// https://stackoverflow.com/a/17479300\n\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\n// Data buffer\nbool isIndex(int index, vec2 fragCoord) {\n    return index == int(fragCoord.x);\n}\n\nvec4 getValue(sampler2D buffer, int index) {\n    return texelFetch(buffer, ivec2(index, 0), 0);\n}\n\n// Keyboard\n#define KEY_Q 81\n#define KEY_W 87\n#define KEY_E 69\n\nbool key_pressed(sampler2D keyboard, int key) {\n    return texelFetch(keyboard, ivec2(key, 1), 0).x != 0.0;\n}\n\n// Map\n#define MAP_WIDTH 9\n#define MAP_HEIGHT 11\n\nconst int[MAP_WIDTH * MAP_HEIGHT] map = int[MAP_WIDTH * MAP_HEIGHT] (\n    0, 0, 0, 1, 0, 0, 0, 0, 0,\n    0, 1, 1, 1, 0, 1, 1, 1, 0,\n    0, 1, 1, 1, 0, 1, 1, 1, 0,\n    0, 1, 0, 0, 0, 0, 0, 1, 0,\n    0, 0, 0, 1, 1, 1, 0, 1, 0,\n    1, 1, 0, 1, 1, 1, 0, 1, 1,\n    1, 1, 0, 1, 0, 1, 0, 1, 1,\n    0, 1, 0, 0, 0, 0, 0, 0, 0,\n    0, 1, 1, 1, 0, 1, 1, 1, 0,\n    0, 1, 1, 1, 0, 1, 1, 1, 0,\n    0, 0, 0, 0, 0, 1, 0, 0, 0\n);\n\nvec2 randdir(vec3 seedA, vec3 seedB) {\n    return normalize(vec2(\n        1.0 - 2.0 * random(seedA),\n        1.0 - 2.0 * random(seedB)\n    ));\n}\n\nint getTile(vec2 tile) {\n    ivec2 p = ivec2(floor(tile));\n    p = min(max(ivec2(0), p), ivec2(MAP_WIDTH - 1, MAP_HEIGHT - 1));\n    p.y = MAP_HEIGHT - 1 - p.y;\n    \n    return map[p.x + p.y * MAP_WIDTH];\n}\n\n// [xOffset, yOffset, tileSize]\nvec3 getTileTransform(vec2 iResolution) {\n    float tileSize;\n    float x,y;\n    \n    if(iResolution.x > iResolution.y) {\n        tileSize = iResolution.y / float(MAP_HEIGHT);\n    } else {\n        tileSize = iResolution.x / float(MAP_WIDTH);\n    }\n    \n    x = (float(MAP_WIDTH)  - iResolution.x / tileSize) / 2.0;\n    y = (float(MAP_HEIGHT) - iResolution.y / tileSize) / 2.0;\n    \n    return vec3(x, y, tileSize);\n}\n\nvec4 saturate(vec4 a) {\n    return min(max(vec4(0), a), vec4(1));\n}\n\n// Take some time so textures can load\n#define START_FRAME 4",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Cliff layer\n\n#define BLUR_SAMPLES 512\n#define BLUR_RADIUS 0.4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel1, uv);\n    \n    if(iFrame == START_FRAME \n       || getValue(iChannel3, 1).xyz != iResolution\n       || key_pressed(iChannel2, KEY_W) || key_pressed(iChannel2, KEY_Q)) {\n        vec3 tileTransform = getTileTransform(iResolution.xy);\n        float tileSize = tileTransform.z;\n        \n        vec2 tile = fragCoord / tileSize + tileTransform.xy;\n        int tileValue = getTile(tile);\n\n        float hits = 0.0;\n\n        for(int i = 0; i < BLUR_SAMPLES; i++) {\n            vec2 offset = randdir(vec3(uv, i), vec3(uv, i * 8));\n            offset *= random(vec3(uv, i * 9 + 17));\n            offset *= BLUR_RADIUS;\n\n            if(getTile(tile + offset) == 1) {\n                hits += 1.0;\n            }\n        }\n\n        hits /= float(BLUR_SAMPLES);\n\n        float value = texture(iChannel0, fragCoord / tileSize).r;\n    \tvec3 color = mix(vec3(0.2), vec3(0.8), sqrt(value));\n        fragColor = vec4(color, hits);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Shadow mask\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel1, uv);\n    \n    if(iFrame == START_FRAME \n       || getValue(iChannel2, 1).xyz != iResolution\n       || key_pressed(iChannel2, KEY_E) || key_pressed(iChannel0, KEY_Q)) {\n        vec3 tileTransform = getTileTransform(iResolution.xy);\n        float tileSize = tileTransform.z;\n\n        vec2 tile = fragCoord / tileSize + tileTransform.xy;\n        int tileValue = getTile(tile);\n        int lowerTile = getTile(tile - vec2(0, 1));\n        \n        float cliffAlpha = texture(iChannel3, uv).a;\n        \n        if(tileValue != 1) {\n            fragColor = vec4(1);\n        } else if(lowerTile == 1) {\n            fragColor = vec4(1.0 - cliffAlpha);\n        } else {\n            fragColor = vec4(2.0 - cliffAlpha - fract(tile.y));\n        }\n        \n        fragColor = saturate(fragColor);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Tilemap composite render\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 grassUv = fragCoord / getTileTransform(iResolution.xy).z;\n    \n    vec4 cliff = texture(iChannel0, uv);\n    vec4 grass = texture(iChannel1, grassUv);\n    grass = mix(vec4(115, 191, 0, 255), vec4(27, 99, 27, 255), grass.r) / 255.0;\n    \n    fragColor = mix(grass, cliff, cliff.a);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}