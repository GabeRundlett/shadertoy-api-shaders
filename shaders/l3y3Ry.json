{
    "Shader": {
        "info": {
            "date": "1717791160",
            "description": "These are my very slow and unoptimized clouds, if you have any feedback on how to improve this I'd love to hear it",
            "flags": 32,
            "hasliked": 0,
            "id": "l3y3Ry",
            "likes": 27,
            "name": "My simple clouds (unoptimized)",
            "published": 3,
            "tags": [
                "raymarching",
                "simple",
                "clouds",
                "shader",
                "realistic"
            ],
            "usePreview": 0,
            "username": "MinimilisticBits",
            "viewed": 1171
        },
        "renderpass": [
            {
                "code": "//from https://www.shadertoy.com/view/X3GGRz \nvec3 tonemap(vec3 sRGB)\n{\n    // NOTE: Tune these params based on your use case.\n    // Desmos graph: https://www.desmos.com/calculator/cvt2brlyl3\n    const float EXPOSUREX = 1.4;\n    const float CONTRAST = 1.5;\n    const float RANGE = 1.5;\n    \n    const mat3 sRGB_to_LMS = transpose(mat3(\n        0.31399022, 0.63951294, 0.04649755,\n        0.15537241, 0.75789446, 0.08670142,\n        0.01775239, 0.10944209, 0.87256922));\n\n    const mat3 LMS_to_sRGB = transpose(mat3(\n        5.47221206, -4.6419601 ,  0.16963708,\n       -1.1252419 ,  2.29317094, -0.1678952 ,\n        0.02980165, -0.19318073,  1.16364789));\n        \n    const vec3 sRGB_to_Y = vec3(0.2126729, 0.7151522, 0.0721750);\n    \n    // Apply tonescale in LMS\n    \n    vec3 LMS = sRGB_to_LMS * sRGB;\n    \n    LMS = pow(EXPOSUREX * LMS, vec3(CONTRAST / RANGE));\n    LMS = LMS / (LMS + 1.0);\n    LMS = pow(LMS, vec3(RANGE));\n    \n    sRGB = LMS_to_sRGB * LMS;\n    \n    // Apply gamut mapping in sRGB\n    \n    float Y = dot(sRGB_to_Y, sRGB);\n    if (Y > 1.0)\n        return vec3(1.0);\n        \n    float minimum = min(sRGB.r, min(sRGB.g, sRGB.b));\n    if (minimum < 0.0)\n        sRGB = mix(sRGB, vec3(Y), -minimum / (Y - minimum));\n    \n    float maximum = max(sRGB.r, max(sRGB.g, sRGB.b));\n    if (maximum > 1.0)\n        sRGB = mix(sRGB, vec3(Y), (1.0 - maximum) / (Y - maximum));\n    \n    return sRGB;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    for(int i = 0; i < 9; i++){\n        vec2 coords = vec2(float(i%3)-1., float(i/3)-1.)*1.;\n        vec2 fin = (fragCoord+coords)/iResolution.xy;\n        col += texture(iChannel0, fin).xyz;\n    }\n    col /= 9.;\n    \n\n    // Output to screen*/\n    col = pow(col, vec3(1.));\n    col = tonemap(col);\n   col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float pi = 3.14159;\nvec2 rot(vec2 a, float c){\nfloat g = c*pi/180.;\nfloat l = length(a);\na = normalize(a);\nfloat ang = atan(a.y,a.x)+g; \nreturn vec2(l*cos(ang),l*sin(ang));\n}\n    vec3 lig = normalize(vec3(0., 0.9, 0.9));\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n\n\n\nfloat RayleighPhase(float cost){\nreturn (3./(16.*3.14159))*(1.0+cost*cost);\n}\n\nfloat p22(float h){\nreturn exp(-h/8500.);\n}\n\nvec3 S(vec3 wave, float cost, float h){\nfloat n = 1.00029;\nfloat N = 2.504;\nfloat a = 3.14159*3.14159*(n*n-1.0)*(n*n-1.0)/2.0;\nfloat b = p22(h)/N;\nvec3 c = 1.0/(wave*wave*wave*wave);\nfloat d = (1.0-cost*cost);\nreturn a*b*c*d;\n}\n\nvec3 B(vec3 wave, float h){\nfloat n = 1.00029;\nfloat N = 2.504;\n\nfloat a = 8.*pow(3.14159,3.)*(n*n-1.0)*(n*n-1.0)/3.;\nfloat b = p22(h)/N;\nvec3 c = 1./wave;\nreturn a*b*c;\n}\n\nvec3 reyleighapprox(vec3 wave, float cost, float h){\nfloat n = 1.00029;\nfloat d = 1432.1;\nfloat a = (1.0+cost*cost)/(2.0*h*h);\nvec3 b = pow(2.*3.14159/wave,vec3(4.));\nfloat c = pow((n*n-1.0)/(n*n+2.),2.);\nfloat d2 = pow(d/2.,6.);\nreturn a*b*c*d2;\n}\n\nfloat CornetteShanksPhase(float costheta, float g){\nfloat a = 3./(8.*3.14159);\nfloat b = (1.0-g*g)*(1.0+costheta*costheta);\nfloat c = (2.0+g*g)*pow(1.0+g*g-2.*g*costheta, 3./2.);\nreturn a*(b/c);\n}\n\nfloat dr(float h){\nreturn exp(h/1200.);\n}\n\nfloat dr2(float h){\nreturn exp(h/8000.);\n}\n\nvec3 boreyleigh(float costheta, vec3 wave){\nfloat n = 1.00029;\nfloat N = 1.504;\nfloat a = 1.0+costheta*costheta;\nfloat v = 3.14159*3.14159*pow(n*n-1., 2.);\nreturn (v/(3.*N*wave*wave*wave*wave*0.000000000002))*a;\n}\n\nvec3 boreyleighconstant(vec3 wave){\nfloat n = 1.00029;\nfloat N = 1.504;\nfloat v = 8.*pow(3.14159, 3.)*pow(n*n-1., 2.);\nreturn (v/(3.*N*wave*wave*wave*wave));\n}\n\nvec3 bommie(float costheta, vec3 wave){\nfloat T = 5.;\nfloat C = (0.6544*T-0.6510);\nvec3 Bm = 0.434*C*3.14159*((4.*3.14159*3.14159)/(wave*wave))*0.67;\nreturn 0.434*C*((4.*3.14159*3.14159)/(wave*wave))*0.5*Bm;\n}\nvec3 bommieconstant(vec3 wave){\nfloat T = 5.;\nfloat C = (0.6544*T-0.6510);\nvec3 Bm = 0.434*C*3.14159*((4.*3.14159*3.14159)/(wave*wave))*0.67;\nreturn Bm;\n}\n\nfloat HenyeyG(float cost, float g){\nreturn (1.0-g*g)/(4.*3.14159*pow(1.0+g*g-2.*cost,3./2.));\n}\n\nfloat ph(float h, float H){\nreturn exp(-(abs(h)/H));\n}\n\nvec3 S(vec3 wave, float h, float H, float cost){\nfloat n = 1.00029;\nfloat N = 2.504*pow(10., 2.);\nfloat a = pow(3.14159,2.)*pow(n*n-1.,2.)/2.;\nfloat b = ph(h, H)/N;\nvec3 c = 1./pow(wave, vec3(4.));\nfloat d = (1.0+cost*cost);\nreturn a*b*c*d;\n}\n//S = B*Y\n\nvec3 B(vec3 wave, float h, float H){\nfloat n = 1.00029;\nfloat N = 2.504*pow(10., 2.);\nfloat a = 8.*pow(3.14159,3.)*pow(n*n-1.,2.)/3.;\nfloat b = ph(h, H)/N;\nvec3 c = 1./pow(wave, vec3(4.));\nreturn a*b*c;\n}\n\nvec3 Bconstant(vec3 wave){\nfloat n = 1.00029;\nfloat N = 2.504*pow(10., 25.);\nfloat a = 8.*pow(3.14159,3.)*pow(n*n-1.,2.)/3.;\nfloat b = 1./N;\nvec3 c = 1./pow(wave, vec3(4.));\nreturn a*b*c;\n}\n\nvec3 BsR(vec3 wave, float h, float H){\nfloat n = 1.00029;\nvec3 N = vec3(2.504)*pow(10., 25.);\nvec3 a = (8.*pow(3.14159,3.)*pow(n*n-1.,2.))/(3.*N*pow(wave,vec3(4.)));\nfloat b = exp(-(h/H));\nreturn a*b;\n}\n\nfloat PM(float cost, float g){\nfloat a = 3./(8.*3.14159);\nfloat b = (1.0-g*g)*(1.0+cost*cost);\nfloat c = (2.0+g*g)*pow(1.0+g*g-2.*g*cost, 3./2.);\nreturn a*(b/c);\n}\n\nfloat PR(float cost){\nreturn (3./(16.*3.14159))*(1.0+cost*cost);\n}\n\nfloat Y(float cost){\nfloat a = 3./(16.*3.14159);\nfloat b = 1.0+cost*cost;\nreturn a*b;\n}\n\nvec3 F(vec3 wave,vec3 wave2, vec3 wave3, vec3 wave4, float s, float cost){\nvec3 br = boreyleighconstant(wave);\nvec3 bm = bommieconstant(wave2);\n\nfloat pr = ph(s, 8500.);\nfloat pm = ph(s, 1200.);\n\nvec3 Br = boreyleigh(cost, wave3);\nvec3 Bm = bommie(cost, wave4);\n\nreturn pr*Br*br*200. + pm*Bm*bm;\n}\n//NOT MY CODE///////////\n bool intersect22(vec3 p,  vec3 C, float size, vec3 d, inout vec2 t){\n \n \t\n\tvec3 o_minus_c = p - C.xyz;\n\n    float p2 = dot(d, o_minus_c);\n    float q = dot(o_minus_c, o_minus_c) - (size * size);\n    \n    float discriminant = (p2 * p2) - q;\n    \n\n    float dRoot = sqrt(discriminant);\n    t.x = -p2 - dRoot;\n    t.y = -p2 + dRoot;\n\n    return true;\n \n }\n vec3 Be(vec3 b0,float h, float H){\nreturn b0*exp(-h/H);\n}\nvec3 Brr(vec3 wave){\nfloat n = 1.029;\nfloat N = 10.;\nreturn 8.*pow(3.14159,3.)*(pow(n*n-1.0, 2.)/(3.*N*wave*wave*wave*wave));\n}\nvec3 sky2x(vec3 p, vec3 d, vec3 lig) {\n  p = vec3(0., 0., 6400.);\n  vec3 wavelengths = vec3(700., 530., 420.);\n  //lig.z = clamp(lig.z, 0., 1.);\n\n  vec2 t = vec2(0.);\n  float reyleighH = 4000.;\n  float MieH = 1200.;\n\n  vec3 accumulateLight = vec3(0.);\n  vec3 accumulateLightMie = vec3(0.);\n  if (intersect22(p, vec3(0., 0., 0.), 6420.0, d, t)) {\n    // col = vec3(t.x);\n    vec3 m = p;\n\n    vec3 cam = p;\n    vec3 fin = p + d * t.y;\n    vec3 div = vec3(fin - cam) / 20.;\n    float mm = length(cam - fin);\n\n    vec3 accum = vec3(0.);\n    vec3 accum11 = vec3(0.);\n    vec3 accum1111 = vec3(0.);\n\n    ///////////////////////////////////\n    float PMMM = PM(max(dot(d, lig), 0.), 0.76);\n    float PRRR = RayleighPhase(max(dot(d, lig), 0.0));\n    vec3 coefficients = vec3(33.1, 13.5, 5.8);\n    float Bs = 110.;\n    vec3 Be0 = Be(coefficients, 0.0, 2000.);\n    // vec3 BRrgb = vec3(6.5, 1.73, 2.30);\n    vec3 BRrgb = Brr(wavelengths * 0.00109);\n    vec3 BMrgb = vec3(0.01);\n    ///////////////////////////////////\n\n    for (int i = 0; i < 20; i++) {\n      accum += ph(max(cam.z - 1660., 0.), reyleighH) * length(div);\n      // accum11 += Bwave(wavelengths*0.01, cam.z, MieH)*length(div);;\n      accum1111 += ph(max(cam.z - 1460., 0.), MieH) * length(div);\n      vec3 accum2 = vec3(0.);\n      vec3 accum222 = vec3(0.);\n      float accum3 = 0.;\n      // energy = energy*(1.0-rayleighcoefficients);\n      if (intersect22(cam, vec3(0., 0., 0.), 6420.0, lig, t)) {\n        vec3 cam2 = cam;\n        vec3 fin2 = cam2 + lig * t.y;\n        vec3 div2 = vec3(fin2 - cam2) / 20.;\n        for (int k = 0; k < 20; k++) {\n          accum2 += max(length(cam2) - 6260., 0.) * length(div2);\n         \n          cam2 += div2;\n        }\n\n        vec3 t1 = BRrgb * accum222 + BMrgb * accum2;\n        vec3 t2 = BRrgb * accum + BMrgb * accum1111;\n\n        accumulateLight +=\n            (exp(-pow(t1 * 0.0054, vec3(1.))) * exp(-t2 * 0.028)) *\n            length(div * 1.) * .0005 * (PRRR * BRrgb * 230. + PMMM * 10.);\n            //*\n            //mix(vec3(0.9, 0.4, 0.9), vec3(0.9),\n             //   clamp(dot(lig, vec3(0., 0., 1.)) * 4., 0., 1.));\n\n      }\n\n     // if (cam.z < 6360.) {\n       // break;\n      //}\n      cam += div;\n    }\n    \n  }\n  \n  return max(accumulateLight * 1.4,\n             0.);\n \n}\n\n\n\nvec3 skysdf(vec3 p, vec3 d, vec3 lig) {\n  float hhh = 7500.;\n  p = vec3(0., 0., hhh);\n  float sphrad = 8000.;\n  \n    vec2 t = vec2(0.);\n\n  intersect22(p, vec3(0., 0., 0.), sphrad, d, t);\n  vec3 fin = p + d * t.y;\n  float dist = length(fin-p)/30.;\n  \n  vec3 wavelengths = vec3(700., 520., 420.);\n  //lig.z = clamp(lig.z, 0., 1.);\n\n  float reyleighH = 1200.;\n  float MieH = 500.;\n\n  vec3 accumulateLight = vec3(0.);\n  vec3 accumulateLightMie = vec3(0.);\n    // col = vec3(t.x);\n    vec3 m = p;\n\n    vec3 cam = p;\n   \n\n    vec3 accum = vec3(0.);\n    vec3 accum11 = vec3(0.);\n    vec3 accum1111 = vec3(0.);\n\n    ///////////////////////////////////\n    float PMMM = PM(max(dot(d, lig), 0.), 0.76);\n    float PRRR = RayleighPhase(max(dot(d, lig), 0.0));\n    vec3 coefficients = vec3(33.1, 13.5, 5.8);\n    float Bs = 10.;\n    vec3 Be0 = Be(coefficients, 0.0, 2000.);\n    // vec3 BRrgb = vec3(6.5, 1.73, 2.30);\n    vec3 BRrgb = Brr(wavelengths * 0.00059);\n    vec3 BMrgb = vec3(0.01);\n    ///////////////////////////////////\n\n    for (int i = 0; i < 30; i++) {\n    //float dist = abs((length(vec3(0., 0., hhh)-cam)-sphrad))+0.001;\n    \n      //accum += ph(max(cam.z - hhh, 0.), sphrad) * dist;\n      accum += exp(-((cam.z-hhh) / reyleighH)*.01)*dist ;\n\n      // accum11 += Bwave(wavelengths*0.01, cam.z, MieH)*length(div);;\n      //accum1111 += ph(max(cam.z - hhh, 0.), MieH) * dist;\n      \n       accum1111 += exp(-((cam.z-hhh) / (MieH))*.01) *dist;\n\n      \n      vec3 accum2 = vec3(0.);\n      vec3 accum222 = vec3(0.);\n      float accum3 = 0.;\n      // energy = energy*(1.0-rayleighcoefficients);\n        vec3 cam2 = cam;\n        \n        vec2 t22 = vec2(0.);\n\n          intersect22(cam, vec3(0., 0., 0.), sphrad, d, t22);\n          vec3 fin2 = cam + lig * t22.y;\n          float dist2 = length(fin2-cam)/30.;\n        for (int k = 0; k < 30; k++) {\n            //float dist2 = abs((length(vec3(0., 0., hhh)-cam2)-sphrad))+0.001;\n           \n          accum2 += exp(-((cam2.z-hhh) / reyleighH)*.1)*dist2 ;\n           //accum222 += exp(-((cam2.z-hhh) / (MieH))*.01)*dist2 ;\n          cam2 += lig*dist2;\n        \n}\n        vec3 t1 = BRrgb * accum222 + BMrgb * accum2;\n        vec3 t2 = BRrgb * accum + BMrgb * accum1111;\n\n        accumulateLight +=  (exp(-pow(t1 * 0.004, vec3(1.))) * exp(-t2 * 0.0018)) *\n             .0005 * (PRRR * BRrgb * 130. + PMMM * 10.);\n            //*\n            //mix(vec3(0.9, 0.4, 0.9), vec3(0.9),\n             //   clamp(dot(lig, vec3(0., 0., 1.)) * 4., 0., 1.));\n        \n      \n\n      if (cam.z < 6360.) {\n        //break;\n      }\n      cam += d*dist;\n    \n    \n  }\n  \n  return max(accumulateLight * 1.4,\n             0.);\n \n}\n\nvec3 sky(vec3 p, vec3 d, vec3 lig) {\n  float hhh = 6400.;\n  float hhh2 = 1220.;\n\n  p = vec3(0., 0., hhh);\n  float sphrad = 6420.;\n  \n    vec2 t = vec2(0.);\n\n  intersect22(p, vec3(0., 0., 0.), sphrad, d, t);\n  vec3 fin = p + d * t.y;\n  float dist = length(fin-p)/30.;\n  \n  vec3 wavelengths = vec3(700., 520., 420.);\n  //lig.z = clamp(lig.z, 0., 1.);\n\n  float reyleighH = 6420.;\n  float MieH = 6420.;\n\n  vec3 accumulateLight = vec3(0.);\n  vec3 accumulateLightMie = vec3(0.);\n    // col = vec3(t.x);\n    vec3 m = p;\n\n    vec3 cam = p;\n   \n\n    vec3 accum = vec3(0.);\n    vec3 accum2 = vec3(0.);\n\n    ///////////////////////////////////\n    float PMMM = PM(max(dot(d, lig), 0.), 0.76);\n    float PRRR = RayleighPhase(max(dot(d, lig), 0.0));\n    vec3 coefficients = vec3(33.1, 13.5, 5.8);\n    float Bs = 10.;\n    vec3 Be0 = Be(coefficients, 0.0, 2000.);\n    // vec3 BRrgb = vec3(6.5, 1.73, 2.30);\n    vec3 BRrgb = Brr(wavelengths * 0.00039);\n    //vec3 BRrgb = boreyleigh(max(dot(d, lig), 0.0), wavelengths*0.00000000001);\n    vec3 BMrgb = vec3(0.001);\n    ///////////////////////////////////\n    vec3 pms = BMrgb*2000.;\n    for (int i = 0; i < 30; i++) {\n        vec3 rayl = PRRR*BRrgb*BsR(wavelengths*0.0000000001, cam.z, reyleighH);\n        rayl = PRRR*BRrgb;\n        float ph1 = exp(-(abs(cam.z-hhh2)/reyleighH))*length(fin-p);\n        float ph0 = exp(-(abs(cam.z-hhh2)/MieH))*length(fin-p);\n\n        accum += ph1;\n        accum2 += ph0;\n        vec3 cam2 = cam;\n        \n        vec2 t22 = vec2(0.);\n\n          intersect22(cam, vec3(0., 0., 0.), sphrad, lig, t22);\n          vec3 fin2 = cam + lig * t22.y;\n          float dist2 = length(fin2-cam)/30.;\n          vec3 accum22 = vec3(0.);\n          vec3 accum11 = vec3(0.);\n        for (int k = 0; k < 30; k++) {\n            float ph2 = exp(-(abs(cam2.z-cam.z-hhh2)/MieH))*length(fin2-cam);\n            float ph3 = exp(-(abs(cam2.z-cam.z-hhh2)/reyleighH))*length(fin2-cam);\n\n           accum22 += ph2;\n           accum11 += ph3;\n          cam2 += lig*dist2;\n       \n        }\n        \n        //rayl*ph1 + PMMM*BMrgb*ph0\n        //rayl*ph3+PMMM*BMrgb*ph2;\n        vec3 v1 = rayl*accum + pms*accum2;\n        vec3 v2 = rayl*accum11+pms*accum22;\n        \n        accumulateLight += 0.00001\n      *dist*((exp(-(v1)*.00009)) * ((exp(-((v2))*.000191))))*\n      (rayl*240. + PMMM*pms*520.);\n//accumulateLight += 1.-exp(-((accum2)*dist2)*0.001);\n      \n      if (cam.z < 6360.) {\n        break;\n      }\n      cam += d*dist;\n    \n    \n  }\n // return (exp(-(accum)*dist*0.1));\n //return accum*0.1;\n  return max(accumulateLight * 1.4,\n             0.);\n \n}\n\n\nfloat remap(float v, float l0, float h0, float ln, float hn){\nreturn ln + ((v-l0)*(hn-ln))/(h0-l0);\n}\nvec3 remap(vec3 v, vec3 l0, vec3 h0, vec3 ln, vec3 hn){\nreturn ln + ((v-l0)*(hn-ln))/(h0-l0);\n}\nfloat random3d(vec3 p){\nreturn fract(sin(p.x*214. + p.y*241. + p.z*123.)*100. + cos(p.x*42. + p.y*41.2+p.z*32.)*10.);\n}\n\nfloat worley3d(vec3 p){\nvec3 f = floor(p);\n\nfloat ll = 999.;\nfor(int i = 0; i < 27; i++){\nvec3 coords = vec3(float(i%3)-1., mod(float(i/3)-1., 3.), float(i/9)-1.);\nvec3 col = f+coords;\nvec3 curr = vec3(random3d(col), random3d(col+2.), random3d(col+4.))-0.5;\nfloat len = length((col+curr)-p);\nll = min(ll, len);\n}\nreturn ll;\n\n}\n\nfloat hash(vec3 p3)\n{\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat noise222( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat fbmss(vec3 p)\n{\n    float scale = 0.1;\n    float threshold = 0.3;\n    float sum = 0.;\n        p += vec3(5., 0., 0.);\n        for(int i = 1; i <= 8; i++)\n        {\n            sum += noise222((p+vec3(iTime, iTime,iTime)*0.5) * scale * pow(2., float(i))) / pow(1.7, float(i));\n        }\n        return max(sum - threshold, 0.);\n}\nfloat fbm(vec3 p, vec3 cam){\n\n\nfloat b = fbmss(p*0.065);\n\n  float Srb = clamp(\n      remap(clamp((cam.z - 200.) / 15., 0., 0.09), 0., 0.09, 0., 1.), 0., 1.);//a *= clamp(abs(length(p)-6500.)*0.00013, 0.0, 1.);\n\nreturn clamp(b,0.,1.);\n}\n\n\n\nfloat noise(vec3 p){\nreturn fract(sin(p.x * 23. + p.y * 241.4 + p.z*52.)*100. + cos(p.x * 234. + p.y * 21.4 + p.z*542.)*124.);\n}\n\nfloat box(vec3 p, vec3 s){\n    vec3 a = abs(p)-s;\n    return max(a.x, max(a.y,a.z));\n}\n\nvec4 clouds2(vec3 p, vec3 d, vec3 lig, inout float dist) {\n  vec3 befo = p;\n \n  float transmission = 1.0;\n  vec3 Ex = vec3(1.0);\n    vec3 ccc = p;\n\n  /*for(int i = 0; i < 40; i++){\n      float dist = box(vec3(0., 0., 220.)-p, vec3(15000., 15000., 1.));\n      if(dist < 0.01){\n          break;\n      }\n   //   p+=dist*d;\n  }*/\n \n  vec3 accumulateLight = vec3(0.);\n\n  vec3 cam = p;\n\n  vec3 accum = vec3(0.);\n  float minus = 0.30;\n  float mult = 1.0;\n\n \n  vec3 sky2 = sky(vec3(0.), lig, lig);\n  float pr2 = PR(max(dot(d, lig), 0.));\n  float keepdensity = 0.;\n  bool firsth = false;\n  vec3 firstHit = p;\n  float stepsize = 8.;\n  for (int i = 0; i < 70; i++) {\n    float density =\n        max(fbm(cam * mult, cam) - minus - abs(cam.z - 220.) * 0.0035, 0.);\n    density = clamp(density, 0., 1.);\n    density = 1.0 - pow(1.0 - density, 4.);\n    if (density > 0.00001) {\n      if (!firsth) {\n        dist = length(cam - ccc);\n        firsth = true;\n        firstHit = cam;\n        stepsize = 5.;\n      }\n      accum += density * 10.6;\n      // accum11 += ph(length(cam)-6500., MieH)*length(div);\n\n      vec3 accum2 = vec3(0.);\n      // float accum3 = 0.;\n      // energy = energy*(1.0-rayleighcoefficients);\n      vec3 cam2 = cam;\n        float transmission2 = 1.;\n      for (int k = 0; k < 43; k++) {\n        float density2 = max(\n            fbm(cam2 * mult, cam2) - minus - abs(cam2.z - 220.) * 0.0035, 0.);\n        // density2 = smoothstep(0.,1.,density2);\n        density2 = clamp(density2, 0., 1.);\n        density2 = 1.0 - pow(1.0 - density2, 4.);\n\n        // accum2 += ph(cam2.z, 1300.)*30.;\n        accum2 += density2 * 20.1;\n        transmission2 *= 1.-density2;\n        // accum3 += ph(length(cam2)-6500., MieH)*length(div2);\n        cam2 += lig * (1. - 0.2 * random3d(cam2) + float(k)*0.0);\n      }\n\n      transmission *= 1.0 - density;\n\n    \n      float octave = 0.;\n\n      for (int i = 0; i < 8; i++) {\n   \n        vec3 pm2 = vec3((PM(max(dot(d, lig), 0.), 0.76))) * 114. +\n                   vec3((PM(max(dot(d, lig), 0.), pow(0.5, octave)))) * 11.5 +\n                   vec3((PM(max(dot(d, lig), 0.), -0.5))) * 41.;\n       //  pm2 *= mix(vec3(0.9,0.6,0.2), vec3(0.9), max(dot(lig, vec3(0.,\n       //  0., 1.)), 0.));\n           vec3 colr = max(sky2,0.);\n           vec3 colr2 = max(5.-sky2, 0.);\n        accumulateLight +=\n            (1. - exp(-density *colr * 3.6)) * density * transmission *\n            (pm2*12. + pr2 * 12.) * pow(0.5, octave) * 3.  *\n            (exp(-accum2 * colr2 * 0.05 * pow(.5, octave)) * exp(-accum * colr2 * 0.1));\n\n        octave += 1.;\n      }\n\n    } \n\n    cam += d * (stepsize - 0.5 * random3d(cam));\n      if(transmission < 0.5){\n          break;\n      }\n  }\n \n  return vec4(accumulateLight * 1.3, transmission);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord)/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    \n    int tiles = 4;\n    int samples = 20;\n    //jk = float(iFrame%samples);\n\n    vec2 res = iResolution.xy / float(tiles);\n    int times = (iFrame/samples);\n    vec2 time = vec2(float(times%tiles), float((times/tiles)%(tiles)));\n    vec2 rr = res*time;\n    bool wtf = false;\n    //if(check == 1.){\n   //if(fragCoord.x < (rr.x) || fragCoord.x > (rr.x+res.x))discard;\n   //if(fragCoord.y < (rr.y) || fragCoord.y > (rr.y+res.y))discard;\n    \n    uv.x *= 1.3;\n    uv.y /= 1.3;\n    \n    vec3 d = normalize(vec3(uv.x, 1., uv.y));\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    d.yz = rot(d.yz, mouse.y*90.);\n    d.xy = rot(d.xy, -mouse.x*180.);\n\n  \n    vec3 skys = sky(vec3(0.), d, lig);\n    vec3 final = skys;\n    \n    float dist = 0.;\n    vec4 mmm = clouds2(vec3(0.,0.,290.),d,lig,dist);\n   // vec4 mmm = vec4(0.,0.,0.,1.);\n    //vec3 final = skys;\n    final = final*mmm.w + pow(mmm.xyz*max(lig.z,0.01), vec3(1.));\n    float f = exp(-dist * .001);\n    final.xyz = final.xyz * f + skys.xyz * (1.0 - f);\n    \n    // Output to screen\n    fragColor = vec4(final,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}