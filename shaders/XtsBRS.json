{
    "Shader": {
        "info": {
            "date": "1512387012",
            "description": "A Mobius spiral with a pseudo random weave - Inspired by Fabrice's cool \"Round Weave\" example.",
            "flags": 0,
            "hasliked": 0,
            "id": "XtsBRS",
            "likes": 52,
            "name": "Mobius Weave",
            "published": 3,
            "tags": [
                "spiral",
                "mobius",
                "complex",
                "weave"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 4279
        },
        "renderpass": [
            {
                "code": "/*\n\n\tMobius Weave\n\t------------\n\n\tA Mobius spiral with a pseudo random weave. The idea came from Fabrice's cool \"Round Weaving\" \n\texample. Fabrice always comes up with clever little shaders, and I have a habit of viewing\n\tthem, then going off on a tangent for a few hours. :) \n\n\tHis \"Round Weaving\" shader essentially involves applying something along the lines of a polar \n\ttransform to a standard cross-weave pattern. Although visually different, this is just an extension \n\tof that with some window dressing applied. Instead of the standard over under weave, I've psuedo-\n\trandomized it, and have substituted the polar transform for a reasonably well known Mobius spiral \n\ttransform, which is polar in nature, but a little bit fancier.\n\n\tInspired by:\n\n    // Slightly different, but basically a polar transformed cross weave. As with a lot of Fabrice's\n\t// shaders, it's very concisely written - Roughly a couple of tweets.\n\tround weaving - FabriceNeyret2\n\thttps://www.shadertoy.com/view/MtffzB\n\n\tOther related examples:\n\n    // Very cool, much more complex (no pun intended) example. Mobius spirals are pretty easy;\n\t// Packing circles into them is less so. :)\n\tDoyle spirals - knighty\n\thttps://www.shadertoy.com/view/4tffDH\n\n\t// A simplified circle packed spiral.\n\tDoyle spiral - ws\n\thttps://www.shadertoy.com/view/MtffDn\n\n\t// Just the basics - for anyone who wants to make a Mobius spiral, or whatever they're\n\t// technically called.\n\tLogarithmic Mobius Transform - Shane\n\thttps://www.shadertoy.com/view/4dcSWs\n\n*/\n\n\n// Standard 2D rotation formula - See Nimitz's comment.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n\n// Standard Mobius transform: f(z) = (az + b)/(cz + d). Slightly obfuscated.\nvec2 Mobius(vec2 p, vec2 z1, vec2 z2){\n\n\tz1 = p - z1; p -= z2;\n\t//return vec2(dot(z1, p), z1.y*p.x - z1.x*p.y)/dot(p, p);\n    // Equivalent to the line above. Fabrice tidied it up. I'd imagine the grouped\n    // operations might make it a little quicker, but don't quote me on that. :)\n    return mat2(z1, z1.y, -z1.x)*p/dot(p, p); \n}\n\n\n// Standard spiral zoom.\nvec2 spiralZoom(vec2 p, vec2 offs, float n, float spiral, float zoom, vec2 phase){\n\t\n\tp -= offs;\n\tfloat a = atan(p.y, p.x)/6.283 + iTime/32.;\n\tfloat d = length(p);\n\t//return vec2(a*n + log(d)*spiral, -log(d)*zoom + a) + phase;\n    // Equivalent to the line above. Fabrice tidied this one up too. :)\n    return mat2(n, 2, spiral,-zoom)*vec2(a, log(d)) + phase;\n\n}\n\n// This is a rewrite of IQ's original. It's self contained, which makes it much\n// easier to copy and paste. I've also tried my best to minimize the amount of \n// operations to lessen the work the GPU has to do, but I think there's room for\n// improvement.\n//\nfloat noise3D(vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(7, 157, 113);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Rotation and scaling.\n    uv = r2(3.14159/6.*sin(iTime/3.))*uv*1.2;    \n    \n     \n/*  \n\t// Polar transformation. Not as fancy looking, but there for comparison.\n    uv = r2(iTime/4.)*uv;\n    uv = r2(atan(uv.y, uv.x)*1.)*uv*2.;\n    float r = length(uv)*.35;\n    vec2 p = uv*16.;\n*/ \n    \n/*   \n\t// Standard patterned weave. Comparitively speaking, not that exciting. :)\n\t// Comment out the four lines below this block first.\n    uv += iTime/16.;\n    float r = 1.;\n    vec2 p = uv*8.;\n*/\n    \n    // Shading over the two singularity points. It serves two purposes: One, to give depth,\n    // but also to alleviate Moire patterns that tend to build up.\n    float r = min(length(uv - vec2(.5, 0)), length(uv - vec2(-.5, 0)));\n    //float r = length(uv - vec2(.5, 0))*length(uv - vec2(-.5, 0));\n    \n    \n    // Transform the screen coordinates: For anyone not familiar with the order in which\n    // you do this, transforms are performed prior to rendering the flat grid.\n    //\n    // The logarithmic Mobius spiral is one of the more interesting transformations, and \n    // just involves a little math. By the way, these transforms work independently, but tend \n    // to look better coupled together.\n    uv = Mobius(uv, vec2(-1, -.5), vec2(.5, 0));\n    // Logarithmic spiral zoom. Odd spiral numbers can sometimes put grid patterns out of\n    // sync, depending on the situation. Just something to think about if yours seams\n    // aren't matching up.\n    uv = spiralZoom(uv, vec2(-.5), 4., 3.14159*.2, .5, vec2(-1, 1)*iTime*.125);\n     \n    \n    // Scene scaling. \n    const float sc = 4.;\n    vec2 p = uv*sc;\n    \n    \n    // Overlapping cross construction. Most of it is common sense - Split space up into\n    // grid cells. In each cell, draw a horizontal line, then overlap it with a vertical \n    // line. Apply shadows, decorative design, etc.\n    \n    \n    // Cell's unique ID.\n    vec2 ip = floor(p);\n    \n    // Partition space into cells. The line below is equivalent to \"p = fract(p) - .5;.\"\n    // It saves a \"fract\" call, which doesn't matter here, but it can be helpful inside\n    // raymarching loops and so forth.\n    p -= ip + .5;\n    \n    // Due to the nature of the transform, the pattern needs to wrap about the line\n    // dividing the two singularity points, so true randomness isn't really possible.\n    // However, it's possible use a symmetrical pattern that looks random... Kind of.\n    //\n    // By the way, I hacked the following together in a hurry, so there's probably a\n    // more elegant way to write it. Although, I could probalby say that about most \n    // of my code. :)\n    if(mod(ip.x*ip.y*.5 + (ip.x + ip.y + 1.)*.75, sc/2.)>.5) p.xy = p.yx;\n\n    // It'd be nice to really randomize with the following, but artifacts are visible\n    // about the line ividing the two singularity points. Hopefully, there's a\n    // workaround, but I'm not sure what it is yet.\n    //if(fract(sin(dot(ip, vec2(1.373, 113.937)))*43758.5453)>.5) p.xy = p.yx;\n    \n\n    // Horizontal line and vertical lines. Fabrices has cleverly used sinsusoids to\n    // do it all, but I needed a little more precission to work with, so went the\n    // 2D distance field route.\n    float cx = abs(p.y) - .21;\n    float cy = abs(p.x) - .21;\n    \n    // Rendering the decorated overlapping crosses. A lot of it was made up as I went\n    // along. I could probably group a lot of it together, but relatively speaking, \n    // this all pretty easy for the GPU to handle.\n    \n    // The patterns that run over the stripes to give it that cheesy yarn-like look. :)\n    float pat = clamp(cos((uv.x - uv.y)*6.283*24.)*.35 + .65, 0., 1.)*.8 + .2;\n    vec2 uv2 = r2(-3.14159/4.)*uv;\n    float pat3 = clamp(cos((uv2.x + uv2.y)*6.283*48.)*.75 + .75, 0., 1.)*.8 + .2;\n    \n    // The longitudinal and latitudinal stripes. One for the vertical line and another\n    // for the horizontal one.\n    float stripeX = clamp(cos(p.y*6.238*6.)*.6 + .57, 0., 1.);\n    float stripeY = clamp(cos(p.x*6.238*6.)*.6 + .57, 0., 1.);\n    \n    // The background pattern - It's supposed to give the impression that there's some more\n    // tightly woven yarn behind the main geometric pattern, or something to that effect.\n    vec3 col = vec3(.25)*(1. - pat3*.9)*pat;\n\n    // Rendering the vertical line.\n    col = mix(col, vec3(0), (1. -smoothstep(0., .1, cx - .125))*.7); // Drop shadow.\n    col = mix(col, vec3(0), 1. -smoothstep(0., .025, cx - .05)); // Sharper border line.\n    // Main pattern.\n    col = mix(col, vec3(.6)*(cos(p.y*6.283) + 1.)*stripeX*pat, 1. -smoothstep(0., .025, cx)); \n    // Darkening the center, just to tone it down a little.\n    col = mix(col, vec3(0), (1. -smoothstep(0., .05, cx + .175))*.65);\n     \n    // Rendering the horizonal line, which is just a repeat of the above.\n    col = mix(col, vec3(0), (1. -smoothstep(0., .1, cy - .125))*.7);\n    col = mix(col, vec3(0), 1. -smoothstep(0., .025, cy - .05));\n    col = mix(col, vec3(.6)*(cos(p.x*6.283) + 1.)*stripeY*pat, 1. -smoothstep(0., .025, cy));\n    col = mix(col, vec3(0), (1. -smoothstep(0., .05, cy + .175))*.65);\n    \n\n    // Add a bit of noise to give the weave material more of an authentic look. 3D noise\n    // was a bit of an indulgence, and not all that necessary, but I thought I'd supply\n    // the fake depth information too.\n    col *= noise3D(vec3(uv*256., r))*.75 + .75;\n    \n    \n    // Artificial depth shading.\n    //\n    // Applying the shading to give the pattern a bit of depth, and to hide singularity\n    // artifacts.\n    vec3 fogCol = vec3(0); // Other - very dark - colors work too, but don't look convincing.\n    col = mix(col, fogCol, 1./(1. + r*.25 + r*r*8.));\n    // Extra fake fog to darken the horizon of those singularities a bit more.\n    col = mix(col, fogCol, smoothstep(0., .99, .03/r));\n    \n    \n    // Very mild sepia, almost charcoal. I did this to pay hommage to Fabrice's version. :)\n    col *= vec3(1.1, 1, .95);\n    \n    \n    // Apply a vignette.\n    uv = fragCoord/iResolution.xy; \n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y), .25)*1.15;\n \n    \n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n} ",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}