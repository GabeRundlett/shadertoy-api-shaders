{
    "Shader": {
        "info": {
            "date": "1675711892",
            "description": "Strolling through the night.",
            "flags": 0,
            "hasliked": 0,
            "id": "DtSSzW",
            "likes": 27,
            "name": "Mouse Walker",
            "published": 3,
            "tags": [
                "cartoon"
            ],
            "usePreview": 0,
            "username": "QuantumSuper",
            "viewed": 433
        },
        "renderpass": [
            {
                "code": "// Mouse Walker 0.8.230209\n// vector-based bufferless cartoon animation\n// by QuantumSuper.\n\n#define PI 3.14159265359 \n\nfloat amp;\n\nmat2 rotM(float deg){\n    deg /= 180./PI;\n    return mat2(cos(deg),-sin(deg),sin(deg),cos(deg));\n}\n\nvec2 rot(vec2 p, vec2 dP, vec3 myRot){\n    return (p-dP-myRot.xy)*rotM(myRot.z)+myRot.xy;\n}\nvec2 rot(vec2 pos, vec2 dPos, float myRot){ //overloaded, rotations around origin\n    return rot(pos, dPos, vec3(.0,.0,myRot));\n}\n\nfloat hash21(vec2 p){ //see The Art of Code on youtu.be/rvDo9LvfoVE\n    p = fract(p*vec2(13.81, 741.76));\n    p += dot(p, p+42.23);\n    return fract(p.x*p.y);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b){ //a line between a and b in domain of p\n\tvec2 ab = b-a;\n\treturn .005/length(a+(ab)*clamp(dot(p-a,ab)/dot(ab,ab),0.,1.)-p);\n}\n\nvoid elli(vec2 p, vec2 e, float fill){ //overloaded, not sure I ever need summed overlaps?\n    float d = length(p/e)-1.;\n    if (d<fwidth(d)) amp = fill*smoothstep(20.*fwidth(d),.0,d);\n}\n\nvoid horizon(vec2 p, vec2 a, vec2 b){ //horizon between a, b with a.x<b.x in domain of p\n\tvec2 ab = b-a;\n    ab = a+(ab)*clamp(dot(p-a,ab)/dot(ab,ab),0.,1.);\n    float d = length(ab-p);\n\tamp += -.5*smoothstep(2.*fwidth(d),.0,d);\n    if ((p.x>a.x) && (p.x<b.x) && (ab.y<p.y)) amp -= .3+.25*d; //sky\n    amp += step(a.y,.124)*.005/length(p-vec2(a.x+.1,1.5*a.y)); //lights\n}\n\nvoid rect(vec2 p, vec2 rect, float fill){ //smooth rectangle\n    vec2 dv = abs(p/rect)-.5; //dist per axis\n    //amp = smoothstep(1.5,-1.5,max(min(.0,min(dv.x,dv.y)),max(dv.x+dv.y,max(dv.x,dv.y)))); //full dist fun\n    //amp = smoothstep(2.5*max(rect.x/rect.y,max(sign(-dv.y),dot(vec2(1.,rect.x/rect.y),normalize(dv)))),.0,max(.0,max(dv.x+dv.y,max(dv.x,dv.y)))); //outer dist fun with smoothstep correction\n    float d = max(.0,max(dv.x+dv.y,max(dv.x,dv.y))); //outer dist fun\n    amp = mix(amp, fill, smoothstep(.025/rect.x,.0, d));\n}\n\nvoid house(vec2 pos, vec2 size, float fill){\n    rect(pos, size, fill); //building\n    float window = size.x/8.;\n    pos += size*vec2(3./8.,.5);\n    for (float n=1.;n<.5*size.y/window-1.; n++){\n        for (float m=.0;m<4.;m++){\n            if (hash21(size*vec2(m,n))<.3) rect(pos-2.*vec2(m*window,n*window), vec2(window), -fill); //windows\n        }\n    }\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float animTime = mod(2.*2.133333*iTime,2.*PI); //...buggy without mod at large iTime, ?overflow\n    float animFrame = floor(float(iFrame)/9.);\n\tvec3 col = vec3(0.5);\n\tamp = 0.;\n    \n    // Viewport\n    vec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y); // max -1..1\n    uv *=1.5;\n\n    // Background\n    for (float n=.0; n<15.; n++){ //horizon & sky\n        horizon(uv, vec2(-1.5+.2*n, .12+.03*hash21(vec2(animFrame)+n)), vec2(-1.5+.2*(n+1.), .12+.03*hash21(vec2(animFrame)+n+1.)));\n    }\n    \n    animFrame *= .2;\n    //float flashx = 3.*hash21(vec2(floor(animFrame)*100.,floor(animFrame)))-1.5;\n    float flashx = 3.*hash21(vec2(floor(animFrame)))-1.5;\n    if (hash21(vec2(flashx,flashx*flashx))<.08){ //lightning\n        for (float n=.0; n<6.; n++){\n            amp += sin(fract(animFrame)*PI)*line(uv, vec2(flashx+.1*sin((100.*flashx+PI)*n),.7-.1*n), vec2(flashx+.1*sin((100.*flashx+PI)*(n+1.)),.6-.1*n));\n        }  \n    } \n    \n    animFrame *= .25;\n    house(uv-vec2(2.-4.*fract(animFrame),.2),vec2(.4+.1*sin(floor(animFrame)),.5+.3*sin(floor(animFrame))),-.2);\n    animFrame *= 1.4;\n    house(uv-vec2(2.-4.*fract(animFrame),.1),vec2(.5+.2*sin(floor(animFrame)),.8+.3*sin(floor(animFrame))),-.1);\n    \n    animFrame *= 1.6;\n    elli(uv-vec2(2.-4.*fract(animFrame),-.65+.15*sin(floor(animFrame))), vec2(.8+.3*sin(floor(animFrame)),.02), -.05);\n    \n    \n    // Figurine animation definition (delta position.xy, delta angle)\n    vec2 friction = 1.+.4*vec2(sin(animTime),sin(animTime-.9*PI)); //thanks @observer for the idea\n    vec3 mArmUL = vec3(.0,.07, 40.+45.*sin(animTime)*friction.y);\n    vec3 mArmUR = vec3(.0,.07, 40.+55.*sin(animTime-.9*PI)*friction.x);\n    \n    vec3 mLegUL = vec3(.0,.07, 45.*sin(animTime-.9*PI)*friction.x);\n    vec3 mLegLL = vec3(.0,.07, 45.*clamp(sin(animTime-73./8.*PI),-.0,1.));\n    vec3 mShoeUL = vec3(.0,.0, -45.*clamp(sin(animTime-.9*PI),-1.,.0));\n    \n    vec3 mLegUR = vec3(.0,.07, 45.*sin(animTime)*friction.y);\n    vec3 mLegLR = vec3(.0,.07, 45.*clamp(sin(animTime-PI/8.),-0.,1.));\n    vec3 mShoeUR = vec3(.0,.0, -45.*clamp(sin(animTime),-1.,.0));\n    \n    \n    // Figurine position definition\n    vec2 body = rot(uv, vec2(.0,.1), -20.);\n    vec2 belly = rot(body, vec2(-.005,-.08), 20.);\n    vec2 trouserM = rot(body, vec2(-.03,-.18), 20.);\n    vec2 buttonR = trouserM-vec2(.12,.02);\n    vec2 buttonL = trouserM-vec2(.03,-.02);\n    \n    vec2 shadow = rot(body, vec2(-.2,-.65), 20.);\n    \n    vec2 armUL = rot(body, vec2(-.08,-.02), mArmUL);\n    vec2 armLL = rot(armUL, vec2(.01,-.15), vec3(.0,.07, -90.));\n    vec2 handUL = armLL-vec2(.0,-.04);\n    vec2 handLL = handUL-vec2(.0,-.07);\n    \n    vec2 armUR = rot(body, vec2(.01,.0), mArmUR);\n    vec2 armLR = rot(armUR, vec2(.01,-.15), vec3(.0,.07, -90.));\n    vec2 handUR = armLR-vec2(.0,-.04);\n    vec2 handLR = handUR-vec2(.0,-.07);\n    \n    vec2 trouserL = trouserM-vec2(-.07,-.08); \n    vec2 legUL = rot(trouserL, vec2(.02,-.06), mLegUL);\n    vec2 legLL = rot(legUL, vec2(.0,-.15), mLegLL);\n    vec2 shoeUL = rot(legLL, vec2(.0,-.1), mShoeUL);\n    vec2 shoeLL = shoeUL-vec2(.06,-.07);\n\n    vec2 trouserR = trouserM-vec2(.07,-.06);\n    vec2 legUR = rot(trouserR, vec2(-.01,-.06), mLegUR);\n    vec2 legLR = rot(legUR, vec2(.0,-.15), mLegLR);\n    vec2 shoeUR = rot(legLR, vec2(.0,-.1), mShoeUR);\n    vec2 shoeLR = shoeUR-vec2(.06,-.07);\n    \n    vec2 head = rot(body, vec2(.02,.22), 20.);\n    vec2 earR = head-vec2(-.12,.22);\n    vec2 earL = head-vec2(-.25,-.02);\n    vec2 noseB = rot(head, vec2(.18,.0), 35.);\n    vec2 noseT = rot(noseB, vec2(.0,.12), vec3(.0,-.04,-15.));\n    vec2 cheek = rot(head, vec2(.01,-.09), 15.);\n    vec2 mouth = head-vec2(.06,-.05);\n    vec2 lipU = head-vec2(.05,-.02);\n    vec2 tongue = rot(mouth, vec2(.025,-.092), -15.);\n    \n    vec2 eyeRO = rot(head, vec2(.08,.09), 45.);\n    vec2 eyeRI = eyeRO-vec2(.0,.01);\n    vec2 eyeLO = rot(head, vec2(-.01,.05), 45.);\n    vec2 eyeLI = eyeLO-vec2(.0);\n    \n    \n    // Figurine assembly, order matters \n    elli(shadow, vec2(.3*sin(animTime),.02), -.2);\n    \n    elli(legUL, vec2(.02,.09), -.5);\n    elli(legLL, vec2(.02,.09), -.5);\n    elli(shoeUL, vec2(.04,.02), .5);\n    elli(shoeLL, vec2(.14,.06), .5);\n    \n    elli(legUR, vec2(.02,.09), -.5);\n    elli(legLR, vec2(.02,.09), -.5); \n    elli(shoeUR, vec2(.04,.02), .5);\n    elli(shoeLR, vec2(.14,.06), .5);\n    \n    elli(armUR, vec2(.02,.09), -.5);\n    elli(armLR, vec2(.02,.09), -.5);\n    elli(handLR, vec2(.08,.07), -.5);\n    elli(handLR, vec2(.07,.06), .5);\n    elli(handUR, vec2(.04,.02), .5);\n    \n    elli(body, vec2(.12,.2), -.5);\n    amp += -1.*smoothstep(.007,-.007, abs(trouserM.y+.03+.02*sin(20.*trouserM.x+2.*animTime)))*smoothstep(.05,.0,length(uv-vec2(-.4,.0))-.3); //tail\n    \n    elli(trouserL, vec2(.08,.06), .5);\n    elli(trouserR, vec2(.08,.06), .5);\n    elli(trouserM, vec2(.17,.12), .5);\n    elli(buttonR, vec2(.025,.045), -.5);\n    elli(buttonR, vec2(.015,.035), .5);\n    elli(buttonL, vec2(.025,.045), -.5);\n    elli(buttonL, vec2(.015,.035), .5);\n    \n    elli(belly, vec2(.12,.06), -.5);\n    \n    elli(armUL, vec2(.02,.09), -.5);\n    elli(armLL, vec2(.02,.09), -.5);\n    elli(handLL, vec2(.08,.07), -.5);\n    elli(handLL, vec2(.07,.06), .5);\n    elli(handUL, vec2(.04,.02), .5);\n\n    elli(head, vec2(.17), -.5);\n    elli(earL, vec2(.11), -.5);\n    elli(earR, vec2(.11), -.5);\n    \n    elli(cheek, vec2(.16,.09), .5);\n    elli(mouth, vec2(.1,.13), -.5);\n    elli(lipU, vec2(.15,.08), .5);\n    elli(tongue, vec2(.065,.022), .5);\n    \n    elli(noseB, vec2(.07,.1), .5);\n    elli(noseT, vec2(.025,.045), -.5);\n    \n    elli(eyeRO, vec2(.09,.05), .5);\n    elli(eyeLO, vec2(.1,.08), .5);\n    elli(eyeRI, vec2(.04,.02), -.5);\n    elli(eyeLI, vec2(.05,.03), -.5);\n    \n    \n    // Draw\n    col += vec3(amp);\n\tcol = pow(col, vec3(.4545)); //gamma correction\n    col += .1*hash21(floor(111.*uv)*animTime)*(1.+.2*cos(20.*uv.y+animTime)); //noise\n    col *= vec3(244,239,223)/255.; //sepia tint\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}