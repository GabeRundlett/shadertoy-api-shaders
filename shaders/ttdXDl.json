{
    "Shader": {
        "info": {
            "date": "1581980874",
            "description": "Playing around with Jos Leys Kleinian Limit Set shader (I think knighty had a hand too): [url]https://www.shadertoy.com/view/MtKXRh[/url]\n\n<mouse> moves things around with a Mobius transformation (move to left edge to disable).\n\nOther keys: see code.",
            "flags": 48,
            "hasliked": 0,
            "id": "ttdXDl",
            "likes": 46,
            "name": "Maskit Kleinian Limit Set",
            "published": 3,
            "tags": [
                "kleinian",
                "maskit",
                "limitset",
                "josleys"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 1204
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Maskit parameterization of Kleinian Limit Sets\n//\n// Original by Jos Leys: https://www.shadertoy.com/view/MtKXRh\n//\n// Jos Leys' explanation: http://www.josleys.com/articles/Kleinian%20escape-time_3.pdf\n// Indra's Pearls: https://en.wikipedia.org/wiki/Indra%27s_Pearls_(book)\n//\n// This version by Matthew Arcus, 2020, mainly just prettified a little.\n//\n// A Kleinian group is generated by two or more Mobius transformations.\n// Repeated application of the group operations result in points\n// moving towards the \"limit set\" which often has an interesting fractal\n// structure.\n//\n// The Maskit parameterization is a way of finding \"interesting\" Kleinian\n// groups that are also amenable to being computer generated in a pointwise\n// way.\n//\n// <mouse>: apply Mobius transformation\n// <up>/<down>: zoom in/out\n// h: map to half plane\n// p: use mouse position for Maskit parameters\n// i: invert in unit disc at mouse position\n//\n////////////////////////////////////////////////////////////////////////////////\n\nfloat AA = 2.0;\n\nbool check = false; // Debugging\nvec3  color1 = vec3(0);\nvec3  color2 = vec3(1,0,0);\nvec3  color3 = vec3(1,1,0);\n\nconst float PI = 3.14159265;\n\n// Interesting parameters, mostly taken from \"Indra's Pearls\"\nconst vec2[] Params =\n  vec2[](vec2(1.8462756,0.09627581),\n         vec2(1.958591,0.011278), // 1/15 cusp\n         vec2(1.857382,0.076258), // 2/15 cusp\n         //vec2(1.90378,0.03958), // 2/19 cusp\n         //vec2(1.64213876,0.76658841),\n         //vec2(1.658312,0.5), // 3/10 cusp\n         //vec2(1.926434053,0.027381792) // MSW p. 323\n         vec2(2,0)); // Apollonian Gasket\n\nconst int NPARAMS = Params.length();\n\nbool domix = true;\n\nint NSTEPS = 50;\n\n//circle inversion\nvec2 InvCentre = vec2(0,-1);\nfloat radius2 = 2.0;\n\nfloat wrap(float x, float a, float s) {\n  return mod(x-s,a) + s;\n}\n\n// Apply Maskit Mobius transformation\nvoid TransA(inout vec2 z, float a, float b, inout float scale){\n  float iR = 1.0/dot(z,z);\n  z *= iR;\n  scale *= iR;\n  z.x = z.x - b;\n  z.y = a - z.y; \n}\n\n// Rotate positions above this line to below the line.\n// This is the clever part.\nbool separation(vec2 z, float a, float b) {\n  //return z.y >= a * 0.5 + sign(b)*(2.*a-1.95)/4. * sign(z.x + b * 0.5)* (1. - exp(-(7.2-(1.95-a)*15.)* abs(z.x + b * 0.5)));\n  float u = a, v = b, x = z.x, y = z.y;\n  float f = (x >= -v/2.0) ? 1.0 : -1.0;\n  float K = sign(b)*(2.0*a-1.95)/4.3;\n  float M = 7.2-(1.95-a)*18.0;\n  return z.y >= 0.5*u + K*f*(1.0 - exp(-M*abs(z.x + v * 0.5)));\n}\n\nvec4 JosKleinian(vec2 z, float a, float b, inout float scale) {\n  //if (separation(z,a,b)) check = true;\n  float f = sign(b);\n  vec2 lz = z+vec2(1), llz = z-vec2(1);\n  //z.y = mod(z.y,a);\n  float flag = 1.0;\n  for (int i = 0; i < 2*NSTEPS ; i++) {\n    z.x = z.x+f*b/a*z.y;\n    z.x = wrap(z.x, 2.0, -1.0);\n    z.x = z.x-f*b/a*z.y;\n                       \n    //If above the separation line, rotate by 180Â° about (-b/2, a/2)\n    if (separation(z,a,b)) {\n      z = vec2(-b, a) - z;\n      flag++;\n    }\n        \n    // Apply Mobius transformation a\n    TransA(z,a,b,scale);\n\t\t\n    // If the iterated points enters a 2-cycle, bail out.\n    if (dot(z-llz,z-llz) < 1e-6) {\n      return vec4(0,i,0.05,scale);\n    }\n    // If the iterated point gets outside z.y=0 and z.y=a, bail out.\n    if (z.y < 0.0) return vec4(flag,i,-z.y,scale);\n    if (z.y > a) return vec4(flag,i,z.y-a,scale);\n\n    //Store previous iterates for 2-cycle check\n    llz=lz; lz=z;\n  }\n  return vec4(0,NSTEPS,0,0);\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nbool keypress(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\n\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_L = 76;\nconst int CHAR_P = 80;\nconst int CHAR_S = 83;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_Z = 90;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor = vec4(0);\n  vec2 Klein = Params[int(iTime)%NPARAMS];\n  if (domix) {\n    float t = mod(0.2*iTime,float(NPARAMS));\n    int i = int(floor(t));\n    t = fract(t);\n    Klein = mix(Params[i],Params[(i+1)%NPARAMS],smoothstep(0.0,1.0,t));\n  }\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 z = (2.0*(fragCoord.xy + vec2(i,j)/AA) - iResolution.xy) / iResolution.y;\n      float zoom = exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n      z *= zoom;\n      float a = Klein.x;\n      float b = Klein.y;\n      float scale = 1.0; // Keep track of scaling factor here\n      if (false) {\n        // Invert in moving disc.\n        vec2 c = vec2(0,1.225*cos(iTime));\n        z -= c;\n        float k = 1.0/dot(z,z);\n        z *= k;\n        scale *= k;\n        z += c;\n      }\n      if (false && dot(z,z) > 1.0) {\n        float k = 1.0/dot(z,z);\n        z *= k;\n        scale *= k;\n      }\n      // Mouse handling\n      if (iMouse.x > 10.0) {\n        vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n        if (keypress(CHAR_P)){\n          a = 2.0+0.1*m.x;\n          b = 0.1*m.y;\n        } else if (keypress(CHAR_I)) {\n          // Invert in unit disc at mouse\n          z -= m;\n          float k = 1.0/dot(z,z);\n          z *= k;\n          scale *= k;\n          z += m;\n        } else {\n          // Unit disc inversion\n          m /= dot(m,m);\n          z -= m;\n          float k = (dot(m,m)-1.0)/dot(z,z);\n          z *= k;\n          scale *= abs(k);\n          z += m;\n        }\n      }\n      if (keypress(CHAR_H)) {\n        // Leave in half plane, but adjust position & size\n        z.y += 1.0;\n        z *= 0.5*a;\n      } else {\n        // Invert to unit disc\n        z -= InvCentre;\n        float d2 = radius2/dot(z,z);\n        z *= d2;\n        scale *= d2;\n        z += InvCentre;\n      }\n      vec4 hit = JosKleinian(z,a,b,scale);\n      vec3 col = color1;\n      if (hit.x != 0.0) {\n        //if (mod(hit.x,2.0) == 0.0) col = color2;\n        //else col = color3;\n        col = hsv2rgb(vec3(0.7+hit.y/float(NSTEPS),1,1));\n      }\n      //col = mix(col,vec3(0),smoothstep(0.0,0.005,hit.z/hit.w));\n      //col = mix(col,vec3(0),smoothstep(0.0,max(zoom*4.0/iResolution.y,0.005),hit.z/scale));\n      col = mix(col,vec3(0),smoothstep(0.0,zoom*4.0/iResolution.y,hit.z/scale));\n      fragColor += vec4(col, 1.0);\n    }\n  }\n  fragColor /= AA*AA;\n  fragColor = pow(fragColor,vec4(0.4545));\n  if (check) fragColor.x = 0.5;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n#if __VERSION__ < 300\n    t = vec4(0);\n#else\n    \n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0 ) {\n        t = vec4(0);\n    } else {\n        t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n        \n#endif           \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}