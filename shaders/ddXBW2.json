{
    "Shader": {
        "info": {
            "date": "1689171764",
            "description": "Visualization of the estimate of a predicate's uniformity across quadtree regions. Also contains definitions of useful estimator functions, which allow for fast and/or exact estimates.",
            "flags": 0,
            "hasliked": 0,
            "id": "ddXBW2",
            "likes": 13,
            "name": "SDF Predicate Uniformity Est.",
            "published": 3,
            "tags": [
                "sdf",
                "voxel",
                "voxel",
                "tree",
                "uniform",
                "uniform",
                "quadtree",
                "hierarchy",
                "uniformity"
            ],
            "usePreview": 0,
            "username": "GabeRundlett",
            "viewed": 450
        },
        "renderpass": [
            {
                "code": "\n// NOTE! The purpose of this ShaderToy is to show HOW an algorithm can improve the performance\n// of terrain generation, however, I can't think of a way that I could implement the algorithm\n// in ShaderToy where it's effectively applied. Therefore, this ShaderToy is just a visualization\n// of the algorithm.\n\n// You can change these!\nconst uint MAX_LOD = 12u;\nconst uint LOD_STEP = 1u;\n\nfloat WORLD_SCALE;\n\nconst bool USE_NAIVE_METHOD = true; // pointless variable, just exists as a explanatory device\n\nconst bool SHOW_ESTIMATED_SURFACE_VOXELS = false;\n\nconst vec3 BLUE = vec3(0.357, 0.612, 0.882);\nconst vec3 ORANGE = vec3(0.969, 0.663, 0.133);\n\nvec2 pixel_space_to_world_space(vec2 pixel_p) {\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = pixel_p / iResolution.xy * 2.0 - 1.0;\n    uv.x *= aspect;\n    uv *= WORLD_SCALE;\n    return uv;\n}\n\nvoid setup_scene() {\n    WORLD_SCALE = iResolution.y / 20.0 * 3.0;\n    circle_pos = vec2(-55.0, sin(iTime * 1.4) * 30.0);\n    if (iMouse.x > 0.0 && iMouse.y > 0.0) {\n        circle_pos = pixel_space_to_world_space(iMouse.xy);\n    }\n    rect_size = vec2(12.0 + sin(iTime * 2.0) * 6.0, 60.0);\n    noise_offset_a = vec2(0.0, -100.0 + sin(iTime) * 10.0);\n    noise_offset_b = vec2(cos(iTime) * 10.0, +100.0);\n    noise_offset_c = vec2(cos(iTime * 2.0) * 10.0, -sin(iTime) * 10.0);\n}\n\nfloat sd_grid(vec2 p) {\n    vec2 uv = abs(fract(p + 0.5) - 0.5);\n    return min(uv.x, uv.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    setup_scene();\n\n    vec2 uv = pixel_space_to_world_space(fragCoord);\n\n    // say this is the center of our voxel\n    vec2 voxel_pos = floor(uv) + 0.5;\n    vec3 voxel_color = vec3(0.0);\n\n    if (USE_NAIVE_METHOD) {\n        // normally, if we were generating a voxel world, we'd loop over every voxel to determine what\n        // the per-voxel data is. To do this, we run a function per-voxel, and then apply a predicate\n        // to the result of this function. Here, our predicate is just whether the value `d` is less\n        // than zero, which decides whether our voxel is BLUE or ORANGE. This function and predicate\n        // are very simple, but I am sure you can imagine how this idea can be extended.\n        float d = map(voxel_pos);\n        if (d < 0.0) {\n            voxel_color = BLUE;\n        } else {\n            voxel_color = ORANGE;\n        }\n        // This is already inefficient, but to add insult to injury, we may then generate a sparse data\n        // structure using this per-voxel data, in order to save memory. In this instance, we'd be using\n        // a \"bottom-up\" algorithm for generating our hierarchy. Anyone who has ever used tree data structures\n        // knows that this is inherently a bad idea, but how could we do our algorithm \"top-down\"?\n    } else {\n        // In order to do our algorithm \"top-down\", we'd need to determine whether this `d < 0.0` condition\n        // were uniform across a given region. Getting an *exact* answer isn't even necessary, it's just\n        // important that the estimate never says a region is uniform when it really isn't. Determining this\n        // is the purpose of this shadertoy, demonstrating the ability to generalize estimating a predicate's\n        // uniformity across the region encompassed by any given LOD level.\n\n        // The environment of a shader is not really the best place to implement this, since we'll still\n        // be running the predicate for every pixel, but if you had a CPU application, or custom GPU app\n        // which enabled you to do conditional generation, then this algorithm is relevant. Shaders are\n        // just the best way to visually demonstrate these things!\n        for (uint lod_i = 0u; lod_i <= MAX_LOD; lod_i += LOD_STEP) {\n            uint lod_level = MAX_LOD - lod_i;\n            if (is_map_uniform_on_lod(voxel_pos, lod_level)) {\n                float d = map(voxel_pos);\n                if (d < 0.0) {\n                    voxel_color = BLUE;\n                } else {\n                    voxel_color = ORANGE;\n                }\n                // A break here represents the early termination of a recursive function, which is why\n                // this would reduce cost if used in a different context.\n                break;\n            }\n        }\n    }\n\n    vec3 color = voxel_color;\n\n    if (SHOW_ESTIMATED_SURFACE_VOXELS) {\n        uint lod_i = MAX_LOD;\n        uint lod_level = MAX_LOD - lod_i;\n        float lod_scl = float(1u << lod_level);\n        if (is_map_uniform_on_lod(uv, lod_level + 1u)) {\n            color *= 0.0;\n        } else {\n            float grid_lines_fac = smoothstep(0.000, 0.25 / float(lod_scl), sd_grid(uv / lod_scl)) * 0.4 + 0.6;\n            color *= grid_lines_fac;\n        }\n    } else {\n        for (uint lod_i = 0u; lod_i <= MAX_LOD; lod_i += LOD_STEP) {\n            uint lod_level = MAX_LOD - lod_i;\n            float lod_scl = float(1u << lod_level);\n            if (is_map_uniform_on_lod(uv, lod_level)) {\n                float grid_lines_fac = smoothstep(0.000, 0.25 / float(lod_scl), sd_grid(uv / lod_scl)) * 0.4 + 0.6;\n                color *= grid_lines_fac;\n                break;\n            }\n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// These are set in the setup_scene() function of Image\nvec2 circle_pos;\nvec2 rect_size;\nvec2 noise_offset_a;\nvec2 noise_offset_b;\nvec2 noise_offset_c;\n\n// Here is where we actually define the map. We do this here as macros because\n// what we can do is swap out the `MAP_CIRCLE` and `MAP_BOX` functions can be\n// swapped out INDIVIDUALLY depending on the context where the map is consumed.\n#define USE_NOISE 1\n#if USE_NOISE\n#define MAP_DEF                                                        \\\n    MAP_CONSTANT(sd_union, 5.0)                                        \\\n    MAP_NOISE(sd_add, noise_offset_a, 0.01, 7.5)                       \\\n    MAP_NOISE(sd_add, noise_offset_b, 0.15, 1.1)                       \\\n    MAP_NOISE(sd_add, noise_offset_c, 0.60, 0.3)                       \\\n    MAP_GRADIENT_Y(sd_add, 0.17)                                       \\\n    MAP_CIRCLE(sd_union, circle_pos, 40.0)                             \\\n    MAP_BOX(sd_union, circle_pos - vec2(0.0, -10.0), vec2(50.0, 10.0)) \\\n    MAP_BOX(sd_union, vec2(80.0, 0.0), rect_size)\n#else\n#define MAP_DEF                                                        \\\n    MAP_CIRCLE(sd_union, circle_pos, 40.0)                             \\\n    MAP_BOX(sd_union, circle_pos - vec2(0.0, -10.0), vec2(50.0, 10.0)) \\\n    MAP_BOX(sd_union, vec2(0.0), rect_size)\n#endif\n\n// Below this is all just implementation details.\n\nconst float MAX_DIST = 1.0e9;\nconst float SQRT_2 = 1.41421356237;\n\nfloat nonzero_sign(float x) {\n    if (x < 0.0)\n        return -1.0;\n    return 1.0;\n}\nvec2 nonzero_sign(vec2 x) {\n    return vec2(nonzero_sign(x.x), nonzero_sign(x.y));\n}\n\nfloat sd_union(float a, float b) { return min(a, b); }\nfloat sd_add(float a, float b) { return (a + b); }\nfloat sd_mul(float a, float b) { return (a * b); }\n\n// assumed circle is at (0, 0)\nfloat sd_circle_nearest(vec2 p, float r) {\n    return length(p) - r;\n}\nfloat sd_circle_furthest(vec2 p, float r) {\n    return length(p) + r * 2.0;\n}\n\n// assumed box is centered at (0, 0)\nfloat sd_box_nearest(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\nfloat sd_box_furthest(vec2 p, vec2 b) {\n    return length(b * nonzero_sign(p) + p);\n}\n\n// assumed circle is at (0, 0)\nvec2 minmax_sd_circle_in_region(vec2 region_center, vec2 region_size, float r) {\n    float min_d = sd_box_nearest(-region_center, region_size);\n    float max_d = sd_box_furthest(-region_center, region_size);\n    return vec2(min_d, max_d) - r;\n}\n\nvec2 minmax_gradient_y_in_region(vec2 region_center, vec2 region_size, float f) {\n    float min_d = (region_center.y - region_size.y) * f;\n    float max_d = (region_center.y + region_size.y) * f;\n    return vec2(min_d, max_d);\n}\n\n// https://www.shadertoy.com/view/XttSz2\nfloat hash(float n) { return fract(sin(n) * 753.5453123); }\nvec4 noised(in vec3 x) {\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    vec3 u = w * w * (3.0 - 2.0 * w);\n    vec3 du = 6.0 * w * (1.0 - w);\n\n    float n = p.x + p.y * 157.0 + 113.0 * p.z;\n\n    float a = hash(n + 0.0);\n    float b = hash(n + 1.0);\n    float c = hash(n + 157.0);\n    float d = hash(n + 158.0);\n    float e = hash(n + 113.0);\n    float f = hash(n + 114.0);\n    float g = hash(n + 270.0);\n    float h = hash(n + 271.0);\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k3 = e - a;\n    float k4 = a - b - c + d;\n    float k5 = a - c - e + g;\n    float k6 = a - b - e + f;\n    float k7 = -a + b + c - d + e - f - g + h;\n\n    return vec4(k0 + k1 * u.x + k2 * u.y + k3 * u.z + k4 * u.x * u.y + k5 * u.y * u.z + k6 * u.z * u.x + k7 * u.x * u.y * u.z,\n                du * (vec3(k1, k2, k3) + u.yzx * vec3(k4, k5, k6) + u.zxy * vec3(k6, k4, k5) + k7 * u.yzx * u.zxy));\n}\n\nfloat sd_noise_conservative(vec2 p, float scale, float amp) {\n    float noise_val = noised(vec3(p * scale, 0.0)).x * 2.0 - 1.0;\n    return noise_val * amp;\n}\n\nvec2 minmax_noise_in_region(vec2 region_center, vec2 region_size, float scale, float amp) {\n    // Use the lipschitz constant to compute min/max est. For the cubic interpolation\n    // function of this noise function, said constant is 2.0 * 1.5 * scale * amp.\n    //  - 2.0 * amp comes from the re-scaling of the range between -amp and amp (line 112-113)\n    //  - scale comes from the re-scaling of the domain on the same line (p * scale)\n    //  - 1.5 comes from the maximum abs value of the first derivative of the noise\n    //    interpolation function (between 0 and 1): d/dx of 3x^2-2x^3 = 6x-6x^2.\n    float lipschitz = 2.0 * 1.5 * scale * amp;\n    float noise_val = sd_noise_conservative(region_center, scale, amp);\n    float max_dist = length(region_size);\n    return vec2(max(noise_val - max_dist * lipschitz, -amp), min(noise_val + max_dist * lipschitz, amp));\n}\n\nfloat map(vec2 p) {\n    float d = MAX_DIST;\n#define MAP_CIRCLE(op, x, r) \\\n    d = op(d, sd_circle_nearest(p - x, r));\n#define MAP_BOX(op, x, r) \\\n    d = op(d, sd_box_nearest(p - x, r));\n#define MAP_NOISE(op, x, s, a) \\\n    d = op(d, sd_noise_conservative(p - x, s, a));\n#define MAP_CONSTANT(op, x) \\\n    d = op(d, x);\n#define MAP_GRADIENT_Y(op, f) \\\n    d = op(d, p.y * f);\n    MAP_DEF\n#undef MAP_CIRCLE\n#undef MAP_BOX\n#undef MAP_NOISE\n#undef MAP_CONSTANT\n#undef MAP_GRADIENT_Y\n    return d;\n}\n\nvec2 map_at_lod(vec2 p, uint lod_level) {\n    float chunk_edge_length_at_lod = float(1u << lod_level);\n    vec2 lod_chunk_center_p = (floor(p / chunk_edge_length_at_lod) + 0.5) * chunk_edge_length_at_lod;\n    float chunk_diag_length_at_lod = SQRT_2 * 0.5 * chunk_edge_length_at_lod;\n\n    float min_d;\n    float max_d;\n\n    bool first = true;\n\n    // This is pretty self explanatory, but what we do here is estimate whether the\n    // chunk could be completely uniform at this LOD by ensuring the furthest distance\n    // in any direction from the chunk center is GREATER than the chunk's diagonal\n    // radius. This, in a sense, is like assuming the chunks are circles/spheres,\n    // which conservatively estimates the LOD-ing, especially when the nearest point\n    // of the SDF is in cardinal directions.\n\n#define MAP_CONSTANT(op, x)       \\\n    {                             \\\n        float d = x;              \\\n        if (first) {              \\\n            min_d = d;            \\\n            max_d = d;            \\\n        } else {                  \\\n            min_d = op(min_d, d); \\\n            max_d = op(max_d, d); \\\n        }                         \\\n        first = false;            \\\n    }\n\n#define MAP_GRADIENT_Y(op, f)                                                                              \\\n    {                                                                                                      \\\n        vec2 d = minmax_gradient_y_in_region(lod_chunk_center_p, vec2(chunk_edge_length_at_lod * 0.5), f); \\\n        if (first) {                                                                                       \\\n            min_d = d[0];                                                                                  \\\n            max_d = d[1];                                                                                  \\\n        } else {                                                                                           \\\n            min_d = op(min_d, d[0]);                                                                       \\\n            max_d = op(max_d, d[1]);                                                                       \\\n        }                                                                                                  \\\n        first = false;                                                                                     \\\n    }\n\n    // Using this function as the definition of the minmaxing of your function will result in\n    // an imperfect but FAST (and super simply implemented) estimate!\n#define SD_SPHERE_CHUNK_EST(op, f)                           \\\n    {                                                        \\\n        float d = f;                                         \\\n        if (first) {                                         \\\n            min_d = d - chunk_diag_length_at_lod;            \\\n            max_d = d + chunk_diag_length_at_lod;            \\\n        } else {                                             \\\n            min_d = op(min_d, d - chunk_diag_length_at_lod); \\\n            max_d = op(max_d, d + chunk_diag_length_at_lod); \\\n        }                                                    \\\n        first = false;                                       \\\n    }\n\n    // Using this function as the definition of the minmaxing of your function will result in\n    // an imperfect (but slightly better, slightly slower, and super simply implemented) estimate!\n#define SD_SPHERE_CHUNK_EST_4(op, f0, f1, f2, f3)                                              \\\n    {                                                                                          \\\n        float d0 = f0;                                                                         \\\n        float d1 = f1;                                                                         \\\n        float d2 = f2;                                                                         \\\n        float d3 = f3;                                                                         \\\n        if (first) {                                                                           \\\n            min_d = min(min(d0, d1), min(d2, d3)) - chunk_diag_length_at_lod * 0.5;            \\\n            max_d = max(max(d0, d1), max(d2, d3)) + chunk_diag_length_at_lod * 0.5;            \\\n        } else {                                                                               \\\n            min_d = op(min_d, min(min(d0, d1), min(d2, d3)) - chunk_diag_length_at_lod * 0.5); \\\n            max_d = op(max_d, max(max(d0, d1), max(d2, d3)) + chunk_diag_length_at_lod * 0.5); \\\n        }                                                                                      \\\n        first = false;                                                                         \\\n    }\n\n    // I defined a perfect circle estimator right below, so there's no need to use the SDF one\n    // #define MAP_CIRCLE(op, x, r) SD_SPHERE_CHUNK_EST(op, sd_circle(lod_chunk_center_p - x, r))\n#define MAP_CIRCLE(op, x, r)                                                                                  \\\n    {                                                                                                         \\\n        vec2 d = minmax_sd_circle_in_region(lod_chunk_center_p - x, vec2(chunk_edge_length_at_lod * 0.5), r); \\\n        if (first) {                                                                                          \\\n            min_d = d[0];                                                                                     \\\n            max_d = d[1];                                                                                     \\\n        } else {                                                                                              \\\n            min_d = op(min_d, d[0]);                                                                          \\\n            max_d = op(max_d, d[1]);                                                                          \\\n        }                                                                                                     \\\n        first = false;                                                                                        \\\n    }\n\n#define MAP_BOX(op, x, r) SD_SPHERE_CHUNK_EST(op, sd_box_nearest(lod_chunk_center_p - x, r))\n\n#define MAP_NOISE(op, x, s, a)                                                                               \\\n    {                                                                                                        \\\n        vec2 d = minmax_noise_in_region(lod_chunk_center_p - x, vec2(chunk_edge_length_at_lod * 0.5), s, a); \\\n        if (first) {                                                                                         \\\n            min_d = d[0];                                                                                    \\\n            max_d = d[1];                                                                                    \\\n        } else {                                                                                             \\\n            min_d = op(min_d, d[0]);                                                                         \\\n            max_d = op(max_d, d[1]);                                                                         \\\n        }                                                                                                    \\\n        first = false;                                                                                       \\\n    }\n\n    MAP_DEF\n#undef MAP_CIRCLE\n#undef MAP_BOX\n#undef MAP_NOISE\n#undef MAP_CONSTANT\n#undef MAP_GRADIENT_Y\n\n    return vec2(min_d, max_d);\n}\n\nbool is_map_uniform_on_lod(vec2 p, uint lod_level) {\n    if (lod_level == 0u)\n        return true;\n    vec2 minmax = map_at_lod(p, lod_level);\n    return minmax[0] >= 0.0 || minmax[1] < 0.0;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}