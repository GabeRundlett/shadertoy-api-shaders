{
    "Shader": {
        "info": {
            "date": "1549494624",
            "description": "I stream shader creation every Wednesday at 9pm UK time, over at [url]https://twitch.tv/lunasorcery[/url]\nCome and watch a show!\n\nOr watch the VOD for this shader here: [url]https://www.twitch.tv/videos/376293452[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "tdB3z3",
            "likes": 16,
            "name": "[twitch] Snap Arch",
            "published": 3,
            "tags": [
                "raymarched",
                "livecoding",
                "twitch"
            ],
            "usePreview": 0,
            "username": "yx",
            "viewed": 684
        },
        "renderpass": [
            {
                "code": "/*\n\tThis shader was created live on stream!\n\tYou can watch the VOD here: https://www.twitch.tv/videos/376293452\n\n\tI use the Bonzomatic tool by Gargaj/Conspiracy:\n\thttps://github.com/Gargaj/Bonzomatic\n\n\tWednesdays around 9pm UK time I stream at https://twitch.tv/lunasorcery\n\tCome and watch a show!\n\n\t~yx\n*/\n\n#define pi (acos(-1.))\n\n// shadertoy port only - Bonzomatic provides a noise texture which I'm approximating here\nfloat noise(vec2 a)\n{\n    float b = 0.;\n    b += texture(iChannel0, a*.25).r*.5;\n    b += texture(iChannel0, a*.5).r*.25;\n    b += texture(iChannel0, a*1.).r*.125;\n    b += texture(iChannel0, a*2.).r*.0625;\n    return b*.6+.2;\n}\n\nvec2 rotate(vec2 a, float b)\n{\n    float c =cos(b);\n    float s =sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nfloat sdBox(vec3 p, vec3 r)\n{\n    p = abs(p)-r;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat upperroof(vec3 p)\n{\n    p.y -= .3;\n    float d = sdBox(p,vec3(6,.05,1));\n    d = min(d, sdBox(p-vec3(0,.1,0),vec3(6.1,.05,1.1)));\n    d = min(d, sdBox(p-vec3(0,.2,0),vec3(6.2,.05,1.2)));\n\n    d = min(d, sdBox(p-vec3(0,.4,0),vec3(5.3,.05,.3)));\n    d = min(d, sdBox(p-vec3(0,.5,0),vec3(5.4,.05,.4)));\n    d = min(d, sdBox(p-vec3(0,.6,0),vec3(5.5,.05,.5)));\n\n    p.x = abs(abs(abs(abs(p.x)-2.1)-2.1)-1.05)-.525;\n    p.z = abs(p.z)-.5;\n    p.y+=.5;\n    d = min(d, sdBox(p, vec3(.05,.5,.05)));\n\n    return d;\n}\n\nfloat roof(vec3 p)\n{\n    p.y-=7.05;\n    float upper = upperroof(p);\n\n    p.y -= (p.x*p.x)*.001;\n    p.z = -abs(p.z);\n    p.x=5.-abs(p.x);\n    p.xz = p.x>p.z?p.xz:p.zx;\n\n    p.yz = rotate(p.yz, pi/6.8);\n\n    float surface = abs(p.y + cos(p.x*6.*pi)*.05)-.04;\n    vec3 np = p;\n    np.x = mod(p.x, 1.)-.5;\n    float surface2 = sdBox(np-vec3(0,.1,0),vec3(.05,.02,4));\n    surface = max(surface, -(length(p.xz+vec2(-5,25))-22.2));\n    surface2 = max(surface2, -(length(p.xz+vec2(-5,25))-22.05)); \n    surface = min(surface, surface2);\n    return min(max(surface,-4.-p.z), upper);\n}\n\nfloat column(vec3 p)\n{\n    p.xz = abs(p.xz);\n\n    p.xz -= .3;\n    p.xz = abs(p.xz);\n\n    float cheap = sdBox(p,vec3(.5,6,.5));\n    if(cheap > .1) return cheap;\n\n    if(p.y>3.&&p.y<5.){\n        p.xz *= 1. + cos(p.y*20.)*.05;\n    }else if(p.y>5.5){\n        p.xz /= 1.+(p.y-5.5);\n    }\n    float d = sdBox(p,vec3(.28,10,.28));\n    d = max(d, -sdBox(p-vec3(.25,3,.25),vec3(.04,2,.04)));\n    d = min(d, sdBox(p,vec3(.37,.1,.37)));\n    d = min(d, sdBox(p,vec3(.33,.2,.33)));\n    d = max(d, -sdBox(p-vec3(0,4,0), vec3(.5)));\n    d = min(d, length(p.xz)-.28);\n    p.xz = p.x>p.z?p.xz:p.zx;\n    //d = max(d, -sdBox(p-vec3(1,2,0),vec3(.75,.95,.17)));\n\n\n    // cut the top off\n    return max(d,p.y-5.9);\n}\n\nfloat columns(vec3 p)\n{\n    p=abs(p);\n    p.xz-= vec2(4,1.6);\n    p=abs(p);\n    p.x-= 2.;\n    return column(p);\n}\n\nfloat ground(vec3 p)\n{\n    if (p.y>.1)\n        return p.y;\n\n    float s = .005*pow(.9,length(p.xz));\n    float displacement = 0.;//sin(columns(vec3(p.x,0,p.z))*10. - iTime*10.);\n    displacement += sin(length(p.xz-vec2(6,0))*5.-iTime*10.);\n    displacement += sin(length(p.xz+vec2(6,0))*4.-iTime*10.);\n    return p.y + displacement * s;\n    //return p.y + sin(p.x*10.)*s+ sin(p.z*10.)*s;\n}\n\nint mat;\n\nfloat scene(vec3 p)\n{\n    //return min(ground(p),column(p));\n    float a = min(\n        roof(p),\n        columns(p)\n    );\n    float b = ground(p);\n    mat = a<b?0:1;\n    return min(a,b);\n}\n\nvec3 skycolor(vec3 dir, vec3 accum)\n{\n    float nois = noise(vec2(dir.y, 2.*atan(dir.x,dir.z)/pi));\n    //nois *= 1.-pow(abs(dir.y),.5)*.2;\n    nois *= 1.-pow(abs(dir.y*.6),.7)*2.5;\n    //return vec3(nois);\n    //return accum * mix(vec3(1,.3,.05),vec3(2,.02,.01),nois*3);\n    return accum * (pow(vec3(nois*2.), vec3(1,2.5,5)) + vec3(.4,0,0)) + smoothstep(.02,.0,abs(dir.y))*.2;\n    return accum * vec3(1);\n}\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n    vec3 accum = vec3(1);\n    vec3 sky = skycolor(dir,accum);\n    float fog = 0.;\n    for(int b=0;b<2;++b){\n        float t = 0.;\n        float k = 0.;\n        int i;\n        for(i=0;i<250;++i)\n        {\n            k = scene(cam+dir*t);\n            t+=k;\n            if(k<.001)\n                break;\n        }\n        vec3 h = cam+dir*t;\n        vec2 o = vec2(.001,0);\n        vec3 n = normalize(vec3(\n            scene(h+o.xyy)-scene(h-o.xyy),\n            scene(h+o.yxy)-scene(h-o.yxy),\n            scene(h+o.yyx)-scene(h-o.yyx)\n        ));\n\n        //return n*.5+.5;\n\n        if (k >= .001)\n        { // sky\n            return mix(sky,skycolor(dir,accum),fog);\n        }\n        else if (mat == 0)\n        {\n            //return vec3(pow(1.-dot(-dir,n),1.));\n            float light = pow(float(i)/100.,3.)*.99+.01;\n            //light += dot(n,normalize(vec3(1,3,1)))*.1;\n            return sky*vec3(light);\n            //  return vec3(n.yyy*.5+.5);\n        }\n        else\n        {\n            dir = reflect(dir,n);\n            cam = h + dir * .01;\n            //accum *= .3;\n            accum *= mix(vec3(1),sky,pow(.8,t));\n            fog = pow(.95,t);\n        }\n    }\n    return vec3(0);\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 cam = vec3(0,2,-30);\n    vec3 dir = normalize(vec3(uv,1.5));\n\n    dir.yz = rotate(dir.yz, -.05);\n\n    // cam.yz = rotate(cam.yz, .3);\n    // dir.yz = rotate(dir.yz, .3);\n    // cam.xz = rotate(cam.xz, -pi/4);\n    // dir.xz = rotate(dir.xz, -pi/4);\n\n    cam.xz = rotate(cam.xz, iTime*.1);\n    dir.xz = rotate(dir.xz, iTime*.1);\n\n    out_color.rgb = trace(cam,dir);\n    out_color.rgb = pow(out_color.rgb, vec3(.45));\n    out_color.rgb = pow(out_color.rgb, vec3(1)+2.*dot(uv,uv));\n    out_color.rgb *= 1.-dot(uv,uv)*.3;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}