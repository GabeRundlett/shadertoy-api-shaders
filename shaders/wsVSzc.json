{
    "Shader": {
        "info": {
            "date": "1574674598",
            "description": "4D raymarching",
            "flags": 0,
            "hasliked": 0,
            "id": "wsVSzc",
            "likes": 5,
            "name": "Hypercube with 4D rotation",
            "published": 3,
            "tags": [
                "raymarching",
                "4d",
                "hypercube"
            ],
            "usePreview": 0,
            "username": "tomoe",
            "viewed": 478
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n#define EPSILON 1e-4\n#define INFTY 1e6\nfloat wireHypCube(vec4 p) {\n    vec4 q = abs(p) - 0.5;\n    vec4 r = -1.0 * min(q, 0.0);\n    // minVal < midVal < maxVal among {x,y,z}\n    float minVal = min(r.x, min(r.y, r.z));\n    float maxVal = max(r.x, max(r.y, r.z));\n    float midVal = min(max(r.x, r.y), min(max(r.y, r.z), max(r.z, r.x)));\n    // val4 < val3 < val2 < val1 among {x,y,z,w}\n    float val4 = min(minVal, r.w);\n    float val1 = max(maxVal, r.w);\n    float val2 = max(midVal, min(maxVal, r.w));\n    float val3 = min(midVal, max(minVal, r.w));\n    // distance to the closest boundary component\n    return sqrt(pow(length(max(q, 0.0)), 2.0) + pow(val4, 2.0) + pow(val3, 2.0));\n}\nfloat surfaceSDF(vec4 p)\n{\n    float edge = 0.01;\t// thickness of edge\n    return wireHypCube(p) - edge;\t// suggested by iapafoto\n}\nfloat getAngle(vec4 p, vec4 q) {\n    return acos(dot(normalize(p), normalize(q)));\n}\nvec4 getNormal(vec4 p) {\n    float d = EPSILON;\n    return normalize(vec4(\n            surfaceSDF(p + vec4(d, 0.0, 0.0, 0.0)) - surfaceSDF(p),\n            surfaceSDF(p + vec4(0.0, d, 0.0, 0.0)) - surfaceSDF(p),\n            surfaceSDF(p + vec4(0.0, 0.0, d, 0.0)) - surfaceSDF(p),\n            surfaceSDF(p + vec4(0.0, 0.0, 0.0, d)) - surfaceSDF(p)\n        ));\n    }\n    mat4 rotXW(float t) {\n        return mat4(\n            1.0, 0.0, 0.0, 0.0,\n            0.0, cos(t), sin(t), 0.0,\n            0.0, - sin(t), cos(t), 0.0,\n            0.0, 0.0, 0.0, 1.0\n        );\n    }\n    mat4 rotXY(float t) {\n        return mat4(\n            1.0, 0.0, 0.0, 0.0,\n            0.0, 1.0, 0.0, 0.0,\n            0.0, 0.0, cos(t), sin(t),\n            0.0, 0.0, - sin(t), cos(t)\n        );\n    }\n    mat4 rotXZ(float t) {\n        return mat4(\n            1.0, 0.0, 0.0, 0.0,\n            0.0, cos(t), 0.0, sin(t),\n            0.0, 0.0, 1.0, 0.0,\n            0.0, - sin(t), 0.0, cos(t)\n        );\n    }\n    mat4 rotYZ(float t) {\n        return mat4(\n            cos(t), 0.0, 0.0, sin(t),\n            0.0, 1.0, 0.0, 0.0,\n            0.0, 0.0, 1.0, 0.0,\n            - sin(t), 0.0, 0.0, cos(t)\n        );\n    }\n    mat4 rotYW(float t) {\n        return mat4(\n            cos(t), 0.0, sin(t), 0.0,\n            0.0, 1.0, 0.0, 0.0,\n            - sin(t), 0.0, cos(t), 0.0,\n            0.0, 0.0, 0.0, 1.0\n        );\n    }\n    mat4 rotZW(float t) {\n        return mat4(\n            cos(t), sin(t), 0.0, 0.0,\n            - sin(t), cos(t), 0.0, 0.0,\n            0.0, 0.0, 1.0, 0.0,\n            0.0, 0.0, 0.0, 1.0\n        );\n    }\n    void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n        vec4 lightDir = vec4(0.0, 4.0, 1.0, 0.0);\n        \n        // fragment position\n        vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n        \n        // camera\n        vec4 cPos = vec4(0.0, 0.0, 2.0, 0.0);\n        vec4 cDir = vec4(0.0, - 0.0, - 1.0, 0.0);\n        vec4 cUp = vec4(0.0, 1.0, 0.0, 0.0);\n        vec4 cSide = vec4(1.0, 0.0, 0.0, 0.0);\n        float targetDepth = 1.0;\n        float t = iTime * 0.3;\n        mat4 g = rotXZ(t) * rotZW(t) * rotXY(t) * rotYZ(t);\n        cPos = g * cPos;\n        cDir = g * cDir;\n        cUp = g * cUp;\n        cSide = g * cSide;\n        lightDir = g * lightDir;\n        \n        // ray\n        vec4 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n        float ang = getAngle(ray, - normalize(cPos));\n        vec4 rPos = cPos + ray;\n        \n        // marching loop\n        for(int i = 0; i < 20; i ++ ) {\n            rPos += surfaceSDF(rPos) * ray;\n            if (surfaceSDF(rPos) < 0.01) {\n                break;\n            }\n        }\n        vec4 normal = getNormal(rPos);\n        float diff = clamp(dot(normalize(lightDir - rPos), normal), 0.01, 1.0);\n        \n        // hit check\n        if (surfaceSDF(rPos) < 0.01) {\n            fragColor = vec4(diff * vec3(rPos.x, 1.0, rPos.p), 1.0);\n        } else {\n            fragColor = vec4(vec3(1.0, 1.0, 1.0), 1.0);\n        }\n    }",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}