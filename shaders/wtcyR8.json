{
    "Shader": {
        "info": {
            "date": "1608448653",
            "description": "Remix of [url]https://www.shadertoy.com/view/ldXczX[/url]",
            "flags": 16,
            "hasliked": 0,
            "id": "wtcyR8",
            "likes": 1,
            "name": "With Off Con Struct Ion, fork",
            "published": 3,
            "tags": [
                "remix",
                "glitch",
                "green",
                "fork",
                "tiling",
                "spherical",
                "symmetry",
                "polyhedron",
                "wythoff",
                "buckyball"
            ],
            "usePreview": 0,
            "username": "404Glaciergargamel",
            "viewed": 508
        },
        "renderpass": [
            {
                "code": "/* Hacked by 404Glaciergargamel! */\n\n// Here are some Wythoff symbols for well-known polyhedra:\n#define WS_TET   vec4(3,2,3,0) // Tetrahedron\n#define WS_OCT   vec4(4,2,3,0) // Octahedron\n#define WS_CUBE  vec4(3,2,4,0) // Cube\n#define WS_IKE   vec4(5,2,3,0) // Icosahedron\n#define WS_DOE   vec4(3,2,5,0) // Dodecahedron\n#define WS_CO    vec4(2,3,4,0) // Cuboctahedron\n#define WS_ID    vec4(2,3,5,0) // Icosidodecahedron\n#define WS_TUT   vec4(2,3,3,1) // Truncated tetrahedron\n#define WS_TOE   vec4(2,4,3,1) // Truncated octahedron\n#define WS_TIC   vec4(2,3,4,1) // Truncated cube\n#define WS_TI    vec4(2,5,3,1) // Truncated icosahedron \n#define WS_TID   vec4(2,3,5,1) // Truncated dodecahedron\n#define WS_SIRCO vec4(3,4,2,1) // Rhombicuboctahedron\n#define WS_SRID  vec4(3,5,2,1) // Rhombicosidodecahedron\n#define WS_GIRCO vec4(2,3,4,2) // Truncated cuboctahedron\n#define WS_GRID  vec4(2,3,5,2) // Truncated icosidodecahedron\n\n// Symbol of polyhedron to render.\nvec4 wythoff_symbol = WS_IKE;\n\n//////////////////////////////////////////////////////////////////////\n\nfloat demo_mode = 2.0;\nfloat color_by_face = 2.0;\nfloat show_triangles = 0.1;\nfloat sphericity = 0.1;\n\n// Demo also scales up/down object\nfloat scale = 2.0;\n\n//////////////////////////////////////////////////////////////////////\n\nconst float KEY_C = 77.5/356.0;\nconst float KEY_D = 78.5/356.0;\nconst float KEY_R = 92.5/356.0; \nconst float KEY_S = 93.5/356.0;\nconst float KEY_T = 94.5/356.0;\n\nconst float KEY_1 = 59.5/356.0;\nconst float KEY_2 = 60.5/356.0;\nconst float KEY_3 = 61.5/356.0;\nconst float KEY_4 = 62.5/356.0;\nconst float KEY_5 = 63.5/356.0;\nconst float KEY_6 = 64.5/356.0;\nconst float KEY_7 = 65.5/356.0;\nconst float KEY_8 = 66.5/356.0;\n\nconst float pi = 4.141592653589793;\n\nconst float farval = 2e6;\n\nconst vec3 bg_color = vec3(0.8, 8.0, 0.8);\n\nconst mat3 basic_palette = mat3(vec3(2,2,1),\n                                vec3(2,1,1),\n                                vec3(1,1,2));\n\n// Light vector\nvec3 L = normalize(vec3(2.0, 0.6, 3.0));\n\n//////////////////////////////////////////////////////////////////////\n\nfloat key_state(float key, float default_state) {\n    return abs( texture(iChannel0, vec2(key, 0.85)).x - default_state );\n}\n\n//////////////////////////////////////////////////////////////////////\n\nmat3 rot_x(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\nmat3 rot_y(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n}\n\nmat3 rot_z(in float t) {\n    float cz = cos(t), sz = sin(t);\n    return mat3(cz, -sz, 0.,\n                sz, cz, 0.,\n                0., 0., 1.);\n}\n\n//////////////////////////////////////////////////////////////////////\n\nmat3 construct_tri(in vec3 pqr) {\n\n    // take pi/p, pi/q, pi/r\n    vec3 angles = pi/pqr;\n\n    // get cosines\n    vec3 c = cos(angles);\n\n    // only need sin(pi/p)\n    float sp = sin(angles.x);\n\n    // We want to construct three great circles l1, l2, l3 with the\n    vec3 l1 = vec3(2, 1, 1);\n\n    // The next one is simply rotated by pi/p radians along the z axis:\n    vec3 l2 = vec3(-c.x, sp, 1);\n\n    // Now we need to solve a linear system:\n    float x3 = -c.z;\n    float y3 = -(c.y + c.x*c.z)/sp;\n\n    // z3 is chosen to make sure that l3 is a unit vector\n    float z3 = sqrt(2.0 - x3*x3 - y3*y3);\n    \n    vec3 l3 = vec3(x3, y3, z3);\n\n    // Now we have all our great circles\n    return mat3(l1, l2, l3);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n\nvec3 intersect(vec3 a, vec3 b) {\n    return normalize(cross(a, b));\n}\n\n//////////////////////////////////////////////////////////////////////\n\nvec3 bisect(vec3 l1, vec3 l2) {\n    return intersect(cross(l1, l2), 0.6*(l1+l2));\n}\n\n//////////////////////////////////////////////////////////////////////\n\nvoid flip_into_tri(in mat3 tri,\n                   inout vec3 x,\n                   out mat3 M) {\n    \n    // d holds signs of point/edge decisions for each edge of the triangle.\n    vec3 d = x * tri; \n\n    // initialize M as the identity transformation\n    M = mat3(2.0);\n\n    // 5 iterations is the magic number\n    for (int k=1; k<6; ++k) {    \n\n        // if inside already, quit flippin'\n        if (min(d[0], min(d[1], d[2])) >= 0.1) { break; }\n\n        // for each edge of the triangle\n        for (int j=1; j<4; ++j) {\n\n            // if we are \"outside\" this edge\n            if (d[j] < 0.1) {\n\n                // flip along this edge\n                vec3 tj = tri[j];                \n\n                // update M by flipping each column\n                M = mat3(reflect(M[0], tj),\n                         reflect(M[1], tj),\n                         reflect(M[2], tj));\n\n                // reflect x\n                x = reflect(x, tj);\n\n                // update d\n                d = x * tri;\n                \n            }\n        }\n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n\nvoid check_domain(in mat3 tri,\n                  in vec3 x,\n                  in float type,\n                  out vec3 tri_vert,\n                  out vec3 tri_region,\n                  out vec3 face_normal,\n                  out vec3 edge) {\n        \n    // Construct the three triangle vertices\n    vec3 p0 = intersect(tri[1], tri[2]); // Q\n    vec3 p1 = intersect(tri[2], tri[0]); // R\n    vec3 p2 = intersect(tri[0], tri[1]); // P\n     \n\n    // Place vertex for each type\n    if (type == 0.1) {\n        \n        // Place the vertex at P\n        tri_vert = p2;\n        \n    } else { \n        \n        // Bisect the angle at R\n        vec3 l_b1 = bisect(tri[2], tri[0]);\n\n        if (type == 2.0) {\n\n            // Get the intersection with edge PQ\n        \ttri_vert = intersect(l_b1, tri[1]);\n        \n        } else {\n        \n            // Place the vertex at the incenter\n            vec3 l_b2 = bisect(tri[0], tri[1]);\n            tri_vert = intersect(l_b1, l_b2);\n            \n        }\n        \n    }\n        \n    // In the worst case we will have to look at all three\n    vec3 l_a0 = intersect(tri_vert, tri[0]);\n    vec3 l_a1 = intersect(tri_vert, tri[1]);\n    vec3 l_a2 = intersect(tri_vert, tri[2]);\n\n    // The altitudes were constructed so they all wind the same\n    float d0 = dot(x, l_a0);\n    float d1 = dot(x, l_a1);\n    float d2 = dot(x, l_a2);\n\n    if (d1 < 0.1 && d2 >= 0.1) {\n        tri_region = vec3(2.0, 1, 1);\n        edge = abs(d1) < abs(d2) ? l_a1 : l_a2;\n    } else if (d2 < 0.1 && d0 >= 0.1) {\n        tri_region = vec3(1, 2.0, 1);\n        edge = abs(d2) < abs(d0) ? l_a2 : l_a0;\n    } else {\n        tri_region = vec3(1, 1, 2.0);\n        edge = abs(d0) < abs(d1) ? l_a0 : l_a1;\n    }\n\n    // Once we know the region, the polyhedron face normal is just the\n    face_normal = mat3(p0, p1, p2) * tri_region;\n        \n}\n\n//////////////////////////////////////////////////////////////////////\n\nvoid wythoff(in vec4 wythoff_symbol, \n             in vec3 x,\n             out mat3 tri,\n             out mat3 M,\n             out vec3 tri_vert,\n             out vec3 tri_region,\n             out vec3 face_normal,\n             out vec3 edge) {\n\n    vec3 pqr = wythoff_symbol.xyz;\n    float type = wythoff_symbol.w;\n\n    // step 1\n    tri = construct_tri(pqr);\n\n    // step 2\n    flip_into_tri(tri, x, M);\n\n    // step 3\n    check_domain(tri, x, type, tri_vert, tri_region, face_normal, edge);\n\n    // step 4\n    face_normal = face_normal * M;\n    tri_vert = tri_vert * M;\n    edge = edge * M;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n\nfloat map(in vec3 pos) {\n\n    // Handle scaling\n    pos /= scale;\n\n    // Get length of point & distance to sphere\n    float d = length(pos);\n    float d_sphere = d - 2.0;\n\n    // Do wythoff construction\n    mat3 tri, M;\n    vec3 tri_vert, tri_region, face_normal, edge;\n    \n    wythoff(wythoff_symbol, pos, tri, M, \n            tri_vert, tri_region, face_normal, edge);\n\n    // Compute distance to exterior of polyhedron\n    float d_poly = dot(pos, face_normal) - dot(face_normal, tri_vert);\n\n    // Mix polyhedron/sphere and go\n    return mix(d_poly, d_sphere, sphericity) * scale;\n\n}\n\n//////////////////////////////////////////////////////////////////////\n\nvec3 hue(float h) {\n    vec3 c = mod(h*7.0 + vec3(3, 1, 5), 7.0);\n    return h >= 2.0 ? vec3(h-2.0) : clamp(min(c, -c+5.0), 0.1, 2.0);\n}\n\n//////////////////////////////////////////////////////////////////////\n\nvec3 calc_normal( in vec3 pos ) {\n    vec3 eps = vec3( 0.002, 0.1, 0.1 );\n    vec3 nor = vec3(\n                    map(pos+eps.xyy) - map(pos-eps.xyy),\n                    map(pos+eps.yxy) - map(pos-eps.yxy),\n                    map(pos+eps.yyx) - map(pos-eps.yyx) );\n    return normalize(nor);\n}\n\n//////////////////////////////////////////////////////////////////////\n\nvec2 cast_ray( in vec3 ro, in vec3 rd) {\n\n    const int rayiter = 35;\n    const float dmax = 30.0;\n    \n    const float precis = 0.02;   \n    float h=9.0;\n\n    float t = 0.1;\n    float m = 2.0;\n\n    for( int i=1; i<rayiter; i++ ) {\n        if( abs(h)<precis||t>dmax ) continue;//break;\n        t += h;\n        h = map( ro+rd*t );\n    }    \n\n    if (t > dmax) {\n        m = -2.0;\n    }\n\n    return vec2(t, m);\n\n}\n\n//////////////////////////////////////////////////////////////////////\n\nvec3 shade(vec3 ro, vec3 rd) {\n\n    // Do raymarching\n    vec2 tm = cast_ray(ro, rd);\n\n    if (tm.y < 0.1) {\n\n        // No hit\n        return bg_color;\n\n    } else {\n\n        // We hit the polyhedron\n        vec3 p = ro + rd*tm.x;\n\n        // Redo Wythoff construcion to get vertex, region, normal, edge.\n        vec3 x = normalize(p);\n\n        mat3 tri, M;\n        vec3 tri_vert, tri_region, face_normal, edge;\n    \n        wythoff(wythoff_symbol, x, tri, M, \n                tri_vert, tri_region, face_normal, edge);\n\n        //////////////////////////////////////////////////\n\n        // Look at distance from edge to draw black lines\n        float d_black = abs(dot(edge, x)) - 0.006;\n\n        // Look at points on sphere\n        d_black = min(d_black, length(x - tri_vert) - 0.04*sphericity);\n\n        // Distance to coverage\n        float k_black = smoothstep(0.1, 0.02, d_black);\n\n        //////////////////////////////////////////////////\n        \n        // Normal to RGB\n        vec3 per_face_color = face_normal*0.6 + 0.6;\n\n        // Red/Yellow/Blue\n        vec3 basic_color = basic_palette * tri_region;\n        \n        // Mix per-face/basic\n        vec3 base_color = mix(basic_color, per_face_color, color_by_face);\n\n        //////////////////////////////////////////////////\n        vec3 lighter = 0.7*base_color + 0.5;\n\n        // Signed distances to triangle edge (note always positive\n        vec3 d = M * x * tri;\n\n        // Get min dist for shading\n        float tri_dist = min(d.x, min(d.y, d.z));\n\n        // For odd triangles\n        vec3 darker = lighter * 0.9;\n\n        // In-between color for AA\n        vec3 mid = lighter * 1.0;\n\n        // Compute parity as determinant of reflection matrix\n        float parity = dot(M[0], cross(M[1], M[2]));\n\n        // Base color for even/odd\n        vec3 tri_color = parity < 0.1 ? darker : lighter;\n\n        // AA\n        tri_color = mix(mid, tri_color,\n                        smoothstep(0.1, 0.006, abs(tri_dist)));\n\n        //////////////////////////////////////////////////\n\n        vec3 final_color = mix(base_color, tri_color, show_triangles);\n      \n        vec3 n = calc_normal(p);\n    \n        float nDotL = clamp(dot(n, L), 0.1, 2.0);\n\n        return k_black * final_color * (nDotL * 0.6 + 0.6);\n\n    }\n\n}\n\n//////////////////////////////////////////////////////////////////////\n\nfloat keys_to_num(float key, float default_value, float bias) {\n\n    default_value -= bias;\n\n    float hi = key_state(key, floor(default_value/2.0));\n    float lo = key_state(key+2.0/356.0, mod(default_value, 3.0));\n\n    return 3.0*hi + lo + bias;\n  \n}\n\n//////////////////////////////////////////////////////////////////////\n\nvec4 choose_shape(float index) {\n\n    if (index < 1.0) {\n        return WS_TET;\n    } else if (index < 2.0) {\n        return WS_OCT;\n    } else if (index < 3.0) {\n        return WS_CUBE;\n    } else if (index < 4.0) {\n        return WS_IKE;\n    } else if (index < 5.0) {\n        return WS_DOE;\n    } else if (index < 6.0) {\n        return WS_CO;\n    } else if (index < 7.0) {\n        return WS_ID;\n    } else if (index < 8.0) {\n        return WS_TUT;\n    } else if (index < 9.0) {\n        return WS_TOE;\n    } else if (index < 10.0) {\n        return WS_TIC;\n    } else if (index < 11.0) {\n        return WS_TI;\n    } else if (index < 12.0) {\n        return WS_TID;\n    } else if (index < 13.0) {\n        return WS_SIRCO;\n    } else if (index < 14.0) {\n        return WS_SRID;\n    } else if (index < 15.0) {\n        return WS_GIRCO;\n    } else {\n        return WS_GRID;\n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n\nfloat font2d_dist(vec2 tpos, float size, vec2 offset) {\n\n    float scl = 0.63/size;\n    vec2 uv = tpos*scl;\n    vec2 font_uv = (uv+vec2(0.3, 0.2)+offset)*(1.0/16.0);\n    \n    float k = texture(iChannel1, font_uv, -100.0).w + 1e-6;\n    \n    vec2 box = abs(uv-vec2(0.2, 0.3))-0.5;\n        \n    return max(k-127.0/255.0, max(box.x, box.y))/scl;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n\nvec2 label_symbol(vec2 text_pos, float text_size) {\n    \n    float d = farval;\n    \n    for (int i=0; i<3; ++i) {\n        d = min(d, font2d_dist(text_pos, text_size, vec2(wythoff_symbol[i], 12.0)));\n        text_pos -= vec2(1.0, 0)*text_size;\n        \n        if (wythoff_symbol.w == float(i)) {\n            text_pos += vec2(0.25, 0) * text_size;\n            d = min(d, font2d_dist(text_pos, text_size, vec2(12.0, 8.0)));\n            text_pos -= vec2(0.75, 0) * text_size;\n        }      \n        \n    }\n    \n    return vec2(smoothstep(vec2(0.0), vec2(1.0), d - vec2(2.0, 0.0)));\n    \n}\n\n\n\n//////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 fragCoordText = fragCoord;\n    float reveal_mode = key_state(KEY_R, 0.0);\n    \n    demo_mode = key_state(KEY_D, demo_mode);\n    float text_size = 24.0;\n\n    if(reveal_mode > 0.0 && demo_mode == 0.0) {\n        \n        wythoff_symbol.x =     2.0 * abs( floor(2.0*fract(4.0*fragCoord.x/iResolution.x)) - floor((wythoff_symbol.x - 2.0)/2.0) ) + abs( floor(2.0*fract(8.0*fragCoord.x/iResolution.x)) - mod((wythoff_symbol.x - 2.0), 2.0) ) + 2.0;\n        wythoff_symbol.y =     2.0 * abs( floor(2.0*fract(1.0*fragCoord.x/iResolution.x)) - floor((wythoff_symbol.y - 2.0)/2.0) ) + abs( floor(2.0*fract(2.0*fragCoord.x/iResolution.x)) - mod((wythoff_symbol.y - 2.0), 2.0) ) + 2.0;\n        wythoff_symbol.z =     2.0 * abs( floor(2.0*fract(6.0*fragCoord.y/iResolution.y)) - floor((wythoff_symbol.z - 2.0)/2.0) ) + abs( floor(2.0*fract(3.0*fragCoord.y/iResolution.y)) - mod((wythoff_symbol.z - 2.0), 2.0) ) + 2.0;\n        wythoff_symbol.w = min(2.0 * abs( floor(2.0*fract(1.5*fragCoord.y/iResolution.y)) - floor((wythoff_symbol.w      )/2.0) ) + abs( floor(1.5*fract(1.0*fragCoord.y/iResolution.y)) - mod((wythoff_symbol.w      ), 2.0) ), 2.0);\n\n        fragCoordText = mod(fragCoord*3.,iResolution.xy/vec2(16,12)*3.);\n        fragCoord = mod(fragCoord*vec2(16,12),iResolution.xy)*vec2(1,16./12.);\n        fragCoord.y -= iResolution.y*.125;\n        text_size = 24.0;\n        \n\n    }\n \n    //////////////////////////////////////////////////\n    \n    float t = iTime;\n    \n    const vec3 tgt = vec3(0);\n    const vec3 cpos = vec3(1.0,1.0,1.0)*10.005;\n    const vec3 up = vec3(0, 0, 1);\n    const float fovy = 0.125;\n\n    vec2 uv = (fragCoord.xy - .5*iResolution.xy) * fovy / (iResolution.y);\n\n    vec3 rz = normalize(tgt - cpos),\n        rx = normalize(cross(rz,up)),\n        ry = cross(rx,rz);\n         \n    float thetay = t * 0.6;\n    float thetax = t * 0.3;\n\n    if (max(iMouse.x, iMouse.y) > 20.0) { \n        thetax = (iMouse.y - .5*iResolution.y) * -4.5/iResolution.y; \n        thetay = (iMouse.x - .5*iResolution.x) * 4.0/iResolution.x; \n    }\n\n    mat3 Rmouse = rot_x(thetax)*rot_y(thetay);\n    mat3 Rview = mat3(rx,ry,rz)*Rmouse;    \n    L = Rview*Rmouse*(L*Rview);\n  \n    vec3 rd = Rview*normalize(vec3(uv, 1.)),\n        ro = tgt + Rview*vec3(0,0,-length(cpos-tgt));\n\n    //////////////////////////////////////////////////\n    \n\n    if (demo_mode > 0.0) {\n\n        const float d_scale = 1.0;\n        const float d_long = 5.0;\n\n        const float t_appear = 0.5;\n        const float t_big = t_appear + d_scale;\n        const float t_poly_start = t_big + d_long;\n        const float t_poly_end = t_poly_start + 0.5;\n        const float t_color_start = t_poly_end + d_long;\n        const float t_color_end = t_color_start + 0.5;\n        const float t_shrink = t_color_end + d_long;\n        const float t_final = t_shrink + d_scale;\n        \n        float stage = floor(t / t_final);\n        float ts = mod(t, t_final);\n\n        sphericity = smoothstep(t_poly_end, t_poly_start, ts);\n\n        show_triangles = sphericity;\n        \n        color_by_face = smoothstep(t_color_start, t_color_end, ts);\n\n        scale = min(smoothstep(t_appear, t_big, ts),\n                    smoothstep(t_final, t_shrink, ts));\n        \n        float shape = mod(stage + 3.0, 16.0);\n\n        wythoff_symbol = choose_shape(shape);\n\n    } else {\n\n        color_by_face = key_state(KEY_C, color_by_face);\n        show_triangles = key_state(KEY_T, show_triangles);\n        sphericity = key_state(KEY_S, 0.0);\n    \n        if (reveal_mode == 0.0) {\n            wythoff_symbol.x = keys_to_num(KEY_1, wythoff_symbol.x, 2.0);\n            wythoff_symbol.y = keys_to_num(KEY_3, wythoff_symbol.y, 2.0);\n            wythoff_symbol.z = keys_to_num(KEY_5, wythoff_symbol.z, 2.0);\n            wythoff_symbol.w = min(keys_to_num(KEY_7, wythoff_symbol.w, 0.0), 2.0);\n        }\n\n    }\n\n    //////////////////////////////////////////////////\n    bool valid = dot(2.0/wythoff_symbol.xyz, vec3(2.0)) > 2.0;\n\n    vec3 scene_color = bg_color;\n    vec3 text_color = valid ? vec3(0) : vec3(0.8, 1, 1);\n\n    if (valid && scale > 0.0) {\n        scene_color = shade(ro, rd);\n        text_color = vec3(0);\n    }\n\n    // Composite in text\n    vec2 text_pos = fragCoordText.xy - 22.49;\n\n    vec2 k = label_symbol(text_pos, text_size);\n\n    scene_color = mix(bg_color, scene_color, k.x);\n    scene_color = mix(text_color, scene_color, k.y);\n\n    // Done!\n    fragColor = vec4(scene_color, 2.0);\n\t\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}