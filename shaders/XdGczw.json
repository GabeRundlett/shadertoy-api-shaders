{
    "Shader": {
        "info": {
            "date": "1521360341",
            "description": "A tetrahedron contains an octahedron with parallel opposite edges, and can also be inscribed uniquely in a parallelepiped sharing its vertices.\n\nMouse to move, 'o' and 'p' toggle display of octahedron and parallelepiped.",
            "flags": 17,
            "hasliked": 0,
            "id": "XdGczw",
            "likes": 10,
            "name": "Tetrahedron and Parallelepiped",
            "published": 3,
            "tags": [
                "raytrace",
                "tetrahedron",
                "parallelepiped"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 720
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Created by Matthew Arcus, 2018\n//\n// A tetrahedron contains an octahedron with parallel opposite\n// edges (between the midpoints of the edges of the tetrahedron),\n// and can also be inscribed uniquely in a parallelepiped\n// sharing its vertices. The octahedron and parallelepiped\n// are dual.\n\n// Mouse to move, 'o' and 'p' toggle display of octahedron\n// and parallelepiped.\n//\n// Raytraced spheres and cylinders, solved analytically\n//\n////////////////////////////////////////////////////////////////////////////////\n\nbool dorotate = true;\nbool dointernal = true;\nbool doexternal = true;\n\nconst float PI = 3.14159;\n\nstruct Hit {\n  float t;      // solution to p=q+t*d\n  vec3 n;       // (unnormalized) normal\n  int id;       // what was hit\n};\n\nstruct Sphere {\n  float r2;      // radius squared\n  vec3 p;       // centre\n  int id;\n};\n\nstruct Cylinder {\n  float r2;      // radius squared\n  // points s and t are end points of cylinder\n  vec3 s,t;\n  int id;\n};\n\n// Use vec2 return?\n// Solve Ax^2 + 2Bx + C = 0\nbool quadratic0(float A, float B, float C, out float x0, out float x1) {\n   float D = B*B - A*C;\n   if (D < 0.0) return false;\n   D = sqrt(D);\n   if (B < 0.0) D = -D;\n   x0 = (-B-D)/A;\n   x1 = C/(A*x0);\n   if (B < 0.0) {\n     // return smallest root first\n     float t = x0; x0 = x1; x1 = t;\n   }\n   return true;\n}\n\nbool quadratic(float A, float B, float C, out float x) {\n  float x1,x2;\n  if (!quadratic0(A,B,C,x1,x2)) return false;\n  if (x1 > 0.0) x = x1;\n  else if (x2 > 0.0) x = x2;\n  else return false;\n  return true;\n}\n\nbool intersectSphere(Sphere s, vec3 q, vec3 d, inout Hit hit) {\n  vec3 p = s.p;\n  float r2 = s.r2;\n  float c2 = dot(p,p);\n  // |q + t*d - p|^2 = r^2\n  float A = 1.0;\n  float B = dot(q-p,d);\n  float C = dot(q,q)-2.0*dot(q,p)+c2-r2;\n  float t;\n  if (!quadratic(A,B,C,t)) return false;\n  if (t < 0.0 || t >= hit.t) return false;\n  // Normal is the radial vector of sphere\n  // We normalize it later\n  hit = Hit(t, q+t*d-p, s.id);\n  return true;\n}\n\nbool cylinder(vec3 q, vec3 s, float r2, vec3 p, vec3 r, out float t, out vec3 normal) {\n  vec3 n = s-q; // Line direction\n  float k2 = dot(n,n);\n  vec3 p1 = p-q; // Move p to line space\n  float rs = dot(r,n);\n  float ps = dot(p1,n);\n  float pr = dot(p1,r);\n  float pp = dot(p1,p1);\n  float A = 1.0 - rs*rs/k2;\n  float B = pr - ps*rs/k2;\n  float C = pp - ps*ps/k2 - r2;\n  if (!quadratic(A,B,C,t)) {\n    return false;\n  } else {\n    p1 += t*r; // Final point in line space\n    float lambda = dot(p1,n)/k2;\n    if (lambda < 0.0 || lambda > 1.0) return false;\n    normal = p1-lambda*n;\n    return true;\n  }\n}\n\nbool intersectCylinder(Cylinder c, vec3 q, vec3 d, inout Hit hit) {\n  vec3 s0 = c.s;\n  vec3 s1 = c.t;\n  float r2 = c.r2;\n  float t;\n  vec3 normal;\n  if (!cylinder(s0,s1,r2,q,d,t,normal) || t >= hit.t) {\n    return false;\n  } else {\n    // Normal is the radial vector of cylinder\n    hit = Hit(t, normal, c.id);\n    return true;\n  }\n}\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  if (dorotate) {\n    float t = iTime;\n    p.zx = rotate(p.zx,t * 0.2);\n  }\n  return p;\n}\n\n// (p+P)(q+Q) = pq + pQ + qP + PQ\nvec4 qmul(vec4 p, vec4 q) {\n  vec3 P = p.xyz, Q = q.xyz;\n  return vec4(p.w*Q+q.w*P+cross(P,Q),p.w*q.w-dot(P,Q));\n}\n\nbool intersectScene(vec3 q, vec3 d, out Hit hit) {\n  vec4 A4 = vec4(1,0,0,0);\n  vec4 B4 = vec4(0,1.5,0,0);\n  vec4 C4 = vec4(0,0,1.1,0);\n  vec4 D4 = vec4(0,0,0,1.2);\n  // Quaternion, w is real part\n  float t = 0.2*iTime;\n  vec4 Q = vec4(sin(t)*vec3(1,0.618,0),cos(t));\n  A4 = qmul(A4,Q);\n  B4 = qmul(B4,Q);\n  C4 = qmul(C4,Q);\n  D4 = qmul(D4,Q);\n  vec3 A = A4.xyz;\n  vec3 B = B4.xyz;\n  vec3 C = C4.xyz;\n  vec3 D = D4.xyz;\n  {\n    // Put centroid at origin\n    vec3 X = 0.25*(A+B+C+D);\n    A -= X; B -= X; C -= X; D -= X; X -= X;\n  }\n  hit = Hit(1e8,vec3(0),0);\n  float s2 = 0.04*0.04;\n  float c2 = 0.015*0.015;\n  // Draw centroid at origin\n  if (dointernal) intersectSphere(Sphere(s2,vec3(0),1),q,d,hit);\n  vec3 points[4];\n    points[0] = A;\n    points[1] = B;\n    points[2] = C;\n    points[3] = D;\n  for (int i = 0; i < 4; i++) {\n    vec3 X = points[i];\n    intersectSphere(Sphere(s2,X,0),q,d,hit);\n#if __VERSION__ < 300\n      // My phone miscompiles this version\n    for (int j = 0; j < 4; j++) {\n      if (j <= i) continue; // WebGL 1.0\n#else\n    for (int j = i+1; j < 4; j++) {\n#endif\n      vec3 Y = points[j];\n      intersectCylinder(Cylinder(c2,X,Y,1),q,d,hit);\n      if (dointernal) {\n        vec3 XY = 0.5*(X+Y);\n        intersectSphere(Sphere(s2,XY,2),q,d,hit);\n        for (int k = 0; k < 4; k++) {\n          if (k == i || k == j) continue;\n          // The lines on the faces between edge midpoints\n          // These assemble into an octahedron\n          vec3 Z = points[k];\n          vec3 XZ = 0.5*(X+Z);\n          vec3 YZ = 0.5*(Y+Z);\n          intersectCylinder(Cylinder(c2,XY,XZ,4),q,d,hit);\n          intersectCylinder(Cylinder(c2,XY,YZ,4),q,d,hit);\n        }\n      }\n    }\n  }\n  // The diagonals\n  if (dointernal) {\n    intersectCylinder(Cylinder(c2,0.5*(A+B),0.5*(C+D),3),q,d,hit);\n    intersectCylinder(Cylinder(c2,0.5*(A+C),0.5*(B+D),3),q,d,hit);\n    intersectCylinder(Cylinder(c2,0.5*(A+D),0.5*(B+C),3),q,d,hit);\n  }\n\n  if (doexternal) {\n    // The containing parallelepiped. Just invert the points in\n    // the origin (which is the centroid).\n    for (int i = 0; i < 4; i++) {\n      vec3 X = -points[i];\n      intersectSphere(Sphere(s2,X,1),q,d,hit);\n      for (int j = 0; j < 4; j++) {\n        if (i == j) continue;\n        vec3 Y = points[j];\n        intersectCylinder(Cylinder(c2,X,Y,3),q,d,hit);\n      }\n    }\n  }\n  return hit.t < 1e8;\n}\n\nvec3 light;\nfloat ambient;\nfloat diffuse;\n\nvec3 getColor(int i) {\n  if (i == 0) return vec3(1,0,0);\n  if (i == 1) return vec3(1,1,0);\n  if (i == 2) return vec3(0,1,0);\n  if (i == 3) return vec3(0,0,1);\n  if (i == 4) return vec3(0,1,1);\n  return vec3(1,1,1);\n}\n\nvec4 solve(vec3 q, vec3 d) {\n  Hit hit;\n  if (!intersectScene(q,d,hit)) {\n    return vec4(0,0,0,1);\n  } else {\n    vec3 n = normalize(hit.n);\n    if (dot(d,n) > 0.0) n *= -1.0;\n    vec3 baseColor = 0.7*getColor(hit.id);\n    vec3 color = baseColor.xyz*(ambient+diffuse*max(0.0,dot(light,n)));\n    float specular = pow(max(0.0,dot(reflect(light,n),d)),2.0);\n    color += 0.5*specular*vec3(1.0,1.0,1.0);\n    color *= clamp(1.0 - (hit.t-3.0)/5.0,0.0,1.0);\n    return vec4(sqrt(color),1.0);\n  }\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord,\n             vec3 fragRayOrigin, vec3 fragRayDir) {\n  float t = 0.5*iTime;\n  light = normalize(vec3(0.5,1.0,-1.0));\n  ambient = 0.5;\n  diffuse = 1.0-ambient;\n  fragColor = solve(fragRayOrigin,fragRayDir);\n}\n\n\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_R = 82;\n\nbool keypress(int key) {\n#if __VERSION__ < 300\n  return false;\n#else\n  return texelFetch(iChannel0, ivec2(key,2),0).x != 0.0;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  dointernal = !keypress(CHAR_O);\n  doexternal = !keypress(CHAR_P);\n  vec2 uv = 2.0*fragCoord.xy/iResolution.xy - 1.0;\n  vec3 p = vec3(0,0,-4.0);\n  // \"screen\" coordinate\n  vec3 s = 0.8*vec3(iResolution.x/iResolution.y * uv.x, uv.y, 0);\n  vec3 d = s-p; // Direction from camera to screen point\n  p = transform(p);\n  d = transform(d);// normalize after rotation!\n  d = normalize(d);\n  mainVR(fragColor,fragCoord,p,d);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}