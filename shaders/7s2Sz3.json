{
    "Shader": {
        "info": {
            "date": "1622807302",
            "description": "I was inspired by cyberpunk2077 :)",
            "flags": 96,
            "hasliked": 0,
            "id": "7s2Sz3",
            "likes": 21,
            "name": "Cyberfish",
            "published": 3,
            "tags": [
                "lights",
                "cyberpunk",
                "zefzefafish"
            ],
            "usePreview": 0,
            "username": "z0rg",
            "viewed": 958
        },
        "renderpass": [
            {
                "code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec3 doBloom(vec2 uv, float blur, float threshold)\n{\n    vec3 col;\n    int cnt = 10;\n    float fcnt = float(cnt);\n    for (int i = 0;i <cnt;++i)\n    {\n        float fi = float(i);\n        float coef = (fi/fcnt);\n        float sz = 1.+pow(coef,2.)*blur;\n        float samplePerTurn = 3.;\n        float an = (fi/(fcnt/samplePerTurn))*PI;\n        vec2 p = uv - vec2(sin(an), cos(an))*(fi/fcnt)*blur*.1;\n        vec3 smple = texture(iChannel0, p).xyz;\n        if (length(smple) > threshold)\n            col += smple;\n    \t\n        \n    }\n    \n    return col/float(cnt);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    float bloomIntensity =204./640.;  \n    vec3 bloomSample = doBloom(uv, 70./360., 337./ 640.);\n    bloomSample = pow(bloomSample, vec3(0.5));\n    \n    col = col + (bloomSample*bloomIntensity);\n    \n    col = pow(col, vec3(1.2));\n    \n    col *= 1.-sat((length(cuv)-.25)*3.);\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "musicstream",
                        "id": 27360,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/centroidband/uncharted-worlds-1"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat _time;\n\nfloat smin( float a, float b, float k ) { // Thanks IQ\n float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(max(l.x, l.y), l.z);\n}\n\nvec2 fish(vec3 p)\n{\nvec3 op = p;\n    p*= .5;\n    p.y += sin(p.x+_time*.25)*0.15-.1;\n    p.xz *= r2d(sin(_time*2.+p.x*3.)*.3);\n    p -= vec3(0.,-.3,0.);\n    p.xy *= mix(1.,.985,sat(sin((p.x)*100.+_time*5.)*.5+.5));\n    float acc = 100.;\n    \n    acc = min(acc, length(p*vec3(1.,2.,3.))-.25);\n    acc = smin(acc, length(p*vec3(1.,2.,3.)-vec3(-0.25,.0,0.))-.17, .1);\n    \n    vec3 pail = p;\n    pail.yz *= r2d(.15*sign(pail.z*2.)*sin(_time));\n    acc = min(acc, max(abs(pail.y-.06)-0.001, (length(pail*vec3(3.,1.,1.)-vec3(.1,0.,0.))-.25)));\n    \n    \n    vec3 ptail = p*vec3(1.,sign(p.y),1.);\n    ptail -=  vec3(-.5,0.05,0.);\n    ptail.xy *= r2d(.7);\n    ptail.z -= sat(10.*-ptail.x)*sin(ptail.y*200.)*.005;\n    \n    acc = smin(acc, max(abs(ptail.z)-0.001, length(ptail*vec3(1.,2.,1.))-.125), .05);\n    vec3 peye = p-vec3(0.15,-0.03,0);\n    peye.z = abs(peye.z)-.05;\n    acc = min(acc, length(peye)-.03);\n   \n\n    return vec2(acc, 0.);\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 fish = vec2(fish(p).x, 0.); \n\n    float repx = 3.;\n    vec3 pbat = p-vec3(-_time,0.,-.5);\n    pbat.x = mod(pbat.x+repx*.5, repx)-repx*.5;\n    \n    float widthCol = .1;\n    vec2 closeBat = vec2(min(_cube(pbat, vec3(widthCol,2.,widthCol)), _cube(p-vec3(0.,.5, -5.), vec3(5., .1, 4.))), 1.);\n    \n    vec2 farBat = vec2(_cube(p-vec3(0.,0.,5.), vec3(15., 5., 1.)), 2.);\n    \n    return _min(_min(closeBat, fish), farBat);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 1.;\n    vec3 r = normalize(cross(rd, vec3(0., 1., 0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+(r*uv.x+u*uv.y)*fov);\n}\n\nvec3 getNormal(vec3 p, float d)\n{\n    vec2 e = vec2(0.01, 0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\n\n\nvec3 _accMarch;\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 res = vec3(-1.);\n    \n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n        {\n            return vec3(res.x, distance(p, ro), res.y);\n        }\n        p += rd*res.x*.15;\n        if (res.y == 0.)\n            _accMarch += .03*vec3(1.)*(1.-sat(res.x/.2));\n    }\n    \n    return res;\n}\n\nfloat mapRoom(vec3 p)\n{\n    p -= vec3(-iTime,0.,0.);\n    vec3 rep = vec3(2.,2.,5.);\n    p = mod(p+rep*.5,rep)-rep*.5;\n    \n    return min(-_cube(p, rep*.45), _cube(p-vec3(0.,.8,0.), vec3(.3,.1,1.)));\n}\nvec3 getNormalRoom(vec3 p, float d)\n{\n    vec2 e = vec2(0.01, 0.);\n    return normalize(vec3(d)-vec3(mapRoom(p-e.xyy), mapRoom(p-e.yxy), mapRoom(p-e.yyx)));\n}\nvec3 rdrRoom(vec3 ro, vec3 rd)\n{\n    vec3 p = ro;\n    for (int i = 0; i < 20; ++i)\n    {\n    \n        float res = mapRoom(p);\n        if (res < 0.01)\n        {\n\n            \n            vec3 n = getNormalRoom(p, res);\n            \n            float dist = distance(p, ro);\n            \n            p -= vec3(-_time,0.,0.);\n            vec3 rep = vec3(2.,2.,5.);\n            vec3 id = floor((p+rep*.5)/rep);\n            p = mod(p+rep*.5,rep)-rep*.5;\n            \n            vec3 lpos = vec3(0.,-.75,1.);\n            vec3 ldir = lpos-p;\n            vec3 ambient = vec3(0.051,0.051,0.071);\n            return ambient+8.*pow(texture(iChannel1, id.xy*.1).x,5.)*mix(vec3(0.886,0.737,0.412), texture(iChannel2, id.xy*.05).xyz,.5)*sat(dot(ldir, n))*(1.-sat(length(ldir)/2.));\n        }\n        p += rd*res;\n\n    }\n    \n    return vec3(0.);\n}\n\nvec3 rdrHolo(vec2 uv)\n{\n    vec2 rep = vec2(.2);\n \n     vec2 id = floor((uv+rep*.5)/rep);\n    uv = mod(uv+rep*.5,rep)-rep*.5;\n    vec2 l = abs(uv)-rep*.25;\n    \n    vec3 rgb = vec3(0.);\n    \n    rgb = mix(rgb, vec3(0.141,0.557,1.000), sat(sin((id.x+id.y)*.1+_time))-.5);\n    rgb += vec3(1.000,0.396,0.141)*sat(sin((id.x-id.y)*1.+_time*2.)+sin(id.x));\n    \n    vec2 repid = vec2(40.,20);\n    vec2 idscreen = floor((id+repid*.5)/repid);\n    id = mod(id+repid*.5,repid)-repid*.75;\n    \n    vec2 screenl = abs(id)-repid*.4;\n    float screen = max(screenl.x, screenl.y);\n    \n    rgb *= (1.-sat(screen*400.));\n    \n    if (mod(idscreen.x+idscreen.y, 2.0) < 0.1)\n        rgb = rgb.zxy;\n    \n    return sat(rgb)*(1.-sat(max(l.x, l.y)*400.))*5.;\n}\n\nvec3 material(vec3 trace, vec3 ro, vec3 rd, vec3 p, vec3 n, vec2 uv)\n{\n    vec3 col = vec3(0.051,0.051,0.071);\n    //col = n*.5+.5;\n    if (trace.z == 2.)\n    {\n        col = p;\n        col = rdrRoom(p, normalize(rd+(texture(iChannel1, uv*4.).xxx-.5)*.1));\n        col += rdrHolo(p.xy-vec2(-_time,0.));\n    }\n    if (trace.z == 0.)\n    {\n        col += vec3(0.976,0.243,0.388)*pow(sat(dot(n, normalize(vec3(-1.)))),7.);\n        col += vec3(0.976,0.427,0.243)*(1.-pow(sat(-dot(n, rd)),2.));\n    }\n    return col;\n}\n\n\n\nvec3 rdr(vec2 uv, vec2 ouv)\n{\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(2.,0.,-3.);\n    vec3 ta = vec3(sin(_time*.5)*.1,sin(_time*.5+.5)*.1,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    vec3 res = trace(ro, rd, 300);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNormal(p, res.x);\n        //l = n*.5+.5;\n        //if (res.z == 0. || res.z == 2.)\n        {\n            col = material(res, ro, rd, p, n, uv);            \n        }\n        if (res.z == 1. || res.z == 2.)\n        {\n            vec3 reflro = p+n*0.01;\n            float spec = 0.5;\n            if (res.z == 2.)\n            {\n                float glassfreq = 20.;\n                float glassSep = .9;\n                float glassMult = 1.;\n                float normMult = .75;\n                n += normalize(n+normMult*vec3(sat((sin((p.x+_time)*glassfreq)-glassSep)*glassMult), sat((sin((p.y)*glassfreq)-glassSep)*glassMult), 0.));\n                spec = 0.1;\n                \n                float rain = texture(iChannel1, (uv*r2d(-.25)*vec2(4.,.5)+vec2(0., mod(iTime,10.)))).x;\n                col += pow(rain,15.)*vec3(800./iResolution.x);\n    \n                float rainB = texture(iChannel1, (uv*r2d(-.1)*vec2(4.,.25)*2.+vec2(0., mod(iTime*1.2,10.)))).x;\n                col += pow(rainB,7.)*vec3(800./iResolution.x);\n            }\n\n            \n            vec3 acc = vec3(0.);\n            for (int ir = 0; ir < 1; ++ir)\n            {\n                        vec3 refl = normalize(reflect(rd, n));\n                vec3 resrefl = trace(reflro, normalize(refl+(texture(iChannel1, vec2(float(ir)*0.1,float(ir)*.2)+uv*20.+mod(_time*0.1,100.)).xxx-.5)*spec), 256);\n                if (resrefl.y > 0.)\n                {\n                    vec3 reflp = reflro+refl*resrefl.y;\n                    vec3 refln = getNormal(reflp, resrefl.x);\n                    acc += .15* material(resrefl, reflro, refl, reflp, refln, uv);\n                    acc += dFdx(acc)*.5;\n                    acc += dFdy(acc)*.5;\n    \n                }\n                acc += .5*pow(texture(iChannel0, refl).xyz,vec3(1.))*.5+vec3(0.024,0.094,0.118)*.3;\n\n            }\n            col += acc;\n        }\n    }\n    col += _accMarch*vec3(0.976,0.243,0.388);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    _time = iTime+texture(iChannel3, fragCoord/8.).x*.075;\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n    vec3 col = rdr(uv, fragCoord/iResolution.xy);\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n#define nsat(a) clamp(a, -1., 1.)\n#define PI 3.14159265\n\nmat2 r2d(float a) { float c= cos(a), s = sin(a); return mat2(c, -s, s, c); }\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec3 rdrWaterDroplets(vec2 ouv, vec2 cuv)\n{\n    vec3 col = texture(iChannel0, ouv).xyz;\n    float mapA = -.5+(texture(iChannel1, cuv*.2+vec2(0., iTime*.005)).x*texture(iChannel1, cuv*.3).x);\n    mapA = pow(mapA, .5);\n    col = mapA*vec3(1.);\n    \n    vec2 off = sat(vec2(dFdx(mapA), dFdy(mapA))*5.);\n    \n    col = mix(texture(iChannel0, ouv).xyz, texture(iChannel0, (ouv-off)).xyz, (1.-sat(length(off*2.))));\n    \n    return col;\n}\n\nvec3 rdr(vec2 uv, vec2 cuv)\n{\n    vec3 col = rdrWaterDroplets(uv, cuv);\n    \n    { // Not so cheap antialiasing SSAA x4\n        //col = vec3(1.,0.,0.); // debug\n        vec2 off = vec2(1., -1.)/(iResolution.x*1.);\n        vec3 acc = col;\n        // To avoid too regular pattern yielding aliasing artifacts\n        mat2 rot = r2d(uv.y*5.); // a bit of value tweaking, appears to be working well\n        acc += rdrWaterDroplets(uv, cuv-off.xx);\n        acc += rdrWaterDroplets(uv, cuv-off.xy);\n        acc += rdrWaterDroplets(uv, cuv-off.yy);\n        acc += rdrWaterDroplets(uv, cuv-off.yx);\n        col = acc/5.;\n    }\n\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    \n    vec3 col = rdr(uv, cuv*2.);\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}