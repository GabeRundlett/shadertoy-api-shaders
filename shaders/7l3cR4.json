{
    "Shader": {
        "info": {
            "date": "1659394644",
            "description": "* Click to stop the demo and take control!\n* Double click on the toolbar to select wall presets, change palettes, delete walls and delete everything.\n* Space to restart demo.\n* Shift to disable anti-aliasing.",
            "flags": 48,
            "hasliked": 0,
            "id": "7l3cR4",
            "likes": 12,
            "name": "Rainbow Sand Playground 2",
            "published": 3,
            "tags": [
                "2d",
                "simulation",
                "antialiasing",
                "particles",
                "sand"
            ],
            "usePreview": 1,
            "username": "fenix",
            "viewed": 418
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Particles are capable of falling or sliding down a slope greater than 45 degrees. \n//  Particle motion is performed within 2x2 cells. Buffer A's cells are in a natural\n//  alignment: cell 0, 0 includes the four cells (0 ... 1, 0 ... 1). Buffer B is offset\n//  by 1, 1 so it can advect particles across buffer A's cell boundaries. Buffers C and D\n//  are just copies of A and B respectively to get twice the integration speed.\n//\n//  v2: added auto-scroll based on deleting bottom row, removed horizontal black lines,\n//      mouse function determined by clicked region\n//  v3: better auto-scroll, new auto-spawner animation\n//\n//  \"playground\" v1: all the things\n//   * doubled pixels to increase activity at higher resolutions\n//   * added content-aware antialiasing to combat resultant blockiness\n//   * added walls\n//   * tool bar allowing selection of particlar colors, wall, and erase functions\n//   * selectable color palettes\n//   * noise added to particle color\n//   * double click detection\n//   * wall presets\n//   * \"sky\" instead of black void\n//\n//   \"playground\" v2: added attract mode, more palettes\n//\n// ---------------------------------------------------------------------------------------\n\n#define DISABLE_ANTIALIASING 0\n\nvec4 getPixel(ivec2 ifc)\n{\n    // to eliminate gaps as particles fall, combine neighboring pixels vertically for rendering\n    vec4 top = texelFetch(iChannel0, ivec2(ifc.x / 4, (ifc.y / 2) & ~1), 0);\n    vec4 bottom = texelFetch(iChannel0, ivec2(ifc.x / 4, (ifc.y / 2) | 1), 0);\n    return top == EMPTY ? bottom : top;\n}\n\n// are these colors different enough to apply anti-aliasing? (so that we blur only edges, not sand particles)\nfloat distantColor(vec4 a, vec4 b)\n{\n    // w component is sand type id\n    return floor(a.w) != floor(b.w) ? 1.0 : 0.0;\n}\n\nvec4 addSky(vec4 x, vec2 uv)\n{\n    if (x != EMPTY) return x;\n    \n    return mix(vec4(0.8, 0.8, 0.8, 1.0), vec4(0.0, 0.0, uv.y * 0.8, 1.0), sqrt(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord.x = fragCoord.x * (iResolution.x / (iResolution.x + 8.0)) + 4.0;\n    ivec2 ifc = ivec2(fragCoord);\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 origPixel = getPixel(ifc);\n    vec4 pixel = origPixel;\n    \n#if !DISABLE_ANTIALIASING\n    vec4 above = getPixel(ifc + ivec2(0, 2));\n    vec4 below = getPixel(ifc + ivec2(0, -2));\n    vec4 left = getPixel(ifc + ivec2(-4, 0));\n    vec4 right = getPixel(ifc + ivec2(4, 0));\n\n    float ulDist = distantColor(above, left);\n    float urDist = distantColor(above, right);\n    float llDist = distantColor(below, left);\n    float lrDist = distantColor(below, right);\n    float distAbove = distantColor(above, pixel);\n    float distBelow = distantColor(below, pixel);\n    float distLeft = distantColor(left, pixel);\n    float distRight = distantColor(right, pixel);\n#endif\n    \n    const float DIST_THRESHOLD = 0.1;\n    \n#if !DISABLE_ANTIALIASING\n    fragColor = addSky(pixel, uv);\n    vec2 subCell = mod(fragCoord, vec2(4.0, 4.0));\n    if (ulDist + lrDist < urDist + llDist && ulDist + lrDist < 0.5)\n    {\n        // we can create a smooth diagonal line from ll to ur\n        if (distAbove > distBelow && distAbove > 0.1)\n        {\n            float aa = smoothstep(0.2, 0.8, (4.0 + subCell.x - subCell.y) / 4.0);\n            fragColor = mix(addSky(mix(above, left, 0.5), uv), addSky(pixel, uv), aa);\n        }\n        else if (distBelow > 0.1)\n        {\n            float aa = smoothstep(0.2, 0.8, (4.0 - subCell.x + subCell.y) / 4.0);\n            fragColor = mix(addSky(mix(below, right, 0.5), uv), addSky(pixel, uv), aa);\n        }\n    }\n    else if (urDist + llDist < 0.5)\n    {\n        // we can create a smooth diagonal line from ul to lr\n        if (distAbove > distBelow && distAbove > 0.1)\n        {\n            float aa = smoothstep(0.2, 0.8, (8.0 - subCell.x - subCell.y) / 4.0);\n            fragColor = mix(addSky(mix(above, right, 0.5), uv), addSky(pixel, uv), aa);\n        }\n        else if (distBelow > 0.1)\n        {\n            float aa = smoothstep(0.2, 0.8, (subCell.x + subCell.y) / 4.0);\n            fragColor = mix(addSky(mix(below, left, 0.5), uv), addSky(pixel, uv), aa);\n        }\n    }\n    else\n#endif\n    {\n        fragColor = addSky(pixel, uv);\n    }\n    \n    // (debug) disable antialiasing\n    bool disableAa = texelFetch(iChannel3,ivec2(KEY_SHIFT,0),0).x > 0.0;\n    if (disableAa) fragColor = addSky(pixel, uv);\n    \n    // draw UI\n    vec4 state = texelFetch(iChannel0, ivec2(0), 0);\n    bool idle = state.w == FLT_MAX;\n\n    float selection = state.z;\n    int pallette = int(state.y);\n    if (!idle && fragCoord.y > iResolution.y * 0.9)\n    {\n        float u = fragCoord.x / iResolution.x;\n        u *= SELECT_CHOICES;\n        \n        // anti-aliasing for UI (also creates curve for selection)\n        float alpha = clamp(fragCoord.y - (iResolution.y * (0.95 - smoothstep(0.0, 0.2, abs(u - round(u))) * 0.025)), 0.0, 1.0);\n        if (disableAa) alpha = floor(alpha);\n        \n        if (fragCoord.y > iResolution.y * 0.95 ||\n            (floor(u) == selection && alpha > 0.0))\n        {\n            vec4 uiColor;\n            if (u < S_RAINBOW)\n            {\n                // specific colors\n                uiColor = rainbow(int(u), pallette);\n            }\n            else if (u < S_WALL)\n            {\n                // color cycle (rainbow)\n                uiColor = colorByFrame(int(fragCoord.x / (iResolution.x * 0.02) * float(COLOR_CHANGE_FRAMES)), pallette);\n            }\n            else if (u < S_ERASE)\n            {\n                // walls\n                uiColor = vec4(1);\n            }\n            else\n            {\n                // eraser\n                uiColor = vec4(0);\n            }\n            fragColor = mix(fragColor, uiColor, alpha);\n        }\n    }    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bufferMain(fragColor, fragCoord, ivec2(0));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// options\nconst float WALL_SIZE = 0.0025;\nconst float SPAWN_SIZE = 0.005;\nconst int COLOR_CHANGE_FRAMES = 100;\n\n// tool bar selections\n// 0 ... 6 are the specific color selections\n#define S_RAINBOW 7.0\n#define S_WALL 8.0\n#define S_ERASE 9.0\n#define SELECT_CHOICES 10.0\n\n// special pixel values\nconst vec4 EMPTY = vec4(0);\nconst vec4 WALL = vec4(1);\n\nfloat length2(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat square(float x)\n{\n    return x * x;\n}\n\nconst int NUM_PALETTES = 6;\n\nvec4 rainbow(int i, int palette)\n{\n    switch(palette)\n    {\n        case 0: // actual rainbow\n            switch(i)\n            {\n                case 0: return vec4(1.0, 0.0, 0.0, 2.0);\n                case 1: return vec4(1.0, 0.5, 0.0, 3.0);\n                case 2: return vec4(1.0, 1.0, 0.0, 4.0);\n                case 3: return vec4(0.0, 1.0, 0.0, 5.0);\n                case 4: return vec4(0.0, 0.0, 1.0, 6.0);\n                case 5: return vec4(0.25, 0.0, 0.5, 7.0);\n                case 6: return vec4(0.5, 0.0, 0.7, 8.0);\n            }\n        case 1: // grey scale w/ red\n            switch(i)\n            {\n                case 0: return vec4(0.1, 0.1, 0.1, 9.0);\n                case 1: return vec4(0.25, 0.25, 0.25, 10.0);\n                case 2: return vec4(0.4, 0.4, 0.4, 11.0);\n                case 3: return vec4(0.55, 0.55, 0.55, 12.0);\n                case 4: return vec4(0.75, 0.75, 0.75, 13.0);\n                case 5: return vec4(0.99, 0.99, 0.99, 14.0);\n                case 6: return vec4(1.0, 0.0, 0.0, 15.0);\n            }\n        case 2: // pastel rainbow\n            switch(i)\n            {\n                case 0: return vec4(255.0 / 256.0, 102.0 / 256.0, 99.0 / 256.0, 16.0);\n                case 1: return vec4(254.0 / 256.0, 177.0 / 256.0, 68.0 / 256.0, 17.0);\n                case 2: return vec4(253.0 / 256.0, 253.0 / 256.0, 151.0 / 256.0, 18.0);\n                case 3: return vec4(158.0 / 256.0, 224.0 / 256.0, 158.0 / 256.0, 19.0);\n                case 4: return vec4(158.0 / 256.0, 193.0 / 256.0, 207.0 / 256.0, 20.0);\n                case 5: return vec4(174.0 / 256.0, 153.0 / 256.0, 231.0 / 256.0, 21.0);\n                case 6: return vec4(204.0 / 256.0, 153.0 / 256.0, 201.0 / 256.0, 22.0);\n            }\n        case 3: // natural colors (draw a mountain scene!)\n            switch(i)\n            {\n                case 0: return vec4(222.0 / 256.0, 204.0 / 256.0, 166.0 / 256.0, 23.0);\n                case 1: return vec4(164.0 / 256.0, 167.0 / 256.0, 38.0 / 256.0, 24.0);\n                case 2: return vec4(25.0 / 256.0, 121.0 / 256.0, 39.0 / 256.0, 25.0);\n                case 3: return vec4(100.0 / 256.0, 100.0 / 256.0, 110.0 / 256.0, 26.0);\n                case 4: return vec4(112.0 / 256.0, 100.0 / 256.0, 84.0 / 256.0, 27.0);\n                case 5: return vec4(148.0 / 256.0, 91.0 / 256.0, 20.0 / 256.0, 28.0);\n                case 6: return vec4(56.0 / 256.0, 29.0 / 256.0, 10.0 / 256.0, 29.0);\n            }\n        case 4: // tiger stripes\n            switch(i)\n            {\n                case 0: return vec4(1.0, 0.5, 0.1, 30.0);\n                case 1: return vec4(0.1, 0.1, 0.1, 31.0);\n                case 2: return vec4(1.0, 0.5, 0.1, 30.0);\n                case 3: return vec4(0.1, 0.1, 0.1, 31.0);\n                case 4: return vec4(1.0, 0.5, 0.1, 30.0);\n                case 5: return vec4(0.1, 0.1, 0.1, 31.0);\n                case 6: return vec4(1.0, 0.5, 0.1, 30.0);\n            }\n        case 5: // boys n girls\n            switch(i)\n            {\n                case 0: return vec4(0.4, 0.4, 0.4, 32.0);\n                case 1: return vec4(0.70, 0.202, 0.706, 33.0);\n                case 2: return vec4(1.0, 0.412, 0.706, 34.0);\n                case 3: return vec4(0.55, 0.55, 0.55, 35.0);\n                case 4: return vec4(0.75, 0.75, 0.75, 36.0);\n                case 5: return vec4(0.3, 0.4, 1.0, 37.0);\n                case 6: return vec4(0.2, 0.5, 1.0, 38.0);\n            }\n    }    \n}\n\nvec4 colorByFrame(int frame, int palette)\n{   \n    // compute the current color for the color-cycling rainbow spawn selection\n    int colorIndex = (frame / COLOR_CHANGE_FRAMES) % 7;\n    int nextColorIndex = (colorIndex + 1) % 7;\n    int blendIndex = frame % COLOR_CHANGE_FRAMES;\n    float blend = float(blendIndex) / float(COLOR_CHANGE_FRAMES);\n    return mix(rainbow(colorIndex, palette), rainbow(nextColorIndex, palette), blend);\n}\n\nfloat hash( int k )\n{\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nfloat linePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord, in vec3 res)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // find the closest point on the line segment from old to new\n    vec2 closest;\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        // line was very short anyway\n        closest = oldPos;\n    }\n\n    // distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    closestDelta *= res.xy / res.y;\n    return length2(closestDelta);\n}\n\nfloat dist2hopper(vec2 fragCoord, vec3 res, vec2 pos, vec2 dim, float opening)\n{\n    float dist2 =      linePointDist2(vec2(pos.x - dim.x, pos.y) * res.xy, vec2(pos.x - dim.x, pos.y + dim.y) * res.xy, fragCoord, res);\n    dist2 = min(dist2, linePointDist2(vec2(pos.x + dim.x, pos.y) * res.xy, vec2(pos.x + dim.x, pos.y + dim.y) * res.xy, fragCoord, res));\n    dist2 = min(dist2, linePointDist2(vec2(pos.x + dim.x, pos.y) * res.xy, vec2(pos.x + opening, pos.y) * res.xy, fragCoord, res));\n    dist2 = min(dist2, linePointDist2(vec2(pos.x - dim.x, pos.y) * res.xy, vec2(pos.x - opening, pos.y) * res.xy, fragCoord, res));\n    return dist2;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb )\n{\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\n#define rnd( x)    fract(1000.*sin(345.2345*x))\n#define id( x,y)   floor(x)+100.*floor(y)\n\n// from maze 2 by FabriceNeyret2\n// https://www.shadertoy.com/view/4sSXWR\nfloat maze(vec2 u) {\n    float n = id(u.x,u.y);  u = fract(u);\n    return 1.-smoothstep(.1,.15,((rnd(n)>.5)?u.x:u.y));\n}\n\n// from Exercise: basic truchet tiling by endymion\n// https://www.shadertoy.com/view/WlcfWf\nfloat truchet(in vec3 res, in int frame, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - 0.5 * res.xy) / res.y;\n    \n    // Zoom;\n    float scale = 10.0;\n    uv *= scale; \n    \n    // Tiles from -.5 to .5\n    vec2 gv = fract(uv) - .5;\n    \n    // Rotate\n    vec2 id = floor(uv);\n    float r = hash(int(id.x + 37.5 * id.y + 9.0 * float(frame)));\n    if (r < .5) gv.x *= -1.;\n    \n    // Curves\n    float sgn = sign(gv.x + gv.y);\n    sgn = sgn == 0. ? 1. : sgn;\n    float dist = abs(abs(gv.x + gv.y) - .5);\n    dist = length(gv - sgn * .5) - .5;\n    float width = 0.002 * scale;\n    return smoothstep(scale/res.y, -scale/res.y, abs(dist) - width);\n}\n\nvoid handleDoubleClick(float selection, vec2 fc, vec3 res, int iFrame, inout vec4 fragColor)\n{\n    bool shouldBeWall = false;\n    float dist2 = 1e6;\n    float dist = 1e6;\n    \n    // wall scenes you can select by double clicking on the specific color tabs\n    switch(int(selection))\n    {\n        case 0:\n            // big V\n            fc.x = abs(fc.x - res.x * 0.125) + res.x * 0.125;\n            dist2 = linePointDist2(vec2(0.13, 0.1) * res.xy, vec2(0.215, 0.4) * res.xy, fc, res);\n            shouldBeWall = dist2 < square(res.x * WALL_SIZE);\n\n            break;\n            \n        case 1:\n            // cascading hoppers\n            fc.x = res.x * 0.125 - abs(fc.x - res.x * 0.125);\n            dist2 =            dist2hopper(fc, res, vec2(0.035, 0.35), vec2(0.025, 0.05), 0.003);\n            dist2 = min(dist2, dist2hopper(fc, res, vec2(0.055, 0.25), vec2(0.025, 0.05), 0.003));\n            dist2 = min(dist2, dist2hopper(fc, res, vec2(0.075, 0.15), vec2(0.025, 0.05), 0.003));\n            dist2 = min(dist2, dist2hopper(fc, res, vec2(0.125, 0.05), vec2(0.06, 0.05), 0.003));\n            shouldBeWall = dist2 < square(res.x * WALL_SIZE);\n\n            break;\n            \n        case 2:\n            // horizontal lines\n            const float HEIGHT = 0.1;\n            fc.x = abs(fc.x - res.x * 0.125) + res.x * 0.125;\n            fc.y = mod(fc.y + res.x * 0.01, res.x * HEIGHT * 1.25);\n            dist2 = linePointDist2(vec2(0.1, HEIGHT) * res.xy, vec2(0.15, HEIGHT) * res.xy, fc, res);\n            dist2 = min(dist2, linePointDist2(vec2(0.175, HEIGHT) * res.xy, vec2(0.225, HEIGHT) * res.xy, fc, res));\n            dist2 = min(dist2, linePointDist2(vec2(0.2, HEIGHT + HEIGHT) * res.xy, vec2(0.1375, HEIGHT + HEIGHT) * res.xy, fc, res));\n            shouldBeWall = dist2 < square(res.x * WALL_SIZE);\n\n            break;\n\n        case 3:\n            // maze       \n            fc.x += mod(float(iFrame % 1000) * 10.0, res.x * 10.0);\n            const float MAZE_SCALE = 1.6;\n            dist = maze(MAZE_SCALE * vec2(square(res.x / res.y), 1.0)*fc/(res.xy * 0.125));\n            shouldBeWall = dist > 0.060 * res.x * WALL_SIZE;\n\n            break;\n                        \n        case 4:\n            // bowls\n            fc.x = abs(fc.x - res.x * 0.125) + res.x * 0.125;\n            fc.y = res.y * 0.125 - fc.y;\n            const float theta = 2.0;\n            const vec2 sc = vec2(sin(theta), cos(theta));\n            dist = sdArc((fc / res.x) - vec2(0.2, 0.0), sc, 0.02, 0.0);\n            dist = min(dist, sdArc((fc / res.x) - vec2(0.15, -0.14), sc, 0.02, 0.0));\n            dist = min(dist, sdArc((fc / res.x) - vec2(0.175, -0.07), sc, 0.02, 0.0));\n            dist = min(dist, sdArc((fc / res.x) - vec2(0.2, -0.14), sc, 0.02, 0.0));\n            dist = min(dist, sdArc((fc / res.x) - vec2(0.15, 0.0), sc, 0.02, 0.0));\n            shouldBeWall = dist < WALL_SIZE;\n\n            break;\n\n        case 5:\n            // slopes\n            fc.x = abs(fc.x - res.x * 0.125) + res.x * 0.125;\n            fc.y = mod(fc.y + res.x * 0.01, res.x * HEIGHT * 1.25);\n            dist2 = linePointDist2(vec2(0.125, HEIGHT * 1.2) * res.xy, vec2(0.15, HEIGHT) * res.xy, fc, res);\n            dist2 = min(dist2, linePointDist2(vec2(0.175, HEIGHT) * res.xy, vec2(0.225, HEIGHT * 1.2) * res.xy, fc, res));\n            dist2 = min(dist2, linePointDist2(vec2(0.2, HEIGHT * 2.2) * res.xy, vec2(0.1375, HEIGHT * 2.0) * res.xy, fc, res));\n            shouldBeWall = dist2 < square(res.x * WALL_SIZE);\n\n            break;\n            \n        case 6:\n            // truchet\n            fc.x *= res.x / res.y;\n            dist = truchet(res, iFrame, fc);\n            shouldBeWall = dist > 0.060 * res.x * WALL_SIZE;\n\n            break;\n    }\n\n    if (shouldBeWall)\n        fragColor = WALL;\n    else if (fragColor == WALL)\n        fragColor = EMPTY;\n}\n\nvoid spawnSand(int frame, vec2 fragCoord, vec3 res, vec2 oldMouse, vec4 newMouse, float selection, int palette, inout vec4 fragColor)\n{\n    if (newMouse.z > 0.0 && newMouse.y < res.y * 0.9)\n    {\n        vec4 sandColor;\n        if (selection < S_RAINBOW)\n        {\n            // specific color selection\n            sandColor = rainbow(int(selection), palette);\n        }\n        else if (selection < S_WALL)\n        {\n            // rainbow selection\n            sandColor = colorByFrame(frame, palette);\n        }\n        else\n        {\n            sandColor = WALL;\n        }\n\n\n        // compute the distance to the line segment from oldMouse to newMouse\n        // using a capsule instead of a sphere prevents gaps when the mouse is moved quickly\n        vec2 spawnBegin = oldMouse / vec2(4.0, 2.0);\n        vec2 spawnEnd = newMouse.xy / vec2(4.0, 2.0);\n        if (newMouse.w > 0.0) spawnBegin = spawnEnd;\n        float dist2 = linePointDist2(spawnBegin, spawnEnd, fragCoord, res);\n        \n        if (sandColor == WALL)\n        {\n            if (dist2 < square(res.x * WALL_SIZE))\n            {\n                // wall selection (white)\n                fragColor = WALL;\n            }\n        }\n        else if (fragColor == EMPTY && dist2 < square(res.x * SPAWN_SIZE))\n        {\n            float noise = (0.55 + 0.45 * hash(frame * int(fragCoord.x) * int(fragCoord.y)));\n            fragColor = vec4(noise, noise, noise, 1.0) * sandColor;\n        }\n    }\n}\n\nvoid removeSand(int frame, vec2 fragCoord, vec3 res, vec2 oldMouse, vec4 newMouse, inout vec4 fragColor)\n{\n    if (newMouse.z > 0.0)\n    {\n        vec2 removeBegin = oldMouse / vec2(4.0, 2.0);\n        vec2 removeEnd = newMouse.xy / vec2(4.0, 2.0);\n        if (newMouse.w > 0.0) removeBegin = removeEnd;\n        float dist2 = linePointDist2(removeBegin, removeEnd, fragCoord, res);\n \n        if (dist2 < square(res.x * 0.01))\n        {\n            // erase selection (black)\n            fragColor = EMPTY;\n        }\n    }\n}\n\nvoid evolveByCells(sampler2D sampler, int frame, ivec2 coord, ivec2 offset, ivec2 ires, out vec4 fragColor)\n{\n    // compute coordinates for the four pixels in our cell\n    ivec2 cellCoord = (coord - offset) / 2;\n    ivec2 llCell = cellCoord * 2 + offset;\n    ivec2 lrCell = llCell + ivec2(1, 0);\n    ivec2 ulCell = llCell + ivec2(0, 1);\n    ivec2 urCell = llCell + ivec2(1, 1);\n   \n    if (!all(lessThan(urCell, ivec2(ires.x / 4, ires.y / 2))) ||\n        (offset != ivec2(0) && any(equal(coord, ivec2(0)))))\n    {\n        // don't move particles at the bottom of the screen or off the edge\n        fragColor = texelFetch(sampler, coord, 0);\n        return;\n    }\n    \n    // fetch the members of our cell\n    vec4 ulValue = texelFetch(sampler, ulCell, 0);\n    vec4 urValue = texelFetch(sampler, urCell, 0);\n    vec4 llValue = texelFetch(sampler, llCell, 0);\n    vec4 lrValue = texelFetch(sampler, lrCell, 0);\n    \n    // figure out which are empty\n    bvec4 cell = bvec4(ulValue != EMPTY, urValue != EMPTY, llValue != EMPTY, lrValue != EMPTY);\n    \n    // try to match a pattern that should fall\n    if ((cell == bvec4(true,  false,\n                      false, false) ||\n        cell == bvec4(true,  false,\n                      false, true)||\n        cell == bvec4(true,  true,\n                      false, true)) && ulValue != WALL)\n    {\n        // left side falls\n        llValue = ulValue;\n        ulValue = EMPTY;\n    }\n    else if ((cell == bvec4(false, true,\n                           false, false) ||\n             cell == bvec4(false, true,\n                           true, false) ||\n             cell == bvec4(true, true,\n                           true, false)) && urValue != WALL)\n    {\n        // right side falls\n        lrValue = urValue;\n        urValue = EMPTY;\n    }\n    else if (cell == bvec4(true, true,\n                           false, false))\n    {\n        // both sides fall\n        if (urValue != WALL)\n        {\n            lrValue = urValue;\n            urValue = EMPTY;\n        }\n        if (ulValue != WALL)\n        {\n            llValue = ulValue;\n            ulValue = EMPTY;\n        }\n    }\n    else if ((cell == bvec4(true, false,\n                           true, false)) && ulValue != WALL)\n    {\n        // left side collapses\n        lrValue = ulValue;\n        ulValue = EMPTY;\n    }\n    else if ((cell == bvec4(false, true,\n                           false, true)) && urValue != WALL)\n    {\n        // right side collapses\n        llValue = urValue;\n        urValue = EMPTY;\n    }\n\n    // record result\n    if (coord == llCell)\n    {\n        fragColor = llValue;\n    }\n    else if (coord == lrCell)\n    {\n        fragColor = lrValue;\n    }\n    else if (coord == ulCell)\n    {\n        fragColor = ulValue;\n    }\n    else if (coord == urCell)\n    {\n        fragColor = urValue;\n    }\n}\n\n#define keyClick(ascii)   ( texelFetch(keySampler,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(keySampler,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n#define FLT_MAX 3.402823466e+38\n\nvec4 updateState(sampler2D sandSampler, sampler2D keySampler, int iFrame, vec4 iMouse, vec3 iResolution)\n{\n    const float DOUBLE_CLICK_FRAMES = 40.0;\n    vec4 oldState = texelFetch(sandSampler, ivec2(0), 0);\n    if (iFrame < 10 || keyDown(KEY_SPACE)) return vec4(0.0, 0.0, S_RAINBOW, FLT_MAX); // init state\n    int palette = int(oldState.y);\n    float selection = oldState.z;\n    float clickState = oldState.w;\n    if (iMouse.z > 0.0 && iMouse.y > iResolution.y * 0.9)\n    {\n        float u = iMouse.x / iResolution.x;\n        float newSelection = floor(u * SELECT_CHOICES);\n\n        if (iMouse.w > 0.0)\n        {\n            if (clickState < 0.0 && clickState > -DOUBLE_CLICK_FRAMES && newSelection == selection)\n            {\n                // double click detected\n                clickState = 0.0;\n                \n                if (newSelection == S_RAINBOW)\n                {\n                    // change palette\n                    palette = (palette + 1) % NUM_PALETTES;\n                }\n            }\n            else\n            {\n                clickState = 1.0;\n            }\n        }\n        else\n        {\n            // count frames held down\n            ++clickState;\n        }\n\n        selection = newSelection;\n    }\n    else\n    {\n        if (clickState < 0.0)\n        {\n            // count frames released...\n            --clickState;\n        }\n        else if (clickState > 1.0 && clickState < 1.0 + DOUBLE_CLICK_FRAMES)\n        {\n            // ...but only if it was held down only a short time.\n            clickState = -1.0;\n        }\n        else if (iMouse.z > 0.0)\n        {\n            clickState = 1.0;\n        }\n    }\n    \n    return vec4(iMouse.x * iResolution.y + iMouse.y, float(palette), selection, clickState);\n}\n\nconst int FRAMES_PER_MODE = 1300;\nconst int IDLE_FRAMES = 300;\nconst int NUM_ATTRACT_MODES = 5;\n\nvec2 sinuous(int frame, vec2 radius, vec2 speed, vec2 center)\n{\n    return vec2(cos(float(frame) * speed.x) * radius.x + center.x, sin(float(frame) * speed.y) * radius.y + center.y);\n}\n\nvoid updateAttract(inout vec2 oldMouse, inout vec4 newMouse, inout float selection, inout int palette, inout bool doubleClick, int frame, vec3 res)\n{\n    int fmod = frame % FRAMES_PER_MODE;\n    if ((frame % FRAMES_PER_MODE) > FRAMES_PER_MODE - IDLE_FRAMES) return;\n    int attractIndex = frame / FRAMES_PER_MODE;\n    int attractMode = attractIndex % NUM_ATTRACT_MODES;\n\n    switch (attractMode)\n    {\n        case 0:\n        \n            float radius = float(fmod) * (0.4 / float(FRAMES_PER_MODE - IDLE_FRAMES));\n            newMouse = vec4(sinuous(frame, radius * res.xy, vec2(0.1), res.xy * 0.5), 1.0, 0.0);\n            oldMouse = sinuous(frame - 1, radius * res.xy, vec2(0.1), res.xy * 0.5);\n            \n            break;\n            \n        case 1:\n\n            radius = 0.4 * sqrt(float(fmod) * (1.0 / float(FRAMES_PER_MODE - IDLE_FRAMES)));\n            newMouse = vec4(sinuous(-frame, radius * res.xy, vec2(0.1, 0.2), res.xy * 0.5), 1.0, 0.0);\n            oldMouse = sinuous(1 - frame, radius * res.xy, vec2(0.1, 0.2), res.xy * 0.5);\n            \n            break;\n\n        case 2:\n            \n            float mouseY = res.y * 0.9 - res.y * 0.9 * float(fmod) / float (FRAMES_PER_MODE - IDLE_FRAMES);\n            float oldMouseY = res.y * 0.9 - res.y * 0.9 * float((frame - 1) % (FRAMES_PER_MODE)) / float (FRAMES_PER_MODE - IDLE_FRAMES);\n            newMouse = vec4(sinuous(-frame, vec2(0.8 * res.y, 0.0), vec2(0.1, 0.2), vec2(res.x * 0.5, res.y * 0.8)).x, mouseY, 1.0, 0.0);\n            oldMouse = vec2(sinuous(1-frame, vec2(0.8 * res.y, 0.0), vec2(0.1, 0.2), vec2(res.x * 0.5, res.y * 0.8)).x, oldMouseY);\n            \n            break;\n\n        case 3:\n\n            newMouse = vec4(sinuous(frame, 0.3 * res.xy, vec2(0.02), res.xy * 0.5) +\n                            sinuous(-frame, 0.07 * res.xy, vec2(0.1), vec2(0)), 1.0, 0.0);\n            oldMouse = sinuous(frame - 1, 0.3 * res.xy, vec2(0.02), res.xy * 0.5) +\n                            sinuous(-(frame - 1), 0.07 * res.xy, vec2(0.1), vec2(0));\n            \n            break;\n\n        case 4:\n\n            newMouse = vec4(sinuous(frame, 0.1 * res.xy, vec2(0.03), res.xy * 0.5) +\n                            sinuous(frame, 0.3 * res.xy, vec2(0.05), vec2(0)), 1.0, 0.0);\n            oldMouse = sinuous(frame - 1, 0.1 * res.xy, vec2(0.03), res.xy * 0.5) +\n                            sinuous(frame - 1, 0.3 * res.xy, vec2(0.05), vec2(0));\n            \n            break;\n\n    }            \n\n    if (fmod == 0)\n    {\n        // new attract, clear the board on frame zero..\n        selection = S_ERASE;\n        doubleClick = true;\n        newMouse.z = -1.0;\n    }\n    else if (fmod == 1)\n    {\n        // choose the wall type on frame one...\n        selection = float(attractIndex % int(S_RAINBOW));\n        doubleClick = true;\n        newMouse.z = -1.0;\n    }\n    else\n    {\n        // then select the palette and let it run\n        palette = attractIndex % NUM_PALETTES;\n    }\n}\n\nvoid bufferMainInternal( out vec4 fragColor, in vec2 fragCoord, in ivec2 offset, in sampler2D sandSampler, in sampler2D keySampler, int iFrame, vec3 iResolution, vec4 iMouse)\n{\n    ivec2 ifc = ivec2(fragCoord);\n\n    // handle persistent state\n    if (ifc == ivec2(0, 0))\n    {\n        fragColor = updateState(sandSampler, keySampler, iFrame, iMouse, iResolution);\n        return;\n    }\n    \n    vec4 state = texelFetch(sandSampler, ivec2(0), 0);\n    int palette = int(state.y);\n    float selection = state.z;\n    float clickState = state.w;\n    bool doubleClick = clickState == 0.0;\n    bool idle = clickState == FLT_MAX;\n\n    // only use an eighth of the screen for simulation\n    if (fragCoord.x > iResolution.x * 0.25 || fragCoord.y > iResolution.y * 0.5)\n    {\n        return;\n    }\n    \n    // integration step\n    evolveByCells(sandSampler, iFrame, ifc, offset, ivec2(iResolution.xy), fragColor);\n    \n    // user interaction\n    float oldEncodedMouse = state.x;\n    vec2 oldMouse = vec2(oldEncodedMouse / iResolution.y, mod(oldEncodedMouse, iResolution.y));\n    \n    if (idle) updateAttract(oldMouse, iMouse, selection, palette, doubleClick, iFrame, iResolution);\n\n    if (selection == S_ERASE)\n        removeSand(iFrame, fragCoord, iResolution, oldMouse, iMouse, fragColor);\n    else\n        spawnSand(iFrame, fragCoord, iResolution, oldMouse, iMouse, selection, palette, fragColor);\n    \n    // perform double click action if requested\n    if (doubleClick && selection != S_RAINBOW) handleDoubleClick(selection, fragCoord, iResolution, iFrame, fragColor);\n    \n    // init scene\n    if (iFrame == 0 || (doubleClick && selection == S_ERASE)) fragColor = EMPTY;\n}\n\n#define bufferMain(X, Y, Z) bufferMainInternal(X, Y, Z, iChannel0, iChannel3, iFrame, iResolution, iMouse)",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bufferMain(fragColor, fragCoord, ivec2(1));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bufferMain(fragColor, fragCoord, ivec2(0));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bufferMain(fragColor, fragCoord, ivec2(1));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}