{
    "Shader": {
        "info": {
            "date": "1663549271",
            "description": "The curve that is made of all of the y(x) = xⁿ functions, one after the next. The first red segment is y=x, the next purple segment is y=x^2+c₂, the next blue one is y=x^3+c₃, etc. The function has been scaled vertically by 1/4 for display purposes.",
            "flags": 0,
            "hasliked": 0,
            "id": "sltfRs",
            "likes": 31,
            "name": "Mega Polynomial Curve",
            "published": 3,
            "tags": [
                "2d",
                "polynomial"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 1758
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright © 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// This is a curve made of all polynomials of the form yₙ(x)=xⁿ+cₙ, by stitiching\n// them together at the proper points xₙ and with the right vertical shifts cₙ, \n// such that their tangents coincide, forming a smooth curve (C1). The stitching\n// points are xₙ = { 1/2, 2/3, 3/4, 4/5, ...} and the coefficients cₙ are\n// { 0,  ½¹-½²+⅔³, ... }, so our \"Mega Polynomial\" function is \n// \n// mp(x) = \n//     if x<½ : x¹\n//     if x<⅔ : x² + (½¹ - ½²)\n//     if x<¾ : x³ + (½¹ - ½² + ⅔² - ⅔³)\n//     if x<⅘ : x⁴ + (½¹ - ½² + ⅔² - ⅔³ + ¾³ - ¾⁴)\n//     if x<⅚ : x⁵ + (½¹ - ½² + ⅔² - ⅔³ + ¾³ - ¾⁴ + ⅘⁴ - ⅘⁵)\n//     ...\n//\n// or alternativelly, shoter but less numerically stable (see line 59):\n// \n// mp(x) = \n//     if x<½ : x¹\n//     if x<⅔ : x² + 1¹/2²\n//     if x<¾ : x³ + 1¹/2² + 2²/3³\n//     if x<⅘ : x⁴ + 1¹/2² + 2²/3³ + 3³/4⁴\n//     if x<⅚ : x⁵ + 1¹/2² + 2²/3³ + 3³/4⁴ + 4⁴/5⁵\n//     ...\n//\n// Full expansion of connection points and coefficients:\n//\n// xₙ = { 0,  1/2,    2/3,       3/4,               4/5,                 5/6,                             6/7, ... }\n// cₙ = { 0,  1/4, 43/108, 3481/6912, 12647597/21600000, 380547619/583200000, 340607106994117/480290277600000, ... }\n//\n// The curve is only defined in [0,1), it tends to infinity as x approaches 1.\n// For ω = (1/6)*(202652381/12500)^(1/6) = 0.838473..., mp(ω) = 1.\n//\n// For a given x, the polynomial to consider is n = ⌊1/(1-x)⌋\n//\n// The coefficients cₙ can be computed with a loop. Or if you want to find a\n// closed form, the denominators are https://oeis.org/A061464, although before\n// simplifications they follow a simple multiplicative rule with nⁿ as a factor.\n//\n// Also, empirically cₙ seems to undulate around f(x)=-log(-log(x))/e, which\n// suggest attempting something in the lines of cₙ = -log(-log(1-1/(n+0.5)))/e\n\nfloat mp( float x, out int n )\n{\n    // determine segment n\n    n = int( min(floor(1.0/(1.0-x)),256.0) ); // max 256 polynomials\n\n    // compute cₙ\n    float c = 0.0;\n    for( int i=1; i<n; i++ )\n    {\n        float a = float(i+0);\n        float b = float(i+1);\n        \n     // c += pow(a,a)/pow(b,b);     // version a : simplified but unstable\n        c += pow(a/b,a)-pow(a/b,b); // version b : more stable\n    }\n\n    // compute yₙ as xⁿ + cₙ\n    return pow(x,float(n)) + c;\n}\n\nfloat helper( float x, in int n )\n{\n    float c = 0.0;\n    for( int i=1; i<n; i++ )\n    {\n        float a = float(i+0);\n        float b = float(i+1);\n        float d = a/b;\n        c += pow(d,a) - pow(d,b);\n    }\n    return c + pow(x,float(n));\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2  p = fragCoord/iResolution.x;\n    float px = 1.0/iResolution.x;\n    \n    p.x *= 0.995;\n    px  *= 0.995;\n    \n    // animate \"support\" polynomial\n    float time = mod(iTime,16.0);\n    int n = int(floor(time));\n\n    float demo = min(time,1.0) * (1.0-clamp(time-14.0,0.0,1.0));\n    if( n>0 ) n=n-1;\n    \n    // draw background\n    vec3 col = vec3( 0.0 );\n\n    // draw stiching points\n    {\n        float n = floor(1.0/(1.0-p.x));\n        float d = min(abs(p.x-n/(n+1.0)),\n                      abs(p.x-(n-1.0)/n));\n\n        float al = (1.0-smoothstep(0.0,1.0*px,d));\n        al *= 1.0-0.95*p.x;\n        al *= demo;\n        col = mix( col, vec3(0.85), al);\n    }\n    \n    // draw helper curve\n    if( n>0 )\n    {\n        float d = 1e20;\n        for( int i=-2; i<=2; i++ )\n        {\n            float x0 = p.x + px*(float(i+0));\n            float x1 = p.x + px*(float(i+1));\n            float y0 = 0.25*helper( x0, n );\n            float y1 = 0.25*helper( x1, n );\n            d = min( d, sdLine(p,vec2(x0,y0),vec2(x1,y1) ) );\n        }\n        float al = 1.0-smoothstep(0.0,2.0*px,d);\n        al *= demo;\n        col = mix( col, vec3(0.5), al );\n    }\n    \n    // draw Mega Polynomial\n    {\n        vec4 min_dis_col = vec4(1e20,0.0,0.0,0.0);\n        for( int i=-2; i<=2; i++ )\n        {\n            int e = 0;\n            int f = 0;\n            float x0 = p.x + px*(float(i+0));\n            float x1 = p.x + px*(float(i+1));\n            float y0 = 0.25*mp( x0, e );\n            float y1 = 0.25*mp( x1, f );\n            float d = sdLine(p,vec2(x0,y0),vec2(x1,y1) );\n            \n            if( e==n ) d -= 4.0*px*demo; // inflate current segment\n            \n            if( d < min_dis_col.x )\n            {\n                vec3 tmp = mix( vec3(1.0), 0.5+0.5*cos(float(e)+vec3(0,2,4)), demo );\n                min_dis_col = vec4(d,tmp);\n            }\n        }\n        col = mix( col, min_dis_col.yzw, 1.0-smoothstep(1.0*px,3.0*px,min_dis_col.x) );\n    }\n\n    fragColor = vec4( col, 1.0 );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}