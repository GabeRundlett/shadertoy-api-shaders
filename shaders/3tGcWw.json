{
    "Shader": {
        "info": {
            "date": "1611194851",
            "description": "I was just messing around and I made a neat fractal.",
            "flags": 32,
            "hasliked": 0,
            "id": "3tGcWw",
            "likes": 12,
            "name": "Funny Volumetric Fractal",
            "published": 3,
            "tags": [
                "fractal",
                "volumetric",
                "pathtrace",
                "pathtracing",
                "pathtracer",
                "trace",
                "path"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 467
        },
        "renderpass": [
            {
                "code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image! ^^^\n// Common is for settings and some functions\n// Buffer A is for rendering\n// Buffer B is for exporting a 32-Bit Floating Point OpenEXR Image\n// using the button at the bottom of the editor\n// This is for drawing the shader on the left (or above if you are in portrait mode XD)\n\n// Funny Volumetric Fractal by Zi7ar21 --- January 20th, 2020\n// Happy Biden and Kamala Inauguration Day!\n// If you found this anywhere except ShaderToy, the original and possibly updated version can be found at:\n// https://www.shadertoy.com/view/3tGcWw\n// Updated January 20th, 2020 19:00 Mountain Time\n// Made with help from LoicVDB (https://www.shadertoy.com/user/loicvdb)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image! ^^^\n// This is for settings and some functions.\n\n// Adjustable settings (Feel free to change these!)\n\n// Maximum Path-Tracing Steps, more results in slower possible speed but very few paths will bounce\n// enough to end up taking so long.\n#define maxsteps 1024\n\n// Path Tracing Step Size, more results in faster speed but a less accurate volume and a lower possible density.\n#define stepsize 0.01\n\n// Volume Density, more results in a denser volume but values set too high require smaller steps.\n#define volumedensity 200.0\n\n// Scene Size, if a path is this far from the scene it will stop.\n#define scenesize 2.0\n\n// Starting Path Distance, a larger value results in saving steps but you can't render volumes\n// close to the camera. Make sure this is less than the closest point to your object from the camera.\n#define startingdistance 0.5\n\n// Position of the Camera.\n#define cameraposition vec3(0.0, 0.0, -1.0)\n\n// Camera's Field of View, a larger value results in a wider Field of View.\n#define camerafov 2.0\n\n// Size of the Camera's Aperture, a laerger value results in a shallower Depth of Field.\n#define aperturesize 0.0\n\n// Camera Focal Plane, volumes this far are in focus.\n#define focaldistance 1.75\n\n// Number of times to iterate the formula.\n// I mean technically it is fbm octaves but you will keep quiet and tell nobody about it, right?\n#define iterations 4\n\n#define rot(a) mat2( cos( a + vec4(0,11,33,0)))\n#define rot3(V,a,b) V.xz *= rot(a), V.yz *= rot(b)\n\n// Constants (Things like Pi for trigonometry, I mean you could change these, but there is no point.)\n#define pi 3.141592653589793\n#define twopi 3.141592653589793*2.0\n\n// High-Quality Random Numbers from Michael0884, proper demo: https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x + fragCoord.y*iResolution.x);\nvoid pcg(){\n    uint state = ns*747796405u+2891336453u;\n    uint word = ((state >> ((state >> 28u)+4u))^state)*277803737u;\n    ns = (word >> 22u)^word;}\n\nfloat rand(){pcg(); return float(ns)/float(0xffffffffu);}\nvec2 rand2(){return vec2(rand(), rand());}\n//vec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Normalized Random, also from Michael0884 https://www.shadertoy.com/view/WttyWX\n/*float ErfInv(float x){\n   float lnx = log((1.0-x)*(1.0+x));\n   float tt1 = 4.3308+0.5*lnx;\n   float tt2 = 6.8027*lnx;\n   return(sign(x)*sqrt(-tt1+sqrt(tt1*tt1-tt2)));\n}*/\n\n//float nrand(){return ErfInv(rand()*2.0-1.0);}\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x))*vec2(cos(twopi*Z.y),sin(twopi*Z.y));}\nvec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}\n//vec4 nrand4(float sigma, vec4 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxyy))*vec4(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w), sin(twopi*Z.w));}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image! ^^^\n// This is for rendering.\n\n// HSV (for Colors)\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(c.xxx+K.xyz)*6.0-K.www);\n    return c.z*mix(K.xxx, clamp(p-K.xxx, 0.0, 1.0), c.y);}\n\n// I don't know, I was trying to make noise-like patterns and I made a neat fractal\nfloat iterate(vec3 x){\n    x *= pi;\n    float componenta = cos(x.x)+cos(x.y)+cos(x.z);\n    float componentb = sin(x.x)+sin(x.y)+sin(x.z);\n    return mix(componenta, componentb, (componenta+3.0)/3.0);}\n\n// Perform iterations on the function\nfloat fractal(vec3 x){\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfor (int i = 0; i < iterations; i++){\n\t\tv += a*iterate(x);\n\t\tx = x.zyx*2.0;\n\t\ta *= 0.5;}\n\treturn v;}\n\n// 3D Volumetric Density Function, this is the heart of the fractal\nvec4 densityfunction(vec3 pathposition){\n    float density = fractal(pathposition+fractal(pathposition))-distance(pathposition, vec3(0.0));\n    float subdensity = max(0.5, fractal(pathposition)-0.5);\n    vec3 coloration = hsv2rgb(vec3(clamp(density, 0.0, 1.0), 0.5, clamp(density-subdensity, 0.0, 1.0)));\n    return vec4(coloration, max(0.0, density-subdensity)*volumedensity);}\n\n// Light Collision Checker\nbool light(vec3 pathposition){return distance(pathposition, vec3(pathposition.x, 2.0, pathposition.z))-0.5 < 0.0;}\n\n// Path-Tracing\nvec3 pathtrace(vec3 pathdirection, vec3 inputcameraposition){\n    vec4 density;\n    float absorbance;\n    float distancetravelled = 0.0;\n    vec3 emission = vec3(0.0);\n    vec3 attenuation = vec3(1.0);\n    vec3 pathposition = inputcameraposition+(pathdirection*startingdistance)+(pathdirection*stepsize*2.0*(rand()-0.5));\n    for(int i = 0; i < maxsteps; i++){\n        density = densityfunction(pathposition);\n        absorbance = exp(-density.w*stepsize);\n        if(absorbance < rand()){attenuation *= clamp(density.rgb*4.0, 0.0, 1.0); emission += density.rgb*0.01*max(0.0, 1.0-absorbance); pathdirection = normalize(nrand3(1.0, vec3(0.0)));}\n        pathposition += pathdirection*stepsize;\n        distancetravelled += stepsize;\n        if(distance(pathposition, vec3(0.0)) > scenesize || distancetravelled > 32.0){break;}\n        if(light(pathposition)){return (vec3(4.0)*attenuation)+emission;}}\n    return vec3(0.0)+emission;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0){oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}\n    fragColor = oldFragColor;\n    INIT_RNG;\n    if(iMouse.z > 0.0){fragColor = vec4(0.0);}\n    vec2 uv = ((fragCoord+nrand2(0.5, vec2(0.0)))-0.5*iResolution.xy)/iResolution.x;\n    mat3 rotationmatrix = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    vec3 aperture = vec3(nrand2(aperturesize, vec2(0.0)), 0.0);\n    vec3 pathdirection = normalize(vec3(camerafov*uv, 1.0)-aperture/focaldistance);\n    vec3 pathposition = aperture;\n    vec2 M =  -3.14*(iMouse.xy*2.0/iResolution.xy);\n    rot3(pathdirection, M.x, M.y);\n    pathposition.z += cameraposition.z;\n    rot3(pathposition, M.x, M.y);\n    pathposition.z -= cameraposition.z;\n    pathdirection *= rotationmatrix;\n    pathposition *= rotationmatrix;\n    pathposition += cameraposition;\n    vec3 pathtraced = pathtrace(pathdirection, pathposition);\n    fragColor += vec4(pathtraced, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image! ^^^\n// This is for exporting a 32-Bit Floating Point OpenEXR Image\n// using the button at the bottom of the editor.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 color = (texel.a == 0.0 ? vec3(0.0) : texel.rgb/texel.a);\n    fragColor = vec4(pow(color, vec3(1.0/2.2)), 1.0);}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}