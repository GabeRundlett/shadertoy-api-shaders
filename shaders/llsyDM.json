{
    "Shader": {
        "info": {
            "date": "1617153472",
            "description": "POC for last scene from https://www.youtube.com/watch?v=oITx9xMrAcM",
            "flags": 0,
            "hasliked": 0,
            "id": "llsyDM",
            "likes": 8,
            "name": "Multiverse2",
            "published": 3,
            "tags": [
                "demoscene",
                "spaghetti"
            ],
            "usePreview": 0,
            "username": "patu",
            "viewed": 345
        },
        "renderpass": [
            {
                "code": "#define getNormal getNormalCube\n\n#define FAR 330.\n#define INFINITY 1e32\n#define t iTime\n#define mt iChannelTime[1]\n#define FOV 80.0\n#define FOG .06\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nfloat vol = 0.;\nbool inball = false;\nfloat iter = 0.;\n\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\nfloat noiseShort(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\nvec3 fromRGB(int r, int g, int b) {\n \treturn vec3(float(r), float(g), float(b)) / 255.;   \n}\n    \nvec3 \n    light = vec3(0.0),\n    p = vec3(0.),\n    p2 = vec3(0.),\n\tlightDir = vec3(0.);\n\n\nvec3 lightColour = normalize(vec3(1.8, 1.0, 0.3)); \n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nstruct geometry {\n    float dist;\n    vec3 space;\n    vec2 material;\n    int iterations;\n    float glow;\n};\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nvec3 DE(vec3 p)\n{\n \tconst float scale = 1.45;\n\tconst float offset = 2.0;\n    const int FRACTALITERATIONS = 15;\n    vec3 modifier = vec3(-12.3 , -4.1, -4.1);\n\tp.y = -p.y;\n\tfor(int n=0; n< FRACTALITERATIONS; n++)\n\t{\n        \n        \n\t\tp.xy = (p.x + p.y <= 0.0) ? -p.yx : p.xy;\n\t\tp.xz = (p.x + p.z <= 0.0) ? -p.zx : p.xz;\n\t\tp.zy = (p.z + p.y <= 0.0) ? -p.yz : p.zy;\n\n\t\tp.y -= 4.1;\n        pR(p.xz, 0.82915);\n        \n        p.yz = -p.zy * vec2(1., -1.);\n        p.x -= 25.;\n        pR(p.zx, -.16915);\n\n\t\tp = scale*p-offset*(scale-1.0) * modifier;\n\t}\n \tvec3 obj;\n    obj.x = length(p) * pow(scale, -float(FRACTALITERATIONS)); \n\n    return obj;\n}\n\nvec3 map(vec3 p) {\n    \n    vec3 bp = p;\n   // p += 15.;\n    vec3 r = pMod3(p, vec3(100.));\n\tp += noiseShort(r) * 20.;\n    vec3 obj, obj2;\n    obj2.x = FAR;\n    obj.x = FAR;\n    obj.y = 2.;\n\n    if (inball) {\n        obj.x = min(obj.x, DE(p).x);\n        obj2.y = 3.;\n        obj = opU2(obj, obj2);\n    } else {\n        obj.x = min(obj.x, fSphere(p, noiseShort(p * .05 + t) * 2. + 30. * sin(length(r)))); \n\n    }\n\n    return obj;\n}\n\nvec3 trace(vec3 ro, vec3 rd) {\n    vec3 tr = vec3(.5, -1., 0.0);\n    for (int i = 0; i < 126; i++) {\n        vec3 d = map(ro + rd * tr.x);\n        tr.x += d.x * 0.4; // Using more accuracy, in the first pass.\n        tr.yz = d.yz;\n        if (abs(d.x) < 0.02 || tr.x > FAR) break;\n\t\titer += 1.;\n    }\n    return tr;\n}\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 8;\n    vec3 rd = (lp - ro); // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = 4.5;\n    float end = max(length(rd), 0.01);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).x;\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.2), 1.0);\n}\n\n#define EPSILON .001\nvec3 getNormalHex(vec3 pos)\n{\n\tfloat d=map(pos).x;\n\treturn normalize(\n        vec3(\n            map(\n                pos+vec3(EPSILON,0,0)).x-d,\n                map(pos+vec3(0,EPSILON,0)).x-d,\n                map(pos+vec3(0,0,EPSILON)).x-d \n        \t)\n    \t);\n}\n\n#define delta vec3(.001, 0., 0.)\nvec3 getNormalCube(vec3 pos)   \n{    \n   vec3 n;  \n   n.x = map( pos + delta.xyy ).x - map( pos - delta.xyy ).x;\n   n.y = map( pos + delta.yxy ).x - map( pos - delta.yxy ).x;\n   n.z = map( pos + delta.yyx ).x - map( pos - delta.yyx ).x;\n   \n   return normalize(n);\n}\n\n\nfloat getAO(vec3 hitp, vec3 normal, float dist)\n{\n    vec3 spos = hitp + normal * dist;\n    float sdist = map(spos).x;\n    return clamp(sdist / dist, 0.0, 1.0);\n}\n\nvec3 Sky(in vec3 rd, bool showSun, vec3 lightDir)\n{\n   \n   float sunSize = 3.5;\n   float sunAmount = max(dot(rd, lightDir), 0.4);\n   float v = pow(1. - max(rd.y, 0.0), .1);\n   vec3 sky = mix(fromRGB(0,136,254), vec3(.1, .2, .3) * .1, v);\n   if (showSun == false) sunSize = .1;\n   sky += lightColour * sunAmount * sunAmount * 1. + lightColour * min(pow(sunAmount, 122.0)* sunSize, 0.2 * sunSize);\n   \n   return clamp(sky / noiseShort(rd * 3.), 0.0, 1.0);\n}\n\nvec3 getObjectColor(vec3 p, vec3 n, geometry obj) {\n    vec3 col = vec3(.0);\n    \n    if (obj.material.x == 0.0) { \n        col = vec3(1., .6, .5);       \n    };\n    \n    if (obj.material.x == 1.0) { col = fromRGB(255,128,0); }\n    if (obj.material.x == 2.0) { \n        col = fromRGB(255,128,50);     \n    }\n    \n    if (obj.material.x == 4.0) { \n        col = vec3(1., .6, .5); \n    };\n    return col;\n\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, geometry obj) {\n\tvec3 sceneCol = vec3(0.0);\n    lp = sp + lp;\n    vec3 ld = lp - sp; // Light direction vector.\n    float lDist = max(length(ld / 2.), 0.001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n\n    // Attenuating the light, based on distance.\n    float atten = 1. / (1.0 + lDist * 0.025 + lDist * lDist * 0.2);\n\n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), 7.);\n    // Standard specualr term.\n    float spec = pow(max(dot(reflect(-ld, sn), -rd), 1.), 1.);\n\n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = getObjectColor(sp, sn, obj);\n\n    // Combining the above terms to produce the final scene color.\n    sceneCol += (objCol * (diff + .15) * spec * .1);// * atten;\n\n    // Return the color. Done once every pass... of which there are\n    // only two, in this particular instance.\n    \n    return sceneCol;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 ouv = fragCoord.xy / iResolution.xy;\n    vec2 uv = ouv - .5;\n    \n    uv *= tan(radians (FOV) / 2.0) * 1.1;\n\n    float t2 = t - 35.;\n    float \n        sk = sin(-t2 * .04) * 26.0, \n        ck = cos(-t2 * .07) * 32.0 - sk,\n        \n        mat = 0.;\n    \n    light = vec3(0., 17., 100.);        \n    lightDir = light;\n        \n    vec3 \n        vuv = vec3(sin(t / 10.), 1., sin(t / 10.)), // up\n    \tro = vec3(-2., ck, sk) + vec3(iMouse.x / 20.,iMouse.y / 10. - 1., 10.); // pos\n    ro -= 120.;\n    vec3\n        vrp =  vec3(sin(t / 30.) * 12., + sin(t * 2.) / 5., 10.) +\n        \tvec3(\n                -2., \n                0. + sin(t) / 3., \n                0. + sin(t / 3.) / 4.), // lookat    */\n\t\t\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro),\n        hit;        \n\t\n    vec3 sceneColor = vec3(0.);\n\n    vec3 tr = trace(ro, rd);    \n    \n    float fog = smoothstep(FAR * FOG, 0., tr.x);\n    hit = ro + rd * tr.x;\n    vec3 otr = tr;\n    vec3 sn = getNormal(hit);\t\n    \n    float sh = softShadow(hit, hit + light, 3.);\n    \n    float \n        ao = getAO(hit, sn, 15.2);\n\n    vec3 sky = Sky(rd, true, normalize(light)) * 1.;\n    vec3 skyNoSun = Sky(rd, false, normalize(light)) * 1.;\n        \n    if (tr.x < FAR) { \n        sceneColor += 0.2;\n        inball = true;\n        vec3 bcol = vec3(0.);\n        if (tr.x > 0.) {\n            rd = refract(rd, sn, 1. - min(1., tr.x / 100.));\n            bcol = vec3(1., .9, 1.0) * pow(noiseShort(sn * 1.) * 1.3, 7.) * .3;\n            bcol += pow(max(0., dot(rd, normalize(light))), 13.);\n            tr = trace(hit, rd);\n        } else {\n            tr = trace(ro, rd);\n        }\n        \n        if (tr.x < FAR) {\n        \thit = hit + rd * (tr.x);\n            sceneColor += 9. / pow(tr.x, 1.1);\n            sceneColor = mix(sceneColor, sky, clamp(tr.x / 30., 0., 1.));\n        } else {\n            sceneColor += sky;\n        }\n        sceneColor += bcol;\n\n    } else {\n        sceneColor = sky;\n\n    }\n    sceneColor += pow(sin(float(iter) / 500.), 1.9) ;\n    sceneColor = mix(sceneColor, sky, clamp(otr.x / 400., 0., 1.));\n    fragColor = vec4(clamp(sceneColor * (1. - length(uv) / 2.5), 0.0, 1.0), 1.0);\n    \n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}