{
    "Shader": {
        "info": {
            "date": "1687188448",
            "description": "All year long I'm going to just focus on truchet tiles and the likes! (mouseable)",
            "flags": 0,
            "hasliked": 0,
            "id": "DdfyRX",
            "likes": 19,
            "name": "Year of Truchets #040",
            "published": 3,
            "tags": [
                "raymarching",
                "refraction",
                "glass",
                "truchet",
                "trippy"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 247
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #040\n    06/19/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    Glass effect is refract/reflect in one pass. Almost\n    like interlacing almost.. It's a weird effect but I\n    like the style, and still playing with it.. \n\n*/\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI  3.141592653\n#define PI2 6.283185307\n\n#define MAX_DIST   30.\n#define MIN_DIST   .001\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.29))) *4832.3734); }\n\n//@iq sdf's + extrude\nfloat opx(in float d, in float z, in float h){\n    vec2 w = vec2( d, abs(z) - h ); return min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\nfloat box(vec2 p,vec2 b){\n    vec2 d = abs(p)-b; return length(max(d,0.)) + min(max(d.x,d.y),0.);\n}\nfloat box(vec3 p, vec3 b){\n  vec3 q = abs(p)-b;return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\n// globals\nfloat gtk,stk,speed;\nvec3 hitPoint,hp,sid,gid;\nmat2 spin;\n\n// constants\nconst float scale = .5;\nconst float hf = .45;\nconst float rd = .015;\nconst float thick = .0375;\n\nvec2 map (in vec3 p) {\n \tvec2 res = vec2(1e5,0);\n    p.xz *= spin;\n    // movement\n    p.y -= speed;\n    \n    // sizing and mixdown\n    gtk = thick;\n    \n    // id grid\n    vec3 id = floor(p*scale), q = fract(p*scale)-.5;\n    gid=id;\n    float hs = hash21(id.xz+id.y);\n    float xhs = fract(35.37*hs);\n\n    if (hs>.75) { q.zy=-q.zy; } else if (hs>.5) { q.xy=-q.xy; }\n \n    vec3 q1,q2,q3;\n    float trh,trx,jre,clip=1e5;\n    \n    //draw\n    if(xhs>.75) {\n        q1 = q;\n        q2 = q + vec3(0,hf,hf);\n        q3 = q - vec3(0,hf,hf);\n\n        trh = opx(box(q1.xz,vec2(.5,thick)),q1.y,thick)-rd;\n        trx = opx(abs(box(q2.yz,vec2(.15))-.3)-thick,q.x,thick)-rd;\n        jre = opx(abs(box(q3.yz,vec2(.15))-.3)-thick,q.x,thick)-rd;\n\n    } else {\n        q1 = q + vec3(hf,0,-hf);\n        q2 = q + vec3(0,hf,hf);\n        q3 = q - vec3(hf,hf,0);\n        \n        trh = opx(abs(box(q1.xz,vec2(.15))-.3)-thick,q.y,thick)-rd;\n        trx = opx(abs(box(q2.yz,vec2(.15))-.3)-thick,q.x,thick)-rd;\n        jre = opx(abs(box(q3.xy,vec2(.15))-.3)-thick,q.z,thick)-rd;\n\n    }\n    \n    clip = box(vec3(abs(q.x)-.5,q.yz),vec3(thick+.01))-rd;\n    clip=min(clip,box(vec3(q.x,abs(q.y)-.5,q.z),vec3(thick+.01))-rd);\n    clip=min(clip,box(vec3(q.xy,abs(q.z)-.5),vec3(thick+.01))-rd);\n        \n    xhs = fract(35.37*hs); \n    if(trh<res.x) {res = vec2(trh,xhs>.6?2.:1.);hp=p;}\n    if(trx<res.x) {res = vec2(trx,xhs>.6?2.:1.);hp=p;}\n    if(jre<res.x) {res = vec2(jre,xhs>.6?2.:1.);hp=p;}\n\n    if(clip<res.x) {res = vec2(clip,3.);hp=p;}\n    \n \treturn res;\n}\n\nvec3 normal(vec3 p, float t, float mindist){\n    float e = mindist*t;\n    vec2 h = vec2(1.,-1.);\n    return normalize( h.xyy*map( p + h.xyy*e).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e).x );\n}\n\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    n.xz*=spin;// match scene rotation\n    n = max(abs(n), MIN_DIST);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n}\n\nvec3 render(vec3 p, vec3 rd, vec3 ro, float d, float m, inout vec3 n){\n    n = normal(p,d,1.01);\n    vec3 lpos = vec3(.5,15.5,.5);\n    vec3 l = normalize(lpos-p);\n\n    float diff = clamp(dot(n,l),.01,.95);\n\n    vec3 h = vec3(0.043,0.078,0.063);\n    float hs = hash21(sid.xz+sid.y);\n    \n    if(m==1.) h=mix(hs>.5?vec3(.42,.21,.04):vec3(.17,.31,0.39),hs>.5?vec3(.19,.09,.01):vec3(.06,.09,.12),smoothstep(.15,.4,tex3D(iChannel0,hitPoint*.5,n).r*.75));\n    \n    if(m==3.) h=mix(vec3(.12,.12,.124),vec3(.067,.07,.071),smoothstep(.2,.15,tex3D(iChannel1,hitPoint*.8,n).r*.75));\n\n    return diff*h;\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    speed =T*.15;\n    spin = rot(T*.03);\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    \n    // ray order+direction\n    vec3 ro = vec3(0,0,1.);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    // mouse //\n    float x = M.xy==vec2(0) || M.z <1. ? 0. :  (M.y/R.y*.5-.25)*PI2;\n    float y = M.xy==vec2(0) || M.z <1. ? 0. : -(M.x/R.x*1.-.5)*PI2;\n\n    mat2 rx = rot(x), ry = rot(-y);\n    ro.zy *= rx; ro.xz *= ry; \n    rd.zy *= rx; rd.xz *= ry;\n    \n    vec3 C = vec3(0);\n    vec3  p = ro + rd;\n    float atten = 1.,k = 1.,d = 0.,a = 0., iv = 1., b = 7.;\n    \n    for(int i=0;i<200;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n = vec3(0);\n        float m = ray.y;\n        d = i<32? ray.x*.85:ray.x;\n        p += rd * d *k;\n        a += d*.425;\n        if (d*d < 1e-8) {\n            hitPoint = hp;\n            sid=gid;\n            C+=render(p,rd,ro,d,ray.y,n)*atten;\n            \n            if(m!=2.||b<0.)break;\n            b--;\n            p += rd*.025;\n            k = sign(map(p).x);\n\n            atten *= .5;\n            vec3 rf=refract(rd,n,iv>0.?.875:1.1);\n            iv *= -1.;\n            if(length(rf) == 0.) rf = reflect(rd,n);\n            rd=rf;\n            p+=-n*.0025;\n\n        } \n        \n        if(distance(p,rd)>MAX_DIST) {break;}\n    }\n    \n    C = mix(vec3(.059,.082,.078),C,exp(-.025*a*a*a));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}