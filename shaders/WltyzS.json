{
    "Shader": {
        "info": {
            "date": "1609361012",
            "description": "I wanted to know taste of physically based lighting, so I copied from romainguy's shader.\nhttps://www.shadertoy.com/view/XlKSDR\nIt's not enough. (I couldn't get some of the functions to work...)\nBut the taste is not so bad.",
            "flags": 32,
            "hasliked": 0,
            "id": "WltyzS",
            "likes": 7,
            "name": "A taste of the physically base",
            "published": 3,
            "tags": [
                "pbr",
                "physicallybasedl",
                "ighting"
            ],
            "usePreview": 0,
            "username": "iY0Yi",
            "viewed": 411
        },
        "renderpass": [
            {
                "code": "// \"Physically-based SDF\" by romainguy:\n//https://www.shadertoy.com/view/XlKSDR\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 Tonemap_ACES(const vec3 x){\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n// https://www.shadertoy.com/view/3ssSz2\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat originalSigmoidContrast(float color, float contrast, float mid){\n    contrast = contrast < 1.0 ? 0.5 + contrast * 0.5 : contrast;\n    float scale_l = 1.0 / mid;\n    float scale_h = 1.0 / (1.0 - mid);\n    float lower = mid * pow(scale_l * color, contrast);\n    float upper = 1.0 - (1.0 - mid) * pow(scale_h - scale_h * color, contrast);\n    return color < mid ? lower : upper;\n}\nvec3 originalSigmoidContrast(vec3 color, float contrast, float mid){\n\tcolor.r = originalSigmoidContrast(color.r, contrast, mid);\n\tcolor.g = originalSigmoidContrast(color.g, contrast, mid);\n\tcolor.b = originalSigmoidContrast(color.b, contrast, mid);\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tvec3 col = texture(iChannel0, uv).rgb;\n\tcol = Tonemap_ACES(col);\n\tcol = sat(col);\n\tcol = originalSigmoidContrast(col, 2.5, .2);\n\tcol = pow(col, vec3(1./2.2));\n\tfragColor = vec4(col, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// General\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define iFrameRate 24.0\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*.5)\n#define ZERO min(0,iFrame)\n\n#define sat(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\n// Raymarching\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define MIN_DIST 0.001\n#define MAX_DIST 1500.0\n#define ITERATION 200\n\n#define MAT_VOID vec3(-1)\n#define MAT_ERNST0 vec3(0.6619, 0.3542, 0.3158)\n#define MAT_ERNST0_006 vec3(0.6619, 0.6108, 0.5172)\n#define MAT_ERNST0_002 vec3(0.3324, 0.6921, 0.5215)\n#define MAT_ERNST0_003 vec3(0.6982, 0.4874, 0.0414)\n#define MAT_ERNST0_001 vec3(0.1334, 0.42, 0.1273)\n#define MAT_ERNST0_005 vec3(0.1025, 0.0915, 0.0915)\n#define MAT_ERNST0_004 vec3(0.2306, 0.2807, 0.6619)\n\n#define AMB_COL vec3(0.6921, 0.8636, 1.0)\n#define AMB_STRENGTH 0.3\n#define FOG_COL vec3(1.0, 1.0, 1.0)\n#define FOG_START 0.0\n#define FOG_POW 1.0\n\n// \"hash11()\" - \"hash44()\"\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat hash11(float p){\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "struct Ray{\n\tvec3 origin;\n\tvec3 direction;\n};\n\nstruct Camera{\n\tvec3 position;\n\tvec3 direction;\n\tvec3 target;\n\tvec4 quaternion;\n\tfloat fov;\n\tfloat orthoDist;\n\tfloat orthoScale;\n};\n\nstruct Light{\n\tvec3 direction;\n\tvec3 color;\n\tfloat intensity;\n\tfloat shadowStart;\n\tfloat shadowEnd;\n\tfloat shadowSoft;\n};\n\nstruct RenderData{\n\tvec3 position;\n\tvec3 albedo;\n\tvec3 normal;\n\tfloat diffuse;\n\tfloat specular;\n\tfloat shadow;\n\tfloat ao;\n\tfloat depth;\n\tvec3 result;\n}renDat;\n\n// \"init\": init camera/lights.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nRay ray;\nCamera cam0;\nLight lit0;\nLight lit1;\nvoid init(){\n    cam0.position = vec3(-26.9963, 88.0527, -48.4978);\n\tcam0.quaternion = vec4(0.2949, -0.0793, -0.2473, 0.9196);\n\tcam0.fov = 0.08;\n\tcam0.orthoDist = 0.0;\n\tcam0.orthoScale = 0.0;\n\n\tlit0.direction = normalize(vec3(-0.5875, 0.7071, -0.3935));\n\tlit0.color = vec3(2.5372, 2.3575, 1.8639);\n\tlit0.shadowStart = 0.05;\n\tlit0.shadowEnd = 30.0;\n\tlit0.shadowSoft = 50.0;\n\tlit1.direction = normalize(vec3(0.5875, -0.7071, 0.3935));\n\tlit1.color = vec3(0.214, 0.1892, 0.1329);\n\tlit1.shadowStart = 0.05;\n\tlit1.shadowEnd = 30.0;\n\tlit1.shadowSoft = 50.0;\n}\n\n// \"camera\": create camera vectors.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 quat_rotate(vec4 quat, vec3 dir){\n\treturn dir + 2.0 * cross(quat.xyz, cross(quat.xyz, dir) + quat.w * dir);\n}void perspectiveCam(vec2 uv){\n\tvec3 dir = quat_rotate(cam0.quaternion, vec3(0,0,-1)).xzy;\n\tvec3 up = quat_rotate(cam0.quaternion, vec3(0,1,0)).xzy;\n\tvec3 pos = cam0.position;\n\tfloat fov = cam0.fov;\n\tvec3 target = pos-dir;\n\n\tvec3 cw = normalize(target - pos);\n\tvec3 cu = normalize(cross(cw, up));\n\tvec3 cv = normalize(cross(cu, cw));\n\n\tmat3 camMat = mat3(cu, cv, cw);\n\tray.origin = pos;\n\tray.direction = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));;\n}\nvoid camera(vec2 uv){\n\tperspectiveCam(uv);\n}\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n\tR(p.xz, r.y);\n\tR(p.yx, r.z);\n\tR(p.zy, r.x);\n\treturn p;\n}\n\n// SDF functions\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat vmax(vec3 v){\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat sdPlane(in vec3 p){\n\treturn p.y;\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r){\n\treturn (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n}\n\nfloat sdCapsule(vec3 p, float r, float c){\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\nfloat sdTorus( vec3 p, vec2 t ){\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nfloat sdCappedTorus(vec3 p, vec2 r, float per){\n\tp.x = abs(p.x);\n\tvec2 sc = vec2(sin(per),cos(per));\n\tfloat k = (sc.y*p.x>sc.x*p.z) ? dot(p.xz,sc) : length(p.xz);\n\treturn sqrt( dot(p,p) + r.x*r.x - 2.0*r.x*k ) - r.y;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h ){\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n\treturn ((min(max(d.x,d.y),0.0) + length(max(d,0.0))))-0.0;\n}\n\nfloat sdPieCylinder( vec3 p, float r, float h, float per ){\n\tper = mod(per, PI);\n\tvec2 c = vec2(sin(per),cos(per));\n\n\tp.xz=c.y*p.xz+c.x*vec2(p.z,-p.x); // rotation\n\tp.x = abs(p.x);\n\n\tfloat l = length(p.xz) - r;\n\tfloat m = length(p.xz-c*clamp(dot(p.xz,c),0.0, r));\n\tfloat x = max(l,m*sign(c.y*p.x-c.x*p.z));\n\n\tfloat y = abs(p.y) - h;\n\n\treturn ((min(max(x,y),0.0) + length(max(vec2(x,y),0.0))));\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 ){\n\tvec2 q = vec2( length(p.xz), p.y );\n\tvec2 k1 = vec2(r2,h);\n\tvec2 k2 = vec2(r2-r1,2.0*h);\n\tvec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n\tvec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n\tfloat s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n\treturn s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n}\n\nfloat sdRoundCone( vec3 p, float h, float r1, float r2 ){\n\tvec2 q = vec2( length(p.xz), p.y+h*.5 );\n\n\tfloat b = (r1-r2)/h;\n\tfloat a = sqrt(1.0-b*b);\n\tfloat k = dot(q,vec2(-b,a));\n\n\tif( k < 0.0 ) return length(q) - r1;\n\tif( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n\n\treturn dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdBox(vec3 p,vec3 b){\n\tvec3 d=abs(p)-b;\n\treturn length(max(d,vec3(0)))+vmax(min(d,vec3(0.0)));\n}\n\nfloat fOpUnion(in float a,in float b){\n\treturn a<b?a:b;\n}\n\nvec4 v4OpUnion(in vec4 a,in vec4 b){\n\treturn a.x<b.x?a:b;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r){\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n\n\t// iq:\n\t//float h = max(r-abs(a-b),0.0);\n\t//return min(a, b) - h*h*0.25/r;\n}\n\nvec4 v4OpUnionSmooth(vec4 a,vec4 b,float r){\n\tfloat h=clamp(0.5+0.5*(b.x-a.x)/r,0.0,1.0);\n\tfloat res = mix(b.x,a.x,h)-r*h*(1.0-h);\n\treturn vec4(res, mix(b.yzw,a.yzw,h));\n}\n\nvec4 v4OpSubstraction(in vec4 a,in vec4 b){\n\tfloat res = max(-a.x, b.x);\n\treturn (res==-a.x)?vec4(-a.x, a.yzw):b;\n}\n\nvec4 v4OpSubstractionSmooth( vec4 a,vec4 b,float r){\n\tvec2 u = max(vec2(r + b.x, r + -a.x), vec2(0));\n\tfloat res = min(-r, max(b.x, -a.x))+length(u);\n\tvec3 m = mix(b.yzw, a.yzw, clamp(abs(-b.x)+abs(res),0.0,1.0)*clamp(r,0.,1.));\n\treturn vec4(res, m);\n}\n\nvec4 v4OpIntersection(in vec4 a,in vec4 b){\n\tfloat res = max(a.x, b.x);\n\treturn (res==a.x)?a:b;\n}\n\nvec4 v4OpIntersectionSmooth( vec4 a,vec4 b,float r){\n\tvec2 u = max(vec2(r + b.x,r + a.x), vec2(0));\n\tfloat res =  min(-r, max(b.x, a.x)) + length(u);\n\tvec3 m = mix(a.yzw, b.yzw, clamp(a.x-res,0.0,1.0)*r);\n\treturn vec4(res, m);\n}\n\n// \"Limited Repetition SDF\" by iq:\n// https://www.shadertoy.com/view/3syGzz\nvoid pRepLimited(inout float p_el, float s, float repetitions ){\n#if 0\n\tfloat r = round(p_el/s);\n\tfloat half_num = (repetitions-1.)/2.;\n\tr = clamp(r, -half_num, repetitions-half_num);\n\tp_el-=s*r;\n#else\n\trepetitions -= 1.;\n\tfloat offset = 1.-step(.5, mod(repetitions, 2.));\n\tp_el += s*.5*offset;\n\tfloat r = round(p_el/s);\n\tfloat half_rep = ceil(repetitions/2.);\n\tr = clamp(r, -half_rep, repetitions-half_rep);\n\tp_el-=s*r;\n#endif\n}\n\n// scene: Shapes.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec4 sd002(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p), bsr=10.0;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\td = sdEllipsoid(p+vec3(-12.0, -1.0, -4.0), vec3(0.99, 0.99, 0.99));\n\tres = v4OpUnion(vec4(d, MAT_ERNST0), res);\n\n\td = sdBox(p+vec3(-12.0, -1.0, -5.0), vec3(1.0, 1.0, 1.0)-0.01)-0.01;\n\tres = v4OpSubstractionSmooth(vec4(d, MAT_ERNST0_001), res, 0.02);\n\treturn res;\n}\nvec4 sd001(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p), bsr=15.0;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\td = sdEllipsoid(p+vec3(-12.0, -1.0, -8.0), vec3(0.99, 0.99, 0.99));\n\tres = v4OpUnion(vec4(d, MAT_ERNST0_005), res);\n\n\td = sdBox(p+vec3(-12.0, -1.0, -9.0), vec3(1.0, 1.0, 1.0)-0.01)-0.01;\n\tres = v4OpIntersectionSmooth(vec4(d, MAT_ERNST0_001), res, 0.02);\n\treturn res;\n}\n\nvec4 sdScene(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\n    vec3 cp001 = p;\n\tcp001.xyz += vec3(-8.0856, -4.9245, -10.7845);\n\tpRepLimited(cp001.y, 2.5, 3.);\n\tpRepLimited(cp001.z, 1.25, 4.);\n\tpRepLimited(cp001.x, 1.25, 4.);\n\n\tres = sd001(p);\n\n\tres = v4OpUnionSmooth(sd002(p), res, 0.01);\n\n\td = sdBox(p+vec3(0.0, -1.0, -6.0), vec3(1.0, 1.0, 1.0)-0.01)-0.01;\n\td = fOpUnionSmooth(sdBox(p+vec3(3.0, -1.0, -6.0), vec3(1.0, 1.0, 1.0)-0.3)-0.3, d, 0.01);\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_003), res, 0.01);\n\n\td = sdCappedCylinder(p+vec3(0.0, -1.0, -9.0), vec2(1.0, 1.0)-0.01)-0.01;\n\td = fOpUnionSmooth(sdCappedCylinder(p+vec3(3.0, -1.0, -9.0), vec2(1.0, 1.0)-0.3)-0.3, d, 0.01);\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0), res, 0.01);\n\n\td = sdCappedTorus(p+vec3(-3.0, -0.5, -12.0), vec2(1.0, 0.5), 2.356);\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_004), res, 0.01);\n\n\td = sdCapsule(p+vec3(-3.0, -2.0, 0.0), 1., 1.);\n\td = fOpUnionSmooth(sdConeSection(p+vec3(0.0, -1.021, -3.0), 1.0-0.01, 1.02-0.01, 0.0)-0.01, d, 0.01);\n\td = fOpUnionSmooth(sdConeSection(p+vec3(3.0, -1.021, -3.0), 1.0-0.1, 1.02-0.1, 0.0)-0.1, d, 0.01);\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0), res, 0.01);\n\n\td = sdEllipsoid(p+vec3(0.0, -1.0, 0.0), vec3(1.0, 1.0, 1.0));\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_001), res, 0.01);\n\n\td = sdEllipsoid(p+vec3(-12.0, -1.0, 0.0), vec3(0.99, 0.99, 0.99));\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0), res, 0.01);\n\n\td = sdEllipsoid(p+vec3(-3.0, -1.5, -3.0), vec3(1.0, 1.5, 1.0));\n\td = fOpUnionSmooth(sdPieCylinder(p+vec3(0.0, -1.0, -12.0), 1.0-0.01, 1.0-0.01, 2.356)-0.01, d, 0.01);\n\td = fOpUnionSmooth(sdPieCylinder(p+vec3(3.0, -1.0, -12.0), 1.0-0.3, 1.0-0.3, 2.356)-0.3, d, 0.01);\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_001), res, 0.01);\n\n\td = sdPlane(p);\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_002), res, 0.01);\n\n\t{\n        // sdHex\n\t\tvec3 tp = p+vec3(-6.0, -1.1, 0.0);\n\t\tvec3 trp = rot(p+vec3(-6.0, -1.1, 0.0), vec3(1.5708, 0.0, 0.0));\n\t\tvec3 dim = vec3(0.75, 0.75, 1.0);\n\t\tfloat td = MAX_DIST;\n        \n\t\tconst vec3 k = vec3(-0.866254, 0.5, 0.57735);\n\t\tvec2 h = dim.xz;\n\t\ttrp = abs(trp);\n\t\ttrp.xy -= 2.0*min(dot(k.xy, trp.xy), 0.0)*k.xy;\n\t\tvec2 d2 = vec2(\n\t\t\t length(trp.xy-vec2(clamp(trp.x,-k.z*h.x,k.z*h.x), h.x))*sign(trp.y-h.x),\n\t\t\t trp.z-h.y );\n\t\ttd = min(max(d2.x,d2.y),0.0) + length(max(d2,0.0))-.01;\n\t\td=td;\n\t}\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_005), res, 0.01);\n\n\t{\n        // sdFakeCapsule\n\t\tvec3 tp = cp001;\n\t\tvec3 trp = cp001;\n\t\tvec3 dim = vec3(0.6342, 1.0, 0.6342);\n\t\tfloat td = MAX_DIST;\n\t\t\n\t\tfloat r = max(dim.x, dim.z);\n\t\tfloat c = dim.y*.5;\n\t\tfloat elg = c-min(.5,c);\n\t\ttrp.y -= clamp(trp.y,-elg,elg); // Elongation: https://www.shadertoy.com/view/Ml3fWj\n\t\t\n\t\tfloat a = .5*trp.y*trp.y+.5;\n\t\tfloat b = abs(trp.y);\n\t\ttrp.y = b<1. ? a : b; // Smooth abs\n\t\t\n\t\ttrp.y -= min(.5,c); // Offset\n\t\ttd = length(trp)-r;\n\t\td=td;\n\t}\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_006), res, 0.01);\n\n\td = sdRoundCone(p+vec3(-3.0, -2., -6.0), 2., 1., 0.0);\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0), res, 0.01);\n\n\td = sdTorus(p+vec3(-3.0, -0.5, -9.0), vec2(1.0, 0.5));\n\td = fOpUnionSmooth(sdBox(p+vec3(-12.0, -1.0, -1.0), vec3(1.0, 1.0, 1.0)-0.01)-0.01, d, 0.01);\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_001), res, 0.01);\n\n\treturn res;\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec4 intersect(){\n\tfloat d = 1.;\n\tvec3  m = MAT_VOID;\n\tfor (int i = ZERO; i < ITERATION+ZERO; i++){\n\t\tvec4 res = sdScene(ray.origin + d * ray.direction);\n\t\tm = res.yzw;\n\t\tres.x *= .5;\n\t\tif (abs(res.x) < MIN_DIST || res.x >= MAX_DIST) break;\n\t\td += res.x;\n\t\tif (d >= MAX_DIST) break;\n\t}\n\treturn vec4(d,m);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 normal(vec3 p)\n{\n    // Copy from iq shader.\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4+ZERO; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(p+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat shadow(vec3 o, vec3 n){\n\tfloat mint=lit0.shadowStart;\n\tfloat maxt=lit0.shadowEnd;\n\tfloat k = lit0.shadowSoft;\n\tfloat res = 1.;\n\tfloat t=mint;\n\tfloat ph = 1e10; // big, such that y = 0 on the first iteration\n\tfor( int i=ZERO; i < ITERATION+ZERO; i++){\n\t\tfloat h = sdScene(o + lit0.direction*t).x;\n#if 1\n\t\tres = min( res, k*h/t);\n#else\n\t\tfloat y = h*h/(2.0*ph);\n\t\tfloat d = sqrt(h*h-y*y);\n\t\tres = min( res, k*d/max(0.0,t-y) );\n\t\tph = h;\n#endif\n\t\tt += h;\n\t\tif( res<0.0001 || t>maxt ) break;\n\t}\n\treturn sat(res);\n}\n\n// \"Hemispherical SDF AO\" by XT95:\n// https://www.shadertoy.com/view/4sdGWN\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 randomSphereDir(vec2 rnd){\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i){\n\tvec3 v = randomSphereDir( vec2(hash11(i+1.), hash11(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff ){\n\tconst int nbIte = 12;\n\tconst float nbIteInv = 1./float(nbIte);\n\tconst float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n\n\tfloat ao = 0.0;\n\n\tfor( int i=ZERO; i<nbIte+ZERO; i++ ){\n\t\tfloat l = hash11(float(i)+maxDist*falloff)*maxDist;\n\t\tvec3 aord = normalize(n+randomHemisphereDir(n, l+maxDist+falloff )*rad)*l; // mix direction with the normal// for self occlusion problems!\n\t\tao += (l - max(sdScene( p + aord ).x,0.)) / maxDist * falloff;\n\t}\n\n\treturn clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n// \"Physically-based SDF\" by romainguy:\n//https://www.shadertoy.com/view/XlKSDR\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat pow5(float x) {\n\tfloat x2 = x * x;\n\treturn x2 * x2 * x;\n}\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n\tfloat oneMinusNoHSquared = 1.0 - NoH * NoH;\n\tfloat a = NoH * linearRoughness;\n\tfloat k = linearRoughness / (oneMinusNoHSquared + a * a);\n\tfloat d = k * k * (1.0 / PI);\n\treturn d;\n}\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\nvec3 F_Schlick(const vec3 f0, float VoH) {\n\treturn f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n#define specular(lr, noV, noL) D_GGX(lr, noV, noL)\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid render(){\n\tvec4 res = intersect();\n\tvec3 p = ray.origin + res.x * ray.direction;\n\n\tif (res.x>=MAX_DIST){\n\t\trenDat.position = vec3(0);\n\t\trenDat.albedo = FOG_COL;\n\t\trenDat.normal = vec3(0);\n\t\trenDat.diffuse = 0.;\n\t\trenDat.specular = 0.;\n\t\trenDat.shadow = 0.;\n\t\trenDat.ao = 0.;\n\t\trenDat.depth = 1.;\n\t\trenDat.result = FOG_COL;\n\t}\n\telse{\n\t\trenDat.position = p;\n\t\trenDat.albedo = res.yzw;\n\t\trenDat.normal = normal(p);\n\n        // I wanted to know taste of physically based lighting,\n        // so I copied from romainguy's shader.\n        // https://www.shadertoy.com/view/XlKSDR\n\t\tvec3 h = normalize(-ray.direction + lit0.direction);\n\t\tfloat NoV = abs(dot(renDat.normal, -ray.direction)) + 1e-5;\n\t\tfloat NoL = sat(dot(renDat.normal, lit0.direction));\n\t\tfloat NoH = sat(dot(renDat.normal, h));\n\t\tfloat LoH = sat(dot(lit0.direction, h));\n\t\tfloat roughness = .5;\n\t\tfloat metallic = .0;\n\t\tfloat intensity = .01;\n\t\t\n        if(distance(MAT_ERNST0, renDat.albedo)<.1){\n            roughness = .3;\n            intensity = .0;\n        }\n        if(distance(MAT_ERNST0_002, renDat.albedo)<.1){\n            roughness = .3;\n            intensity = .0;\n            const float CSIZE = .5;\n            renDat.albedo += .05*max(step(.5, fract(p.x*CSIZE)), step(.5, fract(p.z*CSIZE)))*max(step(.5, fract(p.x*CSIZE+.5)), step(.5, fract(p.z*CSIZE+.5)));\n        }\n        if(distance(MAT_ERNST0_003, renDat.albedo)<.1){\n            roughness = .3;\n            intensity = .1;\n        }\n        if(distance(MAT_ERNST0_001, renDat.albedo)<.1){\n            roughness = .2;\n            intensity = .05;\n        }\n        float linearRoughness = roughness * roughness;\n        \n\t\tfloat lamb1 = sat(dot(renDat.normal, lit0.direction))*(1./PI);\n\t\tfloat lamb2 = sat(dot(renDat.normal, lit1.direction))*(1./PI);\n\n\t\trenDat.shadow = shadow(p+renDat.normal*.0001, renDat.normal);\n\n\t\trenDat.ao = ambientOcclusion(p, renDat.normal, .1, .5);\n\t\trenDat.ao += ambientOcclusion(p, renDat.normal, .5, .5);\n\t\trenDat.ao += ambientOcclusion(p, renDat.normal, 2., 2.);\n\t\trenDat.ao += ambientOcclusion(p, renDat.normal, 4., 2.);\n\t\trenDat.ao = smoothstep(0., 4., renDat.ao);\n\n\t\trenDat.diffuse = lamb1;//Fd_Burley(linearRoughness, NoV, NoL, LoH);\n\t\trenDat.diffuse *= renDat.shadow;\n\t\trenDat.result = mix(vec3(0), lit0.color, renDat.diffuse);\n\n\t\trenDat.diffuse += lamb2*renDat.ao;\n\t\trenDat.result += mix(vec3(0), lit1.color, lamb2*renDat.ao);\n\n\t\trenDat.diffuse += renDat.ao*AMB_STRENGTH;\n\t\trenDat.result += mix(vec3(0), AMB_COL, renDat.ao*AMB_STRENGTH);\n\t\trenDat.result*= renDat.albedo;\n\n\t\tvec3 f0 = .5*(1. - metallic) + renDat.albedo * metallic;\n\t\tvec3  F = F_Schlick(f0, LoH);\n\t\tfloat V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n\t\trenDat.specular = specular(linearRoughness, NoH, h)*intensity;\n\t\trenDat.result = mix(renDat.result, renDat.result+lit0.color, renDat.specular*renDat.shadow*1.)*F;\n\n\t\trenDat.depth = distance(ray.origin, p)/MAX_DIST;\n\t\trenDat.result = mix(renDat.result, FOG_COL, sat(pow(renDat.depth+FOG_START, FOG_POW)));\n\t}\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 offset = u2s(hash22(fragCoord+iTime))/iResolution.xy*.5; // AA: Offset coord for each frame.\n    uv += offset; //\n    \n\tuv = (uv*2.-1.)*iResolution.y/iResolution.x;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tinit();\n\tcamera(uv);\n\trender();\n\n\tfragColor = vec4(renDat.result, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// AA: Mix a new color with the average color.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 new = texture(iChannel0, uv);\n    \n    if(iFrame==0){\n        fragColor = new;\n        return;\n    }\n    \n    vec4 ave = texture(iChannel1, uv);\n    fragColor = mix(new, ave, .99);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}