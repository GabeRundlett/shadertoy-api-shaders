{
    "Shader": {
        "info": {
            "date": "1675325165",
            "description": "Overlapped version - examine 4 regions around pixel point. <mouse-y> sets disc radius \n\n[url]https://twitter.com/matthen2/status/1604117218027077634[/url]\n[url]https://golem.ph.utexas.edu/category/2014/04/the_modular_flow_on_the_space.html[/url]",
            "flags": 16,
            "hasliked": 0,
            "id": "clXXDB",
            "likes": 3,
            "name": "Modular Flow Overlap",
            "published": 3,
            "tags": [
                "flow",
                "modular",
                "eigenvector",
                "eigenvalue"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 109
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////\n//\n// Modular Flow Overlap,mla, 2023\n//\n// Now with overlapping discs - mouse-y sets disc radius\n//\n// Apply a stretch and squeeze transform (x,y)-> (kx,y/k) to a lattice, \n// add just the right skew, and you get a nice looping flow pattern.\n// \n// Inspiration:\n// https://twitter.com/matthen2/status/1604117218027077634\n// https://twitter.com/etiennejcb/status/1604946331411292166 (@Bleuje)\n//\n// For the maths:\n// https://golem.ph.utexas.edu/category/2014/04/the_modular_flow_on_the_space.html\n//\n// mouse-x: zoom\n// mouse-y: disc radius\n// r: image rotation\n// x: show disc rotation\n//\n////////////////////////////////////////////////////////////////////////\n\n// Find a canonical representative under the group action - generally\n// the length of the vector decreases to a minimum, then increases\n// again, so just iterate both ways to find the smallest (breaking ties\n// the same way if two vectors are minimal).\nvec2 reduce(vec2 p, mat2 A, mat2 Ainv) {\n  if (p == vec2(0)) return p;\n  while (true) {\n    vec2 p1 = A*p;\n    if (dot(p1,p1) >= dot(p,p)) break;\n    p = p1;\n  }\n  while (true) {\n    vec2 p1 = Ainv*p;\n    if (dot(p1,p1) > dot(p,p)) break;\n    p = p1;\n  }\n  return p;\n}\n\nvec3 getcol(vec2 ix) {\n  //if (ix == vec2(0)) return vec3(1); // Show centre point\n  uint h = uint(int(ix.x)*12345^int(ix.y));\n  h = ihash(h);\n  return 0.2+0.6*h2rgb(float(h)/exp2(32.0));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    // A can be any suitable element of the modular group. This\n    // one has nice eigenvectors. Since determinant is 1, the\n    // eigenvalues are real and distinct if Tr(A) > 2, and the\n    // product of the eigenvalues is 1. If this is the case,\n    // we have an eigendecomposition A = P'XP where P is the\n    // matrix of eigenvectors and X is the diagonal matrix\n    // of the eigenvalues k,1/k.\n    mat2 A = mat2(2,1,1,1); // Must have Tr(A) > 2 and det(A) = 1\n    //A = mat2(0,-1,1,3);\n    float a = A[0][0], b = A[1][0], c = A[0][1], d = A[1][1];\n    assert(a+d > 2.0);\n    assert(a*d - b*c == 1.0);\n    float trace = a+d;\n    float disc = trace*trace-4.0;\n    float l0 = 0.5*(trace-sqrt(disc));\n    float l1 = 0.5*(trace+sqrt(disc)); // l1 = 2.618\n    vec2 e0 = normalize(vec2(-b,a-l0));\n    vec2 e1 = normalize(vec2(-b,a-l1));\n    mat2 P = mat2(e0,e1); // Eigenvector matrix\n    //P = mat2(-1, 1.618034,-1,-0.618034); // For A = (2,1,1,1) (unnormalized)\n    mat2 Ainv = inverse(A);\n    mat2 Pinv = inverse(P);\n    float cycle = log(l1); // Largest eigenvalue\n\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    if (!key(CHAR_R)) {\n      p += 0.25; p = rotate(p,0.1*iTime); p -= 0.25;\n    }\n    p *= 10.0;\n    if (iMouse.x > 10.0) p *= exp2(3.0*iMouse.x/iResolution.x-1.0);\n    float px = fwidth(p.x);\n    float k = exp(cycle*fract(0.25*iTime)-0.5); // Time loop (repeat every 4 seconds)\n    p *= vec2(k,1.0/k); p = P*p; // Map to skewed space\n    vec2 ix = round(p); p -= ix; // Base cell index and coordinates\n    vec3 col = vec3(1,1,0.75);\n    float radius = 0.8;\n    if (iMouse.y > 10.0) radius = iMouse.y/iResolution.y;\n    int t[] = int[](-1,-1,\n                     -1,0, 0,-1, \n                     -1,1, 0,0, 1,-1, \n                     0,1, 1,0,\n                     1,1); \n    for (int ii = 0; ii < 18; ii += 2) {\n         int i = t[ii], j = t[ii+1];\n         vec2 ix1 = ix + vec2(i,j);\n         vec2 p1 = p - vec2(i,j);\n         p1 = Pinv*p1; p1 *= vec2(1.0/k,k); // Map back to unskewed to draw discs\n         ix1 = reduce(ix1,A,Ainv);\n         vec3 disccol = getcol(ix1);\n         float linewidth = 0.01;\n         vec2 radial = rotate(vec2(1,0),0.25*ix1.x*iTime);\n         if (key(CHAR_X)) disccol *= smoothstep(0.0,px,segment(p1,-radial,radial)-linewidth); \n         col = mix(disccol,col,vec3(smoothstep(0.0,px,length(p1)-radius)));\n         col *= smoothstep(0.0,px,abs(length(p1)-radius)-linewidth);\n    }   \n    col = pow(col,vec3(0.4545));\n    if (alert) col.r = 1.0;\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "bool alert = false;\nint assert(bool b) {\n if (!b) alert = true;\n return 0;\n}\n\nconst float PI = 3.141592654;\nconst float TWOPI = 2.0*PI;\n#define sin(x) sin(mod((x),TWOPI))\n#define cos(x) cos(mod((x),TWOPI))\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\n// const int KEY_SHIFT = 16;\n// const int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\n// const int KEY_UP = 38;\n// const int KEY_DOWN = 40;\n\n// const int CHAR_0 = 48;\n\n// const int CHAR_A = 65;\n// const int CHAR_B = 66;\n// const int CHAR_C = 67;\n// const int CHAR_D = 68;\n// const int CHAR_E = 69;\n// const int CHAR_F = 70;\n// const int CHAR_G = 71;\n// const int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\n// const int CHAR_K = 75;\n// const int CHAR_L = 76;\n// const int CHAR_M = 77;\n// const int CHAR_N = 78;\n// const int CHAR_O = 79;\n// const int CHAR_P = 80;\n// const int CHAR_Q = 81;\nconst int CHAR_R = 82;\n// const int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\n// const int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}